begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction scheduling pass.  This file computes dependencies between    instructions.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,    and currently maintained by, Jim Wilson (wilson@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"cselib.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|reg_known_equiv_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|rtx
modifier|*
name|reg_known_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regset_head
name|reg_pending_sets_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regset_head
name|reg_pending_clobbers_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regset_head
name|reg_pending_uses_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regset
name|reg_pending_sets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regset
name|reg_pending_clobbers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regset
name|reg_pending_uses
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|reg_pending_barrier
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* To speed up the test for duplicate dependency links we keep a    record of dependencies created by add_dependence when the average    number of instructions in a basic block is very large.     Studies have shown that there is typically around 5 instructions between    branches for typical C code.  So we can make a guess that the average    basic block is approximately 5 instructions long; we will choose 100X    the average size as a very large basic block.     Each insn has associated bitmaps for its dependencies.  Each bitmap    has enough entries to represent a dependency on any other insn in    the insn chain.  All bitmap for true dependencies cache is    allocated then the rest two ones are also allocated.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|true_dependency_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|anti_dependency_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|output_dependency_cache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* To speed up checking consistency of formed forward insn    dependencies we use the following cache.  Another possible solution    could be switching off checking duplication of insns in forward    dependencies.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|forward_dependency_cache
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|deps_may_trap_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_dependence_list
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|reg_note
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_dependence_list_and_free
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|,
expr|enum
name|reg_note
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_dependence
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_sched_group_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|flush_pending_lists
name|PARAMS
argument_list|(
operator|(
expr|struct
name|deps
operator|*
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sched_analyze_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|deps
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sched_analyze_2
name|PARAMS
argument_list|(
operator|(
expr|struct
name|deps
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sched_analyze_insn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|deps
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|group_leader
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|get_condition
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|conditions_mutex_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if a load of the memory reference MEM can cause a trap.  */
end_comment

begin_function
specifier|static
name|int
name|deps_may_trap_p
parameter_list|(
name|mem
parameter_list|)
name|rtx
name|mem
decl_stmt|;
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|addr
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_known_value
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
condition|)
name|addr
operator|=
name|reg_known_value
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
expr_stmt|;
return|return
name|rtx_addr_can_trap_p
argument_list|(
name|addr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the INSN_LIST containing INSN in LIST, or NULL    if LIST does not contain INSN.  */
end_comment

begin_function
name|rtx
name|find_insn_list
parameter_list|(
name|insn
parameter_list|,
name|list
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|list
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
operator|==
name|insn
condition|)
return|return
name|list
return|;
name|list
operator|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the condition under which INSN is executed.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_condition
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|cond
decl_stmt|;
if|if
condition|(
name|pat
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|COND_EXEC
condition|)
return|return
name|COND_EXEC_TEST
argument_list|(
name|pat
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|!=
name|pc_rtx
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|IF_THEN_ELSE
condition|)
return|return
literal|0
return|;
name|pat
operator|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|cond
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|2
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return
name|cond
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if conditions COND1 and COND2 can never be both true.  */
end_comment

begin_function
specifier|static
name|int
name|conditions_mutex_p
parameter_list|(
name|cond1
parameter_list|,
name|cond2
parameter_list|)
name|rtx
name|cond1
decl_stmt|,
name|cond2
decl_stmt|;
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|cond1
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|cond2
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|GET_CODE
argument_list|(
name|cond1
argument_list|)
operator|==
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|cond2
argument_list|)
argument_list|)
operator|&&
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|cond2
argument_list|,
literal|0
argument_list|)
operator|&&
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|1
argument_list|)
operator|==
name|XEXP
argument_list|(
name|cond2
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add ELEM wrapped in an INSN_LIST with reg note kind DEP_TYPE to the    LOG_LINKS of INSN, if not already there.  DEP_TYPE indicates the type    of dependence that this link represents.  */
end_comment

begin_function
name|void
name|add_dependence
parameter_list|(
name|insn
parameter_list|,
name|elem
parameter_list|,
name|dep_type
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|elem
decl_stmt|;
name|enum
name|reg_note
name|dep_type
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|,
name|next
decl_stmt|;
name|int
name|present_p
decl_stmt|;
name|rtx
name|cond1
decl_stmt|,
name|cond2
decl_stmt|;
comment|/* Don't depend an insn on itself.  */
if|if
condition|(
name|insn
operator|==
name|elem
condition|)
return|return;
comment|/* We can get a dependency on deleted insns due to optimizations in      the register allocation and reloading or due to splitting.  Any      such dependency is useless and can be ignored.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|elem
argument_list|)
operator|==
name|NOTE
condition|)
return|return;
comment|/* flow.c doesn't handle conditional lifetimes entirely correctly;      calls mess up the conditional lifetimes.  */
comment|/* ??? add_dependence is the wrong place to be eliding dependencies,      as that forgets that the condition expressions themselves may      be dependent.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|elem
argument_list|)
operator|!=
name|CALL_INSN
condition|)
block|{
name|cond1
operator|=
name|get_condition
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|cond2
operator|=
name|get_condition
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond1
operator|&&
name|cond2
operator|&&
name|conditions_mutex_p
argument_list|(
name|cond1
argument_list|,
name|cond2
argument_list|)
comment|/* Make sure first instruction doesn't affect condition of second 	     instruction if switched.  */
operator|&&
operator|!
name|modified_in_p
argument_list|(
name|cond1
argument_list|,
name|elem
argument_list|)
comment|/* Make sure second instruction doesn't affect condition of first 	     instruction if switched.  */
operator|&&
operator|!
name|modified_in_p
argument_list|(
name|cond2
argument_list|,
name|insn
argument_list|)
condition|)
return|return;
block|}
comment|/* If elem is part of a sequence that must be scheduled together, then      make the dependence point to the last insn of the sequence.      When HAVE_cc0, it is possible for NOTEs to exist between users and      setters of the condition codes, so we must skip past notes here.      Otherwise, NOTEs are impossible here.  */
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|&&
name|SCHED_GROUP_P
argument_list|(
name|next
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
comment|/* Notes will never intervene here though, so don't bother checking          for them.  */
comment|/* Hah!  Wrong.  */
comment|/* We must reject CODE_LABELs, so that we don't get confused by one          that has LABEL_PRESERVE_P set, which is represented by the same          bit in the rtl as SCHED_GROUP_P.  A CODE_LABEL can never be          SCHED_GROUP_P.  */
name|rtx
name|nnext
decl_stmt|;
while|while
condition|(
operator|(
name|nnext
operator|=
name|next_nonnote_insn
argument_list|(
name|next
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|SCHED_GROUP_P
argument_list|(
name|nnext
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|nnext
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|next
operator|=
name|nnext
expr_stmt|;
comment|/* Again, don't depend an insn on itself.  */
if|if
condition|(
name|insn
operator|==
name|next
condition|)
return|return;
comment|/* Make the dependence to NEXT, the last insn of the group, instead          of the original ELEM.  */
name|elem
operator|=
name|next
expr_stmt|;
block|}
name|present_p
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
comment|/* ??? No good way to tell from here whether we're doing interblock      scheduling.  Possibly add another callback.  */
if|#
directive|if
literal|0
comment|/* (This code is guarded by INSN_SCHEDULING, otherwise INSN_BB is undefined.)      No need for interblock dependences with calls, since      calls are not moved between blocks.   Note: the edge where      elem is a CALL is still required.  */
block|if (GET_CODE (insn) == CALL_INSN&& (INSN_BB (elem) != INSN_BB (insn)))     return;
endif|#
directive|endif
comment|/* If we already have a dependency for ELEM, then we do not need to      do anything.  Avoiding the list walk below can cut compile times      dramatically for some code.  */
if|if
condition|(
name|true_dependency_cache
operator|!=
name|NULL
condition|)
block|{
name|enum
name|reg_note
name|present_dep_type
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|anti_dependency_cache
operator|==
name|NULL
operator|||
name|output_dependency_cache
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|true_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
condition|)
comment|/* Do nothing (present_set_type is already 0).  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TEST_BIT
argument_list|(
name|anti_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
condition|)
name|present_dep_type
operator|=
name|REG_DEP_ANTI
expr_stmt|;
elseif|else
if|if
condition|(
name|TEST_BIT
argument_list|(
name|output_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
condition|)
name|present_dep_type
operator|=
name|REG_DEP_OUTPUT
expr_stmt|;
else|else
name|present_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|present_p
operator|&&
operator|(
name|int
operator|)
name|dep_type
operator|>=
operator|(
name|int
operator|)
name|present_dep_type
condition|)
return|return;
block|}
endif|#
directive|endif
comment|/* Check that we don't already have this dependence.  */
if|if
condition|(
name|present_p
condition|)
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|elem
condition|)
block|{
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
comment|/* Clear corresponding cache entry because type of the link              may be changed.  */
if|if
condition|(
name|true_dependency_cache
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_ANTI
condition|)
name|RESET_BIT
argument_list|(
name|anti_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_OUTPUT
operator|&&
name|output_dependency_cache
condition|)
name|RESET_BIT
argument_list|(
name|output_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If this is a more restrictive type of dependence than the existing 	     one, then change the existing dependence to this type.  */
if|if
condition|(
operator|(
name|int
operator|)
name|dep_type
operator|<
operator|(
name|int
operator|)
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
condition|)
name|PUT_REG_NOTE_KIND
argument_list|(
name|link
argument_list|,
name|dep_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
comment|/* If we are adding a dependency to INSN's LOG_LINKs, then 	     note that in the bitmap caches of dependency information.  */
if|if
condition|(
name|true_dependency_cache
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
name|SET_BIT
argument_list|(
name|true_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_ANTI
condition|)
name|SET_BIT
argument_list|(
name|anti_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_OUTPUT
condition|)
name|SET_BIT
argument_list|(
name|output_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
block|}
comment|/* Might want to check one level of transitivity to save conses.  */
name|link
operator|=
name|alloc_INSN_LIST
argument_list|(
name|elem
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|link
expr_stmt|;
comment|/* Insn dependency, not data dependency.  */
name|PUT_REG_NOTE_KIND
argument_list|(
name|link
argument_list|,
name|dep_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
comment|/* If we are adding a dependency to INSN's LOG_LINKs, then note that      in the bitmap caches of dependency information.  */
if|if
condition|(
name|true_dependency_cache
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|dep_type
operator|==
literal|0
condition|)
name|SET_BIT
argument_list|(
name|true_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dep_type
operator|==
name|REG_DEP_ANTI
condition|)
name|SET_BIT
argument_list|(
name|anti_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dep_type
operator|==
name|REG_DEP_OUTPUT
condition|)
name|SET_BIT
argument_list|(
name|output_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* A convenience wrapper to operate on an entire list.  */
end_comment

begin_function
specifier|static
name|void
name|add_dependence_list
parameter_list|(
name|insn
parameter_list|,
name|list
parameter_list|,
name|dep_type
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|list
decl_stmt|;
name|enum
name|reg_note
name|dep_type
decl_stmt|;
block|{
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dep_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar, but free *LISTP at the same time.  */
end_comment

begin_function
specifier|static
name|void
name|add_dependence_list_and_free
parameter_list|(
name|insn
parameter_list|,
name|listp
parameter_list|,
name|dep_type
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|listp
decl_stmt|;
name|enum
name|reg_note
name|dep_type
decl_stmt|;
block|{
name|rtx
name|list
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|list
operator|=
operator|*
name|listp
operator|,
operator|*
name|listp
operator|=
name|NULL
init|;
name|list
condition|;
name|list
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dep_type
argument_list|)
expr_stmt|;
name|free_INSN_LIST_node
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remove ELEM wrapped in an INSN_LIST from the LOG_LINKS    of INSN.  Abort if not found.  */
end_comment

begin_function
specifier|static
name|void
name|remove_dependence
parameter_list|(
name|insn
parameter_list|,
name|elem
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|elem
decl_stmt|;
block|{
name|rtx
name|prev
decl_stmt|,
name|link
decl_stmt|,
name|next
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|elem
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
operator|=
name|next
expr_stmt|;
else|else
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
comment|/* If we are removing a dependency from the LOG_LINKS list, 	     make sure to remove it from the cache too.  */
if|if
condition|(
name|true_dependency_cache
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
name|RESET_BIT
argument_list|(
name|true_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_ANTI
condition|)
name|RESET_BIT
argument_list|(
name|anti_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_OUTPUT
condition|)
name|RESET_BIT
argument_list|(
name|output_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|free_INSN_LIST_node
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|link
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Return an insn which represents a SCHED_GROUP, which is    the last insn in the group.  */
end_comment

begin_function
specifier|static
name|rtx
name|group_leader
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|prev
decl_stmt|;
do|do
block|{
name|prev
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|insn
operator|&&
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
operator|)
condition|)
do|;
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Set SCHED_GROUP_P and care for the rest of the bookkeeping that    goes along with that.  */
end_comment

begin_function
specifier|static
name|void
name|set_sched_group_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|,
name|prev
decl_stmt|;
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* There may be a note before this insn now, but all notes will      be removed before we actually try to schedule the insns, so      it won't cause a problem later.  We must avoid it here though.  */
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Make a copy of all dependencies on the immediately previous insn,      and add to this insn.  This is so that all the dependencies will      apply to the group.  Remove an explicit dependence on this insn      as SCHED_GROUP_P now represents it.  */
if|if
condition|(
name|find_insn_list
argument_list|(
name|prev
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|remove_dependence
argument_list|(
name|insn
argument_list|,
name|prev
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|prev
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process an insn's memory dependencies.  There are four kinds of    dependencies:     (0) read dependence: read follows read    (1) true dependence: read follows write    (2) anti dependence: write follows read    (3) output dependence: write follows write     We are careful to build only dependencies which actually exist, and    use transitivity to avoid building too many links.  */
end_comment

begin_comment
comment|/* Add an INSN and MEM reference pair to a pending INSN_LIST and MEM_LIST.    The MEM is a memory reference contained within INSN, which we are saving    so that we can do memory aliasing on it.  */
end_comment

begin_function
name|void
name|add_insn_mem_dependence
parameter_list|(
name|deps
parameter_list|,
name|insn_list
parameter_list|,
name|mem_list
parameter_list|,
name|insn
parameter_list|,
name|mem
parameter_list|)
name|struct
name|deps
modifier|*
name|deps
decl_stmt|;
name|rtx
modifier|*
name|insn_list
decl_stmt|,
decl|*
name|mem_list
decl_stmt|,
name|insn
decl_stmt|,
name|mem
decl_stmt|;
end_function

begin_block
block|{
name|rtx
name|link
decl_stmt|;
name|link
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
operator|*
name|insn_list
argument_list|)
expr_stmt|;
operator|*
name|insn_list
operator|=
name|link
expr_stmt|;
if|if
condition|(
name|current_sched_info
operator|->
name|use_cselib
condition|)
block|{
name|mem
operator|=
name|shallow_copy_rtx
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
operator|=
name|cselib_subst_to_values
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|link
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
operator|*
name|mem_list
argument_list|)
expr_stmt|;
operator|*
name|mem_list
operator|=
name|link
expr_stmt|;
name|deps
operator|->
name|pending_lists_length
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Make a dependency between every memory reference on the pending lists    and INSN, thus flushing the pending lists.  FOR_READ is true if emitting    dependencies for a read operation, similarly with FOR_WRITE.  */
end_comment

begin_function
specifier|static
name|void
name|flush_pending_lists
parameter_list|(
name|deps
parameter_list|,
name|insn
parameter_list|,
name|for_read
parameter_list|,
name|for_write
parameter_list|)
name|struct
name|deps
modifier|*
name|deps
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|for_read
decl_stmt|,
name|for_write
decl_stmt|;
block|{
if|if
condition|(
name|for_write
condition|)
block|{
name|add_dependence_list_and_free
argument_list|(
name|insn
argument_list|,
operator|&
name|deps
operator|->
name|pending_read_insns
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|free_EXPR_LIST_list
argument_list|(
operator|&
name|deps
operator|->
name|pending_read_mems
argument_list|)
expr_stmt|;
block|}
name|add_dependence_list_and_free
argument_list|(
name|insn
argument_list|,
operator|&
name|deps
operator|->
name|pending_write_insns
argument_list|,
name|for_read
condition|?
name|REG_DEP_ANTI
else|:
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|free_EXPR_LIST_list
argument_list|(
operator|&
name|deps
operator|->
name|pending_write_mems
argument_list|)
expr_stmt|;
name|deps
operator|->
name|pending_lists_length
operator|=
literal|0
expr_stmt|;
name|add_dependence_list_and_free
argument_list|(
name|insn
argument_list|,
operator|&
name|deps
operator|->
name|last_pending_memory_flush
argument_list|,
name|for_read
condition|?
name|REG_DEP_ANTI
else|:
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|deps
operator|->
name|last_pending_memory_flush
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|deps
operator|->
name|pending_flush_length
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Analyze a single SET, CLOBBER, PRE_DEC, POST_DEC, PRE_INC or POST_INC    rtx, X, creating all dependencies generated by the write to the    destination of X, and reads of everything mentioned.  */
end_comment

begin_function
specifier|static
name|void
name|sched_analyze_1
parameter_list|(
name|deps
parameter_list|,
name|x
parameter_list|,
name|insn
parameter_list|)
name|struct
name|deps
modifier|*
name|deps
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
name|rtx
name|dest
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|sched_analyze_1
argument_list|(
name|deps
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
block|{
comment|/* The second and third arguments are values read by this insn.  */
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|2
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* A hard reg in a wide mode may really be multiple registers.          If so, mark all of them just like the first.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|i
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|,
name|regno
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_clobbers
argument_list|,
name|regno
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ??? Reload sometimes emits USEs and CLOBBERs of pseudos that 	 it does not reload.  Ignore these as they have served their 	 purpose already.  */
elseif|else
if|if
condition|(
name|regno
operator|>=
name|deps
operator|->
name|max_reg
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|code
operator|==
name|SET
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|,
name|regno
argument_list|)
expr_stmt|;
else|else
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_clobbers
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Pseudos that are REG_EQUIV to something may be replaced 	     by that during reloading.  We need only add dependencies for 	     the address in the REG_EQUIV note.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|reg_known_equiv_p
index|[
name|regno
index|]
operator|&&
name|GET_CODE
argument_list|(
name|reg_known_value
index|[
name|regno
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|reg_known_value
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Don't let it cross a call after scheduling if it doesn't 	     already cross one.  */
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|regno
argument_list|)
operator|==
literal|0
condition|)
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|deps
operator|->
name|last_function_call
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Writing memory.  */
name|rtx
name|t
init|=
name|dest
decl_stmt|;
if|if
condition|(
name|current_sched_info
operator|->
name|use_cselib
condition|)
block|{
name|t
operator|=
name|shallow_copy_rtx
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|cselib_lookup
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|cselib_subst_to_values
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deps
operator|->
name|pending_lists_length
operator|>
name|MAX_PENDING_LIST_LENGTH
condition|)
block|{
comment|/* Flush all pending reads and writes to prevent the pending lists 	     from getting any larger.  Insn scheduling runs too slowly when 	     these lists get long.  When compiling GCC with itself, 	     this flush occurs 8 times for sparc, and 10 times for m88k using 	     the default value of 32.  */
name|flush_pending_lists
argument_list|(
name|deps
argument_list|,
name|insn
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|pending
decl_stmt|,
name|pending_mem
decl_stmt|;
name|pending
operator|=
name|deps
operator|->
name|pending_read_insns
expr_stmt|;
name|pending_mem
operator|=
name|deps
operator|->
name|pending_read_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
if|if
condition|(
name|anti_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|t
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|pending
operator|=
name|deps
operator|->
name|pending_write_insns
expr_stmt|;
name|pending_mem
operator|=
name|deps
operator|->
name|pending_write_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
if|if
condition|(
name|output_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|t
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|deps
operator|->
name|last_pending_memory_flush
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|add_insn_mem_dependence
argument_list|(
name|deps
argument_list|,
operator|&
name|deps
operator|->
name|pending_write_insns
argument_list|,
operator|&
name|deps
operator|->
name|pending_write_mems
argument_list|,
name|insn
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Analyze reads.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Analyze the uses of memory and registers in rtx X in INSN.  */
end_comment

begin_function
specifier|static
name|void
name|sched_analyze_2
parameter_list|(
name|deps
parameter_list|,
name|x
parameter_list|,
name|insn
parameter_list|)
name|struct
name|deps
modifier|*
name|deps
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
comment|/* Ignore constants.  Note that we must handle CONST_DOUBLE here          because it may have a cc0_rtx in its CONST_DOUBLE_CHAIN field, but          this does not mean that this insn is using cc0.  */
return|return;
ifdef|#
directive|ifdef
name|HAVE_cc0
case|case
name|CC0
case|:
comment|/* User of CC0 depends on immediately preceding insn.  */
name|set_sched_group_p
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
name|REG
case|:
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|i
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_uses
argument_list|,
name|regno
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* ??? Reload sometimes emits USEs and CLOBBERs of pseudos that 	   it does not reload.  Ignore these as they have served their 	   purpose already.  */
elseif|else
if|if
condition|(
name|regno
operator|>=
name|deps
operator|->
name|max_reg
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_uses
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Pseudos that are REG_EQUIV to something may be replaced 	       by that during reloading.  We need only add dependencies for 	       the address in the REG_EQUIV note.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|reg_known_equiv_p
index|[
name|regno
index|]
operator|&&
name|GET_CODE
argument_list|(
name|reg_known_value
index|[
name|regno
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|reg_known_value
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* If the register does not already cross any calls, then add this 	       insn to the sched_before_next_call list so that it will still 	       not cross calls after scheduling.  */
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|regno
argument_list|)
operator|==
literal|0
condition|)
name|deps
operator|->
name|sched_before_next_call
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|deps
operator|->
name|sched_before_next_call
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
name|MEM
case|:
block|{
comment|/* Reading memory.  */
name|rtx
name|u
decl_stmt|;
name|rtx
name|pending
decl_stmt|,
name|pending_mem
decl_stmt|;
name|rtx
name|t
init|=
name|x
decl_stmt|;
if|if
condition|(
name|current_sched_info
operator|->
name|use_cselib
condition|)
block|{
name|t
operator|=
name|shallow_copy_rtx
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|cselib_lookup
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|cselib_subst_to_values
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pending
operator|=
name|deps
operator|->
name|pending_read_insns
expr_stmt|;
name|pending_mem
operator|=
name|deps
operator|->
name|pending_read_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
if|if
condition|(
name|read_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|t
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|pending
operator|=
name|deps
operator|->
name|pending_write_insns
expr_stmt|;
name|pending_mem
operator|=
name|deps
operator|->
name|pending_write_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
if|if
condition|(
name|true_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|t
argument_list|,
name|rtx_varies_p
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|u
operator|=
name|deps
operator|->
name|last_pending_memory_flush
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
name|deps_may_trap_p
argument_list|(
name|x
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
comment|/* Always add these dependencies to pending_reads, since 	   this insn may be followed by a write.  */
name|add_insn_mem_dependence
argument_list|(
name|deps
argument_list|,
operator|&
name|deps
operator|->
name|pending_read_insns
argument_list|,
operator|&
name|deps
operator|->
name|pending_read_mems
argument_list|,
name|insn
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Take advantage of tail recursion here.  */
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Force pending stores to memory in case a trap handler needs them.  */
case|case
name|TRAP_IF
case|:
name|flush_pending_lists
argument_list|(
name|deps
argument_list|,
name|insn
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASM_OPERANDS
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|UNSPEC_VOLATILE
case|:
block|{
comment|/* Traditional and volatile asm instructions must be considered to use 	   and clobber all hard registers, all pseudo-registers and all of 	   memory.  So must TRAP_IF and UNSPEC_VOLATILE operations.  	   Consider for instance a volatile asm that changes the fpu rounding 	   mode.  An insn should not be moved across this even if it only uses 	   pseudo-regs because it might give an incorrectly rounded result.  */
if|if
condition|(
name|code
operator|!=
name|ASM_OPERANDS
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
name|reg_pending_barrier
operator|=
name|true
expr_stmt|;
comment|/* For all ASM_OPERANDS, we must traverse the vector of input operands. 	   We can not just fall through here since then we would be confused 	   by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate 	   traditional asms unlike their normal usage.  */
if|if
condition|(
name|code
operator|==
name|ASM_OPERANDS
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|;
name|j
operator|++
control|)
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
case|case
name|PRE_DEC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_INC
case|:
comment|/* These both read and modify the result.  We must handle them as writes          to get proper dependencies for following instructions.  We must handle          them as reads to get proper dependencies from this to previous          instructions.  Thus we need to pass them to both sched_analyze_1          and sched_analyze_2.  We must call sched_analyze_2 first in order          to get the proper antecedent for the read.  */
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|sched_analyze_1
argument_list|(
name|deps
argument_list|,
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
case|case
name|POST_MODIFY
case|:
case|case
name|PRE_MODIFY
case|:
comment|/* op0 = op0 + op1 */
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|sched_analyze_1
argument_list|(
name|deps
argument_list|,
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
comment|/* Other cases: walk the insn.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Analyze an INSN with pattern X to find all dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|sched_analyze_insn
parameter_list|(
name|deps
parameter_list|,
name|x
parameter_list|,
name|insn
parameter_list|,
name|loop_notes
parameter_list|)
name|struct
name|deps
modifier|*
name|deps
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
name|rtx
name|loop_notes
decl_stmt|;
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|COND_EXEC
condition|)
block|{
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* ??? Should be recording conditions so we reduce the number of 	 false dependencies.  */
name|x
operator|=
name|COND_EXEC_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|sched_analyze_1
argument_list|(
name|deps
argument_list|,
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|sub
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|COND_EXEC
condition|)
block|{
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|COND_EXEC_TEST
argument_list|(
name|sub
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|sub
operator|=
name|COND_EXEC_CODE
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|sched_analyze_1
argument_list|(
name|deps
argument_list|,
name|sub
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|sub
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Mark registers CLOBBERED or used by called function.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|sched_analyze_1
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|sched_analyze_2
argument_list|(
name|deps
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL
argument_list|)
condition|)
name|reg_pending_barrier
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|next
decl_stmt|;
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|BARRIER
condition|)
name|reg_pending_barrier
operator|=
name|true
expr_stmt|;
else|else
block|{
name|rtx
name|pending
decl_stmt|,
name|pending_mem
decl_stmt|;
name|regset_head
name|tmp
decl_stmt|;
name|INIT_REG_SET
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|current_sched_info
operator|->
name|compute_jump_reg_dependencies
call|)
argument_list|(
name|insn
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|IOR_REG_SET
argument_list|(
name|reg_pending_uses
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
comment|/* All memory writes and volatile reads must happen before the 	     jump.  Non-volatile reads must happen before the jump iff 	     the result is needed by the above register used mask.  */
name|pending
operator|=
name|deps
operator|->
name|pending_write_insns
expr_stmt|;
name|pending_mem
operator|=
name|deps
operator|->
name|pending_write_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|pending
operator|=
name|deps
operator|->
name|pending_read_insns
expr_stmt|;
name|pending_mem
operator|=
name|deps
operator|->
name|pending_read_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|add_dependence_list
argument_list|(
name|insn
argument_list|,
name|deps
operator|->
name|last_pending_memory_flush
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If there is a {LOOP,EHREGION}_{BEG,END} note in the middle of a basic      block, then we must be sure that no instructions are scheduled across it.      Otherwise, the reg_n_refs info (which depends on loop_depth) would      become incorrect.  */
if|if
condition|(
name|loop_notes
condition|)
block|{
name|rtx
name|link
decl_stmt|;
comment|/* Update loop_notes with any notes from this insn.  Also determine 	 if any of the notes on the list correspond to instruction scheduling 	 barriers (loop, eh& setjmp notes, but not range notes).  */
name|link
operator|=
name|loop_notes
expr_stmt|;
while|while
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
condition|)
name|reg_pending_barrier
operator|=
name|true
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|loop_notes
expr_stmt|;
block|}
comment|/* If this instruction can throw an exception, then moving it changes      where block boundaries fall.  This is mighty confusing elsewhere.       Therefore, prevent such an instruction from being moved.  */
if|if
condition|(
name|can_throw_internal
argument_list|(
name|insn
argument_list|)
condition|)
name|reg_pending_barrier
operator|=
name|true
expr_stmt|;
comment|/* Add dependencies if a scheduling barrier was found.  */
if|if
condition|(
name|reg_pending_barrier
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|COND_EXEC
condition|)
block|{
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|&deps->reg_last_in_use
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 	      struct deps_reg *reg_last =&deps->reg_last[i]; 	      add_dependence_list (insn, reg_last->uses, REG_DEP_ANTI); 	      add_dependence_list (insn, reg_last->sets,
literal|0
argument|); 	      add_dependence_list (insn, reg_last->clobbers,
literal|0
argument|); 	    }
argument_list|)
empty_stmt|;
block|}
else|else
block|{
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|&deps->reg_last_in_use
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 	      struct deps_reg *reg_last =&deps->reg_last[i]; 	      add_dependence_list_and_free (insn,&reg_last->uses, 					    REG_DEP_ANTI); 	      add_dependence_list_and_free (insn,&reg_last->sets,
literal|0
argument|); 	      add_dependence_list_and_free (insn,&reg_last->clobbers,
literal|0
argument|); 	      reg_last->uses_length =
literal|0
argument|; 	      reg_last->clobbers_length =
literal|0
argument|; 	    }
argument_list|)
empty_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|deps
operator|->
name|max_reg
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|deps_reg
modifier|*
name|reg_last
init|=
operator|&
name|deps
operator|->
name|reg_last
index|[
name|i
index|]
decl_stmt|;
name|reg_last
operator|->
name|sets
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|reg_last
operator|->
name|sets
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
operator|&
name|deps
operator|->
name|reg_last_in_use
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|flush_pending_lists
argument_list|(
name|deps
argument_list|,
name|insn
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|reg_pending_barrier
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
comment|/* If the current insn is conditional, we can't free any 	 of the lists.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|COND_EXEC
condition|)
block|{
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|reg_pending_uses
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 	      struct deps_reg *reg_last =&deps->reg_last[i]; 	      add_dependence_list (insn, reg_last->sets,
literal|0
argument|); 	      add_dependence_list (insn, reg_last->clobbers,
literal|0
argument|); 	      reg_last->uses = alloc_INSN_LIST (insn, reg_last->uses); 	      reg_last->uses_length++; 	    }
argument_list|)
empty_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|reg_pending_clobbers
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 	      struct deps_reg *reg_last =&deps->reg_last[i]; 	      add_dependence_list (insn, reg_last->sets, REG_DEP_OUTPUT); 	      add_dependence_list (insn, reg_last->uses, REG_DEP_ANTI); 	      reg_last->clobbers = alloc_INSN_LIST (insn, reg_last->clobbers); 	      reg_last->clobbers_length++; 	    }
argument_list|)
empty_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|reg_pending_sets
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 	      struct deps_reg *reg_last =&deps->reg_last[i]; 	      add_dependence_list (insn, reg_last->sets, REG_DEP_OUTPUT); 	      add_dependence_list (insn, reg_last->clobbers, REG_DEP_OUTPUT); 	      add_dependence_list (insn, reg_last->uses, REG_DEP_ANTI); 	      reg_last->sets = alloc_INSN_LIST (insn, reg_last->sets); 	    }
argument_list|)
empty_stmt|;
block|}
else|else
block|{
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|reg_pending_uses
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 	      struct deps_reg *reg_last =&deps->reg_last[i]; 	      add_dependence_list (insn, reg_last->sets,
literal|0
argument|); 	      add_dependence_list (insn, reg_last->clobbers,
literal|0
argument|); 	      reg_last->uses_length++; 	      reg_last->uses = alloc_INSN_LIST (insn, reg_last->uses); 	    }
argument_list|)
empty_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|reg_pending_clobbers
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 	      struct deps_reg *reg_last =&deps->reg_last[i]; 	      add_dependence_list (insn, reg_last->sets, REG_DEP_OUTPUT); 	      add_dependence_list (insn, reg_last->uses, REG_DEP_ANTI); 	      if (reg_last->uses_length> MAX_PENDING_LIST_LENGTH 		  || reg_last->clobbers_length> MAX_PENDING_LIST_LENGTH) 		{ 		  add_dependence_list_and_free (insn,&reg_last->sets, 					        REG_DEP_OUTPUT); 		  add_dependence_list_and_free (insn,&reg_last->uses, 						REG_DEP_ANTI); 		  add_dependence_list_and_free (insn,&reg_last->clobbers, 						REG_DEP_OUTPUT); 		  reg_last->clobbers_length =
literal|0
argument|; 		  reg_last->uses_length =
literal|0
argument|; 		} 	      else 		{ 		  add_dependence_list (insn, reg_last->sets, REG_DEP_OUTPUT); 		  add_dependence_list (insn, reg_last->uses, REG_DEP_ANTI); 		} 	      reg_last->clobbers_length++; 	      reg_last->clobbers = alloc_INSN_LIST (insn, reg_last->clobbers); 	    }
argument_list|)
empty_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|reg_pending_sets
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 	      struct deps_reg *reg_last =&deps->reg_last[i]; 	      add_dependence_list_and_free (insn,&reg_last->sets, 					    REG_DEP_OUTPUT); 	      add_dependence_list_and_free (insn,&reg_last->clobbers, 					    REG_DEP_OUTPUT); 	      add_dependence_list_and_free (insn,&reg_last->uses, 					    REG_DEP_ANTI); 	      reg_last->sets = alloc_INSN_LIST (insn, reg_last->sets); 	      reg_last->uses_length =
literal|0
argument|; 	      reg_last->clobbers_length =
literal|0
argument|; 	    }
argument_list|)
empty_stmt|;
block|}
name|IOR_REG_SET
argument_list|(
operator|&
name|deps
operator|->
name|reg_last_in_use
argument_list|,
name|reg_pending_uses
argument_list|)
expr_stmt|;
name|IOR_REG_SET
argument_list|(
operator|&
name|deps
operator|->
name|reg_last_in_use
argument_list|,
name|reg_pending_clobbers
argument_list|)
expr_stmt|;
name|IOR_REG_SET
argument_list|(
operator|&
name|deps
operator|->
name|reg_last_in_use
argument_list|,
name|reg_pending_sets
argument_list|)
expr_stmt|;
block|}
name|CLEAR_REG_SET
argument_list|(
name|reg_pending_uses
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|reg_pending_clobbers
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|)
expr_stmt|;
comment|/* If we are currently in a libcall scheduling group, then mark the      current insn as being in a scheduling group and that it can not      be moved into a different basic block.  */
if|if
condition|(
name|deps
operator|->
name|libcall_block_tail_insn
condition|)
block|{
name|set_sched_group_p
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|CANT_MOVE
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If a post-call group is still open, see if it should remain so.      This insn must be a simple move of a hard reg to a pseudo or      vice-versa.       We must avoid moving these insns for correctness on      SMALL_REGISTER_CLASS machines, and for special registers like      PIC_OFFSET_TABLE_REGNUM.  For simplicity, extend this to all      hard regs for all targets.  */
if|if
condition|(
name|deps
operator|->
name|in_post_call_group_p
condition|)
block|{
name|rtx
name|tmp
decl_stmt|,
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|src_regno
decl_stmt|,
name|dest_regno
decl_stmt|;
if|if
condition|(
name|set
operator|==
name|NULL
condition|)
goto|goto
name|end_call_group
goto|;
name|tmp
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SUBREG
condition|)
name|tmp
operator|=
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
condition|)
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
goto|goto
name|end_call_group
goto|;
name|tmp
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SUBREG
condition|)
name|tmp
operator|=
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
condition|)
name|src_regno
operator|=
name|REGNO
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
goto|goto
name|end_call_group
goto|;
if|if
condition|(
name|src_regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|dest_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|set_sched_group_p
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|CANT_MOVE
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|end_call_group
label|:
name|deps
operator|->
name|in_post_call_group_p
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Analyze every insn between HEAD and TAIL inclusive, creating LOG_LINKS    for every dependency.  */
end_comment

begin_function
name|void
name|sched_analyze
parameter_list|(
name|deps
parameter_list|,
name|head
parameter_list|,
name|tail
parameter_list|)
name|struct
name|deps
modifier|*
name|deps
decl_stmt|;
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|loop_notes
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|current_sched_info
operator|->
name|use_cselib
condition|)
name|cselib_init
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|link
decl_stmt|,
name|end_seq
decl_stmt|,
name|r0
decl_stmt|,
name|set
decl_stmt|,
name|note
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
comment|/* Clear out the stale LOG_LINKS from flow.  */
name|free_INSN_LIST_list
argument_list|(
operator|&
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clear out stale SCHED_GROUP_P.  */
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Make each JUMP_INSN a scheduling barrier for memory              references.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
comment|/* Keep the list a reasonable size.  */
if|if
condition|(
name|deps
operator|->
name|pending_flush_length
operator|++
operator|>
name|MAX_PENDING_LIST_LENGTH
condition|)
name|flush_pending_lists
argument_list|(
name|deps
argument_list|,
name|insn
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
name|deps
operator|->
name|last_pending_memory_flush
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|deps
operator|->
name|last_pending_memory_flush
argument_list|)
expr_stmt|;
block|}
name|sched_analyze_insn
argument_list|(
name|deps
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|loop_notes
argument_list|)
expr_stmt|;
name|loop_notes
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|int
name|i
decl_stmt|;
name|CANT_MOVE
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Clear out the stale LOG_LINKS from flow.  */
name|free_INSN_LIST_list
argument_list|(
operator|&
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
comment|/* This is setjmp.  Assume that all registers, not just 		 hard registers, may be clobbered by this call.  */
name|reg_pending_barrier
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
comment|/* A call may read and modify global register variables.  */
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_uses
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Other call-clobbered hard regs may be clobbered.  */
elseif|else
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|i
argument_list|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_clobbers
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* We don't know what set of fixed registers might be used 		   by the function, but it is certain that the stack pointer 		   is among them, but be conservative.  */
elseif|else
if|if
condition|(
name|fixed_regs
index|[
name|i
index|]
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_uses
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* The frame pointer is normally not used by the function 		   itself, but by the debugger.  */
comment|/* ??? MIPS o32 is an exception.  It uses the frame pointer 		   in the macro expansion of jal but does not represent this 		   fact in the call_insn rtl.  */
elseif|else
if|if
condition|(
name|i
operator|==
name|FRAME_POINTER_REGNUM
operator|||
operator|(
name|i
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
operator|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_uses
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* For each insn which shouldn't cross a call, add a dependence 	     between that insn and this call insn.  */
name|add_dependence_list_and_free
argument_list|(
name|insn
argument_list|,
operator|&
name|deps
operator|->
name|sched_before_next_call
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|sched_analyze_insn
argument_list|(
name|deps
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|loop_notes
argument_list|)
expr_stmt|;
name|loop_notes
operator|=
literal|0
expr_stmt|;
comment|/* In the absence of interprocedural alias analysis, we must flush 	     all pending reads and writes, and start new dependencies starting 	     from here.  But only flush writes for constant calls (which may 	     be passed a pointer to something we haven't written yet).  */
name|flush_pending_lists
argument_list|(
name|deps
argument_list|,
name|insn
argument_list|,
name|true
argument_list|,
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remember the last function call for limiting lifetimes.  */
name|free_INSN_LIST_list
argument_list|(
operator|&
name|deps
operator|->
name|last_function_call
argument_list|)
expr_stmt|;
name|deps
operator|->
name|last_function_call
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Before reload, begin a post-call group, so as to keep the 	     lifetimes of hard registers correct.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
name|deps
operator|->
name|in_post_call_group_p
operator|=
name|true
expr_stmt|;
block|}
comment|/* See comments on reemit_notes as to why we do this. 	 ??? Actually, the reemit_notes just say what is done, not why.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_RANGE_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_RANGE_END
operator|)
condition|)
block|{
name|loop_notes
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_SAVE_NOTE
argument_list|,
name|NOTE_RANGE_INFO
argument_list|(
name|insn
argument_list|)
argument_list|,
name|loop_notes
argument_list|)
expr_stmt|;
name|loop_notes
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_SAVE_NOTE
argument_list|,
name|GEN_INT
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|loop_notes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
operator|)
condition|)
block|{
name|rtx
name|rtx_region
decl_stmt|;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
condition|)
name|rtx_region
operator|=
name|GEN_INT
argument_list|(
name|NOTE_EH_HANDLER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|rtx_region
operator|=
name|GEN_INT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|loop_notes
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_SAVE_NOTE
argument_list|,
name|rtx_region
argument_list|,
name|loop_notes
argument_list|)
expr_stmt|;
name|loop_notes
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_SAVE_NOTE
argument_list|,
name|GEN_INT
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|loop_notes
argument_list|)
expr_stmt|;
name|CONST_OR_PURE_CALL_P
argument_list|(
name|loop_notes
argument_list|)
operator|=
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_sched_info
operator|->
name|use_cselib
condition|)
name|cselib_process_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Now that we have completed handling INSN, check and see if it is 	 a CLOBBER beginning a libcall block.   If it is, record the 	 end of the libcall sequence.   	 We want to schedule libcall blocks as a unit before reload.  While 	 this restricts scheduling, it preserves the meaning of a libcall 	 block.  	 As a side effect, we may get better code due to decreased register 	 pressure as well as less chance of a foreign insn appearing in 	 a libcall block.  */
if|if
condition|(
operator|!
name|reload_completed
comment|/* Note we may have nested libcall sequences.  We only care about 	     the outermost libcall sequence.  */
operator|&&
name|deps
operator|->
name|libcall_block_tail_insn
operator|==
literal|0
comment|/* The sequence must start with a clobber of a register.  */
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
operator|(
name|r0
operator|=
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|r0
argument_list|)
operator|==
name|REG
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
comment|/* The CLOBBER must also have a REG_LIBCALL note attached.  */
operator|&&
operator|(
name|link
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|end_seq
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
comment|/* The insn referenced by the REG_LIBCALL note must be a 	     simple nop copy with the same destination as the register 	     mentioned in the clobber.  */
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|end_seq
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|r0
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|r0
comment|/* And finally the insn referenced by the REG_LIBCALL must 	     also contain a REG_EQUAL note and a REG_RETVAL note.  */
operator|&&
name|find_reg_note
argument_list|(
name|end_seq
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|!=
literal|0
operator|&&
name|find_reg_note
argument_list|(
name|end_seq
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|!=
literal|0
condition|)
name|deps
operator|->
name|libcall_block_tail_insn
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we have reached the end of a libcall block, then close the 	 block.  */
if|if
condition|(
name|deps
operator|->
name|libcall_block_tail_insn
operator|==
name|insn
condition|)
name|deps
operator|->
name|libcall_block_tail_insn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|tail
condition|)
block|{
if|if
condition|(
name|current_sched_info
operator|->
name|use_cselib
condition|)
name|cselib_finish
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Examine insns in the range [ HEAD, TAIL ] and Use the backward    dependences from LOG_LINKS to build forward dependences in    INSN_DEPEND.  */
end_comment

begin_function
name|void
name|compute_forward_dependences
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|link
decl_stmt|;
name|rtx
name|next_tail
decl_stmt|;
name|enum
name|reg_note
name|dep_type
decl_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|insn
operator|=
name|group_leader
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|x
init|=
name|group_leader
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|new_link
decl_stmt|;
if|if
condition|(
name|x
operator|!=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* If add_dependence is working properly there should never 	     be notes, deleted insns or duplicates in the backward 	     links.  Thus we need not check for them here.  	     However, if we have enabled checking we might as well go 	     ahead and verify that add_dependence worked properly.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NOTE
operator|||
name|INSN_DELETED_P
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|forward_dependency_cache
operator|!=
name|NULL
operator|&&
name|TEST_BIT
argument_list|(
name|forward_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|forward_dependency_cache
operator|==
name|NULL
operator|&&
name|find_insn_list
argument_list|(
name|insn
argument_list|,
name|INSN_DEPEND
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|forward_dependency_cache
operator|!=
name|NULL
condition|)
name|SET_BIT
argument_list|(
name|forward_dependency_cache
index|[
name|INSN_LUID
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|new_link
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|INSN_DEPEND
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|dep_type
operator|=
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|new_link
argument_list|,
name|dep_type
argument_list|)
expr_stmt|;
name|INSN_DEPEND
argument_list|(
name|x
argument_list|)
operator|=
name|new_link
expr_stmt|;
name|INSN_DEP_COUNT
argument_list|(
name|insn
argument_list|)
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize variables for region data dependence analysis.    n_bbs is the number of region blocks.  */
end_comment

begin_function
name|void
name|init_deps
parameter_list|(
name|deps
parameter_list|)
name|struct
name|deps
modifier|*
name|deps
decl_stmt|;
block|{
name|int
name|max_reg
init|=
operator|(
name|reload_completed
condition|?
name|FIRST_PSEUDO_REGISTER
else|:
name|max_reg_num
argument_list|()
operator|)
decl_stmt|;
name|deps
operator|->
name|max_reg
operator|=
name|max_reg
expr_stmt|;
name|deps
operator|->
name|reg_last
operator|=
operator|(
expr|struct
name|deps_reg
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_reg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|deps_reg
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_REG_SET
argument_list|(
operator|&
name|deps
operator|->
name|reg_last_in_use
argument_list|)
expr_stmt|;
name|deps
operator|->
name|pending_read_insns
operator|=
literal|0
expr_stmt|;
name|deps
operator|->
name|pending_read_mems
operator|=
literal|0
expr_stmt|;
name|deps
operator|->
name|pending_write_insns
operator|=
literal|0
expr_stmt|;
name|deps
operator|->
name|pending_write_mems
operator|=
literal|0
expr_stmt|;
name|deps
operator|->
name|pending_lists_length
operator|=
literal|0
expr_stmt|;
name|deps
operator|->
name|pending_flush_length
operator|=
literal|0
expr_stmt|;
name|deps
operator|->
name|last_pending_memory_flush
operator|=
literal|0
expr_stmt|;
name|deps
operator|->
name|last_function_call
operator|=
literal|0
expr_stmt|;
name|deps
operator|->
name|sched_before_next_call
operator|=
literal|0
expr_stmt|;
name|deps
operator|->
name|in_post_call_group_p
operator|=
name|false
expr_stmt|;
name|deps
operator|->
name|libcall_block_tail_insn
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free insn lists found in DEPS.  */
end_comment

begin_function
name|void
name|free_deps
parameter_list|(
name|deps
parameter_list|)
name|struct
name|deps
modifier|*
name|deps
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|free_INSN_LIST_list
argument_list|(
operator|&
name|deps
operator|->
name|pending_read_insns
argument_list|)
expr_stmt|;
name|free_EXPR_LIST_list
argument_list|(
operator|&
name|deps
operator|->
name|pending_read_mems
argument_list|)
expr_stmt|;
name|free_INSN_LIST_list
argument_list|(
operator|&
name|deps
operator|->
name|pending_write_insns
argument_list|)
expr_stmt|;
name|free_EXPR_LIST_list
argument_list|(
operator|&
name|deps
operator|->
name|pending_write_mems
argument_list|)
expr_stmt|;
name|free_INSN_LIST_list
argument_list|(
operator|&
name|deps
operator|->
name|last_pending_memory_flush
argument_list|)
expr_stmt|;
comment|/* Without the EXECUTE_IF_SET, this loop is executed max_reg * nr_regions      times.  For a test case with 42000 regs and 8000 small basic blocks,      this loop accounted for nearly 60% (84 sec) of the total -O2 runtime.  */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|&deps->reg_last_in_use
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{       struct deps_reg *reg_last =&deps->reg_last[i];       free_INSN_LIST_list (&reg_last->uses);       free_INSN_LIST_list (&reg_last->sets);       free_INSN_LIST_list (&reg_last->clobbers);     }
argument_list|)
empty_stmt|;
name|CLEAR_REG_SET
argument_list|(
operator|&
name|deps
operator|->
name|reg_last_in_use
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|deps
operator|->
name|reg_last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If it is profitable to use them, initialize caches for tracking    dependency informatino.  LUID is the number of insns to be scheduled,    it is used in the estimate of profitability.  */
end_comment

begin_function
name|void
name|init_dependency_caches
parameter_list|(
name|luid
parameter_list|)
name|int
name|luid
decl_stmt|;
block|{
comment|/* ?!? We could save some memory by computing a per-region luid mapping      which could reduce both the number of vectors in the cache and the size      of each vector.  Instead we just avoid the cache entirely unless the      average number of instructions in a basic block is very high.  See      the comment before the declaration of true_dependency_cache for      what we consider "very high".  */
if|if
condition|(
name|luid
operator|/
name|n_basic_blocks
operator|>
literal|100
operator|*
literal|5
condition|)
block|{
name|true_dependency_cache
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|luid
argument_list|,
name|luid
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|true_dependency_cache
argument_list|,
name|luid
argument_list|)
expr_stmt|;
name|anti_dependency_cache
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|luid
argument_list|,
name|luid
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|anti_dependency_cache
argument_list|,
name|luid
argument_list|)
expr_stmt|;
name|output_dependency_cache
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|luid
argument_list|,
name|luid
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|output_dependency_cache
argument_list|,
name|luid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|forward_dependency_cache
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|luid
argument_list|,
name|luid
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|forward_dependency_cache
argument_list|,
name|luid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Free the caches allocated in init_dependency_caches.  */
end_comment

begin_function
name|void
name|free_dependency_caches
parameter_list|()
block|{
if|if
condition|(
name|true_dependency_cache
condition|)
block|{
name|sbitmap_vector_free
argument_list|(
name|true_dependency_cache
argument_list|)
expr_stmt|;
name|true_dependency_cache
operator|=
name|NULL
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|anti_dependency_cache
argument_list|)
expr_stmt|;
name|anti_dependency_cache
operator|=
name|NULL
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|output_dependency_cache
argument_list|)
expr_stmt|;
name|output_dependency_cache
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|sbitmap_vector_free
argument_list|(
name|forward_dependency_cache
argument_list|)
expr_stmt|;
name|forward_dependency_cache
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Initialize some global variables needed by the dependency analysis    code.  */
end_comment

begin_function
name|void
name|init_deps_global
parameter_list|()
block|{
name|reg_pending_sets
operator|=
name|INITIALIZE_REG_SET
argument_list|(
name|reg_pending_sets_head
argument_list|)
expr_stmt|;
name|reg_pending_clobbers
operator|=
name|INITIALIZE_REG_SET
argument_list|(
name|reg_pending_clobbers_head
argument_list|)
expr_stmt|;
name|reg_pending_uses
operator|=
name|INITIALIZE_REG_SET
argument_list|(
name|reg_pending_uses_head
argument_list|)
expr_stmt|;
name|reg_pending_barrier
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free everything used by the dependency analysis code.  */
end_comment

begin_function
name|void
name|finish_deps_global
parameter_list|()
block|{
name|FREE_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|reg_pending_clobbers
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|reg_pending_uses
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

