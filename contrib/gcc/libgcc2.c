begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* More subroutines needed by GCC output code on some machines.  */
end_comment

begin_comment
comment|/* Compile this one with gcc.  */
end_comment

begin_comment
comment|/* Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002  Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  In addition to the permissions in the GNU General Public License, the Free Software Foundation gives you unlimited permission to link the compiled version of this file into combinations with other programs, and to distribute those combinations without any restriction coming from the use of this file.  (The General Public License restrictions do apply in other respects; for example, they cover modification of the file, and distribution when not linked into a combine executable.)  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* It is incorrect to include config.h here, because this file is being    compiled for the target, and hence definitions concerning only the host    do not apply.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"tsystem.h"
end_include

begin_comment
comment|/* Don't use `fancy_abort' here even if config.h says to use it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|abort
end_ifdef

begin_undef
undef|#
directive|undef
name|abort
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"libgcc2.h"
end_include

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DECLARE_LIBRARY_RENAMES
end_ifdef

begin_function
name|DECLARE_LIBRARY_RENAMES
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|L_negdi2
argument_list|)
name|DWtype
name|__negdi2
parameter_list|(
name|DWtype
name|u
parameter_list|)
block|{
name|DWunion
name|w
decl_stmt|;
name|DWunion
name|uu
decl_stmt|;
name|uu
operator|.
name|ll
operator|=
name|u
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|low
operator|=
operator|-
name|uu
operator|.
name|s
operator|.
name|low
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|high
operator|=
operator|-
name|uu
operator|.
name|s
operator|.
name|high
operator|-
operator|(
operator|(
name|UWtype
operator|)
name|w
operator|.
name|s
operator|.
name|low
operator|>
literal|0
operator|)
expr_stmt|;
return|return
name|w
operator|.
name|ll
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_addvsi3
end_ifdef

begin_function
name|Wtype
name|__addvsi3
parameter_list|(
name|Wtype
name|a
parameter_list|,
name|Wtype
name|b
parameter_list|)
block|{
name|Wtype
name|w
decl_stmt|;
name|w
operator|=
name|a
operator|+
name|b
expr_stmt|;
if|if
condition|(
name|b
operator|>=
literal|0
condition|?
name|w
operator|<
name|a
else|:
name|w
operator|>
name|a
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_addvdi3
end_ifdef

begin_function
name|DWtype
name|__addvdi3
parameter_list|(
name|DWtype
name|a
parameter_list|,
name|DWtype
name|b
parameter_list|)
block|{
name|DWtype
name|w
decl_stmt|;
name|w
operator|=
name|a
operator|+
name|b
expr_stmt|;
if|if
condition|(
name|b
operator|>=
literal|0
condition|?
name|w
operator|<
name|a
else|:
name|w
operator|>
name|a
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_subvsi3
end_ifdef

begin_function
name|Wtype
name|__subvsi3
parameter_list|(
name|Wtype
name|a
parameter_list|,
name|Wtype
name|b
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|L_addvsi3
return|return
name|__addvsi3
argument_list|(
name|a
argument_list|,
operator|(
operator|-
name|b
operator|)
argument_list|)
return|;
else|#
directive|else
name|DWtype
name|w
decl_stmt|;
name|w
operator|=
name|a
operator|-
name|b
expr_stmt|;
if|if
condition|(
name|b
operator|>=
literal|0
condition|?
name|w
operator|>
name|a
else|:
name|w
operator|<
name|a
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|w
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_subvdi3
end_ifdef

begin_function
name|DWtype
name|__subvdi3
parameter_list|(
name|DWtype
name|a
parameter_list|,
name|DWtype
name|b
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|L_addvdi3
return|return
operator|(
name|a
operator|,
operator|(
operator|-
name|b
operator|)
operator|)
return|;
else|#
directive|else
name|DWtype
name|w
decl_stmt|;
name|w
operator|=
name|a
operator|-
name|b
expr_stmt|;
if|if
condition|(
name|b
operator|>=
literal|0
condition|?
name|w
operator|>
name|a
else|:
name|w
operator|<
name|a
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|w
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_mulvsi3
end_ifdef

begin_function
name|Wtype
name|__mulvsi3
parameter_list|(
name|Wtype
name|a
parameter_list|,
name|Wtype
name|b
parameter_list|)
block|{
name|DWtype
name|w
decl_stmt|;
name|w
operator|=
name|a
operator|*
name|b
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|a
operator|>=
literal|0
operator|)
operator|==
operator|(
name|b
operator|>=
literal|0
operator|)
operator|)
condition|?
name|w
operator|<
literal|0
else|:
name|w
operator|>
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_negvsi2
end_ifdef

begin_function
name|Wtype
name|__negvsi2
parameter_list|(
name|Wtype
name|a
parameter_list|)
block|{
name|Wtype
name|w
decl_stmt|;
name|w
operator|=
operator|-
name|a
expr_stmt|;
if|if
condition|(
name|a
operator|>=
literal|0
condition|?
name|w
operator|>
literal|0
else|:
name|w
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_negvdi2
end_ifdef

begin_function
name|DWtype
name|__negvdi2
parameter_list|(
name|DWtype
name|a
parameter_list|)
block|{
name|DWtype
name|w
decl_stmt|;
name|w
operator|=
operator|-
name|a
expr_stmt|;
if|if
condition|(
name|a
operator|>=
literal|0
condition|?
name|w
operator|>
literal|0
else|:
name|w
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_absvsi2
end_ifdef

begin_function
name|Wtype
name|__absvsi2
parameter_list|(
name|Wtype
name|a
parameter_list|)
block|{
name|Wtype
name|w
init|=
name|a
decl_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
ifdef|#
directive|ifdef
name|L_negvsi2
name|w
operator|=
name|__negvsi2
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|#
directive|else
name|w
operator|=
operator|-
name|a
expr_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_absvdi2
end_ifdef

begin_function
name|DWtype
name|__absvdi2
parameter_list|(
name|DWtype
name|a
parameter_list|)
block|{
name|DWtype
name|w
init|=
name|a
decl_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
ifdef|#
directive|ifdef
name|L_negvsi2
name|w
operator|=
name|__negvsi2
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|#
directive|else
name|w
operator|=
operator|-
name|a
expr_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_mulvdi3
end_ifdef

begin_function
name|DWtype
name|__mulvdi3
parameter_list|(
name|DWtype
name|u
parameter_list|,
name|DWtype
name|v
parameter_list|)
block|{
name|DWtype
name|w
decl_stmt|;
name|w
operator|=
name|u
operator|*
name|v
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|u
operator|>=
literal|0
operator|)
operator|==
operator|(
name|v
operator|>=
literal|0
operator|)
operator|)
condition|?
name|w
operator|<
literal|0
else|:
name|w
operator|>
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Unless shift functions are defined whith full ANSI prototypes,    parameter b will be promoted to int if word_type is smaller than an int.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|L_lshrdi3
end_ifdef

begin_function
name|DWtype
name|__lshrdi3
parameter_list|(
name|DWtype
name|u
parameter_list|,
name|word_type
name|b
parameter_list|)
block|{
name|DWunion
name|w
decl_stmt|;
name|word_type
name|bm
decl_stmt|;
name|DWunion
name|uu
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
name|u
return|;
name|uu
operator|.
name|ll
operator|=
name|u
expr_stmt|;
name|bm
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|Wtype
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|-
name|b
expr_stmt|;
if|if
condition|(
name|bm
operator|<=
literal|0
condition|)
block|{
name|w
operator|.
name|s
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|low
operator|=
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|high
operator|>>
operator|-
name|bm
expr_stmt|;
block|}
else|else
block|{
name|UWtype
name|carries
init|=
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|high
operator|<<
name|bm
decl_stmt|;
name|w
operator|.
name|s
operator|.
name|high
operator|=
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|high
operator|>>
name|b
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|low
operator|=
operator|(
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|>>
name|b
operator|)
operator||
name|carries
expr_stmt|;
block|}
return|return
name|w
operator|.
name|ll
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_ashldi3
end_ifdef

begin_function
name|DWtype
name|__ashldi3
parameter_list|(
name|DWtype
name|u
parameter_list|,
name|word_type
name|b
parameter_list|)
block|{
name|DWunion
name|w
decl_stmt|;
name|word_type
name|bm
decl_stmt|;
name|DWunion
name|uu
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
name|u
return|;
name|uu
operator|.
name|ll
operator|=
name|u
expr_stmt|;
name|bm
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|Wtype
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|-
name|b
expr_stmt|;
if|if
condition|(
name|bm
operator|<=
literal|0
condition|)
block|{
name|w
operator|.
name|s
operator|.
name|low
operator|=
literal|0
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|high
operator|=
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|<<
operator|-
name|bm
expr_stmt|;
block|}
else|else
block|{
name|UWtype
name|carries
init|=
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|>>
name|bm
decl_stmt|;
name|w
operator|.
name|s
operator|.
name|low
operator|=
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|<<
name|b
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|high
operator|=
operator|(
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|high
operator|<<
name|b
operator|)
operator||
name|carries
expr_stmt|;
block|}
return|return
name|w
operator|.
name|ll
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_ashrdi3
end_ifdef

begin_function
name|DWtype
name|__ashrdi3
parameter_list|(
name|DWtype
name|u
parameter_list|,
name|word_type
name|b
parameter_list|)
block|{
name|DWunion
name|w
decl_stmt|;
name|word_type
name|bm
decl_stmt|;
name|DWunion
name|uu
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
name|u
return|;
name|uu
operator|.
name|ll
operator|=
name|u
expr_stmt|;
name|bm
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|Wtype
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|-
name|b
expr_stmt|;
if|if
condition|(
name|bm
operator|<=
literal|0
condition|)
block|{
comment|/* w.s.high = 1..1 or 0..0 */
name|w
operator|.
name|s
operator|.
name|high
operator|=
name|uu
operator|.
name|s
operator|.
name|high
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|Wtype
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|low
operator|=
name|uu
operator|.
name|s
operator|.
name|high
operator|>>
operator|-
name|bm
expr_stmt|;
block|}
else|else
block|{
name|UWtype
name|carries
init|=
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|high
operator|<<
name|bm
decl_stmt|;
name|w
operator|.
name|s
operator|.
name|high
operator|=
name|uu
operator|.
name|s
operator|.
name|high
operator|>>
name|b
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|low
operator|=
operator|(
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|>>
name|b
operator|)
operator||
name|carries
expr_stmt|;
block|}
return|return
name|w
operator|.
name|ll
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_ffsdi2
end_ifdef

begin_function
name|DWtype
name|__ffsdi2
parameter_list|(
name|DWtype
name|u
parameter_list|)
block|{
name|DWunion
name|uu
decl_stmt|;
name|UWtype
name|word
decl_stmt|,
name|count
decl_stmt|,
name|add
decl_stmt|;
name|uu
operator|.
name|ll
operator|=
name|u
expr_stmt|;
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|low
operator|!=
literal|0
condition|)
name|word
operator|=
name|uu
operator|.
name|s
operator|.
name|low
operator|,
name|add
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|high
operator|!=
literal|0
condition|)
name|word
operator|=
name|uu
operator|.
name|s
operator|.
name|high
operator|,
name|add
operator|=
name|BITS_PER_UNIT
operator|*
sizeof|sizeof
argument_list|(
name|Wtype
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
name|count_trailing_zeros
argument_list|(
name|count
argument_list|,
name|word
argument_list|)
expr_stmt|;
return|return
name|count
operator|+
name|add
operator|+
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_muldi3
end_ifdef

begin_function
name|DWtype
name|__muldi3
parameter_list|(
name|DWtype
name|u
parameter_list|,
name|DWtype
name|v
parameter_list|)
block|{
name|DWunion
name|w
decl_stmt|;
name|DWunion
name|uu
decl_stmt|,
name|vv
decl_stmt|;
name|uu
operator|.
name|ll
operator|=
name|u
operator|,
name|vv
operator|.
name|ll
operator|=
name|v
expr_stmt|;
name|w
operator|.
name|ll
operator|=
name|__umulsidi3
argument_list|(
name|uu
operator|.
name|s
operator|.
name|low
argument_list|,
name|vv
operator|.
name|s
operator|.
name|low
argument_list|)
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|high
operator|+=
operator|(
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|*
operator|(
name|UWtype
operator|)
name|vv
operator|.
name|s
operator|.
name|high
operator|+
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|high
operator|*
operator|(
name|UWtype
operator|)
name|vv
operator|.
name|s
operator|.
name|low
operator|)
expr_stmt|;
return|return
name|w
operator|.
name|ll
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|L_udivdi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divdi3
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|L_umoddi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_moddi3
argument_list|)
operator|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sdiv_qrnnd
argument_list|)
end_if

begin_define
define|#
directive|define
name|L_udiv_w_sdiv
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_udiv_w_sdiv
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sdiv_qrnnd
argument_list|)
end_if

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|L_udivdi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divdi3
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|L_umoddi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_moddi3
argument_list|)
operator|)
end_if

begin_expr_stmt
specifier|static
specifier|inline
name|__attribute__
argument_list|(
argument|(__always_inline__)
argument_list|)
endif|#
directive|endif
name|UWtype
name|__udiv_w_sdiv
argument_list|(
argument|UWtype *rp
argument_list|,
argument|UWtype a1
argument_list|,
argument|UWtype a0
argument_list|,
argument|UWtype d
argument_list|)
block|{
name|UWtype
name|q
block|,
name|r
block|;
name|UWtype
name|c0
block|,
name|c1
block|,
name|b1
block|;
if|if
condition|(
operator|(
name|Wtype
operator|)
name|d
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|a1
operator|<
name|d
operator|-
name|a1
operator|-
operator|(
name|a0
operator|>>
operator|(
name|W_TYPE_SIZE
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* dividend, divisor, and quotient are nonnegative */
name|sdiv_qrnnd
argument_list|(
name|q
argument_list|,
name|r
argument_list|,
name|a1
argument_list|,
name|a0
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
comment|/* Compute c1*2^32 + c0 = a1*2^32 + a0 - 2^31*d */
name|sub_ddmmss
argument_list|(
name|c1
argument_list|,
name|c0
argument_list|,
name|a1
argument_list|,
name|a0
argument_list|,
name|d
operator|>>
literal|1
argument_list|,
name|d
operator|<<
operator|(
name|W_TYPE_SIZE
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Divide (c1*2^32 + c0) by d */
name|sdiv_qrnnd
argument_list|(
name|q
argument_list|,
name|r
argument_list|,
name|c1
argument_list|,
name|c0
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* Add 2^31 to quotient */
name|q
operator|+=
operator|(
name|UWtype
operator|)
literal|1
operator|<<
operator|(
name|W_TYPE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_else

begin_block
unit|}   else
block|{
name|b1
operator|=
name|d
operator|>>
literal|1
expr_stmt|;
comment|/* d/2, between 2^30 and 2^31 - 1 */
name|c1
operator|=
name|a1
operator|>>
literal|1
expr_stmt|;
comment|/* A/2 */
name|c0
operator|=
operator|(
name|a1
operator|<<
operator|(
name|W_TYPE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|+
operator|(
name|a0
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|a1
operator|<
name|b1
condition|)
comment|/* A< 2^32*b1, so A/2< 2^31*b1 */
block|{
name|sdiv_qrnnd
argument_list|(
name|q
argument_list|,
name|r
argument_list|,
name|c1
argument_list|,
name|c0
argument_list|,
name|b1
argument_list|)
expr_stmt|;
comment|/* (A/2) / (d/2) */
name|r
operator|=
literal|2
operator|*
name|r
operator|+
operator|(
name|a0
operator|&
literal|1
operator|)
expr_stmt|;
comment|/* Remainder from A/(2*b1) */
if|if
condition|(
operator|(
name|d
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|>=
name|q
condition|)
name|r
operator|=
name|r
operator|-
name|q
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|-
name|r
operator|<=
name|d
condition|)
block|{
name|r
operator|=
name|r
operator|-
name|q
operator|+
name|d
expr_stmt|;
name|q
operator|--
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|r
operator|-
name|q
operator|+
literal|2
operator|*
name|d
expr_stmt|;
name|q
operator|-=
literal|2
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c1
operator|<
name|b1
condition|)
comment|/* So 2^31<= (A/2)/b1< 2^32 */
block|{
name|c1
operator|=
operator|(
name|b1
operator|-
literal|1
operator|)
operator|-
name|c1
expr_stmt|;
name|c0
operator|=
operator|~
name|c0
expr_stmt|;
comment|/* logical NOT */
name|sdiv_qrnnd
argument_list|(
name|q
argument_list|,
name|r
argument_list|,
name|c1
argument_list|,
name|c0
argument_list|,
name|b1
argument_list|)
expr_stmt|;
comment|/* (A/2) / (d/2) */
name|q
operator|=
operator|~
name|q
expr_stmt|;
comment|/* (A/2)/b1 */
name|r
operator|=
operator|(
name|b1
operator|-
literal|1
operator|)
operator|-
name|r
expr_stmt|;
name|r
operator|=
literal|2
operator|*
name|r
operator|+
operator|(
name|a0
operator|&
literal|1
operator|)
expr_stmt|;
comment|/* A/(2*b1) */
if|if
condition|(
operator|(
name|d
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|>=
name|q
condition|)
name|r
operator|=
name|r
operator|-
name|q
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|-
name|r
operator|<=
name|d
condition|)
block|{
name|r
operator|=
name|r
operator|-
name|q
operator|+
name|d
expr_stmt|;
name|q
operator|--
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|r
operator|-
name|q
operator|+
literal|2
operator|*
name|d
expr_stmt|;
name|q
operator|-=
literal|2
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* Implies c1 = b1 */
block|{
comment|/* Hence a1 = d - 1 = 2*b1 - 1 */
if|if
condition|(
name|a0
operator|>=
operator|-
name|d
condition|)
block|{
name|q
operator|=
operator|-
literal|1
expr_stmt|;
name|r
operator|=
name|a0
operator|+
name|d
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
operator|-
literal|2
expr_stmt|;
name|r
operator|=
name|a0
operator|+
literal|2
operator|*
name|d
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
operator|*
name|rp
operator|=
name|r
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|q
return|;
end_return

begin_else
unit|}
else|#
directive|else
end_else

begin_comment
comment|/* If sdiv_qrnnd doesn't exist, define dummy __udiv_w_sdiv.  */
end_comment

begin_macro
unit|UWtype
name|__udiv_w_sdiv
argument_list|(
argument|UWtype *rp __attribute__ ((__unused__))
argument_list|,
argument|UWtype a1 __attribute__ ((__unused__))
argument_list|,
argument|UWtype a0 __attribute__ ((__unused__))
argument_list|,
argument|UWtype d __attribute__ ((__unused__))
argument_list|)
end_macro

begin_block
block|{
return|return
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|L_udivdi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divdi3
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|L_umoddi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_moddi3
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|L_udivmoddi4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_clz
end_ifdef

begin_decl_stmt
specifier|const
name|UQItype
name|__clz_tab
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_udivmoddi4
end_ifdef

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|L_udivdi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divdi3
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|L_umoddi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_moddi3
argument_list|)
operator|)
end_if

begin_expr_stmt
specifier|static
specifier|inline
name|__attribute__
argument_list|(
argument|(__always_inline__)
argument_list|)
endif|#
directive|endif
name|UDWtype
name|__udivmoddi4
argument_list|(
argument|UDWtype n
argument_list|,
argument|UDWtype d
argument_list|,
argument|UDWtype *rp
argument_list|)
block|{
name|DWunion
name|ww
block|;
name|DWunion
name|nn
block|,
name|dd
block|;
name|DWunion
name|rr
block|;
name|UWtype
name|d0
block|,
name|d1
block|,
name|n0
block|,
name|n1
block|,
name|n2
block|;
name|UWtype
name|q0
block|,
name|q1
block|;
name|UWtype
name|b
block|,
name|bm
block|;
name|nn
operator|.
name|ll
operator|=
name|n
block|;
name|dd
operator|.
name|ll
operator|=
name|d
block|;
name|d0
operator|=
name|dd
operator|.
name|s
operator|.
name|low
block|;
name|d1
operator|=
name|dd
operator|.
name|s
operator|.
name|high
block|;
name|n0
operator|=
name|nn
operator|.
name|s
operator|.
name|low
block|;
name|n1
operator|=
name|nn
operator|.
name|s
operator|.
name|high
block|;
if|#
directive|if
operator|!
name|UDIV_NEEDS_NORMALIZATION
if|if
condition|(
name|d1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|d0
operator|>
name|n1
condition|)
block|{
comment|/* 0q = nn / 0D */
name|udiv_qrnnd
argument_list|(
name|q0
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|d0
argument_list|)
expr_stmt|;
name|q1
operator|=
literal|0
expr_stmt|;
comment|/* Remainder in n0.  */
block|}
end_expr_stmt

begin_else
else|else
block|{
comment|/* qq = NN / 0d */
if|if
condition|(
name|d0
operator|==
literal|0
condition|)
name|d0
operator|=
literal|1
operator|/
name|d0
expr_stmt|;
comment|/* Divide intentionally by zero.  */
name|udiv_qrnnd
argument_list|(
name|q1
argument_list|,
name|n1
argument_list|,
literal|0
argument_list|,
name|n1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
name|udiv_qrnnd
argument_list|(
name|q0
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|d0
argument_list|)
expr_stmt|;
comment|/* Remainder in n0.  */
block|}
end_else

begin_if
if|if
condition|(
name|rp
operator|!=
literal|0
condition|)
block|{
name|rr
operator|.
name|s
operator|.
name|low
operator|=
name|n0
expr_stmt|;
name|rr
operator|.
name|s
operator|.
name|high
operator|=
literal|0
expr_stmt|;
operator|*
name|rp
operator|=
name|rr
operator|.
name|ll
expr_stmt|;
block|}
end_if

begin_else
unit|}
else|#
directive|else
end_else

begin_comment
comment|/* UDIV_NEEDS_NORMALIZATION */
end_comment

begin_expr_stmt
unit|if
operator|(
name|d1
operator|==
literal|0
operator|)
block|{
if|if
condition|(
name|d0
operator|>
name|n1
condition|)
block|{
comment|/* 0q = nn / 0D */
name|count_leading_zeros
argument_list|(
name|bm
argument_list|,
name|d0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bm
operator|!=
literal|0
condition|)
block|{
comment|/* Normalize, i.e. make the most significant bit of the 		 denominator set.  */
name|d0
operator|=
name|d0
operator|<<
name|bm
expr_stmt|;
name|n1
operator|=
operator|(
name|n1
operator|<<
name|bm
operator|)
operator||
operator|(
name|n0
operator|>>
operator|(
name|W_TYPE_SIZE
operator|-
name|bm
operator|)
operator|)
expr_stmt|;
name|n0
operator|=
name|n0
operator|<<
name|bm
expr_stmt|;
block|}
name|udiv_qrnnd
argument_list|(
name|q0
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|d0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|q1
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Remainder in n0>> bm.  */
end_comment

begin_block
unit|}       else
block|{
comment|/* qq = NN / 0d */
if|if
condition|(
name|d0
operator|==
literal|0
condition|)
name|d0
operator|=
literal|1
operator|/
name|d0
expr_stmt|;
comment|/* Divide intentionally by zero.  */
name|count_leading_zeros
argument_list|(
name|bm
argument_list|,
name|d0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bm
operator|==
literal|0
condition|)
block|{
comment|/* From (n1>= d0) /\ (the most significant bit of d0 is set), 		 conclude (the most significant bit of n1 is set) /\ (the 		 leading quotient digit q1 = 1).  		 This special case is necessary, not an optimization. 		 (Shifts counts of W_TYPE_SIZE are undefined.)  */
name|n1
operator|-=
name|d0
expr_stmt|;
name|q1
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Normalize.  */
name|b
operator|=
name|W_TYPE_SIZE
operator|-
name|bm
expr_stmt|;
name|d0
operator|=
name|d0
operator|<<
name|bm
expr_stmt|;
name|n2
operator|=
name|n1
operator|>>
name|b
expr_stmt|;
name|n1
operator|=
operator|(
name|n1
operator|<<
name|bm
operator|)
operator||
operator|(
name|n0
operator|>>
name|b
operator|)
expr_stmt|;
name|n0
operator|=
name|n0
operator|<<
name|bm
expr_stmt|;
name|udiv_qrnnd
argument_list|(
name|q1
argument_list|,
name|n1
argument_list|,
name|n2
argument_list|,
name|n1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
block|}
comment|/* n1 != d0...  */
name|udiv_qrnnd
argument_list|(
name|q0
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|d0
argument_list|)
expr_stmt|;
comment|/* Remainder in n0>> bm.  */
block|}
end_block

begin_if
if|if
condition|(
name|rp
operator|!=
literal|0
condition|)
block|{
name|rr
operator|.
name|s
operator|.
name|low
operator|=
name|n0
operator|>>
name|bm
expr_stmt|;
name|rr
operator|.
name|s
operator|.
name|high
operator|=
literal|0
expr_stmt|;
operator|*
name|rp
operator|=
name|rr
operator|.
name|ll
expr_stmt|;
block|}
end_if

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* UDIV_NEEDS_NORMALIZATION */
end_comment

begin_block
unit|else
block|{
if|if
condition|(
name|d1
operator|>
name|n1
condition|)
block|{
comment|/* 00 = nn / DD */
name|q0
operator|=
literal|0
expr_stmt|;
name|q1
operator|=
literal|0
expr_stmt|;
comment|/* Remainder in n1n0.  */
if|if
condition|(
name|rp
operator|!=
literal|0
condition|)
block|{
name|rr
operator|.
name|s
operator|.
name|low
operator|=
name|n0
expr_stmt|;
name|rr
operator|.
name|s
operator|.
name|high
operator|=
name|n1
expr_stmt|;
operator|*
name|rp
operator|=
name|rr
operator|.
name|ll
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 0q = NN / dd */
name|count_leading_zeros
argument_list|(
name|bm
argument_list|,
name|d1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bm
operator|==
literal|0
condition|)
block|{
comment|/* From (n1>= d1) /\ (the most significant bit of d1 is set), 		 conclude (the most significant bit of n1 is set) /\ (the 		 quotient digit q0 = 0 or 1).  		 This special case is necessary, not an optimization.  */
comment|/* The condition on the next line takes advantage of that 		 n1>= d1 (true due to program flow).  */
if|if
condition|(
name|n1
operator|>
name|d1
operator|||
name|n0
operator|>=
name|d0
condition|)
block|{
name|q0
operator|=
literal|1
expr_stmt|;
name|sub_ddmmss
argument_list|(
name|n1
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|d1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
block|}
else|else
name|q0
operator|=
literal|0
expr_stmt|;
name|q1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rp
operator|!=
literal|0
condition|)
block|{
name|rr
operator|.
name|s
operator|.
name|low
operator|=
name|n0
expr_stmt|;
name|rr
operator|.
name|s
operator|.
name|high
operator|=
name|n1
expr_stmt|;
operator|*
name|rp
operator|=
name|rr
operator|.
name|ll
expr_stmt|;
block|}
block|}
else|else
block|{
name|UWtype
name|m1
decl_stmt|,
name|m0
decl_stmt|;
comment|/* Normalize.  */
name|b
operator|=
name|W_TYPE_SIZE
operator|-
name|bm
expr_stmt|;
name|d1
operator|=
operator|(
name|d1
operator|<<
name|bm
operator|)
operator||
operator|(
name|d0
operator|>>
name|b
operator|)
expr_stmt|;
name|d0
operator|=
name|d0
operator|<<
name|bm
expr_stmt|;
name|n2
operator|=
name|n1
operator|>>
name|b
expr_stmt|;
name|n1
operator|=
operator|(
name|n1
operator|<<
name|bm
operator|)
operator||
operator|(
name|n0
operator|>>
name|b
operator|)
expr_stmt|;
name|n0
operator|=
name|n0
operator|<<
name|bm
expr_stmt|;
name|udiv_qrnnd
argument_list|(
name|q0
argument_list|,
name|n1
argument_list|,
name|n2
argument_list|,
name|n1
argument_list|,
name|d1
argument_list|)
expr_stmt|;
name|umul_ppmm
argument_list|(
name|m1
argument_list|,
name|m0
argument_list|,
name|q0
argument_list|,
name|d0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|>
name|n1
operator|||
operator|(
name|m1
operator|==
name|n1
operator|&&
name|m0
operator|>
name|n0
operator|)
condition|)
block|{
name|q0
operator|--
expr_stmt|;
name|sub_ddmmss
argument_list|(
name|m1
argument_list|,
name|m0
argument_list|,
name|m1
argument_list|,
name|m0
argument_list|,
name|d1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
block|}
name|q1
operator|=
literal|0
expr_stmt|;
comment|/* Remainder in (n1n0 - m1m0)>> bm.  */
if|if
condition|(
name|rp
operator|!=
literal|0
condition|)
block|{
name|sub_ddmmss
argument_list|(
name|n1
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|m1
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|rr
operator|.
name|s
operator|.
name|low
operator|=
operator|(
name|n1
operator|<<
name|b
operator|)
operator||
operator|(
name|n0
operator|>>
name|bm
operator|)
expr_stmt|;
name|rr
operator|.
name|s
operator|.
name|high
operator|=
name|n1
operator|>>
name|bm
expr_stmt|;
operator|*
name|rp
operator|=
name|rr
operator|.
name|ll
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_expr_stmt
name|ww
operator|.
name|s
operator|.
name|low
operator|=
name|q0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ww
operator|.
name|s
operator|.
name|high
operator|=
name|q1
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|ww
operator|.
name|ll
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_divdi3
end_ifdef

begin_macro
unit|DWtype
name|__divdi3
argument_list|(
argument|DWtype u
argument_list|,
argument|DWtype v
argument_list|)
end_macro

begin_block
block|{
name|word_type
name|c
init|=
literal|0
decl_stmt|;
name|DWunion
name|uu
decl_stmt|,
name|vv
decl_stmt|;
name|DWtype
name|w
decl_stmt|;
name|uu
operator|.
name|ll
operator|=
name|u
expr_stmt|;
name|vv
operator|.
name|ll
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|high
operator|<
literal|0
condition|)
name|c
operator|=
operator|~
name|c
operator|,
name|uu
operator|.
name|ll
operator|=
operator|-
name|uu
operator|.
name|ll
expr_stmt|;
if|if
condition|(
name|vv
operator|.
name|s
operator|.
name|high
operator|<
literal|0
condition|)
name|c
operator|=
operator|~
name|c
operator|,
name|vv
operator|.
name|ll
operator|=
operator|-
name|vv
operator|.
name|ll
expr_stmt|;
name|w
operator|=
name|__udivmoddi4
argument_list|(
name|uu
operator|.
name|ll
argument_list|,
name|vv
operator|.
name|ll
argument_list|,
operator|(
name|UDWtype
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|w
operator|=
operator|-
name|w
expr_stmt|;
return|return
name|w
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_moddi3
end_ifdef

begin_function
name|DWtype
name|__moddi3
parameter_list|(
name|DWtype
name|u
parameter_list|,
name|DWtype
name|v
parameter_list|)
block|{
name|word_type
name|c
init|=
literal|0
decl_stmt|;
name|DWunion
name|uu
decl_stmt|,
name|vv
decl_stmt|;
name|DWtype
name|w
decl_stmt|;
name|uu
operator|.
name|ll
operator|=
name|u
expr_stmt|;
name|vv
operator|.
name|ll
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|high
operator|<
literal|0
condition|)
name|c
operator|=
operator|~
name|c
operator|,
name|uu
operator|.
name|ll
operator|=
operator|-
name|uu
operator|.
name|ll
expr_stmt|;
if|if
condition|(
name|vv
operator|.
name|s
operator|.
name|high
operator|<
literal|0
condition|)
name|vv
operator|.
name|ll
operator|=
operator|-
name|vv
operator|.
name|ll
expr_stmt|;
operator|(
name|void
operator|)
name|__udivmoddi4
argument_list|(
name|uu
operator|.
name|ll
argument_list|,
name|vv
operator|.
name|ll
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|w
operator|=
operator|-
name|w
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_umoddi3
end_ifdef

begin_function
name|UDWtype
name|__umoddi3
parameter_list|(
name|UDWtype
name|u
parameter_list|,
name|UDWtype
name|v
parameter_list|)
block|{
name|UDWtype
name|w
decl_stmt|;
operator|(
name|void
operator|)
name|__udivmoddi4
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_udivdi3
end_ifdef

begin_function
name|UDWtype
name|__udivdi3
parameter_list|(
name|UDWtype
name|n
parameter_list|,
name|UDWtype
name|d
parameter_list|)
block|{
return|return
name|__udivmoddi4
argument_list|(
name|n
argument_list|,
name|d
argument_list|,
operator|(
name|UDWtype
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_cmpdi2
end_ifdef

begin_function
name|word_type
name|__cmpdi2
parameter_list|(
name|DWtype
name|a
parameter_list|,
name|DWtype
name|b
parameter_list|)
block|{
name|DWunion
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|ll
operator|=
name|a
operator|,
name|bu
operator|.
name|ll
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|au
operator|.
name|s
operator|.
name|high
operator|<
name|bu
operator|.
name|s
operator|.
name|high
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|au
operator|.
name|s
operator|.
name|high
operator|>
name|bu
operator|.
name|s
operator|.
name|high
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|(
name|UWtype
operator|)
name|au
operator|.
name|s
operator|.
name|low
operator|<
operator|(
name|UWtype
operator|)
name|bu
operator|.
name|s
operator|.
name|low
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|UWtype
operator|)
name|au
operator|.
name|s
operator|.
name|low
operator|>
operator|(
name|UWtype
operator|)
name|bu
operator|.
name|s
operator|.
name|low
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_ucmpdi2
end_ifdef

begin_function
name|word_type
name|__ucmpdi2
parameter_list|(
name|DWtype
name|a
parameter_list|,
name|DWtype
name|b
parameter_list|)
block|{
name|DWunion
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|ll
operator|=
name|a
operator|,
name|bu
operator|.
name|ll
operator|=
name|b
expr_stmt|;
if|if
condition|(
operator|(
name|UWtype
operator|)
name|au
operator|.
name|s
operator|.
name|high
operator|<
operator|(
name|UWtype
operator|)
name|bu
operator|.
name|s
operator|.
name|high
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|UWtype
operator|)
name|au
operator|.
name|s
operator|.
name|high
operator|>
operator|(
name|UWtype
operator|)
name|bu
operator|.
name|s
operator|.
name|high
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|(
name|UWtype
operator|)
name|au
operator|.
name|s
operator|.
name|low
operator|<
operator|(
name|UWtype
operator|)
name|bu
operator|.
name|s
operator|.
name|low
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|UWtype
operator|)
name|au
operator|.
name|s
operator|.
name|low
operator|>
operator|(
name|UWtype
operator|)
name|bu
operator|.
name|s
operator|.
name|low
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixunstfdi
argument_list|)
operator|&&
operator|(
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|128
operator|)
end_if

begin_define
define|#
directive|define
name|WORD_SIZE
value|(sizeof (Wtype) * BITS_PER_UNIT)
end_define

begin_define
define|#
directive|define
name|HIGH_WORD_COEFF
value|(((UDWtype) 1)<< WORD_SIZE)
end_define

begin_function
name|DWtype
name|__fixunstfDI
parameter_list|(
name|TFtype
name|a
parameter_list|)
block|{
name|TFtype
name|b
decl_stmt|;
name|UDWtype
name|v
decl_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Compute high word of result, as a flonum.  */
name|b
operator|=
operator|(
name|a
operator|/
name|HIGH_WORD_COEFF
operator|)
expr_stmt|;
comment|/* Convert that to fixed (but not to DWtype!),      and shift it into the high word.  */
name|v
operator|=
operator|(
name|UWtype
operator|)
name|b
expr_stmt|;
name|v
operator|<<=
name|WORD_SIZE
expr_stmt|;
comment|/* Remove high part from the TFtype, leaving the low part as flonum.  */
name|a
operator|-=
operator|(
name|TFtype
operator|)
name|v
expr_stmt|;
comment|/* Convert that to fixed (but not to DWtype!) and add it in.      Sometimes A comes out negative.  This is significant, since      A has more bits than a long int does.  */
if|if
condition|(
name|a
operator|<
literal|0
condition|)
name|v
operator|-=
call|(
name|UWtype
call|)
argument_list|(
operator|-
name|a
argument_list|)
expr_stmt|;
else|else
name|v
operator|+=
operator|(
name|UWtype
operator|)
name|a
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixtfdi
argument_list|)
operator|&&
operator|(
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|128
operator|)
end_if

begin_function
name|DWtype
name|__fixtfdi
parameter_list|(
name|TFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
operator|-
name|__fixunstfDI
argument_list|(
operator|-
name|a
argument_list|)
return|;
return|return
name|__fixunstfDI
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixunsxfdi
argument_list|)
operator|&&
operator|(
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|96
operator|)
end_if

begin_define
define|#
directive|define
name|WORD_SIZE
value|(sizeof (Wtype) * BITS_PER_UNIT)
end_define

begin_define
define|#
directive|define
name|HIGH_WORD_COEFF
value|(((UDWtype) 1)<< WORD_SIZE)
end_define

begin_function
name|DWtype
name|__fixunsxfDI
parameter_list|(
name|XFtype
name|a
parameter_list|)
block|{
name|XFtype
name|b
decl_stmt|;
name|UDWtype
name|v
decl_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Compute high word of result, as a flonum.  */
name|b
operator|=
operator|(
name|a
operator|/
name|HIGH_WORD_COEFF
operator|)
expr_stmt|;
comment|/* Convert that to fixed (but not to DWtype!),      and shift it into the high word.  */
name|v
operator|=
operator|(
name|UWtype
operator|)
name|b
expr_stmt|;
name|v
operator|<<=
name|WORD_SIZE
expr_stmt|;
comment|/* Remove high part from the XFtype, leaving the low part as flonum.  */
name|a
operator|-=
operator|(
name|XFtype
operator|)
name|v
expr_stmt|;
comment|/* Convert that to fixed (but not to DWtype!) and add it in.      Sometimes A comes out negative.  This is significant, since      A has more bits than a long int does.  */
if|if
condition|(
name|a
operator|<
literal|0
condition|)
name|v
operator|-=
call|(
name|UWtype
call|)
argument_list|(
operator|-
name|a
argument_list|)
expr_stmt|;
else|else
name|v
operator|+=
operator|(
name|UWtype
operator|)
name|a
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixxfdi
argument_list|)
operator|&&
operator|(
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|96
operator|)
end_if

begin_function
name|DWtype
name|__fixxfdi
parameter_list|(
name|XFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
operator|-
name|__fixunsxfDI
argument_list|(
operator|-
name|a
argument_list|)
return|;
return|return
name|__fixunsxfDI
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_fixunsdfdi
end_ifdef

begin_define
define|#
directive|define
name|WORD_SIZE
value|(sizeof (Wtype) * BITS_PER_UNIT)
end_define

begin_define
define|#
directive|define
name|HIGH_WORD_COEFF
value|(((UDWtype) 1)<< WORD_SIZE)
end_define

begin_function
name|DWtype
name|__fixunsdfDI
parameter_list|(
name|DFtype
name|a
parameter_list|)
block|{
name|DFtype
name|b
decl_stmt|;
name|UDWtype
name|v
decl_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Compute high word of result, as a flonum.  */
name|b
operator|=
operator|(
name|a
operator|/
name|HIGH_WORD_COEFF
operator|)
expr_stmt|;
comment|/* Convert that to fixed (but not to DWtype!),      and shift it into the high word.  */
name|v
operator|=
operator|(
name|UWtype
operator|)
name|b
expr_stmt|;
name|v
operator|<<=
name|WORD_SIZE
expr_stmt|;
comment|/* Remove high part from the DFtype, leaving the low part as flonum.  */
name|a
operator|-=
operator|(
name|DFtype
operator|)
name|v
expr_stmt|;
comment|/* Convert that to fixed (but not to DWtype!) and add it in.      Sometimes A comes out negative.  This is significant, since      A has more bits than a long int does.  */
if|if
condition|(
name|a
operator|<
literal|0
condition|)
name|v
operator|-=
call|(
name|UWtype
call|)
argument_list|(
operator|-
name|a
argument_list|)
expr_stmt|;
else|else
name|v
operator|+=
operator|(
name|UWtype
operator|)
name|a
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_fixdfdi
end_ifdef

begin_function
name|DWtype
name|__fixdfdi
parameter_list|(
name|DFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
operator|-
name|__fixunsdfDI
argument_list|(
operator|-
name|a
argument_list|)
return|;
return|return
name|__fixunsdfDI
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_fixunssfdi
end_ifdef

begin_define
define|#
directive|define
name|WORD_SIZE
value|(sizeof (Wtype) * BITS_PER_UNIT)
end_define

begin_define
define|#
directive|define
name|HIGH_WORD_COEFF
value|(((UDWtype) 1)<< WORD_SIZE)
end_define

begin_function
name|DWtype
name|__fixunssfDI
parameter_list|(
name|SFtype
name|original_a
parameter_list|)
block|{
comment|/* Convert the SFtype to a DFtype, because that is surely not going      to lose any bits.  Some day someone else can write a faster version      that avoids converting to DFtype, and verify it really works right.  */
name|DFtype
name|a
init|=
name|original_a
decl_stmt|;
name|DFtype
name|b
decl_stmt|;
name|UDWtype
name|v
decl_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Compute high word of result, as a flonum.  */
name|b
operator|=
operator|(
name|a
operator|/
name|HIGH_WORD_COEFF
operator|)
expr_stmt|;
comment|/* Convert that to fixed (but not to DWtype!),      and shift it into the high word.  */
name|v
operator|=
operator|(
name|UWtype
operator|)
name|b
expr_stmt|;
name|v
operator|<<=
name|WORD_SIZE
expr_stmt|;
comment|/* Remove high part from the DFtype, leaving the low part as flonum.  */
name|a
operator|-=
operator|(
name|DFtype
operator|)
name|v
expr_stmt|;
comment|/* Convert that to fixed (but not to DWtype!) and add it in.      Sometimes A comes out negative.  This is significant, since      A has more bits than a long int does.  */
if|if
condition|(
name|a
operator|<
literal|0
condition|)
name|v
operator|-=
call|(
name|UWtype
call|)
argument_list|(
operator|-
name|a
argument_list|)
expr_stmt|;
else|else
name|v
operator|+=
operator|(
name|UWtype
operator|)
name|a
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_fixsfdi
end_ifdef

begin_function
name|DWtype
name|__fixsfdi
parameter_list|(
name|SFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
operator|-
name|__fixunssfDI
argument_list|(
operator|-
name|a
argument_list|)
return|;
return|return
name|__fixunssfDI
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_floatdixf
argument_list|)
operator|&&
operator|(
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|96
operator|)
end_if

begin_define
define|#
directive|define
name|WORD_SIZE
value|(sizeof (Wtype) * BITS_PER_UNIT)
end_define

begin_define
define|#
directive|define
name|HIGH_HALFWORD_COEFF
value|(((UDWtype) 1)<< (WORD_SIZE / 2))
end_define

begin_define
define|#
directive|define
name|HIGH_WORD_COEFF
value|(((UDWtype) 1)<< WORD_SIZE)
end_define

begin_function
name|XFtype
name|__floatdixf
parameter_list|(
name|DWtype
name|u
parameter_list|)
block|{
name|XFtype
name|d
decl_stmt|;
name|d
operator|=
call|(
name|Wtype
call|)
argument_list|(
name|u
operator|>>
name|WORD_SIZE
argument_list|)
expr_stmt|;
name|d
operator|*=
name|HIGH_HALFWORD_COEFF
expr_stmt|;
name|d
operator|*=
name|HIGH_HALFWORD_COEFF
expr_stmt|;
name|d
operator|+=
call|(
name|UWtype
call|)
argument_list|(
name|u
operator|&
operator|(
name|HIGH_WORD_COEFF
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_floatditf
argument_list|)
operator|&&
operator|(
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|128
operator|)
end_if

begin_define
define|#
directive|define
name|WORD_SIZE
value|(sizeof (Wtype) * BITS_PER_UNIT)
end_define

begin_define
define|#
directive|define
name|HIGH_HALFWORD_COEFF
value|(((UDWtype) 1)<< (WORD_SIZE / 2))
end_define

begin_define
define|#
directive|define
name|HIGH_WORD_COEFF
value|(((UDWtype) 1)<< WORD_SIZE)
end_define

begin_function
name|TFtype
name|__floatditf
parameter_list|(
name|DWtype
name|u
parameter_list|)
block|{
name|TFtype
name|d
decl_stmt|;
name|d
operator|=
call|(
name|Wtype
call|)
argument_list|(
name|u
operator|>>
name|WORD_SIZE
argument_list|)
expr_stmt|;
name|d
operator|*=
name|HIGH_HALFWORD_COEFF
expr_stmt|;
name|d
operator|*=
name|HIGH_HALFWORD_COEFF
expr_stmt|;
name|d
operator|+=
call|(
name|UWtype
call|)
argument_list|(
name|u
operator|&
operator|(
name|HIGH_WORD_COEFF
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_floatdidf
end_ifdef

begin_define
define|#
directive|define
name|WORD_SIZE
value|(sizeof (Wtype) * BITS_PER_UNIT)
end_define

begin_define
define|#
directive|define
name|HIGH_HALFWORD_COEFF
value|(((UDWtype) 1)<< (WORD_SIZE / 2))
end_define

begin_define
define|#
directive|define
name|HIGH_WORD_COEFF
value|(((UDWtype) 1)<< WORD_SIZE)
end_define

begin_function
name|DFtype
name|__floatdidf
parameter_list|(
name|DWtype
name|u
parameter_list|)
block|{
name|DFtype
name|d
decl_stmt|;
name|d
operator|=
call|(
name|Wtype
call|)
argument_list|(
name|u
operator|>>
name|WORD_SIZE
argument_list|)
expr_stmt|;
name|d
operator|*=
name|HIGH_HALFWORD_COEFF
expr_stmt|;
name|d
operator|*=
name|HIGH_HALFWORD_COEFF
expr_stmt|;
name|d
operator|+=
call|(
name|UWtype
call|)
argument_list|(
name|u
operator|&
operator|(
name|HIGH_WORD_COEFF
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_floatdisf
end_ifdef

begin_define
define|#
directive|define
name|WORD_SIZE
value|(sizeof (Wtype) * BITS_PER_UNIT)
end_define

begin_define
define|#
directive|define
name|HIGH_HALFWORD_COEFF
value|(((UDWtype) 1)<< (WORD_SIZE / 2))
end_define

begin_define
define|#
directive|define
name|HIGH_WORD_COEFF
value|(((UDWtype) 1)<< WORD_SIZE)
end_define

begin_define
define|#
directive|define
name|DI_SIZE
value|(sizeof (DWtype) * BITS_PER_UNIT)
end_define

begin_define
define|#
directive|define
name|DF_SIZE
value|DBL_MANT_DIG
end_define

begin_define
define|#
directive|define
name|SF_SIZE
value|FLT_MANT_DIG
end_define

begin_function
name|SFtype
name|__floatdisf
parameter_list|(
name|DWtype
name|u
parameter_list|)
block|{
comment|/* Do the calculation in DFmode      so that we don't lose any of the precision of the high word      while multiplying it.  */
name|DFtype
name|f
decl_stmt|;
comment|/* Protect against double-rounding error.      Represent any low-order bits, that might be truncated in DFmode,      by a bit that won't be lost.  The bit can go in anywhere below the      rounding position of the SFmode.  A fixed mask and bit position      handles all usual configurations.  It doesn't handle the case      of 128-bit DImode, however.  */
if|if
condition|(
name|DF_SIZE
operator|<
name|DI_SIZE
operator|&&
name|DF_SIZE
operator|>
operator|(
name|DI_SIZE
operator|-
name|DF_SIZE
operator|+
name|SF_SIZE
operator|)
condition|)
block|{
define|#
directive|define
name|REP_BIT
value|((UDWtype) 1<< (DI_SIZE - DF_SIZE))
if|if
condition|(
operator|!
operator|(
operator|-
operator|(
operator|(
name|DWtype
operator|)
literal|1
operator|<<
name|DF_SIZE
operator|)
operator|<
name|u
operator|&&
name|u
operator|<
operator|(
operator|(
name|DWtype
operator|)
literal|1
operator|<<
name|DF_SIZE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|UDWtype
operator|)
name|u
operator|&
operator|(
name|REP_BIT
operator|-
literal|1
operator|)
condition|)
block|{
name|u
operator|&=
operator|~
operator|(
name|REP_BIT
operator|-
literal|1
operator|)
expr_stmt|;
name|u
operator||=
name|REP_BIT
expr_stmt|;
block|}
block|}
block|}
name|f
operator|=
call|(
name|Wtype
call|)
argument_list|(
name|u
operator|>>
name|WORD_SIZE
argument_list|)
expr_stmt|;
name|f
operator|*=
name|HIGH_HALFWORD_COEFF
expr_stmt|;
name|f
operator|*=
name|HIGH_HALFWORD_COEFF
expr_stmt|;
name|f
operator|+=
call|(
name|UWtype
call|)
argument_list|(
name|u
operator|&
operator|(
name|HIGH_WORD_COEFF
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SFtype
operator|)
name|f
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixunsxfsi
argument_list|)
operator|&&
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|96
end_if

begin_comment
comment|/* Reenable the normal types, in case limits.h needs them.  */
end_comment

begin_undef
undef|#
directive|undef
name|char
end_undef

begin_undef
undef|#
directive|undef
name|short
end_undef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_undef
undef|#
directive|undef
name|long
end_undef

begin_undef
undef|#
directive|undef
name|unsigned
end_undef

begin_undef
undef|#
directive|undef
name|float
end_undef

begin_undef
undef|#
directive|undef
name|double
end_undef

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_function
name|UWtype
name|__fixunsxfSI
parameter_list|(
name|XFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|>=
operator|-
operator|(
name|DFtype
operator|)
name|Wtype_MIN
condition|)
return|return
call|(
name|Wtype
call|)
argument_list|(
name|a
operator|+
name|Wtype_MIN
argument_list|)
operator|-
name|Wtype_MIN
return|;
return|return
operator|(
name|Wtype
operator|)
name|a
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_fixunsdfsi
end_ifdef

begin_comment
comment|/* Reenable the normal types, in case limits.h needs them.  */
end_comment

begin_undef
undef|#
directive|undef
name|char
end_undef

begin_undef
undef|#
directive|undef
name|short
end_undef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_undef
undef|#
directive|undef
name|long
end_undef

begin_undef
undef|#
directive|undef
name|unsigned
end_undef

begin_undef
undef|#
directive|undef
name|float
end_undef

begin_undef
undef|#
directive|undef
name|double
end_undef

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_function
name|UWtype
name|__fixunsdfSI
parameter_list|(
name|DFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|>=
operator|-
operator|(
name|DFtype
operator|)
name|Wtype_MIN
condition|)
return|return
call|(
name|Wtype
call|)
argument_list|(
name|a
operator|+
name|Wtype_MIN
argument_list|)
operator|-
name|Wtype_MIN
return|;
return|return
operator|(
name|Wtype
operator|)
name|a
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_fixunssfsi
end_ifdef

begin_comment
comment|/* Reenable the normal types, in case limits.h needs them.  */
end_comment

begin_undef
undef|#
directive|undef
name|char
end_undef

begin_undef
undef|#
directive|undef
name|short
end_undef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_undef
undef|#
directive|undef
name|long
end_undef

begin_undef
undef|#
directive|undef
name|unsigned
end_undef

begin_undef
undef|#
directive|undef
name|float
end_undef

begin_undef
undef|#
directive|undef
name|double
end_undef

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_function
name|UWtype
name|__fixunssfSI
parameter_list|(
name|SFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|>=
operator|-
operator|(
name|SFtype
operator|)
name|Wtype_MIN
condition|)
return|return
call|(
name|Wtype
call|)
argument_list|(
name|a
operator|+
name|Wtype_MIN
argument_list|)
operator|-
name|Wtype_MIN
return|;
return|return
operator|(
name|Wtype
operator|)
name|a
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* From here on down, the routines use normal data types.  */
end_comment

begin_define
define|#
directive|define
name|SItype
value|bogus_type
end_define

begin_define
define|#
directive|define
name|USItype
value|bogus_type
end_define

begin_define
define|#
directive|define
name|DItype
value|bogus_type
end_define

begin_define
define|#
directive|define
name|UDItype
value|bogus_type
end_define

begin_define
define|#
directive|define
name|SFtype
value|bogus_type
end_define

begin_define
define|#
directive|define
name|DFtype
value|bogus_type
end_define

begin_undef
undef|#
directive|undef
name|Wtype
end_undef

begin_undef
undef|#
directive|undef
name|UWtype
end_undef

begin_undef
undef|#
directive|undef
name|HWtype
end_undef

begin_undef
undef|#
directive|undef
name|UHWtype
end_undef

begin_undef
undef|#
directive|undef
name|DWtype
end_undef

begin_undef
undef|#
directive|undef
name|UDWtype
end_undef

begin_undef
undef|#
directive|undef
name|char
end_undef

begin_undef
undef|#
directive|undef
name|short
end_undef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_undef
undef|#
directive|undef
name|long
end_undef

begin_undef
undef|#
directive|undef
name|unsigned
end_undef

begin_undef
undef|#
directive|undef
name|float
end_undef

begin_undef
undef|#
directive|undef
name|double
end_undef

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L__gcc_bcmp
end_ifdef

begin_comment
comment|/* Like bcmp except the sign is meaningful.    Result is negative if S1 is less than S2,    positive if S1 is greater, 0 if S1 and S2 are equal.  */
end_comment

begin_function
name|int
name|__gcc_bcmp
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|s2
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|unsigned
name|char
name|c1
init|=
operator|*
name|s1
operator|++
decl_stmt|,
name|c2
init|=
operator|*
name|s2
operator|++
decl_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
name|c1
operator|-
name|c2
return|;
name|size
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* __eprintf used to be used by GCC's private version of<assert.h>.    We no longer provide that header, but this routine remains in libgcc.a    for binary backward compatibility.  Note that it is not included in    the shared version of libgcc.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|L_eprintf
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|inhibit_libc
end_ifndef

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_comment
comment|/* Avoid errors if stdio.h and our stddef.h mismatch.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
name|void
name|__eprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
specifier|const
name|char
modifier|*
name|expression
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|expression
argument_list|,
name|line
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_bb
end_ifdef

begin_struct
struct|struct
name|bb_function_info
block|{
name|long
name|checksum
decl_stmt|;
name|int
name|arc_count
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Structure emitted by --profile-arcs  */
end_comment

begin_struct
struct|struct
name|bb
block|{
name|long
name|zero_word
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|gcov_type
modifier|*
name|counts
decl_stmt|;
name|long
name|ncounts
decl_stmt|;
name|struct
name|bb
modifier|*
name|next
decl_stmt|;
comment|/* Older GCC's did not emit these fields.  */
name|long
name|sizeof_bb
decl_stmt|;
name|struct
name|bb_function_info
modifier|*
name|function_infos
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|inhibit_libc
end_ifndef

begin_comment
comment|/* Arc profile dumper. Requires atexit and stdio.  */
end_comment

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_comment
comment|/* Avoid errors if stdio.h and our stddef.h mismatch.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"gcov-io.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_HAS_F_SETLKW
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Chain of per-object file bb structures.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bb
modifier|*
name|bb_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dump the coverage counts. We merge with existing counts when    possible, to avoid growing the .da files ad infinitum.  */
end_comment

begin_function
name|void
name|__bb_exit_func
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bb
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gcov_type
name|program_sum
init|=
literal|0
decl_stmt|;
name|gcov_type
name|program_max
init|=
literal|0
decl_stmt|;
name|long
name|program_arcs
init|=
literal|0
decl_stmt|;
name|gcov_type
name|merged_sum
init|=
literal|0
decl_stmt|;
name|gcov_type
name|merged_max
init|=
literal|0
decl_stmt|;
name|long
name|merged_arcs
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TARGET_HAS_F_SETLKW
argument_list|)
name|struct
name|flock
name|s_flock
decl_stmt|;
name|s_flock
operator|.
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
name|s_flock
operator|.
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
name|s_flock
operator|.
name|l_start
operator|=
literal|0
expr_stmt|;
name|s_flock
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
comment|/* Until EOF.  */
name|s_flock
operator|.
name|l_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Non-merged stats for this program.  */
for|for
control|(
name|ptr
operator|=
name|bb_head
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ptr
operator|->
name|ncounts
condition|;
name|i
operator|++
control|)
block|{
name|program_sum
operator|+=
name|ptr
operator|->
name|counts
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|counts
index|[
name|i
index|]
operator|>
name|program_max
condition|)
name|program_max
operator|=
name|ptr
operator|->
name|counts
index|[
name|i
index|]
expr_stmt|;
block|}
name|program_arcs
operator|+=
name|ptr
operator|->
name|ncounts
expr_stmt|;
block|}
for|for
control|(
name|ptr
operator|=
name|bb_head
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|FILE
modifier|*
name|da_file
decl_stmt|;
name|gcov_type
name|object_max
init|=
literal|0
decl_stmt|;
name|gcov_type
name|object_sum
init|=
literal|0
decl_stmt|;
name|long
name|object_functions
init|=
literal|0
decl_stmt|;
name|int
name|merging
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|bb_function_info
modifier|*
name|fn_info
decl_stmt|;
name|gcov_type
modifier|*
name|count_ptr
decl_stmt|;
comment|/* Open for modification */
name|da_file
operator|=
name|fopen
argument_list|(
name|ptr
operator|->
name|filename
argument_list|,
literal|"r+b"
argument_list|)
expr_stmt|;
if|if
condition|(
name|da_file
condition|)
name|merging
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* Try for appending */
name|da_file
operator|=
name|fopen
argument_list|(
name|ptr
operator|->
name|filename
argument_list|,
literal|"ab"
argument_list|)
expr_stmt|;
comment|/* Some old systems might not allow the 'b' mode modifier.              Therefore, try to open without it.  This can lead to a              race condition so that when you delete and re-create the              file, the file might be opened in text mode, but then,              you shouldn't delete the file in the first place.  */
if|if
condition|(
operator|!
name|da_file
condition|)
name|da_file
operator|=
name|fopen
argument_list|(
name|ptr
operator|->
name|filename
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|da_file
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arc profiling: Can't open output file %s.\n"
argument_list|,
name|ptr
operator|->
name|filename
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|filename
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TARGET_HAS_F_SETLKW
argument_list|)
comment|/* After a fork, another process might try to read and/or write          the same file simultanously.  So if we can, lock the file to          avoid race conditions.  */
while|while
condition|(
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|da_file
argument_list|)
argument_list|,
name|F_SETLKW
argument_list|,
operator|&
name|s_flock
argument_list|)
operator|&&
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
endif|#
directive|endif
for|for
control|(
name|fn_info
operator|=
name|ptr
operator|->
name|function_infos
init|;
name|fn_info
operator|->
name|arc_count
operator|!=
operator|-
literal|1
condition|;
name|fn_info
operator|++
control|)
name|object_functions
operator|++
expr_stmt|;
if|if
condition|(
name|merging
condition|)
block|{
comment|/* Merge data from file.  */
name|long
name|tmp_long
decl_stmt|;
name|gcov_type
name|tmp_gcov
decl_stmt|;
if|if
condition|(
comment|/* magic */
operator|(
name|__read_long
argument_list|(
operator|&
name|tmp_long
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
operator|||
name|tmp_long
operator|!=
operator|-
literal|123l
operator|)
comment|/* functions in object file.  */
operator|||
operator|(
name|__read_long
argument_list|(
operator|&
name|tmp_long
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
operator|||
name|tmp_long
operator|!=
name|object_functions
operator|)
comment|/* extension block, skipped */
operator|||
operator|(
name|__read_long
argument_list|(
operator|&
name|tmp_long
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
operator|||
name|fseek
argument_list|(
name|da_file
argument_list|,
name|tmp_long
argument_list|,
name|SEEK_CUR
argument_list|)
operator|)
condition|)
block|{
name|read_error
label|:
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arc profiling: Error merging output file %s.\n"
argument_list|,
name|ptr
operator|->
name|filename
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|da_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Merge execution counts for each function.  */
name|count_ptr
operator|=
name|ptr
operator|->
name|counts
expr_stmt|;
for|for
control|(
name|fn_info
operator|=
name|ptr
operator|->
name|function_infos
init|;
name|fn_info
operator|->
name|arc_count
operator|!=
operator|-
literal|1
condition|;
name|fn_info
operator|++
control|)
block|{
if|if
condition|(
comment|/* function name delim */
operator|(
name|__read_long
argument_list|(
operator|&
name|tmp_long
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
operator|||
name|tmp_long
operator|!=
operator|-
literal|1
operator|)
comment|/* function name length */
operator|||
operator|(
name|__read_long
argument_list|(
operator|&
name|tmp_long
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
operator|||
name|tmp_long
operator|!=
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|fn_info
operator|->
name|name
argument_list|)
operator|)
comment|/* skip string */
operator|||
name|fseek
argument_list|(
name|da_file
argument_list|,
operator|(
operator|(
name|tmp_long
operator|+
literal|1
operator|)
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
argument_list|,
name|SEEK_CUR
argument_list|)
comment|/* function name delim */
operator|||
operator|(
name|__read_long
argument_list|(
operator|&
name|tmp_long
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
operator|||
name|tmp_long
operator|!=
operator|-
literal|1
operator|)
condition|)
goto|goto
name|read_error
goto|;
if|if
condition|(
comment|/* function checksum */
operator|(
name|__read_long
argument_list|(
operator|&
name|tmp_long
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
operator|||
name|tmp_long
operator|!=
name|fn_info
operator|->
name|checksum
operator|)
comment|/* arc count */
operator|||
operator|(
name|__read_long
argument_list|(
operator|&
name|tmp_long
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
operator|||
name|tmp_long
operator|!=
name|fn_info
operator|->
name|arc_count
operator|)
condition|)
goto|goto
name|read_error
goto|;
for|for
control|(
name|i
operator|=
name|fn_info
operator|->
name|arc_count
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|count_ptr
operator|++
control|)
if|if
condition|(
name|__read_gcov_type
argument_list|(
operator|&
name|tmp_gcov
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
condition|)
goto|goto
name|read_error
goto|;
else|else
operator|*
name|count_ptr
operator|+=
name|tmp_gcov
expr_stmt|;
block|}
block|}
name|fseek
argument_list|(
name|da_file
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate the per-object statistics.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ptr
operator|->
name|ncounts
condition|;
name|i
operator|++
control|)
block|{
name|object_sum
operator|+=
name|ptr
operator|->
name|counts
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|counts
index|[
name|i
index|]
operator|>
name|object_max
condition|)
name|object_max
operator|=
name|ptr
operator|->
name|counts
index|[
name|i
index|]
expr_stmt|;
block|}
name|merged_sum
operator|+=
name|object_sum
expr_stmt|;
if|if
condition|(
name|merged_max
operator|<
name|object_max
condition|)
name|merged_max
operator|=
name|object_max
expr_stmt|;
name|merged_arcs
operator|+=
name|ptr
operator|->
name|ncounts
expr_stmt|;
comment|/* Write out the data.  */
if|if
condition|(
comment|/* magic */
name|__write_long
argument_list|(
operator|-
literal|123
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
comment|/* number of functions in object file.  */
operator|||
name|__write_long
argument_list|(
name|object_functions
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
comment|/* length of extra data in bytes.  */
operator|||
name|__write_long
argument_list|(
operator|(
literal|4
operator|+
literal|8
operator|+
literal|8
operator|)
operator|+
operator|(
literal|4
operator|+
literal|8
operator|+
literal|8
operator|)
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
comment|/* whole program statistics. If merging write per-object 	     now, rewrite later */
comment|/* number of instrumented arcs.  */
operator|||
name|__write_long
argument_list|(
name|merging
condition|?
name|ptr
operator|->
name|ncounts
else|:
name|program_arcs
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
comment|/* sum of counters.  */
operator|||
name|__write_gcov_type
argument_list|(
name|merging
condition|?
name|object_sum
else|:
name|program_sum
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
comment|/* maximal counter.  */
operator|||
name|__write_gcov_type
argument_list|(
name|merging
condition|?
name|object_max
else|:
name|program_max
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
comment|/* per-object statistics.  */
comment|/* number of counters.  */
operator|||
name|__write_long
argument_list|(
name|ptr
operator|->
name|ncounts
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
comment|/* sum of counters.  */
operator|||
name|__write_gcov_type
argument_list|(
name|object_sum
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
comment|/* maximal counter.  */
operator|||
name|__write_gcov_type
argument_list|(
name|object_max
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|write_error
label|:
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arc profiling: Error writing output file %s.\n"
argument_list|,
name|ptr
operator|->
name|filename
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Write execution counts for each function.  */
name|count_ptr
operator|=
name|ptr
operator|->
name|counts
expr_stmt|;
for|for
control|(
name|fn_info
operator|=
name|ptr
operator|->
name|function_infos
init|;
name|fn_info
operator|->
name|arc_count
operator|!=
operator|-
literal|1
condition|;
name|fn_info
operator|++
control|)
block|{
if|if
condition|(
name|__write_gcov_string
argument_list|(
name|fn_info
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|fn_info
operator|->
name|name
argument_list|)
argument_list|,
name|da_file
argument_list|,
operator|-
literal|1
argument_list|)
operator|||
name|__write_long
argument_list|(
name|fn_info
operator|->
name|checksum
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
operator|||
name|__write_long
argument_list|(
name|fn_info
operator|->
name|arc_count
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
condition|)
goto|goto
name|write_error
goto|;
for|for
control|(
name|i
operator|=
name|fn_info
operator|->
name|arc_count
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|count_ptr
operator|++
control|)
if|if
condition|(
name|__write_gcov_type
argument_list|(
operator|*
name|count_ptr
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
condition|)
goto|goto
name|write_error
goto|;
comment|/* RIP Edsger Dijkstra */
block|}
block|}
if|if
condition|(
name|fclose
argument_list|(
name|da_file
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arc profiling: Error closing output file %s.\n"
argument_list|,
name|ptr
operator|->
name|filename
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|||
operator|!
name|merging
condition|)
name|ptr
operator|->
name|filename
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Upate whole program statistics.  */
for|for
control|(
name|ptr
operator|=
name|bb_head
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
name|ptr
operator|->
name|filename
condition|)
block|{
name|FILE
modifier|*
name|da_file
decl_stmt|;
name|da_file
operator|=
name|fopen
argument_list|(
name|ptr
operator|->
name|filename
argument_list|,
literal|"r+b"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|da_file
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arc profiling: Cannot reopen %s.\n"
argument_list|,
name|ptr
operator|->
name|filename
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TARGET_HAS_F_SETLKW
argument_list|)
while|while
condition|(
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|da_file
argument_list|)
argument_list|,
name|F_SETLKW
argument_list|,
operator|&
name|s_flock
argument_list|)
operator|&&
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|fseek
argument_list|(
name|da_file
argument_list|,
literal|4
operator|*
literal|3
argument_list|,
name|SEEK_SET
argument_list|)
comment|/* number of instrumented arcs.  */
operator|||
name|__write_long
argument_list|(
name|merged_arcs
argument_list|,
name|da_file
argument_list|,
literal|4
argument_list|)
comment|/* sum of counters.  */
operator|||
name|__write_gcov_type
argument_list|(
name|merged_sum
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
comment|/* maximal counter.  */
operator|||
name|__write_gcov_type
argument_list|(
name|merged_max
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arc profiling: Error updating program header %s.\n"
argument_list|,
name|ptr
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|da_file
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arc profiling: Error reclosing %s\n"
argument_list|,
name|ptr
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a new object file onto the bb chain.  Invoked automatically    when running an object file's global ctors.  */
end_comment

begin_function
name|void
name|__bb_init_func
parameter_list|(
name|struct
name|bb
modifier|*
name|blocks
parameter_list|)
block|{
if|if
condition|(
name|blocks
operator|->
name|zero_word
condition|)
return|return;
comment|/* Initialize destructor and per-thread data.  */
if|if
condition|(
operator|!
name|bb_head
condition|)
name|atexit
argument_list|(
name|__bb_exit_func
argument_list|)
expr_stmt|;
comment|/* Set up linked list.  */
name|blocks
operator|->
name|zero_word
operator|=
literal|1
expr_stmt|;
name|blocks
operator|->
name|next
operator|=
name|bb_head
expr_stmt|;
name|bb_head
operator|=
name|blocks
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called before fork or exec - write out profile information gathered so    far and reset it to zero.  This avoids duplication or loss of the    profile information gathered so far.  */
end_comment

begin_function
name|void
name|__bb_fork_func
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bb
modifier|*
name|ptr
decl_stmt|;
name|__bb_exit_func
argument_list|()
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|bb_head
init|;
name|ptr
operator|!=
operator|(
expr|struct
name|bb
operator|*
operator|)
literal|0
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|long
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ptr
operator|->
name|ncounts
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|ptr
operator|->
name|counts
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not inhibit_libc */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_bb */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_clear_cache
end_ifdef

begin_comment
comment|/* Clear part of an instruction cache.  */
end_comment

begin_define
define|#
directive|define
name|INSN_CACHE_PLANE_SIZE
value|(INSN_CACHE_SIZE / INSN_CACHE_DEPTH)
end_define

begin_decl_stmt
name|void
name|__clear_cache
argument_list|(
name|char
operator|*
name|beg
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
name|char
operator|*
name|end
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{
ifdef|#
directive|ifdef
name|CLEAR_INSN_CACHE
name|CLEAR_INSN_CACHE
argument_list|(
name|beg
argument_list|,
name|end
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|INSN_CACHE_SIZE
specifier|static
name|char
name|array
index|[
name|INSN_CACHE_SIZE
operator|+
name|INSN_CACHE_PLANE_SIZE
operator|+
name|INSN_CACHE_LINE_WIDTH
index|]
decl_stmt|;
specifier|static
name|int
name|initialized
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|void
modifier|*
name|start_addr
name|void
modifier|*
name|end_addr
decl_stmt|;
typedef|typedef
call|(
modifier|*
name|function_ptr
call|)
argument_list|(
name|void
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|INSN_CACHE_SIZE
operator|/
name|INSN_CACHE_LINE_WIDTH
operator|)
operator|<
literal|16
comment|/* It's cheaper to clear the whole cache.      Put in a series of jump instructions so that calling the beginning      of the cache will clear the whole thing.  */
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|int
name|ptr
init|=
operator|(
operator|(
operator|(
name|int
operator|)
name|array
operator|+
name|INSN_CACHE_LINE_WIDTH
operator|-
literal|1
operator|)
operator|&
operator|-
name|INSN_CACHE_LINE_WIDTH
operator|)
decl_stmt|;
name|int
name|end_ptr
init|=
name|ptr
operator|+
name|INSN_CACHE_SIZE
decl_stmt|;
while|while
condition|(
name|ptr
operator|<
name|end_ptr
condition|)
block|{
operator|*
operator|(
name|INSTRUCTION_TYPE
operator|*
operator|)
name|ptr
operator|=
name|JUMP_AHEAD_INSTRUCTION
operator|+
name|INSN_CACHE_LINE_WIDTH
expr_stmt|;
name|ptr
operator|+=
name|INSN_CACHE_LINE_WIDTH
expr_stmt|;
block|}
operator|*
operator|(
name|INSTRUCTION_TYPE
operator|*
operator|)
operator|(
name|ptr
operator|-
name|INSN_CACHE_LINE_WIDTH
operator|)
operator|=
name|RETURN_INSTRUCTION
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Call the beginning of the sequence.  */
operator|(
operator|(
call|(
name|function_ptr
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
name|array
operator|+
name|INSN_CACHE_LINE_WIDTH
operator|-
literal|1
operator|)
operator|&
operator|-
name|INSN_CACHE_LINE_WIDTH
argument_list|)
operator|)
operator|(
operator|)
operator|)
expr_stmt|;
else|#
directive|else
comment|/* Cache is large.  */
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|int
name|ptr
init|=
operator|(
operator|(
operator|(
name|int
operator|)
name|array
operator|+
name|INSN_CACHE_LINE_WIDTH
operator|-
literal|1
operator|)
operator|&
operator|-
name|INSN_CACHE_LINE_WIDTH
operator|)
decl_stmt|;
while|while
condition|(
name|ptr
operator|<
operator|(
name|int
operator|)
name|array
operator|+
sizeof|sizeof
name|array
condition|)
block|{
operator|*
operator|(
name|INSTRUCTION_TYPE
operator|*
operator|)
name|ptr
operator|=
name|RETURN_INSTRUCTION
expr_stmt|;
name|ptr
operator|+=
name|INSN_CACHE_LINE_WIDTH
expr_stmt|;
block|}
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Find the location in array that occupies the same cache line as BEG.  */
name|offset
operator|=
operator|(
operator|(
name|int
operator|)
name|beg
operator|&
operator|-
name|INSN_CACHE_LINE_WIDTH
operator|)
operator|&
operator|(
name|INSN_CACHE_PLANE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|start_addr
operator|=
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
name|array
operator|+
name|INSN_CACHE_PLANE_SIZE
operator|-
literal|1
argument_list|)
operator|&
operator|-
name|INSN_CACHE_PLANE_SIZE
operator|)
operator|+
name|offset
operator|)
expr_stmt|;
comment|/* Compute the cache alignment of the place to stop clearing.  */
if|#
directive|if
literal|0
comment|/* This is not needed for gcc's purposes.  */
comment|/* If the block to clear is bigger than a cache plane,      we clear the entire cache, and OFFSET is already correct.  */
block|if (end< beg + INSN_CACHE_PLANE_SIZE)
endif|#
directive|endif
name|offset
operator|=
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
name|end
operator|+
name|INSN_CACHE_LINE_WIDTH
operator|-
literal|1
argument_list|)
operator|&
operator|-
name|INSN_CACHE_LINE_WIDTH
operator|)
operator|&
operator|(
name|INSN_CACHE_PLANE_SIZE
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|#
directive|if
name|INSN_CACHE_DEPTH
operator|>
literal|1
name|end_addr
operator|=
operator|(
name|start_addr
operator|&
operator|-
name|INSN_CACHE_PLANE_SIZE
operator|)
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|end_addr
operator|<=
name|start_addr
condition|)
name|end_addr
operator|+=
name|INSN_CACHE_PLANE_SIZE
expr_stmt|;
for|for
control|(
name|plane
operator|=
literal|0
init|;
name|plane
operator|<
name|INSN_CACHE_DEPTH
condition|;
name|plane
operator|++
control|)
block|{
name|int
name|addr
init|=
name|start_addr
operator|+
name|plane
operator|*
name|INSN_CACHE_PLANE_SIZE
decl_stmt|;
name|int
name|stop
init|=
name|end_addr
operator|+
name|plane
operator|*
name|INSN_CACHE_PLANE_SIZE
decl_stmt|;
while|while
condition|(
name|addr
operator|!=
name|stop
condition|)
block|{
comment|/* Call the return instruction at ADDR.  */
operator|(
operator|(
name|function_ptr
operator|)
name|addr
operator|)
operator|(
operator|)
expr_stmt|;
name|addr
operator|+=
name|INSN_CACHE_LINE_WIDTH
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* just one plane */
do|do
block|{
comment|/* Call the return instruction at START_ADDR.  */
operator|(
operator|(
name|function_ptr
operator|)
name|start_addr
operator|)
operator|(
operator|)
expr_stmt|;
name|start_addr
operator|+=
name|INSN_CACHE_LINE_WIDTH
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|start_addr
operator|%
name|INSN_CACHE_SIZE
operator|)
operator|!=
name|offset
condition|)
do|;
endif|#
directive|endif
comment|/* just one plane */
endif|#
directive|endif
comment|/* Cache is large */
endif|#
directive|endif
comment|/* Cache exists */
endif|#
directive|endif
comment|/* CLEAR_INSN_CACHE */
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_clear_cache */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_trampoline
end_ifdef

begin_comment
comment|/* Jump to a trampoline, loading the static chain address.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_UWIN
argument_list|)
end_if

begin_function
name|long
name|getpagesize
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_ALPHA_
return|return
literal|8192
return|;
else|#
directive|else
return|return
literal|4096
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_function_decl
specifier|extern
name|int
name|VirtualProtect
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(stdcall
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|mprotect
parameter_list|(
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
name|int
name|np
decl_stmt|,
name|op
decl_stmt|;
if|if
condition|(
name|prot
operator|==
literal|7
condition|)
name|np
operator|=
literal|0x40
expr_stmt|;
elseif|else
if|if
condition|(
name|prot
operator|==
literal|5
condition|)
name|np
operator|=
literal|0x20
expr_stmt|;
elseif|else
if|if
condition|(
name|prot
operator|==
literal|4
condition|)
name|np
operator|=
literal|0x10
expr_stmt|;
elseif|else
if|if
condition|(
name|prot
operator|==
literal|3
condition|)
name|np
operator|=
literal|0x04
expr_stmt|;
elseif|else
if|if
condition|(
name|prot
operator|==
literal|1
condition|)
name|np
operator|=
literal|0x02
expr_stmt|;
elseif|else
if|if
condition|(
name|prot
operator|==
literal|0
condition|)
name|np
operator|=
literal|0x01
expr_stmt|;
if|if
condition|(
name|VirtualProtect
argument_list|(
name|addr
argument_list|,
name|len
argument_list|,
name|np
argument_list|,
operator|&
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WINNT&& ! __CYGWIN__&& ! _UWIN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TRANSFER_FROM_TRAMPOLINE
end_ifdef

begin_decl_stmt
name|TRANSFER_FROM_TRAMPOLINE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__sysV68__
include|#
directive|include
file|<sys/signal.h>
include|#
directive|include
file|<errno.h>
comment|/* Motorola forgot to put memctl.o in the libp version of libc881.a,    so define it here, because we need it in __clear_insn_cache below */
comment|/* On older versions of this OS, no memctl or MCT_TEXT are defined;    hence we enable this stuff only if MCT_TEXT is #define'd.  */
ifdef|#
directive|ifdef
name|MCT_TEXT
name|asm
argument_list|(
literal|"\n\ 	global memctl\n\ memctl:\n\ 	movq&75,%d0\n\ 	trap&0\n\ 	bcc.b noerror\n\ 	jmp cerror%\n\ noerror:\n\ 	movq&0,%d0\n\ 	rts"
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Clear instruction cache so we can call trampolines on stack.    This is called from FINALIZE_TRAMPOLINE in mot3300.h.  */
end_comment

begin_function
name|void
name|__clear_insn_cache
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MCT_TEXT
name|int
name|save_errno
decl_stmt|;
comment|/* Preserve errno, because users would be surprised to have   errno changing without explicitly calling any system-call.  */
name|save_errno
operator|=
name|errno
expr_stmt|;
comment|/* Keep it simple : memctl (MCT_TEXT) always fully clears the insn cache.      No need to use an address derived from _start or %sp, as 0 works also.  */
name|memctl
argument_list|(
literal|0
argument_list|,
literal|4096
argument_list|,
name|MCT_TEXT
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __sysV68__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_trampoline */
end_comment

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|__CYGWIN__
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|L__main
end_ifdef

begin_include
include|#
directive|include
file|"gbl-ctors.h"
end_include

begin_comment
comment|/* Some systems use __main in a way incompatible with its use in gcc, in these    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to    give the same symbol without quotes for an alternative entry point.  You    must define both, or neither.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NAME__MAIN
end_ifndef

begin_define
define|#
directive|define
name|NAME__MAIN
value|"__main"
end_define

begin_define
define|#
directive|define
name|SYMBOL__MAIN
value|__main
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INIT_SECTION_ASM_OP
end_ifdef

begin_undef
undef|#
directive|undef
name|HAS_INIT_SECTION
end_undef

begin_define
define|#
directive|define
name|HAS_INIT_SECTION
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_INIT_SECTION
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|OBJECT_FORMAT_ELF
argument_list|)
end_if

begin_comment
comment|/* Some ELF crosses use crtstuff.c to provide __CTOR_LIST__, but use this    code to run constructors.  In that case, we need to handle EH here, too.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EH_FRAME_SECTION_NAME
end_ifdef

begin_include
include|#
directive|include
file|"unwind-dw2-fde.h"
end_include

begin_decl_stmt
specifier|extern
name|unsigned
name|char
name|__EH_FRAME_BEGIN__
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Run all the global destructors on exit from the program.  */
end_comment

begin_function
name|void
name|__do_global_dtors
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DO_GLOBAL_DTORS_BODY
name|DO_GLOBAL_DTORS_BODY
expr_stmt|;
else|#
directive|else
specifier|static
name|func_ptr
modifier|*
name|p
init|=
name|__DTOR_LIST__
operator|+
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p
operator|++
expr_stmt|;
operator|(
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|)
operator|(
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EH_FRAME_SECTION_NAME
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_INIT_SECTION
argument_list|)
block|{
specifier|static
name|int
name|completed
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|completed
condition|)
block|{
name|completed
operator|=
literal|1
expr_stmt|;
name|__deregister_frame_info
argument_list|(
name|__EH_FRAME_BEGIN__
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_INIT_SECTION
end_ifndef

begin_comment
comment|/* Run all the global constructors on entry to the program.  */
end_comment

begin_function
name|void
name|__do_global_ctors
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|EH_FRAME_SECTION_NAME
block|{
specifier|static
name|struct
name|object
name|object
decl_stmt|;
name|__register_frame_info
argument_list|(
name|__EH_FRAME_BEGIN__
argument_list|,
operator|&
name|object
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|DO_GLOBAL_CTORS_BODY
expr_stmt|;
name|atexit
argument_list|(
name|__do_global_dtors
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no HAS_INIT_SECTION */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_INIT_SECTION
argument_list|)
operator|||
name|defined
argument_list|(
name|INVOKE__main
argument_list|)
end_if

begin_comment
comment|/* Subroutine called automatically by `main'.    Compiling a global function named `main'    produces an automatic call to this function at the beginning.     For many systems, this routine calls __do_global_ctors.    For systems which support a .init section we use the .init section    to run __do_global_ctors, so we need not do anything here.  */
end_comment

begin_function
name|void
name|SYMBOL__MAIN
parameter_list|()
block|{
comment|/* Support recursive calls to `main': run initializers just once.  */
specifier|static
name|int
name|initialized
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|initialized
operator|=
literal|1
expr_stmt|;
name|__do_global_ctors
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no HAS_INIT_SECTION or INVOKE__main */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L__main */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __CYGWIN__ */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_ctors
end_ifdef

begin_include
include|#
directive|include
file|"gbl-ctors.h"
end_include

begin_comment
comment|/* Provide default definitions for the lists of constructors and    destructors, so that we don't get linker errors.  These symbols are    intentionally bss symbols, so that gld and/or collect will provide    the right values.  */
end_comment

begin_comment
comment|/* We declare the lists here with two elements each,    so that they are valid empty lists if no other definition is loaded.     If we are using the old "set" extensions to have the gnu linker    collect ctors and dtors, then we __CTOR_LIST__ and __DTOR_LIST__    must be in the bss/common section.     Long term no port should use those extensions.  But many still do.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INIT_SECTION_ASM_OP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CTOR_LISTS_DEFINED_EXTERNALLY
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TARGET_ASM_CONSTRUCTOR
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_COLLECT2
argument_list|)
end_if

begin_decl_stmt
name|func_ptr
name|__CTOR_LIST__
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|func_ptr
name|__DTOR_LIST__
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|func_ptr
name|__CTOR_LIST__
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|func_ptr
name|__DTOR_LIST__
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no INIT_SECTION_ASM_OP and not CTOR_LISTS_DEFINED_EXTERNALLY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_ctors */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_exit
end_ifdef

begin_include
include|#
directive|include
file|"gbl-ctors.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_ATEXIT
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|ON_EXIT
end_ifndef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|static
name|func_ptr
modifier|*
name|atexit_chain
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|atexit_chain_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|long
name|last_atexit_chain_slot
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|atexit
parameter_list|(
name|func_ptr
name|func
parameter_list|)
block|{
if|if
condition|(
operator|++
name|last_atexit_chain_slot
operator|==
name|atexit_chain_length
condition|)
block|{
name|atexit_chain_length
operator|+=
literal|32
expr_stmt|;
if|if
condition|(
name|atexit_chain
condition|)
name|atexit_chain
operator|=
operator|(
name|func_ptr
operator|*
operator|)
name|realloc
argument_list|(
name|atexit_chain
argument_list|,
name|atexit_chain_length
operator|*
sizeof|sizeof
argument_list|(
name|func_ptr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|atexit_chain
operator|=
operator|(
name|func_ptr
operator|*
operator|)
name|malloc
argument_list|(
name|atexit_chain_length
operator|*
sizeof|sizeof
argument_list|(
name|func_ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|atexit_chain
condition|)
block|{
name|atexit_chain_length
operator|=
literal|0
expr_stmt|;
name|last_atexit_chain_slot
operator|=
operator|-
literal|1
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|atexit_chain
index|[
name|last_atexit_chain_slot
index|]
operator|=
name|func
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|extern
name|void
name|_cleanup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_exit
parameter_list|(
name|int
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__noreturn__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function
name|void
name|exit
parameter_list|(
name|int
name|status
parameter_list|)
block|{
if|if
condition|(
name|atexit_chain
condition|)
block|{
for|for
control|(
init|;
name|last_atexit_chain_slot
operator|--
operator|>=
literal|0
condition|;
control|)
block|{
call|(
modifier|*
name|atexit_chain
index|[
name|last_atexit_chain_slot
operator|+
literal|1
index|]
call|)
argument_list|()
expr_stmt|;
name|atexit_chain
index|[
name|last_atexit_chain_slot
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|atexit_chain
argument_list|)
expr_stmt|;
name|atexit_chain
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EXIT_BODY
name|EXIT_BODY
expr_stmt|;
else|#
directive|else
name|_cleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|_exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ON_EXIT */
end_comment

begin_comment
comment|/* Simple; we just need a wrapper for ON_EXIT.  */
end_comment

begin_function
name|int
name|atexit
parameter_list|(
name|func_ptr
name|func
parameter_list|)
block|{
return|return
name|ON_EXIT
argument_list|(
name|func
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ON_EXIT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEED_ATEXIT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_exit */
end_comment

end_unit

