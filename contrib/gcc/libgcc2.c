begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* More subroutines needed by GCC output code on some machines.  */
end_comment

begin_comment
comment|/* Compile this one with gcc.  */
end_comment

begin_comment
comment|/* Copyright (C) 1989, 92-98, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files,    some of which are compiled with GCC, to produce an executable,    this library does not by itself cause the resulting executable    to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* It is incorrect to include config.h here, because this file is being    compiled for the target, and hence definitions concerning only the host    do not apply.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_comment
comment|/* We disable this when inhibit_libc, so that gcc can still be built without    needing header files first.  */
end_comment

begin_comment
comment|/* ??? This is not a good solution, since prototypes may be required in    some cases for correct code.  See also frame.c.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|inhibit_libc
end_ifndef

begin_comment
comment|/* fixproto guarantees these system headers exist. */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|L_trampoline
end_ifndef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Don't use `fancy_abort' here even if config.h says to use it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|abort
end_ifdef

begin_undef
undef|#
directive|undef
name|abort
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|SUPPORTS_WEAK
operator|==
literal|1
operator|)
operator|&&
operator|(
name|defined
argument_list|(
name|ASM_OUTPUT_DEF
argument_list|)
operator|||
name|defined
argument_list|(
name|ASM_OUTPUT_WEAK_ALIAS
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|WEAK_ALIAS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* In a cross-compilation situation, default to inhibiting compilation    of routines that use libc.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CROSS_COMPILE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|inhibit_libc
argument_list|)
end_if

begin_define
define|#
directive|define
name|inhibit_libc
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Permit the tm.h file to select the endianness to use just for this    file.  This is used when the endianness is determined when the    compiler is run.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LIBGCC2_WORDS_BIG_ENDIAN
end_ifndef

begin_define
define|#
directive|define
name|LIBGCC2_WORDS_BIG_ENDIAN
value|WORDS_BIG_ENDIAN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
value|LONG_DOUBLE_TYPE_SIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* In the first part of this file, we are interfacing to calls generated    by the compiler itself.  These calls pass values into these routines    which have very specific modes (rather than very specific types), and    these compiler-generated calls also expect any return values to have    very specific modes (rather than very specific types).  Thus, we need    to avoid using regular C language type names in this part of the file    because the sizes for those types can be configured to be anything.    Instead we use the following special type names.  */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|int
name|UQItype
name|__attribute__
typedef|((
name|mode
typedef|(
name|QI
typedef|)));
end_typedef

begin_typedef
typedef|typedef
name|int
name|SItype
name|__attribute__
typedef|((
name|mode
typedef|(
name|SI
typedef|)));
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|USItype
name|__attribute__
typedef|((
name|mode
typedef|(
name|SI
typedef|)));
end_typedef

begin_typedef
typedef|typedef
name|int
name|DItype
name|__attribute__
typedef|((
name|mode
typedef|(
name|DI
typedef|)));
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|UDItype
name|__attribute__
typedef|((
name|mode
typedef|(
name|DI
typedef|)));
end_typedef

begin_typedef
typedef|typedef
name|float
name|SFtype
name|__attribute__
typedef|((
name|mode
typedef|(
name|SF
typedef|)));
end_typedef

begin_typedef
typedef|typedef
name|float
name|DFtype
name|__attribute__
typedef|((
name|mode
typedef|(
name|DF
typedef|)));
end_typedef

begin_if
if|#
directive|if
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|96
end_if

begin_typedef
typedef|typedef
name|float
name|XFtype
name|__attribute__
typedef|((
name|mode
typedef|(
name|XF
typedef|)));
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|128
end_if

begin_typedef
typedef|typedef
name|float
name|TFtype
name|__attribute__
typedef|((
name|mode
typedef|(
name|TF
typedef|)));
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|int
name|word_type
name|__attribute__
typedef|((
name|mode
typedef|(
name|__word__
typedef|)));
end_typedef

begin_comment
comment|/* Make sure that we don't accidentally use any normal C language built-in    type names in the first part of this file.  Instead we want to use *only*    the type names defined above.  The following macro definitions insure    that if we *do* accidentally use some normal C language built-in type name,    we will get a syntax error.  */
end_comment

begin_define
define|#
directive|define
name|char
value|bogus_type
end_define

begin_define
define|#
directive|define
name|short
value|bogus_type
end_define

begin_define
define|#
directive|define
name|int
value|bogus_type
end_define

begin_define
define|#
directive|define
name|long
value|bogus_type
end_define

begin_define
define|#
directive|define
name|unsigned
value|bogus_type
end_define

begin_define
define|#
directive|define
name|float
value|bogus_type
end_define

begin_define
define|#
directive|define
name|double
value|bogus_type
end_define

begin_define
define|#
directive|define
name|SI_TYPE_SIZE
value|(sizeof (SItype) * BITS_PER_UNIT)
end_define

begin_comment
comment|/* DIstructs are pairs of SItype values in the order determined by    LIBGCC2_WORDS_BIG_ENDIAN.  */
end_comment

begin_if
if|#
directive|if
name|LIBGCC2_WORDS_BIG_ENDIAN
end_if

begin_struct
struct|struct
name|DIstruct
block|{
name|SItype
name|high
decl_stmt|,
name|low
decl_stmt|;
block|}
struct|;
end_struct

begin_else
else|#
directive|else
end_else

begin_struct
struct|struct
name|DIstruct
block|{
name|SItype
name|low
decl_stmt|,
name|high
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We need this union to unpack/pack DImode values, since we don't have    any arithmetic yet.  Incoming DImode parameters are stored into the    `ll' field, and the unpacked result is read from the struct `s'.  */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
name|struct
name|DIstruct
name|s
decl_stmt|;
name|DItype
name|ll
decl_stmt|;
block|}
name|DIunion
typedef|;
end_typedef

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|L_udivmoddi4
argument_list|)
operator|||
name|defined
argument_list|(
name|L_muldi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_udiv_w_sdiv
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|L_divdi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_udivdi3
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|L_moddi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_umoddi3
argument_list|)
operator|)
end_if

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* udiv or mul */
end_comment

begin_function_decl
specifier|extern
name|DItype
name|__fixunssfdi
parameter_list|(
name|SFtype
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|DItype
name|__fixunsdfdi
parameter_list|(
name|DFtype
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|96
end_if

begin_function_decl
specifier|extern
name|DItype
name|__fixunsxfdi
parameter_list|(
name|XFtype
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|128
end_if

begin_function_decl
specifier|extern
name|DItype
name|__fixunstfdi
parameter_list|(
name|TFtype
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_negdi2
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divdi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_moddi3
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_divdi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_moddi3
argument_list|)
end_if

begin_function
specifier|static
specifier|inline
endif|#
directive|endif
name|DItype
name|__negdi2
parameter_list|(
name|DItype
name|u
parameter_list|)
block|{
name|DIunion
name|w
decl_stmt|;
name|DIunion
name|uu
decl_stmt|;
name|uu
operator|.
name|ll
operator|=
name|u
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|low
operator|=
operator|-
name|uu
operator|.
name|s
operator|.
name|low
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|high
operator|=
operator|-
name|uu
operator|.
name|s
operator|.
name|high
operator|-
operator|(
operator|(
name|USItype
operator|)
name|w
operator|.
name|s
operator|.
name|low
operator|>
literal|0
operator|)
expr_stmt|;
return|return
name|w
operator|.
name|ll
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Unless shift functions are defined whith full ANSI prototypes,    parameter b will be promoted to int if word_type is smaller than an int.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|L_lshrdi3
end_ifdef

begin_function
name|DItype
name|__lshrdi3
parameter_list|(
name|DItype
name|u
parameter_list|,
name|word_type
name|b
parameter_list|)
block|{
name|DIunion
name|w
decl_stmt|;
name|word_type
name|bm
decl_stmt|;
name|DIunion
name|uu
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
name|u
return|;
name|uu
operator|.
name|ll
operator|=
name|u
expr_stmt|;
name|bm
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|SItype
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|-
name|b
expr_stmt|;
if|if
condition|(
name|bm
operator|<=
literal|0
condition|)
block|{
name|w
operator|.
name|s
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|low
operator|=
operator|(
name|USItype
operator|)
name|uu
operator|.
name|s
operator|.
name|high
operator|>>
operator|-
name|bm
expr_stmt|;
block|}
else|else
block|{
name|USItype
name|carries
init|=
operator|(
name|USItype
operator|)
name|uu
operator|.
name|s
operator|.
name|high
operator|<<
name|bm
decl_stmt|;
name|w
operator|.
name|s
operator|.
name|high
operator|=
operator|(
name|USItype
operator|)
name|uu
operator|.
name|s
operator|.
name|high
operator|>>
name|b
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|low
operator|=
operator|(
operator|(
name|USItype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|>>
name|b
operator|)
operator||
name|carries
expr_stmt|;
block|}
return|return
name|w
operator|.
name|ll
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_ashldi3
end_ifdef

begin_function
name|DItype
name|__ashldi3
parameter_list|(
name|DItype
name|u
parameter_list|,
name|word_type
name|b
parameter_list|)
block|{
name|DIunion
name|w
decl_stmt|;
name|word_type
name|bm
decl_stmt|;
name|DIunion
name|uu
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
name|u
return|;
name|uu
operator|.
name|ll
operator|=
name|u
expr_stmt|;
name|bm
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|SItype
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|-
name|b
expr_stmt|;
if|if
condition|(
name|bm
operator|<=
literal|0
condition|)
block|{
name|w
operator|.
name|s
operator|.
name|low
operator|=
literal|0
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|high
operator|=
operator|(
name|USItype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|<<
operator|-
name|bm
expr_stmt|;
block|}
else|else
block|{
name|USItype
name|carries
init|=
operator|(
name|USItype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|>>
name|bm
decl_stmt|;
name|w
operator|.
name|s
operator|.
name|low
operator|=
operator|(
name|USItype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|<<
name|b
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|high
operator|=
operator|(
operator|(
name|USItype
operator|)
name|uu
operator|.
name|s
operator|.
name|high
operator|<<
name|b
operator|)
operator||
name|carries
expr_stmt|;
block|}
return|return
name|w
operator|.
name|ll
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_ashrdi3
end_ifdef

begin_function
name|DItype
name|__ashrdi3
parameter_list|(
name|DItype
name|u
parameter_list|,
name|word_type
name|b
parameter_list|)
block|{
name|DIunion
name|w
decl_stmt|;
name|word_type
name|bm
decl_stmt|;
name|DIunion
name|uu
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
name|u
return|;
name|uu
operator|.
name|ll
operator|=
name|u
expr_stmt|;
name|bm
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|SItype
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|-
name|b
expr_stmt|;
if|if
condition|(
name|bm
operator|<=
literal|0
condition|)
block|{
comment|/* w.s.high = 1..1 or 0..0 */
name|w
operator|.
name|s
operator|.
name|high
operator|=
name|uu
operator|.
name|s
operator|.
name|high
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|SItype
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|low
operator|=
name|uu
operator|.
name|s
operator|.
name|high
operator|>>
operator|-
name|bm
expr_stmt|;
block|}
else|else
block|{
name|USItype
name|carries
init|=
operator|(
name|USItype
operator|)
name|uu
operator|.
name|s
operator|.
name|high
operator|<<
name|bm
decl_stmt|;
name|w
operator|.
name|s
operator|.
name|high
operator|=
name|uu
operator|.
name|s
operator|.
name|high
operator|>>
name|b
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|low
operator|=
operator|(
operator|(
name|USItype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|>>
name|b
operator|)
operator||
name|carries
expr_stmt|;
block|}
return|return
name|w
operator|.
name|ll
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_ffsdi2
end_ifdef

begin_function
name|DItype
name|__ffsdi2
parameter_list|(
name|DItype
name|u
parameter_list|)
block|{
name|DIunion
name|uu
decl_stmt|,
name|w
decl_stmt|;
name|uu
operator|.
name|ll
operator|=
name|u
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|low
operator|=
name|ffs
argument_list|(
name|uu
operator|.
name|s
operator|.
name|low
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|s
operator|.
name|low
operator|!=
literal|0
condition|)
return|return
name|w
operator|.
name|ll
return|;
name|w
operator|.
name|s
operator|.
name|low
operator|=
name|ffs
argument_list|(
name|uu
operator|.
name|s
operator|.
name|high
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|s
operator|.
name|low
operator|!=
literal|0
condition|)
block|{
name|w
operator|.
name|s
operator|.
name|low
operator|+=
name|BITS_PER_UNIT
operator|*
sizeof|sizeof
argument_list|(
name|SItype
argument_list|)
expr_stmt|;
return|return
name|w
operator|.
name|ll
return|;
block|}
return|return
name|w
operator|.
name|ll
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_muldi3
end_ifdef

begin_function
name|DItype
name|__muldi3
parameter_list|(
name|DItype
name|u
parameter_list|,
name|DItype
name|v
parameter_list|)
block|{
name|DIunion
name|w
decl_stmt|;
name|DIunion
name|uu
decl_stmt|,
name|vv
decl_stmt|;
name|uu
operator|.
name|ll
operator|=
name|u
operator|,
name|vv
operator|.
name|ll
operator|=
name|v
expr_stmt|;
name|w
operator|.
name|ll
operator|=
name|__umulsidi3
argument_list|(
name|uu
operator|.
name|s
operator|.
name|low
argument_list|,
name|vv
operator|.
name|s
operator|.
name|low
argument_list|)
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|high
operator|+=
operator|(
operator|(
name|USItype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|*
operator|(
name|USItype
operator|)
name|vv
operator|.
name|s
operator|.
name|high
operator|+
operator|(
name|USItype
operator|)
name|uu
operator|.
name|s
operator|.
name|high
operator|*
operator|(
name|USItype
operator|)
name|vv
operator|.
name|s
operator|.
name|low
operator|)
expr_stmt|;
return|return
name|w
operator|.
name|ll
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_udiv_w_sdiv
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sdiv_qrnnd
argument_list|)
end_if

begin_function
name|USItype
name|__udiv_w_sdiv
parameter_list|(
name|USItype
modifier|*
name|rp
parameter_list|,
name|USItype
name|a1
parameter_list|,
name|USItype
name|a0
parameter_list|,
name|USItype
name|d
parameter_list|)
block|{
name|USItype
name|q
decl_stmt|,
name|r
decl_stmt|;
name|USItype
name|c0
decl_stmt|,
name|c1
decl_stmt|,
name|b1
decl_stmt|;
if|if
condition|(
operator|(
name|SItype
operator|)
name|d
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|a1
operator|<
name|d
operator|-
name|a1
operator|-
operator|(
name|a0
operator|>>
operator|(
name|SI_TYPE_SIZE
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* dividend, divisor, and quotient are nonnegative */
name|sdiv_qrnnd
argument_list|(
name|q
argument_list|,
name|r
argument_list|,
name|a1
argument_list|,
name|a0
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Compute c1*2^32 + c0 = a1*2^32 + a0 - 2^31*d */
name|sub_ddmmss
argument_list|(
name|c1
argument_list|,
name|c0
argument_list|,
name|a1
argument_list|,
name|a0
argument_list|,
name|d
operator|>>
literal|1
argument_list|,
name|d
operator|<<
operator|(
name|SI_TYPE_SIZE
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Divide (c1*2^32 + c0) by d */
name|sdiv_qrnnd
argument_list|(
name|q
argument_list|,
name|r
argument_list|,
name|c1
argument_list|,
name|c0
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* Add 2^31 to quotient */
name|q
operator|+=
operator|(
name|USItype
operator|)
literal|1
operator|<<
operator|(
name|SI_TYPE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|b1
operator|=
name|d
operator|>>
literal|1
expr_stmt|;
comment|/* d/2, between 2^30 and 2^31 - 1 */
name|c1
operator|=
name|a1
operator|>>
literal|1
expr_stmt|;
comment|/* A/2 */
name|c0
operator|=
operator|(
name|a1
operator|<<
operator|(
name|SI_TYPE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|+
operator|(
name|a0
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|a1
operator|<
name|b1
condition|)
comment|/* A< 2^32*b1, so A/2< 2^31*b1 */
block|{
name|sdiv_qrnnd
argument_list|(
name|q
argument_list|,
name|r
argument_list|,
name|c1
argument_list|,
name|c0
argument_list|,
name|b1
argument_list|)
expr_stmt|;
comment|/* (A/2) / (d/2) */
name|r
operator|=
literal|2
operator|*
name|r
operator|+
operator|(
name|a0
operator|&
literal|1
operator|)
expr_stmt|;
comment|/* Remainder from A/(2*b1) */
if|if
condition|(
operator|(
name|d
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|>=
name|q
condition|)
name|r
operator|=
name|r
operator|-
name|q
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|-
name|r
operator|<=
name|d
condition|)
block|{
name|r
operator|=
name|r
operator|-
name|q
operator|+
name|d
expr_stmt|;
name|q
operator|--
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|r
operator|-
name|q
operator|+
literal|2
operator|*
name|d
expr_stmt|;
name|q
operator|-=
literal|2
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c1
operator|<
name|b1
condition|)
comment|/* So 2^31<= (A/2)/b1< 2^32 */
block|{
name|c1
operator|=
operator|(
name|b1
operator|-
literal|1
operator|)
operator|-
name|c1
expr_stmt|;
name|c0
operator|=
operator|~
name|c0
expr_stmt|;
comment|/* logical NOT */
name|sdiv_qrnnd
argument_list|(
name|q
argument_list|,
name|r
argument_list|,
name|c1
argument_list|,
name|c0
argument_list|,
name|b1
argument_list|)
expr_stmt|;
comment|/* (A/2) / (d/2) */
name|q
operator|=
operator|~
name|q
expr_stmt|;
comment|/* (A/2)/b1 */
name|r
operator|=
operator|(
name|b1
operator|-
literal|1
operator|)
operator|-
name|r
expr_stmt|;
name|r
operator|=
literal|2
operator|*
name|r
operator|+
operator|(
name|a0
operator|&
literal|1
operator|)
expr_stmt|;
comment|/* A/(2*b1) */
if|if
condition|(
operator|(
name|d
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|>=
name|q
condition|)
name|r
operator|=
name|r
operator|-
name|q
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|-
name|r
operator|<=
name|d
condition|)
block|{
name|r
operator|=
name|r
operator|-
name|q
operator|+
name|d
expr_stmt|;
name|q
operator|--
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|r
operator|-
name|q
operator|+
literal|2
operator|*
name|d
expr_stmt|;
name|q
operator|-=
literal|2
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* Implies c1 = b1 */
block|{
comment|/* Hence a1 = d - 1 = 2*b1 - 1 */
if|if
condition|(
name|a0
operator|>=
operator|-
name|d
condition|)
block|{
name|q
operator|=
operator|-
literal|1
expr_stmt|;
name|r
operator|=
name|a0
operator|+
name|d
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
operator|-
literal|2
expr_stmt|;
name|r
operator|=
name|a0
operator|+
literal|2
operator|*
name|d
expr_stmt|;
block|}
block|}
block|}
operator|*
name|rp
operator|=
name|r
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* If sdiv_qrnnd doesn't exist, define dummy __udiv_w_sdiv.  */
end_comment

begin_decl_stmt
name|USItype
name|__udiv_w_sdiv
argument_list|(
name|USItype
operator|*
name|rp
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
name|USItype
name|a1
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
name|USItype
name|a0
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
name|USItype
name|d
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|L_udivdi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divdi3
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|L_umoddi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_moddi3
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|L_udivmoddi4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_udivmoddi4
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|UQItype
name|__clz_tab
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|, }
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|L_udivdi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divdi3
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|L_umoddi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_moddi3
argument_list|)
operator|)
end_if

begin_function
specifier|static
specifier|inline
endif|#
directive|endif
name|UDItype
name|__udivmoddi4
parameter_list|(
name|UDItype
name|n
parameter_list|,
name|UDItype
name|d
parameter_list|,
name|UDItype
modifier|*
name|rp
parameter_list|)
block|{
name|DIunion
name|ww
decl_stmt|;
name|DIunion
name|nn
decl_stmt|,
name|dd
decl_stmt|;
name|DIunion
name|rr
decl_stmt|;
name|USItype
name|d0
decl_stmt|,
name|d1
decl_stmt|,
name|n0
decl_stmt|,
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|USItype
name|q0
decl_stmt|,
name|q1
decl_stmt|;
name|USItype
name|b
decl_stmt|,
name|bm
decl_stmt|;
name|nn
operator|.
name|ll
operator|=
name|n
expr_stmt|;
name|dd
operator|.
name|ll
operator|=
name|d
expr_stmt|;
name|d0
operator|=
name|dd
operator|.
name|s
operator|.
name|low
expr_stmt|;
name|d1
operator|=
name|dd
operator|.
name|s
operator|.
name|high
expr_stmt|;
name|n0
operator|=
name|nn
operator|.
name|s
operator|.
name|low
expr_stmt|;
name|n1
operator|=
name|nn
operator|.
name|s
operator|.
name|high
expr_stmt|;
if|#
directive|if
operator|!
name|UDIV_NEEDS_NORMALIZATION
if|if
condition|(
name|d1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|d0
operator|>
name|n1
condition|)
block|{
comment|/* 0q = nn / 0D */
name|udiv_qrnnd
argument_list|(
name|q0
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|d0
argument_list|)
expr_stmt|;
name|q1
operator|=
literal|0
expr_stmt|;
comment|/* Remainder in n0.  */
block|}
else|else
block|{
comment|/* qq = NN / 0d */
if|if
condition|(
name|d0
operator|==
literal|0
condition|)
name|d0
operator|=
literal|1
operator|/
name|d0
expr_stmt|;
comment|/* Divide intentionally by zero.  */
name|udiv_qrnnd
argument_list|(
name|q1
argument_list|,
name|n1
argument_list|,
literal|0
argument_list|,
name|n1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
name|udiv_qrnnd
argument_list|(
name|q0
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|d0
argument_list|)
expr_stmt|;
comment|/* Remainder in n0.  */
block|}
if|if
condition|(
name|rp
operator|!=
literal|0
condition|)
block|{
name|rr
operator|.
name|s
operator|.
name|low
operator|=
name|n0
expr_stmt|;
name|rr
operator|.
name|s
operator|.
name|high
operator|=
literal|0
expr_stmt|;
operator|*
name|rp
operator|=
name|rr
operator|.
name|ll
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* UDIV_NEEDS_NORMALIZATION */
if|if
condition|(
name|d1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|d0
operator|>
name|n1
condition|)
block|{
comment|/* 0q = nn / 0D */
name|count_leading_zeros
argument_list|(
name|bm
argument_list|,
name|d0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bm
operator|!=
literal|0
condition|)
block|{
comment|/* Normalize, i.e. make the most significant bit of the 		 denominator set.  */
name|d0
operator|=
name|d0
operator|<<
name|bm
expr_stmt|;
name|n1
operator|=
operator|(
name|n1
operator|<<
name|bm
operator|)
operator||
operator|(
name|n0
operator|>>
operator|(
name|SI_TYPE_SIZE
operator|-
name|bm
operator|)
operator|)
expr_stmt|;
name|n0
operator|=
name|n0
operator|<<
name|bm
expr_stmt|;
block|}
name|udiv_qrnnd
argument_list|(
name|q0
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|d0
argument_list|)
expr_stmt|;
name|q1
operator|=
literal|0
expr_stmt|;
comment|/* Remainder in n0>> bm.  */
block|}
else|else
block|{
comment|/* qq = NN / 0d */
if|if
condition|(
name|d0
operator|==
literal|0
condition|)
name|d0
operator|=
literal|1
operator|/
name|d0
expr_stmt|;
comment|/* Divide intentionally by zero.  */
name|count_leading_zeros
argument_list|(
name|bm
argument_list|,
name|d0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bm
operator|==
literal|0
condition|)
block|{
comment|/* From (n1>= d0) /\ (the most significant bit of d0 is set), 		 conclude (the most significant bit of n1 is set) /\ (the 		 leading quotient digit q1 = 1).  		 This special case is necessary, not an optimization. 		 (Shifts counts of SI_TYPE_SIZE are undefined.)  */
name|n1
operator|-=
name|d0
expr_stmt|;
name|q1
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Normalize.  */
name|b
operator|=
name|SI_TYPE_SIZE
operator|-
name|bm
expr_stmt|;
name|d0
operator|=
name|d0
operator|<<
name|bm
expr_stmt|;
name|n2
operator|=
name|n1
operator|>>
name|b
expr_stmt|;
name|n1
operator|=
operator|(
name|n1
operator|<<
name|bm
operator|)
operator||
operator|(
name|n0
operator|>>
name|b
operator|)
expr_stmt|;
name|n0
operator|=
name|n0
operator|<<
name|bm
expr_stmt|;
name|udiv_qrnnd
argument_list|(
name|q1
argument_list|,
name|n1
argument_list|,
name|n2
argument_list|,
name|n1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
block|}
comment|/* n1 != d0...  */
name|udiv_qrnnd
argument_list|(
name|q0
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|d0
argument_list|)
expr_stmt|;
comment|/* Remainder in n0>> bm.  */
block|}
if|if
condition|(
name|rp
operator|!=
literal|0
condition|)
block|{
name|rr
operator|.
name|s
operator|.
name|low
operator|=
name|n0
operator|>>
name|bm
expr_stmt|;
name|rr
operator|.
name|s
operator|.
name|high
operator|=
literal|0
expr_stmt|;
operator|*
name|rp
operator|=
name|rr
operator|.
name|ll
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* UDIV_NEEDS_NORMALIZATION */
else|else
block|{
if|if
condition|(
name|d1
operator|>
name|n1
condition|)
block|{
comment|/* 00 = nn / DD */
name|q0
operator|=
literal|0
expr_stmt|;
name|q1
operator|=
literal|0
expr_stmt|;
comment|/* Remainder in n1n0.  */
if|if
condition|(
name|rp
operator|!=
literal|0
condition|)
block|{
name|rr
operator|.
name|s
operator|.
name|low
operator|=
name|n0
expr_stmt|;
name|rr
operator|.
name|s
operator|.
name|high
operator|=
name|n1
expr_stmt|;
operator|*
name|rp
operator|=
name|rr
operator|.
name|ll
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 0q = NN / dd */
name|count_leading_zeros
argument_list|(
name|bm
argument_list|,
name|d1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bm
operator|==
literal|0
condition|)
block|{
comment|/* From (n1>= d1) /\ (the most significant bit of d1 is set), 		 conclude (the most significant bit of n1 is set) /\ (the 		 quotient digit q0 = 0 or 1).  		 This special case is necessary, not an optimization.  */
comment|/* The condition on the next line takes advantage of that 		 n1>= d1 (true due to program flow).  */
if|if
condition|(
name|n1
operator|>
name|d1
operator|||
name|n0
operator|>=
name|d0
condition|)
block|{
name|q0
operator|=
literal|1
expr_stmt|;
name|sub_ddmmss
argument_list|(
name|n1
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|d1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
block|}
else|else
name|q0
operator|=
literal|0
expr_stmt|;
name|q1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rp
operator|!=
literal|0
condition|)
block|{
name|rr
operator|.
name|s
operator|.
name|low
operator|=
name|n0
expr_stmt|;
name|rr
operator|.
name|s
operator|.
name|high
operator|=
name|n1
expr_stmt|;
operator|*
name|rp
operator|=
name|rr
operator|.
name|ll
expr_stmt|;
block|}
block|}
else|else
block|{
name|USItype
name|m1
decl_stmt|,
name|m0
decl_stmt|;
comment|/* Normalize.  */
name|b
operator|=
name|SI_TYPE_SIZE
operator|-
name|bm
expr_stmt|;
name|d1
operator|=
operator|(
name|d1
operator|<<
name|bm
operator|)
operator||
operator|(
name|d0
operator|>>
name|b
operator|)
expr_stmt|;
name|d0
operator|=
name|d0
operator|<<
name|bm
expr_stmt|;
name|n2
operator|=
name|n1
operator|>>
name|b
expr_stmt|;
name|n1
operator|=
operator|(
name|n1
operator|<<
name|bm
operator|)
operator||
operator|(
name|n0
operator|>>
name|b
operator|)
expr_stmt|;
name|n0
operator|=
name|n0
operator|<<
name|bm
expr_stmt|;
name|udiv_qrnnd
argument_list|(
name|q0
argument_list|,
name|n1
argument_list|,
name|n2
argument_list|,
name|n1
argument_list|,
name|d1
argument_list|)
expr_stmt|;
name|umul_ppmm
argument_list|(
name|m1
argument_list|,
name|m0
argument_list|,
name|q0
argument_list|,
name|d0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|>
name|n1
operator|||
operator|(
name|m1
operator|==
name|n1
operator|&&
name|m0
operator|>
name|n0
operator|)
condition|)
block|{
name|q0
operator|--
expr_stmt|;
name|sub_ddmmss
argument_list|(
name|m1
argument_list|,
name|m0
argument_list|,
name|m1
argument_list|,
name|m0
argument_list|,
name|d1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
block|}
name|q1
operator|=
literal|0
expr_stmt|;
comment|/* Remainder in (n1n0 - m1m0)>> bm.  */
if|if
condition|(
name|rp
operator|!=
literal|0
condition|)
block|{
name|sub_ddmmss
argument_list|(
name|n1
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|m1
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|rr
operator|.
name|s
operator|.
name|low
operator|=
operator|(
name|n1
operator|<<
name|b
operator|)
operator||
operator|(
name|n0
operator|>>
name|bm
operator|)
expr_stmt|;
name|rr
operator|.
name|s
operator|.
name|high
operator|=
name|n1
operator|>>
name|bm
expr_stmt|;
operator|*
name|rp
operator|=
name|rr
operator|.
name|ll
expr_stmt|;
block|}
block|}
block|}
block|}
name|ww
operator|.
name|s
operator|.
name|low
operator|=
name|q0
expr_stmt|;
name|ww
operator|.
name|s
operator|.
name|high
operator|=
name|q1
expr_stmt|;
return|return
name|ww
operator|.
name|ll
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_divdi3
end_ifdef

begin_function_decl
name|UDItype
name|__udivmoddi4
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|DItype
name|__divdi3
parameter_list|(
name|DItype
name|u
parameter_list|,
name|DItype
name|v
parameter_list|)
block|{
name|word_type
name|c
init|=
literal|0
decl_stmt|;
name|DIunion
name|uu
decl_stmt|,
name|vv
decl_stmt|;
name|DItype
name|w
decl_stmt|;
name|uu
operator|.
name|ll
operator|=
name|u
expr_stmt|;
name|vv
operator|.
name|ll
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|high
operator|<
literal|0
condition|)
name|c
operator|=
operator|~
name|c
operator|,
name|uu
operator|.
name|ll
operator|=
name|__negdi2
argument_list|(
name|uu
operator|.
name|ll
argument_list|)
expr_stmt|;
if|if
condition|(
name|vv
operator|.
name|s
operator|.
name|high
operator|<
literal|0
condition|)
name|c
operator|=
operator|~
name|c
operator|,
name|vv
operator|.
name|ll
operator|=
name|__negdi2
argument_list|(
name|vv
operator|.
name|ll
argument_list|)
expr_stmt|;
name|w
operator|=
name|__udivmoddi4
argument_list|(
name|uu
operator|.
name|ll
argument_list|,
name|vv
operator|.
name|ll
argument_list|,
operator|(
name|UDItype
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|w
operator|=
name|__negdi2
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_moddi3
end_ifdef

begin_function_decl
name|UDItype
name|__udivmoddi4
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|DItype
name|__moddi3
parameter_list|(
name|DItype
name|u
parameter_list|,
name|DItype
name|v
parameter_list|)
block|{
name|word_type
name|c
init|=
literal|0
decl_stmt|;
name|DIunion
name|uu
decl_stmt|,
name|vv
decl_stmt|;
name|DItype
name|w
decl_stmt|;
name|uu
operator|.
name|ll
operator|=
name|u
expr_stmt|;
name|vv
operator|.
name|ll
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|high
operator|<
literal|0
condition|)
name|c
operator|=
operator|~
name|c
operator|,
name|uu
operator|.
name|ll
operator|=
name|__negdi2
argument_list|(
name|uu
operator|.
name|ll
argument_list|)
expr_stmt|;
if|if
condition|(
name|vv
operator|.
name|s
operator|.
name|high
operator|<
literal|0
condition|)
name|vv
operator|.
name|ll
operator|=
name|__negdi2
argument_list|(
name|vv
operator|.
name|ll
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|__udivmoddi4
argument_list|(
name|uu
operator|.
name|ll
argument_list|,
name|vv
operator|.
name|ll
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|w
operator|=
name|__negdi2
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_umoddi3
end_ifdef

begin_function_decl
name|UDItype
name|__udivmoddi4
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|UDItype
name|__umoddi3
parameter_list|(
name|UDItype
name|u
parameter_list|,
name|UDItype
name|v
parameter_list|)
block|{
name|UDItype
name|w
decl_stmt|;
operator|(
name|void
operator|)
name|__udivmoddi4
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_udivdi3
end_ifdef

begin_function_decl
name|UDItype
name|__udivmoddi4
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|UDItype
name|__udivdi3
parameter_list|(
name|UDItype
name|n
parameter_list|,
name|UDItype
name|d
parameter_list|)
block|{
return|return
name|__udivmoddi4
argument_list|(
name|n
argument_list|,
name|d
argument_list|,
operator|(
name|UDItype
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_cmpdi2
end_ifdef

begin_function
name|word_type
name|__cmpdi2
parameter_list|(
name|DItype
name|a
parameter_list|,
name|DItype
name|b
parameter_list|)
block|{
name|DIunion
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|ll
operator|=
name|a
operator|,
name|bu
operator|.
name|ll
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|au
operator|.
name|s
operator|.
name|high
operator|<
name|bu
operator|.
name|s
operator|.
name|high
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|au
operator|.
name|s
operator|.
name|high
operator|>
name|bu
operator|.
name|s
operator|.
name|high
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|(
name|USItype
operator|)
name|au
operator|.
name|s
operator|.
name|low
operator|<
operator|(
name|USItype
operator|)
name|bu
operator|.
name|s
operator|.
name|low
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|USItype
operator|)
name|au
operator|.
name|s
operator|.
name|low
operator|>
operator|(
name|USItype
operator|)
name|bu
operator|.
name|s
operator|.
name|low
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_ucmpdi2
end_ifdef

begin_function
name|word_type
name|__ucmpdi2
parameter_list|(
name|DItype
name|a
parameter_list|,
name|DItype
name|b
parameter_list|)
block|{
name|DIunion
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|ll
operator|=
name|a
operator|,
name|bu
operator|.
name|ll
operator|=
name|b
expr_stmt|;
if|if
condition|(
operator|(
name|USItype
operator|)
name|au
operator|.
name|s
operator|.
name|high
operator|<
operator|(
name|USItype
operator|)
name|bu
operator|.
name|s
operator|.
name|high
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|USItype
operator|)
name|au
operator|.
name|s
operator|.
name|high
operator|>
operator|(
name|USItype
operator|)
name|bu
operator|.
name|s
operator|.
name|high
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|(
name|USItype
operator|)
name|au
operator|.
name|s
operator|.
name|low
operator|<
operator|(
name|USItype
operator|)
name|bu
operator|.
name|s
operator|.
name|low
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|USItype
operator|)
name|au
operator|.
name|s
operator|.
name|low
operator|>
operator|(
name|USItype
operator|)
name|bu
operator|.
name|s
operator|.
name|low
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixunstfdi
argument_list|)
operator|&&
operator|(
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|128
operator|)
end_if

begin_define
define|#
directive|define
name|WORD_SIZE
value|(sizeof (SItype) * BITS_PER_UNIT)
end_define

begin_define
define|#
directive|define
name|HIGH_WORD_COEFF
value|(((UDItype) 1)<< WORD_SIZE)
end_define

begin_function
name|DItype
name|__fixunstfdi
parameter_list|(
name|TFtype
name|a
parameter_list|)
block|{
name|TFtype
name|b
decl_stmt|;
name|UDItype
name|v
decl_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Compute high word of result, as a flonum.  */
name|b
operator|=
operator|(
name|a
operator|/
name|HIGH_WORD_COEFF
operator|)
expr_stmt|;
comment|/* Convert that to fixed (but not to DItype!),      and shift it into the high word.  */
name|v
operator|=
operator|(
name|USItype
operator|)
name|b
expr_stmt|;
name|v
operator|<<=
name|WORD_SIZE
expr_stmt|;
comment|/* Remove high part from the TFtype, leaving the low part as flonum.  */
name|a
operator|-=
operator|(
name|TFtype
operator|)
name|v
expr_stmt|;
comment|/* Convert that to fixed (but not to DItype!) and add it in.      Sometimes A comes out negative.  This is significant, since      A has more bits than a long int does.  */
if|if
condition|(
name|a
operator|<
literal|0
condition|)
name|v
operator|-=
call|(
name|USItype
call|)
argument_list|(
operator|-
name|a
argument_list|)
expr_stmt|;
else|else
name|v
operator|+=
operator|(
name|USItype
operator|)
name|a
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixtfdi
argument_list|)
operator|&&
operator|(
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|128
operator|)
end_if

begin_function
name|DItype
name|__fixtfdi
parameter_list|(
name|TFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
operator|-
name|__fixunstfdi
argument_list|(
operator|-
name|a
argument_list|)
return|;
return|return
name|__fixunstfdi
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixunsxfdi
argument_list|)
operator|&&
operator|(
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|96
operator|)
end_if

begin_define
define|#
directive|define
name|WORD_SIZE
value|(sizeof (SItype) * BITS_PER_UNIT)
end_define

begin_define
define|#
directive|define
name|HIGH_WORD_COEFF
value|(((UDItype) 1)<< WORD_SIZE)
end_define

begin_function
name|DItype
name|__fixunsxfdi
parameter_list|(
name|XFtype
name|a
parameter_list|)
block|{
name|XFtype
name|b
decl_stmt|;
name|UDItype
name|v
decl_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Compute high word of result, as a flonum.  */
name|b
operator|=
operator|(
name|a
operator|/
name|HIGH_WORD_COEFF
operator|)
expr_stmt|;
comment|/* Convert that to fixed (but not to DItype!),      and shift it into the high word.  */
name|v
operator|=
operator|(
name|USItype
operator|)
name|b
expr_stmt|;
name|v
operator|<<=
name|WORD_SIZE
expr_stmt|;
comment|/* Remove high part from the XFtype, leaving the low part as flonum.  */
name|a
operator|-=
operator|(
name|XFtype
operator|)
name|v
expr_stmt|;
comment|/* Convert that to fixed (but not to DItype!) and add it in.      Sometimes A comes out negative.  This is significant, since      A has more bits than a long int does.  */
if|if
condition|(
name|a
operator|<
literal|0
condition|)
name|v
operator|-=
call|(
name|USItype
call|)
argument_list|(
operator|-
name|a
argument_list|)
expr_stmt|;
else|else
name|v
operator|+=
operator|(
name|USItype
operator|)
name|a
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixxfdi
argument_list|)
operator|&&
operator|(
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|96
operator|)
end_if

begin_function
name|DItype
name|__fixxfdi
parameter_list|(
name|XFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
operator|-
name|__fixunsxfdi
argument_list|(
operator|-
name|a
argument_list|)
return|;
return|return
name|__fixunsxfdi
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_fixunsdfdi
end_ifdef

begin_define
define|#
directive|define
name|WORD_SIZE
value|(sizeof (SItype) * BITS_PER_UNIT)
end_define

begin_define
define|#
directive|define
name|HIGH_WORD_COEFF
value|(((UDItype) 1)<< WORD_SIZE)
end_define

begin_function
name|DItype
name|__fixunsdfdi
parameter_list|(
name|DFtype
name|a
parameter_list|)
block|{
name|DFtype
name|b
decl_stmt|;
name|UDItype
name|v
decl_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Compute high word of result, as a flonum.  */
name|b
operator|=
operator|(
name|a
operator|/
name|HIGH_WORD_COEFF
operator|)
expr_stmt|;
comment|/* Convert that to fixed (but not to DItype!),      and shift it into the high word.  */
name|v
operator|=
operator|(
name|USItype
operator|)
name|b
expr_stmt|;
name|v
operator|<<=
name|WORD_SIZE
expr_stmt|;
comment|/* Remove high part from the DFtype, leaving the low part as flonum.  */
name|a
operator|-=
operator|(
name|DFtype
operator|)
name|v
expr_stmt|;
comment|/* Convert that to fixed (but not to DItype!) and add it in.      Sometimes A comes out negative.  This is significant, since      A has more bits than a long int does.  */
if|if
condition|(
name|a
operator|<
literal|0
condition|)
name|v
operator|-=
call|(
name|USItype
call|)
argument_list|(
operator|-
name|a
argument_list|)
expr_stmt|;
else|else
name|v
operator|+=
operator|(
name|USItype
operator|)
name|a
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_fixdfdi
end_ifdef

begin_function
name|DItype
name|__fixdfdi
parameter_list|(
name|DFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
operator|-
name|__fixunsdfdi
argument_list|(
operator|-
name|a
argument_list|)
return|;
return|return
name|__fixunsdfdi
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_fixunssfdi
end_ifdef

begin_define
define|#
directive|define
name|WORD_SIZE
value|(sizeof (SItype) * BITS_PER_UNIT)
end_define

begin_define
define|#
directive|define
name|HIGH_WORD_COEFF
value|(((UDItype) 1)<< WORD_SIZE)
end_define

begin_function
name|DItype
name|__fixunssfdi
parameter_list|(
name|SFtype
name|original_a
parameter_list|)
block|{
comment|/* Convert the SFtype to a DFtype, because that is surely not going      to lose any bits.  Some day someone else can write a faster version      that avoids converting to DFtype, and verify it really works right.  */
name|DFtype
name|a
init|=
name|original_a
decl_stmt|;
name|DFtype
name|b
decl_stmt|;
name|UDItype
name|v
decl_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Compute high word of result, as a flonum.  */
name|b
operator|=
operator|(
name|a
operator|/
name|HIGH_WORD_COEFF
operator|)
expr_stmt|;
comment|/* Convert that to fixed (but not to DItype!),      and shift it into the high word.  */
name|v
operator|=
operator|(
name|USItype
operator|)
name|b
expr_stmt|;
name|v
operator|<<=
name|WORD_SIZE
expr_stmt|;
comment|/* Remove high part from the DFtype, leaving the low part as flonum.  */
name|a
operator|-=
operator|(
name|DFtype
operator|)
name|v
expr_stmt|;
comment|/* Convert that to fixed (but not to DItype!) and add it in.      Sometimes A comes out negative.  This is significant, since      A has more bits than a long int does.  */
if|if
condition|(
name|a
operator|<
literal|0
condition|)
name|v
operator|-=
call|(
name|USItype
call|)
argument_list|(
operator|-
name|a
argument_list|)
expr_stmt|;
else|else
name|v
operator|+=
operator|(
name|USItype
operator|)
name|a
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_fixsfdi
end_ifdef

begin_function
name|DItype
name|__fixsfdi
parameter_list|(
name|SFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
operator|-
name|__fixunssfdi
argument_list|(
operator|-
name|a
argument_list|)
return|;
return|return
name|__fixunssfdi
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_floatdixf
argument_list|)
operator|&&
operator|(
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|96
operator|)
end_if

begin_define
define|#
directive|define
name|WORD_SIZE
value|(sizeof (SItype) * BITS_PER_UNIT)
end_define

begin_define
define|#
directive|define
name|HIGH_HALFWORD_COEFF
value|(((UDItype) 1)<< (WORD_SIZE / 2))
end_define

begin_define
define|#
directive|define
name|HIGH_WORD_COEFF
value|(((UDItype) 1)<< WORD_SIZE)
end_define

begin_function
name|XFtype
name|__floatdixf
parameter_list|(
name|DItype
name|u
parameter_list|)
block|{
name|XFtype
name|d
decl_stmt|;
name|d
operator|=
call|(
name|SItype
call|)
argument_list|(
name|u
operator|>>
name|WORD_SIZE
argument_list|)
expr_stmt|;
name|d
operator|*=
name|HIGH_HALFWORD_COEFF
expr_stmt|;
name|d
operator|*=
name|HIGH_HALFWORD_COEFF
expr_stmt|;
name|d
operator|+=
call|(
name|USItype
call|)
argument_list|(
name|u
operator|&
operator|(
name|HIGH_WORD_COEFF
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_floatditf
argument_list|)
operator|&&
operator|(
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|128
operator|)
end_if

begin_define
define|#
directive|define
name|WORD_SIZE
value|(sizeof (SItype) * BITS_PER_UNIT)
end_define

begin_define
define|#
directive|define
name|HIGH_HALFWORD_COEFF
value|(((UDItype) 1)<< (WORD_SIZE / 2))
end_define

begin_define
define|#
directive|define
name|HIGH_WORD_COEFF
value|(((UDItype) 1)<< WORD_SIZE)
end_define

begin_function
name|TFtype
name|__floatditf
parameter_list|(
name|DItype
name|u
parameter_list|)
block|{
name|TFtype
name|d
decl_stmt|;
name|d
operator|=
call|(
name|SItype
call|)
argument_list|(
name|u
operator|>>
name|WORD_SIZE
argument_list|)
expr_stmt|;
name|d
operator|*=
name|HIGH_HALFWORD_COEFF
expr_stmt|;
name|d
operator|*=
name|HIGH_HALFWORD_COEFF
expr_stmt|;
name|d
operator|+=
call|(
name|USItype
call|)
argument_list|(
name|u
operator|&
operator|(
name|HIGH_WORD_COEFF
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_floatdidf
end_ifdef

begin_define
define|#
directive|define
name|WORD_SIZE
value|(sizeof (SItype) * BITS_PER_UNIT)
end_define

begin_define
define|#
directive|define
name|HIGH_HALFWORD_COEFF
value|(((UDItype) 1)<< (WORD_SIZE / 2))
end_define

begin_define
define|#
directive|define
name|HIGH_WORD_COEFF
value|(((UDItype) 1)<< WORD_SIZE)
end_define

begin_function
name|DFtype
name|__floatdidf
parameter_list|(
name|DItype
name|u
parameter_list|)
block|{
name|DFtype
name|d
decl_stmt|;
name|d
operator|=
call|(
name|SItype
call|)
argument_list|(
name|u
operator|>>
name|WORD_SIZE
argument_list|)
expr_stmt|;
name|d
operator|*=
name|HIGH_HALFWORD_COEFF
expr_stmt|;
name|d
operator|*=
name|HIGH_HALFWORD_COEFF
expr_stmt|;
name|d
operator|+=
call|(
name|USItype
call|)
argument_list|(
name|u
operator|&
operator|(
name|HIGH_WORD_COEFF
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_floatdisf
end_ifdef

begin_define
define|#
directive|define
name|WORD_SIZE
value|(sizeof (SItype) * BITS_PER_UNIT)
end_define

begin_define
define|#
directive|define
name|HIGH_HALFWORD_COEFF
value|(((UDItype) 1)<< (WORD_SIZE / 2))
end_define

begin_define
define|#
directive|define
name|HIGH_WORD_COEFF
value|(((UDItype) 1)<< WORD_SIZE)
end_define

begin_define
define|#
directive|define
name|DI_SIZE
value|(sizeof (DItype) * BITS_PER_UNIT)
end_define

begin_comment
comment|/* Define codes for all the float formats that we know of.  Note    that this is copied from real.h.  */
end_comment

begin_define
define|#
directive|define
name|UNKNOWN_FLOAT_FORMAT
value|0
end_define

begin_define
define|#
directive|define
name|IEEE_FLOAT_FORMAT
value|1
end_define

begin_define
define|#
directive|define
name|VAX_FLOAT_FORMAT
value|2
end_define

begin_define
define|#
directive|define
name|IBM_FLOAT_FORMAT
value|3
end_define

begin_comment
comment|/* Default to IEEE float if not specified.  Nearly all machines use it.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_FLOAT_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|HOST_FLOAT_FORMAT
value|IEEE_FLOAT_FORMAT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
end_if

begin_define
define|#
directive|define
name|DF_SIZE
value|53
end_define

begin_define
define|#
directive|define
name|SF_SIZE
value|24
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|==
name|IBM_FLOAT_FORMAT
end_if

begin_define
define|#
directive|define
name|DF_SIZE
value|56
end_define

begin_define
define|#
directive|define
name|SF_SIZE
value|24
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|==
name|VAX_FLOAT_FORMAT
end_if

begin_define
define|#
directive|define
name|DF_SIZE
value|56
end_define

begin_define
define|#
directive|define
name|SF_SIZE
value|24
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|SFtype
name|__floatdisf
parameter_list|(
name|DItype
name|u
parameter_list|)
block|{
comment|/* Do the calculation in DFmode      so that we don't lose any of the precision of the high word      while multiplying it.  */
name|DFtype
name|f
decl_stmt|;
comment|/* Protect against double-rounding error.      Represent any low-order bits, that might be truncated in DFmode,      by a bit that won't be lost.  The bit can go in anywhere below the      rounding position of the SFmode.  A fixed mask and bit position      handles all usual configurations.  It doesn't handle the case      of 128-bit DImode, however.  */
if|if
condition|(
name|DF_SIZE
operator|<
name|DI_SIZE
operator|&&
name|DF_SIZE
operator|>
operator|(
name|DI_SIZE
operator|-
name|DF_SIZE
operator|+
name|SF_SIZE
operator|)
condition|)
block|{
define|#
directive|define
name|REP_BIT
value|((USItype) 1<< (DI_SIZE - DF_SIZE))
if|if
condition|(
operator|!
operator|(
operator|-
operator|(
operator|(
name|DItype
operator|)
literal|1
operator|<<
name|DF_SIZE
operator|)
operator|<
name|u
operator|&&
name|u
operator|<
operator|(
operator|(
name|DItype
operator|)
literal|1
operator|<<
name|DF_SIZE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|USItype
operator|)
name|u
operator|&
operator|(
name|REP_BIT
operator|-
literal|1
operator|)
condition|)
name|u
operator||=
name|REP_BIT
expr_stmt|;
block|}
block|}
name|f
operator|=
call|(
name|SItype
call|)
argument_list|(
name|u
operator|>>
name|WORD_SIZE
argument_list|)
expr_stmt|;
name|f
operator|*=
name|HIGH_HALFWORD_COEFF
expr_stmt|;
name|f
operator|*=
name|HIGH_HALFWORD_COEFF
expr_stmt|;
name|f
operator|+=
call|(
name|USItype
call|)
argument_list|(
name|u
operator|&
operator|(
name|HIGH_WORD_COEFF
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SFtype
operator|)
name|f
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixunsxfsi
argument_list|)
operator|&&
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|96
end_if

begin_comment
comment|/* Reenable the normal types, in case limits.h needs them.  */
end_comment

begin_undef
undef|#
directive|undef
name|char
end_undef

begin_undef
undef|#
directive|undef
name|short
end_undef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_undef
undef|#
directive|undef
name|long
end_undef

begin_undef
undef|#
directive|undef
name|unsigned
end_undef

begin_undef
undef|#
directive|undef
name|float
end_undef

begin_undef
undef|#
directive|undef
name|double
end_undef

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_function
name|USItype
name|__fixunsxfsi
parameter_list|(
name|XFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|>=
operator|-
operator|(
name|DFtype
operator|)
name|LONG_MIN
condition|)
return|return
call|(
name|SItype
call|)
argument_list|(
name|a
operator|+
name|LONG_MIN
argument_list|)
operator|-
name|LONG_MIN
return|;
return|return
operator|(
name|SItype
operator|)
name|a
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_fixunsdfsi
end_ifdef

begin_comment
comment|/* Reenable the normal types, in case limits.h needs them.  */
end_comment

begin_undef
undef|#
directive|undef
name|char
end_undef

begin_undef
undef|#
directive|undef
name|short
end_undef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_undef
undef|#
directive|undef
name|long
end_undef

begin_undef
undef|#
directive|undef
name|unsigned
end_undef

begin_undef
undef|#
directive|undef
name|float
end_undef

begin_undef
undef|#
directive|undef
name|double
end_undef

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_function
name|USItype
name|__fixunsdfsi
parameter_list|(
name|DFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|>=
operator|-
operator|(
name|DFtype
operator|)
name|LONG_MIN
condition|)
return|return
call|(
name|SItype
call|)
argument_list|(
name|a
operator|+
name|LONG_MIN
argument_list|)
operator|-
name|LONG_MIN
return|;
return|return
operator|(
name|SItype
operator|)
name|a
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_fixunssfsi
end_ifdef

begin_comment
comment|/* Reenable the normal types, in case limits.h needs them.  */
end_comment

begin_undef
undef|#
directive|undef
name|char
end_undef

begin_undef
undef|#
directive|undef
name|short
end_undef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_undef
undef|#
directive|undef
name|long
end_undef

begin_undef
undef|#
directive|undef
name|unsigned
end_undef

begin_undef
undef|#
directive|undef
name|float
end_undef

begin_undef
undef|#
directive|undef
name|double
end_undef

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_function
name|USItype
name|__fixunssfsi
parameter_list|(
name|SFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|>=
operator|-
operator|(
name|SFtype
operator|)
name|LONG_MIN
condition|)
return|return
call|(
name|SItype
call|)
argument_list|(
name|a
operator|+
name|LONG_MIN
argument_list|)
operator|-
name|LONG_MIN
return|;
return|return
operator|(
name|SItype
operator|)
name|a
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* From here on down, the routines use normal data types.  */
end_comment

begin_define
define|#
directive|define
name|SItype
value|bogus_type
end_define

begin_define
define|#
directive|define
name|USItype
value|bogus_type
end_define

begin_define
define|#
directive|define
name|DItype
value|bogus_type
end_define

begin_define
define|#
directive|define
name|UDItype
value|bogus_type
end_define

begin_define
define|#
directive|define
name|SFtype
value|bogus_type
end_define

begin_define
define|#
directive|define
name|DFtype
value|bogus_type
end_define

begin_undef
undef|#
directive|undef
name|char
end_undef

begin_undef
undef|#
directive|undef
name|short
end_undef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_undef
undef|#
directive|undef
name|long
end_undef

begin_undef
undef|#
directive|undef
name|unsigned
end_undef

begin_undef
undef|#
directive|undef
name|float
end_undef

begin_undef
undef|#
directive|undef
name|double
end_undef

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L__gcc_bcmp
end_ifdef

begin_comment
comment|/* Like bcmp except the sign is meaningful.    Result is negative if S1 is less than S2,    positive if S1 is greater, 0 if S1 and S2 are equal.  */
end_comment

begin_function
name|int
name|__gcc_bcmp
parameter_list|(
name|unsigned
name|char
modifier|*
name|s1
parameter_list|,
name|unsigned
name|char
modifier|*
name|s2
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|unsigned
name|char
name|c1
init|=
operator|*
name|s1
operator|++
decl_stmt|,
name|c2
init|=
operator|*
name|s2
operator|++
decl_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
name|c1
operator|-
name|c2
return|;
name|size
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L__dummy
end_ifdef

begin_function
name|void
name|__dummy
parameter_list|()
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_varargs
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__i860__
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__svr4__
argument_list|)
operator|||
name|defined
argument_list|(
name|__alliant__
argument_list|)
end_if

begin_asm
asm|asm ("	.text");
end_asm

begin_asm
asm|asm ("	.align	4");
end_asm

begin_comment
comment|/* The Alliant needs the added underscore.  */
end_comment

begin_asm
asm|asm (".globl	__builtin_saveregs");
end_asm

begin_asm
asm|asm ("__builtin_saveregs:");
end_asm

begin_asm
asm|asm (".globl	___builtin_saveregs");
end_asm

begin_asm
asm|asm ("___builtin_saveregs:");
end_asm

begin_asm
asm|asm ("	andnot	0x0f,%sp,%sp");
end_asm

begin_comment
comment|/* round down to 16-byte boundary */
end_comment

begin_asm
asm|asm ("	adds	-96,%sp,%sp");
end_asm

begin_comment
comment|/* allocate stack space for reg save 					   area and also for a new va_list 					   structure */
end_comment

begin_comment
comment|/* Save all argument registers in the arg reg save area.  The 	   arg reg save area must have the following layout (according 	   to the svr4 ABI):  		struct { 		  union  { 		    float freg[8]; 		    double dreg[4]; 		  } float_regs; 		  long	ireg[12]; 		}; 	*/
end_comment

begin_asm
asm|asm ("	fst.q	%f8,  0(%sp)");
end_asm

begin_comment
comment|/* save floating regs (f8-f15)  */
end_comment

begin_asm
asm|asm ("	fst.q	%f12,16(%sp)");
end_asm

begin_asm
asm|asm ("	st.l	%r16,32(%sp)");
end_asm

begin_comment
comment|/* save integer regs (r16-r27) */
end_comment

begin_asm
asm|asm ("	st.l	%r17,36(%sp)");
end_asm

begin_asm
asm|asm ("	st.l	%r18,40(%sp)");
end_asm

begin_asm
asm|asm ("	st.l	%r19,44(%sp)");
end_asm

begin_asm
asm|asm ("	st.l	%r20,48(%sp)");
end_asm

begin_asm
asm|asm ("	st.l	%r21,52(%sp)");
end_asm

begin_asm
asm|asm ("	st.l	%r22,56(%sp)");
end_asm

begin_asm
asm|asm ("	st.l	%r23,60(%sp)");
end_asm

begin_asm
asm|asm ("	st.l	%r24,64(%sp)");
end_asm

begin_asm
asm|asm ("	st.l	%r25,68(%sp)");
end_asm

begin_asm
asm|asm ("	st.l	%r26,72(%sp)");
end_asm

begin_asm
asm|asm ("	st.l	%r27,76(%sp)");
end_asm

begin_asm
asm|asm ("	adds	80,%sp,%r16");
end_asm

begin_comment
comment|/* compute the address of the new 					   va_list structure.  Put in into 					   r16 so that it will be returned 					   to the caller.  */
end_comment

begin_comment
comment|/* Initialize all fields of the new va_list structure.  This 	   structure looks like:  		typedef struct { 		    unsigned long	ireg_used; 		    unsigned long	freg_used; 		    long		*reg_base; 		    long		*mem_ptr; 		} va_list; 	*/
end_comment

begin_asm
asm|asm ("	st.l	%r0, 0(%r16)");
end_asm

begin_comment
comment|/* nfixed */
end_comment

begin_asm
asm|asm ("	st.l	%r0, 4(%r16)");
end_asm

begin_comment
comment|/* nfloating */
end_comment

begin_asm
asm|asm ("  st.l    %sp, 8(%r16)");
end_asm

begin_comment
comment|/* __va_ctl points to __va_struct.  */
end_comment

begin_asm
asm|asm ("	bri	%r1");
end_asm

begin_comment
comment|/* delayed return */
end_comment

begin_asm
asm|asm ("	st.l	%r28,12(%r16)");
end_asm

begin_comment
comment|/* pointer to overflow args */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __svr4__ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__PARAGON__
argument_list|)
end_if

begin_comment
comment|/* 	 *	we'll use SVR4-ish varargs but need SVR3.2 assembler syntax, 	 *	and we stand a better chance of hooking into libraries 	 *	compiled by PGI.  [andyp@ssd.intel.com] 	 */
end_comment

begin_asm
asm|asm ("	.text");
end_asm

begin_asm
asm|asm ("	.align	4");
end_asm

begin_asm
asm|asm (".globl	__builtin_saveregs");
end_asm

begin_asm
asm|asm ("__builtin_saveregs:");
end_asm

begin_asm
asm|asm (".globl	___builtin_saveregs");
end_asm

begin_asm
asm|asm ("___builtin_saveregs:");
end_asm

begin_asm
asm|asm ("	andnot	0x0f,sp,sp");
end_asm

begin_comment
comment|/* round down to 16-byte boundary */
end_comment

begin_asm
asm|asm ("	adds	-96,sp,sp");
end_asm

begin_comment
comment|/* allocate stack space for reg save 					   area and also for a new va_list 					   structure */
end_comment

begin_comment
comment|/* Save all argument registers in the arg reg save area.  The 	   arg reg save area must have the following layout (according 	   to the svr4 ABI):  		struct { 		  union  { 		    float freg[8]; 		    double dreg[4]; 		  } float_regs; 		  long	ireg[12]; 		}; 	*/
end_comment

begin_asm
asm|asm ("	fst.q	f8,  0(sp)");
end_asm

begin_asm
asm|asm ("	fst.q	f12,16(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r16,32(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r17,36(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r18,40(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r19,44(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r20,48(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r21,52(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r22,56(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r23,60(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r24,64(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r25,68(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r26,72(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r27,76(sp)");
end_asm

begin_asm
asm|asm ("	adds	80,sp,r16");
end_asm

begin_comment
comment|/* compute the address of the new 					   va_list structure.  Put in into 					   r16 so that it will be returned 					   to the caller.  */
end_comment

begin_comment
comment|/* Initialize all fields of the new va_list structure.  This 	   structure looks like:  		typedef struct { 		    unsigned long	ireg_used; 		    unsigned long	freg_used; 		    long		*reg_base; 		    long		*mem_ptr; 		} va_list; 	*/
end_comment

begin_asm
asm|asm ("	st.l	r0, 0(r16)");
end_asm

begin_comment
comment|/* nfixed */
end_comment

begin_asm
asm|asm ("	st.l	r0, 4(r16)");
end_asm

begin_comment
comment|/* nfloating */
end_comment

begin_asm
asm|asm ("  st.l    sp, 8(r16)");
end_asm

begin_comment
comment|/* __va_ctl points to __va_struct.  */
end_comment

begin_asm
asm|asm ("	bri	r1");
end_asm

begin_comment
comment|/* delayed return */
end_comment

begin_asm
asm|asm ("	 st.l	r28,12(r16)");
end_asm

begin_comment
comment|/* pointer to overflow args */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __PARAGON__ */
end_comment

begin_asm
asm|asm ("	.text");
end_asm

begin_asm
asm|asm ("	.align	4");
end_asm

begin_asm
asm|asm (".globl	___builtin_saveregs");
end_asm

begin_asm
asm|asm ("___builtin_saveregs:");
end_asm

begin_asm
asm|asm ("	mov	sp,r30");
end_asm

begin_asm
asm|asm ("	andnot	0x0f,sp,sp");
end_asm

begin_asm
asm|asm ("	adds	-96,sp,sp");
end_asm

begin_comment
comment|/* allocate sufficient space on the stack */
end_comment

begin_comment
comment|/* Fill in the __va_struct.  */
end_comment

begin_asm
asm|asm ("	st.l	r16, 0(sp)");
end_asm

begin_comment
comment|/* save integer regs (r16-r27) */
end_comment

begin_asm
asm|asm ("	st.l	r17, 4(sp)");
end_asm

begin_comment
comment|/* int	fixed[12] */
end_comment

begin_asm
asm|asm ("	st.l	r18, 8(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r19,12(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r20,16(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r21,20(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r22,24(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r23,28(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r24,32(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r25,36(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r26,40(sp)");
end_asm

begin_asm
asm|asm ("	st.l	r27,44(sp)");
end_asm

begin_asm
asm|asm ("	fst.q	f8, 48(sp)");
end_asm

begin_comment
comment|/* save floating regs (f8-f15) */
end_comment

begin_asm
asm|asm ("	fst.q	f12,64(sp)");
end_asm

begin_comment
comment|/* int floating[8] */
end_comment

begin_comment
comment|/* Fill in the __va_ctl.  */
end_comment

begin_asm
asm|asm ("  st.l    sp, 80(sp)");
end_asm

begin_comment
comment|/* __va_ctl points to __va_struct.  */
end_comment

begin_asm
asm|asm ("	st.l	r28,84(sp)");
end_asm

begin_comment
comment|/* pointer to more args */
end_comment

begin_asm
asm|asm ("	st.l	r0, 88(sp)");
end_asm

begin_comment
comment|/* nfixed */
end_comment

begin_asm
asm|asm ("	st.l	r0, 92(sp)");
end_asm

begin_comment
comment|/* nfloating */
end_comment

begin_asm
asm|asm ("	adds	80,sp,r16");
end_asm

begin_comment
comment|/* return address of the __va_ctl.  */
end_comment

begin_asm
asm|asm ("	bri	r1");
end_asm

begin_asm
asm|asm ("	mov	r30,sp");
end_asm

begin_comment
comment|/* recover stack and pass address to start  				   of data.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __PARAGON__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __svr4__ */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __i860__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__sparc__
end_ifdef

begin_asm
asm|asm (".global __builtin_saveregs");
end_asm

begin_asm
asm|asm ("__builtin_saveregs:");
end_asm

begin_asm
asm|asm (".global ___builtin_saveregs");
end_asm

begin_asm
asm|asm ("___builtin_saveregs:");
end_asm

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_PROC_COMMAND
end_ifdef

begin_asm
asm|asm (".proc 020");
end_asm

begin_endif
endif|#
directive|endif
end_endif

begin_asm
asm|asm ("st %i0,[%fp+68]");
end_asm

begin_asm
asm|asm ("st %i1,[%fp+72]");
end_asm

begin_asm
asm|asm ("st %i2,[%fp+76]");
end_asm

begin_asm
asm|asm ("st %i3,[%fp+80]");
end_asm

begin_asm
asm|asm ("st %i4,[%fp+84]");
end_asm

begin_asm
asm|asm ("retl");
end_asm

begin_asm
asm|asm ("st %i5,[%fp+88]");
end_asm

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_TYPE_COMMAND
end_ifdef

begin_asm
asm|asm (".type __builtin_saveregs,#function");
end_asm

begin_asm
asm|asm (".size __builtin_saveregs,.-__builtin_saveregs");
end_asm

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __sparc__ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__MIPSEL__
argument_list|)
operator||
name|defined
argument_list|(
name|__R3000__
argument_list|)
operator||
name|defined
argument_list|(
name|__R2000__
argument_list|)
operator||
name|defined
argument_list|(
name|__mips__
argument_list|)
end_if

begin_asm
asm|asm ("	.text");
end_asm

begin_ifdef
ifdef|#
directive|ifdef
name|__mips16
end_ifdef

begin_asm
asm|asm ("	.set nomips16");
end_asm

begin_endif
endif|#
directive|endif
end_endif

begin_asm
asm|asm ("	.ent __builtin_saveregs");
end_asm

begin_asm
asm|asm ("	.globl __builtin_saveregs");
end_asm

begin_asm
asm|asm ("__builtin_saveregs:");
end_asm

begin_asm
asm|asm ("	sw	$4,0($30)");
end_asm

begin_asm
asm|asm ("	sw	$5,4($30)");
end_asm

begin_asm
asm|asm ("	sw	$6,8($30)");
end_asm

begin_asm
asm|asm ("	sw	$7,12($30)");
end_asm

begin_asm
asm|asm ("	j	$31");
end_asm

begin_asm
asm|asm ("	.end __builtin_saveregs");
end_asm

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __mips__, etc.  */
end_comment

begin_function
name|void
modifier|*
name|__builtin_saveregs
parameter_list|()
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __mips__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __sparc__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __i860__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_eprintf
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|inhibit_libc
end_ifndef

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_comment
comment|/* Avoid errors if stdio.h and our stddef.h mismatch.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* This is used by the `assert' macro.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|__eprintf
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__noreturn__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function
name|void
name|__eprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
specifier|const
name|char
modifier|*
name|expression
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|expression
argument_list|,
name|line
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_bb
end_ifdef

begin_comment
comment|/* Structure emitted by -a  */
end_comment

begin_struct
struct|struct
name|bb
block|{
name|long
name|zero_word
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|long
modifier|*
name|counts
decl_stmt|;
name|long
name|ncounts
decl_stmt|;
name|struct
name|bb
modifier|*
name|next
decl_stmt|;
specifier|const
name|unsigned
name|long
modifier|*
name|addresses
decl_stmt|;
comment|/* Older GCC's did not emit these fields.  */
name|long
name|nwords
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|functions
decl_stmt|;
specifier|const
name|long
modifier|*
name|line_nums
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|filenames
decl_stmt|;
name|char
modifier|*
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|BLOCK_PROFILER_CODE
end_ifdef

begin_function_decl
name|BLOCK_PROFILER_CODE
else|#
directive|else
ifndef|#
directive|ifndef
name|inhibit_libc
comment|/* Simple minded basic block profiling output dumper for    systems that don't provide tcov support.  At present,    it requires atexit and stdio.  */
undef|#
directive|undef
name|NULL
comment|/* Avoid errors if stdio.h and our stddef.h mismatch.  */
include|#
directive|include
file|<stdio.h>
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
end_function_decl

begin_include
include|#
directive|include
file|"gbl-ctors.h"
end_include

begin_include
include|#
directive|include
file|"gcov-io.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|bb
modifier|*
name|bb_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the number of digits needed to print a value */
end_comment

begin_comment
comment|/* __inline__ */
end_comment

begin_function
specifier|static
name|int
name|num_digits
parameter_list|(
name|long
name|value
parameter_list|,
name|int
name|base
parameter_list|)
block|{
name|int
name|minus
init|=
operator|(
name|value
operator|<
literal|0
operator|&&
name|base
operator|!=
literal|16
operator|)
decl_stmt|;
name|unsigned
name|long
name|v
init|=
operator|(
name|minus
operator|)
condition|?
operator|-
name|value
else|:
name|value
decl_stmt|;
name|int
name|ret
init|=
name|minus
decl_stmt|;
do|do
block|{
name|v
operator|/=
name|base
expr_stmt|;
name|ret
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|v
condition|)
do|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|__bb_exit_func
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|da_file
decl_stmt|,
modifier|*
name|file
decl_stmt|;
name|long
name|time_value
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bb_head
operator|==
literal|0
condition|)
return|return;
name|i
operator|=
name|strlen
argument_list|(
name|bb_head
operator|->
name|filename
argument_list|)
operator|-
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|bb_head
operator|->
name|filename
operator|+
name|i
argument_list|,
literal|".da"
argument_list|)
condition|)
block|{
comment|/* Must be -fprofile-arcs not -a. 	 Dump data in a form that gcov expects.  */
name|struct
name|bb
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|bb_head
init|;
name|ptr
operator|!=
operator|(
expr|struct
name|bb
operator|*
operator|)
literal|0
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
comment|/* If the file exists, and the number of counts in it is the same, 	     then merge them in.  */
if|if
condition|(
operator|(
name|da_file
operator|=
name|fopen
argument_list|(
name|ptr
operator|->
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|long
name|n_counts
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|__read_long
argument_list|(
operator|&
name|n_counts
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arc profiling: Can't read output file %s.\n"
argument_list|,
name|ptr
operator|->
name|filename
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|n_counts
operator|==
name|ptr
operator|->
name|ncounts
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_counts
condition|;
name|i
operator|++
control|)
block|{
name|long
name|v
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|__read_long
argument_list|(
operator|&
name|v
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arc profiling: Can't read output file %s.\n"
argument_list|,
name|ptr
operator|->
name|filename
argument_list|)
expr_stmt|;
break|break;
block|}
name|ptr
operator|->
name|counts
index|[
name|i
index|]
operator|+=
name|v
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fclose
argument_list|(
name|da_file
argument_list|)
operator|==
name|EOF
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arc profiling: Error closing output file %s.\n"
argument_list|,
name|ptr
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|da_file
operator|=
name|fopen
argument_list|(
name|ptr
operator|->
name|filename
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arc profiling: Can't open output file %s.\n"
argument_list|,
name|ptr
operator|->
name|filename
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* ??? Should first write a header to the file.  Preferably, a 4 byte 	     magic number, 4 bytes containing the time the program was 	     compiled, 4 bytes containing the last modification time of the 	     source file, and 4 bytes indicating the compiler options used.  	     That way we can easily verify that the proper source/executable/ 	     data file combination is being used from gcov.  */
if|if
condition|(
name|__write_long
argument_list|(
name|ptr
operator|->
name|ncounts
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arc profiling: Error writing output file %s.\n"
argument_list|,
name|ptr
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|j
decl_stmt|;
name|long
modifier|*
name|count_ptr
init|=
name|ptr
operator|->
name|counts
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
name|ptr
operator|->
name|ncounts
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|__write_long
argument_list|(
operator|*
name|count_ptr
argument_list|,
name|da_file
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|count_ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arc profiling: Error writing output file %s.\n"
argument_list|,
name|ptr
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|da_file
argument_list|)
operator|==
name|EOF
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arc profiling: Error closing output file %s.\n"
argument_list|,
name|ptr
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* Must be basic block profiling.  Emit a human readable output file.  */
name|file
operator|=
name|fopen
argument_list|(
literal|"bb.out"
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
name|perror
argument_list|(
literal|"bb.out"
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|bb
modifier|*
name|ptr
decl_stmt|;
comment|/* This is somewhat type incorrect, but it avoids worrying about 	 exactly where time.h is included from.  It should be ok unless 	 a void * differs from other pointer formats, or if sizeof (long) 	 is< sizeof (time_t).  It would be nice if we could assume the 	 use of rationale standards here.  */
name|time
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|time_value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Basic block profiling finished on %s\n"
argument_list|,
name|ctime
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|time_value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We check the length field explicitly in order to allow compatibility 	 with older GCC's which did not provide it.  */
for|for
control|(
name|ptr
operator|=
name|bb_head
init|;
name|ptr
operator|!=
operator|(
expr|struct
name|bb
operator|*
operator|)
literal|0
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|func_p
init|=
operator|(
name|ptr
operator|->
name|nwords
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|bb
argument_list|)
operator|&&
name|ptr
operator|->
name|nwords
operator|<=
literal|1000
operator|&&
name|ptr
operator|->
name|functions
operator|)
decl_stmt|;
name|int
name|line_p
init|=
operator|(
name|func_p
operator|&&
name|ptr
operator|->
name|line_nums
operator|)
decl_stmt|;
name|int
name|file_p
init|=
operator|(
name|func_p
operator|&&
name|ptr
operator|->
name|filenames
operator|)
decl_stmt|;
name|int
name|addr_p
init|=
operator|(
name|ptr
operator|->
name|addresses
operator|!=
literal|0
operator|)
decl_stmt|;
name|long
name|ncounts
init|=
name|ptr
operator|->
name|ncounts
decl_stmt|;
name|long
name|cnt_max
init|=
literal|0
decl_stmt|;
name|long
name|line_max
init|=
literal|0
decl_stmt|;
name|long
name|addr_max
init|=
literal|0
decl_stmt|;
name|int
name|file_len
init|=
literal|0
decl_stmt|;
name|int
name|func_len
init|=
literal|0
decl_stmt|;
name|int
name|blk_len
init|=
name|num_digits
argument_list|(
name|ncounts
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|int
name|cnt_len
decl_stmt|;
name|int
name|line_len
decl_stmt|;
name|int
name|addr_len
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"File %s, %ld basic blocks \n\n"
argument_list|,
name|ptr
operator|->
name|filename
argument_list|,
name|ncounts
argument_list|)
expr_stmt|;
comment|/* Get max values for each field.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncounts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|cnt_max
operator|<
name|ptr
operator|->
name|counts
index|[
name|i
index|]
condition|)
name|cnt_max
operator|=
name|ptr
operator|->
name|counts
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|addr_p
operator|&&
name|addr_max
operator|<
name|ptr
operator|->
name|addresses
index|[
name|i
index|]
condition|)
name|addr_max
operator|=
name|ptr
operator|->
name|addresses
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|line_p
operator|&&
name|line_max
operator|<
name|ptr
operator|->
name|line_nums
index|[
name|i
index|]
condition|)
name|line_max
operator|=
name|ptr
operator|->
name|line_nums
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|func_p
condition|)
block|{
name|p
operator|=
operator|(
name|ptr
operator|->
name|functions
index|[
name|i
index|]
operator|)
condition|?
operator|(
name|ptr
operator|->
name|functions
index|[
name|i
index|]
operator|)
else|:
literal|"<none>"
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|func_len
operator|<
name|len
condition|)
name|func_len
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|file_p
condition|)
block|{
name|p
operator|=
operator|(
name|ptr
operator|->
name|filenames
index|[
name|i
index|]
operator|)
condition|?
operator|(
name|ptr
operator|->
name|filenames
index|[
name|i
index|]
operator|)
else|:
literal|"<none>"
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_len
operator|<
name|len
condition|)
name|file_len
operator|=
name|len
expr_stmt|;
block|}
block|}
name|addr_len
operator|=
name|num_digits
argument_list|(
name|addr_max
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|cnt_len
operator|=
name|num_digits
argument_list|(
name|cnt_max
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|line_len
operator|=
name|num_digits
argument_list|(
name|line_max
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Now print out the basic block information.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncounts
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"    Block #%*d: executed %*ld time(s)"
argument_list|,
name|blk_len
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|cnt_len
argument_list|,
name|ptr
operator|->
name|counts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_p
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" address= 0x%.*lx"
argument_list|,
name|addr_len
argument_list|,
name|ptr
operator|->
name|addresses
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|func_p
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" function= %-*s"
argument_list|,
name|func_len
argument_list|,
operator|(
name|ptr
operator|->
name|functions
index|[
name|i
index|]
operator|)
condition|?
name|ptr
operator|->
name|functions
index|[
name|i
index|]
else|:
literal|"<none>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_p
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" line= %*ld"
argument_list|,
name|line_len
argument_list|,
name|ptr
operator|->
name|line_nums
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_p
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" file= %s"
argument_list|,
operator|(
name|ptr
operator|->
name|filenames
index|[
name|i
index|]
operator|)
condition|?
name|ptr
operator|->
name|filenames
index|[
name|i
index|]
else|:
literal|"<none>"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|__bb_init_func
parameter_list|(
name|struct
name|bb
modifier|*
name|blocks
parameter_list|)
block|{
comment|/* User is supposed to check whether the first word is non-0,      but just in case....  */
if|if
condition|(
name|blocks
operator|->
name|zero_word
condition|)
return|return;
ifdef|#
directive|ifdef
name|ON_EXIT
comment|/* Initialize destructor.  */
if|if
condition|(
operator|!
name|bb_head
condition|)
name|ON_EXIT
argument_list|(
name|__bb_exit_func
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set up linked list.  */
name|blocks
operator|->
name|zero_word
operator|=
literal|1
expr_stmt|;
name|blocks
operator|->
name|next
operator|=
name|bb_head
expr_stmt|;
name|bb_head
operator|=
name|blocks
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MACHINE_STATE_SAVE
end_ifndef

begin_define
define|#
directive|define
name|MACHINE_STATE_SAVE
parameter_list|(
name|ID
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MACHINE_STATE_RESTORE
end_ifndef

begin_define
define|#
directive|define
name|MACHINE_STATE_RESTORE
parameter_list|(
name|ID
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of buckets in hashtable of basic block addresses.  */
end_comment

begin_define
define|#
directive|define
name|BB_BUCKETS
value|311
end_define

begin_comment
comment|/* Maximum length of string in file bb.in.  */
end_comment

begin_define
define|#
directive|define
name|BBINBUFSIZE
value|500
end_define

begin_comment
comment|/* BBINBUFSIZE-1 with double quotes. We could use #BBINBUFSIZE or    "BBINBUFSIZE" but want to avoid trouble with preprocessors.  */
end_comment

begin_define
define|#
directive|define
name|BBINBUFSIZESTR
value|"499"
end_define

begin_struct
struct|struct
name|bb_edge
block|{
name|struct
name|bb_edge
modifier|*
name|next
decl_stmt|;
name|unsigned
name|long
name|src_addr
decl_stmt|;
name|unsigned
name|long
name|dst_addr
decl_stmt|;
name|unsigned
name|long
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|bb_func_mode
block|{
name|TRACE_KEEP
init|=
literal|0
block|,
name|TRACE_ON
init|=
literal|1
block|,
name|TRACE_OFF
init|=
literal|2
block|}
enum|;
end_enum

begin_struct
struct|struct
name|bb_func
block|{
name|struct
name|bb_func
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|funcname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|enum
name|bb_func_mode
name|mode
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is the connection to the outside world.    The BLOCK_PROFILER macro must set __bb.blocks    and __bb.blockno.  */
end_comment

begin_struct
struct|struct
block|{
name|unsigned
name|long
name|blockno
decl_stmt|;
name|struct
name|bb
modifier|*
name|blocks
decl_stmt|;
block|}
name|__bb
struct|;
end_struct

begin_comment
comment|/* Vars to store addrs of source and destination basic blocks     of a jump.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|bb_src
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|bb_dst
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|bb_tracefile
init|=
operator|(
name|FILE
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bb_edge
modifier|*
modifier|*
name|bb_hashbuckets
init|=
operator|(
expr|struct
name|bb_edge
operator|*
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bb_func
modifier|*
name|bb_func_head
init|=
operator|(
expr|struct
name|bb_func
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|bb_callcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bb_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
modifier|*
name|bb_stack
init|=
operator|(
name|unsigned
name|long
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|bb_stacksize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reported
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Trace modes: Always             :   Print execution frequencies of basic blocks                        to file bb.out. bb_mode& 1 != 0   :   Dump trace of basic blocks to file bbtrace[.gz] bb_mode& 2 != 0   :   Print jump frequencies to file bb.out. bb_mode& 4 != 0   :   Cut call instructions from basic block flow. bb_mode& 8 != 0   :   Insert return instructions in basic block flow. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_POPEN
end_ifdef

begin_comment
comment|/*#include<sys/types.h>*/
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/*#include<malloc.h>*/
end_comment

begin_comment
comment|/* Commands executed by gopen.  */
end_comment

begin_define
define|#
directive|define
name|GOPENDECOMPRESS
value|"gzip -cd "
end_define

begin_define
define|#
directive|define
name|GOPENCOMPRESS
value|"gzip -c>"
end_define

begin_comment
comment|/* Like fopen but pipes through gzip.  mode may only be "r" or "w".    If it does not compile, simply replace gopen by fopen and delete    '.gz' from any first parameter to gopen.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|gopen
parameter_list|(
name|char
modifier|*
name|fn
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|int
name|use_gzip
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|mode
index|[
literal|1
index|]
condition|)
return|return
operator|(
name|FILE
operator|*
operator|)
literal|0
return|;
if|if
condition|(
name|mode
index|[
literal|0
index|]
operator|!=
literal|'r'
operator|&&
name|mode
index|[
literal|0
index|]
operator|!=
literal|'w'
condition|)
return|return
operator|(
name|FILE
operator|*
operator|)
literal|0
return|;
name|p
operator|=
name|fn
operator|+
name|strlen
argument_list|(
name|fn
argument_list|)
operator|-
literal|1
expr_stmt|;
name|use_gzip
operator|=
operator|(
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'Z'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'z'
operator|)
operator|)
operator|||
operator|(
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'g'
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'z'
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|use_gzip
condition|)
block|{
if|if
condition|(
name|mode
index|[
literal|0
index|]
operator|==
literal|'r'
condition|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|strlen
argument_list|(
name|fn
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|GOPENDECOMPRESS
argument_list|)
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|GOPENDECOMPRESS
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|GOPENDECOMPRESS
argument_list|)
operator|-
literal|1
operator|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|f
operator|=
name|popen
argument_list|(
name|s
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
else|else
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|strlen
argument_list|(
name|fn
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|GOPENCOMPRESS
argument_list|)
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|GOPENCOMPRESS
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|GOPENCOMPRESS
argument_list|)
operator|-
literal|1
operator|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|f
operator|=
name|popen
argument_list|(
name|s
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
name|f
operator|=
name|fopen
argument_list|(
name|s
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
block|}
else|else
return|return
name|fopen
argument_list|(
name|fn
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gclose
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fstat
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
operator|&&
name|S_ISFIFO
argument_list|(
name|buf
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|pclose
argument_list|(
name|f
argument_list|)
return|;
return|return
name|fclose
argument_list|(
name|f
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_POPEN */
end_comment

begin_comment
comment|/* Called once per program.  */
end_comment

begin_function
specifier|static
name|void
name|__bb_exit_trace_func
parameter_list|()
block|{
name|FILE
modifier|*
name|file
init|=
name|fopen
argument_list|(
literal|"bb.out"
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|struct
name|bb_func
modifier|*
name|f
decl_stmt|;
name|struct
name|bb
modifier|*
name|b
decl_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
name|perror
argument_list|(
literal|"bb.out"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb_mode
operator|&
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bb_tracefile
condition|)
name|perror
argument_list|(
literal|"bbtrace"
argument_list|)
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|HAVE_POPEN
name|gclose
argument_list|(
name|bb_tracefile
argument_list|)
expr_stmt|;
else|#
directive|else
name|fclose
argument_list|(
name|bb_tracefile
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_POPEN */
block|}
comment|/* Check functions in `bb.in'.  */
if|if
condition|(
name|file
condition|)
block|{
name|long
name|time_value
decl_stmt|;
specifier|const
name|struct
name|bb_func
modifier|*
name|p
decl_stmt|;
name|int
name|printed_something
init|=
literal|0
decl_stmt|;
name|struct
name|bb
modifier|*
name|ptr
decl_stmt|;
name|long
name|blk
decl_stmt|;
comment|/* This is somewhat type incorrect.  */
name|time
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|time_value
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|bb_func_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bb_func
operator|*
operator|)
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
for|for
control|(
name|ptr
operator|=
name|bb_head
init|;
name|ptr
operator|!=
operator|(
expr|struct
name|bb
operator|*
operator|)
literal|0
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|ptr
operator|->
name|filename
operator|||
operator|(
name|p
operator|->
name|filename
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|strcmp
argument_list|(
name|p
operator|->
name|filename
argument_list|,
name|ptr
operator|->
name|filename
argument_list|)
operator|)
condition|)
continue|continue;
for|for
control|(
name|blk
operator|=
literal|0
init|;
name|blk
operator|<
name|ptr
operator|->
name|ncounts
condition|;
name|blk
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|funcname
argument_list|,
name|ptr
operator|->
name|functions
index|[
name|blk
index|]
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|printed_something
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Functions in `bb.in' not executed during basic block profiling on %s\n"
argument_list|,
name|ctime
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|time_value
argument_list|)
argument_list|)
expr_stmt|;
name|printed_something
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tFunction %s"
argument_list|,
name|p
operator|->
name|funcname
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|filename
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" of file %s"
argument_list|,
name|p
operator|->
name|filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|found
label|:
empty_stmt|;
block|}
if|if
condition|(
name|printed_something
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bb_mode
operator|&
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|bb_hashbuckets
condition|)
block|{
if|if
condition|(
operator|!
name|reported
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Profiler: out of memory\n"
argument_list|)
expr_stmt|;
name|reported
operator|=
literal|1
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|file
condition|)
block|{
name|long
name|time_value
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|addr_max
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|cnt_max
init|=
literal|0
decl_stmt|;
name|int
name|cnt_len
decl_stmt|;
name|int
name|addr_len
decl_stmt|;
comment|/* This is somewhat type incorrect, but it avoids worrying about              exactly where time.h is included from.  It should be ok unless              a void * differs from other pointer formats, or if sizeof (long)              is< sizeof (time_t).  It would be nice if we could assume the              use of rationale standards here.  */
name|time
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|time_value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Basic block jump tracing"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bb_mode
operator|&
literal|12
condition|)
block|{
case|case
literal|0
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" (with call)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* Print nothing.  */
break|break;
case|case
literal|8
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" (with call& ret)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" (with ret)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" finished on %s\n"
argument_list|,
name|ctime
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|time_value
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BB_BUCKETS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bb_edge
modifier|*
name|bucket
init|=
name|bb_hashbuckets
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
init|;
name|bucket
condition|;
name|bucket
operator|=
name|bucket
operator|->
name|next
control|)
block|{
if|if
condition|(
name|addr_max
operator|<
name|bucket
operator|->
name|src_addr
condition|)
name|addr_max
operator|=
name|bucket
operator|->
name|src_addr
expr_stmt|;
if|if
condition|(
name|addr_max
operator|<
name|bucket
operator|->
name|dst_addr
condition|)
name|addr_max
operator|=
name|bucket
operator|->
name|dst_addr
expr_stmt|;
if|if
condition|(
name|cnt_max
operator|<
name|bucket
operator|->
name|count
condition|)
name|cnt_max
operator|=
name|bucket
operator|->
name|count
expr_stmt|;
block|}
block|}
name|addr_len
operator|=
name|num_digits
argument_list|(
name|addr_max
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|cnt_len
operator|=
name|num_digits
argument_list|(
name|cnt_max
argument_list|,
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BB_BUCKETS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bb_edge
modifier|*
name|bucket
init|=
name|bb_hashbuckets
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
init|;
name|bucket
condition|;
name|bucket
operator|=
name|bucket
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Jump from block 0x%.*lx to "
literal|"block 0x%.*lx executed %*lu time(s)\n"
argument_list|,
name|addr_len
argument_list|,
name|bucket
operator|->
name|src_addr
argument_list|,
name|addr_len
argument_list|,
name|bucket
operator|->
name|dst_addr
argument_list|,
name|cnt_len
argument_list|,
name|bucket
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|file
condition|)
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Free allocated memory.  */
name|f
operator|=
name|bb_func_head
expr_stmt|;
while|while
condition|(
name|f
condition|)
block|{
name|struct
name|bb_func
modifier|*
name|old
init|=
name|f
decl_stmt|;
name|f
operator|=
name|f
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|funcname
condition|)
name|free
argument_list|(
name|old
operator|->
name|funcname
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|filename
condition|)
name|free
argument_list|(
name|old
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bb_stack
condition|)
name|free
argument_list|(
name|bb_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb_hashbuckets
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BB_BUCKETS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bb_edge
modifier|*
name|old
decl_stmt|,
modifier|*
name|bucket
init|=
name|bb_hashbuckets
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|bucket
condition|)
block|{
name|old
operator|=
name|bucket
expr_stmt|;
name|bucket
operator|=
name|bucket
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|bb_hashbuckets
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|b
operator|=
name|bb_head
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|next
control|)
if|if
condition|(
name|b
operator|->
name|flags
condition|)
name|free
argument_list|(
name|b
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called once per program.  */
end_comment

begin_function
specifier|static
name|void
name|__bb_init_prg
parameter_list|()
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
name|buf
index|[
name|BBINBUFSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|pos
decl_stmt|;
name|enum
name|bb_func_mode
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|ON_EXIT
comment|/* Initialize destructor.  */
name|ON_EXIT
argument_list|(
name|__bb_exit_func
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|file
operator|=
name|fopen
argument_list|(
literal|"bb.in"
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
return|return;
while|while
condition|(
name|fscanf
argument_list|(
name|file
argument_list|,
literal|" %"
name|BBINBUFSIZESTR
literal|"s "
argument_list|,
name|buf
argument_list|)
operator|!=
name|EOF
condition|)
block|{
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|m
operator|=
name|TRACE_OFF
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|TRACE_ON
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"__bb_trace__"
argument_list|)
condition|)
name|bb_mode
operator||=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"__bb_jumps__"
argument_list|)
condition|)
name|bb_mode
operator||=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"__bb_hidecall__"
argument_list|)
condition|)
name|bb_mode
operator||=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"__bb_showret__"
argument_list|)
condition|)
name|bb_mode
operator||=
literal|8
expr_stmt|;
else|else
block|{
name|struct
name|bb_func
modifier|*
name|f
init|=
operator|(
expr|struct
name|bb_func
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bb_func
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|unsigned
name|long
name|l
decl_stmt|;
name|f
operator|->
name|next
operator|=
name|bb_func_head
expr_stmt|;
if|if
condition|(
operator|(
name|pos
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|f
operator|->
name|funcname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
continue|continue;
name|strcpy
argument_list|(
name|f
operator|->
name|funcname
argument_list|,
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|l
operator|=
name|pos
operator|-
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|l
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
name|strncpy
argument_list|(
name|f
operator|->
name|filename
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|f
operator|->
name|filename
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|f
operator|->
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|f
operator|->
name|funcname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
continue|continue;
name|strcpy
argument_list|(
name|f
operator|->
name|funcname
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|f
operator|->
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|f
operator|->
name|mode
operator|=
name|m
expr_stmt|;
name|bb_func_head
operator|=
name|f
expr_stmt|;
block|}
block|}
block|}
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_POPEN
if|if
condition|(
name|bb_mode
operator|&
literal|1
condition|)
name|bb_tracefile
operator|=
name|gopen
argument_list|(
literal|"bbtrace.gz"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|bb_mode
operator|&
literal|1
condition|)
name|bb_tracefile
operator|=
name|fopen
argument_list|(
literal|"bbtrace"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_POPEN */
if|if
condition|(
name|bb_mode
operator|&
literal|2
condition|)
block|{
name|bb_hashbuckets
operator|=
operator|(
expr|struct
name|bb_edge
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|BB_BUCKETS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bb_edge
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb_hashbuckets
condition|)
name|memset
argument_list|(
name|bb_hashbuckets
argument_list|,
literal|0
argument_list|,
name|BB_BUCKETS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bb_edge
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bb_mode
operator|&
literal|12
condition|)
block|{
name|bb_stacksize
operator|=
literal|10
expr_stmt|;
name|bb_stack
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|malloc
argument_list|(
name|bb_stacksize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|bb_stack
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ON_EXIT
comment|/* Initialize destructor.  */
name|ON_EXIT
argument_list|(
name|__bb_exit_trace_func
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Called upon entering a basic block.  */
end_comment

begin_function
name|void
name|__bb_trace_func
parameter_list|()
block|{
name|struct
name|bb_edge
modifier|*
name|bucket
decl_stmt|;
name|MACHINE_STATE_SAVE
argument_list|(
literal|"1"
argument_list|)
if|if
condition|(
operator|!
name|bb_callcount
operator|||
operator|(
name|__bb
operator|.
name|blocks
operator|->
name|flags
operator|&&
operator|(
name|__bb
operator|.
name|blocks
operator|->
name|flags
index|[
name|__bb
operator|.
name|blockno
index|]
operator|&
name|TRACE_OFF
operator|)
operator|)
condition|)
goto|goto
name|skip
goto|;
name|bb_dst
operator|=
name|__bb
operator|.
name|blocks
operator|->
name|addresses
index|[
name|__bb
operator|.
name|blockno
index|]
expr_stmt|;
name|__bb
operator|.
name|blocks
operator|->
name|counts
index|[
name|__bb
operator|.
name|blockno
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|bb_tracefile
condition|)
block|{
name|fwrite
argument_list|(
operator|&
name|bb_dst
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|,
literal|1
argument_list|,
name|bb_tracefile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bb_hashbuckets
condition|)
block|{
name|struct
name|bb_edge
modifier|*
modifier|*
name|startbucket
decl_stmt|,
modifier|*
modifier|*
name|oldnext
decl_stmt|;
name|oldnext
operator|=
name|startbucket
operator|=
operator|&
name|bb_hashbuckets
index|[
operator|(
operator|(
operator|(
name|int
operator|)
name|bb_src
operator|*
literal|8
operator|)
operator|^
operator|(
name|int
operator|)
name|bb_dst
operator|)
operator|%
name|BB_BUCKETS
index|]
expr_stmt|;
name|bucket
operator|=
operator|*
name|startbucket
expr_stmt|;
for|for
control|(
name|bucket
operator|=
operator|*
name|startbucket
init|;
name|bucket
condition|;
name|oldnext
operator|=
operator|&
operator|(
name|bucket
operator|->
name|next
operator|)
operator|,
name|bucket
operator|=
operator|*
name|oldnext
control|)
block|{
if|if
condition|(
name|bucket
operator|->
name|src_addr
operator|==
name|bb_src
operator|&&
name|bucket
operator|->
name|dst_addr
operator|==
name|bb_dst
condition|)
block|{
name|bucket
operator|->
name|count
operator|++
expr_stmt|;
operator|*
name|oldnext
operator|=
name|bucket
operator|->
name|next
expr_stmt|;
name|bucket
operator|->
name|next
operator|=
operator|*
name|startbucket
expr_stmt|;
operator|*
name|startbucket
operator|=
name|bucket
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
name|bucket
operator|=
operator|(
expr|struct
name|bb_edge
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bb_edge
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bucket
condition|)
block|{
if|if
condition|(
operator|!
name|reported
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Profiler: out of memory\n"
argument_list|)
expr_stmt|;
name|reported
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|bucket
operator|->
name|src_addr
operator|=
name|bb_src
expr_stmt|;
name|bucket
operator|->
name|dst_addr
operator|=
name|bb_dst
expr_stmt|;
name|bucket
operator|->
name|next
operator|=
operator|*
name|startbucket
expr_stmt|;
operator|*
name|startbucket
operator|=
name|bucket
expr_stmt|;
name|bucket
operator|->
name|count
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|ret
label|:
name|bb_src
operator|=
name|bb_dst
expr_stmt|;
name|skip
label|:
empty_stmt|;
name|MACHINE_STATE_RESTORE
argument_list|(
literal|"1"
argument_list|)
block|}
end_function

begin_comment
comment|/* Called when returning from a function and `__bb_showret__' is set.  */
end_comment

begin_function
specifier|static
name|void
name|__bb_trace_func_ret
parameter_list|()
block|{
name|struct
name|bb_edge
modifier|*
name|bucket
decl_stmt|;
if|if
condition|(
operator|!
name|bb_callcount
operator|||
operator|(
name|__bb
operator|.
name|blocks
operator|->
name|flags
operator|&&
operator|(
name|__bb
operator|.
name|blocks
operator|->
name|flags
index|[
name|__bb
operator|.
name|blockno
index|]
operator|&
name|TRACE_OFF
operator|)
operator|)
condition|)
goto|goto
name|skip
goto|;
if|if
condition|(
name|bb_hashbuckets
condition|)
block|{
name|struct
name|bb_edge
modifier|*
modifier|*
name|startbucket
decl_stmt|,
modifier|*
modifier|*
name|oldnext
decl_stmt|;
name|oldnext
operator|=
name|startbucket
operator|=
operator|&
name|bb_hashbuckets
index|[
operator|(
operator|(
operator|(
name|int
operator|)
name|bb_dst
operator|*
literal|8
operator|)
operator|^
operator|(
name|int
operator|)
name|bb_src
operator|)
operator|%
name|BB_BUCKETS
index|]
expr_stmt|;
name|bucket
operator|=
operator|*
name|startbucket
expr_stmt|;
for|for
control|(
name|bucket
operator|=
operator|*
name|startbucket
init|;
name|bucket
condition|;
name|oldnext
operator|=
operator|&
operator|(
name|bucket
operator|->
name|next
operator|)
operator|,
name|bucket
operator|=
operator|*
name|oldnext
control|)
block|{
if|if
condition|(
name|bucket
operator|->
name|src_addr
operator|==
name|bb_dst
operator|&&
name|bucket
operator|->
name|dst_addr
operator|==
name|bb_src
condition|)
block|{
name|bucket
operator|->
name|count
operator|++
expr_stmt|;
operator|*
name|oldnext
operator|=
name|bucket
operator|->
name|next
expr_stmt|;
name|bucket
operator|->
name|next
operator|=
operator|*
name|startbucket
expr_stmt|;
operator|*
name|startbucket
operator|=
name|bucket
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
name|bucket
operator|=
operator|(
expr|struct
name|bb_edge
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bb_edge
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bucket
condition|)
block|{
if|if
condition|(
operator|!
name|reported
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Profiler: out of memory\n"
argument_list|)
expr_stmt|;
name|reported
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|bucket
operator|->
name|src_addr
operator|=
name|bb_dst
expr_stmt|;
name|bucket
operator|->
name|dst_addr
operator|=
name|bb_src
expr_stmt|;
name|bucket
operator|->
name|next
operator|=
operator|*
name|startbucket
expr_stmt|;
operator|*
name|startbucket
operator|=
name|bucket
expr_stmt|;
name|bucket
operator|->
name|count
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|ret
label|:
name|bb_dst
operator|=
name|bb_src
expr_stmt|;
name|skip
label|:
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Called upon entering the first function of a file.  */
end_comment

begin_function
specifier|static
name|void
name|__bb_init_file
parameter_list|(
name|struct
name|bb
modifier|*
name|blocks
parameter_list|)
block|{
specifier|const
name|struct
name|bb_func
modifier|*
name|p
decl_stmt|;
name|long
name|blk
decl_stmt|,
name|ncounts
init|=
name|blocks
operator|->
name|ncounts
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|functions
init|=
name|blocks
operator|->
name|functions
decl_stmt|;
comment|/* Set up linked list.  */
name|blocks
operator|->
name|zero_word
operator|=
literal|1
expr_stmt|;
name|blocks
operator|->
name|next
operator|=
name|bb_head
expr_stmt|;
name|bb_head
operator|=
name|blocks
expr_stmt|;
name|blocks
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|bb_func_head
operator|||
operator|!
operator|(
name|blocks
operator|->
name|flags
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|blocks
operator|->
name|ncounts
argument_list|)
operator|)
condition|)
return|return;
for|for
control|(
name|blk
operator|=
literal|0
init|;
name|blk
operator|<
name|ncounts
condition|;
name|blk
operator|++
control|)
name|blocks
operator|->
name|flags
index|[
name|blk
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|blk
operator|=
literal|0
init|;
name|blk
operator|<
name|ncounts
condition|;
name|blk
operator|++
control|)
block|{
for|for
control|(
name|p
operator|=
name|bb_func_head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|funcname
argument_list|,
name|functions
index|[
name|blk
index|]
argument_list|)
operator|&&
operator|(
operator|!
name|p
operator|->
name|filename
operator|||
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|filename
argument_list|,
name|blocks
operator|->
name|filename
argument_list|)
operator|)
condition|)
block|{
name|blocks
operator|->
name|flags
index|[
name|blk
index|]
operator||=
name|p
operator|->
name|mode
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Called when exiting from a function.  */
end_comment

begin_function
name|void
name|__bb_trace_ret
parameter_list|()
block|{
name|MACHINE_STATE_SAVE
argument_list|(
literal|"2"
argument_list|)
if|if
condition|(
name|bb_callcount
condition|)
block|{
if|if
condition|(
operator|(
name|bb_mode
operator|&
literal|12
operator|)
operator|&&
name|bb_stacksize
operator|>
name|bb_callcount
condition|)
block|{
name|bb_src
operator|=
name|bb_stack
index|[
name|bb_callcount
index|]
expr_stmt|;
if|if
condition|(
name|bb_mode
operator|&
literal|8
condition|)
name|__bb_trace_func_ret
argument_list|()
expr_stmt|;
block|}
name|bb_callcount
operator|-=
literal|1
expr_stmt|;
block|}
name|MACHINE_STATE_RESTORE
argument_list|(
literal|"2"
argument_list|)
block|}
end_function

begin_comment
comment|/* Called when entering a function.  */
end_comment

begin_function
name|void
name|__bb_init_trace_func
parameter_list|(
name|struct
name|bb
modifier|*
name|blocks
parameter_list|,
name|unsigned
name|long
name|blockno
parameter_list|)
block|{
specifier|static
name|int
name|trace_init
init|=
literal|0
decl_stmt|;
name|MACHINE_STATE_SAVE
argument_list|(
literal|"3"
argument_list|)
if|if
condition|(
operator|!
name|blocks
operator|->
name|zero_word
condition|)
block|{
if|if
condition|(
operator|!
name|trace_init
condition|)
block|{
name|trace_init
operator|=
literal|1
expr_stmt|;
name|__bb_init_prg
argument_list|()
expr_stmt|;
block|}
name|__bb_init_file
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bb_callcount
condition|)
block|{
name|bb_callcount
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|bb_mode
operator|&
literal|12
condition|)
block|{
if|if
condition|(
name|bb_callcount
operator|>=
name|bb_stacksize
condition|)
block|{
name|size_t
name|newsize
init|=
name|bb_callcount
operator|+
literal|100
decl_stmt|;
name|bb_stack
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|realloc
argument_list|(
name|bb_stack
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bb_stack
condition|)
block|{
if|if
condition|(
operator|!
name|reported
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Profiler: out of memory\n"
argument_list|)
expr_stmt|;
name|reported
operator|=
literal|1
expr_stmt|;
block|}
name|bb_stacksize
operator|=
literal|0
expr_stmt|;
goto|goto
name|stack_overflow
goto|;
block|}
name|bb_stacksize
operator|=
name|newsize
expr_stmt|;
block|}
name|bb_stack
index|[
name|bb_callcount
index|]
operator|=
name|bb_src
expr_stmt|;
if|if
condition|(
name|bb_mode
operator|&
literal|4
condition|)
name|bb_src
operator|=
literal|0
expr_stmt|;
block|}
name|stack_overflow
label|:
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|blocks
operator|->
name|flags
operator|&&
operator|(
name|blocks
operator|->
name|flags
index|[
name|blockno
index|]
operator|&
name|TRACE_ON
operator|)
condition|)
block|{
name|bb_callcount
operator|=
literal|1
expr_stmt|;
name|bb_src
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bb_stack
condition|)
name|bb_stack
index|[
name|bb_callcount
index|]
operator|=
name|bb_src
expr_stmt|;
block|}
name|MACHINE_STATE_RESTORE
argument_list|(
literal|"3"
argument_list|)
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not inhibit_libc */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not BLOCK_PROFILER_CODE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_bb */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_shtab
end_ifdef

begin_decl_stmt
name|unsigned
name|int
name|__shtab
index|[]
init|=
block|{
literal|0x00000001
block|,
literal|0x00000002
block|,
literal|0x00000004
block|,
literal|0x00000008
block|,
literal|0x00000010
block|,
literal|0x00000020
block|,
literal|0x00000040
block|,
literal|0x00000080
block|,
literal|0x00000100
block|,
literal|0x00000200
block|,
literal|0x00000400
block|,
literal|0x00000800
block|,
literal|0x00001000
block|,
literal|0x00002000
block|,
literal|0x00004000
block|,
literal|0x00008000
block|,
literal|0x00010000
block|,
literal|0x00020000
block|,
literal|0x00040000
block|,
literal|0x00080000
block|,
literal|0x00100000
block|,
literal|0x00200000
block|,
literal|0x00400000
block|,
literal|0x00800000
block|,
literal|0x01000000
block|,
literal|0x02000000
block|,
literal|0x04000000
block|,
literal|0x08000000
block|,
literal|0x10000000
block|,
literal|0x20000000
block|,
literal|0x40000000
block|,
literal|0x80000000
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_clear_cache
end_ifdef

begin_comment
comment|/* Clear part of an instruction cache.  */
end_comment

begin_define
define|#
directive|define
name|INSN_CACHE_PLANE_SIZE
value|(INSN_CACHE_SIZE / INSN_CACHE_DEPTH)
end_define

begin_function
name|void
name|__clear_cache
parameter_list|(
name|char
modifier|*
name|beg
parameter_list|,
name|char
modifier|*
name|end
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CLEAR_INSN_CACHE
name|CLEAR_INSN_CACHE
argument_list|(
name|beg
argument_list|,
name|end
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|INSN_CACHE_SIZE
specifier|static
name|char
name|array
index|[
name|INSN_CACHE_SIZE
operator|+
name|INSN_CACHE_PLANE_SIZE
operator|+
name|INSN_CACHE_LINE_WIDTH
index|]
decl_stmt|;
specifier|static
name|int
name|initialized
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|void
modifier|*
name|start_addr
name|void
modifier|*
name|end_addr
decl_stmt|;
typedef|typedef
call|(
modifier|*
name|function_ptr
call|)
argument_list|()
expr_stmt|;
if|#
directive|if
operator|(
name|INSN_CACHE_SIZE
operator|/
name|INSN_CACHE_LINE_WIDTH
operator|)
operator|<
literal|16
comment|/* It's cheaper to clear the whole cache.      Put in a series of jump instructions so that calling the beginning      of the cache will clear the whole thing.  */
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|int
name|ptr
init|=
operator|(
operator|(
operator|(
name|int
operator|)
name|array
operator|+
name|INSN_CACHE_LINE_WIDTH
operator|-
literal|1
operator|)
operator|&
operator|-
name|INSN_CACHE_LINE_WIDTH
operator|)
decl_stmt|;
name|int
name|end_ptr
init|=
name|ptr
operator|+
name|INSN_CACHE_SIZE
decl_stmt|;
while|while
condition|(
name|ptr
operator|<
name|end_ptr
condition|)
block|{
operator|*
operator|(
name|INSTRUCTION_TYPE
operator|*
operator|)
name|ptr
operator|=
name|JUMP_AHEAD_INSTRUCTION
operator|+
name|INSN_CACHE_LINE_WIDTH
expr_stmt|;
name|ptr
operator|+=
name|INSN_CACHE_LINE_WIDTH
expr_stmt|;
block|}
operator|*
operator|(
name|INSTRUCTION_TYPE
operator|*
operator|)
operator|(
name|ptr
operator|-
name|INSN_CACHE_LINE_WIDTH
operator|)
operator|=
name|RETURN_INSTRUCTION
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Call the beginning of the sequence.  */
operator|(
operator|(
call|(
name|function_ptr
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
name|array
operator|+
name|INSN_CACHE_LINE_WIDTH
operator|-
literal|1
operator|)
operator|&
operator|-
name|INSN_CACHE_LINE_WIDTH
argument_list|)
operator|)
operator|(
operator|)
operator|)
expr_stmt|;
else|#
directive|else
comment|/* Cache is large.  */
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|int
name|ptr
init|=
operator|(
operator|(
operator|(
name|int
operator|)
name|array
operator|+
name|INSN_CACHE_LINE_WIDTH
operator|-
literal|1
operator|)
operator|&
operator|-
name|INSN_CACHE_LINE_WIDTH
operator|)
decl_stmt|;
while|while
condition|(
name|ptr
operator|<
operator|(
name|int
operator|)
name|array
operator|+
sizeof|sizeof
name|array
condition|)
block|{
operator|*
operator|(
name|INSTRUCTION_TYPE
operator|*
operator|)
name|ptr
operator|=
name|RETURN_INSTRUCTION
expr_stmt|;
name|ptr
operator|+=
name|INSN_CACHE_LINE_WIDTH
expr_stmt|;
block|}
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Find the location in array that occupies the same cache line as BEG.  */
name|offset
operator|=
operator|(
operator|(
name|int
operator|)
name|beg
operator|&
operator|-
name|INSN_CACHE_LINE_WIDTH
operator|)
operator|&
operator|(
name|INSN_CACHE_PLANE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|start_addr
operator|=
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
name|array
operator|+
name|INSN_CACHE_PLANE_SIZE
operator|-
literal|1
argument_list|)
operator|&
operator|-
name|INSN_CACHE_PLANE_SIZE
operator|)
operator|+
name|offset
operator|)
expr_stmt|;
comment|/* Compute the cache alignment of the place to stop clearing.  */
if|#
directive|if
literal|0
comment|/* This is not needed for gcc's purposes.  */
comment|/* If the block to clear is bigger than a cache plane,      we clear the entire cache, and OFFSET is already correct.  */
block|if (end< beg + INSN_CACHE_PLANE_SIZE)
endif|#
directive|endif
name|offset
operator|=
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
name|end
operator|+
name|INSN_CACHE_LINE_WIDTH
operator|-
literal|1
argument_list|)
operator|&
operator|-
name|INSN_CACHE_LINE_WIDTH
operator|)
operator|&
operator|(
name|INSN_CACHE_PLANE_SIZE
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|#
directive|if
name|INSN_CACHE_DEPTH
operator|>
literal|1
name|end_addr
operator|=
operator|(
name|start_addr
operator|&
operator|-
name|INSN_CACHE_PLANE_SIZE
operator|)
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|end_addr
operator|<=
name|start_addr
condition|)
name|end_addr
operator|+=
name|INSN_CACHE_PLANE_SIZE
expr_stmt|;
for|for
control|(
name|plane
operator|=
literal|0
init|;
name|plane
operator|<
name|INSN_CACHE_DEPTH
condition|;
name|plane
operator|++
control|)
block|{
name|int
name|addr
init|=
name|start_addr
operator|+
name|plane
operator|*
name|INSN_CACHE_PLANE_SIZE
decl_stmt|;
name|int
name|stop
init|=
name|end_addr
operator|+
name|plane
operator|*
name|INSN_CACHE_PLANE_SIZE
decl_stmt|;
while|while
condition|(
name|addr
operator|!=
name|stop
condition|)
block|{
comment|/* Call the return instruction at ADDR.  */
operator|(
operator|(
name|function_ptr
operator|)
name|addr
operator|)
operator|(
operator|)
expr_stmt|;
name|addr
operator|+=
name|INSN_CACHE_LINE_WIDTH
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* just one plane */
do|do
block|{
comment|/* Call the return instruction at START_ADDR.  */
operator|(
operator|(
name|function_ptr
operator|)
name|start_addr
operator|)
operator|(
operator|)
expr_stmt|;
name|start_addr
operator|+=
name|INSN_CACHE_LINE_WIDTH
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|start_addr
operator|%
name|INSN_CACHE_SIZE
operator|)
operator|!=
name|offset
condition|)
do|;
endif|#
directive|endif
comment|/* just one plane */
endif|#
directive|endif
comment|/* Cache is large */
endif|#
directive|endif
comment|/* Cache exists */
endif|#
directive|endif
comment|/* CLEAR_INSN_CACHE */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_clear_cache */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_trampoline
end_ifdef

begin_comment
comment|/* Jump to a trampoline, loading the static chain address.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_UWIN
argument_list|)
end_if

begin_function
name|long
name|getpagesize
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|_ALPHA_
return|return
literal|8192
return|;
else|#
directive|else
return|return
literal|4096
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|i386
end_ifdef

begin_function_decl
specifier|extern
name|int
name|VirtualProtect
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(stdcall
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|mprotect
parameter_list|(
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
name|int
name|np
decl_stmt|,
name|op
decl_stmt|;
if|if
condition|(
name|prot
operator|==
literal|7
condition|)
name|np
operator|=
literal|0x40
expr_stmt|;
elseif|else
if|if
condition|(
name|prot
operator|==
literal|5
condition|)
name|np
operator|=
literal|0x20
expr_stmt|;
elseif|else
if|if
condition|(
name|prot
operator|==
literal|4
condition|)
name|np
operator|=
literal|0x10
expr_stmt|;
elseif|else
if|if
condition|(
name|prot
operator|==
literal|3
condition|)
name|np
operator|=
literal|0x04
expr_stmt|;
elseif|else
if|if
condition|(
name|prot
operator|==
literal|1
condition|)
name|np
operator|=
literal|0x02
expr_stmt|;
elseif|else
if|if
condition|(
name|prot
operator|==
literal|0
condition|)
name|np
operator|=
literal|0x01
expr_stmt|;
if|if
condition|(
name|VirtualProtect
argument_list|(
name|addr
argument_list|,
name|len
argument_list|,
name|np
argument_list|,
operator|&
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WINNT&& ! __CYGWIN__&& ! _UWIN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TRANSFER_FROM_TRAMPOLINE
end_ifdef

begin_function
name|TRANSFER_FROM_TRAMPOLINE
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|NeXT
argument_list|)
operator|&&
name|defined
argument_list|(
name|__MACH__
argument_list|)
comment|/* Make stack executable so we can call trampolines on stack.    This is called from INITIALIZE_TRAMPOLINE in next.h.  */
ifdef|#
directive|ifdef
name|NeXTStep21
include|#
directive|include
file|<mach.h>
else|#
directive|else
include|#
directive|include
file|<mach/mach.h>
endif|#
directive|endif
name|void
name|__enable_execute_stack
parameter_list|(
name|char
modifier|*
name|addr
parameter_list|)
block|{
name|kern_return_t
name|r
decl_stmt|;
name|char
modifier|*
name|eaddr
init|=
name|addr
operator|+
name|TRAMPOLINE_SIZE
decl_stmt|;
name|vm_address_t
name|a
init|=
operator|(
name|vm_address_t
operator|)
name|addr
decl_stmt|;
comment|/* turn on execute access on stack */
name|r
operator|=
name|vm_protect
argument_list|(
name|task_self
argument_list|()
argument_list|,
name|a
argument_list|,
name|TRAMPOLINE_SIZE
argument_list|,
name|FALSE
argument_list|,
name|VM_PROT_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|mach_error
argument_list|(
literal|"vm_protect VM_PROT_ALL"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* We inline the i-cache invalidation for speed */
ifdef|#
directive|ifdef
name|CLEAR_INSN_CACHE
name|CLEAR_INSN_CACHE
argument_list|(
name|addr
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
else|#
directive|else
name|__clear_cache
argument_list|(
operator|(
name|int
operator|)
name|addr
argument_list|,
operator|(
name|int
operator|)
name|eaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (NeXT)&& defined (__MACH__) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__convex__
end_ifdef

begin_comment
comment|/* Make stack executable so we can call trampolines on stack.    This is called from INITIALIZE_TRAMPOLINE in convex.h.  */
end_comment

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<machine/machparam.h>
end_include

begin_function
name|void
name|__enable_execute_stack
parameter_list|()
block|{
name|int
name|fp
decl_stmt|;
specifier|static
name|unsigned
name|lowest
init|=
name|USRSTACK
decl_stmt|;
name|unsigned
name|current
init|=
operator|(
name|unsigned
operator|)
operator|&
name|fp
operator|&
operator|-
name|NBPG
decl_stmt|;
if|if
condition|(
name|lowest
operator|>
name|current
condition|)
block|{
name|unsigned
name|len
init|=
name|lowest
operator|-
name|current
decl_stmt|;
name|mremap
argument_list|(
name|current
argument_list|,
operator|&
name|len
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|,
name|MAP_PRIVATE
argument_list|)
expr_stmt|;
name|lowest
operator|=
name|current
expr_stmt|;
block|}
comment|/* Clear instruction cache in case an old trampoline is in it.  */
asm|asm ("pich");
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __convex__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__sysV88__
end_ifdef

begin_comment
comment|/* Modified from the convex -code above.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/m88kbcs.h>
end_include

begin_function
name|void
name|__enable_execute_stack
parameter_list|()
block|{
name|int
name|save_errno
decl_stmt|;
specifier|static
name|unsigned
name|long
name|lowest
init|=
name|USRSTACK
decl_stmt|;
name|unsigned
name|long
name|current
init|=
operator|(
name|unsigned
name|long
operator|)
operator|&
name|save_errno
operator|&
operator|-
name|NBPC
decl_stmt|;
comment|/* Ignore errno being set. memctl sets errno to EINVAL whenever the      address is seen as 'negative'. That is the case with the stack.   */
name|save_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|lowest
operator|>
name|current
condition|)
block|{
name|unsigned
name|len
init|=
name|lowest
operator|-
name|current
decl_stmt|;
name|memctl
argument_list|(
name|current
argument_list|,
name|len
argument_list|,
name|MCT_TEXT
argument_list|)
expr_stmt|;
name|lowest
operator|=
name|current
expr_stmt|;
block|}
else|else
name|memctl
argument_list|(
name|current
argument_list|,
name|NBPC
argument_list|,
name|MCT_TEXT
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __sysV88__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__sysV68__
end_ifdef

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* Motorola forgot to put memctl.o in the libp version of libc881.a,    so define it here, because we need it in __clear_insn_cache below */
end_comment

begin_comment
comment|/* On older versions of this OS, no memctl or MCT_TEXT are defined;    hence we enable this stuff only if MCT_TEXT is #define'd.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MCT_TEXT
end_ifdef

begin_asm
asm|asm("\n\ 	global memctl\n\ memctl:\n\ 	movq&75,%d0\n\ 	trap&0\n\ 	bcc.b noerror\n\ 	jmp cerror%\n\ noerror:\n\ 	movq&0,%d0\n\ 	rts");
end_asm

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Clear instruction cache so we can call trampolines on stack.    This is called from FINALIZE_TRAMPOLINE in mot3300.h.  */
end_comment

begin_function
name|void
name|__clear_insn_cache
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|MCT_TEXT
name|int
name|save_errno
decl_stmt|;
comment|/* Preserve errno, because users would be surprised to have   errno changing without explicitly calling any system-call. */
name|save_errno
operator|=
name|errno
expr_stmt|;
comment|/* Keep it simple : memctl (MCT_TEXT) always fully clears the insn cache.       No need to use an address derived from _start or %sp, as 0 works also. */
name|memctl
argument_list|(
literal|0
argument_list|,
literal|4096
argument_list|,
name|MCT_TEXT
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __sysV68__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__pyr__
end_ifdef

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_comment
comment|/* Avoid errors if stdio.h and our stddef.h mismatch.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmac.h>
end_include

begin_comment
comment|/* Modified from the convex -code above.    mremap promises to clear the i-cache.  */
end_comment

begin_function
name|void
name|__enable_execute_stack
parameter_list|()
block|{
name|int
name|fp
decl_stmt|;
if|if
condition|(
name|mprotect
argument_list|(
operator|(
operator|(
name|unsigned
name|int
operator|)
operator|&
name|fp
operator|/
name|PAGSIZ
operator|)
operator|*
name|PAGSIZ
argument_list|,
name|PAGSIZ
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"mprotect in __enable_execute_stack"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __pyr__ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sony_news
argument_list|)
operator|&&
name|defined
argument_list|(
name|SYSTYPE_BSD
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<syscall.h>
end_include

begin_include
include|#
directive|include
file|<machine/sysnews.h>
end_include

begin_comment
comment|/* cacheflush function for NEWS-OS 4.2.    This function is called from trampoline-initialize code    defined in config/mips/mips.h.  */
end_comment

begin_function
name|void
name|cacheflush
parameter_list|(
name|char
modifier|*
name|beg
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
if|if
condition|(
name|syscall
argument_list|(
name|SYS_sysnews
argument_list|,
name|NEWS_CACHEFLUSH
argument_list|,
name|beg
argument_list|,
name|size
argument_list|,
name|FLUSH_BCACHE
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"cache_flush"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sony_news */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_trampoline */
end_comment

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|__CYGWIN__
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|L__main
end_ifdef

begin_include
include|#
directive|include
file|"gbl-ctors.h"
end_include

begin_comment
comment|/* Some systems use __main in a way incompatible with its use in gcc, in these    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to    give the same symbol without quotes for an alternative entry point.  You    must define both, or neither.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NAME__MAIN
end_ifndef

begin_define
define|#
directive|define
name|NAME__MAIN
value|"__main"
end_define

begin_define
define|#
directive|define
name|SYMBOL__MAIN
value|__main
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INIT_SECTION_ASM_OP
end_ifdef

begin_undef
undef|#
directive|undef
name|HAS_INIT_SECTION
end_undef

begin_define
define|#
directive|define
name|HAS_INIT_SECTION
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_INIT_SECTION
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|OBJECT_FORMAT_ELF
argument_list|)
end_if

begin_comment
comment|/* Run all the global destructors on exit from the program.  */
end_comment

begin_function
name|void
name|__do_global_dtors
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DO_GLOBAL_DTORS_BODY
name|DO_GLOBAL_DTORS_BODY
expr_stmt|;
else|#
directive|else
specifier|static
name|func_ptr
modifier|*
name|p
init|=
name|__DTOR_LIST__
operator|+
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p
operator|++
expr_stmt|;
operator|(
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|)
operator|(
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_INIT_SECTION
end_ifndef

begin_comment
comment|/* Run all the global constructors on entry to the program.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ON_EXIT
end_ifndef

begin_define
define|#
directive|define
name|ON_EXIT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Make sure the exit routine is pulled in to define the globals as    bss symbols, just in case the linker does not automatically pull    bss definitions from the library.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|_exit_dummy_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|_exit_dummy_ref
init|=
operator|&
name|_exit_dummy_decl
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ON_EXIT */
end_comment

begin_function
name|void
name|__do_global_ctors
parameter_list|()
block|{
name|DO_GLOBAL_CTORS_BODY
expr_stmt|;
name|ON_EXIT
argument_list|(
name|__do_global_dtors
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no HAS_INIT_SECTION */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_INIT_SECTION
argument_list|)
operator|||
name|defined
argument_list|(
name|INVOKE__main
argument_list|)
end_if

begin_comment
comment|/* Subroutine called automatically by `main'.    Compiling a global function named `main'    produces an automatic call to this function at the beginning.     For many systems, this routine calls __do_global_ctors.    For systems which support a .init section we use the .init section    to run __do_global_ctors, so we need not do anything here.  */
end_comment

begin_function
name|void
name|SYMBOL__MAIN
parameter_list|()
block|{
comment|/* Support recursive calls to `main': run initializers just once.  */
specifier|static
name|int
name|initialized
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|initialized
operator|=
literal|1
expr_stmt|;
name|__do_global_ctors
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no HAS_INIT_SECTION or INVOKE__main */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L__main */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __CYGWIN__ */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_ctors
end_ifdef

begin_include
include|#
directive|include
file|"gbl-ctors.h"
end_include

begin_comment
comment|/* Provide default definitions for the lists of constructors and    destructors, so that we don't get linker errors.  These symbols are    intentionally bss symbols, so that gld and/or collect will provide    the right values.  */
end_comment

begin_comment
comment|/* We declare the lists here with two elements each,    so that they are valid empty lists if no other definition is loaded.     If we are using the old "set" extensions to have the gnu linker    collect ctors and dtors, then we __CTOR_LIST__ and __DTOR_LIST__    must be in the bss/common section.     Long term no port should use those extensions.  But many still do.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INIT_SECTION_ASM_OP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CTOR_LISTS_DEFINED_EXTERNALLY
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ASM_OUTPUT_CONSTRUCTOR
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_COLLECT2
argument_list|)
end_if

begin_decl_stmt
name|func_ptr
name|__CTOR_LIST__
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|func_ptr
name|__DTOR_LIST__
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|func_ptr
name|__CTOR_LIST__
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|func_ptr
name|__DTOR_LIST__
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no INIT_SECTION_ASM_OP and not CTOR_LISTS_DEFINED_EXTERNALLY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_ctors */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_exit
end_ifdef

begin_include
include|#
directive|include
file|"gbl-ctors.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_ATEXIT
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|ON_EXIT
end_ifdef

begin_undef
undef|#
directive|undef
name|ON_EXIT
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|_exit_dummy_decl
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prevent compiler& linker warnings */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ON_EXIT
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_ATEXIT
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|static
name|func_ptr
modifier|*
name|atexit_chain
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|atexit_chain_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|long
name|last_atexit_chain_slot
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|atexit
parameter_list|(
name|func_ptr
name|func
parameter_list|)
block|{
if|if
condition|(
operator|++
name|last_atexit_chain_slot
operator|==
name|atexit_chain_length
condition|)
block|{
name|atexit_chain_length
operator|+=
literal|32
expr_stmt|;
if|if
condition|(
name|atexit_chain
condition|)
name|atexit_chain
operator|=
operator|(
name|func_ptr
operator|*
operator|)
name|realloc
argument_list|(
name|atexit_chain
argument_list|,
name|atexit_chain_length
operator|*
sizeof|sizeof
argument_list|(
name|func_ptr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|atexit_chain
operator|=
operator|(
name|func_ptr
operator|*
operator|)
name|malloc
argument_list|(
name|atexit_chain_length
operator|*
sizeof|sizeof
argument_list|(
name|func_ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|atexit_chain
condition|)
block|{
name|atexit_chain_length
operator|=
literal|0
expr_stmt|;
name|last_atexit_chain_slot
operator|=
operator|-
literal|1
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|atexit_chain
index|[
name|last_atexit_chain_slot
index|]
operator|=
name|func
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEED_ATEXIT */
end_comment

begin_comment
comment|/* If we have no known way of registering our own __do_global_dtors    routine so that it will be invoked at program exit time, then we    have to define our own exit routine which will get this to happen.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|__do_global_dtors
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|__bb_exit_func
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_cleanup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_exit
parameter_list|()
function_decl|__attribute__
parameter_list|(
function_decl|(noreturn
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function
name|void
name|exit
parameter_list|(
name|int
name|status
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INIT_SECTION_ASM_OP
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|OBJECT_FORMAT_ELF
argument_list|)
ifdef|#
directive|ifdef
name|NEED_ATEXIT
if|if
condition|(
name|atexit_chain
condition|)
block|{
for|for
control|(
init|;
name|last_atexit_chain_slot
operator|--
operator|>=
literal|0
condition|;
control|)
block|{
call|(
modifier|*
name|atexit_chain
index|[
name|last_atexit_chain_slot
operator|+
literal|1
index|]
call|)
argument_list|()
expr_stmt|;
name|atexit_chain
index|[
name|last_atexit_chain_slot
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|atexit_chain
argument_list|)
expr_stmt|;
name|atexit_chain
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
comment|/* No NEED_ATEXIT */
name|__do_global_dtors
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* No NEED_ATEXIT */
endif|#
directive|endif
comment|/* !defined (INIT_SECTION_ASM_OP) || !defined (OBJECT_FORMAT_ELF) */
comment|/* In gbl-ctors.h, ON_EXIT is defined if HAVE_ATEXIT is defined.  In    __bb_init_func and _bb_init_prg, __bb_exit_func is registered with    ON_EXIT if ON_EXIT is defined.  Thus we must not call __bb_exit_func here    if HAVE_ATEXIT is defined. */
ifndef|#
directive|ifndef
name|HAVE_ATEXIT
ifndef|#
directive|ifndef
name|inhibit_libc
name|__bb_exit_func
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* !HAVE_ATEXIT */
ifdef|#
directive|ifdef
name|EXIT_BODY
name|EXIT_BODY
expr_stmt|;
else|#
directive|else
name|_cleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|_exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ON_EXIT defined */
end_comment

begin_decl_stmt
name|int
name|_exit_dummy_decl
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prevent compiler& linker warnings */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_ATEXIT
end_ifndef

begin_comment
comment|/* Provide a fake for atexit() using ON_EXIT.  */
end_comment

begin_function
name|int
name|atexit
parameter_list|(
name|func_ptr
name|func
parameter_list|)
block|{
return|return
name|ON_EXIT
argument_list|(
name|func
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_ATEXIT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ON_EXIT defined */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_exit */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_eh
end_ifdef

begin_include
include|#
directive|include
file|"gthr.h"
end_include

begin_comment
comment|/* Shared exception handling support routines.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|__default_terminate
parameter_list|(
name|void
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__noreturn__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function
name|void
name|__default_terminate
parameter_list|()
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
function_decl|(
modifier|*
name|__terminate_func
function_decl|)
parameter_list|()
init|=
name|__default_terminate
function_decl|;
end_function_decl

begin_function
name|void
name|__terminate
parameter_list|()
block|{
call|(
modifier|*
name|__terminate_func
call|)
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|__throw_type_match
parameter_list|(
name|void
modifier|*
name|catch_type
parameter_list|,
name|void
modifier|*
name|throw_type
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
if|#
directive|if
literal|0
block|printf ("__throw_type_match (): catch_type = %s, throw_type = %s\n", 	 catch_type, throw_type);
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|catch_type
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|throw_type
argument_list|)
operator|==
literal|0
condition|)
return|return
name|obj
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|__empty
parameter_list|()
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* Include definitions of EH context and table layout */
end_comment

begin_include
include|#
directive|include
file|"eh-common.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|inhibit_libc
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Allocate and return a new EH context structure. */
end_comment

begin_function_decl
specifier|extern
name|void
name|__throw
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
modifier|*
name|new_eh_context
parameter_list|()
block|{
struct|struct
name|eh_full_context
block|{
name|struct
name|eh_context
name|c
decl_stmt|;
name|void
modifier|*
name|top_elt
index|[
literal|2
index|]
decl_stmt|;
block|}
modifier|*
name|ehfc
init|=
operator|(
expr|struct
name|eh_full_context
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ehfc
argument_list|)
struct|;
if|if
condition|(
operator|!
name|ehfc
condition|)
name|__terminate
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|ehfc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|ehfc
argument_list|)
expr_stmt|;
name|ehfc
operator|->
name|c
operator|.
name|dynamic_handler_chain
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|ehfc
operator|->
name|top_elt
expr_stmt|;
comment|/* This should optimize out entirely.  This should always be true,      but just in case it ever isn't, don't allow bogus code to be      generated.  */
if|if
condition|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|ehfc
operator|->
name|c
operator|)
operator|!=
operator|(
name|void
operator|*
operator|)
name|ehfc
condition|)
name|__terminate
argument_list|()
expr_stmt|;
return|return
operator|&
name|ehfc
operator|->
name|c
return|;
block|}
end_function

begin_if
if|#
directive|if
name|__GTHREADS
end_if

begin_decl_stmt
specifier|static
name|__gthread_key_t
name|eh_context_key
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Destructor for struct eh_context. */
end_comment

begin_function
specifier|static
name|void
name|eh_context_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|__gthread_key_dtor
argument_list|(
name|eh_context_key
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Pointer to function to return EH context. */
end_comment

begin_function_decl
specifier|static
name|struct
name|eh_context
modifier|*
name|eh_context_initialize
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|eh_context
modifier|*
name|eh_context_static
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|__GTHREADS
end_if

begin_function_decl
specifier|static
name|struct
name|eh_context
modifier|*
name|eh_context_specific
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|eh_context
modifier|*
function_decl|(
modifier|*
name|get_eh_context
function_decl|)
parameter_list|()
init|=
operator|&
name|eh_context_initialize
function_decl|;
end_function_decl

begin_comment
comment|/* Routine to get EH context.    This one will simply call the function pointer. */
end_comment

begin_function
name|void
modifier|*
name|__get_eh_context
parameter_list|()
block|{
return|return
operator|(
name|void
operator|*
operator|)
call|(
modifier|*
name|get_eh_context
call|)
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Get and set the language specific info pointer. */
end_comment

begin_function
name|void
modifier|*
modifier|*
name|__get_eh_info
parameter_list|()
block|{
name|struct
name|eh_context
modifier|*
name|eh
init|=
call|(
modifier|*
name|get_eh_context
call|)
argument_list|()
decl_stmt|;
return|return
operator|&
name|eh
operator|->
name|info
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|__GTHREADS
end_if

begin_function
specifier|static
name|void
name|eh_threads_initialize
parameter_list|()
block|{
comment|/* Try to create the key.  If it fails, revert to static method,      otherwise start using thread specific EH contexts. */
if|if
condition|(
name|__gthread_key_create
argument_list|(
operator|&
name|eh_context_key
argument_list|,
operator|&
name|eh_context_free
argument_list|)
operator|==
literal|0
condition|)
name|get_eh_context
operator|=
operator|&
name|eh_context_specific
expr_stmt|;
else|else
name|get_eh_context
operator|=
operator|&
name|eh_context_static
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no __GTHREADS */
end_comment

begin_comment
comment|/* Initialize EH context.    This will be called only once, since we change GET_EH_CONTEXT    pointer to another routine. */
end_comment

begin_function
specifier|static
name|struct
name|eh_context
modifier|*
name|eh_context_initialize
parameter_list|()
block|{
if|#
directive|if
name|__GTHREADS
specifier|static
name|__gthread_once_t
name|once
init|=
name|__GTHREAD_ONCE_INIT
decl_stmt|;
comment|/* Make sure that get_eh_context does not point to us anymore.      Some systems have dummy thread routines in their libc that      return a success (Solaris 2.6 for example). */
if|if
condition|(
name|__gthread_once
argument_list|(
operator|&
name|once
argument_list|,
name|eh_threads_initialize
argument_list|)
operator|!=
literal|0
operator|||
name|get_eh_context
operator|==
operator|&
name|eh_context_initialize
condition|)
block|{
comment|/* Use static version of EH context. */
name|get_eh_context
operator|=
operator|&
name|eh_context_static
expr_stmt|;
block|}
else|#
directive|else
comment|/* no __GTHREADS */
comment|/* Use static version of EH context. */
name|get_eh_context
operator|=
operator|&
name|eh_context_static
expr_stmt|;
endif|#
directive|endif
comment|/* no __GTHREADS */
return|return
call|(
modifier|*
name|get_eh_context
call|)
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Return a static EH context. */
end_comment

begin_function
specifier|static
name|struct
name|eh_context
modifier|*
name|eh_context_static
parameter_list|()
block|{
specifier|static
name|struct
name|eh_context
name|eh
decl_stmt|;
specifier|static
name|int
name|initialized
decl_stmt|;
specifier|static
name|void
modifier|*
name|top_elt
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|initialized
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|eh
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|eh
argument_list|)
expr_stmt|;
name|eh
operator|.
name|dynamic_handler_chain
operator|=
name|top_elt
expr_stmt|;
block|}
return|return
operator|&
name|eh
return|;
block|}
end_function

begin_if
if|#
directive|if
name|__GTHREADS
end_if

begin_comment
comment|/* Return a thread specific EH context. */
end_comment

begin_function
specifier|static
name|struct
name|eh_context
modifier|*
name|eh_context_specific
parameter_list|()
block|{
name|struct
name|eh_context
modifier|*
name|eh
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|eh_context
operator|*
operator|)
name|__gthread_getspecific
argument_list|(
name|eh_context_key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eh
condition|)
block|{
name|eh
operator|=
name|new_eh_context
argument_list|()
expr_stmt|;
if|if
condition|(
name|__gthread_setspecific
argument_list|(
name|eh_context_key
argument_list|,
operator|(
name|void
operator|*
operator|)
name|eh
argument_list|)
operator|!=
literal|0
condition|)
name|__terminate
argument_list|()
expr_stmt|;
block|}
return|return
name|eh
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|__GTHREADS
end_endif

begin_escape
end_escape

begin_comment
comment|/* Support routines for setjmp/longjmp exception handling.  */
end_comment

begin_comment
comment|/* Calls to __sjthrow are generated by the compiler when an exception    is raised when using the setjmp/longjmp exception handling codegen    method.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DONT_USE_BUILTIN_SETJMP
end_ifdef

begin_function_decl
specifier|extern
name|void
name|longjmp
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Routine to get the head of the current thread's dynamic handler chain    use for exception handling. */
end_comment

begin_function
name|void
modifier|*
modifier|*
modifier|*
name|__get_dynamic_handler_chain
parameter_list|()
block|{
name|struct
name|eh_context
modifier|*
name|eh
init|=
call|(
modifier|*
name|get_eh_context
call|)
argument_list|()
decl_stmt|;
return|return
operator|&
name|eh
operator|->
name|dynamic_handler_chain
return|;
block|}
end_function

begin_comment
comment|/* This is used to throw an exception when the setjmp/longjmp codegen    method is used for exception handling.     We call __terminate if there are no handlers left.  Otherwise we run the    cleanup actions off the dynamic cleanup stack, and pop the top of the    dynamic handler chain, and use longjmp to transfer back to the associated    handler.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|__sjthrow
parameter_list|(
name|void
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__noreturn__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function
name|void
name|__sjthrow
parameter_list|()
block|{
name|struct
name|eh_context
modifier|*
name|eh
init|=
call|(
modifier|*
name|get_eh_context
call|)
argument_list|()
decl_stmt|;
name|void
modifier|*
modifier|*
modifier|*
name|dhc
init|=
operator|&
name|eh
operator|->
name|dynamic_handler_chain
decl_stmt|;
name|void
modifier|*
name|jmpbuf
decl_stmt|;
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|void
modifier|*
name|arg
decl_stmt|;
name|void
modifier|*
modifier|*
modifier|*
name|cleanup
decl_stmt|;
comment|/* The cleanup chain is one word into the buffer.  Get the cleanup      chain.  */
name|cleanup
operator|=
operator|(
name|void
operator|*
operator|*
operator|*
operator|)
operator|&
operator|(
operator|*
name|dhc
operator|)
index|[
literal|1
index|]
expr_stmt|;
comment|/* If there are any cleanups in the chain, run them now.  */
if|if
condition|(
name|cleanup
index|[
literal|0
index|]
condition|)
block|{
name|double
name|store
index|[
literal|200
index|]
decl_stmt|;
name|void
modifier|*
modifier|*
name|buf
init|=
operator|(
name|void
operator|*
operator|*
operator|)
name|store
decl_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|(
operator|*
name|dhc
operator|)
expr_stmt|;
comment|/* try { */
ifdef|#
directive|ifdef
name|DONT_USE_BUILTIN_SETJMP
if|if
condition|(
operator|!
name|setjmp
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|__builtin_setjmp
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|)
condition|)
endif|#
directive|endif
block|{
operator|*
name|dhc
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|cleanup
index|[
literal|0
index|]
condition|)
block|{
name|func
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|int
argument_list|)
operator|)
name|cleanup
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|arg
operator|=
operator|(
name|void
operator|*
operator|)
name|cleanup
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
comment|/* Update this before running the cleanup.  */
name|cleanup
index|[
literal|0
index|]
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|cleanup
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
operator|*
name|dhc
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* catch (...) */
else|else
block|{
name|__terminate
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* We must call terminate if we try and rethrow an exception, when      there is no exception currently active and when there are no      handlers left.  */
if|if
condition|(
operator|!
name|eh
operator|->
name|info
operator|||
operator|(
operator|*
name|dhc
operator|)
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|__terminate
argument_list|()
expr_stmt|;
comment|/* Find the jmpbuf associated with the top element of the dynamic      handler chain.  The jumpbuf starts two words into the buffer.  */
name|jmpbuf
operator|=
operator|&
operator|(
operator|*
name|dhc
operator|)
index|[
literal|2
index|]
expr_stmt|;
comment|/* Then we pop the top element off the dynamic handler chain.  */
operator|*
name|dhc
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
operator|*
name|dhc
operator|)
index|[
literal|0
index|]
expr_stmt|;
comment|/* And then we jump to the handler.  */
ifdef|#
directive|ifdef
name|DONT_USE_BUILTIN_SETJMP
name|longjmp
argument_list|(
name|jmpbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|__builtin_longjmp
argument_list|(
name|jmpbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Run cleanups on the dynamic cleanup stack for the current dynamic    handler, then pop the handler off the dynamic handler stack, and    then throw.  This is used to skip the first handler, and transfer    control to the next handler in the dynamic handler stack.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|__sjpopnthrow
parameter_list|(
name|void
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__noreturn__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function
name|void
name|__sjpopnthrow
parameter_list|()
block|{
name|struct
name|eh_context
modifier|*
name|eh
init|=
call|(
modifier|*
name|get_eh_context
call|)
argument_list|()
decl_stmt|;
name|void
modifier|*
modifier|*
modifier|*
name|dhc
init|=
operator|&
name|eh
operator|->
name|dynamic_handler_chain
decl_stmt|;
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|void
modifier|*
name|arg
decl_stmt|;
name|void
modifier|*
modifier|*
modifier|*
name|cleanup
decl_stmt|;
comment|/* The cleanup chain is one word into the buffer.  Get the cleanup      chain.  */
name|cleanup
operator|=
operator|(
name|void
operator|*
operator|*
operator|*
operator|)
operator|&
operator|(
operator|*
name|dhc
operator|)
index|[
literal|1
index|]
expr_stmt|;
comment|/* If there are any cleanups in the chain, run them now.  */
if|if
condition|(
name|cleanup
index|[
literal|0
index|]
condition|)
block|{
name|double
name|store
index|[
literal|200
index|]
decl_stmt|;
name|void
modifier|*
modifier|*
name|buf
init|=
operator|(
name|void
operator|*
operator|*
operator|)
name|store
decl_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|(
operator|*
name|dhc
operator|)
expr_stmt|;
comment|/* try { */
ifdef|#
directive|ifdef
name|DONT_USE_BUILTIN_SETJMP
if|if
condition|(
operator|!
name|setjmp
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|__builtin_setjmp
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|)
condition|)
endif|#
directive|endif
block|{
operator|*
name|dhc
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|cleanup
index|[
literal|0
index|]
condition|)
block|{
name|func
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|int
argument_list|)
operator|)
name|cleanup
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|arg
operator|=
operator|(
name|void
operator|*
operator|)
name|cleanup
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
comment|/* Update this before running the cleanup.  */
name|cleanup
index|[
literal|0
index|]
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|cleanup
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
operator|*
name|dhc
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* catch (...) */
else|else
block|{
name|__terminate
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Then we pop the top element off the dynamic handler chain.  */
operator|*
name|dhc
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
operator|*
name|dhc
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|__sjthrow
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Support code for all exception region-based exception handling.  */
end_comment

begin_function
name|int
name|__eh_rtime_match
parameter_list|(
name|void
modifier|*
name|rtime
parameter_list|)
block|{
name|void
modifier|*
name|info
decl_stmt|;
name|__eh_matcher
name|matcher
decl_stmt|;
name|void
modifier|*
name|ret
decl_stmt|;
name|info
operator|=
operator|*
operator|(
name|__get_eh_info
argument_list|()
operator|)
expr_stmt|;
name|matcher
operator|=
operator|(
operator|(
name|__eh_info
operator|*
operator|)
name|info
operator|)
operator|->
name|match_function
expr_stmt|;
if|if
condition|(
operator|!
name|matcher
condition|)
block|{
ifndef|#
directive|ifndef
name|inhibit_libc
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Internal Compiler Bug: No runtime type matcher."
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|ret
operator|=
call|(
modifier|*
name|matcher
call|)
argument_list|(
name|info
argument_list|,
name|rtime
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This value identifies the place from which an exception is being    thrown.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EH_TABLE_LOOKUP
end_ifdef

begin_function
name|EH_TABLE_LOOKUP
else|#
directive|else
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
comment|/* Return the table version of an exception descriptor */
name|short
name|__get_eh_table_version
parameter_list|(
name|exception_descriptor
modifier|*
name|table
parameter_list|)
block|{
return|return
name|table
operator|->
name|lang
operator|.
name|version
return|;
block|}
end_function

begin_comment
comment|/* Return the originating table language of an exception descriptor */
end_comment

begin_function
name|short
name|__get_eh_table_language
parameter_list|(
name|exception_descriptor
modifier|*
name|table
parameter_list|)
block|{
return|return
name|table
operator|->
name|lang
operator|.
name|language
return|;
block|}
end_function

begin_comment
comment|/* This routine takes a PC and a pointer to the exception region TABLE for    its translation unit, and returns the address of the exception handler    associated with the closest exception table handler entry associated    with that PC, or 0 if there are no table entries the PC fits in.     In the advent of a tie, we have to give the last entry, as it represents    an inner block.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|old_find_exception_handler
parameter_list|(
name|void
modifier|*
name|pc
parameter_list|,
name|old_exception_table
modifier|*
name|table
parameter_list|)
block|{
if|if
condition|(
name|table
condition|)
block|{
name|int
name|pos
decl_stmt|;
name|int
name|best
init|=
operator|-
literal|1
decl_stmt|;
comment|/* We can't do a binary search because the table isn't guaranteed          to be sorted from function to function.  */
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|table
index|[
name|pos
index|]
operator|.
name|start_region
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|;
operator|++
name|pos
control|)
block|{
if|if
condition|(
name|table
index|[
name|pos
index|]
operator|.
name|start_region
operator|<=
name|pc
operator|&&
name|table
index|[
name|pos
index|]
operator|.
name|end_region
operator|>
name|pc
condition|)
block|{
comment|/* This can apply.  Make sure it is at least as small as                  the previous best.  */
if|if
condition|(
name|best
operator|==
operator|-
literal|1
operator|||
operator|(
name|table
index|[
name|pos
index|]
operator|.
name|end_region
operator|<=
name|table
index|[
name|best
index|]
operator|.
name|end_region
operator|&&
name|table
index|[
name|pos
index|]
operator|.
name|start_region
operator|>=
name|table
index|[
name|best
index|]
operator|.
name|start_region
operator|)
condition|)
name|best
operator|=
name|pos
expr_stmt|;
block|}
comment|/* But it is sorted by starting PC within a function.  */
elseif|else
if|if
condition|(
name|best
operator|>=
literal|0
operator|&&
name|table
index|[
name|pos
index|]
operator|.
name|start_region
operator|>
name|pc
condition|)
break|break;
block|}
if|if
condition|(
name|best
operator|!=
operator|-
literal|1
condition|)
return|return
name|table
index|[
name|best
index|]
operator|.
name|exception_handler
return|;
block|}
return|return
operator|(
name|void
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* find_exception_handler finds the correct handler, if there is one, to    handle an exception.    returns a pointer to the handler which controlled should be transferred    to, or NULL if there is nothing left.    Parameters:    PC - pc where the exception originates. If this is a rethrow,          then this starts out as a pointer to the exception table 	entry we wish to rethrow out of.    TABLE - exception table for the current module.    EH_INFO - eh info pointer for this exception.    RETHROW - 1 if this is a rethrow. (see incoming value of PC).    CLEANUP - returned flag indicating whether this is a cleanup handler. */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|find_exception_handler
parameter_list|(
name|void
modifier|*
name|pc
parameter_list|,
name|exception_descriptor
modifier|*
name|table
parameter_list|,
name|__eh_info
modifier|*
name|eh_info
parameter_list|,
name|int
name|rethrow
parameter_list|,
name|int
modifier|*
name|cleanup
parameter_list|)
block|{
name|void
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
operator|*
name|cleanup
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|table
condition|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
comment|/* The new model assumed the table is sorted inner-most out so the          first region we find which matches is the correct one */
name|exception_table
modifier|*
name|tab
init|=
operator|&
operator|(
name|table
operator|->
name|table
index|[
literal|0
index|]
operator|)
decl_stmt|;
comment|/* Subtract 1 from the PC to avoid hitting the next region */
if|if
condition|(
name|rethrow
condition|)
block|{
comment|/* pc is actually the region table entry to rethrow out of */
name|pos
operator|=
operator|(
operator|(
name|exception_table
operator|*
operator|)
name|pc
operator|)
operator|-
name|tab
expr_stmt|;
name|pc
operator|=
operator|(
operator|(
name|exception_table
operator|*
operator|)
name|pc
operator|)
operator|->
name|end_region
operator|-
literal|1
expr_stmt|;
comment|/* The label is always on the LAST handler entry for a region,               so we know the next entry is a different region, even if the              addresses are the same. Make sure its not end of table tho. */
if|if
condition|(
name|tab
index|[
name|pos
index|]
operator|.
name|start_region
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
name|pos
operator|++
expr_stmt|;
block|}
else|else
name|pc
operator|--
expr_stmt|;
comment|/* We can't do a binary search because the table is in inner-most          to outermost address ranges within functions */
for|for
control|(
init|;
name|tab
index|[
name|pos
index|]
operator|.
name|start_region
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|;
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|tab
index|[
name|pos
index|]
operator|.
name|start_region
operator|<=
name|pc
operator|&&
name|tab
index|[
name|pos
index|]
operator|.
name|end_region
operator|>
name|pc
condition|)
block|{
if|if
condition|(
name|tab
index|[
name|pos
index|]
operator|.
name|match_info
condition|)
block|{
name|__eh_matcher
name|matcher
init|=
name|eh_info
operator|->
name|match_function
decl_stmt|;
comment|/* match info but no matcher is NOT a match */
if|if
condition|(
name|matcher
condition|)
block|{
name|void
modifier|*
name|ret
init|=
call|(
modifier|*
name|matcher
call|)
argument_list|(
operator|(
name|void
operator|*
operator|)
name|eh_info
argument_list|,
name|tab
index|[
name|pos
index|]
operator|.
name|match_info
argument_list|,
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|retval
operator|==
name|NULL
condition|)
name|retval
operator|=
name|tab
index|[
name|pos
index|]
operator|.
name|exception_handler
expr_stmt|;
operator|*
name|cleanup
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|retval
operator|==
name|NULL
condition|)
name|retval
operator|=
name|tab
index|[
name|pos
index|]
operator|.
name|exception_handler
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|retval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DWARF2_UNWIND_INFO */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EH_TABLE_LOOKUP */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
end_ifdef

begin_comment
comment|/* Support code for exception handling using static unwind information.  */
end_comment

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* This type is used in get_reg and put_reg to deal with ABIs where a void*    is smaller than a word, such as the Irix 6 n32 ABI.  We cast twice to    avoid a warning about casting between int and pointer of different    sizes.  */
end_comment

begin_typedef
typedef|typedef
name|int
name|ptr_type
name|__attribute__
typedef|((
name|mode
typedef|(
name|pointer
typedef|)));
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|INCOMING_REGNO
end_ifdef

begin_comment
comment|/* Is the saved value for register REG in frame UDATA stored in a register    window in the previous frame?  */
end_comment

begin_comment
comment|/* ??? The Sparc INCOMING_REGNO references TARGET_FLAT.  This allows us    to use the macro here.  One wonders, though, that perhaps TARGET_FLAT    compiled functions won't work with the frame-unwind stuff here.      Perhaps the entireity of in_reg_window should be conditional on having    seen a DW_CFA_GNU_window_save?  */
end_comment

begin_define
define|#
directive|define
name|target_flags
value|0
end_define

begin_function
specifier|static
name|int
name|in_reg_window
parameter_list|(
name|int
name|reg
parameter_list|,
name|frame_state
modifier|*
name|udata
parameter_list|)
block|{
if|if
condition|(
name|udata
operator|->
name|saved
index|[
name|reg
index|]
operator|==
name|REG_SAVED_REG
condition|)
return|return
name|INCOMING_REGNO
argument_list|(
name|reg
argument_list|)
operator|==
name|reg
return|;
if|if
condition|(
name|udata
operator|->
name|saved
index|[
name|reg
index|]
operator|!=
name|REG_SAVED_OFFSET
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
return|return
name|udata
operator|->
name|reg_or_offset
index|[
name|reg
index|]
operator|>
literal|0
return|;
else|#
directive|else
return|return
name|udata
operator|->
name|reg_or_offset
index|[
name|reg
index|]
operator|<
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
specifier|inline
name|int
name|in_reg_window
parameter_list|(
name|int
name|reg
parameter_list|,
name|frame_state
modifier|*
name|udata
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INCOMING_REGNO */
end_comment

begin_comment
comment|/* Get the address of register REG as saved in UDATA, where SUB_UDATA is a    frame called by UDATA or 0.  */
end_comment

begin_function
specifier|static
name|word_type
modifier|*
name|get_reg_addr
parameter_list|(
name|unsigned
name|reg
parameter_list|,
name|frame_state
modifier|*
name|udata
parameter_list|,
name|frame_state
modifier|*
name|sub_udata
parameter_list|)
block|{
while|while
condition|(
name|udata
operator|->
name|saved
index|[
name|reg
index|]
operator|==
name|REG_SAVED_REG
condition|)
block|{
name|reg
operator|=
name|udata
operator|->
name|reg_or_offset
index|[
name|reg
index|]
expr_stmt|;
if|if
condition|(
name|in_reg_window
argument_list|(
name|reg
argument_list|,
name|udata
argument_list|)
condition|)
block|{
name|udata
operator|=
name|sub_udata
expr_stmt|;
name|sub_udata
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|udata
operator|->
name|saved
index|[
name|reg
index|]
operator|==
name|REG_SAVED_OFFSET
condition|)
return|return
operator|(
name|word_type
operator|*
operator|)
operator|(
name|udata
operator|->
name|cfa
operator|+
name|udata
operator|->
name|reg_or_offset
index|[
name|reg
index|]
operator|)
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the value of register REG as saved in UDATA, where SUB_UDATA is a    frame called by UDATA or 0.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|get_reg
parameter_list|(
name|unsigned
name|reg
parameter_list|,
name|frame_state
modifier|*
name|udata
parameter_list|,
name|frame_state
modifier|*
name|sub_udata
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
operator|(
name|ptr_type
operator|)
operator|*
name|get_reg_addr
argument_list|(
name|reg
argument_list|,
name|udata
argument_list|,
name|sub_udata
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Overwrite the saved value for register REG in frame UDATA with VAL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|put_reg
parameter_list|(
name|unsigned
name|reg
parameter_list|,
name|void
modifier|*
name|val
parameter_list|,
name|frame_state
modifier|*
name|udata
parameter_list|)
block|{
operator|*
name|get_reg_addr
argument_list|(
name|reg
argument_list|,
name|udata
argument_list|,
name|NULL
argument_list|)
operator|=
operator|(
name|word_type
operator|)
operator|(
name|ptr_type
operator|)
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the saved value for register REG from frame UDATA to frame    TARGET_UDATA.  Unlike the previous two functions, this can handle    registers that are not one word large.  */
end_comment

begin_function
specifier|static
name|void
name|copy_reg
parameter_list|(
name|unsigned
name|reg
parameter_list|,
name|frame_state
modifier|*
name|udata
parameter_list|,
name|frame_state
modifier|*
name|target_udata
parameter_list|)
block|{
name|word_type
modifier|*
name|preg
init|=
name|get_reg_addr
argument_list|(
name|reg
argument_list|,
name|udata
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|word_type
modifier|*
name|ptreg
init|=
name|get_reg_addr
argument_list|(
name|reg
argument_list|,
name|target_udata
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|ptreg
argument_list|,
name|preg
argument_list|,
name|__builtin_dwarf_reg_size
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Retrieve the return address for frame UDATA.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|get_return_addr
parameter_list|(
name|frame_state
modifier|*
name|udata
parameter_list|,
name|frame_state
modifier|*
name|sub_udata
parameter_list|)
block|{
return|return
name|__builtin_extract_return_addr
argument_list|(
name|get_reg
argument_list|(
name|udata
operator|->
name|retaddr_column
argument_list|,
name|udata
argument_list|,
name|sub_udata
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Overwrite the return address for frame UDATA with VAL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|put_return_addr
parameter_list|(
name|void
modifier|*
name|val
parameter_list|,
name|frame_state
modifier|*
name|udata
parameter_list|)
block|{
name|val
operator|=
name|__builtin_frob_return_addr
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|put_reg
argument_list|(
name|udata
operator|->
name|retaddr_column
argument_list|,
name|val
argument_list|,
name|udata
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given the current frame UDATA and its return address PC, return the    information about the calling frame in CALLER_UDATA.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|next_stack_level
parameter_list|(
name|void
modifier|*
name|pc
parameter_list|,
name|frame_state
modifier|*
name|udata
parameter_list|,
name|frame_state
modifier|*
name|caller_udata
parameter_list|)
block|{
name|caller_udata
operator|=
name|__frame_state_for
argument_list|(
name|pc
argument_list|,
name|caller_udata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|caller_udata
condition|)
return|return
literal|0
return|;
comment|/* Now go back to our caller's stack frame.  If our caller's CFA register      was saved in our stack frame, restore it; otherwise, assume the CFA      register is SP and restore it to our CFA value.  */
if|if
condition|(
name|udata
operator|->
name|saved
index|[
name|caller_udata
operator|->
name|cfa_reg
index|]
condition|)
name|caller_udata
operator|->
name|cfa
operator|=
name|get_reg
argument_list|(
name|caller_udata
operator|->
name|cfa_reg
argument_list|,
name|udata
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|caller_udata
operator|->
name|cfa
operator|=
name|udata
operator|->
name|cfa
expr_stmt|;
name|caller_udata
operator|->
name|cfa
operator|+=
name|caller_udata
operator|->
name|cfa_offset
expr_stmt|;
return|return
name|caller_udata
return|;
block|}
end_function

begin_comment
comment|/* Hook to call before __terminate if only cleanup handlers remain. */
end_comment

begin_function
name|void
name|__unwinding_cleanup
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* throw_helper performs some of the common grunt work for a throw. This    routine is called by throw and rethrows. This is pretty much split     out from the old __throw routine. An addition has been added which allows    for a dummy call to a routine __unwinding_cleanup() when there are nothing    but cleanups remaining. This allows a debugger to examine the state    at which the throw was executed, before any cleanups, rather than    at the terminate point after the stack has been unwound.     EH is the current eh_context structure.    PC is the address of the call to __throw.    MY_UDATA is the unwind information for __throw.    OFFSET_P is where we return the SP adjustment offset.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|throw_helper
parameter_list|(
name|eh
parameter_list|,
name|pc
parameter_list|,
name|my_udata
parameter_list|,
name|offset_p
parameter_list|)
name|struct
name|eh_context
modifier|*
name|eh
decl_stmt|;
name|void
modifier|*
name|pc
decl_stmt|;
name|frame_state
modifier|*
name|my_udata
decl_stmt|;
name|long
modifier|*
name|offset_p
decl_stmt|;
block|{
name|frame_state
name|ustruct2
decl_stmt|,
modifier|*
name|udata
init|=
operator|&
name|ustruct2
decl_stmt|;
name|frame_state
name|ustruct
decl_stmt|;
name|frame_state
modifier|*
name|sub_udata
init|=
operator|&
name|ustruct
decl_stmt|;
name|void
modifier|*
name|saved_pc
init|=
name|pc
decl_stmt|;
name|void
modifier|*
name|handler
decl_stmt|;
name|void
modifier|*
name|handler_p
decl_stmt|;
name|void
modifier|*
name|pc_p
decl_stmt|;
name|frame_state
name|saved_ustruct
decl_stmt|;
name|int
name|new_eh_model
decl_stmt|;
name|int
name|cleanup
init|=
literal|0
decl_stmt|;
name|int
name|only_cleanup
init|=
literal|0
decl_stmt|;
name|int
name|rethrow
init|=
literal|0
decl_stmt|;
name|int
name|saved_state
init|=
literal|0
decl_stmt|;
name|long
name|args_size
decl_stmt|;
name|__eh_info
modifier|*
name|eh_info
init|=
operator|(
name|__eh_info
operator|*
operator|)
name|eh
operator|->
name|info
decl_stmt|;
comment|/* Do we find a handler based on a re-throw PC? */
if|if
condition|(
name|eh
operator|->
name|table_index
operator|!=
operator|(
name|void
operator|*
operator|)
literal|0
condition|)
name|rethrow
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|udata
argument_list|,
name|my_udata
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|udata
argument_list|)
argument_list|)
expr_stmt|;
name|handler
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|frame_state
modifier|*
name|p
init|=
name|udata
decl_stmt|;
name|udata
operator|=
name|next_stack_level
argument_list|(
name|pc
argument_list|,
name|udata
argument_list|,
name|sub_udata
argument_list|)
expr_stmt|;
name|sub_udata
operator|=
name|p
expr_stmt|;
comment|/* If we couldn't find the next frame, we lose.  */
if|if
condition|(
operator|!
name|udata
condition|)
break|break;
if|if
condition|(
name|udata
operator|->
name|eh_ptr
operator|==
name|NULL
condition|)
name|new_eh_model
operator|=
literal|0
expr_stmt|;
else|else
name|new_eh_model
operator|=
operator|(
operator|(
operator|(
name|exception_descriptor
operator|*
operator|)
operator|(
name|udata
operator|->
name|eh_ptr
operator|)
operator|)
operator|->
name|runtime_id_field
operator|==
name|NEW_EH_RUNTIME
operator|)
expr_stmt|;
if|if
condition|(
name|rethrow
condition|)
block|{
name|rethrow
operator|=
literal|0
expr_stmt|;
name|handler
operator|=
name|find_exception_handler
argument_list|(
name|eh
operator|->
name|table_index
argument_list|,
name|udata
operator|->
name|eh_ptr
argument_list|,
name|eh_info
argument_list|,
literal|1
argument_list|,
operator|&
name|cleanup
argument_list|)
expr_stmt|;
name|eh
operator|->
name|table_index
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_eh_model
condition|)
name|handler
operator|=
name|find_exception_handler
argument_list|(
name|pc
argument_list|,
name|udata
operator|->
name|eh_ptr
argument_list|,
name|eh_info
argument_list|,
literal|0
argument_list|,
operator|&
name|cleanup
argument_list|)
expr_stmt|;
else|else
name|handler
operator|=
name|old_find_exception_handler
argument_list|(
name|pc
argument_list|,
name|udata
operator|->
name|eh_ptr
argument_list|)
expr_stmt|;
comment|/* If we found one, we can stop searching, if its not a cleanup.           for cleanups, we save the state, and keep looking. This allows          us to call a debug hook if there are nothing but cleanups left. */
if|if
condition|(
name|handler
condition|)
block|{
if|if
condition|(
name|cleanup
condition|)
block|{
if|if
condition|(
operator|!
name|saved_state
condition|)
block|{
name|saved_ustruct
operator|=
operator|*
name|udata
expr_stmt|;
name|handler_p
operator|=
name|handler
expr_stmt|;
name|pc_p
operator|=
name|pc
expr_stmt|;
name|saved_state
operator|=
literal|1
expr_stmt|;
name|only_cleanup
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|only_cleanup
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* Otherwise, we continue searching.  We subtract 1 from PC to avoid 	 hitting the beginning of the next region.  */
name|pc
operator|=
name|get_return_addr
argument_list|(
name|udata
argument_list|,
name|sub_udata
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|saved_state
condition|)
block|{
name|udata
operator|=
operator|&
name|saved_ustruct
expr_stmt|;
name|handler
operator|=
name|handler_p
expr_stmt|;
name|pc
operator|=
name|pc_p
expr_stmt|;
if|if
condition|(
name|only_cleanup
condition|)
name|__unwinding_cleanup
argument_list|()
expr_stmt|;
block|}
comment|/* If we haven't found a handler by now, this is an unhandled      exception.  */
if|if
condition|(
operator|!
name|handler
condition|)
name|__terminate
argument_list|()
expr_stmt|;
name|eh
operator|->
name|handler_label
operator|=
name|handler
expr_stmt|;
name|args_size
operator|=
name|udata
operator|->
name|args_size
expr_stmt|;
if|if
condition|(
name|pc
operator|==
name|saved_pc
condition|)
comment|/* We found a handler in the throw context, no need to unwind.  */
name|udata
operator|=
name|my_udata
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* Unwind all the frames between this one and the handler by copying 	 their saved register values into our register save slots.  */
comment|/* Remember the PC where we found the handler.  */
name|void
modifier|*
name|handler_pc
init|=
name|pc
decl_stmt|;
comment|/* Start from the throw context again.  */
name|pc
operator|=
name|saved_pc
expr_stmt|;
name|memcpy
argument_list|(
name|udata
argument_list|,
name|my_udata
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|udata
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|pc
operator|!=
name|handler_pc
condition|)
block|{
name|frame_state
modifier|*
name|p
init|=
name|udata
decl_stmt|;
name|udata
operator|=
name|next_stack_level
argument_list|(
name|pc
argument_list|,
name|udata
argument_list|,
name|sub_udata
argument_list|)
expr_stmt|;
name|sub_udata
operator|=
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|!=
name|udata
operator|->
name|retaddr_column
operator|&&
name|udata
operator|->
name|saved
index|[
name|i
index|]
condition|)
block|{
comment|/* If you modify the saved value of the return address 		   register on the SPARC, you modify the return address for 		   your caller's frame.  Don't do that here, as it will 		   confuse get_return_addr.  */
if|if
condition|(
name|in_reg_window
argument_list|(
name|i
argument_list|,
name|udata
argument_list|)
operator|&&
name|udata
operator|->
name|saved
index|[
name|udata
operator|->
name|retaddr_column
index|]
operator|==
name|REG_SAVED_REG
operator|&&
name|udata
operator|->
name|reg_or_offset
index|[
name|udata
operator|->
name|retaddr_column
index|]
operator|==
name|i
condition|)
continue|continue;
name|copy_reg
argument_list|(
name|i
argument_list|,
name|udata
argument_list|,
name|my_udata
argument_list|)
expr_stmt|;
block|}
name|pc
operator|=
name|get_return_addr
argument_list|(
name|udata
argument_list|,
name|sub_udata
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
comment|/* But we do need to update the saved return address register from 	 the last frame we unwind, or the handler frame will have the wrong 	 return address.  */
if|if
condition|(
name|udata
operator|->
name|saved
index|[
name|udata
operator|->
name|retaddr_column
index|]
operator|==
name|REG_SAVED_REG
condition|)
block|{
name|i
operator|=
name|udata
operator|->
name|reg_or_offset
index|[
name|udata
operator|->
name|retaddr_column
index|]
expr_stmt|;
if|if
condition|(
name|in_reg_window
argument_list|(
name|i
argument_list|,
name|udata
argument_list|)
condition|)
name|copy_reg
argument_list|(
name|i
argument_list|,
name|udata
argument_list|,
name|my_udata
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* udata now refers to the frame called by the handler frame.  */
comment|/* We adjust SP by the difference between __throw's CFA and the CFA for      the frame called by the handler frame, because those CFAs correspond      to the SP values at the two call sites.  We need to further adjust by      the args_size of the handler frame itself to get the handler frame's      SP from before the args were pushed for that call.  */
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
operator|*
name|offset_p
operator|=
name|udata
operator|->
name|cfa
operator|-
name|my_udata
operator|->
name|cfa
operator|+
name|args_size
expr_stmt|;
else|#
directive|else
operator|*
name|offset_p
operator|=
name|my_udata
operator|->
name|cfa
operator|-
name|udata
operator|->
name|cfa
operator|-
name|args_size
expr_stmt|;
endif|#
directive|endif
return|return
name|handler
return|;
block|}
end_function

begin_comment
comment|/* We first search for an exception handler, and if we don't find    it, we call __terminate on the current stack frame so that we may    use the debugger to walk the stack and understand why no handler    was found.     If we find one, then we unwind the frames down to the one that    has the handler and transfer control into the handler.  */
end_comment

begin_comment
comment|/*extern void __throw(void) __attribute__ ((__noreturn__));*/
end_comment

begin_function
name|void
name|__throw
parameter_list|()
block|{
name|struct
name|eh_context
modifier|*
name|eh
init|=
call|(
modifier|*
name|get_eh_context
call|)
argument_list|()
decl_stmt|;
name|void
modifier|*
name|pc
decl_stmt|,
modifier|*
name|handler
decl_stmt|;
name|long
name|offset
decl_stmt|;
comment|/* XXX maybe make my_ustruct static so we don't have to look it up for      each throw.  */
name|frame_state
name|my_ustruct
decl_stmt|,
modifier|*
name|my_udata
init|=
operator|&
name|my_ustruct
decl_stmt|;
comment|/* This is required for C++ semantics.  We must call terminate if we      try and rethrow an exception, when there is no exception currently      active.  */
if|if
condition|(
operator|!
name|eh
operator|->
name|info
condition|)
name|__terminate
argument_list|()
expr_stmt|;
comment|/* Start at our stack frame.  */
name|label
label|:
name|my_udata
operator|=
name|__frame_state_for
argument_list|(
operator|&&
name|label
argument_list|,
name|my_udata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|my_udata
condition|)
name|__terminate
argument_list|()
expr_stmt|;
comment|/* We need to get the value from the CFA register. */
name|my_udata
operator|->
name|cfa
operator|=
name|__builtin_dwarf_cfa
argument_list|()
expr_stmt|;
comment|/* Do any necessary initialization to access arbitrary stack frames.      On the SPARC, this means flushing the register windows.  */
name|__builtin_unwind_init
argument_list|()
expr_stmt|;
comment|/* Now reset pc to the right throw point.  */
name|pc
operator|=
name|__builtin_extract_return_addr
argument_list|(
name|__builtin_return_address
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|handler
operator|=
name|throw_helper
argument_list|(
name|eh
argument_list|,
name|pc
argument_list|,
name|my_udata
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
comment|/* Now go!  */
name|__builtin_eh_return
argument_list|(
operator|(
name|void
operator|*
operator|)
name|eh
argument_list|,
name|offset
argument_list|,
name|handler
argument_list|)
expr_stmt|;
comment|/* Epilogue:  restore the handler frame's register values and return      to the stub.  */
block|}
end_function

begin_comment
comment|/*extern void __rethrow(void *) __attribute__ ((__noreturn__));*/
end_comment

begin_function
name|void
name|__rethrow
parameter_list|(
name|index
parameter_list|)
name|void
modifier|*
name|index
decl_stmt|;
block|{
name|struct
name|eh_context
modifier|*
name|eh
init|=
call|(
modifier|*
name|get_eh_context
call|)
argument_list|()
decl_stmt|;
name|void
modifier|*
name|pc
decl_stmt|,
modifier|*
name|handler
decl_stmt|;
name|long
name|offset
decl_stmt|;
comment|/* XXX maybe make my_ustruct static so we don't have to look it up for      each throw.  */
name|frame_state
name|my_ustruct
decl_stmt|,
modifier|*
name|my_udata
init|=
operator|&
name|my_ustruct
decl_stmt|;
comment|/* This is required for C++ semantics.  We must call terminate if we      try and rethrow an exception, when there is no exception currently      active.  */
if|if
condition|(
operator|!
name|eh
operator|->
name|info
condition|)
name|__terminate
argument_list|()
expr_stmt|;
comment|/* This is the table index we want to rethrow from. The value of      the END_REGION label is used for the PC of the throw, and the      search begins with the next table entry. */
name|eh
operator|->
name|table_index
operator|=
name|index
expr_stmt|;
comment|/* Start at our stack frame.  */
name|label
label|:
name|my_udata
operator|=
name|__frame_state_for
argument_list|(
operator|&&
name|label
argument_list|,
name|my_udata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|my_udata
condition|)
name|__terminate
argument_list|()
expr_stmt|;
comment|/* We need to get the value from the CFA register. */
name|my_udata
operator|->
name|cfa
operator|=
name|__builtin_dwarf_cfa
argument_list|()
expr_stmt|;
comment|/* Do any necessary initialization to access arbitrary stack frames.      On the SPARC, this means flushing the register windows.  */
name|__builtin_unwind_init
argument_list|()
expr_stmt|;
comment|/* Now reset pc to the right throw point.  */
name|pc
operator|=
name|__builtin_extract_return_addr
argument_list|(
name|__builtin_return_address
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|handler
operator|=
name|throw_helper
argument_list|(
name|eh
argument_list|,
name|pc
argument_list|,
name|my_udata
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
comment|/* Now go!  */
name|__builtin_eh_return
argument_list|(
operator|(
name|void
operator|*
operator|)
name|eh
argument_list|,
name|offset
argument_list|,
name|handler
argument_list|)
expr_stmt|;
comment|/* Epilogue:  restore the handler frame's register values and return      to the stub.  */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DWARF2_UNWIND_INFO */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_eh */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_pure
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|inhibit_libc
end_ifndef

begin_comment
comment|/* This gets us __GNU_LIBRARY__.  */
end_comment

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_comment
comment|/* Avoid errors if stdio.h and our stddef.h mismatch.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__GNU_LIBRARY__
end_ifdef

begin_comment
comment|/* Avoid forcing the library's meaning of `write' on the user program      by using the "internal" name (for use within the library)  */
end_comment

begin_define
define|#
directive|define
name|write
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|n
parameter_list|)
value|__write((fd), (buf), (n))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* inhibit_libc */
end_comment

begin_define
define|#
directive|define
name|MESSAGE
value|"pure virtual method called\n"
end_define

begin_function
name|void
name|__pure_virtual
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|inhibit_libc
name|write
argument_list|(
literal|2
argument_list|,
name|MESSAGE
argument_list|,
sizeof|sizeof
argument_list|(
name|MESSAGE
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|__terminate
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

