begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* More subroutines needed by GCC output code on some machines.  */
end_comment

begin_comment
comment|/* Compile this one with gcc.  */
end_comment

begin_comment
comment|/* Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004, 2005  Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  In addition to the permissions in the GNU General Public License, the Free Software Foundation gives you unlimited permission to link the compiled version of this file into combinations with other programs, and to distribute those combinations without any restriction coming from the use of this file.  (The General Public License restrictions do apply in other respects; for example, they cover modification of the file, and distribution when not linked into a combine executable.)  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"tsystem.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GAS_HIDDEN
end_ifdef

begin_define
define|#
directive|define
name|ATTRIBUTE_HIDDEN
value|__attribute__ ((__visibility__ ("hidden")))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ATTRIBUTE_HIDDEN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MIN_UNITS_PER_WORD
end_ifndef

begin_define
define|#
directive|define
name|MIN_UNITS_PER_WORD
value|UNITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Work out the largest "word" size that we can deal with on this target.  */
end_comment

begin_if
if|#
directive|if
name|MIN_UNITS_PER_WORD
operator|>
literal|4
end_if

begin_define
define|#
directive|define
name|LIBGCC2_MAX_UNITS_PER_WORD
value|8
end_define

begin_elif
elif|#
directive|elif
operator|(
name|MIN_UNITS_PER_WORD
operator|>
literal|2
expr|\
operator|||
operator|(
name|MIN_UNITS_PER_WORD
operator|>
literal|1
operator|&&
name|LONG_LONG_TYPE_SIZE
operator|>
literal|32
operator|)
operator|)
end_elif

begin_define
define|#
directive|define
name|LIBGCC2_MAX_UNITS_PER_WORD
value|4
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LIBGCC2_MAX_UNITS_PER_WORD
value|MIN_UNITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Work out what word size we are using for this compilation.    The value can be set on the command line.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LIBGCC2_UNITS_PER_WORD
end_ifndef

begin_define
define|#
directive|define
name|LIBGCC2_UNITS_PER_WORD
value|LIBGCC2_MAX_UNITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|LIBGCC2_UNITS_PER_WORD
operator|<=
name|LIBGCC2_MAX_UNITS_PER_WORD
end_if

begin_include
include|#
directive|include
file|"libgcc2.h"
end_include

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DECLARE_LIBRARY_RENAMES
end_ifdef

begin_function
name|DECLARE_LIBRARY_RENAMES
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|L_negdi2
argument_list|)
name|DWtype
name|__negdi2
parameter_list|(
name|DWtype
name|u
parameter_list|)
block|{
specifier|const
name|DWunion
name|uu
init|=
block|{
operator|.
name|ll
operator|=
name|u
block|}
decl_stmt|;
specifier|const
name|DWunion
name|w
init|=
block|{
block|{
operator|.
name|low
operator|=
operator|-
name|uu
operator|.
name|s
operator|.
name|low
block|,
operator|.
name|high
operator|=
operator|-
name|uu
operator|.
name|s
operator|.
name|high
operator|-
operator|(
operator|(
name|UWtype
operator|)
operator|-
name|uu
operator|.
name|s
operator|.
name|low
operator|>
literal|0
operator|)
block|}
block|}
decl_stmt|;
return|return
name|w
operator|.
name|ll
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_addvsi3
end_ifdef

begin_function
name|Wtype
name|__addvSI3
parameter_list|(
name|Wtype
name|a
parameter_list|,
name|Wtype
name|b
parameter_list|)
block|{
specifier|const
name|Wtype
name|w
init|=
name|a
operator|+
name|b
decl_stmt|;
if|if
condition|(
name|b
operator|>=
literal|0
condition|?
name|w
operator|<
name|a
else|:
name|w
operator|>
name|a
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_SIMODE_TRAPPING_ARITHMETIC
end_ifdef

begin_function
name|SItype
name|__addvsi3
parameter_list|(
name|SItype
name|a
parameter_list|,
name|SItype
name|b
parameter_list|)
block|{
specifier|const
name|SItype
name|w
init|=
name|a
operator|+
name|b
decl_stmt|;
if|if
condition|(
name|b
operator|>=
literal|0
condition|?
name|w
operator|<
name|a
else|:
name|w
operator|>
name|a
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_SIMODE_TRAPPING_ARITHMETIC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_addvdi3
end_ifdef

begin_function
name|DWtype
name|__addvDI3
parameter_list|(
name|DWtype
name|a
parameter_list|,
name|DWtype
name|b
parameter_list|)
block|{
specifier|const
name|DWtype
name|w
init|=
name|a
operator|+
name|b
decl_stmt|;
if|if
condition|(
name|b
operator|>=
literal|0
condition|?
name|w
operator|<
name|a
else|:
name|w
operator|>
name|a
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_subvsi3
end_ifdef

begin_function
name|Wtype
name|__subvSI3
parameter_list|(
name|Wtype
name|a
parameter_list|,
name|Wtype
name|b
parameter_list|)
block|{
specifier|const
name|Wtype
name|w
init|=
name|a
operator|-
name|b
decl_stmt|;
if|if
condition|(
name|b
operator|>=
literal|0
condition|?
name|w
operator|>
name|a
else|:
name|w
operator|<
name|a
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_SIMODE_TRAPPING_ARITHMETIC
end_ifdef

begin_function
name|SItype
name|__subvsi3
parameter_list|(
name|SItype
name|a
parameter_list|,
name|SItype
name|b
parameter_list|)
block|{
specifier|const
name|SItype
name|w
init|=
name|a
operator|-
name|b
decl_stmt|;
if|if
condition|(
name|b
operator|>=
literal|0
condition|?
name|w
operator|>
name|a
else|:
name|w
operator|<
name|a
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_SIMODE_TRAPPING_ARITHMETIC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_subvdi3
end_ifdef

begin_function
name|DWtype
name|__subvDI3
parameter_list|(
name|DWtype
name|a
parameter_list|,
name|DWtype
name|b
parameter_list|)
block|{
specifier|const
name|DWtype
name|w
init|=
name|a
operator|-
name|b
decl_stmt|;
if|if
condition|(
name|b
operator|>=
literal|0
condition|?
name|w
operator|>
name|a
else|:
name|w
operator|<
name|a
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_mulvsi3
end_ifdef

begin_function
name|Wtype
name|__mulvSI3
parameter_list|(
name|Wtype
name|a
parameter_list|,
name|Wtype
name|b
parameter_list|)
block|{
specifier|const
name|DWtype
name|w
init|=
operator|(
name|DWtype
operator|)
name|a
operator|*
operator|(
name|DWtype
operator|)
name|b
decl_stmt|;
if|if
condition|(
call|(
name|Wtype
call|)
argument_list|(
name|w
operator|>>
name|W_TYPE_SIZE
argument_list|)
operator|!=
operator|(
name|Wtype
operator|)
name|w
operator|>>
operator|(
name|W_TYPE_SIZE
operator|-
literal|1
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_SIMODE_TRAPPING_ARITHMETIC
end_ifdef

begin_undef
undef|#
directive|undef
name|WORD_SIZE
end_undef

begin_define
define|#
directive|define
name|WORD_SIZE
value|(sizeof (SItype) * BITS_PER_UNIT)
end_define

begin_function
name|SItype
name|__mulvsi3
parameter_list|(
name|SItype
name|a
parameter_list|,
name|SItype
name|b
parameter_list|)
block|{
specifier|const
name|DItype
name|w
init|=
operator|(
name|DItype
operator|)
name|a
operator|*
operator|(
name|DItype
operator|)
name|b
decl_stmt|;
if|if
condition|(
call|(
name|SItype
call|)
argument_list|(
name|w
operator|>>
name|WORD_SIZE
argument_list|)
operator|!=
operator|(
name|SItype
operator|)
name|w
operator|>>
operator|(
name|WORD_SIZE
operator|-
literal|1
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_SIMODE_TRAPPING_ARITHMETIC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_negvsi2
end_ifdef

begin_function
name|Wtype
name|__negvSI2
parameter_list|(
name|Wtype
name|a
parameter_list|)
block|{
specifier|const
name|Wtype
name|w
init|=
operator|-
name|a
decl_stmt|;
if|if
condition|(
name|a
operator|>=
literal|0
condition|?
name|w
operator|>
literal|0
else|:
name|w
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_SIMODE_TRAPPING_ARITHMETIC
end_ifdef

begin_function
name|SItype
name|__negvsi2
parameter_list|(
name|SItype
name|a
parameter_list|)
block|{
specifier|const
name|SItype
name|w
init|=
operator|-
name|a
decl_stmt|;
if|if
condition|(
name|a
operator|>=
literal|0
condition|?
name|w
operator|>
literal|0
else|:
name|w
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_SIMODE_TRAPPING_ARITHMETIC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_negvdi2
end_ifdef

begin_function
name|DWtype
name|__negvDI2
parameter_list|(
name|DWtype
name|a
parameter_list|)
block|{
specifier|const
name|DWtype
name|w
init|=
operator|-
name|a
decl_stmt|;
if|if
condition|(
name|a
operator|>=
literal|0
condition|?
name|w
operator|>
literal|0
else|:
name|w
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_absvsi2
end_ifdef

begin_function
name|Wtype
name|__absvSI2
parameter_list|(
name|Wtype
name|a
parameter_list|)
block|{
name|Wtype
name|w
init|=
name|a
decl_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
ifdef|#
directive|ifdef
name|L_negvsi2
name|w
operator|=
name|__negvSI2
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|#
directive|else
name|w
operator|=
operator|-
name|a
expr_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|w
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_SIMODE_TRAPPING_ARITHMETIC
end_ifdef

begin_function
name|SItype
name|__absvsi2
parameter_list|(
name|SItype
name|a
parameter_list|)
block|{
name|SItype
name|w
init|=
name|a
decl_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
ifdef|#
directive|ifdef
name|L_negvsi2
name|w
operator|=
name|__negvsi2
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|#
directive|else
name|w
operator|=
operator|-
name|a
expr_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_SIMODE_TRAPPING_ARITHMETIC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_absvdi2
end_ifdef

begin_function
name|DWtype
name|__absvDI2
parameter_list|(
name|DWtype
name|a
parameter_list|)
block|{
name|DWtype
name|w
init|=
name|a
decl_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
ifdef|#
directive|ifdef
name|L_negvdi2
name|w
operator|=
name|__negvDI2
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|#
directive|else
name|w
operator|=
operator|-
name|a
expr_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_mulvdi3
end_ifdef

begin_function
name|DWtype
name|__mulvDI3
parameter_list|(
name|DWtype
name|u
parameter_list|,
name|DWtype
name|v
parameter_list|)
block|{
comment|/* The unchecked multiplication needs 3 Wtype x Wtype multiplications,      but the checked multiplication needs only two.  */
specifier|const
name|DWunion
name|uu
init|=
block|{
operator|.
name|ll
operator|=
name|u
block|}
decl_stmt|;
specifier|const
name|DWunion
name|vv
init|=
block|{
operator|.
name|ll
operator|=
name|v
block|}
decl_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|uu
operator|.
name|s
operator|.
name|high
operator|==
name|uu
operator|.
name|s
operator|.
name|low
operator|>>
operator|(
name|W_TYPE_SIZE
operator|-
literal|1
operator|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* u fits in a single Wtype.  */
if|if
condition|(
name|__builtin_expect
argument_list|(
name|vv
operator|.
name|s
operator|.
name|high
operator|==
name|vv
operator|.
name|s
operator|.
name|low
operator|>>
operator|(
name|W_TYPE_SIZE
operator|-
literal|1
operator|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* v fits in a single Wtype as well.  */
comment|/* A single multiplication.  No overflow risk.  */
return|return
operator|(
name|DWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|*
operator|(
name|DWtype
operator|)
name|vv
operator|.
name|s
operator|.
name|low
return|;
block|}
else|else
block|{
comment|/* Two multiplications.  */
name|DWunion
name|w0
init|=
block|{
operator|.
name|ll
operator|=
operator|(
name|UDWtype
operator|)
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|*
operator|(
name|UDWtype
operator|)
operator|(
name|UWtype
operator|)
name|vv
operator|.
name|s
operator|.
name|low
block|}
decl_stmt|;
name|DWunion
name|w1
init|=
block|{
operator|.
name|ll
operator|=
operator|(
name|UDWtype
operator|)
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|*
operator|(
name|UDWtype
operator|)
operator|(
name|UWtype
operator|)
name|vv
operator|.
name|s
operator|.
name|high
block|}
decl_stmt|;
if|if
condition|(
name|vv
operator|.
name|s
operator|.
name|high
operator|<
literal|0
condition|)
name|w1
operator|.
name|s
operator|.
name|high
operator|-=
name|uu
operator|.
name|s
operator|.
name|low
expr_stmt|;
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|low
operator|<
literal|0
condition|)
name|w1
operator|.
name|ll
operator|-=
name|vv
operator|.
name|ll
expr_stmt|;
name|w1
operator|.
name|ll
operator|+=
operator|(
name|UWtype
operator|)
name|w0
operator|.
name|s
operator|.
name|high
expr_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|w1
operator|.
name|s
operator|.
name|high
operator|==
name|w1
operator|.
name|s
operator|.
name|low
operator|>>
operator|(
name|W_TYPE_SIZE
operator|-
literal|1
operator|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|w0
operator|.
name|s
operator|.
name|high
operator|=
name|w1
operator|.
name|s
operator|.
name|low
expr_stmt|;
return|return
name|w0
operator|.
name|ll
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|__builtin_expect
argument_list|(
name|vv
operator|.
name|s
operator|.
name|high
operator|==
name|vv
operator|.
name|s
operator|.
name|low
operator|>>
operator|(
name|W_TYPE_SIZE
operator|-
literal|1
operator|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* v fits into a single Wtype.  */
comment|/* Two multiplications.  */
name|DWunion
name|w0
init|=
block|{
operator|.
name|ll
operator|=
operator|(
name|UDWtype
operator|)
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|*
operator|(
name|UDWtype
operator|)
operator|(
name|UWtype
operator|)
name|vv
operator|.
name|s
operator|.
name|low
block|}
decl_stmt|;
name|DWunion
name|w1
init|=
block|{
operator|.
name|ll
operator|=
operator|(
name|UDWtype
operator|)
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|high
operator|*
operator|(
name|UDWtype
operator|)
operator|(
name|UWtype
operator|)
name|vv
operator|.
name|s
operator|.
name|low
block|}
decl_stmt|;
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|high
operator|<
literal|0
condition|)
name|w1
operator|.
name|s
operator|.
name|high
operator|-=
name|vv
operator|.
name|s
operator|.
name|low
expr_stmt|;
if|if
condition|(
name|vv
operator|.
name|s
operator|.
name|low
operator|<
literal|0
condition|)
name|w1
operator|.
name|ll
operator|-=
name|uu
operator|.
name|ll
expr_stmt|;
name|w1
operator|.
name|ll
operator|+=
operator|(
name|UWtype
operator|)
name|w0
operator|.
name|s
operator|.
name|high
expr_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|w1
operator|.
name|s
operator|.
name|high
operator|==
name|w1
operator|.
name|s
operator|.
name|low
operator|>>
operator|(
name|W_TYPE_SIZE
operator|-
literal|1
operator|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|w0
operator|.
name|s
operator|.
name|high
operator|=
name|w1
operator|.
name|s
operator|.
name|low
expr_stmt|;
return|return
name|w0
operator|.
name|ll
return|;
block|}
block|}
else|else
block|{
comment|/* A few sign checks and a single multiplication.  */
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|high
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|vv
operator|.
name|s
operator|.
name|high
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|high
operator|==
literal|0
operator|&&
name|vv
operator|.
name|s
operator|.
name|high
operator|==
literal|0
condition|)
block|{
specifier|const
name|DWtype
name|w
init|=
operator|(
name|UDWtype
operator|)
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|*
operator|(
name|UDWtype
operator|)
operator|(
name|UWtype
operator|)
name|vv
operator|.
name|s
operator|.
name|low
decl_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|w
operator|>=
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|w
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|high
operator|==
literal|0
operator|&&
name|vv
operator|.
name|s
operator|.
name|high
operator|==
operator|(
name|Wtype
operator|)
operator|-
literal|1
condition|)
block|{
name|DWunion
name|ww
init|=
block|{
operator|.
name|ll
operator|=
operator|(
name|UDWtype
operator|)
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|*
operator|(
name|UDWtype
operator|)
operator|(
name|UWtype
operator|)
name|vv
operator|.
name|s
operator|.
name|low
block|}
decl_stmt|;
name|ww
operator|.
name|s
operator|.
name|high
operator|-=
name|uu
operator|.
name|s
operator|.
name|low
expr_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|ww
operator|.
name|s
operator|.
name|high
operator|<
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|ww
operator|.
name|ll
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|vv
operator|.
name|s
operator|.
name|high
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|high
operator|==
operator|(
name|Wtype
operator|)
operator|-
literal|1
operator|&&
name|vv
operator|.
name|s
operator|.
name|high
operator|==
literal|0
condition|)
block|{
name|DWunion
name|ww
init|=
block|{
operator|.
name|ll
operator|=
operator|(
name|UDWtype
operator|)
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|*
operator|(
name|UDWtype
operator|)
operator|(
name|UWtype
operator|)
name|vv
operator|.
name|s
operator|.
name|low
block|}
decl_stmt|;
name|ww
operator|.
name|s
operator|.
name|high
operator|-=
name|vv
operator|.
name|s
operator|.
name|low
expr_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|ww
operator|.
name|s
operator|.
name|high
operator|<
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|ww
operator|.
name|ll
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|high
operator|==
operator|(
name|Wtype
operator|)
operator|-
literal|1
operator|&&
name|vv
operator|.
name|s
operator|.
name|high
operator|==
operator|(
name|Wtype
operator|)
operator|-
literal|1
condition|)
block|{
name|DWunion
name|ww
init|=
block|{
operator|.
name|ll
operator|=
operator|(
name|UDWtype
operator|)
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|*
operator|(
name|UDWtype
operator|)
operator|(
name|UWtype
operator|)
name|vv
operator|.
name|s
operator|.
name|low
block|}
decl_stmt|;
name|ww
operator|.
name|s
operator|.
name|high
operator|-=
name|uu
operator|.
name|s
operator|.
name|low
expr_stmt|;
name|ww
operator|.
name|s
operator|.
name|high
operator|-=
name|vv
operator|.
name|s
operator|.
name|low
expr_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|ww
operator|.
name|s
operator|.
name|high
operator|>=
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|ww
operator|.
name|ll
return|;
block|}
block|}
block|}
block|}
block|}
comment|/* Overflow.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Unless shift functions are defined with full ANSI prototypes,    parameter b will be promoted to int if word_type is smaller than an int.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|L_lshrdi3
end_ifdef

begin_function
name|DWtype
name|__lshrdi3
parameter_list|(
name|DWtype
name|u
parameter_list|,
name|word_type
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
name|u
return|;
specifier|const
name|DWunion
name|uu
init|=
block|{
operator|.
name|ll
operator|=
name|u
block|}
decl_stmt|;
specifier|const
name|word_type
name|bm
init|=
operator|(
sizeof|sizeof
argument_list|(
name|Wtype
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|-
name|b
decl_stmt|;
name|DWunion
name|w
decl_stmt|;
if|if
condition|(
name|bm
operator|<=
literal|0
condition|)
block|{
name|w
operator|.
name|s
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|low
operator|=
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|high
operator|>>
operator|-
name|bm
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|UWtype
name|carries
init|=
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|high
operator|<<
name|bm
decl_stmt|;
name|w
operator|.
name|s
operator|.
name|high
operator|=
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|high
operator|>>
name|b
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|low
operator|=
operator|(
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|>>
name|b
operator|)
operator||
name|carries
expr_stmt|;
block|}
return|return
name|w
operator|.
name|ll
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_ashldi3
end_ifdef

begin_function
name|DWtype
name|__ashldi3
parameter_list|(
name|DWtype
name|u
parameter_list|,
name|word_type
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
name|u
return|;
specifier|const
name|DWunion
name|uu
init|=
block|{
operator|.
name|ll
operator|=
name|u
block|}
decl_stmt|;
specifier|const
name|word_type
name|bm
init|=
operator|(
sizeof|sizeof
argument_list|(
name|Wtype
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|-
name|b
decl_stmt|;
name|DWunion
name|w
decl_stmt|;
if|if
condition|(
name|bm
operator|<=
literal|0
condition|)
block|{
name|w
operator|.
name|s
operator|.
name|low
operator|=
literal|0
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|high
operator|=
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|<<
operator|-
name|bm
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|UWtype
name|carries
init|=
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|>>
name|bm
decl_stmt|;
name|w
operator|.
name|s
operator|.
name|low
operator|=
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|<<
name|b
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|high
operator|=
operator|(
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|high
operator|<<
name|b
operator|)
operator||
name|carries
expr_stmt|;
block|}
return|return
name|w
operator|.
name|ll
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_ashrdi3
end_ifdef

begin_function
name|DWtype
name|__ashrdi3
parameter_list|(
name|DWtype
name|u
parameter_list|,
name|word_type
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
name|u
return|;
specifier|const
name|DWunion
name|uu
init|=
block|{
operator|.
name|ll
operator|=
name|u
block|}
decl_stmt|;
specifier|const
name|word_type
name|bm
init|=
operator|(
sizeof|sizeof
argument_list|(
name|Wtype
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|-
name|b
decl_stmt|;
name|DWunion
name|w
decl_stmt|;
if|if
condition|(
name|bm
operator|<=
literal|0
condition|)
block|{
comment|/* w.s.high = 1..1 or 0..0 */
name|w
operator|.
name|s
operator|.
name|high
operator|=
name|uu
operator|.
name|s
operator|.
name|high
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|Wtype
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|low
operator|=
name|uu
operator|.
name|s
operator|.
name|high
operator|>>
operator|-
name|bm
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|UWtype
name|carries
init|=
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|high
operator|<<
name|bm
decl_stmt|;
name|w
operator|.
name|s
operator|.
name|high
operator|=
name|uu
operator|.
name|s
operator|.
name|high
operator|>>
name|b
expr_stmt|;
name|w
operator|.
name|s
operator|.
name|low
operator|=
operator|(
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|>>
name|b
operator|)
operator||
name|carries
expr_stmt|;
block|}
return|return
name|w
operator|.
name|ll
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_bswapsi2
end_ifdef

begin_function
name|UWtype
name|__bswapsi2
parameter_list|(
name|UWtype
name|u
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
operator|(
name|u
operator|)
operator|&
literal|0xff000000
operator|)
operator|>>
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u
operator|)
operator|&
literal|0x00ff0000
operator|)
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u
operator|)
operator|&
literal|0x0000ff00
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u
operator|)
operator|&
literal|0x000000ff
operator|)
operator|<<
literal|24
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_bswapdi2
end_ifdef

begin_function
name|UDWtype
name|__bswapdi2
parameter_list|(
name|UDWtype
name|u
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
operator|(
name|u
operator|)
operator|&
literal|0xff00000000000000ull
operator|)
operator|>>
literal|56
operator|)
operator||
operator|(
operator|(
operator|(
name|u
operator|)
operator|&
literal|0x00ff000000000000ull
operator|)
operator|>>
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u
operator|)
operator|&
literal|0x0000ff0000000000ull
operator|)
operator|>>
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u
operator|)
operator|&
literal|0x000000ff00000000ull
operator|)
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u
operator|)
operator|&
literal|0x00000000ff000000ull
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|u
operator|)
operator|&
literal|0x0000000000ff0000ull
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|u
operator|)
operator|&
literal|0x000000000000ff00ull
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|u
operator|)
operator|&
literal|0x00000000000000ffull
operator|)
operator|<<
literal|56
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_ffssi2
end_ifdef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_function
name|int
name|__ffsSI2
parameter_list|(
name|UWtype
name|u
parameter_list|)
block|{
name|UWtype
name|count
decl_stmt|;
if|if
condition|(
name|u
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|count_trailing_zeros
argument_list|(
name|count
argument_list|,
name|u
argument_list|)
expr_stmt|;
return|return
name|count
operator|+
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_ffsdi2
end_ifdef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_function
name|int
name|__ffsDI2
parameter_list|(
name|DWtype
name|u
parameter_list|)
block|{
specifier|const
name|DWunion
name|uu
init|=
block|{
operator|.
name|ll
operator|=
name|u
block|}
decl_stmt|;
name|UWtype
name|word
decl_stmt|,
name|count
decl_stmt|,
name|add
decl_stmt|;
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|low
operator|!=
literal|0
condition|)
name|word
operator|=
name|uu
operator|.
name|s
operator|.
name|low
operator|,
name|add
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|high
operator|!=
literal|0
condition|)
name|word
operator|=
name|uu
operator|.
name|s
operator|.
name|high
operator|,
name|add
operator|=
name|BITS_PER_UNIT
operator|*
sizeof|sizeof
argument_list|(
name|Wtype
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
name|count_trailing_zeros
argument_list|(
name|count
argument_list|,
name|word
argument_list|)
expr_stmt|;
return|return
name|count
operator|+
name|add
operator|+
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_muldi3
end_ifdef

begin_function
name|DWtype
name|__muldi3
parameter_list|(
name|DWtype
name|u
parameter_list|,
name|DWtype
name|v
parameter_list|)
block|{
specifier|const
name|DWunion
name|uu
init|=
block|{
operator|.
name|ll
operator|=
name|u
block|}
decl_stmt|;
specifier|const
name|DWunion
name|vv
init|=
block|{
operator|.
name|ll
operator|=
name|v
block|}
decl_stmt|;
name|DWunion
name|w
init|=
block|{
operator|.
name|ll
operator|=
name|__umulsidi3
argument_list|(
argument|uu.s.low
argument_list|,
argument|vv.s.low
argument_list|)
block|}
decl_stmt|;
name|w
operator|.
name|s
operator|.
name|high
operator|+=
operator|(
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|low
operator|*
operator|(
name|UWtype
operator|)
name|vv
operator|.
name|s
operator|.
name|high
operator|+
operator|(
name|UWtype
operator|)
name|uu
operator|.
name|s
operator|.
name|high
operator|*
operator|(
name|UWtype
operator|)
name|vv
operator|.
name|s
operator|.
name|low
operator|)
expr_stmt|;
return|return
name|w
operator|.
name|ll
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|L_udivdi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divdi3
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|L_umoddi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_moddi3
argument_list|)
operator|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sdiv_qrnnd
argument_list|)
end_if

begin_define
define|#
directive|define
name|L_udiv_w_sdiv
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_udiv_w_sdiv
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sdiv_qrnnd
argument_list|)
end_if

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|L_udivdi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divdi3
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|L_umoddi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_moddi3
argument_list|)
operator|)
end_if

begin_expr_stmt
specifier|static
specifier|inline
name|__attribute__
argument_list|(
argument|(__always_inline__)
argument_list|)
endif|#
directive|endif
name|UWtype
name|__udiv_w_sdiv
argument_list|(
argument|UWtype *rp
argument_list|,
argument|UWtype a1
argument_list|,
argument|UWtype a0
argument_list|,
argument|UWtype d
argument_list|)
block|{
name|UWtype
name|q
block|,
name|r
block|;
name|UWtype
name|c0
block|,
name|c1
block|,
name|b1
block|;
if|if
condition|(
operator|(
name|Wtype
operator|)
name|d
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|a1
operator|<
name|d
operator|-
name|a1
operator|-
operator|(
name|a0
operator|>>
operator|(
name|W_TYPE_SIZE
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* Dividend, divisor, and quotient are nonnegative.  */
name|sdiv_qrnnd
argument_list|(
name|q
argument_list|,
name|r
argument_list|,
name|a1
argument_list|,
name|a0
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
comment|/* Compute c1*2^32 + c0 = a1*2^32 + a0 - 2^31*d.  */
name|sub_ddmmss
argument_list|(
name|c1
argument_list|,
name|c0
argument_list|,
name|a1
argument_list|,
name|a0
argument_list|,
name|d
operator|>>
literal|1
argument_list|,
name|d
operator|<<
operator|(
name|W_TYPE_SIZE
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Divide (c1*2^32 + c0) by d.  */
name|sdiv_qrnnd
argument_list|(
name|q
argument_list|,
name|r
argument_list|,
name|c1
argument_list|,
name|c0
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* Add 2^31 to quotient.  */
name|q
operator|+=
operator|(
name|UWtype
operator|)
literal|1
operator|<<
operator|(
name|W_TYPE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_else

begin_block
unit|}   else
block|{
name|b1
operator|=
name|d
operator|>>
literal|1
expr_stmt|;
comment|/* d/2, between 2^30 and 2^31 - 1 */
name|c1
operator|=
name|a1
operator|>>
literal|1
expr_stmt|;
comment|/* A/2 */
name|c0
operator|=
operator|(
name|a1
operator|<<
operator|(
name|W_TYPE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|+
operator|(
name|a0
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|a1
operator|<
name|b1
condition|)
comment|/* A< 2^32*b1, so A/2< 2^31*b1 */
block|{
name|sdiv_qrnnd
argument_list|(
name|q
argument_list|,
name|r
argument_list|,
name|c1
argument_list|,
name|c0
argument_list|,
name|b1
argument_list|)
expr_stmt|;
comment|/* (A/2) / (d/2) */
name|r
operator|=
literal|2
operator|*
name|r
operator|+
operator|(
name|a0
operator|&
literal|1
operator|)
expr_stmt|;
comment|/* Remainder from A/(2*b1) */
if|if
condition|(
operator|(
name|d
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|>=
name|q
condition|)
name|r
operator|=
name|r
operator|-
name|q
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|-
name|r
operator|<=
name|d
condition|)
block|{
name|r
operator|=
name|r
operator|-
name|q
operator|+
name|d
expr_stmt|;
name|q
operator|--
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|r
operator|-
name|q
operator|+
literal|2
operator|*
name|d
expr_stmt|;
name|q
operator|-=
literal|2
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c1
operator|<
name|b1
condition|)
comment|/* So 2^31<= (A/2)/b1< 2^32 */
block|{
name|c1
operator|=
operator|(
name|b1
operator|-
literal|1
operator|)
operator|-
name|c1
expr_stmt|;
name|c0
operator|=
operator|~
name|c0
expr_stmt|;
comment|/* logical NOT */
name|sdiv_qrnnd
argument_list|(
name|q
argument_list|,
name|r
argument_list|,
name|c1
argument_list|,
name|c0
argument_list|,
name|b1
argument_list|)
expr_stmt|;
comment|/* (A/2) / (d/2) */
name|q
operator|=
operator|~
name|q
expr_stmt|;
comment|/* (A/2)/b1 */
name|r
operator|=
operator|(
name|b1
operator|-
literal|1
operator|)
operator|-
name|r
expr_stmt|;
name|r
operator|=
literal|2
operator|*
name|r
operator|+
operator|(
name|a0
operator|&
literal|1
operator|)
expr_stmt|;
comment|/* A/(2*b1) */
if|if
condition|(
operator|(
name|d
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|>=
name|q
condition|)
name|r
operator|=
name|r
operator|-
name|q
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|-
name|r
operator|<=
name|d
condition|)
block|{
name|r
operator|=
name|r
operator|-
name|q
operator|+
name|d
expr_stmt|;
name|q
operator|--
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|r
operator|-
name|q
operator|+
literal|2
operator|*
name|d
expr_stmt|;
name|q
operator|-=
literal|2
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* Implies c1 = b1 */
block|{
comment|/* Hence a1 = d - 1 = 2*b1 - 1 */
if|if
condition|(
name|a0
operator|>=
operator|-
name|d
condition|)
block|{
name|q
operator|=
operator|-
literal|1
expr_stmt|;
name|r
operator|=
name|a0
operator|+
name|d
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
operator|-
literal|2
expr_stmt|;
name|r
operator|=
name|a0
operator|+
literal|2
operator|*
name|d
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
operator|*
name|rp
operator|=
name|r
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|q
return|;
end_return

begin_else
unit|}
else|#
directive|else
end_else

begin_comment
comment|/* If sdiv_qrnnd doesn't exist, define dummy __udiv_w_sdiv.  */
end_comment

begin_macro
unit|UWtype
name|__udiv_w_sdiv
argument_list|(
argument|UWtype *rp __attribute__ ((__unused__))
argument_list|,
argument|UWtype a1 __attribute__ ((__unused__))
argument_list|,
argument|UWtype a0 __attribute__ ((__unused__))
argument_list|,
argument|UWtype d __attribute__ ((__unused__))
argument_list|)
end_macro

begin_block
block|{
return|return
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|L_udivdi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divdi3
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|L_umoddi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_moddi3
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|L_udivmoddi4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_clz
end_ifdef

begin_decl_stmt
specifier|const
name|UQItype
name|__clz_tab
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_clzsi2
end_ifdef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_function
name|int
name|__clzSI2
parameter_list|(
name|UWtype
name|x
parameter_list|)
block|{
name|Wtype
name|ret
decl_stmt|;
name|count_leading_zeros
argument_list|(
name|ret
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_clzdi2
end_ifdef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_function
name|int
name|__clzDI2
parameter_list|(
name|UDWtype
name|x
parameter_list|)
block|{
specifier|const
name|DWunion
name|uu
init|=
block|{
operator|.
name|ll
operator|=
name|x
block|}
decl_stmt|;
name|UWtype
name|word
decl_stmt|;
name|Wtype
name|ret
decl_stmt|,
name|add
decl_stmt|;
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|high
condition|)
name|word
operator|=
name|uu
operator|.
name|s
operator|.
name|high
operator|,
name|add
operator|=
literal|0
expr_stmt|;
else|else
name|word
operator|=
name|uu
operator|.
name|s
operator|.
name|low
operator|,
name|add
operator|=
name|W_TYPE_SIZE
expr_stmt|;
name|count_leading_zeros
argument_list|(
name|ret
argument_list|,
name|word
argument_list|)
expr_stmt|;
return|return
name|ret
operator|+
name|add
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_ctzsi2
end_ifdef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_function
name|int
name|__ctzSI2
parameter_list|(
name|UWtype
name|x
parameter_list|)
block|{
name|Wtype
name|ret
decl_stmt|;
name|count_trailing_zeros
argument_list|(
name|ret
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_ctzdi2
end_ifdef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_function
name|int
name|__ctzDI2
parameter_list|(
name|UDWtype
name|x
parameter_list|)
block|{
specifier|const
name|DWunion
name|uu
init|=
block|{
operator|.
name|ll
operator|=
name|x
block|}
decl_stmt|;
name|UWtype
name|word
decl_stmt|;
name|Wtype
name|ret
decl_stmt|,
name|add
decl_stmt|;
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|low
condition|)
name|word
operator|=
name|uu
operator|.
name|s
operator|.
name|low
operator|,
name|add
operator|=
literal|0
expr_stmt|;
else|else
name|word
operator|=
name|uu
operator|.
name|s
operator|.
name|high
operator|,
name|add
operator|=
name|W_TYPE_SIZE
expr_stmt|;
name|count_trailing_zeros
argument_list|(
name|ret
argument_list|,
name|word
argument_list|)
expr_stmt|;
return|return
name|ret
operator|+
name|add
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_popcount_tab
end_ifdef

begin_decl_stmt
specifier|const
name|UQItype
name|__popcount_tab
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_popcountsi2
end_ifdef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_function
name|int
name|__popcountSI2
parameter_list|(
name|UWtype
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|W_TYPE_SIZE
condition|;
name|i
operator|+=
literal|8
control|)
name|ret
operator|+=
name|__popcount_tab
index|[
operator|(
name|x
operator|>>
name|i
operator|)
operator|&
literal|0xff
index|]
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_popcountdi2
end_ifdef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_function
name|int
name|__popcountDI2
parameter_list|(
name|UDWtype
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
operator|*
name|W_TYPE_SIZE
condition|;
name|i
operator|+=
literal|8
control|)
name|ret
operator|+=
name|__popcount_tab
index|[
operator|(
name|x
operator|>>
name|i
operator|)
operator|&
literal|0xff
index|]
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_paritysi2
end_ifdef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_function
name|int
name|__paritySI2
parameter_list|(
name|UWtype
name|x
parameter_list|)
block|{
if|#
directive|if
name|W_TYPE_SIZE
operator|>
literal|64
error|#
directive|error
literal|"fill out the table"
endif|#
directive|endif
if|#
directive|if
name|W_TYPE_SIZE
operator|>
literal|32
name|x
operator|^=
name|x
operator|>>
literal|32
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|W_TYPE_SIZE
operator|>
literal|16
name|x
operator|^=
name|x
operator|>>
literal|16
expr_stmt|;
endif|#
directive|endif
name|x
operator|^=
name|x
operator|>>
literal|8
expr_stmt|;
name|x
operator|^=
name|x
operator|>>
literal|4
expr_stmt|;
name|x
operator|&=
literal|0xf
expr_stmt|;
return|return
operator|(
literal|0x6996
operator|>>
name|x
operator|)
operator|&
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_paritydi2
end_ifdef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_function
name|int
name|__parityDI2
parameter_list|(
name|UDWtype
name|x
parameter_list|)
block|{
specifier|const
name|DWunion
name|uu
init|=
block|{
operator|.
name|ll
operator|=
name|x
block|}
decl_stmt|;
name|UWtype
name|nx
init|=
name|uu
operator|.
name|s
operator|.
name|low
operator|^
name|uu
operator|.
name|s
operator|.
name|high
decl_stmt|;
if|#
directive|if
name|W_TYPE_SIZE
operator|>
literal|64
error|#
directive|error
literal|"fill out the table"
endif|#
directive|endif
if|#
directive|if
name|W_TYPE_SIZE
operator|>
literal|32
name|nx
operator|^=
name|nx
operator|>>
literal|32
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|W_TYPE_SIZE
operator|>
literal|16
name|nx
operator|^=
name|nx
operator|>>
literal|16
expr_stmt|;
endif|#
directive|endif
name|nx
operator|^=
name|nx
operator|>>
literal|8
expr_stmt|;
name|nx
operator|^=
name|nx
operator|>>
literal|4
expr_stmt|;
name|nx
operator|&=
literal|0xf
expr_stmt|;
return|return
operator|(
literal|0x6996
operator|>>
name|nx
operator|)
operator|&
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_udivmoddi4
end_ifdef

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|L_udivdi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divdi3
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|L_umoddi3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_moddi3
argument_list|)
operator|)
end_if

begin_expr_stmt
specifier|static
specifier|inline
name|__attribute__
argument_list|(
argument|(__always_inline__)
argument_list|)
endif|#
directive|endif
name|UDWtype
name|__udivmoddi4
argument_list|(
argument|UDWtype n
argument_list|,
argument|UDWtype d
argument_list|,
argument|UDWtype *rp
argument_list|)
block|{
specifier|const
name|DWunion
name|nn
operator|=
block|{
operator|.
name|ll
operator|=
name|n
block|}
block|;
specifier|const
name|DWunion
name|dd
operator|=
block|{
operator|.
name|ll
operator|=
name|d
block|}
block|;
name|DWunion
name|rr
block|;
name|UWtype
name|d0
block|,
name|d1
block|,
name|n0
block|,
name|n1
block|,
name|n2
block|;
name|UWtype
name|q0
block|,
name|q1
block|;
name|UWtype
name|b
block|,
name|bm
block|;
name|d0
operator|=
name|dd
operator|.
name|s
operator|.
name|low
block|;
name|d1
operator|=
name|dd
operator|.
name|s
operator|.
name|high
block|;
name|n0
operator|=
name|nn
operator|.
name|s
operator|.
name|low
block|;
name|n1
operator|=
name|nn
operator|.
name|s
operator|.
name|high
block|;
if|#
directive|if
operator|!
name|UDIV_NEEDS_NORMALIZATION
if|if
condition|(
name|d1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|d0
operator|>
name|n1
condition|)
block|{
comment|/* 0q = nn / 0D */
name|udiv_qrnnd
argument_list|(
name|q0
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|d0
argument_list|)
expr_stmt|;
name|q1
operator|=
literal|0
expr_stmt|;
comment|/* Remainder in n0.  */
block|}
end_expr_stmt

begin_else
else|else
block|{
comment|/* qq = NN / 0d */
if|if
condition|(
name|d0
operator|==
literal|0
condition|)
name|d0
operator|=
literal|1
operator|/
name|d0
expr_stmt|;
comment|/* Divide intentionally by zero.  */
name|udiv_qrnnd
argument_list|(
name|q1
argument_list|,
name|n1
argument_list|,
literal|0
argument_list|,
name|n1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
name|udiv_qrnnd
argument_list|(
name|q0
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|d0
argument_list|)
expr_stmt|;
comment|/* Remainder in n0.  */
block|}
end_else

begin_if
if|if
condition|(
name|rp
operator|!=
literal|0
condition|)
block|{
name|rr
operator|.
name|s
operator|.
name|low
operator|=
name|n0
expr_stmt|;
name|rr
operator|.
name|s
operator|.
name|high
operator|=
literal|0
expr_stmt|;
operator|*
name|rp
operator|=
name|rr
operator|.
name|ll
expr_stmt|;
block|}
end_if

begin_else
unit|}
else|#
directive|else
end_else

begin_comment
comment|/* UDIV_NEEDS_NORMALIZATION */
end_comment

begin_expr_stmt
unit|if
operator|(
name|d1
operator|==
literal|0
operator|)
block|{
if|if
condition|(
name|d0
operator|>
name|n1
condition|)
block|{
comment|/* 0q = nn / 0D */
name|count_leading_zeros
argument_list|(
name|bm
argument_list|,
name|d0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bm
operator|!=
literal|0
condition|)
block|{
comment|/* Normalize, i.e. make the most significant bit of the 		 denominator set.  */
name|d0
operator|=
name|d0
operator|<<
name|bm
expr_stmt|;
name|n1
operator|=
operator|(
name|n1
operator|<<
name|bm
operator|)
operator||
operator|(
name|n0
operator|>>
operator|(
name|W_TYPE_SIZE
operator|-
name|bm
operator|)
operator|)
expr_stmt|;
name|n0
operator|=
name|n0
operator|<<
name|bm
expr_stmt|;
block|}
name|udiv_qrnnd
argument_list|(
name|q0
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|d0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|q1
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Remainder in n0>> bm.  */
end_comment

begin_block
unit|}       else
block|{
comment|/* qq = NN / 0d */
if|if
condition|(
name|d0
operator|==
literal|0
condition|)
name|d0
operator|=
literal|1
operator|/
name|d0
expr_stmt|;
comment|/* Divide intentionally by zero.  */
name|count_leading_zeros
argument_list|(
name|bm
argument_list|,
name|d0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bm
operator|==
literal|0
condition|)
block|{
comment|/* From (n1>= d0) /\ (the most significant bit of d0 is set), 		 conclude (the most significant bit of n1 is set) /\ (the 		 leading quotient digit q1 = 1).  		 This special case is necessary, not an optimization. 		 (Shifts counts of W_TYPE_SIZE are undefined.)  */
name|n1
operator|-=
name|d0
expr_stmt|;
name|q1
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Normalize.  */
name|b
operator|=
name|W_TYPE_SIZE
operator|-
name|bm
expr_stmt|;
name|d0
operator|=
name|d0
operator|<<
name|bm
expr_stmt|;
name|n2
operator|=
name|n1
operator|>>
name|b
expr_stmt|;
name|n1
operator|=
operator|(
name|n1
operator|<<
name|bm
operator|)
operator||
operator|(
name|n0
operator|>>
name|b
operator|)
expr_stmt|;
name|n0
operator|=
name|n0
operator|<<
name|bm
expr_stmt|;
name|udiv_qrnnd
argument_list|(
name|q1
argument_list|,
name|n1
argument_list|,
name|n2
argument_list|,
name|n1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
block|}
comment|/* n1 != d0...  */
name|udiv_qrnnd
argument_list|(
name|q0
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|d0
argument_list|)
expr_stmt|;
comment|/* Remainder in n0>> bm.  */
block|}
end_block

begin_if
if|if
condition|(
name|rp
operator|!=
literal|0
condition|)
block|{
name|rr
operator|.
name|s
operator|.
name|low
operator|=
name|n0
operator|>>
name|bm
expr_stmt|;
name|rr
operator|.
name|s
operator|.
name|high
operator|=
literal|0
expr_stmt|;
operator|*
name|rp
operator|=
name|rr
operator|.
name|ll
expr_stmt|;
block|}
end_if

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* UDIV_NEEDS_NORMALIZATION */
end_comment

begin_block
unit|else
block|{
if|if
condition|(
name|d1
operator|>
name|n1
condition|)
block|{
comment|/* 00 = nn / DD */
name|q0
operator|=
literal|0
expr_stmt|;
name|q1
operator|=
literal|0
expr_stmt|;
comment|/* Remainder in n1n0.  */
if|if
condition|(
name|rp
operator|!=
literal|0
condition|)
block|{
name|rr
operator|.
name|s
operator|.
name|low
operator|=
name|n0
expr_stmt|;
name|rr
operator|.
name|s
operator|.
name|high
operator|=
name|n1
expr_stmt|;
operator|*
name|rp
operator|=
name|rr
operator|.
name|ll
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 0q = NN / dd */
name|count_leading_zeros
argument_list|(
name|bm
argument_list|,
name|d1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bm
operator|==
literal|0
condition|)
block|{
comment|/* From (n1>= d1) /\ (the most significant bit of d1 is set), 		 conclude (the most significant bit of n1 is set) /\ (the 		 quotient digit q0 = 0 or 1).  		 This special case is necessary, not an optimization.  */
comment|/* The condition on the next line takes advantage of that 		 n1>= d1 (true due to program flow).  */
if|if
condition|(
name|n1
operator|>
name|d1
operator|||
name|n0
operator|>=
name|d0
condition|)
block|{
name|q0
operator|=
literal|1
expr_stmt|;
name|sub_ddmmss
argument_list|(
name|n1
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|d1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
block|}
else|else
name|q0
operator|=
literal|0
expr_stmt|;
name|q1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rp
operator|!=
literal|0
condition|)
block|{
name|rr
operator|.
name|s
operator|.
name|low
operator|=
name|n0
expr_stmt|;
name|rr
operator|.
name|s
operator|.
name|high
operator|=
name|n1
expr_stmt|;
operator|*
name|rp
operator|=
name|rr
operator|.
name|ll
expr_stmt|;
block|}
block|}
else|else
block|{
name|UWtype
name|m1
decl_stmt|,
name|m0
decl_stmt|;
comment|/* Normalize.  */
name|b
operator|=
name|W_TYPE_SIZE
operator|-
name|bm
expr_stmt|;
name|d1
operator|=
operator|(
name|d1
operator|<<
name|bm
operator|)
operator||
operator|(
name|d0
operator|>>
name|b
operator|)
expr_stmt|;
name|d0
operator|=
name|d0
operator|<<
name|bm
expr_stmt|;
name|n2
operator|=
name|n1
operator|>>
name|b
expr_stmt|;
name|n1
operator|=
operator|(
name|n1
operator|<<
name|bm
operator|)
operator||
operator|(
name|n0
operator|>>
name|b
operator|)
expr_stmt|;
name|n0
operator|=
name|n0
operator|<<
name|bm
expr_stmt|;
name|udiv_qrnnd
argument_list|(
name|q0
argument_list|,
name|n1
argument_list|,
name|n2
argument_list|,
name|n1
argument_list|,
name|d1
argument_list|)
expr_stmt|;
name|umul_ppmm
argument_list|(
name|m1
argument_list|,
name|m0
argument_list|,
name|q0
argument_list|,
name|d0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|>
name|n1
operator|||
operator|(
name|m1
operator|==
name|n1
operator|&&
name|m0
operator|>
name|n0
operator|)
condition|)
block|{
name|q0
operator|--
expr_stmt|;
name|sub_ddmmss
argument_list|(
name|m1
argument_list|,
name|m0
argument_list|,
name|m1
argument_list|,
name|m0
argument_list|,
name|d1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
block|}
name|q1
operator|=
literal|0
expr_stmt|;
comment|/* Remainder in (n1n0 - m1m0)>> bm.  */
if|if
condition|(
name|rp
operator|!=
literal|0
condition|)
block|{
name|sub_ddmmss
argument_list|(
name|n1
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|m1
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|rr
operator|.
name|s
operator|.
name|low
operator|=
operator|(
name|n1
operator|<<
name|b
operator|)
operator||
operator|(
name|n0
operator|>>
name|bm
operator|)
expr_stmt|;
name|rr
operator|.
name|s
operator|.
name|high
operator|=
name|n1
operator|>>
name|bm
expr_stmt|;
operator|*
name|rp
operator|=
name|rr
operator|.
name|ll
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_decl_stmt
specifier|const
name|DWunion
name|ww
init|=
block|{
block|{
operator|.
name|low
operator|=
name|q0
block|,
operator|.
name|high
operator|=
name|q1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|ww
operator|.
name|ll
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_divdi3
end_ifdef

begin_macro
unit|DWtype
name|__divdi3
argument_list|(
argument|DWtype u
argument_list|,
argument|DWtype v
argument_list|)
end_macro

begin_block
block|{
name|word_type
name|c
init|=
literal|0
decl_stmt|;
name|DWunion
name|uu
init|=
block|{
operator|.
name|ll
operator|=
name|u
block|}
decl_stmt|;
name|DWunion
name|vv
init|=
block|{
operator|.
name|ll
operator|=
name|v
block|}
decl_stmt|;
name|DWtype
name|w
decl_stmt|;
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|high
operator|<
literal|0
condition|)
name|c
operator|=
operator|~
name|c
operator|,
name|uu
operator|.
name|ll
operator|=
operator|-
name|uu
operator|.
name|ll
expr_stmt|;
if|if
condition|(
name|vv
operator|.
name|s
operator|.
name|high
operator|<
literal|0
condition|)
name|c
operator|=
operator|~
name|c
operator|,
name|vv
operator|.
name|ll
operator|=
operator|-
name|vv
operator|.
name|ll
expr_stmt|;
name|w
operator|=
name|__udivmoddi4
argument_list|(
name|uu
operator|.
name|ll
argument_list|,
name|vv
operator|.
name|ll
argument_list|,
operator|(
name|UDWtype
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|w
operator|=
operator|-
name|w
expr_stmt|;
return|return
name|w
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_moddi3
end_ifdef

begin_function
name|DWtype
name|__moddi3
parameter_list|(
name|DWtype
name|u
parameter_list|,
name|DWtype
name|v
parameter_list|)
block|{
name|word_type
name|c
init|=
literal|0
decl_stmt|;
name|DWunion
name|uu
init|=
block|{
operator|.
name|ll
operator|=
name|u
block|}
decl_stmt|;
name|DWunion
name|vv
init|=
block|{
operator|.
name|ll
operator|=
name|v
block|}
decl_stmt|;
name|DWtype
name|w
decl_stmt|;
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|high
operator|<
literal|0
condition|)
name|c
operator|=
operator|~
name|c
operator|,
name|uu
operator|.
name|ll
operator|=
operator|-
name|uu
operator|.
name|ll
expr_stmt|;
if|if
condition|(
name|vv
operator|.
name|s
operator|.
name|high
operator|<
literal|0
condition|)
name|vv
operator|.
name|ll
operator|=
operator|-
name|vv
operator|.
name|ll
expr_stmt|;
operator|(
name|void
operator|)
name|__udivmoddi4
argument_list|(
name|uu
operator|.
name|ll
argument_list|,
name|vv
operator|.
name|ll
argument_list|,
operator|(
name|UDWtype
operator|*
operator|)
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|w
operator|=
operator|-
name|w
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_umoddi3
end_ifdef

begin_function
name|UDWtype
name|__umoddi3
parameter_list|(
name|UDWtype
name|u
parameter_list|,
name|UDWtype
name|v
parameter_list|)
block|{
name|UDWtype
name|w
decl_stmt|;
operator|(
name|void
operator|)
name|__udivmoddi4
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_udivdi3
end_ifdef

begin_function
name|UDWtype
name|__udivdi3
parameter_list|(
name|UDWtype
name|n
parameter_list|,
name|UDWtype
name|d
parameter_list|)
block|{
return|return
name|__udivmoddi4
argument_list|(
name|n
argument_list|,
name|d
argument_list|,
operator|(
name|UDWtype
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_cmpdi2
end_ifdef

begin_function
name|word_type
name|__cmpdi2
parameter_list|(
name|DWtype
name|a
parameter_list|,
name|DWtype
name|b
parameter_list|)
block|{
specifier|const
name|DWunion
name|au
init|=
block|{
operator|.
name|ll
operator|=
name|a
block|}
decl_stmt|;
specifier|const
name|DWunion
name|bu
init|=
block|{
operator|.
name|ll
operator|=
name|b
block|}
decl_stmt|;
if|if
condition|(
name|au
operator|.
name|s
operator|.
name|high
operator|<
name|bu
operator|.
name|s
operator|.
name|high
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|au
operator|.
name|s
operator|.
name|high
operator|>
name|bu
operator|.
name|s
operator|.
name|high
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|(
name|UWtype
operator|)
name|au
operator|.
name|s
operator|.
name|low
operator|<
operator|(
name|UWtype
operator|)
name|bu
operator|.
name|s
operator|.
name|low
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|UWtype
operator|)
name|au
operator|.
name|s
operator|.
name|low
operator|>
operator|(
name|UWtype
operator|)
name|bu
operator|.
name|s
operator|.
name|low
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_ucmpdi2
end_ifdef

begin_function
name|word_type
name|__ucmpdi2
parameter_list|(
name|DWtype
name|a
parameter_list|,
name|DWtype
name|b
parameter_list|)
block|{
specifier|const
name|DWunion
name|au
init|=
block|{
operator|.
name|ll
operator|=
name|a
block|}
decl_stmt|;
specifier|const
name|DWunion
name|bu
init|=
block|{
operator|.
name|ll
operator|=
name|b
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|UWtype
operator|)
name|au
operator|.
name|s
operator|.
name|high
operator|<
operator|(
name|UWtype
operator|)
name|bu
operator|.
name|s
operator|.
name|high
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|UWtype
operator|)
name|au
operator|.
name|s
operator|.
name|high
operator|>
operator|(
name|UWtype
operator|)
name|bu
operator|.
name|s
operator|.
name|high
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|(
name|UWtype
operator|)
name|au
operator|.
name|s
operator|.
name|low
operator|<
operator|(
name|UWtype
operator|)
name|bu
operator|.
name|s
operator|.
name|low
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|UWtype
operator|)
name|au
operator|.
name|s
operator|.
name|low
operator|>
operator|(
name|UWtype
operator|)
name|bu
operator|.
name|s
operator|.
name|low
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixunstfdi
argument_list|)
operator|&&
name|LIBGCC2_HAS_TF_MODE
end_if

begin_function
name|DWtype
name|__fixunstfDI
parameter_list|(
name|TFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Compute high word of result, as a flonum.  */
specifier|const
name|TFtype
name|b
init|=
operator|(
name|a
operator|/
name|Wtype_MAXp1_F
operator|)
decl_stmt|;
comment|/* Convert that to fixed (but not to DWtype!),      and shift it into the high word.  */
name|UDWtype
name|v
init|=
operator|(
name|UWtype
operator|)
name|b
decl_stmt|;
name|v
operator|<<=
name|W_TYPE_SIZE
expr_stmt|;
comment|/* Remove high part from the TFtype, leaving the low part as flonum.  */
name|a
operator|-=
operator|(
name|TFtype
operator|)
name|v
expr_stmt|;
comment|/* Convert that to fixed (but not to DWtype!) and add it in.      Sometimes A comes out negative.  This is significant, since      A has more bits than a long int does.  */
if|if
condition|(
name|a
operator|<
literal|0
condition|)
name|v
operator|-=
call|(
name|UWtype
call|)
argument_list|(
operator|-
name|a
argument_list|)
expr_stmt|;
else|else
name|v
operator|+=
operator|(
name|UWtype
operator|)
name|a
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixtfdi
argument_list|)
operator|&&
name|LIBGCC2_HAS_TF_MODE
end_if

begin_function
name|DWtype
name|__fixtfdi
parameter_list|(
name|TFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
operator|-
name|__fixunstfDI
argument_list|(
operator|-
name|a
argument_list|)
return|;
return|return
name|__fixunstfDI
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixunsxfdi
argument_list|)
operator|&&
name|LIBGCC2_HAS_XF_MODE
end_if

begin_function
name|DWtype
name|__fixunsxfDI
parameter_list|(
name|XFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Compute high word of result, as a flonum.  */
specifier|const
name|XFtype
name|b
init|=
operator|(
name|a
operator|/
name|Wtype_MAXp1_F
operator|)
decl_stmt|;
comment|/* Convert that to fixed (but not to DWtype!),      and shift it into the high word.  */
name|UDWtype
name|v
init|=
operator|(
name|UWtype
operator|)
name|b
decl_stmt|;
name|v
operator|<<=
name|W_TYPE_SIZE
expr_stmt|;
comment|/* Remove high part from the XFtype, leaving the low part as flonum.  */
name|a
operator|-=
operator|(
name|XFtype
operator|)
name|v
expr_stmt|;
comment|/* Convert that to fixed (but not to DWtype!) and add it in.      Sometimes A comes out negative.  This is significant, since      A has more bits than a long int does.  */
if|if
condition|(
name|a
operator|<
literal|0
condition|)
name|v
operator|-=
call|(
name|UWtype
call|)
argument_list|(
operator|-
name|a
argument_list|)
expr_stmt|;
else|else
name|v
operator|+=
operator|(
name|UWtype
operator|)
name|a
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixxfdi
argument_list|)
operator|&&
name|LIBGCC2_HAS_XF_MODE
end_if

begin_function
name|DWtype
name|__fixxfdi
parameter_list|(
name|XFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
operator|-
name|__fixunsxfDI
argument_list|(
operator|-
name|a
argument_list|)
return|;
return|return
name|__fixunsxfDI
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixunsdfdi
argument_list|)
operator|&&
name|LIBGCC2_HAS_DF_MODE
end_if

begin_function
name|DWtype
name|__fixunsdfDI
parameter_list|(
name|DFtype
name|a
parameter_list|)
block|{
comment|/* Get high part of result.  The division here will just moves the radix      point and will not cause any rounding.  Then the conversion to integral      type chops result as desired.  */
specifier|const
name|UWtype
name|hi
init|=
name|a
operator|/
name|Wtype_MAXp1_F
decl_stmt|;
comment|/* Get low part of result.  Convert `hi' to floating type and scale it back,      then subtract this from the number being converted.  This leaves the low      part.  Convert that to integral type.  */
specifier|const
name|UWtype
name|lo
init|=
name|a
operator|-
operator|(
name|DFtype
operator|)
name|hi
operator|*
name|Wtype_MAXp1_F
decl_stmt|;
comment|/* Assemble result from the two parts.  */
return|return
operator|(
operator|(
name|UDWtype
operator|)
name|hi
operator|<<
name|W_TYPE_SIZE
operator|)
operator||
name|lo
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixdfdi
argument_list|)
operator|&&
name|LIBGCC2_HAS_DF_MODE
end_if

begin_function
name|DWtype
name|__fixdfdi
parameter_list|(
name|DFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
operator|-
name|__fixunsdfDI
argument_list|(
operator|-
name|a
argument_list|)
return|;
return|return
name|__fixunsdfDI
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixunssfdi
argument_list|)
operator|&&
name|LIBGCC2_HAS_SF_MODE
end_if

begin_function
name|DWtype
name|__fixunssfDI
parameter_list|(
name|SFtype
name|a
parameter_list|)
block|{
if|#
directive|if
name|LIBGCC2_HAS_DF_MODE
comment|/* Convert the SFtype to a DFtype, because that is surely not going      to lose any bits.  Some day someone else can write a faster version      that avoids converting to DFtype, and verify it really works right.  */
specifier|const
name|DFtype
name|dfa
init|=
name|a
decl_stmt|;
comment|/* Get high part of result.  The division here will just moves the radix      point and will not cause any rounding.  Then the conversion to integral      type chops result as desired.  */
specifier|const
name|UWtype
name|hi
init|=
name|dfa
operator|/
name|Wtype_MAXp1_F
decl_stmt|;
comment|/* Get low part of result.  Convert `hi' to floating type and scale it back,      then subtract this from the number being converted.  This leaves the low      part.  Convert that to integral type.  */
specifier|const
name|UWtype
name|lo
init|=
name|dfa
operator|-
operator|(
name|DFtype
operator|)
name|hi
operator|*
name|Wtype_MAXp1_F
decl_stmt|;
comment|/* Assemble result from the two parts.  */
return|return
operator|(
operator|(
name|UDWtype
operator|)
name|hi
operator|<<
name|W_TYPE_SIZE
operator|)
operator||
name|lo
return|;
elif|#
directive|elif
name|FLT_MANT_DIG
operator|<
name|W_TYPE_SIZE
if|if
condition|(
name|a
operator|<
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|a
operator|<
name|Wtype_MAXp1_F
condition|)
return|return
operator|(
name|UWtype
operator|)
name|a
return|;
if|if
condition|(
name|a
operator|<
name|Wtype_MAXp1_F
operator|*
name|Wtype_MAXp1_F
condition|)
block|{
comment|/* Since we know that there are fewer significant bits in the SFmode 	 quantity than in a word, we know that we can convert out all the 	 significant bits in one step, and thus avoid losing bits.  */
comment|/* ??? This following loop essentially performs frexpf.  If we could 	 use the real libm function, or poke at the actual bits of the fp 	 format, it would be significantly faster.  */
name|UWtype
name|shift
init|=
literal|0
decl_stmt|,
name|counter
decl_stmt|;
name|SFtype
name|msb
decl_stmt|;
name|a
operator|/=
name|Wtype_MAXp1_F
expr_stmt|;
for|for
control|(
name|counter
operator|=
name|W_TYPE_SIZE
operator|/
literal|2
init|;
name|counter
operator|!=
literal|0
condition|;
name|counter
operator|>>=
literal|1
control|)
block|{
name|SFtype
name|counterf
init|=
operator|(
name|UWtype
operator|)
literal|1
operator|<<
name|counter
decl_stmt|;
if|if
condition|(
name|a
operator|>=
name|counterf
condition|)
block|{
name|shift
operator||=
name|counter
expr_stmt|;
name|a
operator|/=
name|counterf
expr_stmt|;
block|}
block|}
comment|/* Rescale into the range of one word, extract the bits of that 	 one word, and shift the result into position.  */
name|a
operator|*=
name|Wtype_MAXp1_F
expr_stmt|;
name|counter
operator|=
name|a
expr_stmt|;
return|return
operator|(
name|DWtype
operator|)
name|counter
operator|<<
name|shift
return|;
block|}
return|return
operator|-
literal|1
return|;
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixsfdi
argument_list|)
operator|&&
name|LIBGCC2_HAS_SF_MODE
end_if

begin_function
name|DWtype
name|__fixsfdi
parameter_list|(
name|SFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
operator|-
name|__fixunssfDI
argument_list|(
operator|-
name|a
argument_list|)
return|;
return|return
name|__fixunssfDI
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_floatdixf
argument_list|)
operator|&&
name|LIBGCC2_HAS_XF_MODE
end_if

begin_function
name|XFtype
name|__floatdixf
parameter_list|(
name|DWtype
name|u
parameter_list|)
block|{
if|#
directive|if
name|W_TYPE_SIZE
operator|>
name|XF_SIZE
error|#
directive|error
endif|#
directive|endif
name|XFtype
name|d
init|=
call|(
name|Wtype
call|)
argument_list|(
name|u
operator|>>
name|W_TYPE_SIZE
argument_list|)
decl_stmt|;
name|d
operator|*=
name|Wtype_MAXp1_F
expr_stmt|;
name|d
operator|+=
operator|(
name|UWtype
operator|)
name|u
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_floatundixf
argument_list|)
operator|&&
name|LIBGCC2_HAS_XF_MODE
end_if

begin_function
name|XFtype
name|__floatundixf
parameter_list|(
name|UDWtype
name|u
parameter_list|)
block|{
if|#
directive|if
name|W_TYPE_SIZE
operator|>
name|XF_SIZE
error|#
directive|error
endif|#
directive|endif
name|XFtype
name|d
init|=
call|(
name|UWtype
call|)
argument_list|(
name|u
operator|>>
name|W_TYPE_SIZE
argument_list|)
decl_stmt|;
name|d
operator|*=
name|Wtype_MAXp1_F
expr_stmt|;
name|d
operator|+=
operator|(
name|UWtype
operator|)
name|u
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_floatditf
argument_list|)
operator|&&
name|LIBGCC2_HAS_TF_MODE
end_if

begin_function
name|TFtype
name|__floatditf
parameter_list|(
name|DWtype
name|u
parameter_list|)
block|{
if|#
directive|if
name|W_TYPE_SIZE
operator|>
name|TF_SIZE
error|#
directive|error
endif|#
directive|endif
name|TFtype
name|d
init|=
call|(
name|Wtype
call|)
argument_list|(
name|u
operator|>>
name|W_TYPE_SIZE
argument_list|)
decl_stmt|;
name|d
operator|*=
name|Wtype_MAXp1_F
expr_stmt|;
name|d
operator|+=
operator|(
name|UWtype
operator|)
name|u
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_floatunditf
argument_list|)
operator|&&
name|LIBGCC2_HAS_TF_MODE
end_if

begin_function
name|TFtype
name|__floatunditf
parameter_list|(
name|UDWtype
name|u
parameter_list|)
block|{
if|#
directive|if
name|W_TYPE_SIZE
operator|>
name|TF_SIZE
error|#
directive|error
endif|#
directive|endif
name|TFtype
name|d
init|=
call|(
name|UWtype
call|)
argument_list|(
name|u
operator|>>
name|W_TYPE_SIZE
argument_list|)
decl_stmt|;
name|d
operator|*=
name|Wtype_MAXp1_F
expr_stmt|;
name|d
operator|+=
operator|(
name|UWtype
operator|)
name|u
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|L_floatdisf
argument_list|)
operator|&&
name|LIBGCC2_HAS_SF_MODE
operator|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|L_floatdidf
argument_list|)
operator|&&
name|LIBGCC2_HAS_DF_MODE
operator|)
end_if

begin_define
define|#
directive|define
name|DI_SIZE
value|(W_TYPE_SIZE * 2)
end_define

begin_define
define|#
directive|define
name|F_MODE_OK
parameter_list|(
name|SIZE
parameter_list|)
define|\
value|(SIZE< DI_SIZE							\&& SIZE> (DI_SIZE - SIZE + FSSIZE)					\
comment|/* Don't use IBM Extended Double TFmode for TI->SF calculations.	\       The conversion from long double to float suffers from double	\       rounding, because we convert via double.  In any case, the	\       fallback code is faster.  */
value|\&& !IS_IBM_EXTENDED (SIZE))
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_floatdisf
argument_list|)
end_if

begin_define
define|#
directive|define
name|FUNC
value|__floatdisf
end_define

begin_define
define|#
directive|define
name|FSTYPE
value|SFtype
end_define

begin_define
define|#
directive|define
name|FSSIZE
value|SF_SIZE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FUNC
value|__floatdidf
end_define

begin_define
define|#
directive|define
name|FSTYPE
value|DFtype
end_define

begin_define
define|#
directive|define
name|FSSIZE
value|DF_SIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|FSTYPE
name|FUNC
parameter_list|(
name|DWtype
name|u
parameter_list|)
block|{
if|#
directive|if
name|FSSIZE
operator|>=
name|W_TYPE_SIZE
comment|/* When the word size is small, we never get any rounding error.  */
name|FSTYPE
name|f
init|=
call|(
name|Wtype
call|)
argument_list|(
name|u
operator|>>
name|W_TYPE_SIZE
argument_list|)
decl_stmt|;
name|f
operator|*=
name|Wtype_MAXp1_F
expr_stmt|;
name|f
operator|+=
operator|(
name|UWtype
operator|)
name|u
expr_stmt|;
return|return
name|f
return|;
elif|#
directive|elif
operator|(
name|LIBGCC2_HAS_DF_MODE
operator|&&
name|F_MODE_OK
argument_list|(
name|DF_SIZE
argument_list|)
operator|)
expr|\
operator|||
operator|(
name|LIBGCC2_HAS_XF_MODE
operator|&&
name|F_MODE_OK
argument_list|(
name|XF_SIZE
argument_list|)
operator|)
expr|\
operator|||
operator|(
name|LIBGCC2_HAS_TF_MODE
operator|&&
name|F_MODE_OK
argument_list|(
name|TF_SIZE
argument_list|)
operator|)
if|#
directive|if
operator|(
name|LIBGCC2_HAS_DF_MODE
operator|&&
name|F_MODE_OK
argument_list|(
name|DF_SIZE
argument_list|)
operator|)
define|#
directive|define
name|FSIZE
value|DF_SIZE
define|#
directive|define
name|FTYPE
value|DFtype
elif|#
directive|elif
operator|(
name|LIBGCC2_HAS_XF_MODE
operator|&&
name|F_MODE_OK
argument_list|(
name|XF_SIZE
argument_list|)
operator|)
define|#
directive|define
name|FSIZE
value|XF_SIZE
define|#
directive|define
name|FTYPE
value|XFtype
elif|#
directive|elif
operator|(
name|LIBGCC2_HAS_TF_MODE
operator|&&
name|F_MODE_OK
argument_list|(
name|TF_SIZE
argument_list|)
operator|)
define|#
directive|define
name|FSIZE
value|TF_SIZE
define|#
directive|define
name|FTYPE
value|TFtype
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
define|#
directive|define
name|REP_BIT
value|((UDWtype) 1<< (DI_SIZE - FSIZE))
comment|/* Protect against double-rounding error.      Represent any low-order bits, that might be truncated by a bit that      won't be lost.  The bit can go in anywhere below the rounding position      of the FSTYPE.  A fixed mask and bit position handles all usual      configurations.  */
if|if
condition|(
operator|!
operator|(
operator|-
operator|(
operator|(
name|DWtype
operator|)
literal|1
operator|<<
name|FSIZE
operator|)
operator|<
name|u
operator|&&
name|u
operator|<
operator|(
operator|(
name|DWtype
operator|)
literal|1
operator|<<
name|FSIZE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|UDWtype
operator|)
name|u
operator|&
operator|(
name|REP_BIT
operator|-
literal|1
operator|)
condition|)
block|{
name|u
operator|&=
operator|~
operator|(
name|REP_BIT
operator|-
literal|1
operator|)
expr_stmt|;
name|u
operator||=
name|REP_BIT
expr_stmt|;
block|}
block|}
comment|/* Do the calculation in a wider type so that we don't lose any of      the precision of the high word while multiplying it.  */
name|FTYPE
name|f
init|=
call|(
name|Wtype
call|)
argument_list|(
name|u
operator|>>
name|W_TYPE_SIZE
argument_list|)
decl_stmt|;
name|f
operator|*=
name|Wtype_MAXp1_F
expr_stmt|;
name|f
operator|+=
operator|(
name|UWtype
operator|)
name|u
expr_stmt|;
return|return
operator|(
name|FSTYPE
operator|)
name|f
return|;
else|#
directive|else
if|#
directive|if
name|FSSIZE
operator|>=
name|W_TYPE_SIZE
operator|-
literal|2
error|#
directive|error
endif|#
directive|endif
comment|/* Finally, the word size is larger than the number of bits in the      required FSTYPE, and we've got no suitable wider type.  The only      way to avoid double rounding is to special case the      extraction.  */
comment|/* If there are no high bits set, fall back to one conversion.  */
if|if
condition|(
operator|(
name|Wtype
operator|)
name|u
operator|==
name|u
condition|)
return|return
operator|(
name|FSTYPE
operator|)
operator|(
name|Wtype
operator|)
name|u
return|;
comment|/* Otherwise, find the power of two.  */
name|Wtype
name|hi
init|=
name|u
operator|>>
name|W_TYPE_SIZE
decl_stmt|;
if|if
condition|(
name|hi
operator|<
literal|0
condition|)
name|hi
operator|=
operator|-
name|hi
expr_stmt|;
name|UWtype
name|count
decl_stmt|,
name|shift
decl_stmt|;
name|count_leading_zeros
argument_list|(
name|count
argument_list|,
name|hi
argument_list|)
expr_stmt|;
comment|/* No leading bits means u == minimum.  */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|-
operator|(
name|Wtype_MAXp1_F
operator|*
operator|(
name|Wtype_MAXp1_F
operator|/
literal|2
operator|)
operator|)
return|;
name|shift
operator|=
literal|1
operator|+
name|W_TYPE_SIZE
operator|-
name|count
expr_stmt|;
comment|/* Shift down the most significant bits.  */
name|hi
operator|=
name|u
operator|>>
name|shift
expr_stmt|;
comment|/* If we lost any nonzero bits, set the lsb to ensure correct rounding.  */
if|if
condition|(
name|u
operator|&
operator|(
operator|(
operator|(
name|DWtype
operator|)
literal|1
operator|<<
name|shift
operator|)
operator|-
literal|1
operator|)
condition|)
name|hi
operator||=
literal|1
expr_stmt|;
comment|/* Convert the one word of data, and rescale.  */
name|FSTYPE
name|f
init|=
name|hi
decl_stmt|;
name|f
operator|*=
operator|(
name|UDWtype
operator|)
literal|1
operator|<<
name|shift
expr_stmt|;
return|return
name|f
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|L_floatundisf
argument_list|)
operator|&&
name|LIBGCC2_HAS_SF_MODE
operator|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|L_floatundidf
argument_list|)
operator|&&
name|LIBGCC2_HAS_DF_MODE
operator|)
end_if

begin_define
define|#
directive|define
name|DI_SIZE
value|(W_TYPE_SIZE * 2)
end_define

begin_define
define|#
directive|define
name|F_MODE_OK
parameter_list|(
name|SIZE
parameter_list|)
define|\
value|(SIZE< DI_SIZE							\&& SIZE> (DI_SIZE - SIZE + FSSIZE)					\
comment|/* Don't use IBM Extended Double TFmode for TI->SF calculations.	\       The conversion from long double to float suffers from double	\       rounding, because we convert via double.  In any case, the	\       fallback code is faster.  */
value|\&& !IS_IBM_EXTENDED (SIZE))
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_floatundisf
argument_list|)
end_if

begin_define
define|#
directive|define
name|FUNC
value|__floatundisf
end_define

begin_define
define|#
directive|define
name|FSTYPE
value|SFtype
end_define

begin_define
define|#
directive|define
name|FSSIZE
value|SF_SIZE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FUNC
value|__floatundidf
end_define

begin_define
define|#
directive|define
name|FSTYPE
value|DFtype
end_define

begin_define
define|#
directive|define
name|FSSIZE
value|DF_SIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|FSTYPE
name|FUNC
parameter_list|(
name|UDWtype
name|u
parameter_list|)
block|{
if|#
directive|if
name|FSSIZE
operator|>=
name|W_TYPE_SIZE
comment|/* When the word size is small, we never get any rounding error.  */
name|FSTYPE
name|f
init|=
call|(
name|UWtype
call|)
argument_list|(
name|u
operator|>>
name|W_TYPE_SIZE
argument_list|)
decl_stmt|;
name|f
operator|*=
name|Wtype_MAXp1_F
expr_stmt|;
name|f
operator|+=
operator|(
name|UWtype
operator|)
name|u
expr_stmt|;
return|return
name|f
return|;
elif|#
directive|elif
operator|(
name|LIBGCC2_HAS_DF_MODE
operator|&&
name|F_MODE_OK
argument_list|(
name|DF_SIZE
argument_list|)
operator|)
expr|\
operator|||
operator|(
name|LIBGCC2_HAS_XF_MODE
operator|&&
name|F_MODE_OK
argument_list|(
name|XF_SIZE
argument_list|)
operator|)
expr|\
operator|||
operator|(
name|LIBGCC2_HAS_TF_MODE
operator|&&
name|F_MODE_OK
argument_list|(
name|TF_SIZE
argument_list|)
operator|)
if|#
directive|if
operator|(
name|LIBGCC2_HAS_DF_MODE
operator|&&
name|F_MODE_OK
argument_list|(
name|DF_SIZE
argument_list|)
operator|)
define|#
directive|define
name|FSIZE
value|DF_SIZE
define|#
directive|define
name|FTYPE
value|DFtype
elif|#
directive|elif
operator|(
name|LIBGCC2_HAS_XF_MODE
operator|&&
name|F_MODE_OK
argument_list|(
name|XF_SIZE
argument_list|)
operator|)
define|#
directive|define
name|FSIZE
value|XF_SIZE
define|#
directive|define
name|FTYPE
value|XFtype
elif|#
directive|elif
operator|(
name|LIBGCC2_HAS_TF_MODE
operator|&&
name|F_MODE_OK
argument_list|(
name|TF_SIZE
argument_list|)
operator|)
define|#
directive|define
name|FSIZE
value|TF_SIZE
define|#
directive|define
name|FTYPE
value|TFtype
else|#
directive|else
error|#
directive|error
endif|#
directive|endif
define|#
directive|define
name|REP_BIT
value|((UDWtype) 1<< (DI_SIZE - FSIZE))
comment|/* Protect against double-rounding error.      Represent any low-order bits, that might be truncated by a bit that      won't be lost.  The bit can go in anywhere below the rounding position      of the FSTYPE.  A fixed mask and bit position handles all usual      configurations.  */
if|if
condition|(
name|u
operator|>=
operator|(
operator|(
name|UDWtype
operator|)
literal|1
operator|<<
name|FSIZE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|UDWtype
operator|)
name|u
operator|&
operator|(
name|REP_BIT
operator|-
literal|1
operator|)
condition|)
block|{
name|u
operator|&=
operator|~
operator|(
name|REP_BIT
operator|-
literal|1
operator|)
expr_stmt|;
name|u
operator||=
name|REP_BIT
expr_stmt|;
block|}
block|}
comment|/* Do the calculation in a wider type so that we don't lose any of      the precision of the high word while multiplying it.  */
name|FTYPE
name|f
init|=
call|(
name|UWtype
call|)
argument_list|(
name|u
operator|>>
name|W_TYPE_SIZE
argument_list|)
decl_stmt|;
name|f
operator|*=
name|Wtype_MAXp1_F
expr_stmt|;
name|f
operator|+=
operator|(
name|UWtype
operator|)
name|u
expr_stmt|;
return|return
operator|(
name|FSTYPE
operator|)
name|f
return|;
else|#
directive|else
if|#
directive|if
name|FSSIZE
operator|==
name|W_TYPE_SIZE
operator|-
literal|1
error|#
directive|error
endif|#
directive|endif
comment|/* Finally, the word size is larger than the number of bits in the      required FSTYPE, and we've got no suitable wider type.  The only      way to avoid double rounding is to special case the      extraction.  */
comment|/* If there are no high bits set, fall back to one conversion.  */
if|if
condition|(
operator|(
name|UWtype
operator|)
name|u
operator|==
name|u
condition|)
return|return
operator|(
name|FSTYPE
operator|)
operator|(
name|UWtype
operator|)
name|u
return|;
comment|/* Otherwise, find the power of two.  */
name|UWtype
name|hi
init|=
name|u
operator|>>
name|W_TYPE_SIZE
decl_stmt|;
name|UWtype
name|count
decl_stmt|,
name|shift
decl_stmt|;
name|count_leading_zeros
argument_list|(
name|count
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|shift
operator|=
name|W_TYPE_SIZE
operator|-
name|count
expr_stmt|;
comment|/* Shift down the most significant bits.  */
name|hi
operator|=
name|u
operator|>>
name|shift
expr_stmt|;
comment|/* If we lost any nonzero bits, set the lsb to ensure correct rounding.  */
if|if
condition|(
name|u
operator|&
operator|(
operator|(
operator|(
name|UDWtype
operator|)
literal|1
operator|<<
name|shift
operator|)
operator|-
literal|1
operator|)
condition|)
name|hi
operator||=
literal|1
expr_stmt|;
comment|/* Convert the one word of data, and rescale.  */
name|FSTYPE
name|f
init|=
name|hi
decl_stmt|;
name|f
operator|*=
operator|(
name|UDWtype
operator|)
literal|1
operator|<<
name|shift
expr_stmt|;
return|return
name|f
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixunsxfsi
argument_list|)
operator|&&
name|LIBGCC2_HAS_XF_MODE
end_if

begin_comment
comment|/* Reenable the normal types, in case limits.h needs them.  */
end_comment

begin_undef
undef|#
directive|undef
name|char
end_undef

begin_undef
undef|#
directive|undef
name|short
end_undef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_undef
undef|#
directive|undef
name|long
end_undef

begin_undef
undef|#
directive|undef
name|unsigned
end_undef

begin_undef
undef|#
directive|undef
name|float
end_undef

begin_undef
undef|#
directive|undef
name|double
end_undef

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_function
name|UWtype
name|__fixunsxfSI
parameter_list|(
name|XFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|>=
operator|-
operator|(
name|DFtype
operator|)
name|Wtype_MIN
condition|)
return|return
call|(
name|Wtype
call|)
argument_list|(
name|a
operator|+
name|Wtype_MIN
argument_list|)
operator|-
name|Wtype_MIN
return|;
return|return
operator|(
name|Wtype
operator|)
name|a
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixunsdfsi
argument_list|)
operator|&&
name|LIBGCC2_HAS_DF_MODE
end_if

begin_comment
comment|/* Reenable the normal types, in case limits.h needs them.  */
end_comment

begin_undef
undef|#
directive|undef
name|char
end_undef

begin_undef
undef|#
directive|undef
name|short
end_undef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_undef
undef|#
directive|undef
name|long
end_undef

begin_undef
undef|#
directive|undef
name|unsigned
end_undef

begin_undef
undef|#
directive|undef
name|float
end_undef

begin_undef
undef|#
directive|undef
name|double
end_undef

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_function
name|UWtype
name|__fixunsdfSI
parameter_list|(
name|DFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|>=
operator|-
operator|(
name|DFtype
operator|)
name|Wtype_MIN
condition|)
return|return
call|(
name|Wtype
call|)
argument_list|(
name|a
operator|+
name|Wtype_MIN
argument_list|)
operator|-
name|Wtype_MIN
return|;
return|return
operator|(
name|Wtype
operator|)
name|a
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fixunssfsi
argument_list|)
operator|&&
name|LIBGCC2_HAS_SF_MODE
end_if

begin_comment
comment|/* Reenable the normal types, in case limits.h needs them.  */
end_comment

begin_undef
undef|#
directive|undef
name|char
end_undef

begin_undef
undef|#
directive|undef
name|short
end_undef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_undef
undef|#
directive|undef
name|long
end_undef

begin_undef
undef|#
directive|undef
name|unsigned
end_undef

begin_undef
undef|#
directive|undef
name|float
end_undef

begin_undef
undef|#
directive|undef
name|double
end_undef

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_function
name|UWtype
name|__fixunssfSI
parameter_list|(
name|SFtype
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|>=
operator|-
operator|(
name|SFtype
operator|)
name|Wtype_MIN
condition|)
return|return
call|(
name|Wtype
call|)
argument_list|(
name|a
operator|+
name|Wtype_MIN
argument_list|)
operator|-
name|Wtype_MIN
return|;
return|return
operator|(
name|Wtype
operator|)
name|a
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Integer power helper used from __builtin_powi for non-constant    exponents.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|L_powisf2
argument_list|)
operator|&&
name|LIBGCC2_HAS_SF_MODE
operator|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|L_powidf2
argument_list|)
operator|&&
name|LIBGCC2_HAS_DF_MODE
operator|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|L_powixf2
argument_list|)
operator|&&
name|LIBGCC2_HAS_XF_MODE
operator|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|L_powitf2
argument_list|)
operator|&&
name|LIBGCC2_HAS_TF_MODE
operator|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_powisf2
argument_list|)
end_if

begin_define
define|#
directive|define
name|TYPE
value|SFtype
end_define

begin_define
define|#
directive|define
name|NAME
value|__powisf2
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|L_powidf2
argument_list|)
end_elif

begin_define
define|#
directive|define
name|TYPE
value|DFtype
end_define

begin_define
define|#
directive|define
name|NAME
value|__powidf2
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|L_powixf2
argument_list|)
end_elif

begin_define
define|#
directive|define
name|TYPE
value|XFtype
end_define

begin_define
define|#
directive|define
name|NAME
value|__powixf2
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|L_powitf2
argument_list|)
end_elif

begin_define
define|#
directive|define
name|TYPE
value|TFtype
end_define

begin_define
define|#
directive|define
name|NAME
value|__powitf2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_undef
undef|#
directive|undef
name|unsigned
end_undef

begin_function
name|TYPE
name|NAME
parameter_list|(
name|TYPE
name|x
parameter_list|,
name|int
name|m
parameter_list|)
block|{
name|unsigned
name|int
name|n
init|=
name|m
operator|<
literal|0
condition|?
operator|-
name|m
else|:
name|m
decl_stmt|;
name|TYPE
name|y
init|=
name|n
operator|%
literal|2
condition|?
name|x
else|:
literal|1
decl_stmt|;
while|while
condition|(
name|n
operator|>>=
literal|1
condition|)
block|{
name|x
operator|=
name|x
operator|*
name|x
expr_stmt|;
if|if
condition|(
name|n
operator|%
literal|2
condition|)
name|y
operator|=
name|y
operator|*
name|x
expr_stmt|;
block|}
return|return
name|m
operator|<
literal|0
condition|?
literal|1
operator|/
name|y
else|:
name|y
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_if
if|#
directive|if
operator|(
operator|(
name|defined
argument_list|(
name|L_mulsc3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divsc3
argument_list|)
operator|)
operator|&&
name|LIBGCC2_HAS_SF_MODE
operator|)
expr|\
operator|||
operator|(
operator|(
name|defined
argument_list|(
name|L_muldc3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divdc3
argument_list|)
operator|)
operator|&&
name|LIBGCC2_HAS_DF_MODE
operator|)
expr|\
operator|||
operator|(
operator|(
name|defined
argument_list|(
name|L_mulxc3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divxc3
argument_list|)
operator|)
operator|&&
name|LIBGCC2_HAS_XF_MODE
operator|)
expr|\
operator|||
operator|(
operator|(
name|defined
argument_list|(
name|L_multc3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divtc3
argument_list|)
operator|)
operator|&&
name|LIBGCC2_HAS_TF_MODE
operator|)
end_if

begin_undef
undef|#
directive|undef
name|float
end_undef

begin_undef
undef|#
directive|undef
name|double
end_undef

begin_undef
undef|#
directive|undef
name|long
end_undef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_mulsc3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divsc3
argument_list|)
end_if

begin_define
define|#
directive|define
name|MTYPE
value|SFtype
end_define

begin_define
define|#
directive|define
name|CTYPE
value|SCtype
end_define

begin_define
define|#
directive|define
name|MODE
value|sc
end_define

begin_define
define|#
directive|define
name|CEXT
value|f
end_define

begin_define
define|#
directive|define
name|NOTRUNC
value|__FLT_EVAL_METHOD__ == 0
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|L_muldc3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divdc3
argument_list|)
end_elif

begin_define
define|#
directive|define
name|MTYPE
value|DFtype
end_define

begin_define
define|#
directive|define
name|CTYPE
value|DCtype
end_define

begin_define
define|#
directive|define
name|MODE
value|dc
end_define

begin_if
if|#
directive|if
name|LIBGCC2_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|CEXT
value|l
end_define

begin_define
define|#
directive|define
name|NOTRUNC
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CEXT
end_define

begin_define
define|#
directive|define
name|NOTRUNC
value|__FLT_EVAL_METHOD__ == 0 || __FLT_EVAL_METHOD__ == 1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|L_mulxc3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divxc3
argument_list|)
end_elif

begin_define
define|#
directive|define
name|MTYPE
value|XFtype
end_define

begin_define
define|#
directive|define
name|CTYPE
value|XCtype
end_define

begin_define
define|#
directive|define
name|MODE
value|xc
end_define

begin_define
define|#
directive|define
name|CEXT
value|l
end_define

begin_define
define|#
directive|define
name|NOTRUNC
value|1
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|L_multc3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divtc3
argument_list|)
end_elif

begin_define
define|#
directive|define
name|MTYPE
value|TFtype
end_define

begin_define
define|#
directive|define
name|CTYPE
value|TCtype
end_define

begin_define
define|#
directive|define
name|MODE
value|tc
end_define

begin_define
define|#
directive|define
name|CEXT
value|l
end_define

begin_define
define|#
directive|define
name|NOTRUNC
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CONCAT3
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|,
name|C
parameter_list|)
value|_CONCAT3(A,B,C)
end_define

begin_define
define|#
directive|define
name|_CONCAT3
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|,
name|C
parameter_list|)
value|A##B##C
end_define

begin_define
define|#
directive|define
name|CONCAT2
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|_CONCAT2(A,B)
end_define

begin_define
define|#
directive|define
name|_CONCAT2
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|A##B
end_define

begin_comment
comment|/* All of these would be present in a full C99 implementation of<math.h>    and<complex.h>.  Our problem is that only a few systems have such full    implementations.  Further, libgcc_s.so isn't currently linked against    libm.so, and even for systems that do provide full C99, the extra overhead    of all programs using libgcc having to link against libm.  So avoid it.  */
end_comment

begin_define
define|#
directive|define
name|isnan
parameter_list|(
name|x
parameter_list|)
value|__builtin_expect ((x) != (x), 0)
end_define

begin_define
define|#
directive|define
name|isfinite
parameter_list|(
name|x
parameter_list|)
value|__builtin_expect (!isnan((x) - (x)), 1)
end_define

begin_define
define|#
directive|define
name|isinf
parameter_list|(
name|x
parameter_list|)
value|__builtin_expect (!isnan(x)& !isfinite(x), 0)
end_define

begin_define
define|#
directive|define
name|INFINITY
value|CONCAT2(__builtin_inf, CEXT) ()
end_define

begin_define
define|#
directive|define
name|I
value|1i
end_define

begin_comment
comment|/* Helpers to make the following code slightly less gross.  */
end_comment

begin_define
define|#
directive|define
name|COPYSIGN
value|CONCAT2(__builtin_copysign, CEXT)
end_define

begin_define
define|#
directive|define
name|FABS
value|CONCAT2(__builtin_fabs, CEXT)
end_define

begin_comment
comment|/* Verify that MTYPE matches up with CEXT.  */
end_comment

begin_decl_stmt
specifier|extern
name|void
modifier|*
name|compile_type_assert
index|[
sizeof|sizeof
argument_list|(
name|INFINITY
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|MTYPE
argument_list|)
condition|?
literal|1
else|:
operator|-
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ensure that we've lost any extra precision.  */
end_comment

begin_if
if|#
directive|if
name|NOTRUNC
end_if

begin_define
define|#
directive|define
name|TRUNC
parameter_list|(
name|x
parameter_list|)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TRUNC
parameter_list|(
name|x
parameter_list|)
value|__asm__ ("" : "=m"(x) : "m"(x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_mulsc3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_muldc3
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|L_mulxc3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_multc3
argument_list|)
end_if

begin_decl_stmt
name|CTYPE
name|CONCAT3
argument_list|(
name|__mul
argument_list|,
name|MODE
argument_list|,
literal|3
argument_list|)
argument_list|(
name|MTYPE
name|a
argument_list|,
name|MTYPE
name|b
argument_list|,
name|MTYPE
name|c
argument_list|,
name|MTYPE
name|d
argument_list|)
block|{
name|MTYPE
name|ac
decl_stmt|,
name|bd
decl_stmt|,
name|ad
decl_stmt|,
name|bc
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|ac
operator|=
name|a
operator|*
name|c
expr_stmt|;
name|bd
operator|=
name|b
operator|*
name|d
expr_stmt|;
name|ad
operator|=
name|a
operator|*
name|d
expr_stmt|;
name|bc
operator|=
name|b
operator|*
name|c
expr_stmt|;
name|TRUNC
argument_list|(
name|ac
argument_list|)
expr_stmt|;
name|TRUNC
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|TRUNC
argument_list|(
name|ad
argument_list|)
expr_stmt|;
name|TRUNC
argument_list|(
name|bc
argument_list|)
expr_stmt|;
name|x
operator|=
name|ac
operator|-
name|bd
expr_stmt|;
name|y
operator|=
name|ad
operator|+
name|bc
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
name|x
argument_list|)
operator|&&
name|isnan
argument_list|(
name|y
argument_list|)
condition|)
block|{
comment|/* Recover infinities that computed as NaN + iNaN.  */
name|_Bool
name|recalc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isinf
argument_list|(
name|a
argument_list|)
operator|||
name|isinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
comment|/* z is infinite.  "Box" the infinity and change NaNs in 	     the other factor to 0.  */
name|a
operator|=
name|COPYSIGN
argument_list|(
name|isinf
argument_list|(
name|a
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|b
operator|=
name|COPYSIGN
argument_list|(
name|isinf
argument_list|(
name|b
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|COPYSIGN
argument_list|(
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|COPYSIGN
argument_list|(
literal|0
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|recalc
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|isinf
argument_list|(
name|c
argument_list|)
operator|||
name|isinf
argument_list|(
name|d
argument_list|)
condition|)
block|{
comment|/* w is infinite.  "Box" the infinity and change NaNs in 	     the other factor to 0.  */
name|c
operator|=
name|COPYSIGN
argument_list|(
name|isinf
argument_list|(
name|c
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|d
operator|=
name|COPYSIGN
argument_list|(
name|isinf
argument_list|(
name|d
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
name|a
argument_list|)
condition|)
name|a
operator|=
name|COPYSIGN
argument_list|(
literal|0
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
name|b
argument_list|)
condition|)
name|b
operator|=
name|COPYSIGN
argument_list|(
literal|0
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|recalc
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|recalc
operator|&&
operator|(
name|isinf
argument_list|(
name|ac
argument_list|)
operator|||
name|isinf
argument_list|(
name|bd
argument_list|)
operator|||
name|isinf
argument_list|(
name|ad
argument_list|)
operator|||
name|isinf
argument_list|(
name|bc
argument_list|)
operator|)
condition|)
block|{
comment|/* Recover infinities from overflow by changing NaNs to 0.  */
if|if
condition|(
name|isnan
argument_list|(
name|a
argument_list|)
condition|)
name|a
operator|=
name|COPYSIGN
argument_list|(
literal|0
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
name|b
argument_list|)
condition|)
name|b
operator|=
name|COPYSIGN
argument_list|(
literal|0
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|COPYSIGN
argument_list|(
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|COPYSIGN
argument_list|(
literal|0
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|recalc
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|recalc
condition|)
block|{
name|x
operator|=
name|INFINITY
operator|*
operator|(
name|a
operator|*
name|c
operator|-
name|b
operator|*
name|d
operator|)
expr_stmt|;
name|y
operator|=
name|INFINITY
operator|*
operator|(
name|a
operator|*
name|d
operator|+
name|b
operator|*
name|c
operator|)
expr_stmt|;
block|}
block|}
return|return
name|x
operator|+
name|I
operator|*
name|y
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* complex multiply */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_divsc3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divdc3
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|L_divxc3
argument_list|)
operator|||
name|defined
argument_list|(
name|L_divtc3
argument_list|)
end_if

begin_decl_stmt
name|CTYPE
name|CONCAT3
argument_list|(
name|__div
argument_list|,
name|MODE
argument_list|,
literal|3
argument_list|)
argument_list|(
name|MTYPE
name|a
argument_list|,
name|MTYPE
name|b
argument_list|,
name|MTYPE
name|c
argument_list|,
name|MTYPE
name|d
argument_list|)
block|{
name|MTYPE
name|denom
decl_stmt|,
name|ratio
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* ??? We can get better behavior from logarithmic scaling instead of      the division.  But that would mean starting to link libgcc against      libm.  We could implement something akin to ldexp/frexp as gcc builtins      fairly easily...  */
if|if
condition|(
name|FABS
argument_list|(
name|c
argument_list|)
operator|<
name|FABS
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|ratio
operator|=
name|c
operator|/
name|d
expr_stmt|;
name|denom
operator|=
operator|(
name|c
operator|*
name|ratio
operator|)
operator|+
name|d
expr_stmt|;
name|x
operator|=
operator|(
operator|(
name|a
operator|*
name|ratio
operator|)
operator|+
name|b
operator|)
operator|/
name|denom
expr_stmt|;
name|y
operator|=
operator|(
operator|(
name|b
operator|*
name|ratio
operator|)
operator|-
name|a
operator|)
operator|/
name|denom
expr_stmt|;
block|}
else|else
block|{
name|ratio
operator|=
name|d
operator|/
name|c
expr_stmt|;
name|denom
operator|=
operator|(
name|d
operator|*
name|ratio
operator|)
operator|+
name|c
expr_stmt|;
name|x
operator|=
operator|(
operator|(
name|b
operator|*
name|ratio
operator|)
operator|+
name|a
operator|)
operator|/
name|denom
expr_stmt|;
name|y
operator|=
operator|(
name|b
operator|-
operator|(
name|a
operator|*
name|ratio
operator|)
operator|)
operator|/
name|denom
expr_stmt|;
block|}
comment|/* Recover infinities and zeros that computed as NaN+iNaN; the only cases      are nonzero/zero, infinite/finite, and finite/infinite.  */
if|if
condition|(
name|isnan
argument_list|(
name|x
argument_list|)
operator|&&
name|isnan
argument_list|(
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0.0
operator|&&
name|d
operator|==
literal|0.0
operator|&&
operator|(
operator|!
name|isnan
argument_list|(
name|a
argument_list|)
operator|||
operator|!
name|isnan
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
name|x
operator|=
name|COPYSIGN
argument_list|(
name|INFINITY
argument_list|,
name|c
argument_list|)
operator|*
name|a
expr_stmt|;
name|y
operator|=
name|COPYSIGN
argument_list|(
name|INFINITY
argument_list|,
name|c
argument_list|)
operator|*
name|b
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|isinf
argument_list|(
name|a
argument_list|)
operator|||
name|isinf
argument_list|(
name|b
argument_list|)
operator|)
operator|&&
name|isfinite
argument_list|(
name|c
argument_list|)
operator|&&
name|isfinite
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|a
operator|=
name|COPYSIGN
argument_list|(
name|isinf
argument_list|(
name|a
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|b
operator|=
name|COPYSIGN
argument_list|(
name|isinf
argument_list|(
name|b
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|x
operator|=
name|INFINITY
operator|*
operator|(
name|a
operator|*
name|c
operator|+
name|b
operator|*
name|d
operator|)
expr_stmt|;
name|y
operator|=
name|INFINITY
operator|*
operator|(
name|b
operator|*
name|c
operator|-
name|a
operator|*
name|d
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|isinf
argument_list|(
name|c
argument_list|)
operator|||
name|isinf
argument_list|(
name|d
argument_list|)
operator|)
operator|&&
name|isfinite
argument_list|(
name|a
argument_list|)
operator|&&
name|isfinite
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|c
operator|=
name|COPYSIGN
argument_list|(
name|isinf
argument_list|(
name|c
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|d
operator|=
name|COPYSIGN
argument_list|(
name|isinf
argument_list|(
name|d
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|x
operator|=
literal|0.0
operator|*
operator|(
name|a
operator|*
name|c
operator|+
name|b
operator|*
name|d
operator|)
expr_stmt|;
name|y
operator|=
literal|0.0
operator|*
operator|(
name|b
operator|*
name|c
operator|-
name|a
operator|*
name|d
operator|)
expr_stmt|;
block|}
block|}
return|return
name|x
operator|+
name|I
operator|*
name|y
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* complex divide */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* all complex float routines */
end_comment

begin_escape
end_escape

begin_comment
comment|/* From here on down, the routines use normal data types.  */
end_comment

begin_define
define|#
directive|define
name|SItype
value|bogus_type
end_define

begin_define
define|#
directive|define
name|USItype
value|bogus_type
end_define

begin_define
define|#
directive|define
name|DItype
value|bogus_type
end_define

begin_define
define|#
directive|define
name|UDItype
value|bogus_type
end_define

begin_define
define|#
directive|define
name|SFtype
value|bogus_type
end_define

begin_define
define|#
directive|define
name|DFtype
value|bogus_type
end_define

begin_undef
undef|#
directive|undef
name|Wtype
end_undef

begin_undef
undef|#
directive|undef
name|UWtype
end_undef

begin_undef
undef|#
directive|undef
name|HWtype
end_undef

begin_undef
undef|#
directive|undef
name|UHWtype
end_undef

begin_undef
undef|#
directive|undef
name|DWtype
end_undef

begin_undef
undef|#
directive|undef
name|UDWtype
end_undef

begin_undef
undef|#
directive|undef
name|char
end_undef

begin_undef
undef|#
directive|undef
name|short
end_undef

begin_undef
undef|#
directive|undef
name|int
end_undef

begin_undef
undef|#
directive|undef
name|long
end_undef

begin_undef
undef|#
directive|undef
name|unsigned
end_undef

begin_undef
undef|#
directive|undef
name|float
end_undef

begin_undef
undef|#
directive|undef
name|double
end_undef

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L__gcc_bcmp
end_ifdef

begin_comment
comment|/* Like bcmp except the sign is meaningful.    Result is negative if S1 is less than S2,    positive if S1 is greater, 0 if S1 and S2 are equal.  */
end_comment

begin_function
name|int
name|__gcc_bcmp
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|s2
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
specifier|const
name|unsigned
name|char
name|c1
init|=
operator|*
name|s1
operator|++
decl_stmt|,
name|c2
init|=
operator|*
name|s2
operator|++
decl_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
name|c1
operator|-
name|c2
return|;
name|size
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* __eprintf used to be used by GCC's private version of<assert.h>.    We no longer provide that header, but this routine remains in libgcc.a    for binary backward compatibility.  Note that it is not included in    the shared version of libgcc.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|L_eprintf
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|inhibit_libc
end_ifndef

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_comment
comment|/* Avoid errors if stdio.h and our stddef.h mismatch.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
name|void
name|__eprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
specifier|const
name|char
modifier|*
name|expression
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|expression
argument_list|,
name|line
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_clear_cache
end_ifdef

begin_comment
comment|/* Clear part of an instruction cache.  */
end_comment

begin_decl_stmt
name|void
name|__clear_cache
argument_list|(
name|void
operator|*
name|beg
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
name|void
operator|*
name|end
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{
ifdef|#
directive|ifdef
name|CLEAR_INSN_CACHE
name|CLEAR_INSN_CACHE
argument_list|(
name|beg
argument_list|,
name|end
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLEAR_INSN_CACHE */
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_clear_cache */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_enable_execute_stack
end_ifdef

begin_comment
comment|/* Attempt to turn on execute permission for the stack.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_EXECUTE_STACK
end_ifdef

begin_decl_stmt
name|ENABLE_EXECUTE_STACK
else|#
directive|else
name|void
name|__enable_execute_stack
argument_list|(
name|void
operator|*
name|addr
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_EXECUTE_STACK */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_enable_execute_stack */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_trampoline
end_ifdef

begin_comment
comment|/* Jump to a trampoline, loading the static chain address.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_UWIN
argument_list|)
end_if

begin_function
name|int
name|getpagesize
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_ALPHA_
return|return
literal|8192
return|;
else|#
directive|else
return|return
literal|4096
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_function_decl
specifier|extern
name|int
name|VirtualProtect
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(stdcall
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|mprotect
parameter_list|(
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
name|int
name|np
decl_stmt|,
name|op
decl_stmt|;
if|if
condition|(
name|prot
operator|==
literal|7
condition|)
name|np
operator|=
literal|0x40
expr_stmt|;
elseif|else
if|if
condition|(
name|prot
operator|==
literal|5
condition|)
name|np
operator|=
literal|0x20
expr_stmt|;
elseif|else
if|if
condition|(
name|prot
operator|==
literal|4
condition|)
name|np
operator|=
literal|0x10
expr_stmt|;
elseif|else
if|if
condition|(
name|prot
operator|==
literal|3
condition|)
name|np
operator|=
literal|0x04
expr_stmt|;
elseif|else
if|if
condition|(
name|prot
operator|==
literal|1
condition|)
name|np
operator|=
literal|0x02
expr_stmt|;
elseif|else
if|if
condition|(
name|prot
operator|==
literal|0
condition|)
name|np
operator|=
literal|0x01
expr_stmt|;
if|if
condition|(
name|VirtualProtect
argument_list|(
name|addr
argument_list|,
name|len
argument_list|,
name|np
argument_list|,
operator|&
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WINNT&& ! __CYGWIN__&& ! _UWIN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TRANSFER_FROM_TRAMPOLINE
end_ifdef

begin_decl_stmt
name|TRANSFER_FROM_TRAMPOLINE
endif|#
directive|endif
endif|#
directive|endif
comment|/* L_trampoline */
ifndef|#
directive|ifndef
name|__CYGWIN__
ifdef|#
directive|ifdef
name|L__main
include|#
directive|include
file|"gbl-ctors.h"
comment|/* Some systems use __main in a way incompatible with its use in gcc, in these    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to    give the same symbol without quotes for an alternative entry point.  You    must define both, or neither.  */
ifndef|#
directive|ifndef
name|NAME__MAIN
define|#
directive|define
name|NAME__MAIN
value|"__main"
define|#
directive|define
name|SYMBOL__MAIN
value|__main
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INIT_SECTION_ASM_OP
argument_list|)
operator|||
name|defined
argument_list|(
name|INIT_ARRAY_SECTION_ASM_OP
argument_list|)
undef|#
directive|undef
name|HAS_INIT_SECTION
define|#
directive|define
name|HAS_INIT_SECTION
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_INIT_SECTION
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|OBJECT_FORMAT_ELF
argument_list|)
comment|/* Some ELF crosses use crtstuff.c to provide __CTOR_LIST__, but use this    code to run constructors.  In that case, we need to handle EH here, too.  */
ifdef|#
directive|ifdef
name|EH_FRAME_SECTION_NAME
include|#
directive|include
file|"unwind-dw2-fde.h"
specifier|extern
name|unsigned
name|char
name|__EH_FRAME_BEGIN__
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Run all the global destructors on exit from the program.  */
end_comment

begin_function
name|void
name|__do_global_dtors
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DO_GLOBAL_DTORS_BODY
name|DO_GLOBAL_DTORS_BODY
expr_stmt|;
else|#
directive|else
specifier|static
name|func_ptr
modifier|*
name|p
init|=
name|__DTOR_LIST__
operator|+
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p
operator|++
expr_stmt|;
operator|(
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|)
operator|(
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EH_FRAME_SECTION_NAME
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_INIT_SECTION
argument_list|)
block|{
specifier|static
name|int
name|completed
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|completed
condition|)
block|{
name|completed
operator|=
literal|1
expr_stmt|;
name|__deregister_frame_info
argument_list|(
name|__EH_FRAME_BEGIN__
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_INIT_SECTION
end_ifndef

begin_comment
comment|/* Run all the global constructors on entry to the program.  */
end_comment

begin_function
name|void
name|__do_global_ctors
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|EH_FRAME_SECTION_NAME
block|{
specifier|static
name|struct
name|object
name|object
decl_stmt|;
name|__register_frame_info
argument_list|(
name|__EH_FRAME_BEGIN__
argument_list|,
operator|&
name|object
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|DO_GLOBAL_CTORS_BODY
expr_stmt|;
name|atexit
argument_list|(
name|__do_global_dtors
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no HAS_INIT_SECTION */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_INIT_SECTION
argument_list|)
operator|||
name|defined
argument_list|(
name|INVOKE__main
argument_list|)
end_if

begin_comment
comment|/* Subroutine called automatically by `main'.    Compiling a global function named `main'    produces an automatic call to this function at the beginning.     For many systems, this routine calls __do_global_ctors.    For systems which support a .init section we use the .init section    to run __do_global_ctors, so we need not do anything here.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|SYMBOL__MAIN
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|SYMBOL__MAIN
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Support recursive calls to `main': run initializers just once.  */
specifier|static
name|int
name|initialized
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|initialized
operator|=
literal|1
expr_stmt|;
name|__do_global_ctors
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no HAS_INIT_SECTION or INVOKE__main */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L__main */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __CYGWIN__ */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|L_ctors
end_ifdef

begin_include
include|#
directive|include
file|"gbl-ctors.h"
end_include

begin_comment
comment|/* Provide default definitions for the lists of constructors and    destructors, so that we don't get linker errors.  These symbols are    intentionally bss symbols, so that gld and/or collect will provide    the right values.  */
end_comment

begin_comment
comment|/* We declare the lists here with two elements each,    so that they are valid empty lists if no other definition is loaded.     If we are using the old "set" extensions to have the gnu linker    collect ctors and dtors, then we __CTOR_LIST__ and __DTOR_LIST__    must be in the bss/common section.     Long term no port should use those extensions.  But many still do.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INIT_SECTION_ASM_OP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CTOR_LISTS_DEFINED_EXTERNALLY
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TARGET_ASM_CONSTRUCTOR
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_COLLECT2
argument_list|)
end_if

begin_decl_stmt
name|func_ptr
name|__CTOR_LIST__
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|func_ptr
name|__DTOR_LIST__
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|func_ptr
name|__CTOR_LIST__
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|func_ptr
name|__DTOR_LIST__
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no INIT_SECTION_ASM_OP and not CTOR_LISTS_DEFINED_EXTERNALLY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_ctors */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBGCC2_UNITS_PER_WORD<= MIN_UNITS_PER_WORD */
end_comment

end_unit

