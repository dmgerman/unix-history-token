begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Conditional constant propagation pass for the GNU compiler.    Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.    Original framework by Daniel Berlin<dan@cgsoftware.com>    Fleshed out and major cleanups by Jeff Law<law@redhat.com>     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Conditional constant propagation.     References:       Constant propagation with conditional branches,      Wegman and Zadeck, ACM TOPLAS 13(2):181-210.       Building an Optimizing Compiler,      Robert Morgan, Butterworth-Heinemann, 1998, Section 8.9.       Advanced Compiler Design and Implementation,      Steven Muchnick, Morgan Kaufmann, 1997, Section 12.6     The overall structure is as follows:  	1. Run a simple SSA based DCE pass to remove any dead code. 	2. Run CCP to compute what registers are known constants 	   and what edges are not executable.  Remove unexecutable 	   edges from the CFG and simplify PHI nodes. 	3. Replace registers with constants where possible. 	4. Remove unreachable blocks computed in step #2. 	5. Another simple SSA DCE pass to remove dead code exposed 	   by CCP.     When we exit, we are still in SSA form.       Potential further enhancements:      1. Handle SUBREGs, STRICT_LOW_PART, etc in destinations more        gracefully.      2. Handle insns with multiple outputs more gracefully.      3. Handle CONST_DOUBLE and symbolic constants.      4. Fold expressions after performing constant substitutions.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"ssa.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"df.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Possible lattice values.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|UNDEFINED
block|,
name|CONSTANT
block|,
name|VARYING
block|}
name|latticevalue
typedef|;
end_typedef

begin_comment
comment|/* Main structure for CCP.      Contains the lattice value and, if it's a constant, the constant    value.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|latticevalue
name|lattice_val
decl_stmt|;
name|rtx
name|const_value
decl_stmt|;
block|}
name|value
typedef|;
end_typedef

begin_comment
comment|/* Array of values indexed by register number.  */
end_comment

begin_decl_stmt
specifier|static
name|value
modifier|*
name|values
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A bitmap to keep track of executable blocks in the CFG.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|executable_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A bitmap for all executable edges in the CFG.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|executable_edges
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of edges on the work list.  */
end_comment

begin_decl_stmt
specifier|static
name|edge
modifier|*
name|edge_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We need an edge list to be able to get indexes easily.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|edge_list
modifier|*
name|edges
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For building/following use-def and def-use chains.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|df
modifier|*
name|df_analyzer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current edge we are operating on, from the worklist */
end_comment

begin_decl_stmt
specifier|static
name|edge
name|flow_edges
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bitmap of SSA edges which will need reexamination as their definition    has changed.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|ssa_edges
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple macros to simplify code */
end_comment

begin_define
define|#
directive|define
name|SSA_NAME
parameter_list|(
name|x
parameter_list|)
value|REGNO (SET_DEST (x))
end_define

begin_define
define|#
directive|define
name|PHI_PARMS
parameter_list|(
name|x
parameter_list|)
value|XVEC (SET_SRC (x), 0)
end_define

begin_define
define|#
directive|define
name|EIE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|EDGE_INDEX (edges, x, y)
end_define

begin_decl_stmt
specifier|static
name|void
name|visit_phi_node
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|visit_expression
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|defs_to_undefined
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|defs_to_varying
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|examine_flow_edges
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mark_references
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|follow_def_use_chains
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|optimize_unexecutable_edges
name|PARAMS
argument_list|(
operator|(
expr|struct
name|edge_list
operator|*
operator|,
name|sbitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ssa_ccp_substitute_constants
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ssa_ccp_df_delete_unreachable_insns
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ssa_fast_dce
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Loop through the PHI_NODE's parameters for BLOCK and compare their    lattice values to determine PHI_NODE's lattice value.  */
end_comment

begin_function
specifier|static
name|void
name|visit_phi_node
parameter_list|(
name|phi_node
parameter_list|,
name|block
parameter_list|)
name|rtx
name|phi_node
decl_stmt|;
name|basic_block
name|block
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|rtx
name|phi_node_expr
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|phi_node_name
init|=
name|SSA_NAME
argument_list|(
name|PATTERN
argument_list|(
name|phi_node
argument_list|)
argument_list|)
decl_stmt|;
name|latticevalue
name|phi_node_lattice_val
init|=
name|UNDEFINED
decl_stmt|;
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|phi_node
argument_list|)
decl_stmt|;
name|rtvec
name|phi_vec
init|=
name|XVEC
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|num_elem
init|=
name|GET_NUM_ELEM
argument_list|(
name|phi_vec
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_elem
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|TEST_BIT
argument_list|(
name|executable_edges
argument_list|,
name|EIE
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|INTVAL
argument_list|(
name|RTVEC_ELT
argument_list|(
name|phi_vec
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|block
argument_list|)
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|current_parm
init|=
name|REGNO
argument_list|(
name|RTVEC_ELT
argument_list|(
name|phi_vec
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|latticevalue
name|current_parm_lattice_val
init|=
name|values
index|[
name|current_parm
index|]
operator|.
name|lattice_val
decl_stmt|;
comment|/* If any node is VARYING, then new value of PHI_NODE 	     is VARYING.  */
if|if
condition|(
name|current_parm_lattice_val
operator|==
name|VARYING
condition|)
block|{
name|phi_node_lattice_val
operator|=
name|VARYING
expr_stmt|;
name|phi_node_expr
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* If we have more than one distinct constant, then the new 	     value of PHI_NODE is VARYING.  */
if|if
condition|(
name|current_parm_lattice_val
operator|==
name|CONSTANT
operator|&&
name|phi_node_lattice_val
operator|==
name|CONSTANT
operator|&&
name|values
index|[
name|current_parm
index|]
operator|.
name|const_value
operator|!=
name|phi_node_expr
condition|)
block|{
name|phi_node_lattice_val
operator|=
name|VARYING
expr_stmt|;
name|phi_node_expr
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* If the current value of PHI_NODE is UNDEFINED and one 	     node in PHI_NODE is CONSTANT, then the new value of the 	     PHI is that CONSTANT.  Note this can turn into VARYING 	     if we find another distinct constant later.  */
if|if
condition|(
name|phi_node_lattice_val
operator|==
name|UNDEFINED
operator|&&
name|phi_node_expr
operator|==
name|NULL
operator|&&
name|current_parm_lattice_val
operator|==
name|CONSTANT
condition|)
block|{
name|phi_node_expr
operator|=
name|values
index|[
name|current_parm
index|]
operator|.
name|const_value
expr_stmt|;
name|phi_node_lattice_val
operator|=
name|CONSTANT
expr_stmt|;
continue|continue;
block|}
block|}
block|}
comment|/* If the value of PHI_NODE changed, then we will need to      re-execute uses of the output of PHI_NODE.  */
if|if
condition|(
name|phi_node_lattice_val
operator|!=
name|values
index|[
name|phi_node_name
index|]
operator|.
name|lattice_val
condition|)
block|{
name|values
index|[
name|phi_node_name
index|]
operator|.
name|lattice_val
operator|=
name|phi_node_lattice_val
expr_stmt|;
name|values
index|[
name|phi_node_name
index|]
operator|.
name|const_value
operator|=
name|phi_node_expr
expr_stmt|;
name|SET_BIT
argument_list|(
name|ssa_edges
argument_list|,
name|phi_node_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Sets all defs in an insn to UNDEFINED.  */
end_comment

begin_function
specifier|static
name|void
name|defs_to_undefined
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|struct
name|df_link
modifier|*
name|currdef
decl_stmt|;
for|for
control|(
name|currdef
operator|=
name|DF_INSN_DEFS
argument_list|(
name|df_analyzer
argument_list|,
name|insn
argument_list|)
init|;
name|currdef
condition|;
name|currdef
operator|=
name|currdef
operator|->
name|next
control|)
block|{
if|if
condition|(
name|values
index|[
name|DF_REF_REGNO
argument_list|(
name|currdef
operator|->
name|ref
argument_list|)
index|]
operator|.
name|lattice_val
operator|!=
name|UNDEFINED
condition|)
name|SET_BIT
argument_list|(
name|ssa_edges
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|currdef
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|values
index|[
name|DF_REF_REGNO
argument_list|(
name|currdef
operator|->
name|ref
argument_list|)
index|]
operator|.
name|lattice_val
operator|=
name|UNDEFINED
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Sets all defs in an insn to VARYING.  */
end_comment

begin_function
specifier|static
name|void
name|defs_to_varying
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|struct
name|df_link
modifier|*
name|currdef
decl_stmt|;
for|for
control|(
name|currdef
operator|=
name|DF_INSN_DEFS
argument_list|(
name|df_analyzer
argument_list|,
name|insn
argument_list|)
init|;
name|currdef
condition|;
name|currdef
operator|=
name|currdef
operator|->
name|next
control|)
block|{
if|if
condition|(
name|values
index|[
name|DF_REF_REGNO
argument_list|(
name|currdef
operator|->
name|ref
argument_list|)
index|]
operator|.
name|lattice_val
operator|!=
name|VARYING
condition|)
name|SET_BIT
argument_list|(
name|ssa_edges
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|currdef
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|values
index|[
name|DF_REF_REGNO
argument_list|(
name|currdef
operator|->
name|ref
argument_list|)
index|]
operator|.
name|lattice_val
operator|=
name|VARYING
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Go through the expression, call the appropriate evaluation routines    to attempt cprop */
end_comment

begin_function
specifier|static
name|void
name|visit_expression
parameter_list|(
name|insn
parameter_list|,
name|block
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|basic_block
name|block
decl_stmt|;
block|{
name|rtx
name|src
decl_stmt|,
name|dest
decl_stmt|,
name|set
decl_stmt|;
comment|/* Ugh.  CALL_INSNs may end a basic block and have multiple edges      leading out from them.       Mark all the outgoing edges as executable, then fall into the      normal processing below.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|block
operator|->
name|end
operator|==
name|insn
condition|)
block|{
name|edge
name|curredge
decl_stmt|;
for|for
control|(
name|curredge
operator|=
name|block
operator|->
name|succ
init|;
name|curredge
condition|;
name|curredge
operator|=
name|curredge
operator|->
name|succ_next
control|)
block|{
name|int
name|index
init|=
name|EIE
argument_list|(
name|curredge
operator|->
name|src
argument_list|,
name|curredge
operator|->
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|executable_edges
argument_list|,
name|index
argument_list|)
condition|)
continue|continue;
name|SET_BIT
argument_list|(
name|executable_edges
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|edge_info
index|[
name|index
index|]
operator|=
name|flow_edges
expr_stmt|;
name|flow_edges
operator|=
name|curredge
expr_stmt|;
block|}
block|}
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
block|{
name|defs_to_varying
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
comment|/* We may want to refine this some day.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
operator|&&
name|dest
operator|!=
name|pc_rtx
condition|)
block|{
name|defs_to_varying
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Hard registers are not put in SSA form and thus we must consider      them varying.  All the more reason to avoid hard registers in       RTL until as late as possible in the compilation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|defs_to_varying
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If this is assigning DEST to a constant, record that fact.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
condition|)
block|{
name|unsigned
name|int
name|resultreg
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|values
index|[
name|resultreg
index|]
operator|.
name|lattice_val
operator|=
name|CONSTANT
expr_stmt|;
name|values
index|[
name|resultreg
index|]
operator|.
name|const_value
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|ssa_edges
argument_list|,
name|resultreg
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a copy operation, then we can copy the lattice values.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|old_value
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|latticevalue
name|old_lattice_value
init|=
name|values
index|[
name|old_value
index|]
operator|.
name|lattice_val
decl_stmt|;
name|unsigned
name|int
name|new_value
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
comment|/* Unless the lattice value is going to change, don't bother          adding the "new value" into the worklist.  */
if|if
condition|(
name|values
index|[
name|new_value
index|]
operator|.
name|lattice_val
operator|!=
name|old_lattice_value
operator|||
name|values
index|[
name|new_value
index|]
operator|.
name|const_value
operator|!=
name|values
index|[
name|old_value
index|]
operator|.
name|const_value
condition|)
name|SET_BIT
argument_list|(
name|ssa_edges
argument_list|,
name|new_value
argument_list|)
expr_stmt|;
comment|/* Copy the old lattice node info into the new value lattice node.  */
name|values
index|[
name|new_value
index|]
operator|.
name|lattice_val
operator|=
name|old_lattice_value
expr_stmt|;
name|values
index|[
name|new_value
index|]
operator|.
name|const_value
operator|=
name|values
index|[
name|old_value
index|]
operator|.
name|const_value
expr_stmt|;
block|}
comment|/* Handle jumps.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|x
init|=
name|pc_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|IF_THEN_ELSE
condition|)
block|{
name|edge
name|curredge
decl_stmt|;
comment|/* This is a computed jump, table jump, or an unconditional 	     jump.  For all these cases we want to mark all successor 	     blocks as executable if they have not already been 	     marked.  	     One day we may try do better with swtich tables and 	     other computed jumps.  */
for|for
control|(
name|curredge
operator|=
name|block
operator|->
name|succ
init|;
name|curredge
condition|;
name|curredge
operator|=
name|curredge
operator|->
name|succ_next
control|)
block|{
name|int
name|index
init|=
name|EIE
argument_list|(
name|curredge
operator|->
name|src
argument_list|,
name|curredge
operator|->
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|executable_edges
argument_list|,
name|index
argument_list|)
condition|)
continue|continue;
name|SET_BIT
argument_list|(
name|executable_edges
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|edge_info
index|[
name|index
index|]
operator|=
name|flow_edges
expr_stmt|;
name|flow_edges
operator|=
name|curredge
expr_stmt|;
block|}
block|}
else|else
block|{
name|edge
name|curredge
decl_stmt|;
name|enum
name|rtx_code
name|comparison_code
decl_stmt|;
name|rtx
name|comparison_src0
decl_stmt|;
name|rtx
name|comparison_src1
decl_stmt|;
name|comparison_code
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|comparison_src0
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|comparison_src1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If either operand is undefined, then there is nothing to 	     do right now.  If/when operands are later defined we will 	     revaluate the condition and take the appropriate action.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|comparison_src0
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|comparison_src0
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|UNDEFINED
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|comparison_src1
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|comparison_src1
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|UNDEFINED
operator|)
condition|)
return|return;
comment|/* If either operand is varying, then we must consider all 	     paths as executable.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|comparison_src0
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|comparison_src0
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|VARYING
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|comparison_src1
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|comparison_src1
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|VARYING
operator|)
condition|)
block|{
for|for
control|(
name|curredge
operator|=
name|block
operator|->
name|succ
init|;
name|curredge
condition|;
name|curredge
operator|=
name|curredge
operator|->
name|succ_next
control|)
block|{
name|int
name|index
init|=
name|EIE
argument_list|(
name|curredge
operator|->
name|src
argument_list|,
name|curredge
operator|->
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|executable_edges
argument_list|,
name|index
argument_list|)
condition|)
continue|continue;
name|SET_BIT
argument_list|(
name|executable_edges
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|edge_info
index|[
name|index
index|]
operator|=
name|flow_edges
expr_stmt|;
name|flow_edges
operator|=
name|curredge
expr_stmt|;
block|}
return|return;
block|}
comment|/* Try to simplify the comparison.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|comparison_src0
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|comparison_src0
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|CONSTANT
condition|)
name|comparison_src0
operator|=
name|values
index|[
name|REGNO
argument_list|(
name|comparison_src0
argument_list|)
index|]
operator|.
name|const_value
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|comparison_src1
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|comparison_src1
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|CONSTANT
condition|)
name|comparison_src1
operator|=
name|values
index|[
name|REGNO
argument_list|(
name|comparison_src1
argument_list|)
index|]
operator|.
name|const_value
expr_stmt|;
name|x
operator|=
name|simplify_ternary_operation
argument_list|(
name|IF_THEN_ELSE
argument_list|,
name|VOIDmode
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|comparison_code
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|comparison_src0
argument_list|,
name|comparison_src1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Walk through all the outgoing edges from this block and see 	     which (if any) we should mark as executable.  */
for|for
control|(
name|curredge
operator|=
name|block
operator|->
name|succ
init|;
name|curredge
condition|;
name|curredge
operator|=
name|curredge
operator|->
name|succ_next
control|)
block|{
name|int
name|index
init|=
name|EIE
argument_list|(
name|curredge
operator|->
name|src
argument_list|,
name|curredge
operator|->
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|executable_edges
argument_list|,
name|index
argument_list|)
condition|)
continue|continue;
comment|/* If we were unable to simplify the expression at this 		 point, it's highly unlikely we'll be able to simplify 		 it later.  So consider all edges as executable if the 		 expression did not simplify.  		 If the expression simplified to (pc), then we know we 		 will take the fall-thru edge, so mark it.  Similarly, 		 if the expression simplified to (label_ref ...), then 		 we know the branch will be taken and we mark that 		 edge as taken.  */
if|if
condition|(
operator|!
name|x
operator|||
operator|(
name|x
operator|==
name|pc_rtx
operator|&&
operator|(
name|curredge
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
operator|&&
operator|!
operator|(
name|curredge
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|executable_edges
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|edge_info
index|[
name|index
index|]
operator|=
name|flow_edges
expr_stmt|;
name|flow_edges
operator|=
name|curredge
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|PHI_NODE_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|simplified
init|=
name|NULL
decl_stmt|;
comment|/* We've got some kind of INSN.  If it's simple, try to evaluate 	 it and record the results.   	 We already know this insn is a single_set and that it sets 	 a pseudo register.   So we just need to extract the source 	 arguments, simplify them to constants if possible, then 	 simplify the expression as a whole if possible.  */
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'<'
case|:
block|{
name|rtx
name|src0
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|src1
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* If either is undefined, then the result is undefined.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|src0
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|src0
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|UNDEFINED
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src1
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|src1
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|UNDEFINED
operator|)
condition|)
block|{
name|defs_to_undefined
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Determine the mode for the operation before we simplify 		 our arguments to constants.  */
name|mode
operator|=
name|GET_MODE
argument_list|(
name|src0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|src1
argument_list|)
expr_stmt|;
comment|/* Simplify source operands to whatever known values they 		 may have.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src0
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|src0
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|CONSTANT
condition|)
name|src0
operator|=
name|values
index|[
name|REGNO
argument_list|(
name|src0
argument_list|)
index|]
operator|.
name|const_value
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src1
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|src1
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|CONSTANT
condition|)
name|src1
operator|=
name|values
index|[
name|REGNO
argument_list|(
name|src1
argument_list|)
index|]
operator|.
name|const_value
expr_stmt|;
comment|/* See if the simplifier can determine if this operation 		 computes a constant value.  */
name|simplified
operator|=
name|simplify_relational_operation
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|mode
argument_list|,
name|src0
argument_list|,
name|src1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'1'
case|:
block|{
name|rtx
name|src0
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|GET_MODE
argument_list|(
name|src0
argument_list|)
decl_stmt|;
comment|/* If the operand is undefined, then the result is undefined.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src0
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|src0
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|UNDEFINED
condition|)
block|{
name|defs_to_undefined
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Simplify source operands to whatever known values they 		 may have.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src0
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|src0
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|CONSTANT
condition|)
name|src0
operator|=
name|values
index|[
name|REGNO
argument_list|(
name|src0
argument_list|)
index|]
operator|.
name|const_value
expr_stmt|;
comment|/* See if the simplifier can determine if this operation 		 computes a constant value.  */
name|simplified
operator|=
name|simplify_unary_operation
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|src0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'2'
case|:
case|case
literal|'c'
case|:
block|{
name|rtx
name|src0
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|src1
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* If either is undefined, then the result is undefined.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|src0
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|src0
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|UNDEFINED
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src1
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|src1
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|UNDEFINED
operator|)
condition|)
block|{
name|defs_to_undefined
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Simplify source operands to whatever known values they 		 may have.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src0
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|src0
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|CONSTANT
condition|)
name|src0
operator|=
name|values
index|[
name|REGNO
argument_list|(
name|src0
argument_list|)
index|]
operator|.
name|const_value
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src1
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|src1
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|CONSTANT
condition|)
name|src1
operator|=
name|values
index|[
name|REGNO
argument_list|(
name|src1
argument_list|)
index|]
operator|.
name|const_value
expr_stmt|;
comment|/* See if the simplifier can determine if this operation 		 computes a constant value.  */
name|simplified
operator|=
name|simplify_binary_operation
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|src0
argument_list|,
name|src1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'3'
case|:
case|case
literal|'b'
case|:
block|{
name|rtx
name|src0
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|src1
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|src2
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
decl_stmt|;
comment|/* If either is undefined, then the result is undefined.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|src0
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|src0
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|UNDEFINED
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src1
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|src1
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|UNDEFINED
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src2
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|src2
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|UNDEFINED
operator|)
condition|)
block|{
name|defs_to_undefined
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Simplify source operands to whatever known values they 		 may have.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src0
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|src0
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|CONSTANT
condition|)
name|src0
operator|=
name|values
index|[
name|REGNO
argument_list|(
name|src0
argument_list|)
index|]
operator|.
name|const_value
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src1
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|src1
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|CONSTANT
condition|)
name|src1
operator|=
name|values
index|[
name|REGNO
argument_list|(
name|src1
argument_list|)
index|]
operator|.
name|const_value
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src2
argument_list|)
operator|==
name|REG
operator|&&
name|values
index|[
name|REGNO
argument_list|(
name|src2
argument_list|)
index|]
operator|.
name|lattice_val
operator|==
name|CONSTANT
condition|)
name|src2
operator|=
name|values
index|[
name|REGNO
argument_list|(
name|src2
argument_list|)
index|]
operator|.
name|const_value
expr_stmt|;
comment|/* See if the simplifier can determine if this operation 		 computes a constant value.  */
name|simplified
operator|=
name|simplify_ternary_operation
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|src0
argument_list|,
name|src1
argument_list|,
name|src2
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|defs_to_varying
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|simplified
operator|&&
name|GET_CODE
argument_list|(
name|simplified
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|values
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|.
name|lattice_val
operator|!=
name|CONSTANT
operator|||
name|values
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|.
name|const_value
operator|!=
name|simplified
condition|)
name|SET_BIT
argument_list|(
name|ssa_edges
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|values
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|.
name|lattice_val
operator|=
name|CONSTANT
expr_stmt|;
name|values
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|.
name|const_value
operator|=
name|simplified
expr_stmt|;
block|}
else|else
name|defs_to_varying
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Iterate over the FLOW_EDGES work list.  Simulate the target block    for each edge.  */
end_comment

begin_function
specifier|static
name|void
name|examine_flow_edges
parameter_list|()
block|{
while|while
condition|(
name|flow_edges
operator|!=
name|NULL
condition|)
block|{
name|basic_block
name|succ_block
decl_stmt|;
name|rtx
name|curr_phi_node
decl_stmt|;
comment|/* Pull the next block to simulate off the worklist.  */
name|succ_block
operator|=
name|flow_edges
operator|->
name|dest
expr_stmt|;
name|flow_edges
operator|=
name|edge_info
index|[
name|EIE
argument_list|(
name|flow_edges
operator|->
name|src
argument_list|,
name|flow_edges
operator|->
name|dest
argument_list|)
index|]
expr_stmt|;
comment|/* There is nothing to do for the exit block.  */
if|if
condition|(
name|succ_block
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
comment|/* Always simulate PHI nodes, even if we have simulated this block 	 before.  Note that all PHI nodes are consecutive within a block.  */
for|for
control|(
name|curr_phi_node
operator|=
name|first_insn_after_basic_block_note
argument_list|(
name|succ_block
argument_list|)
init|;
name|PHI_NODE_P
argument_list|(
name|curr_phi_node
argument_list|)
condition|;
name|curr_phi_node
operator|=
name|NEXT_INSN
argument_list|(
name|curr_phi_node
argument_list|)
control|)
name|visit_phi_node
argument_list|(
name|curr_phi_node
argument_list|,
name|succ_block
argument_list|)
expr_stmt|;
comment|/* If this is the first time we've simulated this block, then we 	 must simulate each of its insns.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|executable_blocks
argument_list|,
name|succ_block
operator|->
name|index
argument_list|)
condition|)
block|{
name|rtx
name|currinsn
decl_stmt|;
name|edge
name|succ_edge
init|=
name|succ_block
operator|->
name|succ
decl_stmt|;
comment|/* Note that we have simulated this block.  */
name|SET_BIT
argument_list|(
name|executable_blocks
argument_list|,
name|succ_block
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Simulate each insn within the block.  */
name|currinsn
operator|=
name|succ_block
operator|->
name|head
expr_stmt|;
while|while
condition|(
name|currinsn
operator|!=
name|succ_block
operator|->
name|end
condition|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|currinsn
argument_list|)
condition|)
name|visit_expression
argument_list|(
name|currinsn
argument_list|,
name|succ_block
argument_list|)
expr_stmt|;
name|currinsn
operator|=
name|NEXT_INSN
argument_list|(
name|currinsn
argument_list|)
expr_stmt|;
block|}
comment|/* Don't forget the last insn in the block.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|currinsn
argument_list|)
condition|)
name|visit_expression
argument_list|(
name|currinsn
argument_list|,
name|succ_block
argument_list|)
expr_stmt|;
comment|/* If we haven't looked at the next block, and it has a 	     single successor, add it onto the worklist.  This is because 	     if we only have one successor, we know it gets executed, 	     so we don't have to wait for cprop to tell us.  */
if|if
condition|(
name|succ_edge
operator|!=
name|NULL
operator|&&
name|succ_edge
operator|->
name|succ_next
operator|==
name|NULL
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|executable_edges
argument_list|,
name|EIE
argument_list|(
name|succ_edge
operator|->
name|src
argument_list|,
name|succ_edge
operator|->
name|dest
argument_list|)
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|executable_edges
argument_list|,
name|EIE
argument_list|(
name|succ_edge
operator|->
name|src
argument_list|,
name|succ_edge
operator|->
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|edge_info
index|[
name|EIE
argument_list|(
name|succ_edge
operator|->
name|src
argument_list|,
name|succ_edge
operator|->
name|dest
argument_list|)
index|]
operator|=
name|flow_edges
expr_stmt|;
name|flow_edges
operator|=
name|succ_edge
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Follow the def-use chains for each definition on the worklist and    simulate the uses of the definition.  */
end_comment

begin_function
specifier|static
name|void
name|follow_def_use_chains
parameter_list|()
block|{
comment|/* Iterate over all the entries on the SSA_EDGES worklist.  */
while|while
condition|(
name|sbitmap_first_set_bit
argument_list|(
name|ssa_edges
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|int
name|member
decl_stmt|;
name|struct
name|df_link
modifier|*
name|curruse
decl_stmt|;
comment|/* Pick an entry off the worklist (it does not matter which 	 entry we pick).  */
name|member
operator|=
name|sbitmap_first_set_bit
argument_list|(
name|ssa_edges
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|ssa_edges
argument_list|,
name|member
argument_list|)
expr_stmt|;
comment|/* Iterate through all the uses of this entry.  */
for|for
control|(
name|curruse
operator|=
name|df_analyzer
operator|->
name|regs
index|[
name|member
index|]
operator|.
name|uses
init|;
name|curruse
condition|;
name|curruse
operator|=
name|curruse
operator|->
name|next
control|)
block|{
name|rtx
name|useinsn
decl_stmt|;
name|useinsn
operator|=
name|DF_REF_INSN
argument_list|(
name|curruse
operator|->
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|PHI_NODE_P
argument_list|(
name|useinsn
argument_list|)
condition|)
block|{
if|if
condition|(
name|TEST_BIT
argument_list|(
name|executable_blocks
argument_list|,
name|BLOCK_NUM
argument_list|(
name|useinsn
argument_list|)
argument_list|)
condition|)
name|visit_phi_node
argument_list|(
name|useinsn
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|useinsn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TEST_BIT
argument_list|(
name|executable_blocks
argument_list|,
name|BLOCK_NUM
argument_list|(
name|useinsn
argument_list|)
argument_list|)
condition|)
name|visit_expression
argument_list|(
name|useinsn
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|useinsn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Examine each edge to see if we were able to prove any were    not executable.      If an edge is not executable, then we can remove its alternative    in PHI nodes as the destination of the edge, we can simplify the    conditional branch at the source of the edge, and we can remove    the edge from the CFG.  Note we do not delete unreachable blocks    yet as the DF analyzer can not deal with that yet.  */
end_comment

begin_function
specifier|static
name|void
name|optimize_unexecutable_edges
parameter_list|(
name|edges
parameter_list|,
name|executable_edges
parameter_list|)
name|struct
name|edge_list
modifier|*
name|edges
decl_stmt|;
name|sbitmap
name|executable_edges
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EDGES
argument_list|(
name|edges
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|executable_edges
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|edge
name|edge
init|=
name|INDEX_EDGE
argument_list|(
name|edges
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|edge
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
continue|continue;
comment|/* We found an edge that is not executable.  First simplify 	     the PHI nodes in the target block.  */
if|if
condition|(
name|edge
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|rtx
name|insn
init|=
name|first_insn_after_basic_block_note
argument_list|(
name|edge
operator|->
name|dest
argument_list|)
decl_stmt|;
while|while
condition|(
name|PHI_NODE_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|remove_phi_alternative
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|edge
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Removing alternative for bb %d of phi %d\n"
argument_list|,
name|edge
operator|->
name|src
operator|->
name|index
argument_list|,
name|SSA_NAME
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Removing unexecutable edge from %d to %d\n"
argument_list|,
name|edge
operator|->
name|src
operator|->
name|index
argument_list|,
name|edge
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Since the edge was not executable, remove it from the CFG.  */
name|remove_edge
argument_list|(
name|edge
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We have removed all the unexecutable edges from the CFG.  Fix up      the conditional jumps at the end of any affected block.       We have three cases to deal with:         a. Both outgoing edges are not executable.  This happens if the 	  source block is not reachable.  We will deal with this by 	  deleting all the insns in the block later.         b. The fall-thru edge is not executable.  In this case we 	  change the conditional jump into an unconditional jump and 	  add a BARRIER after the unconditional jump.  Note that since 	  we are working on generic RTL we can change the jump in-place 	  instead of dealing with the headache of reemitting the jump.         c. The branch taken edge is not executable.  In this case 	  we turn the jump into (set (pc) (pc)) which is a nop-jump           and we will remove the unrecognizable insn later.       In cases B& C we are removing uses of registers, so make sure      to note those changes for the DF analyzer.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rtx
name|insn
init|=
name|bb
operator|->
name|end
decl_stmt|;
name|edge
name|edge
init|=
name|bb
operator|->
name|succ
decl_stmt|;
comment|/* If we have no predecessors, then this block is unreachable and 	 will be cleaned up when we remove unreachable blocks.  */
if|if
condition|(
name|bb
operator|->
name|pred
operator|==
name|NULL
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
continue|continue;
comment|/* If this block ends in a conditional jump, but only has one 	 successor, then the jump needs adjustment.  */
if|if
condition|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|bb
operator|->
name|succ
operator|&&
name|bb
operator|->
name|succ
operator|->
name|succ_next
operator|==
name|NULL
condition|)
block|{
comment|/* If the fallthru edge is the executable edge, then turn 	     this jump into a nop jump, otherwise make it an unconditinoal 	     jump to its target.  */
if|if
condition|(
name|edge
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
block|}
else|else
block|{
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier_after
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Inform the DF analyzer that this insn changed.  */
name|df_insn_modify
argument_list|(
name|df_analyzer
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Perform substitution of known values for pseudo registers.     ??? Note we do not do simplifications or constant folding here, it    is unlikely that any significant simplifications can be done here    anyway.  Consider that if the simplification would result in an    expression that produces a constant value that the value would    have been discovered and recorded already.        We perform two transformations.  First, we initialize pseudos to their    known constant values at their definition point.  Second, we try to    replace uses with the known constant value.  */
end_comment

begin_function
specifier|static
name|void
name|ssa_ccp_substitute_constants
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|VARRAY_SIZE
argument_list|(
name|ssa_definition
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|values
index|[
name|i
index|]
operator|.
name|lattice_val
operator|==
name|CONSTANT
condition|)
block|{
name|rtx
name|def
init|=
name|VARRAY_RTX
argument_list|(
name|ssa_definition
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|struct
name|df_link
modifier|*
name|curruse
decl_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
continue|continue;
comment|/* Do not try to simplify PHI nodes down to a constant load. 	     That will be done later as we translate out of SSA.  Also, 	     doing that here could violate the rule that all PHI nodes 	     are consecutive at the start of the basic block.  	     Don't do anything to nodes that were already sets to 	     constants.	 */
if|if
condition|(
operator|!
name|PHI_NODE_P
argument_list|(
name|def
argument_list|)
operator|&&
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|def
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Register %d is now set to a constant\n"
argument_list|,
name|SSA_NAME
argument_list|(
name|PATTERN
argument_list|(
name|def
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|=
name|values
index|[
name|i
index|]
operator|.
name|const_value
expr_stmt|;
name|INSN_CODE
argument_list|(
name|def
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|df_insn_modify
argument_list|(
name|df_analyzer
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|def
argument_list|)
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
comment|/* Iterate through all the uses of this entry and try replacements 	     there too.  Note it is not particularly profitable to try 	     and fold/simplify expressions here as most of the common 	     cases were handled above.  */
for|for
control|(
name|curruse
operator|=
name|df_analyzer
operator|->
name|regs
index|[
name|i
index|]
operator|.
name|uses
init|;
name|curruse
condition|;
name|curruse
operator|=
name|curruse
operator|->
name|next
control|)
block|{
name|rtx
name|useinsn
decl_stmt|;
name|useinsn
operator|=
name|DF_REF_INSN
argument_list|(
name|curruse
operator|->
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_DELETED_P
argument_list|(
name|useinsn
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|useinsn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|useinsn
argument_list|)
operator|==
name|NOTE_INSN_DELETED
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|useinsn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|useinsn
argument_list|)
operator|==
name|JUMP_INSN
operator|)
condition|)
block|{
if|if
condition|(
name|validate_replace_src
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
name|values
index|[
name|i
index|]
operator|.
name|const_value
argument_list|,
name|useinsn
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Register %d in insn %d replaced with constant\n"
argument_list|,
name|i
argument_list|,
name|INSN_UID
argument_list|(
name|useinsn
argument_list|)
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|useinsn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|df_insn_modify
argument_list|(
name|df_analyzer
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|useinsn
argument_list|)
argument_list|,
name|useinsn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Now find all unreachable basic blocks.  All the insns in those    blocks are unreachable, so delete them and mark any necessary    updates for the DF analyzer.  */
end_comment

begin_function
specifier|static
name|void
name|ssa_ccp_df_delete_unreachable_insns
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* Use the CFG to find all the reachable blocks.  */
name|find_unreachable_blocks
argument_list|()
expr_stmt|;
comment|/* Now we know what blocks are not reachable.  Mark all the insns      in those blocks as deleted for the DF analyzer.   We'll let the      normal flow code actually remove the unreachable blocks.  */
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|basic_block
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|b
operator|->
name|flags
operator|&
name|BB_REACHABLE
operator|)
condition|)
block|{
name|rtx
name|start
init|=
name|b
operator|->
name|head
decl_stmt|;
name|rtx
name|end
init|=
name|b
operator|->
name|end
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
comment|/* Include any jump table following the basic block.  */
name|end
operator|=
name|b
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|end
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|tmp
operator|=
name|JUMP_LABEL
argument_list|(
name|end
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
operator|(
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
name|end
operator|=
name|tmp
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|start
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|start
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|start
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|start
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|df_insn_delete
argument_list|(
name|df_analyzer
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|start
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|end
condition|)
break|break;
name|start
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Main entry point for SSA Conditional Constant Propagation.     Long term it should accept as input the specific flow graph to    operate on so that it can be called for sub-graphs.  */
end_comment

begin_function
name|void
name|ssa_const_prop
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|edge
name|curredge
decl_stmt|;
comment|/* We need alias analysis (for what?) */
name|init_alias_analysis
argument_list|()
expr_stmt|;
name|df_analyzer
operator|=
name|df_init
argument_list|()
expr_stmt|;
name|df_analyse
argument_list|(
name|df_analyzer
argument_list|,
literal|0
argument_list|,
name|DF_RD_CHAIN
operator||
name|DF_RU_CHAIN
operator||
name|DF_REG_INFO
operator||
name|DF_HARD_REGS
argument_list|)
expr_stmt|;
comment|/* We need mappings from insn to its containing block.  */
name|compute_bb_for_insn
argument_list|(
name|get_max_uid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Perform a quick and dirty dead code elimination pass.  This is not      as aggressive as it could be, but it's good enough to clean up a      lot of unwanted junk and it is fast.  */
name|ssa_fast_dce
argument_list|(
name|df_analyzer
argument_list|)
expr_stmt|;
comment|/* Build an edge list from the CFG.  */
name|edges
operator|=
name|create_edge_list
argument_list|()
expr_stmt|;
comment|/* Initialize the values array with everything as undefined.  */
name|values
operator|=
operator|(
name|value
operator|*
operator|)
name|xmalloc
argument_list|(
name|VARRAY_SIZE
argument_list|(
name|ssa_definition
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VARRAY_SIZE
argument_list|(
name|ssa_definition
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|values
index|[
name|i
index|]
operator|.
name|lattice_val
operator|=
name|VARYING
expr_stmt|;
else|else
name|values
index|[
name|i
index|]
operator|.
name|lattice_val
operator|=
name|UNDEFINED
expr_stmt|;
name|values
index|[
name|i
index|]
operator|.
name|const_value
operator|=
name|NULL
expr_stmt|;
block|}
name|ssa_edges
operator|=
name|sbitmap_alloc
argument_list|(
name|VARRAY_SIZE
argument_list|(
name|ssa_definition
argument_list|)
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|ssa_edges
argument_list|)
expr_stmt|;
name|executable_blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|executable_blocks
argument_list|)
expr_stmt|;
name|executable_edges
operator|=
name|sbitmap_alloc
argument_list|(
name|NUM_EDGES
argument_list|(
name|edges
argument_list|)
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|executable_edges
argument_list|)
expr_stmt|;
name|edge_info
operator|=
operator|(
name|edge
operator|*
operator|)
name|xmalloc
argument_list|(
name|NUM_EDGES
argument_list|(
name|edges
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
name|flow_edges
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
expr_stmt|;
comment|/* Add the successors of the entry block to the edge worklist.  That      is enough of a seed to get SSA-CCP started.  */
for|for
control|(
name|curredge
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
init|;
name|curredge
condition|;
name|curredge
operator|=
name|curredge
operator|->
name|succ_next
control|)
block|{
name|int
name|index
init|=
name|EIE
argument_list|(
name|curredge
operator|->
name|src
argument_list|,
name|curredge
operator|->
name|dest
argument_list|)
decl_stmt|;
name|SET_BIT
argument_list|(
name|executable_edges
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|edge_info
index|[
name|index
index|]
operator|=
name|curredge
operator|->
name|succ_next
expr_stmt|;
block|}
comment|/* Iterate until until the worklists are empty.  */
do|do
block|{
name|examine_flow_edges
argument_list|()
expr_stmt|;
name|follow_def_use_chains
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|flow_edges
operator|!=
name|NULL
condition|)
do|;
comment|/* Now perform substitutions based on the known constant values.  */
name|ssa_ccp_substitute_constants
argument_list|()
expr_stmt|;
comment|/* Remove unexecutable edges from the CFG and make appropriate      adjustments to PHI nodes.  */
name|optimize_unexecutable_edges
argument_list|(
name|edges
argument_list|,
name|executable_edges
argument_list|)
expr_stmt|;
comment|/* Now remove all unreachable insns and update the DF information.      as appropriate.  */
name|ssa_ccp_df_delete_unreachable_insns
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The DF analyzer expects the number of blocks to remain constant,      so we can't remove unreachable blocks.       Code the DF analyzer calls expects there to be no unreachable      blocks in the CFG.  So we can't leave unreachable blocks in the      CFG.       So, there is no way to do an incremental update of the DF data      at this point.  */
block|df_analyse (df_analyzer, 0, 	      DF_RD_CHAIN | DF_RU_CHAIN | DF_REG_INFO | DF_HARD_REGS);
endif|#
directive|endif
comment|/* Clean up any dead code exposed by SSA-CCP, do this after updating      the dataflow information!  */
name|ssa_fast_dce
argument_list|(
name|df_analyzer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|values
argument_list|)
expr_stmt|;
name|values
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|edge_info
argument_list|)
expr_stmt|;
name|edge_info
operator|=
name|NULL
expr_stmt|;
name|sbitmap_free
argument_list|(
name|executable_blocks
argument_list|)
expr_stmt|;
name|executable_blocks
operator|=
name|NULL
expr_stmt|;
name|sbitmap_free
argument_list|(
name|ssa_edges
argument_list|)
expr_stmt|;
name|ssa_edges
operator|=
name|NULL
expr_stmt|;
name|free_edge_list
argument_list|(
name|edges
argument_list|)
expr_stmt|;
name|edges
operator|=
name|NULL
expr_stmt|;
name|sbitmap_free
argument_list|(
name|executable_edges
argument_list|)
expr_stmt|;
name|executable_edges
operator|=
name|NULL
expr_stmt|;
name|df_finish
argument_list|(
name|df_analyzer
argument_list|)
expr_stmt|;
name|end_alias_analysis
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mark_references
parameter_list|(
name|current_rtx
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|current_rtx
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|current_rtx
decl_stmt|;
name|sbitmap
name|worklist
init|=
operator|(
name|sbitmap
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
name|rtx
name|reg
decl_stmt|;
name|reg
operator|=
name|dest
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
name|SET_BIT
argument_list|(
name|worklist
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|for_each_rtx
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|mark_references
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|SET_BIT
argument_list|(
name|worklist
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ssa_fast_dce
parameter_list|(
name|df
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
block|{
name|sbitmap
name|worklist
init|=
name|sbitmap_alloc
argument_list|(
name|VARRAY_SIZE
argument_list|(
name|ssa_definition
argument_list|)
argument_list|)
decl_stmt|;
name|sbitmap_ones
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
comment|/* Iterate on the worklist until there's no definitions left to      examine.  */
while|while
condition|(
name|sbitmap_first_set_bit
argument_list|(
name|worklist
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|struct
name|df_link
modifier|*
name|curruse
decl_stmt|;
name|int
name|reg
decl_stmt|,
name|found_use
decl_stmt|;
comment|/* Remove an item from the worklist.  */
name|reg
operator|=
name|sbitmap_first_set_bit
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|worklist
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* We never consider deleting assignments to hard regs or things 	 which do not have SSA definitions, or things we have already 	 deleted, or things with unusual side effects.  */
if|if
condition|(
name|reg
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|VARRAY_RTX
argument_list|(
name|ssa_definition
argument_list|,
name|reg
argument_list|)
operator|||
name|INSN_DELETED_P
argument_list|(
name|VARRAY_RTX
argument_list|(
name|ssa_definition
argument_list|,
name|reg
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|VARRAY_RTX
argument_list|(
name|ssa_definition
argument_list|,
name|reg
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|VARRAY_RTX
argument_list|(
name|ssa_definition
argument_list|,
name|reg
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_DELETED
operator|)
operator|)
operator|||
name|side_effects_p
argument_list|(
name|PATTERN
argument_list|(
name|VARRAY_RTX
argument_list|(
name|ssa_definition
argument_list|,
name|reg
argument_list|)
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Iterate over the uses of this register.  If we can not find 	 any uses that have not been deleted, then the definition of 	 this register is dead.  */
name|found_use
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|curruse
operator|=
name|df
operator|->
name|regs
index|[
name|reg
index|]
operator|.
name|uses
init|;
name|curruse
condition|;
name|curruse
operator|=
name|curruse
operator|->
name|next
control|)
block|{
if|if
condition|(
name|curruse
operator|->
name|ref
operator|&&
name|DF_REF_INSN
argument_list|(
name|curruse
operator|->
name|ref
argument_list|)
operator|&&
operator|!
name|INSN_DELETED_P
argument_list|(
name|DF_REF_INSN
argument_list|(
name|curruse
operator|->
name|ref
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|DF_REF_INSN
argument_list|(
name|curruse
operator|->
name|ref
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|DF_REF_INSN
argument_list|(
name|curruse
operator|->
name|ref
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_DELETED
operator|)
operator|)
operator|&&
name|DF_REF_INSN
argument_list|(
name|curruse
operator|->
name|ref
argument_list|)
operator|!=
name|VARRAY_RTX
argument_list|(
name|ssa_definition
argument_list|,
name|reg
argument_list|)
condition|)
block|{
name|found_use
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we did not find a use of this register, then the definition 	 of this register is dead.  */
if|if
condition|(
operator|!
name|found_use
condition|)
block|{
name|rtx
name|def
init|=
name|VARRAY_RTX
argument_list|(
name|ssa_definition
argument_list|,
name|reg
argument_list|)
decl_stmt|;
comment|/* Add all registers referenced by INSN to the work 	     list.  */
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|def
argument_list|)
argument_list|,
name|mark_references
argument_list|,
name|worklist
argument_list|)
expr_stmt|;
comment|/* Inform the analyzer that this insn is going to be 	     deleted.  */
name|df_insn_delete
argument_list|(
name|df
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|def
argument_list|)
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|VARRAY_RTX
argument_list|(
name|ssa_definition
argument_list|,
name|reg
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|sbitmap_free
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

