begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Graph coloring register allocator    Copyright (C) 2001, 2002 Free Software Foundation, Inc.    Contributed by Michael Matz<matz@suse.de>    and Daniel Berlin<dan@cgsoftware.com>.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the    terms of the GNU General Public License as published by the Free Software    Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more    details.     You should have received a copy of the GNU General Public License along    with GCC; see the file COPYING.  If not, write to the Free Software    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"df.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"ra.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_comment
comment|/* This file is part of the graph coloring register allocator, and    contains the functions to change the insn stream.  I.e. it adds    spill code, rewrites insns to use the new registers after    coloring and deletes coalesced moves.  */
end_comment

begin_struct_decl
struct_decl|struct
name|rewrite_info
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|rtx_list
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|void
name|spill_coalescing
name|PARAMS
argument_list|(
operator|(
name|sbitmap
operator|,
name|sbitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|spill_prop_savings
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|,
name|sbitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|spill_prop_insert
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|,
name|sbitmap
operator|,
name|sbitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|spill_propagation
name|PARAMS
argument_list|(
operator|(
name|sbitmap
operator|,
name|sbitmap
operator|,
name|sbitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|spill_coalprop
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|allocate_spill_web
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|choose_spill_colors
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rewrite_program
name|PARAMS
argument_list|(
operator|(
name|bitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remember_slot
name|PARAMS
argument_list|(
operator|(
expr|struct
name|rtx_list
operator|*
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|slots_overlap_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_overlapping_slots
name|PARAMS
argument_list|(
operator|(
expr|struct
name|rtx_list
operator|*
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|slot_member_p
name|PARAMS
argument_list|(
operator|(
expr|struct
name|rtx_list
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_stores
name|PARAMS
argument_list|(
operator|(
name|bitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|spill_same_color_p
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|,
expr|struct
name|web
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|is_partly_live_1
name|PARAMS
argument_list|(
operator|(
name|sbitmap
operator|,
expr|struct
name|web
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_spill_colors
name|PARAMS
argument_list|(
operator|(
name|HARD_REG_SET
operator|*
operator|,
expr|struct
name|web
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|spill_is_free
name|PARAMS
argument_list|(
operator|(
name|HARD_REG_SET
operator|*
operator|,
expr|struct
name|web
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_loads
name|PARAMS
argument_list|(
operator|(
expr|struct
name|rewrite_info
operator|*
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reloads_to_loads
name|PARAMS
argument_list|(
operator|(
expr|struct
name|rewrite_info
operator|*
operator|,
expr|struct
name|ref
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|web
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rewrite_program2
name|PARAMS
argument_list|(
operator|(
name|bitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_refs_for_checking
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|,
name|bitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|detect_web_parts_to_rebuild
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_useless_defs
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|detect_non_changed_webs
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reset_changed_flag
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For tracking some statistics, we count the number (and cost)    of deleted move insns.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|deleted_move_insns
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|deleted_move_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the spill coalescing phase.  In SPILLED the IDs of all    already spilled webs are noted.  In COALESCED the IDs of webs still    to check for coalescing.  This tries to coalesce two webs, which were    spilled, are connected by a move, and don't conflict.  Greatly    reduces memory shuffling.  */
end_comment

begin_function
specifier|static
name|void
name|spill_coalescing
parameter_list|(
name|coalesce
parameter_list|,
name|spilled
parameter_list|)
name|sbitmap
name|coalesce
decl_stmt|,
name|spilled
decl_stmt|;
block|{
name|struct
name|move_list
modifier|*
name|ml
decl_stmt|;
name|struct
name|move
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|ml
operator|=
name|wl_moves
init|;
name|ml
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|m
operator|=
name|ml
operator|->
name|move
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|web
modifier|*
name|s
init|=
name|alias
argument_list|(
name|m
operator|->
name|source_web
argument_list|)
decl_stmt|;
name|struct
name|web
modifier|*
name|t
init|=
name|alias
argument_list|(
name|m
operator|->
name|target_web
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TEST_BIT
argument_list|(
name|spilled
argument_list|,
name|s
operator|->
name|id
argument_list|)
operator|&&
name|TEST_BIT
argument_list|(
name|coalesce
argument_list|,
name|t
operator|->
name|id
argument_list|)
operator|)
operator|||
operator|(
name|TEST_BIT
argument_list|(
name|spilled
argument_list|,
name|t
operator|->
name|id
argument_list|)
operator|&&
name|TEST_BIT
argument_list|(
name|coalesce
argument_list|,
name|s
operator|->
name|id
argument_list|)
operator|)
condition|)
block|{
name|struct
name|conflict_link
modifier|*
name|wl
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|s
operator|->
name|id
operator|*
name|num_webs
operator|+
name|t
operator|->
name|id
argument_list|)
operator|||
name|TEST_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|t
operator|->
name|id
operator|*
name|num_webs
operator|+
name|s
operator|->
name|id
argument_list|)
operator|||
name|s
operator|->
name|pattern
operator|||
name|t
operator|->
name|pattern
condition|)
continue|continue;
name|deleted_move_insns
operator|++
expr_stmt|;
name|deleted_move_cost
operator|+=
name|BLOCK_FOR_INSN
argument_list|(
name|m
operator|->
name|insn
argument_list|)
operator|->
name|frequency
operator|+
literal|1
expr_stmt|;
name|PUT_CODE
argument_list|(
name|m
operator|->
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|m
operator|->
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|df_insn_modify
argument_list|(
name|df
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|,
name|m
operator|->
name|insn
argument_list|)
expr_stmt|;
name|m
operator|->
name|target_web
operator|->
name|target_of_spilled_move
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|t
condition|)
comment|/* May be, already coalesced due to a former move.  */
continue|continue;
comment|/* Merge the nodes S and T in the I-graph.  Beware: the merging 	       of conflicts relies on the fact, that in the conflict list 	       of T all of it's conflicts are noted.  This is currently not 	       the case if T would be the target of a coalesced web, because 	       then (in combine () above) only those conflicts were noted in 	       T from the web which was coalesced into T, which at the time 	       of combine() were not already on the SELECT stack or were 	       itself coalesced to something other.  */
if|if
condition|(
name|t
operator|->
name|type
operator|!=
name|SPILLED
operator|||
name|s
operator|->
name|type
operator|!=
name|SPILLED
condition|)
name|abort
argument_list|()
expr_stmt|;
name|remove_list
argument_list|(
name|t
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|SPILLED
argument_list|)
argument_list|)
expr_stmt|;
name|put_web
argument_list|(
name|t
argument_list|,
name|COALESCED
argument_list|)
expr_stmt|;
name|t
operator|->
name|alias
operator|=
name|s
expr_stmt|;
name|s
operator|->
name|is_coalesced
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|is_coalesced
operator|=
literal|1
expr_stmt|;
name|merge_moves
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|wl
operator|=
name|t
operator|->
name|conflict_list
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|pweb
init|=
name|wl
operator|->
name|t
decl_stmt|;
if|if
condition|(
name|wl
operator|->
name|sub
operator|==
name|NULL
condition|)
name|record_conflict
argument_list|(
name|s
argument_list|,
name|pweb
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|sub_conflict
modifier|*
name|sl
decl_stmt|;
for|for
control|(
name|sl
operator|=
name|wl
operator|->
name|sub
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|sweb
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|SUBWEB_P
argument_list|(
name|sl
operator|->
name|s
argument_list|)
condition|)
name|sweb
operator|=
name|find_subweb
argument_list|(
name|s
argument_list|,
name|sl
operator|->
name|s
operator|->
name|orig_x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sweb
condition|)
name|sweb
operator|=
name|s
expr_stmt|;
name|record_conflict
argument_list|(
name|sweb
argument_list|,
name|sl
operator|->
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* No decrement_degree here, because we already have colored 		   the graph, and don't want to insert pweb into any other 		   list.  */
name|pweb
operator|->
name|num_conflicts
operator|-=
literal|1
operator|+
name|t
operator|->
name|add_hardregs
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Returns the probable saving of coalescing WEB with webs from    SPILLED, in terms of removed move insn cost.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|spill_prop_savings
parameter_list|(
name|web
parameter_list|,
name|spilled
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
name|sbitmap
name|spilled
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|savings
init|=
literal|0
decl_stmt|;
name|struct
name|move_list
modifier|*
name|ml
decl_stmt|;
name|struct
name|move
modifier|*
name|m
decl_stmt|;
name|unsigned
name|int
name|cost
decl_stmt|;
if|if
condition|(
name|web
operator|->
name|pattern
condition|)
return|return
literal|0
return|;
name|cost
operator|=
literal|1
operator|+
name|MEMORY_MOVE_COST
argument_list|(
name|GET_MODE
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
argument_list|,
name|web
operator|->
name|regclass
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cost
operator|+=
literal|1
operator|+
name|MEMORY_MOVE_COST
argument_list|(
name|GET_MODE
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
argument_list|,
name|web
operator|->
name|regclass
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ml
operator|=
name|wl_moves
init|;
name|ml
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|m
operator|=
name|ml
operator|->
name|move
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|web
modifier|*
name|s
init|=
name|alias
argument_list|(
name|m
operator|->
name|source_web
argument_list|)
decl_stmt|;
name|struct
name|web
modifier|*
name|t
init|=
name|alias
argument_list|(
name|m
operator|->
name|target_web
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|web
condition|)
block|{
name|struct
name|web
modifier|*
name|h
init|=
name|s
decl_stmt|;
name|s
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|h
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|!=
name|web
operator|||
operator|!
name|TEST_BIT
argument_list|(
name|spilled
argument_list|,
name|t
operator|->
name|id
argument_list|)
operator|||
name|t
operator|->
name|pattern
operator|||
name|TEST_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|s
operator|->
name|id
operator|*
name|num_webs
operator|+
name|t
operator|->
name|id
argument_list|)
operator|||
name|TEST_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|t
operator|->
name|id
operator|*
name|num_webs
operator|+
name|s
operator|->
name|id
argument_list|)
condition|)
continue|continue;
name|savings
operator|+=
name|BLOCK_FOR_INSN
argument_list|(
name|m
operator|->
name|insn
argument_list|)
operator|->
name|frequency
operator|*
name|cost
expr_stmt|;
block|}
return|return
name|savings
return|;
block|}
end_function

begin_comment
comment|/* This add all IDs of colored webs, which are connected to WEB by a move    to LIST and PROCESSED.  */
end_comment

begin_function
specifier|static
name|void
name|spill_prop_insert
parameter_list|(
name|web
parameter_list|,
name|list
parameter_list|,
name|processed
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
name|sbitmap
name|list
decl_stmt|,
name|processed
decl_stmt|;
block|{
name|struct
name|move_list
modifier|*
name|ml
decl_stmt|;
name|struct
name|move
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|ml
operator|=
name|wl_moves
init|;
name|ml
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|m
operator|=
name|ml
operator|->
name|move
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|web
modifier|*
name|s
init|=
name|alias
argument_list|(
name|m
operator|->
name|source_web
argument_list|)
decl_stmt|;
name|struct
name|web
modifier|*
name|t
init|=
name|alias
argument_list|(
name|m
operator|->
name|target_web
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|web
condition|)
block|{
name|struct
name|web
modifier|*
name|h
init|=
name|s
decl_stmt|;
name|s
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|h
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|!=
name|web
operator|||
name|t
operator|->
name|type
operator|!=
name|COLORED
operator|||
name|TEST_BIT
argument_list|(
name|processed
argument_list|,
name|t
operator|->
name|id
argument_list|)
condition|)
continue|continue;
name|SET_BIT
argument_list|(
name|list
argument_list|,
name|t
operator|->
name|id
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|processed
argument_list|,
name|t
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The spill propagation pass.  If we have to spilled webs, the first    connected through a move to a colored one, and the second also connected    to that colored one, and this colored web is only used to connect both    spilled webs, it might be worthwhile to spill that colored one.    This is the case, if the cost of the removed copy insns (all three webs    could be placed into the same stack slot) is higher than the spill cost    of the web.    TO_PROP are the webs we try to propagate from (i.e. spilled ones),    SPILLED the set of all spilled webs so far and PROCESSED the set    of all webs processed so far, so we don't do work twice.  */
end_comment

begin_function
specifier|static
name|int
name|spill_propagation
parameter_list|(
name|to_prop
parameter_list|,
name|spilled
parameter_list|,
name|processed
parameter_list|)
name|sbitmap
name|to_prop
decl_stmt|,
name|spilled
decl_stmt|,
name|processed
decl_stmt|;
block|{
name|int
name|id
decl_stmt|;
name|int
name|again
init|=
literal|0
decl_stmt|;
name|sbitmap
name|list
init|=
name|sbitmap_alloc
argument_list|(
name|num_webs
argument_list|)
decl_stmt|;
name|sbitmap_zero
argument_list|(
name|list
argument_list|)
expr_stmt|;
comment|/* First insert colored move neighbors into the candidate list.  */
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|to_prop
argument_list|,
literal|0
argument_list|,
argument|id
argument_list|,
argument|{       spill_prop_insert (ID2WEB (id), list, processed);     }
argument_list|)
empty_stmt|;
name|sbitmap_zero
argument_list|(
name|to_prop
argument_list|)
expr_stmt|;
comment|/* For all candidates, see, if the savings are higher than it's      spill cost.  */
while|while
condition|(
operator|(
name|id
operator|=
name|sbitmap_first_set_bit
argument_list|(
name|list
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|ID2WEB
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|RESET_BIT
argument_list|(
name|list
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|spill_prop_savings
argument_list|(
name|web
argument_list|,
name|spilled
argument_list|)
operator|>=
name|web
operator|->
name|spill_cost
condition|)
block|{
comment|/* If so, we found a new spilled web.  Insert it's colored 	     move neighbors again, and mark, that we need to repeat the 	     whole mainloop of spillprog/coalescing again.  */
name|remove_web_from_list
argument_list|(
name|web
argument_list|)
expr_stmt|;
name|web
operator|->
name|color
operator|=
operator|-
literal|1
expr_stmt|;
name|put_web
argument_list|(
name|web
argument_list|,
name|SPILLED
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|spilled
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|to_prop
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|spill_prop_insert
argument_list|(
name|web
argument_list|,
name|list
argument_list|,
name|processed
argument_list|)
expr_stmt|;
name|again
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|sbitmap_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|again
return|;
block|}
end_function

begin_comment
comment|/* The main phase to improve spill costs.  This repeatedly runs    spill coalescing and spill propagation, until nothing changes.  */
end_comment

begin_function
specifier|static
name|void
name|spill_coalprop
parameter_list|()
block|{
name|sbitmap
name|spilled
decl_stmt|,
name|processed
decl_stmt|,
name|to_prop
decl_stmt|;
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
name|int
name|again
decl_stmt|;
name|spilled
operator|=
name|sbitmap_alloc
argument_list|(
name|num_webs
argument_list|)
expr_stmt|;
name|processed
operator|=
name|sbitmap_alloc
argument_list|(
name|num_webs
argument_list|)
expr_stmt|;
name|to_prop
operator|=
name|sbitmap_alloc
argument_list|(
name|num_webs
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|spilled
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|SPILLED
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|SET_BIT
argument_list|(
name|spilled
argument_list|,
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
operator|->
name|id
argument_list|)
expr_stmt|;
name|sbitmap_copy
argument_list|(
name|to_prop
argument_list|,
name|spilled
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|processed
argument_list|)
expr_stmt|;
do|do
block|{
name|spill_coalescing
argument_list|(
name|to_prop
argument_list|,
name|spilled
argument_list|)
expr_stmt|;
comment|/* XXX Currently (with optimistic coalescing) spill_propagation() 	 doesn't give better code, sometimes it gives worse (but not by much) 	 code.  I believe this is because of slightly wrong cost 	 measurements.  Anyway right now it isn't worth the time it takes, 	 so deactivate it for now.  */
name|again
operator|=
literal|0
operator|&&
name|spill_propagation
argument_list|(
name|to_prop
argument_list|,
name|spilled
argument_list|,
name|processed
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|again
condition|)
do|;
name|sbitmap_free
argument_list|(
name|to_prop
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|processed
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|spilled
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate a spill slot for a WEB.  Currently we spill to pseudo    registers, to be able to track also webs for "stack slots", and also    to possibly colorize them.  These pseudos are sometimes handled    in a special way, where we know, that they also can represent    MEM references.  */
end_comment

begin_function
specifier|static
name|void
name|allocate_spill_web
parameter_list|(
name|web
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
block|{
name|int
name|regno
init|=
name|web
operator|->
name|regno
decl_stmt|;
name|rtx
name|slot
decl_stmt|;
if|if
condition|(
name|web
operator|->
name|stack_slot
condition|)
return|return;
name|slot
operator|=
name|gen_reg_rtx
argument_list|(
name|PSEUDO_REGNO_MODE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|web
operator|->
name|stack_slot
operator|=
name|slot
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This chooses a color for all SPILLED webs for interference region    spilling.  The heuristic isn't good in any way.  */
end_comment

begin_function
specifier|static
name|void
name|choose_spill_colors
parameter_list|()
block|{
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|costs
init|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|)
name|xmalloc
argument_list|(
name|FIRST_PSEUDO_REGISTER
operator|*
sizeof|sizeof
argument_list|(
name|costs
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|SPILLED
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|struct
name|conflict_link
modifier|*
name|wl
decl_stmt|;
name|int
name|bestc
decl_stmt|,
name|c
decl_stmt|;
name|HARD_REG_SET
name|avail
decl_stmt|;
name|memset
argument_list|(
name|costs
argument_list|,
literal|0
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|*
sizeof|sizeof
argument_list|(
name|costs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|wl
operator|=
name|web
operator|->
name|conflict_list
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|pweb
init|=
name|wl
operator|->
name|t
decl_stmt|;
if|if
condition|(
name|pweb
operator|->
name|type
operator|==
name|COLORED
operator|||
name|pweb
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
name|costs
index|[
name|pweb
operator|->
name|color
index|]
operator|+=
name|pweb
operator|->
name|spill_cost
expr_stmt|;
block|}
name|COPY_HARD_REG_SET
argument_list|(
name|avail
argument_list|,
name|web
operator|->
name|usable_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|crosses_call
condition|)
block|{
comment|/* Add an arbitrary constant cost to colors not usable by 	     call-crossing webs without saves/loads.  */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|call_used_reg_set
argument_list|,
name|c
argument_list|)
condition|)
name|costs
index|[
name|c
index|]
operator|+=
literal|1000
expr_stmt|;
block|}
name|bestc
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|bestc
operator|<
literal|0
operator|||
name|costs
index|[
name|bestc
index|]
operator|>
name|costs
index|[
name|c
index|]
operator|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|avail
argument_list|,
name|c
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|c
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|web
operator|->
name|regno
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
name|size
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|c
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|web
operator|->
name|regno
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|size
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|avail
argument_list|,
name|c
operator|+
name|i
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
name|size
condition|)
name|bestc
operator|=
name|c
expr_stmt|;
block|}
name|web
operator|->
name|color
operator|=
name|bestc
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_PROCESS
argument_list|,
literal|"choosing color %d for spilled web %d\n"
argument_list|,
name|bestc
argument_list|,
name|web
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|costs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For statistics sake we count the number and cost of all new loads,    stores and emitted rematerializations.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|emitted_spill_loads
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|emitted_spill_stores
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|emitted_remat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|spill_load_cost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|spill_store_cost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|spill_remat_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In rewrite_program2() we detect if some def us useless, in the sense,    that the pseudo set is not live anymore at that point.  The REF_IDs    of such defs are noted here.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|useless_defs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the simple and fast version of rewriting the program to    include spill code.  It spills at every insn containing spilled    defs or uses.  Loads are added only if flag_ra_spill_every_use is    nonzero, otherwise only stores will be added.  This doesn't    support rematerialization.     NEW_DEATHS is filled with uids for insns, which probably contain    deaths.  */
end_comment

begin_function
specifier|static
name|void
name|rewrite_program
parameter_list|(
name|new_deaths
parameter_list|)
name|bitmap
name|new_deaths
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
name|bitmap
name|b
init|=
name|BITMAP_XMALLOC
argument_list|()
decl_stmt|;
comment|/* We walk over all webs, over all uses/defs.  For all webs, we need      to look at spilled webs, and webs coalesced to spilled ones, in case      their alias isn't broken up, or they got spill coalesced.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
for|for
control|(
name|d
operator|=
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
name|WEBS
argument_list|(
name|SPILLED
argument_list|)
else|:
name|WEBS
argument_list|(
name|COALESCED
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|struct
name|web
modifier|*
name|aweb
init|=
name|alias
argument_list|(
name|web
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|rtx
name|slot
decl_stmt|;
comment|/* Is trivially true for spilled webs, but not for coalesced ones.  */
if|if
condition|(
name|aweb
operator|->
name|type
operator|!=
name|SPILLED
condition|)
continue|continue;
comment|/* First add loads before every use, if we have to.  */
if|if
condition|(
name|flag_ra_spill_every_use
condition|)
block|{
name|bitmap_clear
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|allocate_spill_web
argument_list|(
name|aweb
argument_list|)
expr_stmt|;
name|slot
operator|=
name|aweb
operator|->
name|stack_slot
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|web
operator|->
name|num_uses
condition|;
name|j
operator|++
control|)
block|{
name|rtx
name|insns
decl_stmt|,
name|target
decl_stmt|,
name|source
decl_stmt|;
name|rtx
name|insn
init|=
name|DF_REF_INSN
argument_list|(
name|web
operator|->
name|uses
index|[
name|j
index|]
argument_list|)
decl_stmt|;
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Happens when spill_coalescing() deletes move insns.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* Check that we didn't already added a load for this web 		   and insn.  Happens, when the an insn uses the same web 		   multiple times.  */
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|b
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
continue|continue;
name|bitmap_set_bit
argument_list|(
name|b
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|DF_REF_REG
argument_list|(
name|web
operator|->
name|uses
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|source
operator|=
name|slot
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|SUBREG
condition|)
name|source
operator|=
name|simplify_gen_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|source
argument_list|,
name|GET_MODE
argument_list|(
name|source
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|ra_emit_move_insn
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|insns
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|head
operator|==
name|insn
condition|)
name|bb
operator|->
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|insn
operator|!=
name|prev
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|set_block_for_insn
argument_list|(
name|insn
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|df_insn_modify
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|emitted_spill_loads
operator|++
expr_stmt|;
name|spill_load_cost
operator|+=
name|bb
operator|->
name|frequency
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* Now emit the stores after each def. 	   If any uses were loaded from stackslots (compared to 	   rematerialized or not reloaded due to IR spilling), 	   aweb->stack_slot will be set.  If not, we don't need to emit 	   any stack stores.  */
name|slot
operator|=
name|aweb
operator|->
name|stack_slot
expr_stmt|;
name|bitmap_clear
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|web
operator|->
name|num_defs
condition|;
name|j
operator|++
control|)
block|{
name|rtx
name|insns
decl_stmt|,
name|source
decl_stmt|,
name|dest
decl_stmt|;
name|rtx
name|insn
init|=
name|DF_REF_INSN
argument_list|(
name|web
operator|->
name|defs
index|[
name|j
index|]
argument_list|)
decl_stmt|;
name|rtx
name|following
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Happens when spill_coalescing() deletes move insns.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|b
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
continue|continue;
name|bitmap_set_bit
argument_list|(
name|b
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|source
operator|=
name|DF_REF_REG
argument_list|(
name|web
operator|->
name|defs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|dest
operator|=
name|slot
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|source
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|simplify_gen_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|source
argument_list|)
argument_list|,
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|ra_emit_move_insn
argument_list|(
name|dest
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|insns
condition|)
block|{
name|emit_insn_after
argument_list|(
name|insns
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|end
operator|==
name|insn
condition|)
name|bb
operator|->
name|end
operator|=
name|PREV_INSN
argument_list|(
name|following
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
operator|!=
name|following
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|set_block_for_insn
argument_list|(
name|insn
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|df_insn_modify
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|df_insn_modify
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emitted_spill_stores
operator|++
expr_stmt|;
name|spill_store_cost
operator|+=
name|bb
operator|->
name|frequency
operator|+
literal|1
expr_stmt|;
comment|/* XXX we should set new_deaths for all inserted stores 		 whose pseudo dies here. 		 Note, that this isn't the case for _all_ stores.  */
comment|/* I.e. the next is wrong, and might cause some spilltemps 		 to be categorized as spilltemp2's (i.e. live over a death), 		 although they aren't.  This might make them spill again, 		 which causes endlessness in the case, this insn is in fact 		 _no_ death.  */
name|bitmap_set_bit
argument_list|(
name|new_deaths
argument_list|,
name|INSN_UID
argument_list|(
name|PREV_INSN
argument_list|(
name|following
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|BITMAP_XFREE
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A simple list of rtx's.  */
end_comment

begin_struct
struct|struct
name|rtx_list
block|{
name|struct
name|rtx_list
modifier|*
name|next
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Adds X to *LIST.  */
end_comment

begin_function
specifier|static
name|void
name|remember_slot
parameter_list|(
name|list
parameter_list|,
name|x
parameter_list|)
name|struct
name|rtx_list
modifier|*
modifier|*
name|list
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|rtx_list
modifier|*
name|l
decl_stmt|;
comment|/* PRE: X is not already in LIST.  */
name|l
operator|=
operator|(
expr|struct
name|rtx_list
operator|*
operator|)
name|ra_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
name|l
operator|->
name|x
operator|=
name|x
expr_stmt|;
operator|*
name|list
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given two rtx' S1 and S2, either being REGs or MEMs (or SUBREGs    thereof), return nonzero, if they overlap.  REGs and MEMs don't    overlap, and if they are MEMs they must have an easy address    (plus (basereg) (const_inst x)), otherwise they overlap.  */
end_comment

begin_function
specifier|static
name|int
name|slots_overlap_p
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|rtx
name|s1
decl_stmt|,
name|s2
decl_stmt|;
block|{
name|rtx
name|base1
decl_stmt|,
name|base2
decl_stmt|;
name|HOST_WIDE_INT
name|ofs1
init|=
literal|0
decl_stmt|,
name|ofs2
init|=
literal|0
decl_stmt|;
name|int
name|size1
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|s1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|size2
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|s2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|s1
argument_list|)
operator|==
name|SUBREG
condition|)
name|ofs1
operator|=
name|SUBREG_BYTE
argument_list|(
name|s1
argument_list|)
operator|,
name|s1
operator|=
name|SUBREG_REG
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|s2
argument_list|)
operator|==
name|SUBREG
condition|)
name|ofs2
operator|=
name|SUBREG_BYTE
argument_list|(
name|s2
argument_list|)
operator|,
name|s2
operator|=
name|SUBREG_REG
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
operator|==
name|s2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|s1
argument_list|)
operator|!=
name|GET_CODE
argument_list|(
name|s2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|s1
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|s2
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|s1
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|s2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ofs1
operator|>=
name|ofs2
operator|+
name|size2
operator|||
name|ofs2
operator|>=
name|ofs1
operator|+
name|size1
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|s1
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|s2
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|s1
operator|=
name|XEXP
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s2
operator|=
name|XEXP
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|s1
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|s1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|s2
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|s2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|1
return|;
name|base1
operator|=
name|XEXP
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|base2
operator|=
name|XEXP
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|base1
argument_list|,
name|base2
argument_list|)
condition|)
return|return
literal|1
return|;
name|ofs1
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|s1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ofs2
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|s2
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofs1
operator|>=
name|ofs2
operator|+
name|size2
operator|||
name|ofs2
operator|>=
name|ofs1
operator|+
name|size1
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This deletes from *LIST all rtx's which overlap with X in the sense    of slots_overlap_p().  */
end_comment

begin_function
specifier|static
name|void
name|delete_overlapping_slots
parameter_list|(
name|list
parameter_list|,
name|x
parameter_list|)
name|struct
name|rtx_list
modifier|*
modifier|*
name|list
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|list
condition|)
block|{
if|if
condition|(
name|slots_overlap_p
argument_list|(
operator|(
operator|*
name|list
operator|)
operator|->
name|x
argument_list|,
name|x
argument_list|)
condition|)
operator|*
name|list
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|next
expr_stmt|;
else|else
name|list
operator|=
operator|&
operator|(
operator|(
operator|*
name|list
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns nonzero, of X is member of LIST.  */
end_comment

begin_function
specifier|static
name|int
name|slot_member_p
parameter_list|(
name|list
parameter_list|,
name|x
parameter_list|)
name|struct
name|rtx_list
modifier|*
name|list
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|list
operator|->
name|x
argument_list|,
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A more sophisticated (and slower) method of adding the stores, than    rewrite_program().  This goes backward the insn stream, adding    stores as it goes, but only if it hasn't just added a store to the    same location.  NEW_DEATHS is a bitmap filled with uids of insns    containing deaths.  */
end_comment

begin_function
specifier|static
name|void
name|insert_stores
parameter_list|(
name|new_deaths
parameter_list|)
name|bitmap
name|new_deaths
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|last_slot
init|=
name|NULL_RTX
decl_stmt|;
name|struct
name|rtx_list
modifier|*
name|slots
init|=
name|NULL
decl_stmt|;
comment|/* We go simply backwards over basic block borders.  */
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If we reach a basic block border, which has more than one 	 outgoing edge, we simply forget all already emitted stores.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
operator|||
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|||
name|can_throw_internal
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|last_slot
operator|=
name|NULL_RTX
expr_stmt|;
name|slots
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* If this insn was not just added in this pass.  */
if|if
condition|(
name|uid
operator|<
name|insn_df_max_uid
condition|)
block|{
name|unsigned
name|int
name|n
decl_stmt|;
name|rtx
name|following
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|struct
name|ra_insn_info
name|info
decl_stmt|;
name|info
operator|=
name|insn_df
index|[
name|uid
index|]
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|info
operator|.
name|num_defs
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|def2web
index|[
name|DF_REF_ID
argument_list|(
name|info
operator|.
name|defs
index|[
name|n
index|]
argument_list|)
index|]
decl_stmt|;
name|struct
name|web
modifier|*
name|aweb
init|=
name|alias
argument_list|(
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|slot
decl_stmt|,
name|source
decl_stmt|;
if|if
condition|(
name|aweb
operator|->
name|type
operator|!=
name|SPILLED
operator|||
operator|!
name|aweb
operator|->
name|stack_slot
condition|)
continue|continue;
name|slot
operator|=
name|aweb
operator|->
name|stack_slot
expr_stmt|;
name|source
operator|=
name|DF_REF_REG
argument_list|(
name|info
operator|.
name|defs
index|[
name|n
index|]
argument_list|)
expr_stmt|;
comment|/* adjust_address() might generate code.  */
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|source
argument_list|)
operator|==
name|SUBREG
condition|)
name|slot
operator|=
name|simplify_gen_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|source
argument_list|)
argument_list|,
name|slot
argument_list|,
name|GET_MODE
argument_list|(
name|slot
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have no info about emitted stores, or it didn't 		 contain the location we intend to use soon, then 		 add the store.  */
if|if
condition|(
operator|(
operator|!
name|last_slot
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|slot
argument_list|,
name|last_slot
argument_list|)
operator|)
operator|&&
operator|!
name|slot_member_p
argument_list|(
name|slots
argument_list|,
name|slot
argument_list|)
condition|)
block|{
name|rtx
name|insns
decl_stmt|,
name|ni
decl_stmt|;
name|last_slot
operator|=
name|slot
expr_stmt|;
name|remember_slot
argument_list|(
operator|&
name|slots
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|ra_emit_move_insn
argument_list|(
name|slot
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|insns
condition|)
block|{
name|emit_insn_after
argument_list|(
name|insns
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|end
operator|==
name|insn
condition|)
name|bb
operator|->
name|end
operator|=
name|PREV_INSN
argument_list|(
name|following
argument_list|)
expr_stmt|;
for|for
control|(
name|ni
operator|=
name|insns
init|;
name|ni
operator|!=
name|following
condition|;
name|ni
operator|=
name|NEXT_INSN
argument_list|(
name|ni
argument_list|)
control|)
block|{
name|set_block_for_insn
argument_list|(
name|ni
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|df_insn_modify
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|df_insn_modify
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emitted_spill_stores
operator|++
expr_stmt|;
name|spill_store_cost
operator|+=
name|bb
operator|->
name|frequency
operator|+
literal|1
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|new_deaths
argument_list|,
name|INSN_UID
argument_list|(
name|PREV_INSN
argument_list|(
name|following
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise ignore insns from adjust_address() above.  */
name|end_sequence
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* If we look at a load generated by the allocator, forget 	 the last emitted slot, and additionally clear all slots 	 overlapping it's source (after all, we need it again).  */
comment|/* XXX If we emit the stack-ref directly into the using insn the          following needs a change, because that is no new insn.  Preferably 	 we would add some notes to the insn, what stackslots are needed 	 for it.  */
if|if
condition|(
name|uid
operator|>=
name|last_max_uid
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|last_slot
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* If this was no simple set, give up, and forget everything.  */
if|if
condition|(
operator|!
name|set
condition|)
name|slots
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
literal|1
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|delete_overlapping_slots
argument_list|(
operator|&
name|slots
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Returns 1 if both colored webs have some hardregs in common, even if    they are not the same width.  */
end_comment

begin_function
specifier|static
name|int
name|spill_same_color_p
parameter_list|(
name|web1
parameter_list|,
name|web2
parameter_list|)
name|struct
name|web
modifier|*
name|web1
decl_stmt|,
decl|*
name|web2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|c1
decl_stmt|,
name|size1
decl_stmt|,
name|c2
decl_stmt|,
name|size2
decl_stmt|;
if|if
condition|(
operator|(
name|c1
operator|=
name|alias
argument_list|(
name|web1
argument_list|)
operator|->
name|color
operator|)
operator|<
literal|0
operator|||
name|c1
operator|==
name|an_unusable_color
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|c2
operator|=
name|alias
argument_list|(
name|web2
argument_list|)
operator|->
name|color
operator|)
operator|<
literal|0
operator|||
name|c2
operator|==
name|an_unusable_color
condition|)
return|return
literal|0
return|;
name|size1
operator|=
name|web1
operator|->
name|type
operator|==
name|PRECOLORED
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|c1
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|web1
operator|->
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|size2
operator|=
name|web2
operator|->
name|type
operator|==
name|PRECOLORED
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|c2
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|web2
operator|->
name|regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|>=
name|c2
operator|+
name|size2
operator|||
name|c2
operator|>=
name|c1
operator|+
name|size1
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Given the set of live web IDs LIVE, returns nonzero, if any of WEBs    subwebs (or WEB itself) is live.  */
end_comment

begin_function
specifier|static
name|bool
name|is_partly_live_1
parameter_list|(
name|live
parameter_list|,
name|web
parameter_list|)
name|sbitmap
name|live
decl_stmt|;
name|struct
name|web
modifier|*
name|web
decl_stmt|;
block|{
do|do
if|if
condition|(
name|TEST_BIT
argument_list|(
name|live
argument_list|,
name|web
operator|->
name|id
argument_list|)
condition|)
return|return
literal|1
return|;
do|while
condition|(
operator|(
name|web
operator|=
name|web
operator|->
name|subreg_next
operator|)
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fast version in case WEB has no subwebs.  */
end_comment

begin_define
define|#
directive|define
name|is_partly_live
parameter_list|(
name|live
parameter_list|,
name|web
parameter_list|)
value|((!web->subreg_next)	\ 				   ? TEST_BIT (live, web->id)	\ 				   : is_partly_live_1 (live, web))
end_define

begin_comment
comment|/* Change the set of currently IN_USE colors according to    WEB's color.  Either add those colors to the hardreg set (if ADD    is nonzero), or remove them.  */
end_comment

begin_function
specifier|static
name|void
name|update_spill_colors
parameter_list|(
name|in_use
parameter_list|,
name|web
parameter_list|,
name|add
parameter_list|)
name|HARD_REG_SET
modifier|*
name|in_use
decl_stmt|;
name|struct
name|web
modifier|*
name|web
decl_stmt|;
name|int
name|add
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|alias
argument_list|(
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
argument_list|)
operator|->
name|color
operator|)
operator|<
literal|0
operator|||
name|c
operator|==
name|an_unusable_color
condition|)
return|return;
name|size
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|c
argument_list|,
name|GET_MODE
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUBWEB_P
argument_list|(
name|web
argument_list|)
condition|)
block|{
name|c
operator|+=
name|subreg_regno_offset
argument_list|(
name|c
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|web
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
name|size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|add
condition|)
for|for
control|(
init|;
name|size
operator|--
condition|;
control|)
name|SET_HARD_REG_BIT
argument_list|(
operator|*
name|in_use
argument_list|,
name|c
operator|+
name|size
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
name|size
operator|--
condition|;
control|)
name|CLEAR_HARD_REG_BIT
argument_list|(
operator|*
name|in_use
argument_list|,
name|c
operator|+
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a set of hardregs currently IN_USE and the color C of WEB,    return -1 if WEB has no color, 1 of it has the unusable color,    0 if one of it's used hardregs are in use, and 1 otherwise.    Generally, if WEB can't be left colorized return 1.  */
end_comment

begin_function
specifier|static
name|int
name|spill_is_free
parameter_list|(
name|in_use
parameter_list|,
name|web
parameter_list|)
name|HARD_REG_SET
modifier|*
name|in_use
decl_stmt|;
name|struct
name|web
modifier|*
name|web
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|alias
argument_list|(
name|web
argument_list|)
operator|->
name|color
operator|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|c
operator|==
name|an_unusable_color
condition|)
return|return
literal|1
return|;
name|size
operator|=
name|web
operator|->
name|type
operator|==
name|PRECOLORED
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|c
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|web
operator|->
name|regno
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|size
operator|--
condition|;
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
operator|*
name|in_use
argument_list|,
name|c
operator|+
name|size
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Structure for passing between rewrite_program2() and emit_loads().  */
end_comment

begin_struct
struct|struct
name|rewrite_info
block|{
comment|/* The web IDs which currently would need a reload.  These are      currently live spilled webs, whose color was still free.  */
name|bitmap
name|need_reload
decl_stmt|;
comment|/* We need a scratch bitmap, but don't want to allocate one a zillion      times.  */
name|bitmap
name|scratch
decl_stmt|;
comment|/* Web IDs of currently live webs.  This are the precise IDs,      not just those of the superwebs.  If only on part is live, only      that ID is placed here.  */
name|sbitmap
name|live
decl_stmt|;
comment|/* An array of webs, which currently need a load added.      They will be emitted when seeing the first death.  */
name|struct
name|web
modifier|*
modifier|*
name|needed_loads
decl_stmt|;
comment|/* The current number of entries in needed_loads.  */
name|int
name|nl_size
decl_stmt|;
comment|/* The number of bits set in need_reload.  */
name|int
name|num_reloads
decl_stmt|;
comment|/* The current set of hardregs not available.  */
name|HARD_REG_SET
name|colors_in_use
decl_stmt|;
comment|/* Nonzero, if we just added some spill temps to need_reload or      needed_loads.  In this case we don't wait for the next death      to emit their loads.  */
name|int
name|any_spilltemps_spilled
decl_stmt|;
comment|/* Nonzero, if we currently need to emit the loads.  E.g. when we      saw an insn containing deaths.  */
name|int
name|need_load
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The needed_loads list of RI contains some webs for which    we add the actual load insns here.  They are added just before    their use last seen.  NL_FIRST_RELOAD is the index of the first    load which is a converted reload, all other entries are normal    loads.  LAST_BLOCK_INSN is the last insn of the current basic block.  */
end_comment

begin_function
specifier|static
name|void
name|emit_loads
parameter_list|(
name|ri
parameter_list|,
name|nl_first_reload
parameter_list|,
name|last_block_insn
parameter_list|)
name|struct
name|rewrite_info
modifier|*
name|ri
decl_stmt|;
name|int
name|nl_first_reload
decl_stmt|;
name|rtx
name|last_block_insn
decl_stmt|;
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|ri
operator|->
name|nl_size
init|;
name|j
condition|;
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|ri
operator|->
name|needed_loads
index|[
operator|--
name|j
index|]
decl_stmt|;
name|struct
name|web
modifier|*
name|supweb
decl_stmt|;
name|struct
name|web
modifier|*
name|aweb
decl_stmt|;
name|rtx
name|ni
decl_stmt|,
name|slot
decl_stmt|,
name|reg
decl_stmt|;
name|rtx
name|before
init|=
name|NULL_RTX
decl_stmt|,
name|after
init|=
name|NULL_RTX
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* When spilltemps were spilled for the last insns, their 	 loads already are emitted, which is noted by setting 	 needed_loads[] for it to 0.  */
if|if
condition|(
operator|!
name|web
condition|)
continue|continue;
name|supweb
operator|=
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
expr_stmt|;
if|if
condition|(
name|supweb
operator|->
name|regno
operator|>=
name|max_normal_pseudo
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Check for web being a spilltemp, if we only want to 	 load spilltemps.  Also remember, that we emitted that 	 load, which we don't need to do when we have a death, 	 because then all of needed_loads[] is emptied.  */
if|if
condition|(
operator|!
name|ri
operator|->
name|need_load
condition|)
block|{
if|if
condition|(
operator|!
name|supweb
operator|->
name|spill_temp
condition|)
continue|continue;
else|else
name|ri
operator|->
name|needed_loads
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|web
operator|->
name|in_load
operator|=
literal|0
expr_stmt|;
comment|/* The adding of reloads doesn't depend on liveness.  */
if|if
condition|(
name|j
operator|<
name|nl_first_reload
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|ri
operator|->
name|live
argument_list|,
name|web
operator|->
name|id
argument_list|)
condition|)
continue|continue;
name|aweb
operator|=
name|alias
argument_list|(
name|supweb
argument_list|)
expr_stmt|;
name|aweb
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|supweb
operator|->
name|pattern
condition|)
block|{
comment|/* XXX If we later allow non-constant sources for rematerialization 	     we must also disallow coalescing _to_ rematerialized webs 	     (at least then disallow spilling them, which we already ensure 	     when flag_ra_break_aliases), or not take the pattern but a 	     stackslot.  */
if|if
condition|(
name|aweb
operator|!=
name|supweb
condition|)
name|abort
argument_list|()
expr_stmt|;
name|slot
operator|=
name|copy_rtx
argument_list|(
name|supweb
operator|->
name|pattern
argument_list|)
expr_stmt|;
name|reg
operator|=
name|copy_rtx
argument_list|(
name|supweb
operator|->
name|orig_x
argument_list|)
expr_stmt|;
comment|/* Sanity check.  orig_x should be a REG rtx, which should be 	     shared over all RTL, so copy_rtx should have no effect.  */
if|if
condition|(
name|reg
operator|!=
name|supweb
operator|->
name|orig_x
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|allocate_spill_web
argument_list|(
name|aweb
argument_list|)
expr_stmt|;
name|slot
operator|=
name|aweb
operator|->
name|stack_slot
expr_stmt|;
comment|/* If we don't copy the RTL there might be some SUBREG 	     rtx shared in the next iteration although being in 	     different webs, which leads to wrong code.  */
name|reg
operator|=
name|copy_rtx
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
comment|/*slot = adjust_address (slot, GET_MODE (reg), SUBREG_BYTE 	       (reg));*/
name|slot
operator|=
name|simplify_gen_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|slot
argument_list|,
name|GET_MODE
argument_list|(
name|slot
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ra_emit_move_insn
argument_list|(
name|reg
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|ni
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|before
operator|=
name|web
operator|->
name|last_use_insn
expr_stmt|;
name|web
operator|->
name|last_use_insn
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
operator|!
name|before
condition|)
block|{
if|if
condition|(
name|JUMP_P
argument_list|(
name|last_block_insn
argument_list|)
condition|)
name|before
operator|=
name|last_block_insn
expr_stmt|;
else|else
name|after
operator|=
name|last_block_insn
expr_stmt|;
block|}
if|if
condition|(
name|after
condition|)
block|{
name|rtx
name|foll
init|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
decl_stmt|;
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|after
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|ni
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|end
operator|==
name|after
condition|)
name|bb
operator|->
name|end
operator|=
name|PREV_INSN
argument_list|(
name|foll
argument_list|)
expr_stmt|;
for|for
control|(
name|ni
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
init|;
name|ni
operator|!=
name|foll
condition|;
name|ni
operator|=
name|NEXT_INSN
argument_list|(
name|ni
argument_list|)
control|)
block|{
name|set_block_for_insn
argument_list|(
name|ni
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|df_insn_modify
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|before
argument_list|)
decl_stmt|;
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|before
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|ni
argument_list|,
name|before
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|head
operator|==
name|before
condition|)
name|bb
operator|->
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ni
operator|!=
name|before
condition|;
name|ni
operator|=
name|NEXT_INSN
argument_list|(
name|ni
argument_list|)
control|)
block|{
name|set_block_for_insn
argument_list|(
name|ni
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|df_insn_modify
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|supweb
operator|->
name|pattern
condition|)
block|{
name|emitted_remat
operator|++
expr_stmt|;
name|spill_remat_cost
operator|+=
name|bb
operator|->
name|frequency
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|emitted_spill_loads
operator|++
expr_stmt|;
name|spill_load_cost
operator|+=
name|bb
operator|->
name|frequency
operator|+
literal|1
expr_stmt|;
block|}
name|RESET_BIT
argument_list|(
name|ri
operator|->
name|live
argument_list|,
name|web
operator|->
name|id
argument_list|)
expr_stmt|;
comment|/* In the special case documented above only emit the reloads and 	 one load.  */
if|if
condition|(
name|ri
operator|->
name|need_load
operator|==
literal|2
operator|&&
name|j
operator|<
name|nl_first_reload
condition|)
break|break;
block|}
if|if
condition|(
name|ri
operator|->
name|need_load
condition|)
name|ri
operator|->
name|nl_size
operator|=
name|j
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a set of reloads in RI, an array of NUM_REFS references (either    uses or defs) in REFS, and REF2WEB to translate ref IDs to webs    (either use2web or def2web) convert some reloads to loads.    This looks at the webs referenced, and how they change the set of    available colors.  Now put all still live webs, which needed reloads,    and whose colors isn't free anymore, on the needed_loads list.  */
end_comment

begin_function
specifier|static
name|void
name|reloads_to_loads
parameter_list|(
name|ri
parameter_list|,
name|refs
parameter_list|,
name|num_refs
parameter_list|,
name|ref2web
parameter_list|)
name|struct
name|rewrite_info
modifier|*
name|ri
decl_stmt|;
name|struct
name|ref
modifier|*
modifier|*
name|refs
decl_stmt|;
name|unsigned
name|int
name|num_refs
decl_stmt|;
name|struct
name|web
modifier|*
modifier|*
name|ref2web
decl_stmt|;
block|{
name|unsigned
name|int
name|n
decl_stmt|;
name|int
name|num_reloads
init|=
name|ri
operator|->
name|num_reloads
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_refs
operator|&&
name|num_reloads
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|ref2web
index|[
name|DF_REF_ID
argument_list|(
name|refs
index|[
name|n
index|]
argument_list|)
index|]
decl_stmt|;
name|struct
name|web
modifier|*
name|supweb
init|=
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
decl_stmt|;
name|int
name|is_death
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Only emit reloads when entering their interference 	 region.  A use of a spilled web never opens an 	 interference region, independent of it's color.  */
if|if
condition|(
name|alias
argument_list|(
name|supweb
argument_list|)
operator|->
name|type
operator|==
name|SPILLED
condition|)
continue|continue;
if|if
condition|(
name|supweb
operator|->
name|type
operator|==
name|PRECOLORED
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|never_use_colors
argument_list|,
name|supweb
operator|->
name|color
argument_list|)
condition|)
continue|continue;
comment|/* Note, that if web (and supweb) are DEFs, we already cleared 	 the corresponding bits in live.  I.e. is_death becomes true, which 	 is what we want.  */
name|is_death
operator|=
operator|!
name|TEST_BIT
argument_list|(
name|ri
operator|->
name|live
argument_list|,
name|supweb
operator|->
name|id
argument_list|)
expr_stmt|;
name|is_death
operator|&=
operator|!
name|TEST_BIT
argument_list|(
name|ri
operator|->
name|live
argument_list|,
name|web
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_death
condition|)
block|{
name|int
name|old_num_r
init|=
name|num_reloads
decl_stmt|;
name|bitmap_clear
argument_list|(
name|ri
operator|->
name|scratch
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|ri->need_reload
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|{ 	      struct web *web2 = ID2WEB (j); 	      struct web *aweb2 = alias (find_web_for_subweb (web2)); 	      if (spill_is_free (&(ri->colors_in_use), aweb2) ==
literal|0
argument|) 		abort (); 	      if (spill_same_color_p (supweb, aweb2)
comment|/*&& interfere (web, web2) */
argument|) 		{ 		  if (!web2->in_load) 		    { 		      ri->needed_loads[ri->nl_size++] = web2; 		      web2->in_load =
literal|1
argument|; 		    } 		  bitmap_set_bit (ri->scratch, j); 		  num_reloads--; 		} 	    }
argument_list|)
empty_stmt|;
if|if
condition|(
name|num_reloads
operator|!=
name|old_num_r
condition|)
name|bitmap_operation
argument_list|(
name|ri
operator|->
name|need_reload
argument_list|,
name|ri
operator|->
name|need_reload
argument_list|,
name|ri
operator|->
name|scratch
argument_list|,
name|BITMAP_AND_COMPL
argument_list|)
expr_stmt|;
block|}
block|}
name|ri
operator|->
name|num_reloads
operator|=
name|num_reloads
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This adds loads for spilled webs to the program.  It uses a kind of    interference region spilling.  If flag_ra_ir_spilling is zero it    only uses improved chaitin spilling (adding loads only at insns    containing deaths).  */
end_comment

begin_function
specifier|static
name|void
name|rewrite_program2
parameter_list|(
name|new_deaths
parameter_list|)
name|bitmap
name|new_deaths
decl_stmt|;
block|{
name|basic_block
name|bb
decl_stmt|;
name|int
name|nl_first_reload
decl_stmt|;
name|struct
name|rewrite_info
name|ri
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|ri
operator|.
name|needed_loads
operator|=
operator|(
expr|struct
name|web
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|num_webs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|web
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ri
operator|.
name|need_reload
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|ri
operator|.
name|scratch
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|ri
operator|.
name|live
operator|=
name|sbitmap_alloc
argument_list|(
name|num_webs
argument_list|)
expr_stmt|;
name|ri
operator|.
name|nl_size
operator|=
literal|0
expr_stmt|;
name|ri
operator|.
name|num_reloads
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|basic_block
name|last_bb
init|=
name|NULL
decl_stmt|;
name|rtx
name|last_block_insn
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|insn
operator|&&
operator|!
operator|(
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
name|insn
operator|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
break|break;
name|i
operator|=
name|bb
operator|->
name|index
operator|+
literal|2
expr_stmt|;
name|last_block_insn
operator|=
name|insn
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|ri
operator|.
name|live
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|ri
operator|.
name|colors_in_use
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|live_at_end[i -
literal|2
argument|]
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|{ 	  struct web *web = use2web[j]; 	  struct web *aweb = alias (find_web_for_subweb (web));
comment|/* A web is only live at end, if it isn't spilled.  If we wouldn't 	     check this, the last uses of spilled web per basic block 	     wouldn't be detected as deaths, although they are in the final 	     code.  This would lead to cumulating many loads without need, 	     only increasing register pressure.  */
comment|/* XXX do add also spilled webs which got a color for IR spilling. 	     Remember to not add to colors_in_use in that case.  */
argument|if (aweb->type != SPILLED
comment|/*|| aweb->color>= 0*/
argument|) 	    { 	      SET_BIT (ri.live, web->id); 	      if (aweb->type != SPILLED) 	        update_spill_colors (&(ri.colors_in_use), web,
literal|1
argument|); 	    } 	}
argument_list|)
empty_stmt|;
name|bitmap_clear
argument_list|(
name|ri
operator|.
name|need_reload
argument_list|)
expr_stmt|;
name|ri
operator|.
name|num_reloads
operator|=
literal|0
expr_stmt|;
name|ri
operator|.
name|any_spilltemps_spilled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_ra_ir_spilling
condition|)
block|{
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
name|int
name|pass
decl_stmt|;
comment|/* XXX If we don't add spilled nodes into live above, the following 	     becomes an empty loop.  */
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
for|for
control|(
name|d
operator|=
operator|(
name|pass
operator|)
condition|?
name|WEBS
argument_list|(
name|SPILLED
argument_list|)
else|:
name|WEBS
argument_list|(
name|COALESCED
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|struct
name|web
modifier|*
name|aweb
init|=
name|alias
argument_list|(
name|web
argument_list|)
decl_stmt|;
if|if
condition|(
name|aweb
operator|->
name|type
operator|!=
name|SPILLED
condition|)
continue|continue;
if|if
condition|(
name|is_partly_live
argument_list|(
name|ri
operator|.
name|live
argument_list|,
name|web
argument_list|)
operator|&&
name|spill_is_free
argument_list|(
operator|&
operator|(
name|ri
operator|.
name|colors_in_use
operator|)
argument_list|,
name|web
argument_list|)
operator|>
literal|0
condition|)
block|{
name|ri
operator|.
name|num_reloads
operator|++
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|ri
operator|.
name|need_reload
argument_list|,
name|web
operator|->
name|id
argument_list|)
expr_stmt|;
comment|/* Last using insn is somewhere in another block.  */
name|web
operator|->
name|last_use_insn
operator|=
name|NULL_RTX
expr_stmt|;
block|}
block|}
block|}
name|last_bb
operator|=
name|bb
expr_stmt|;
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|struct
name|ra_insn_info
name|info
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
name|last_bb
condition|)
block|{
name|int
name|index
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|->
name|index
operator|+
literal|2
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|live_at_end[index -
literal|2
argument|]
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|{ 		  struct web *web = use2web[j]; 		  struct web *aweb = alias (find_web_for_subweb (web)); 		  if (aweb->type != SPILLED) 		    { 		      SET_BIT (ri.live, web->id); 		      update_spill_colors (&(ri.colors_in_use), web,
literal|1
argument|); 		    } 		}
argument_list|)
empty_stmt|;
name|bitmap_clear
argument_list|(
name|ri
operator|.
name|scratch
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|ri.need_reload
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|{ 		  struct web *web2 = ID2WEB (j); 		  struct web *supweb2 = find_web_for_subweb (web2); 		  struct web *aweb2 = alias (supweb2); 		  if (spill_is_free (&(ri.colors_in_use), aweb2)<=
literal|0
argument|) 		    { 		      if (!web2->in_load) 			{ 			  ri.needed_loads[ri.nl_size++] = web2; 			  web2->in_load =
literal|1
argument|; 			} 		      bitmap_set_bit (ri.scratch, j); 		      ri.num_reloads--; 		    } 		}
argument_list|)
empty_stmt|;
name|bitmap_operation
argument_list|(
name|ri
operator|.
name|need_reload
argument_list|,
name|ri
operator|.
name|need_reload
argument_list|,
name|ri
operator|.
name|scratch
argument_list|,
name|BITMAP_AND_COMPL
argument_list|)
expr_stmt|;
name|last_bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|last_block_insn
operator|=
name|insn
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|last_block_insn
argument_list|)
condition|)
name|last_block_insn
operator|=
name|prev_real_insn
argument_list|(
name|last_block_insn
argument_list|)
expr_stmt|;
block|}
name|ri
operator|.
name|need_load
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|info
operator|=
name|insn_df
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|info
operator|.
name|num_defs
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|ref
modifier|*
name|ref
init|=
name|info
operator|.
name|defs
index|[
name|n
index|]
decl_stmt|;
name|struct
name|web
modifier|*
name|web
init|=
name|def2web
index|[
name|DF_REF_ID
argument_list|(
name|ref
argument_list|)
index|]
decl_stmt|;
name|struct
name|web
modifier|*
name|supweb
init|=
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
decl_stmt|;
name|int
name|is_non_def
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|n2
decl_stmt|;
name|supweb
operator|=
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
expr_stmt|;
comment|/* Webs which are defined here, but also used in the same insn 		   are rmw webs, or this use isn't a death because of looping 		   constructs.  In neither case makes this def available it's 		   resources.  Reloads for it are still needed, it's still 		   live and it's colors don't become free.  */
for|for
control|(
name|n2
operator|=
literal|0
init|;
name|n2
operator|<
name|info
operator|.
name|num_uses
condition|;
name|n2
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|web2
init|=
name|use2web
index|[
name|DF_REF_ID
argument_list|(
name|info
operator|.
name|uses
index|[
name|n2
index|]
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|supweb
operator|==
name|find_web_for_subweb
argument_list|(
name|web2
argument_list|)
condition|)
block|{
name|is_non_def
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|is_non_def
condition|)
continue|continue;
if|if
condition|(
operator|!
name|is_partly_live
argument_list|(
name|ri
operator|.
name|live
argument_list|,
name|supweb
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|useless_defs
argument_list|,
name|DF_REF_ID
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|ri
operator|.
name|live
argument_list|,
name|web
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|ri
operator|.
name|need_reload
argument_list|,
name|web
operator|->
name|id
argument_list|)
condition|)
block|{
name|ri
operator|.
name|num_reloads
operator|--
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|ri
operator|.
name|need_reload
argument_list|,
name|web
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|web
operator|!=
name|supweb
condition|)
block|{
comment|/* XXX subwebs aren't precisely tracked here.  We have 		       everything we need (inverse webs), but the code isn't 		       yet written.  We need to make all completely 		       overlapping web parts non-live here.  */
comment|/* If by luck now the whole web isn't live anymore, no 		       reloads for it are needed.  */
if|if
condition|(
operator|!
name|is_partly_live
argument_list|(
name|ri
operator|.
name|live
argument_list|,
name|supweb
argument_list|)
operator|&&
name|bitmap_bit_p
argument_list|(
name|ri
operator|.
name|need_reload
argument_list|,
name|supweb
operator|->
name|id
argument_list|)
condition|)
block|{
name|ri
operator|.
name|num_reloads
operator|--
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|ri
operator|.
name|need_reload
argument_list|,
name|supweb
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|web
modifier|*
name|sweb
decl_stmt|;
comment|/* If the whole web is defined here, no parts of it are 		       live anymore and no reloads are needed for them.  */
for|for
control|(
name|sweb
operator|=
name|supweb
operator|->
name|subreg_next
init|;
name|sweb
condition|;
name|sweb
operator|=
name|sweb
operator|->
name|subreg_next
control|)
block|{
name|RESET_BIT
argument_list|(
name|ri
operator|.
name|live
argument_list|,
name|sweb
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|ri
operator|.
name|need_reload
argument_list|,
name|sweb
operator|->
name|id
argument_list|)
condition|)
block|{
name|ri
operator|.
name|num_reloads
operator|--
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|ri
operator|.
name|need_reload
argument_list|,
name|sweb
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|alias
argument_list|(
name|supweb
argument_list|)
operator|->
name|type
operator|!=
name|SPILLED
condition|)
name|update_spill_colors
argument_list|(
operator|&
operator|(
name|ri
operator|.
name|colors_in_use
operator|)
argument_list|,
name|web
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|nl_first_reload
operator|=
name|ri
operator|.
name|nl_size
expr_stmt|;
comment|/* CALL_INSNs are not really deaths, but still more registers 	     are free after a call, than before. 	     XXX Note, that sometimes reload barfs when we emit insns between 	     a call and the insn which copies the return register into a 	     pseudo.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|ri
operator|.
name|need_load
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|info
operator|.
name|num_uses
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|use2web
index|[
name|DF_REF_ID
argument_list|(
name|info
operator|.
name|uses
index|[
name|n
index|]
argument_list|)
index|]
decl_stmt|;
name|struct
name|web
modifier|*
name|supweb
init|=
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
decl_stmt|;
name|int
name|is_death
decl_stmt|;
if|if
condition|(
name|supweb
operator|->
name|type
operator|==
name|PRECOLORED
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|never_use_colors
argument_list|,
name|supweb
operator|->
name|color
argument_list|)
condition|)
continue|continue;
name|is_death
operator|=
operator|!
name|TEST_BIT
argument_list|(
name|ri
operator|.
name|live
argument_list|,
name|supweb
operator|->
name|id
argument_list|)
expr_stmt|;
name|is_death
operator|&=
operator|!
name|TEST_BIT
argument_list|(
name|ri
operator|.
name|live
argument_list|,
name|web
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_death
condition|)
block|{
name|ri
operator|.
name|need_load
operator|=
literal|1
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|new_deaths
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|ri
operator|.
name|num_reloads
condition|)
block|{
name|int
name|old_num_reloads
init|=
name|ri
operator|.
name|num_reloads
decl_stmt|;
name|reloads_to_loads
argument_list|(
operator|&
name|ri
argument_list|,
name|info
operator|.
name|uses
argument_list|,
name|info
operator|.
name|num_uses
argument_list|,
name|use2web
argument_list|)
expr_stmt|;
comment|/* If this insn sets a pseudo, which isn't used later 		 (i.e. wasn't live before) it is a dead store.  We need 		 to emit all reloads which have the same color as this def. 		 We don't need to check for non-liveness here to detect 		 the deadness (it anyway is too late, as we already cleared 		 the liveness in the first loop over the defs), because if it 		 _would_ be live here, no reload could have that color, as 		 they would already have been converted to a load.  */
if|if
condition|(
name|ri
operator|.
name|num_reloads
condition|)
name|reloads_to_loads
argument_list|(
operator|&
name|ri
argument_list|,
name|info
operator|.
name|defs
argument_list|,
name|info
operator|.
name|num_defs
argument_list|,
name|def2web
argument_list|)
expr_stmt|;
if|if
condition|(
name|ri
operator|.
name|num_reloads
operator|!=
name|old_num_reloads
operator|&&
operator|!
name|ri
operator|.
name|need_load
condition|)
name|ri
operator|.
name|need_load
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ri
operator|.
name|nl_size
operator|&&
operator|(
name|ri
operator|.
name|need_load
operator|||
name|ri
operator|.
name|any_spilltemps_spilled
operator|)
condition|)
name|emit_loads
argument_list|(
operator|&
name|ri
argument_list|,
name|nl_first_reload
argument_list|,
name|last_block_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|flag_ra_ir_spilling
condition|)
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|info
operator|.
name|num_uses
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|use2web
index|[
name|DF_REF_ID
argument_list|(
name|info
operator|.
name|uses
index|[
name|n
index|]
argument_list|)
index|]
decl_stmt|;
name|struct
name|web
modifier|*
name|aweb
init|=
name|alias
argument_list|(
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|aweb
operator|->
name|type
operator|!=
name|SPILLED
condition|)
name|update_spill_colors
argument_list|(
operator|&
operator|(
name|ri
operator|.
name|colors_in_use
operator|)
argument_list|,
name|web
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ri
operator|.
name|any_spilltemps_spilled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|info
operator|.
name|num_uses
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|use2web
index|[
name|DF_REF_ID
argument_list|(
name|info
operator|.
name|uses
index|[
name|n
index|]
argument_list|)
index|]
decl_stmt|;
name|struct
name|web
modifier|*
name|supweb
init|=
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
decl_stmt|;
name|struct
name|web
modifier|*
name|aweb
init|=
name|alias
argument_list|(
name|supweb
argument_list|)
decl_stmt|;
name|SET_BIT
argument_list|(
name|ri
operator|.
name|live
argument_list|,
name|web
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|aweb
operator|->
name|type
operator|!=
name|SPILLED
condition|)
continue|continue;
if|if
condition|(
name|supweb
operator|->
name|spill_temp
condition|)
name|ri
operator|.
name|any_spilltemps_spilled
operator|=
literal|1
expr_stmt|;
name|web
operator|->
name|last_use_insn
operator|=
name|insn
expr_stmt|;
if|if
condition|(
operator|!
name|web
operator|->
name|in_load
condition|)
block|{
if|if
condition|(
name|spill_is_free
argument_list|(
operator|&
operator|(
name|ri
operator|.
name|colors_in_use
operator|)
argument_list|,
name|aweb
argument_list|)
operator|<=
literal|0
operator|||
operator|!
name|flag_ra_ir_spilling
condition|)
block|{
name|ri
operator|.
name|needed_loads
index|[
name|ri
operator|.
name|nl_size
operator|++
index|]
operator|=
name|web
expr_stmt|;
name|web
operator|->
name|in_load
operator|=
literal|1
expr_stmt|;
name|web
operator|->
name|one_load
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|ri
operator|.
name|need_reload
argument_list|,
name|web
operator|->
name|id
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|ri
operator|.
name|need_reload
argument_list|,
name|web
operator|->
name|id
argument_list|)
expr_stmt|;
name|ri
operator|.
name|num_reloads
operator|++
expr_stmt|;
name|web
operator|->
name|one_load
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|web
operator|->
name|one_load
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|web
operator|->
name|one_load
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
block|}
name|nl_first_reload
operator|=
name|ri
operator|.
name|nl_size
expr_stmt|;
if|if
condition|(
name|ri
operator|.
name|num_reloads
condition|)
block|{
name|int
name|in_ir
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
name|HARD_REG_SET
name|cum_colors
decl_stmt|,
name|colors
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|cum_colors
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
operator|&&
name|num
operator|<
literal|5
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
operator|,
name|num
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|colors
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|live_at_end[e->src->index]
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|{ 		  struct web *web = use2web[j]; 		  struct web *aweb = alias (find_web_for_subweb (web)); 		  if (aweb->type != SPILLED) 		    update_spill_colors (&colors, web,
literal|1
argument|); 		}
argument_list|)
empty_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|cum_colors
argument_list|,
name|colors
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|==
literal|5
condition|)
name|in_ir
operator|=
literal|1
expr_stmt|;
name|bitmap_clear
argument_list|(
name|ri
operator|.
name|scratch
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|ri.need_reload
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|{ 	      struct web *web2 = ID2WEB (j); 	      struct web *supweb2 = find_web_for_subweb (web2); 	      struct web *aweb2 = alias (supweb2);
comment|/* block entry is IR boundary for aweb2? 		 Currently more some tries for good conditions.  */
argument|if (((ra_pass>
literal|0
argument||| supweb2->target_of_spilled_move)&& (
literal|1
argument||| in_ir || spill_is_free (&cum_colors, aweb2)<=
literal|0
argument|)) 		  || (ra_pass ==
literal|1
argument|&& (in_ir 			  || spill_is_free (&cum_colors, aweb2)<=
literal|0
argument|))) 		{ 		  if (!web2->in_load) 		    { 		      ri.needed_loads[ri.nl_size++] = web2; 		      web2->in_load =
literal|1
argument|; 		    } 		  bitmap_set_bit (ri.scratch, j); 		  ri.num_reloads--; 		} 	    }
argument_list|)
empty_stmt|;
name|bitmap_operation
argument_list|(
name|ri
operator|.
name|need_reload
argument_list|,
name|ri
operator|.
name|need_reload
argument_list|,
name|ri
operator|.
name|scratch
argument_list|,
name|BITMAP_AND_COMPL
argument_list|)
expr_stmt|;
block|}
name|ri
operator|.
name|need_load
operator|=
literal|1
expr_stmt|;
name|emit_loads
argument_list|(
operator|&
name|ri
argument_list|,
name|nl_first_reload
argument_list|,
name|last_block_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ri
operator|.
name|nl_size
operator|!=
literal|0
comment|/*|| ri.num_reloads != 0*/
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
break|break;
block|}
name|free
argument_list|(
name|ri
operator|.
name|needed_loads
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|ri
operator|.
name|live
argument_list|)
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|ri
operator|.
name|scratch
argument_list|)
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|ri
operator|.
name|need_reload
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* WEBS is a web conflicting with a spilled one.  Prepare it    to be able to rescan it in the next pass.  Mark all it's uses    for checking, and clear the some members of their web parts    (of defs and uses).  Notably don't clear the uplink.  We don't    change the layout of this web, just it's conflicts.    Also remember all IDs of its uses in USES_AS_BITMAP.  */
end_comment

begin_function
specifier|static
name|void
name|mark_refs_for_checking
parameter_list|(
name|web
parameter_list|,
name|uses_as_bitmap
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
name|bitmap
name|uses_as_bitmap
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|web
operator|->
name|num_uses
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|id
init|=
name|DF_REF_ID
argument_list|(
name|web
operator|->
name|uses
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|SET_BIT
argument_list|(
name|last_check_uses
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|uses_as_bitmap
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|web_parts
index|[
name|df
operator|->
name|def_id
operator|+
name|id
index|]
operator|.
name|spanned_deaths
operator|=
literal|0
expr_stmt|;
name|web_parts
index|[
name|df
operator|->
name|def_id
operator|+
name|id
index|]
operator|.
name|crosses_call
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|web
operator|->
name|num_defs
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|id
init|=
name|DF_REF_ID
argument_list|(
name|web
operator|->
name|defs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|web_parts
index|[
name|id
index|]
operator|.
name|spanned_deaths
operator|=
literal|0
expr_stmt|;
name|web_parts
index|[
name|id
index|]
operator|.
name|crosses_call
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The last step of the spill phase is to set up the structures for    incrementally rebuilding the interference graph.  We break up    the web part structure of all spilled webs, mark their uses for    rechecking, look at their neighbors, and clean up some global    information, we will rebuild.  */
end_comment

begin_function
specifier|static
name|void
name|detect_web_parts_to_rebuild
parameter_list|()
block|{
name|bitmap
name|uses_as_bitmap
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|pass
decl_stmt|;
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
name|sbitmap
name|already_webs
init|=
name|sbitmap_alloc
argument_list|(
name|num_webs
argument_list|)
decl_stmt|;
name|uses_as_bitmap
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
if|if
condition|(
name|last_check_uses
condition|)
name|sbitmap_free
argument_list|(
name|last_check_uses
argument_list|)
expr_stmt|;
name|last_check_uses
operator|=
name|sbitmap_alloc
argument_list|(
name|df
operator|->
name|use_id
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|last_check_uses
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|already_webs
argument_list|)
expr_stmt|;
comment|/* We need to recheck all uses of all webs involved in spilling (and the      uses added by spill insns, but those are not analyzed yet).      Those are the spilled webs themself, webs coalesced to spilled ones,      and webs conflicting with any of them.  */
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
for|for
control|(
name|d
operator|=
operator|(
name|pass
operator|==
literal|0
operator|)
condition|?
name|WEBS
argument_list|(
name|SPILLED
argument_list|)
else|:
name|WEBS
argument_list|(
name|COALESCED
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|struct
name|conflict_link
modifier|*
name|wl
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
comment|/* This check is only needed for coalesced nodes, but hey.  */
if|if
condition|(
name|alias
argument_list|(
name|web
argument_list|)
operator|->
name|type
operator|!=
name|SPILLED
condition|)
continue|continue;
comment|/* For the spilled web itself we also need to clear it's 	   uplink, to be able to rebuild smaller webs.  After all 	   spilling has split the web.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|web
operator|->
name|num_uses
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|id
init|=
name|DF_REF_ID
argument_list|(
name|web
operator|->
name|uses
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|SET_BIT
argument_list|(
name|last_check_uses
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|uses_as_bitmap
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|web_parts
index|[
name|df
operator|->
name|def_id
operator|+
name|id
index|]
operator|.
name|uplink
operator|=
name|NULL
expr_stmt|;
name|web_parts
index|[
name|df
operator|->
name|def_id
operator|+
name|id
index|]
operator|.
name|spanned_deaths
operator|=
literal|0
expr_stmt|;
name|web_parts
index|[
name|df
operator|->
name|def_id
operator|+
name|id
index|]
operator|.
name|crosses_call
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|web
operator|->
name|num_defs
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|id
init|=
name|DF_REF_ID
argument_list|(
name|web
operator|->
name|defs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|web_parts
index|[
name|id
index|]
operator|.
name|uplink
operator|=
name|NULL
expr_stmt|;
name|web_parts
index|[
name|id
index|]
operator|.
name|spanned_deaths
operator|=
literal|0
expr_stmt|;
name|web_parts
index|[
name|id
index|]
operator|.
name|crosses_call
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now look at all neighbors of this spilled web.  */
if|if
condition|(
name|web
operator|->
name|have_orig_conflicts
condition|)
name|wl
operator|=
name|web
operator|->
name|orig_conflict_list
expr_stmt|;
else|else
name|wl
operator|=
name|web
operator|->
name|conflict_list
expr_stmt|;
for|for
control|(
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TEST_BIT
argument_list|(
name|already_webs
argument_list|,
name|wl
operator|->
name|t
operator|->
name|id
argument_list|)
condition|)
continue|continue;
name|SET_BIT
argument_list|(
name|already_webs
argument_list|,
name|wl
operator|->
name|t
operator|->
name|id
argument_list|)
expr_stmt|;
name|mark_refs_for_checking
argument_list|(
name|wl
operator|->
name|t
argument_list|,
name|uses_as_bitmap
argument_list|)
expr_stmt|;
block|}
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|web->useless_conflicts
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|{ 	    struct web *web2 = ID2WEB (j); 	    if (TEST_BIT (already_webs, web2->id)) 	      continue; 	    SET_BIT (already_webs, web2->id); 	    mark_refs_for_checking (web2, uses_as_bitmap); 	  }
argument_list|)
empty_stmt|;
block|}
comment|/* We also recheck unconditionally all uses of any hardregs.  This means      we _can_ delete all these uses from the live_at_end[] bitmaps.      And because we sometimes delete insn refering to hardregs (when      they became useless because they setup a rematerializable pseudo, which      then was rematerialized), some of those uses will go away with the next      df_analyse().  This means we even _must_ delete those uses from      the live_at_end[] bitmaps.  For simplicity we simply delete      all of them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
index|]
condition|)
block|{
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|df
operator|->
name|regs
index|[
name|i
index|]
operator|.
name|uses
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
if|if
condition|(
name|link
operator|->
name|ref
condition|)
name|bitmap_set_bit
argument_list|(
name|uses_as_bitmap
argument_list|,
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The information in live_at_end[] will be rebuild for all uses      we recheck, so clear it here (the uses of spilled webs, might      indeed not become member of it again).  */
name|live_at_end
operator|-=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
name|int
operator|)
name|last_basic_block
operator|+
literal|2
condition|;
name|i
operator|++
control|)
name|bitmap_operation
argument_list|(
name|live_at_end
index|[
name|i
index|]
argument_list|,
name|live_at_end
index|[
name|i
index|]
argument_list|,
name|uses_as_bitmap
argument_list|,
name|BITMAP_AND_COMPL
argument_list|)
expr_stmt|;
name|live_at_end
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
operator|&&
operator|(
name|debug_new_regalloc
operator|&
name|DUMP_REBUILD
operator|)
operator|!=
literal|0
condition|)
block|{
name|ra_debug_msg
argument_list|(
name|DUMP_REBUILD
argument_list|,
literal|"need to check these uses:\n"
argument_list|)
expr_stmt|;
name|dump_sbitmap_file
argument_list|(
name|rtl_dump_file
argument_list|,
name|last_check_uses
argument_list|)
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|already_webs
argument_list|)
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|uses_as_bitmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Statistics about deleted insns, which are useless now.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|deleted_def_insns
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|deleted_def_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In rewrite_program2() we noticed, when a certain insn set a pseudo    which wasn't live.  Try to delete all those insns.  */
end_comment

begin_function
specifier|static
name|void
name|delete_useless_defs
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* If the insn only sets the def without any sideeffect (besides      clobbers or uses), we can delete it.  single_set() also tests      for INSN_P(insn).  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|useless_defs
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{       rtx insn = DF_REF_INSN (df->defs[i]);       rtx set = single_set (insn);       struct web *web = find_web_for_subweb (def2web[i]);       if (set&& web->type == SPILLED&& web->stack_slot == NULL)         { 	  deleted_def_insns++; 	  deleted_def_cost += BLOCK_FOR_INSN (insn)->frequency +
literal|1
argument|; 	  PUT_CODE (insn, NOTE); 	  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED; 	  df_insn_modify (df, BLOCK_FOR_INSN (insn), insn); 	}     }
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Look for spilled webs, on whose behalf no insns were emitted.    We inversify (sp?) the changed flag of the webs, so after this function    a nonzero changed flag means, that this web was not spillable (at least    in this pass).  */
end_comment

begin_function
specifier|static
name|void
name|detect_non_changed_webs
parameter_list|()
block|{
name|struct
name|dlist
modifier|*
name|d
decl_stmt|,
modifier|*
name|d_next
decl_stmt|;
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|SPILLED
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d_next
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|d_next
operator|=
name|d
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|web
operator|->
name|changed
condition|)
block|{
name|ra_debug_msg
argument_list|(
name|DUMP_PROCESS
argument_list|,
literal|"no insns emitted for spilled web %d\n"
argument_list|,
name|web
operator|->
name|id
argument_list|)
expr_stmt|;
name|remove_web_from_list
argument_list|(
name|web
argument_list|)
expr_stmt|;
name|put_web
argument_list|(
name|web
argument_list|,
name|COLORED
argument_list|)
expr_stmt|;
name|web
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|web
operator|->
name|changed
operator|=
literal|0
expr_stmt|;
comment|/* From now on web->changed is used as the opposite flag. 	 I.e. colored webs, which have changed set were formerly 	 spilled webs for which no insns were emitted.  */
block|}
block|}
end_function

begin_comment
comment|/* Before spilling we clear the changed flags for all spilled webs.  */
end_comment

begin_function
specifier|static
name|void
name|reset_changed_flag
parameter_list|()
block|{
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|SPILLED
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
operator|->
name|changed
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The toplevel function for this file.  Given a colorized graph,    and lists of spilled, coalesced and colored webs, we add some    spill code.  This also sets up the structures for incrementally    building the interference graph in the next pass.  */
end_comment

begin_function
name|void
name|actual_spill
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|bitmap
name|new_deaths
init|=
name|BITMAP_XMALLOC
argument_list|()
decl_stmt|;
name|reset_changed_flag
argument_list|()
expr_stmt|;
name|spill_coalprop
argument_list|()
expr_stmt|;
name|choose_spill_colors
argument_list|()
expr_stmt|;
name|useless_defs
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_ra_improved_spilling
condition|)
name|rewrite_program2
argument_list|(
name|new_deaths
argument_list|)
expr_stmt|;
else|else
name|rewrite_program
argument_list|(
name|new_deaths
argument_list|)
expr_stmt|;
name|insert_stores
argument_list|(
name|new_deaths
argument_list|)
expr_stmt|;
name|delete_useless_defs
argument_list|()
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|useless_defs
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|insns_with_deaths
argument_list|)
expr_stmt|;
name|insns_with_deaths
operator|=
name|sbitmap_alloc
argument_list|(
name|get_max_uid
argument_list|()
argument_list|)
expr_stmt|;
name|death_insns_max_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|insns_with_deaths
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|new_deaths
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ SET_BIT (insns_with_deaths, i);}
argument_list|)
empty_stmt|;
name|detect_non_changed_webs
argument_list|()
expr_stmt|;
name|detect_web_parts_to_rebuild
argument_list|()
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|new_deaths
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A bitmap of pseudo reg numbers which are coalesced directly    to a hardreg.  Set in emit_colors(), used and freed in    remove_suspicious_death_notes().  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|regnos_coalesced_to_hardregs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create new pseudos for each web we colored, change insns to    use those pseudos and set up ra_reg_renumber.  */
end_comment

begin_function
name|void
name|emit_colors
parameter_list|(
name|df
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|si
decl_stmt|;
name|struct
name|web
modifier|*
name|web
decl_stmt|;
name|int
name|old_max_regno
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|regset
name|old_regs
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* This bitmap is freed in remove_suspicious_death_notes(),      which is also the user of it.  */
name|regnos_coalesced_to_hardregs
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
comment|/* First create the (REG xx) rtx's for all webs, as we need to know      the number, to make sure, flow has enough memory for them in the      various tables.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_webs
operator|-
name|num_subwebs
condition|;
name|i
operator|++
control|)
block|{
name|web
operator|=
name|ID2WEB
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|type
operator|!=
name|COLORED
operator|&&
name|web
operator|->
name|type
operator|!=
name|COALESCED
condition|)
continue|continue;
if|if
condition|(
name|web
operator|->
name|type
operator|==
name|COALESCED
operator|&&
name|alias
argument_list|(
name|web
argument_list|)
operator|->
name|type
operator|==
name|COLORED
condition|)
continue|continue;
if|if
condition|(
name|web
operator|->
name|reg_rtx
operator|||
name|web
operator|->
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|regno
operator|>=
name|max_normal_pseudo
condition|)
block|{
name|rtx
name|place
decl_stmt|;
if|if
condition|(
name|web
operator|->
name|color
operator|==
name|an_unusable_color
condition|)
block|{
name|unsigned
name|int
name|inherent_size
init|=
name|PSEUDO_REGNO_BYTES
argument_list|(
name|web
operator|->
name|regno
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|total_size
init|=
name|MAX
argument_list|(
name|inherent_size
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|place
operator|=
name|assign_stack_local
argument_list|(
name|PSEUDO_REGNO_MODE
argument_list|(
name|web
operator|->
name|regno
argument_list|)
argument_list|,
name|total_size
argument_list|,
name|inherent_size
operator|==
name|total_size
condition|?
literal|0
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|place
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|regno_reg_rtx
index|[
name|web
operator|->
name|regno
index|]
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|place
argument_list|,
name|new_alias_set
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|place
operator|=
name|gen_reg_rtx
argument_list|(
name|PSEUDO_REGNO_MODE
argument_list|(
name|web
operator|->
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|web
operator|->
name|reg_rtx
operator|=
name|place
expr_stmt|;
block|}
else|else
block|{
comment|/* Special case for i386 'fix_truncdi_nomemory' insn. 	     We must choose mode from insns not from PSEUDO_REGNO_MODE. 	     Actual only for clobbered register.  */
if|if
condition|(
name|web
operator|->
name|num_uses
operator|==
literal|0
operator|&&
name|web
operator|->
name|num_defs
operator|==
literal|1
condition|)
name|web
operator|->
name|reg_rtx
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|DF_REF_REAL_REG
argument_list|(
name|web
operator|->
name|defs
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|web
operator|->
name|reg_rtx
operator|=
name|gen_reg_rtx
argument_list|(
name|PSEUDO_REGNO_MODE
argument_list|(
name|web
operator|->
name|regno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remember the different parts directly coalesced to a hardreg.  */
if|if
condition|(
name|web
operator|->
name|type
operator|==
name|COALESCED
condition|)
name|bitmap_set_bit
argument_list|(
name|regnos_coalesced_to_hardregs
argument_list|,
name|REGNO
argument_list|(
name|web
operator|->
name|reg_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ra_max_regno
operator|=
name|max_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|allocate_reg_info
argument_list|(
name|max_regno
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ra_reg_renumber
operator|=
operator|(
name|short
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|si
operator|=
literal|0
init|;
name|si
operator|<
name|max_regno
condition|;
name|si
operator|++
control|)
name|ra_reg_renumber
index|[
name|si
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Then go through all references, and replace them by a new      pseudoreg for each web.  All uses.  */
comment|/* XXX      Beware: The order of replacements (first uses, then defs) matters only      for read-mod-write insns, where the RTL expression for the REG is      shared between def and use.  For normal rmw insns we connected all such      webs, i.e. both the use and the def (which are the same memory)      there get the same new pseudo-reg, so order would not matter.      _However_ we did not connect webs, were the read cycle was an      uninitialized read.  If we now would first replace the def reference      and then the use ref, we would initialize it with a REG rtx, which      gets never initialized, and yet more wrong, which would overwrite      the definition of the other REG rtx.  So we must replace the defs last.    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df
operator|->
name|use_id
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|df
operator|->
name|uses
index|[
name|i
index|]
condition|)
block|{
name|regset
name|rs
init|=
name|DF_REF_BB
argument_list|(
name|df
operator|->
name|uses
index|[
name|i
index|]
argument_list|)
operator|->
name|global_live_at_start
decl_stmt|;
name|rtx
name|regrtx
decl_stmt|;
name|web
operator|=
name|use2web
index|[
name|i
index|]
expr_stmt|;
name|web
operator|=
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|type
operator|!=
name|COLORED
operator|&&
name|web
operator|->
name|type
operator|!=
name|COALESCED
condition|)
continue|continue;
name|regrtx
operator|=
name|alias
argument_list|(
name|web
argument_list|)
operator|->
name|reg_rtx
expr_stmt|;
if|if
condition|(
operator|!
name|regrtx
condition|)
name|regrtx
operator|=
name|web
operator|->
name|reg_rtx
expr_stmt|;
operator|*
name|DF_REF_REAL_LOC
argument_list|(
name|df
operator|->
name|uses
index|[
name|i
index|]
argument_list|)
operator|=
name|regrtx
expr_stmt|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|rs
argument_list|,
name|web
operator|->
name|regno
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|regrtx
argument_list|)
condition|)
block|{
comment|/*CLEAR_REGNO_REG_SET (rs, web->regno);*/
name|SET_REGNO_REG_SET
argument_list|(
name|rs
argument_list|,
name|REGNO
argument_list|(
name|regrtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* And all defs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df
operator|->
name|def_id
condition|;
name|i
operator|++
control|)
block|{
name|regset
name|rs
decl_stmt|;
name|rtx
name|regrtx
decl_stmt|;
if|if
condition|(
operator|!
name|df
operator|->
name|defs
index|[
name|i
index|]
condition|)
continue|continue;
name|rs
operator|=
name|DF_REF_BB
argument_list|(
name|df
operator|->
name|defs
index|[
name|i
index|]
argument_list|)
operator|->
name|global_live_at_start
expr_stmt|;
name|web
operator|=
name|def2web
index|[
name|i
index|]
expr_stmt|;
name|web
operator|=
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|type
operator|!=
name|COLORED
operator|&&
name|web
operator|->
name|type
operator|!=
name|COALESCED
condition|)
continue|continue;
name|regrtx
operator|=
name|alias
argument_list|(
name|web
argument_list|)
operator|->
name|reg_rtx
expr_stmt|;
if|if
condition|(
operator|!
name|regrtx
condition|)
name|regrtx
operator|=
name|web
operator|->
name|reg_rtx
expr_stmt|;
operator|*
name|DF_REF_REAL_LOC
argument_list|(
name|df
operator|->
name|defs
index|[
name|i
index|]
argument_list|)
operator|=
name|regrtx
expr_stmt|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|rs
argument_list|,
name|web
operator|->
name|regno
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|regrtx
argument_list|)
condition|)
block|{
comment|/* Don't simply clear the current regno, as it might be 	     replaced by two webs.  */
comment|/*CLEAR_REGNO_REG_SET (rs, web->regno);*/
name|SET_REGNO_REG_SET
argument_list|(
name|rs
argument_list|,
name|REGNO
argument_list|(
name|regrtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* And now set up the ra_reg_renumber array for reload with all the new      pseudo-regs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_webs
operator|-
name|num_subwebs
condition|;
name|i
operator|++
control|)
block|{
name|web
operator|=
name|ID2WEB
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|reg_rtx
operator|&&
name|REG_P
argument_list|(
name|web
operator|->
name|reg_rtx
argument_list|)
condition|)
block|{
name|int
name|r
init|=
name|REGNO
argument_list|(
name|web
operator|->
name|reg_rtx
argument_list|)
decl_stmt|;
name|ra_reg_renumber
index|[
name|r
index|]
operator|=
name|web
operator|->
name|color
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_COLORIZE
argument_list|,
literal|"Renumber pseudo %d (== web %d) to %d\n"
argument_list|,
name|r
argument_list|,
name|web
operator|->
name|id
argument_list|,
name|ra_reg_renumber
index|[
name|r
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|old_regs
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
for|for
control|(
name|si
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|si
operator|<
name|old_max_regno
condition|;
name|si
operator|++
control|)
name|SET_REGNO_REG_SET
argument_list|(
name|old_regs
argument_list|,
name|si
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|AND_COMPL_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|old_regs
argument_list|)
expr_stmt|;
name|AND_COMPL_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_end
argument_list|,
name|old_regs
argument_list|)
expr_stmt|;
block|}
name|BITMAP_XFREE
argument_list|(
name|old_regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete some coalesced moves from the insn stream.  */
end_comment

begin_function
name|void
name|delete_moves
parameter_list|()
block|{
name|struct
name|move_list
modifier|*
name|ml
decl_stmt|;
name|struct
name|web
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
comment|/* XXX Beware: We normally would test here each copy insn, if      source and target got the same color (either by coalescing or by pure      luck), and then delete it.      This will currently not work.  One problem is, that we don't color      the regs ourself, but instead defer to reload.  So the colorization      is only a kind of suggestion, which reload doesn't have to follow.      For webs which are coalesced to a normal colored web, we only have one      new pseudo, so in this case we indeed can delete copy insns involving      those (because even if reload colors them different from our suggestion,      it still has to color them the same, as only one pseudo exists).  But for      webs coalesced to precolored ones, we have not a single pseudo, but      instead one for each coalesced web.  This means, that we can't delete      copy insns, where source and target are webs coalesced to precolored      ones, because then the connection between both webs is destroyed.  Note      that this not only means copy insns, where one side is the precolored one      itself, but also those between webs which are coalesced to one color.      Also because reload we can't delete copy insns which involve any      precolored web at all.  These often have also special meaning (e.g.      copying a return value of a call to a pseudo, or copying pseudo to the      return register), and the deletion would confuse reload in thinking the      pseudo isn't needed.  One of those days reload will get away and we can      do everything we want.      In effect because of the later reload, we can't base our deletion on the      colors itself, but instead need to base them on the newly created      pseudos.  */
for|for
control|(
name|ml
operator|=
name|wl_moves
init|;
name|ml
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
comment|/* The real condition we would ideally use is: s->color == t->color.        Additionally: s->type != PRECOLORED&& t->type != PRECOLORED, in case        we want to prevent deletion of "special" copies.  */
if|if
condition|(
name|ml
operator|->
name|move
operator|&&
operator|(
name|s
operator|=
name|alias
argument_list|(
name|ml
operator|->
name|move
operator|->
name|source_web
argument_list|)
operator|)
operator|->
name|reg_rtx
operator|==
operator|(
name|t
operator|=
name|alias
argument_list|(
name|ml
operator|->
name|move
operator|->
name|target_web
argument_list|)
operator|)
operator|->
name|reg_rtx
operator|&&
name|s
operator|->
name|type
operator|!=
name|PRECOLORED
operator|&&
name|t
operator|->
name|type
operator|!=
name|PRECOLORED
condition|)
block|{
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|ml
operator|->
name|move
operator|->
name|insn
argument_list|)
decl_stmt|;
name|df_insn_delete
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|ml
operator|->
name|move
operator|->
name|insn
argument_list|)
expr_stmt|;
name|deleted_move_insns
operator|++
expr_stmt|;
name|deleted_move_cost
operator|+=
name|bb
operator|->
name|frequency
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Due to resons documented elsewhere we create different pseudos    for all webs coalesced to hardregs.  For these parts life_analysis()    might have added REG_DEAD notes without considering, that only this part    but not the whole coalesced web dies.  The RTL is correct, there is no    coalescing yet.  But if later reload's alter_reg() substitutes the    hardreg into the REG rtx it looks like that particular hardreg dies here,    although (due to coalescing) it still is live.  This might make different    places of reload think, it can use that hardreg for reload regs,    accidentally overwriting it.  So we need to remove those REG_DEAD notes.    (Or better teach life_analysis() and reload about our coalescing, but    that comes later) Bah.  */
end_comment

begin_function
name|void
name|remove_suspicious_death_notes
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
modifier|*
name|pnote
init|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|pnote
condition|)
block|{
name|rtx
name|note
init|=
operator|*
name|pnote
decl_stmt|;
if|if
condition|(
operator|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_UNUSED
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|bitmap_bit_p
argument_list|(
name|regnos_coalesced_to_hardregs
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
operator|*
name|pnote
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|pnote
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|BITMAP_XFREE
argument_list|(
name|regnos_coalesced_to_hardregs
argument_list|)
expr_stmt|;
name|regnos_coalesced_to_hardregs
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate space for max_reg_num() pseudo registers, and    fill reg_renumber[] from ra_reg_renumber[].  If FREE_IT    is nonzero, also free ra_reg_renumber and reset ra_max_regno.  */
end_comment

begin_function
name|void
name|setup_renumber
parameter_list|(
name|free_it
parameter_list|)
name|int
name|free_it
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|max_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|allocate_reg_info
argument_list|(
name|max_regno
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
name|reg_renumber
index|[
name|i
index|]
operator|=
operator|(
name|i
operator|<
name|ra_max_regno
operator|)
condition|?
name|ra_reg_renumber
index|[
name|i
index|]
else|:
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|free_it
condition|)
block|{
name|free
argument_list|(
name|ra_reg_renumber
argument_list|)
expr_stmt|;
name|ra_reg_renumber
operator|=
name|NULL
expr_stmt|;
name|ra_max_regno
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump the costs and savings due to spilling, i.e. of added spill insns    and removed moves or useless defs.  */
end_comment

begin_function
name|void
name|dump_cost
parameter_list|(
name|level
parameter_list|)
name|unsigned
name|int
name|level
decl_stmt|;
block|{
name|ra_debug_msg
argument_list|(
name|level
argument_list|,
literal|"Instructions for spilling\n added:\n"
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|level
argument_list|,
literal|"  loads =%d cost="
argument_list|,
name|emitted_spill_loads
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|level
argument_list|,
name|HOST_WIDE_INT_PRINT_UNSIGNED
argument_list|,
name|spill_load_cost
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|level
argument_list|,
literal|"\n  stores=%d cost="
argument_list|,
name|emitted_spill_stores
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|level
argument_list|,
name|HOST_WIDE_INT_PRINT_UNSIGNED
argument_list|,
name|spill_store_cost
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|level
argument_list|,
literal|"\n  remat =%d cost="
argument_list|,
name|emitted_remat
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|level
argument_list|,
name|HOST_WIDE_INT_PRINT_UNSIGNED
argument_list|,
name|spill_remat_cost
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|level
argument_list|,
literal|"\n removed:\n  moves =%d cost="
argument_list|,
name|deleted_move_insns
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|level
argument_list|,
name|HOST_WIDE_INT_PRINT_UNSIGNED
argument_list|,
name|deleted_move_cost
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|level
argument_list|,
literal|"\n  others=%d cost="
argument_list|,
name|deleted_def_insns
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|level
argument_list|,
name|HOST_WIDE_INT_PRINT_UNSIGNED
argument_list|,
name|deleted_def_cost
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|level
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialization of the rewrite phase.  */
end_comment

begin_function
name|void
name|ra_rewrite_init
parameter_list|()
block|{
name|emitted_spill_loads
operator|=
literal|0
expr_stmt|;
name|emitted_spill_stores
operator|=
literal|0
expr_stmt|;
name|emitted_remat
operator|=
literal|0
expr_stmt|;
name|spill_load_cost
operator|=
literal|0
expr_stmt|;
name|spill_store_cost
operator|=
literal|0
expr_stmt|;
name|spill_remat_cost
operator|=
literal|0
expr_stmt|;
name|deleted_move_insns
operator|=
literal|0
expr_stmt|;
name|deleted_move_cost
operator|=
literal|0
expr_stmt|;
name|deleted_def_insns
operator|=
literal|0
expr_stmt|;
name|deleted_def_cost
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* vim:cinoptions={.5s,g0,p5,t0,(0,^-0.5s,n-0.5s:tw=78:cindent:sw=4: */
end_comment

end_unit

