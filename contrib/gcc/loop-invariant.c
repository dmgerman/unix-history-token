begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* RTL-level loop invariant motion.    Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This implements the loop invariant motion pass.  It is very simple    (no calls, libcalls, etc.).  This should be sufficient to cleanup things    like address arithmetics -- other more complicated invariants should be    eliminated on tree level either in tree-ssa-loop-im.c or in tree-ssa-pre.c.     We proceed loop by loop -- it is simpler than trying to handle things    globally and should not lose much.  First we inspect all sets inside loop    and create a dependency graph on insns (saying "to move this insn, you must    also move the following insns").     We then need to determine what to move.  We estimate the number of registers    used and move as many invariants as possible while we still have enough free    registers.  We prefer the expensive invariants.     Then we move the selected invariants out of the loop, creating a new    temporaries for them if necessary.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"df.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_comment
comment|/* The data stored for the loop.  */
end_comment

begin_struct
struct|struct
name|loop_data
block|{
name|struct
name|loop
modifier|*
name|outermost_exit
decl_stmt|;
comment|/* The outermost exit of the loop.  */
name|bool
name|has_call
decl_stmt|;
comment|/* True if the loop contains a call.  */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LOOP_DATA
parameter_list|(
name|LOOP
parameter_list|)
value|((struct loop_data *) (LOOP)->aux)
end_define

begin_comment
comment|/* The description of an use.  */
end_comment

begin_struct
struct|struct
name|use
block|{
name|rtx
modifier|*
name|pos
decl_stmt|;
comment|/* Position of the use.  */
name|rtx
name|insn
decl_stmt|;
comment|/* The insn in that the use occurs.  */
name|struct
name|use
modifier|*
name|next
decl_stmt|;
comment|/* Next use in the list.  */
block|}
struct|;
end_struct

begin_comment
comment|/* The description of a def.  */
end_comment

begin_struct
struct|struct
name|def
block|{
name|struct
name|use
modifier|*
name|uses
decl_stmt|;
comment|/* The list of uses that are uniquely reached 				   by it.  */
name|unsigned
name|n_uses
decl_stmt|;
comment|/* Number of such uses.  */
name|unsigned
name|invno
decl_stmt|;
comment|/* The corresponding invariant.  */
block|}
struct|;
end_struct

begin_comment
comment|/* The data stored for each invariant.  */
end_comment

begin_struct
struct|struct
name|invariant
block|{
comment|/* The number of the invariant.  */
name|unsigned
name|invno
decl_stmt|;
comment|/* The number of the invariant with the same value.  */
name|unsigned
name|eqto
decl_stmt|;
comment|/* If we moved the invariant out of the loop, the register that contains its      value.  */
name|rtx
name|reg
decl_stmt|;
comment|/* The definition of the invariant.  */
name|struct
name|def
modifier|*
name|def
decl_stmt|;
comment|/* The insn in that it is defined.  */
name|rtx
name|insn
decl_stmt|;
comment|/* Whether it is always executed.  */
name|bool
name|always_executed
decl_stmt|;
comment|/* Whether to move the invariant.  */
name|bool
name|move
decl_stmt|;
comment|/* Cost of the invariant.  */
name|unsigned
name|cost
decl_stmt|;
comment|/* The invariants it depends on.  */
name|bitmap
name|depends_on
decl_stmt|;
comment|/* Used for detecting already visited invariants during determining      costs of movements.  */
name|unsigned
name|stamp
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Entry for hash table of invariant expressions.  */
end_comment

begin_struct
struct|struct
name|invariant_expr_entry
block|{
comment|/* The invariant.  */
name|struct
name|invariant
modifier|*
name|inv
decl_stmt|;
comment|/* Its value.  */
name|rtx
name|expr
decl_stmt|;
comment|/* Its mode.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Its hash.  */
name|hashval_t
name|hash
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The actual stamp for marking already visited invariants during determining    costs of movements.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|actual_stamp
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|struct
name|invariant
modifier|*
name|invariant_p
typedef|;
end_typedef

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|invariant_p
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|invariant_p
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The invariants.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|invariant_p
argument_list|,
name|heap
argument_list|)
operator|*
name|invariants
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The dataflow object.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|df
modifier|*
name|df
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Test for possibility of invariantness of X.  */
end_comment

begin_function
specifier|static
name|bool
name|check_maybe_invariant
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
return|return
name|true
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|UNSPEC_VOLATILE
case|:
case|case
name|CALL
case|:
return|return
name|false
return|;
case|case
name|REG
case|:
return|return
name|true
return|;
case|case
name|MEM
case|:
comment|/* Load/store motion is done elsewhere.  ??? Perhaps also add it here? 	 It should not be hard, and might be faster than "elsewhere".  */
comment|/* Just handle the most trivial case where we load from an unchanging 	 location (most importantly, pic tables).  */
if|if
condition|(
name|MEM_READONLY_P
argument_list|(
name|x
argument_list|)
condition|)
break|break;
return|return
name|false
return|;
case|case
name|ASM_OPERANDS
case|:
comment|/* Don't mess with insns declared volatile.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
operator|!
name|check_maybe_invariant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|check_maybe_invariant
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Returns the invariant definition for USE, or NULL if USE is not    invariant.  */
end_comment

begin_function
specifier|static
name|struct
name|invariant
modifier|*
name|invariant_for_use
parameter_list|(
name|struct
name|df_ref
modifier|*
name|use
parameter_list|)
block|{
name|struct
name|df_link
modifier|*
name|defs
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|def
decl_stmt|;
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|use
operator|->
name|insn
argument_list|)
decl_stmt|,
name|def_bb
decl_stmt|;
if|if
condition|(
name|use
operator|->
name|flags
operator|&
name|DF_REF_READ_WRITE
condition|)
return|return
name|NULL
return|;
name|defs
operator|=
name|DF_REF_CHAIN
argument_list|(
name|use
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|defs
operator|||
name|defs
operator|->
name|next
condition|)
return|return
name|NULL
return|;
name|def
operator|=
name|defs
operator|->
name|ref
expr_stmt|;
if|if
condition|(
operator|!
name|DF_REF_DATA
argument_list|(
name|def
argument_list|)
condition|)
return|return
name|NULL
return|;
name|def_bb
operator|=
name|DF_REF_BB
argument_list|(
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|,
name|def_bb
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|DF_REF_DATA
argument_list|(
name|def
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Computes hash value for invariant expression X in INSN.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|hash_invariant_expr_1
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|hashval_t
name|val
init|=
name|code
decl_stmt|;
name|int
name|do_not_record_p
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|use
decl_stmt|;
name|struct
name|invariant
modifier|*
name|inv
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
return|return
name|hash_rtx
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|do_not_record_p
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|)
return|;
case|case
name|REG
case|:
name|use
operator|=
name|df_find_use
argument_list|(
name|df
argument_list|,
name|insn
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use
condition|)
return|return
name|hash_rtx
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|do_not_record_p
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|)
return|;
name|inv
operator|=
name|invariant_for_use
argument_list|(
name|use
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inv
condition|)
return|return
name|hash_rtx
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|do_not_record_p
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|)
return|;
name|gcc_assert
argument_list|(
name|inv
operator|->
name|eqto
operator|!=
operator|~
literal|0u
argument_list|)
expr_stmt|;
return|return
name|inv
operator|->
name|eqto
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|val
operator|^=
name|hash_invariant_expr_1
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|val
operator|^=
name|hash_invariant_expr_1
argument_list|(
name|insn
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'i'
operator|||
name|fmt
index|[
name|i
index|]
operator|==
literal|'n'
condition|)
name|val
operator|^=
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the invariant expressions E1 and E2 used in insns INSN1    and INSN2 have always the same value.  */
end_comment

begin_function
specifier|static
name|bool
name|invariant_expr_equal_p
parameter_list|(
name|rtx
name|insn1
parameter_list|,
name|rtx
name|e1
parameter_list|,
name|rtx
name|insn2
parameter_list|,
name|rtx
name|e2
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|e1
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|use1
decl_stmt|,
modifier|*
name|use2
decl_stmt|;
name|struct
name|invariant
modifier|*
name|inv1
init|=
name|NULL
decl_stmt|,
modifier|*
name|inv2
init|=
name|NULL
decl_stmt|;
name|rtx
name|sub1
decl_stmt|,
name|sub2
decl_stmt|;
comment|/* If mode of only one of the operands is VOIDmode, it is not equivalent to      the other one.  If both are VOIDmode, we rely on the caller of this      function to verify that their modes are the same.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|e2
argument_list|)
operator|||
name|GET_MODE
argument_list|(
name|e1
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|e2
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
return|return
name|rtx_equal_p
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|)
return|;
case|case
name|REG
case|:
name|use1
operator|=
name|df_find_use
argument_list|(
name|df
argument_list|,
name|insn1
argument_list|,
name|e1
argument_list|)
expr_stmt|;
name|use2
operator|=
name|df_find_use
argument_list|(
name|df
argument_list|,
name|insn2
argument_list|,
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
name|use1
condition|)
name|inv1
operator|=
name|invariant_for_use
argument_list|(
name|use1
argument_list|)
expr_stmt|;
if|if
condition|(
name|use2
condition|)
name|inv2
operator|=
name|invariant_for_use
argument_list|(
name|use2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inv1
operator|&&
operator|!
name|inv2
condition|)
return|return
name|rtx_equal_p
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|)
return|;
if|if
condition|(
operator|!
name|inv1
operator|||
operator|!
name|inv2
condition|)
return|return
name|false
return|;
name|gcc_assert
argument_list|(
name|inv1
operator|->
name|eqto
operator|!=
operator|~
literal|0u
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|inv2
operator|->
name|eqto
operator|!=
operator|~
literal|0u
argument_list|)
expr_stmt|;
return|return
name|inv1
operator|->
name|eqto
operator|==
name|inv2
operator|->
name|eqto
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|sub1
operator|=
name|XEXP
argument_list|(
name|e1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sub2
operator|=
name|XEXP
argument_list|(
name|e2
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|invariant_expr_equal_p
argument_list|(
name|insn1
argument_list|,
name|sub1
argument_list|,
name|insn2
argument_list|,
name|sub2
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
if|if
condition|(
name|XVECLEN
argument_list|(
name|e1
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|e2
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|e1
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|sub1
operator|=
name|XVECEXP
argument_list|(
name|e1
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|sub2
operator|=
name|XVECEXP
argument_list|(
name|e2
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|invariant_expr_equal_p
argument_list|(
name|insn1
argument_list|,
name|sub1
argument_list|,
name|insn2
argument_list|,
name|sub2
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'i'
operator|||
name|fmt
index|[
name|i
index|]
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
name|XINT
argument_list|(
name|e1
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|e2
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Unhandled type of subexpression, we fail conservatively.  */
else|else
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Returns hash value for invariant expression entry E.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|hash_invariant_expr
parameter_list|(
specifier|const
name|void
modifier|*
name|e
parameter_list|)
block|{
specifier|const
name|struct
name|invariant_expr_entry
modifier|*
name|entry
init|=
name|e
decl_stmt|;
return|return
name|entry
operator|->
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Compares invariant expression entries E1 and E2.  */
end_comment

begin_function
specifier|static
name|int
name|eq_invariant_expr
parameter_list|(
specifier|const
name|void
modifier|*
name|e1
parameter_list|,
specifier|const
name|void
modifier|*
name|e2
parameter_list|)
block|{
specifier|const
name|struct
name|invariant_expr_entry
modifier|*
name|entry1
init|=
name|e1
decl_stmt|;
specifier|const
name|struct
name|invariant_expr_entry
modifier|*
name|entry2
init|=
name|e2
decl_stmt|;
if|if
condition|(
name|entry1
operator|->
name|mode
operator|!=
name|entry2
operator|->
name|mode
condition|)
return|return
literal|0
return|;
return|return
name|invariant_expr_equal_p
argument_list|(
name|entry1
operator|->
name|inv
operator|->
name|insn
argument_list|,
name|entry1
operator|->
name|expr
argument_list|,
name|entry2
operator|->
name|inv
operator|->
name|insn
argument_list|,
name|entry2
operator|->
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Checks whether invariant with value EXPR in machine mode MODE is    recorded in EQ.  If this is the case, return the invariant.  Otherwise    insert INV to the table for this expression and return INV.  */
end_comment

begin_function
specifier|static
name|struct
name|invariant
modifier|*
name|find_or_insert_inv
parameter_list|(
name|htab_t
name|eq
parameter_list|,
name|rtx
name|expr
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|struct
name|invariant
modifier|*
name|inv
parameter_list|)
block|{
name|hashval_t
name|hash
init|=
name|hash_invariant_expr_1
argument_list|(
name|inv
operator|->
name|insn
argument_list|,
name|expr
argument_list|)
decl_stmt|;
name|struct
name|invariant_expr_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|invariant_expr_entry
name|pentry
decl_stmt|;
name|PTR
modifier|*
name|slot
decl_stmt|;
name|pentry
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
name|pentry
operator|.
name|inv
operator|=
name|inv
expr_stmt|;
name|pentry
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|eq
argument_list|,
operator|&
name|pentry
argument_list|,
name|hash
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|*
name|slot
expr_stmt|;
if|if
condition|(
name|entry
condition|)
return|return
name|entry
operator|->
name|inv
return|;
name|entry
operator|=
name|XNEW
argument_list|(
expr|struct
name|invariant_expr_entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|inv
operator|=
name|inv
expr_stmt|;
name|entry
operator|->
name|expr
operator|=
name|expr
expr_stmt|;
name|entry
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|entry
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
operator|*
name|slot
operator|=
name|entry
expr_stmt|;
return|return
name|inv
return|;
block|}
end_function

begin_comment
comment|/* Finds invariants identical to INV and records the equivalence.  EQ is the    hash table of the invariants.  */
end_comment

begin_function
specifier|static
name|void
name|find_identical_invariants
parameter_list|(
name|htab_t
name|eq
parameter_list|,
name|struct
name|invariant
modifier|*
name|inv
parameter_list|)
block|{
name|unsigned
name|depno
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|struct
name|invariant
modifier|*
name|dep
decl_stmt|;
name|rtx
name|expr
decl_stmt|,
name|set
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|inv
operator|->
name|eqto
operator|!=
operator|~
literal|0u
condition|)
return|return;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|inv->depends_on
argument_list|,
literal|0
argument_list|,
argument|depno
argument_list|,
argument|bi
argument_list|)
block|{
name|dep
operator|=
name|VEC_index
argument_list|(
name|invariant_p
argument_list|,
name|invariants
argument_list|,
name|depno
argument_list|)
expr_stmt|;
name|find_identical_invariants
argument_list|(
name|eq
argument_list|,
name|dep
argument_list|)
expr_stmt|;
block|}
name|set
operator|=
name|single_set
argument_list|(
name|inv
operator|->
name|insn
argument_list|)
expr_stmt|;
name|expr
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|inv
operator|->
name|eqto
operator|=
name|find_or_insert_inv
argument_list|(
name|eq
argument_list|,
name|expr
argument_list|,
name|mode
argument_list|,
name|inv
argument_list|)
operator|->
name|invno
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
name|inv
operator|->
name|eqto
operator|!=
name|inv
operator|->
name|invno
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Invariant %d is equivalent to invariant %d.\n"
argument_list|,
name|inv
operator|->
name|invno
argument_list|,
name|inv
operator|->
name|eqto
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find invariants with the same value and record the equivalences.  */
end_comment

begin_function
specifier|static
name|void
name|merge_identical_invariants
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|invariant
modifier|*
name|inv
decl_stmt|;
name|htab_t
name|eq
init|=
name|htab_create
argument_list|(
name|VEC_length
argument_list|(
name|invariant_p
argument_list|,
name|invariants
argument_list|)
argument_list|,
name|hash_invariant_expr
argument_list|,
name|eq_invariant_expr
argument_list|,
name|free
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|invariant_p
argument_list|,
name|invariants
argument_list|,
name|i
argument_list|,
name|inv
argument_list|)
condition|;
name|i
operator|++
control|)
name|find_identical_invariants
argument_list|(
name|eq
argument_list|,
name|inv
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|eq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determines the basic blocks inside LOOP that are always executed and    stores their bitmap to ALWAYS_REACHED.  MAY_EXIT is a bitmap of    basic blocks that may either exit the loop, or contain the call that    does not have to return.  BODY is body of the loop obtained by    get_loop_body_in_dom_order.  */
end_comment

begin_function
specifier|static
name|void
name|compute_always_reached
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
modifier|*
name|body
parameter_list|,
name|bitmap
name|may_exit
parameter_list|,
name|bitmap
name|always_reached
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loop
operator|->
name|latch
argument_list|,
name|body
index|[
name|i
index|]
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|always_reached
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|may_exit
argument_list|,
name|i
argument_list|)
condition|)
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Finds exits out of the LOOP with body BODY.  Marks blocks in that we may    exit the loop by cfg edge to HAS_EXIT and MAY_EXIT.  In MAY_EXIT    additionally mark blocks that may exit due to a call.  */
end_comment

begin_function
specifier|static
name|void
name|find_exits
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
modifier|*
name|body
parameter_list|,
name|bitmap
name|may_exit
parameter_list|,
name|bitmap
name|has_exit
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|struct
name|loop
modifier|*
name|outermost_exit
init|=
name|loop
decl_stmt|,
modifier|*
name|aexit
decl_stmt|;
name|bool
name|has_call
init|=
name|false
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|body
index|[
name|i
index|]
operator|->
name|loop_father
operator|==
name|loop
condition|)
block|{
name|FOR_BB_INSNS
argument_list|(
argument|body[i]
argument_list|,
argument|insn
argument_list|)
block|{
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|has_call
operator|=
name|true
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|may_exit
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|body[i]->succs
argument_list|)
block|{
if|if
condition|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
continue|continue;
name|bitmap_set_bit
argument_list|(
name|may_exit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|has_exit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|outermost_exit
operator|=
name|find_common_loop
argument_list|(
name|outermost_exit
argument_list|,
name|e
operator|->
name|dest
operator|->
name|loop_father
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Use the data stored for the subloop to decide whether we may exit 	 through it.  It is sufficient to do this for header of the loop, 	 as other basic blocks inside it must be dominated by it.  */
if|if
condition|(
name|body
index|[
name|i
index|]
operator|->
name|loop_father
operator|->
name|header
operator|!=
name|body
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|LOOP_DATA
argument_list|(
name|body
index|[
name|i
index|]
operator|->
name|loop_father
argument_list|)
operator|->
name|has_call
condition|)
block|{
name|has_call
operator|=
name|true
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|may_exit
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|aexit
operator|=
name|LOOP_DATA
argument_list|(
name|body
index|[
name|i
index|]
operator|->
name|loop_father
argument_list|)
operator|->
name|outermost_exit
expr_stmt|;
if|if
condition|(
name|aexit
operator|!=
name|loop
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|may_exit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|has_exit
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow_loop_nested_p
argument_list|(
name|aexit
argument_list|,
name|outermost_exit
argument_list|)
condition|)
name|outermost_exit
operator|=
name|aexit
expr_stmt|;
block|}
block|}
name|loop
operator|->
name|aux
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|loop_data
argument_list|)
argument_list|)
expr_stmt|;
name|LOOP_DATA
argument_list|(
name|loop
argument_list|)
operator|->
name|outermost_exit
operator|=
name|outermost_exit
expr_stmt|;
name|LOOP_DATA
argument_list|(
name|loop
argument_list|)
operator|->
name|has_call
operator|=
name|has_call
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check whether we may assign a value to X from a register.  */
end_comment

begin_function
specifier|static
name|bool
name|may_assign_reg_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|can_copy_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
name|REG_P
argument_list|(
name|x
argument_list|)
operator|||
operator|!
name|HARD_REGISTER_P
argument_list|(
name|x
argument_list|)
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|NO_REGS
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Finds definitions that may correspond to invariants in LOOP with body    BODY.  */
end_comment

begin_function
specifier|static
name|void
name|find_defs
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
modifier|*
name|body
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|bitmap
name|blocks
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
name|bitmap_set_bit
argument_list|(
name|blocks
argument_list|,
name|body
index|[
name|i
index|]
operator|->
name|index
argument_list|)
expr_stmt|;
name|df_set_blocks
argument_list|(
name|df
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
name|df_analyze
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Creates a new invariant for definition DEF in INSN, depending on invariants    in DEPENDS_ON.  ALWAYS_EXECUTED is true if the insn is always executed,    unless the program ends due to a function call.  The newly created invariant    is returned.  */
end_comment

begin_function
specifier|static
name|struct
name|invariant
modifier|*
name|create_new_invariant
parameter_list|(
name|struct
name|def
modifier|*
name|def
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|bitmap
name|depends_on
parameter_list|,
name|bool
name|always_executed
parameter_list|)
block|{
name|struct
name|invariant
modifier|*
name|inv
init|=
name|XNEW
argument_list|(
expr|struct
name|invariant
argument_list|)
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|inv
operator|->
name|def
operator|=
name|def
expr_stmt|;
name|inv
operator|->
name|always_executed
operator|=
name|always_executed
expr_stmt|;
name|inv
operator|->
name|depends_on
operator|=
name|depends_on
expr_stmt|;
comment|/* If the set is simple, usually by moving it we move the whole store out of      the loop.  Otherwise we save only cost of the computation.  */
if|if
condition|(
name|def
condition|)
name|inv
operator|->
name|cost
operator|=
name|rtx_cost
argument_list|(
name|set
argument_list|,
name|SET
argument_list|)
expr_stmt|;
else|else
name|inv
operator|->
name|cost
operator|=
name|rtx_cost
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
name|inv
operator|->
name|move
operator|=
name|false
expr_stmt|;
name|inv
operator|->
name|reg
operator|=
name|NULL_RTX
expr_stmt|;
name|inv
operator|->
name|stamp
operator|=
literal|0
expr_stmt|;
name|inv
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|inv
operator|->
name|invno
operator|=
name|VEC_length
argument_list|(
name|invariant_p
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|inv
operator|->
name|eqto
operator|=
operator|~
literal|0u
expr_stmt|;
if|if
condition|(
name|def
condition|)
name|def
operator|->
name|invno
operator|=
name|inv
operator|->
name|invno
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|invariant_p
argument_list|,
name|heap
argument_list|,
name|invariants
argument_list|,
name|inv
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Set in insn %d is invariant (%d), cost %d, depends on "
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|inv
operator|->
name|invno
argument_list|,
name|inv
operator|->
name|cost
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|dump_file
argument_list|,
name|inv
operator|->
name|depends_on
argument_list|)
expr_stmt|;
block|}
return|return
name|inv
return|;
block|}
end_function

begin_comment
comment|/* Record USE at DEF.  */
end_comment

begin_function
specifier|static
name|void
name|record_use
parameter_list|(
name|struct
name|def
modifier|*
name|def
parameter_list|,
name|rtx
modifier|*
name|use
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|use
modifier|*
name|u
init|=
name|XNEW
argument_list|(
expr|struct
name|use
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|use
argument_list|)
operator|==
name|SUBREG
condition|)
name|use
operator|=
operator|&
name|SUBREG_REG
argument_list|(
operator|*
name|use
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
operator|*
name|use
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|->
name|pos
operator|=
name|use
expr_stmt|;
name|u
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|u
operator|->
name|next
operator|=
name|def
operator|->
name|uses
expr_stmt|;
name|def
operator|->
name|uses
operator|=
name|u
expr_stmt|;
name|def
operator|->
name|n_uses
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finds the invariants INSN depends on and store them to the DEPENDS_ON    bitmap.  Returns true if all dependencies of INSN are known to be    loop invariants, false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|check_dependencies
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|bitmap
name|depends_on
parameter_list|)
block|{
name|struct
name|df_link
modifier|*
name|defs
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|use
decl_stmt|,
modifier|*
name|def
decl_stmt|;
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|,
name|def_bb
decl_stmt|;
name|struct
name|def
modifier|*
name|def_data
decl_stmt|;
name|struct
name|invariant
modifier|*
name|inv
decl_stmt|;
for|for
control|(
name|use
operator|=
name|DF_INSN_GET
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
operator|->
name|uses
init|;
name|use
condition|;
name|use
operator|=
name|use
operator|->
name|next_ref
control|)
block|{
if|if
condition|(
name|use
operator|->
name|flags
operator|&
name|DF_REF_READ_WRITE
condition|)
return|return
name|false
return|;
name|defs
operator|=
name|DF_REF_CHAIN
argument_list|(
name|use
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|defs
condition|)
continue|continue;
if|if
condition|(
name|defs
operator|->
name|next
condition|)
return|return
name|false
return|;
name|def
operator|=
name|defs
operator|->
name|ref
expr_stmt|;
name|inv
operator|=
name|DF_REF_DATA
argument_list|(
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inv
condition|)
return|return
name|false
return|;
name|def_data
operator|=
name|inv
operator|->
name|def
expr_stmt|;
name|gcc_assert
argument_list|(
name|def_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|def_bb
operator|=
name|DF_REF_BB
argument_list|(
name|def
argument_list|)
expr_stmt|;
comment|/* Note that in case bb == def_bb, we know that the definition dominates 	 insn, because def has DF_REF_DATA defined and we process the insns 	 in the basic block bb sequentially.  */
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|,
name|def_bb
argument_list|)
condition|)
return|return
name|false
return|;
name|bitmap_set_bit
argument_list|(
name|depends_on
argument_list|,
name|def_data
operator|->
name|invno
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finds invariant in INSN.  ALWAYS_REACHED is true if the insn is always    executed.  ALWAYS_EXECUTED is true if the insn is always executed,    unless the program ends due to a function call.  */
end_comment

begin_function
specifier|static
name|void
name|find_invariant_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|bool
name|always_reached
parameter_list|,
name|bool
name|always_executed
parameter_list|)
block|{
name|struct
name|df_ref
modifier|*
name|ref
decl_stmt|;
name|struct
name|def
modifier|*
name|def
decl_stmt|;
name|bitmap
name|depends_on
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|dest
decl_stmt|;
name|bool
name|simple
init|=
name|true
decl_stmt|;
name|struct
name|invariant
modifier|*
name|inv
decl_stmt|;
comment|/* Until we get rid of LIBCALLS.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|||
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|||
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_NO_CONFLICT
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* We can't move a CC0 setter without the user.  */
if|if
condition|(
name|sets_cc0_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
endif|#
directive|endif
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|dest
argument_list|)
operator|||
name|HARD_REGISTER_P
argument_list|(
name|dest
argument_list|)
condition|)
name|simple
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|may_assign_reg_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|||
operator|!
name|check_maybe_invariant
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* If the insn can throw exception, we cannot move it at all without changing      cfg.  */
if|if
condition|(
name|can_throw_internal
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
comment|/* We cannot make trapping insn executed, unless it was executed before.  */
if|if
condition|(
name|may_trap_after_code_motion_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
operator|!
name|always_reached
condition|)
return|return;
name|depends_on
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|check_dependencies
argument_list|(
name|insn
argument_list|,
name|depends_on
argument_list|)
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|depends_on
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|simple
condition|)
name|def
operator|=
name|XCNEW
argument_list|(
expr|struct
name|def
argument_list|)
expr_stmt|;
else|else
name|def
operator|=
name|NULL
expr_stmt|;
name|inv
operator|=
name|create_new_invariant
argument_list|(
name|def
argument_list|,
name|insn
argument_list|,
name|depends_on
argument_list|,
name|always_executed
argument_list|)
expr_stmt|;
if|if
condition|(
name|simple
condition|)
block|{
name|ref
operator|=
name|df_find_def
argument_list|(
name|df
argument_list|,
name|insn
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|DF_REF_DATA
argument_list|(
name|ref
argument_list|)
operator|=
name|inv
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record registers used in INSN that have a unique invariant definition.  */
end_comment

begin_function
specifier|static
name|void
name|record_uses
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|df_ref
modifier|*
name|use
decl_stmt|;
name|struct
name|invariant
modifier|*
name|inv
decl_stmt|;
for|for
control|(
name|use
operator|=
name|DF_INSN_GET
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
operator|->
name|uses
init|;
name|use
condition|;
name|use
operator|=
name|use
operator|->
name|next_ref
control|)
block|{
name|inv
operator|=
name|invariant_for_use
argument_list|(
name|use
argument_list|)
expr_stmt|;
if|if
condition|(
name|inv
condition|)
name|record_use
argument_list|(
name|inv
operator|->
name|def
argument_list|,
name|DF_REF_LOC
argument_list|(
name|use
argument_list|)
argument_list|,
name|DF_REF_INSN
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finds invariants in INSN.  ALWAYS_REACHED is true if the insn is always    executed.  ALWAYS_EXECUTED is true if the insn is always executed,    unless the program ends due to a function call.  */
end_comment

begin_function
specifier|static
name|void
name|find_invariants_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|bool
name|always_reached
parameter_list|,
name|bool
name|always_executed
parameter_list|)
block|{
name|find_invariant_insn
argument_list|(
name|insn
argument_list|,
name|always_reached
argument_list|,
name|always_executed
argument_list|)
expr_stmt|;
name|record_uses
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finds invariants in basic block BB.  ALWAYS_REACHED is true if the    basic block is always executed.  ALWAYS_EXECUTED is true if the basic    block is always executed, unless the program ends due to a function    call.  */
end_comment

begin_function
specifier|static
name|void
name|find_invariants_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|bool
name|always_reached
parameter_list|,
name|bool
name|always_executed
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|FOR_BB_INSNS
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|find_invariants_insn
argument_list|(
name|insn
argument_list|,
name|always_reached
argument_list|,
name|always_executed
argument_list|)
expr_stmt|;
if|if
condition|(
name|always_reached
operator|&&
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|always_reached
operator|=
name|false
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finds invariants in LOOP with body BODY.  ALWAYS_REACHED is the bitmap of    basic blocks in BODY that are always executed.  ALWAYS_EXECUTED is the    bitmap of basic blocks in BODY that are always executed unless the program    ends due to a function call.  */
end_comment

begin_function
specifier|static
name|void
name|find_invariants_body
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
modifier|*
name|body
parameter_list|,
name|bitmap
name|always_reached
parameter_list|,
name|bitmap
name|always_executed
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
name|find_invariants_bb
argument_list|(
name|body
index|[
name|i
index|]
argument_list|,
name|bitmap_bit_p
argument_list|(
name|always_reached
argument_list|,
name|i
argument_list|)
argument_list|,
name|bitmap_bit_p
argument_list|(
name|always_executed
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finds invariants in LOOP.  */
end_comment

begin_function
specifier|static
name|void
name|find_invariants
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|bitmap
name|may_exit
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|bitmap
name|always_reached
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|bitmap
name|has_exit
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|bitmap
name|always_executed
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|basic_block
modifier|*
name|body
init|=
name|get_loop_body_in_dom_order
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|find_exits
argument_list|(
name|loop
argument_list|,
name|body
argument_list|,
name|may_exit
argument_list|,
name|has_exit
argument_list|)
expr_stmt|;
name|compute_always_reached
argument_list|(
name|loop
argument_list|,
name|body
argument_list|,
name|may_exit
argument_list|,
name|always_reached
argument_list|)
expr_stmt|;
name|compute_always_reached
argument_list|(
name|loop
argument_list|,
name|body
argument_list|,
name|has_exit
argument_list|,
name|always_executed
argument_list|)
expr_stmt|;
name|find_defs
argument_list|(
name|loop
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|find_invariants_body
argument_list|(
name|loop
argument_list|,
name|body
argument_list|,
name|always_reached
argument_list|,
name|always_executed
argument_list|)
expr_stmt|;
name|merge_identical_invariants
argument_list|()
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|always_reached
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|always_executed
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|may_exit
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|has_exit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Frees a list of uses USE.  */
end_comment

begin_function
specifier|static
name|void
name|free_use_list
parameter_list|(
name|struct
name|use
modifier|*
name|use
parameter_list|)
block|{
name|struct
name|use
modifier|*
name|next
decl_stmt|;
for|for
control|(
init|;
name|use
condition|;
name|use
operator|=
name|next
control|)
block|{
name|next
operator|=
name|use
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|use
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Calculates cost and number of registers needed for moving invariant INV    out of the loop and stores them to *COST and *REGS_NEEDED.  */
end_comment

begin_function
specifier|static
name|void
name|get_inv_cost
parameter_list|(
name|struct
name|invariant
modifier|*
name|inv
parameter_list|,
name|int
modifier|*
name|comp_cost
parameter_list|,
name|unsigned
modifier|*
name|regs_needed
parameter_list|)
block|{
name|int
name|acomp_cost
decl_stmt|;
name|unsigned
name|aregs_needed
decl_stmt|;
name|unsigned
name|depno
decl_stmt|;
name|struct
name|invariant
modifier|*
name|dep
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* Find the representative of the class of the equivalent invariants.  */
name|inv
operator|=
name|VEC_index
argument_list|(
name|invariant_p
argument_list|,
name|invariants
argument_list|,
name|inv
operator|->
name|eqto
argument_list|)
expr_stmt|;
operator|*
name|comp_cost
operator|=
literal|0
expr_stmt|;
operator|*
name|regs_needed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inv
operator|->
name|move
operator|||
name|inv
operator|->
name|stamp
operator|==
name|actual_stamp
condition|)
return|return;
name|inv
operator|->
name|stamp
operator|=
name|actual_stamp
expr_stmt|;
operator|(
operator|*
name|regs_needed
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|comp_cost
operator|)
operator|+=
name|inv
operator|->
name|cost
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
block|{
comment|/* Hoisting constant pool constants into stack regs may cost more than        just single register.  On x87, the balance is affected both by the        small number of FP registers, and by its register stack organization,        that forces us to add compensation code in and around the loop to        shuffle the operands to the top of stack before use, and pop them        from the stack after the loop finishes.         To model this effect, we increase the number of registers needed for        stack registers by two: one register push, and one register pop.        This usually has the effect that FP constant loads from the constant        pool are not moved out of the loop.         Note that this also means that dependent invariants can not be moved.        However, the primary purpose of this pass is to move loop invariant        address arithmetic out of loops, and address arithmetic that depends        on floating point constants is unlikely to ever occur.  */
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|inv
operator|->
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|IS_STACK_MODE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|constant_pool_constant_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
operator|(
operator|*
name|regs_needed
operator|)
operator|+=
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|inv->depends_on
argument_list|,
literal|0
argument_list|,
argument|depno
argument_list|,
argument|bi
argument_list|)
block|{
name|dep
operator|=
name|VEC_index
argument_list|(
name|invariant_p
argument_list|,
name|invariants
argument_list|,
name|depno
argument_list|)
expr_stmt|;
name|get_inv_cost
argument_list|(
name|dep
argument_list|,
operator|&
name|acomp_cost
argument_list|,
operator|&
name|aregs_needed
argument_list|)
expr_stmt|;
if|if
condition|(
name|aregs_needed
comment|/* We need to check always_executed, since if the original value of 	     the invariant may be preserved, we may need to keep it in a 	     separate register.  TODO check whether the register has an 	     use outside of the loop.  */
operator|&&
name|dep
operator|->
name|always_executed
operator|&&
operator|!
name|dep
operator|->
name|def
operator|->
name|uses
operator|->
name|next
condition|)
block|{
comment|/* If this is a single use, after moving the dependency we will not 	     need a new register.  */
name|aregs_needed
operator|--
expr_stmt|;
block|}
operator|(
operator|*
name|regs_needed
operator|)
operator|+=
name|aregs_needed
expr_stmt|;
operator|(
operator|*
name|comp_cost
operator|)
operator|+=
name|acomp_cost
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Calculates gain for eliminating invariant INV.  REGS_USED is the number    of registers used in the loop, N_INV_USES is the number of uses of    invariants, NEW_REGS is the number of new variables already added due to    the invariant motion.  The number of registers needed for it is stored in    *REGS_NEEDED.  */
end_comment

begin_function
specifier|static
name|int
name|gain_for_invariant
parameter_list|(
name|struct
name|invariant
modifier|*
name|inv
parameter_list|,
name|unsigned
modifier|*
name|regs_needed
parameter_list|,
name|unsigned
name|new_regs
parameter_list|,
name|unsigned
name|regs_used
parameter_list|,
name|unsigned
name|n_inv_uses
parameter_list|)
block|{
name|int
name|comp_cost
decl_stmt|,
name|size_cost
decl_stmt|;
name|get_inv_cost
argument_list|(
name|inv
argument_list|,
operator|&
name|comp_cost
argument_list|,
name|regs_needed
argument_list|)
expr_stmt|;
name|actual_stamp
operator|++
expr_stmt|;
name|size_cost
operator|=
operator|(
name|global_cost_for_size
argument_list|(
name|new_regs
operator|+
operator|*
name|regs_needed
argument_list|,
name|regs_used
argument_list|,
name|n_inv_uses
argument_list|)
operator|-
name|global_cost_for_size
argument_list|(
name|new_regs
argument_list|,
name|regs_used
argument_list|,
name|n_inv_uses
argument_list|)
operator|)
expr_stmt|;
return|return
name|comp_cost
operator|-
name|size_cost
return|;
block|}
end_function

begin_comment
comment|/* Finds invariant with best gain for moving.  Returns the gain, stores    the invariant in *BEST and number of registers needed for it to    *REGS_NEEDED.  REGS_USED is the number of registers used in    the loop, N_INV_USES is the number of uses of invariants.  NEW_REGS    is the number of new variables already added due to invariant motion.  */
end_comment

begin_function
specifier|static
name|int
name|best_gain_for_invariant
parameter_list|(
name|struct
name|invariant
modifier|*
modifier|*
name|best
parameter_list|,
name|unsigned
modifier|*
name|regs_needed
parameter_list|,
name|unsigned
name|new_regs
parameter_list|,
name|unsigned
name|regs_used
parameter_list|,
name|unsigned
name|n_inv_uses
parameter_list|)
block|{
name|struct
name|invariant
modifier|*
name|inv
decl_stmt|;
name|int
name|gain
init|=
literal|0
decl_stmt|,
name|again
decl_stmt|;
name|unsigned
name|aregs_needed
decl_stmt|,
name|invno
decl_stmt|;
for|for
control|(
name|invno
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|invariant_p
argument_list|,
name|invariants
argument_list|,
name|invno
argument_list|,
name|inv
argument_list|)
condition|;
name|invno
operator|++
control|)
block|{
if|if
condition|(
name|inv
operator|->
name|move
condition|)
continue|continue;
comment|/* Only consider the "representatives" of equivalent invariants.  */
if|if
condition|(
name|inv
operator|->
name|eqto
operator|!=
name|inv
operator|->
name|invno
condition|)
continue|continue;
name|again
operator|=
name|gain_for_invariant
argument_list|(
name|inv
argument_list|,
operator|&
name|aregs_needed
argument_list|,
name|new_regs
argument_list|,
name|regs_used
argument_list|,
name|n_inv_uses
argument_list|)
expr_stmt|;
if|if
condition|(
name|again
operator|>
name|gain
condition|)
block|{
name|gain
operator|=
name|again
expr_stmt|;
operator|*
name|best
operator|=
name|inv
expr_stmt|;
operator|*
name|regs_needed
operator|=
name|aregs_needed
expr_stmt|;
block|}
block|}
return|return
name|gain
return|;
block|}
end_function

begin_comment
comment|/* Marks invariant INVNO and all its dependencies for moving.  */
end_comment

begin_function
specifier|static
name|void
name|set_move_mark
parameter_list|(
name|unsigned
name|invno
parameter_list|)
block|{
name|struct
name|invariant
modifier|*
name|inv
init|=
name|VEC_index
argument_list|(
name|invariant_p
argument_list|,
name|invariants
argument_list|,
name|invno
argument_list|)
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* Find the representative of the class of the equivalent invariants.  */
name|inv
operator|=
name|VEC_index
argument_list|(
name|invariant_p
argument_list|,
name|invariants
argument_list|,
name|inv
operator|->
name|eqto
argument_list|)
expr_stmt|;
if|if
condition|(
name|inv
operator|->
name|move
condition|)
return|return;
name|inv
operator|->
name|move
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Decided to move invariant %d\n"
argument_list|,
name|invno
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|inv->depends_on
argument_list|,
literal|0
argument_list|,
argument|invno
argument_list|,
argument|bi
argument_list|)
block|{
name|set_move_mark
argument_list|(
name|invno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determines which invariants to move.  */
end_comment

begin_function
specifier|static
name|void
name|find_invariants_to_move
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|regs_used
decl_stmt|,
name|n_inv_uses
decl_stmt|,
name|regs_needed
init|=
literal|0
decl_stmt|,
name|new_regs
decl_stmt|;
name|struct
name|invariant
modifier|*
name|inv
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|n_regs
init|=
name|DF_REG_SIZE
argument_list|(
name|df
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|VEC_length
argument_list|(
name|invariant_p
argument_list|,
name|invariants
argument_list|)
condition|)
return|return;
comment|/* Now something slightly more involved.  First estimate the number of used      registers.  */
name|n_inv_uses
operator|=
literal|0
expr_stmt|;
comment|/* We do not really do a good job in this estimation; put some initial bound      here to stand for induction variables etc. that we do not detect.  */
name|regs_used
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_regs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|DF_REGNO_FIRST_DEF
argument_list|(
name|df
argument_list|,
name|i
argument_list|)
operator|&&
name|DF_REGNO_LAST_USE
argument_list|(
name|df
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* This is a value that is used but not changed inside loop.  */
name|regs_used
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|invariant_p
argument_list|,
name|invariants
argument_list|,
name|i
argument_list|,
name|inv
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inv
operator|->
name|def
condition|)
name|n_inv_uses
operator|+=
name|inv
operator|->
name|def
operator|->
name|n_uses
expr_stmt|;
block|}
name|new_regs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|best_gain_for_invariant
argument_list|(
operator|&
name|inv
argument_list|,
operator|&
name|regs_needed
argument_list|,
name|new_regs
argument_list|,
name|regs_used
argument_list|,
name|n_inv_uses
argument_list|)
operator|>
literal|0
condition|)
block|{
name|set_move_mark
argument_list|(
name|inv
operator|->
name|invno
argument_list|)
expr_stmt|;
name|new_regs
operator|+=
name|regs_needed
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns true if all insns in SEQ are valid.  */
end_comment

begin_function
specifier|static
name|bool
name|seq_insns_valid_p
parameter_list|(
name|rtx
name|seq
parameter_list|)
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|seq
init|;
name|x
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|insn_invalid_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Move invariant INVNO out of the LOOP.  Returns true if this succeeds, false    otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|move_invariant_reg
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|unsigned
name|invno
parameter_list|)
block|{
name|struct
name|invariant
modifier|*
name|inv
init|=
name|VEC_index
argument_list|(
name|invariant_p
argument_list|,
name|invariants
argument_list|,
name|invno
argument_list|)
decl_stmt|;
name|struct
name|invariant
modifier|*
name|repr
init|=
name|VEC_index
argument_list|(
name|invariant_p
argument_list|,
name|invariants
argument_list|,
name|inv
operator|->
name|eqto
argument_list|)
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|basic_block
name|preheader
init|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
operator|->
name|src
decl_stmt|;
name|rtx
name|reg
decl_stmt|,
name|set
decl_stmt|,
name|dest
decl_stmt|,
name|seq
decl_stmt|,
name|op
decl_stmt|;
name|struct
name|use
modifier|*
name|use
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
if|if
condition|(
name|inv
operator|->
name|reg
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|repr
operator|->
name|move
condition|)
return|return
name|false
return|;
comment|/* If this is a representative of the class of equivalent invariants,      really move the invariant.  Otherwise just replace its use with      the register used for the representative.  */
if|if
condition|(
name|inv
operator|==
name|repr
condition|)
block|{
if|if
condition|(
name|inv
operator|->
name|depends_on
condition|)
block|{
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|inv->depends_on
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
if|if
condition|(
operator|!
name|move_invariant_reg
argument_list|(
name|loop
argument_list|,
name|i
argument_list|)
condition|)
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Move the set out of the loop.  If the set is always executed (we could 	 omit this condition if we know that the register is unused outside of the 	 loop, but it does not seem worth finding out) and it has no uses that 	 would not be dominated by it, we may just move it (TODO).  Otherwise we 	 need to create a temporary register.  */
name|set
operator|=
name|single_set
argument_list|(
name|inv
operator|->
name|insn
argument_list|)
expr_stmt|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the SET_DEST of the invariant insn is a pseudo, we can just move 	 the insn out of the loop.  Otherwise, we have to use gen_move_insn 	 to let emit_move_insn produce a valid instruction stream.  */
if|if
condition|(
name|REG_P
argument_list|(
name|dest
argument_list|)
operator|&&
operator|!
name|HARD_REGISTER_P
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|dest
argument_list|,
name|reg
argument_list|)
argument_list|,
name|inv
operator|->
name|insn
argument_list|)
expr_stmt|;
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|=
name|reg
expr_stmt|;
name|reorder_insns
argument_list|(
name|inv
operator|->
name|insn
argument_list|,
name|inv
operator|->
name|insn
argument_list|,
name|BB_END
argument_list|(
name|preheader
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|op
operator|=
name|force_operand
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|op
operator|!=
name|reg
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|seq_insns_valid_p
argument_list|(
name|seq
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|BB_END
argument_list|(
name|preheader
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|dest
argument_list|,
name|reg
argument_list|)
argument_list|,
name|inv
operator|->
name|insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|inv
operator|->
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|move_invariant_reg
argument_list|(
name|loop
argument_list|,
name|repr
operator|->
name|invno
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|reg
operator|=
name|repr
operator|->
name|reg
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|inv
operator|->
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|reg
argument_list|)
argument_list|,
name|inv
operator|->
name|insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|inv
operator|->
name|insn
argument_list|)
expr_stmt|;
block|}
name|inv
operator|->
name|reg
operator|=
name|reg
expr_stmt|;
comment|/* Replace the uses we know to be dominated.  It saves work for copy      propagation, and also it is necessary so that dependent invariants      are computed right.  */
if|if
condition|(
name|inv
operator|->
name|def
condition|)
block|{
for|for
control|(
name|use
operator|=
name|inv
operator|->
name|def
operator|->
name|uses
init|;
name|use
condition|;
name|use
operator|=
name|use
operator|->
name|next
control|)
operator|*
name|use
operator|->
name|pos
operator|=
name|reg
expr_stmt|;
block|}
return|return
name|true
return|;
name|fail
label|:
comment|/* If we failed, clear move flag, so that we do not try to move inv      again.  */
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Failed to move invariant %d\n"
argument_list|,
name|invno
argument_list|)
expr_stmt|;
name|inv
operator|->
name|move
operator|=
name|false
expr_stmt|;
name|inv
operator|->
name|reg
operator|=
name|NULL_RTX
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Move selected invariant out of the LOOP.  Newly created regs are marked    in TEMPORARY_REGS.  */
end_comment

begin_function
specifier|static
name|void
name|move_invariants
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|struct
name|invariant
modifier|*
name|inv
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|invariant_p
argument_list|,
name|invariants
argument_list|,
name|i
argument_list|,
name|inv
argument_list|)
condition|;
name|i
operator|++
control|)
name|move_invariant_reg
argument_list|(
name|loop
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initializes invariant motion data.  */
end_comment

begin_function
specifier|static
name|void
name|init_inv_motion_data
parameter_list|(
name|void
parameter_list|)
block|{
name|actual_stamp
operator|=
literal|1
expr_stmt|;
name|invariants
operator|=
name|VEC_alloc
argument_list|(
name|invariant_p
argument_list|,
name|heap
argument_list|,
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Frees the data allocated by invariant motion.  */
end_comment

begin_function
specifier|static
name|void
name|free_inv_motion_data
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|def
modifier|*
name|def
decl_stmt|;
name|struct
name|invariant
modifier|*
name|inv
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DF_DEFS_SIZE
argument_list|(
name|df
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|df_ref
modifier|*
name|ref
init|=
name|DF_DEFS_GET
argument_list|(
name|df
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
continue|continue;
name|inv
operator|=
name|DF_REF_DATA
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inv
condition|)
continue|continue;
name|def
operator|=
name|inv
operator|->
name|def
expr_stmt|;
name|gcc_assert
argument_list|(
name|def
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|free_use_list
argument_list|(
name|def
operator|->
name|uses
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
argument_list|)
expr_stmt|;
name|DF_REF_DATA
argument_list|(
name|ref
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|invariant_p
argument_list|,
name|invariants
argument_list|,
name|i
argument_list|,
name|inv
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|BITMAP_FREE
argument_list|(
name|inv
operator|->
name|depends_on
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inv
argument_list|)
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|invariant_p
argument_list|,
name|heap
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move the invariants out of the LOOP.  */
end_comment

begin_function
specifier|static
name|void
name|move_single_loop_invariants
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|init_inv_motion_data
argument_list|()
expr_stmt|;
name|find_invariants
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|find_invariants_to_move
argument_list|()
expr_stmt|;
name|move_invariants
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|free_inv_motion_data
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Releases the auxiliary data for LOOP.  */
end_comment

begin_function
specifier|static
name|void
name|free_loop_data
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|struct
name|loop_data
modifier|*
name|data
init|=
name|LOOP_DATA
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|loop
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move the invariants out of the LOOPS.  */
end_comment

begin_function
name|void
name|move_loop_invariants
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|df
operator|=
name|df_init
argument_list|(
name|DF_HARD_REGS
operator||
name|DF_EQUIV_NOTES
argument_list|)
expr_stmt|;
name|df_chain_add_problem
argument_list|(
name|df
argument_list|,
name|DF_UD_CHAIN
argument_list|)
expr_stmt|;
comment|/* Process the loops, innermost first.  */
name|loop
operator|=
name|loops
operator|->
name|tree_root
expr_stmt|;
while|while
condition|(
name|loop
operator|->
name|inner
condition|)
name|loop
operator|=
name|loop
operator|->
name|inner
expr_stmt|;
while|while
condition|(
name|loop
operator|!=
name|loops
operator|->
name|tree_root
condition|)
block|{
name|move_single_loop_invariants
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|next
condition|)
block|{
name|loop
operator|=
name|loop
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|loop
operator|->
name|inner
condition|)
name|loop
operator|=
name|loop
operator|->
name|inner
expr_stmt|;
block|}
else|else
name|loop
operator|=
name|loop
operator|->
name|outer
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|loops
operator|->
name|parray
index|[
name|i
index|]
condition|)
name|free_loop_data
argument_list|(
name|loops
operator|->
name|parray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|df_finish
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|df
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

