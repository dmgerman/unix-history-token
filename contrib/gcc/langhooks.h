begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The lang_hooks data structure.    Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GCC_LANG_HOOKS_H
end_ifndef

begin_define
define|#
directive|define
name|GCC_LANG_HOOKS_H
end_define

begin_comment
comment|/* This file should be #include-d after tree.h.  */
end_comment

begin_struct_decl
struct_decl|struct
name|diagnostic_context
struct_decl|;
end_struct_decl

begin_comment
comment|/* A print hook for print_tree ().  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|lang_print_tree_hook
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* The following hooks are documented in langhooks.c.  Must not be    NULL.  */
end_comment

begin_struct
struct|struct
name|lang_hooks_for_tree_inlining
block|{
name|tree
function_decl|(
modifier|*
name|walk_subtrees
function_decl|)
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|tree
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|cannot_inline_tree_fn
function_decl|)
parameter_list|(
name|tree
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|disregard_inline_limits
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
name|tree
function_decl|(
modifier|*
name|add_pending_fn_decls
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|tree_chain_matters_p
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|auto_var_in_fn_p
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
name|tree
function_decl|(
modifier|*
name|copy_res_decl_for_inlining
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|anon_aggr_type_p
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
name|bool
function_decl|(
modifier|*
name|var_mod_type_p
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|start_inlining
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|end_inlining
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
name|tree
function_decl|(
modifier|*
name|convert_parm_for_inlining
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|estimate_num_insns
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|lang_hooks_for_callgraph
block|{
comment|/* The node passed is a language-specific tree node.  If its contents      are relevant to use of other declarations, mark them.  */
name|tree
function_decl|(
modifier|*
name|analyze_expr
function_decl|)
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
comment|/* Produce RTL for function passed as argument.  */
name|void
function_decl|(
modifier|*
name|expand_function
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* Lang hooks for management of language-specific data or status    when entering / leaving functions etc.  */
end_comment

begin_struct
struct|struct
name|lang_hooks_for_functions
block|{
comment|/* Called when entering a function.  */
name|void
function_decl|(
modifier|*
name|init
function_decl|)
parameter_list|(
name|struct
name|function
modifier|*
parameter_list|)
function_decl|;
comment|/* Called when leaving a function.  */
name|void
function_decl|(
modifier|*
name|final
function_decl|)
parameter_list|(
name|struct
name|function
modifier|*
parameter_list|)
function_decl|;
comment|/* Called when entering a nested function.  */
name|void
function_decl|(
modifier|*
name|enter_nested
function_decl|)
parameter_list|(
name|struct
name|function
modifier|*
parameter_list|)
function_decl|;
comment|/* Called when leaving a nested function.  */
name|void
function_decl|(
modifier|*
name|leave_nested
function_decl|)
parameter_list|(
name|struct
name|function
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* Lang hooks for rtl code generation.  */
end_comment

begin_struct
struct|struct
name|lang_hooks_for_rtl_expansion
block|{
comment|/* Called after expand_function_start, but before expanding the body.  */
name|void
function_decl|(
modifier|*
name|start
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Called to expand each statement.  */
name|void
function_decl|(
modifier|*
name|stmt
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Called after expanding the body but before expand_function_end.  */
name|void
function_decl|(
modifier|*
name|end
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following hooks are used by tree-dump.c.  */
end_comment

begin_struct
struct|struct
name|lang_hooks_for_tree_dump
block|{
comment|/* Dump language-specific parts of tree nodes.  Returns nonzero if it      does not want the usual dumping of the second argument.  */
name|bool
function_decl|(
modifier|*
name|dump_tree
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
comment|/* Determine type qualifiers in a language-specific way.  */
name|int
function_decl|(
modifier|*
name|type_quals
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* Hooks related to types.  */
end_comment

begin_struct
struct|struct
name|lang_hooks_for_types
block|{
comment|/* Return a new type (with the indicated CODE), doing whatever      language-specific processing is required.  */
name|tree
function_decl|(
modifier|*
name|make_type
function_decl|)
parameter_list|(
name|enum
name|tree_code
parameter_list|)
function_decl|;
comment|/* Given MODE and UNSIGNEDP, return a suitable type-tree with that      mode.  */
name|tree
function_decl|(
modifier|*
name|type_for_mode
function_decl|)
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* Given PRECISION and UNSIGNEDP, return a suitable type-tree for an      integer type with at least that precision.  */
name|tree
function_decl|(
modifier|*
name|type_for_size
function_decl|)
parameter_list|(
name|unsigned
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* Given an integer type T, return a type like T but unsigned.      If T is unsigned, the value is T.  */
name|tree
function_decl|(
modifier|*
name|unsigned_type
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Given an integer type T, return a type like T but signed.      If T is signed, the value is T.  */
name|tree
function_decl|(
modifier|*
name|signed_type
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Return a type the same as TYPE except unsigned or signed      according to UNSIGNEDP.  */
name|tree
function_decl|(
modifier|*
name|signed_or_unsigned_type
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
comment|/* Given a type, apply default promotions to unnamed function      arguments and return the new type.  Return the same type if no      change.  Required by any language that supports variadic      arguments.  The default hook aborts.  */
name|tree
function_decl|(
modifier|*
name|type_promotes_to
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Register TYPE as a builtin type with the indicated NAME.  The      TYPE is placed in the outermost lexical scope.  The semantics      should be analogous to:         typedef TYPE NAME;       in C.  The default hook ignores the declaration.  */
name|void
function_decl|(
modifier|*
name|register_builtin_type
function_decl|)
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
comment|/* This routine is called in tree.c to print an error message for      invalid use of an incomplete type.  VALUE is the expression that      was used (or 0 if that isn't known) and TYPE is the type that was      invalid.  */
name|void
function_decl|(
modifier|*
name|incomplete_type_error
function_decl|)
parameter_list|(
name|tree
name|value
parameter_list|,
name|tree
name|type
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* Language hooks related to decls and the symbol table.  */
end_comment

begin_struct
struct|struct
name|lang_hooks_for_decls
block|{
comment|/* Enter a new lexical scope.  Argument is always zero when called      from outside the front end.  */
name|void
function_decl|(
modifier|*
name|pushlevel
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
comment|/* Exit a lexical scope and return a BINDING for that scope.      Takes three arguments:      KEEP -- nonzero if there were declarations in this scope.      REVERSE -- reverse the order of decls before returning them.      FUNCTIONBODY -- nonzero if this level is the body of a function.  */
name|tree
function_decl|(
modifier|*
name|poplevel
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* Returns nonzero if we are in the global binding level.  Ada      returns -1 for an undocumented reason used in stor-layout.c.  */
name|int
function_decl|(
modifier|*
name|global_bindings_p
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Insert BLOCK at the end of the list of subblocks of the      current binding level.  This is used when a BIND_EXPR is expanded,      to handle the BLOCK node inside the BIND_EXPR.  */
name|void
function_decl|(
modifier|*
name|insert_block
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Set the BLOCK node for the current scope level.  */
name|void
function_decl|(
modifier|*
name|set_block
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Function to add a decl to the current scope level.  Takes one      argument, a decl to add.  Returns that decl, or, if the same      symbol is already declared, may return a different decl for that      name.  */
name|tree
function_decl|(
modifier|*
name|pushdecl
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Returns the chain of decls so far in the current scope level.  */
name|tree
function_decl|(
modifier|*
name|getdecls
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Returns a chain of TYPE_DECLs for built-in types.  */
name|tree
function_decl|(
modifier|*
name|builtin_type_decls
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Returns true when we should warn for an unused global DECL.      We will already have checked that it has static binding.  */
name|bool
function_decl|(
modifier|*
name|warn_unused_global
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Obtain a list of globals and do final output on them at end      of compilation */
name|void
function_decl|(
modifier|*
name|final_write_globals
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Do necessary preparations before assemble_variable can proceed.  */
name|void
function_decl|(
modifier|*
name|prepare_assemble_variable
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* True if this decl may be called via a sibcall.  */
name|bool
function_decl|(
modifier|*
name|ok_for_sibcall
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* Language-specific hooks.  See langhooks-def.h for defaults.  */
end_comment

begin_struct
struct|struct
name|lang_hooks
block|{
comment|/* String identifying the front end.  e.g. "GNU C++".  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* sizeof (struct lang_identifier), so make_node () creates      identifier nodes long enough for the language-specific slots.  */
name|size_t
name|identifier_size
decl_stmt|;
comment|/* Determines the size of any language-specific 'x' or 'c' nodes.      Since it is called from make_node, the only information available      is the tree code.  Expected to abort on unrecognized codes.  */
name|size_t
function_decl|(
modifier|*
name|tree_size
function_decl|)
parameter_list|(
name|enum
name|tree_code
parameter_list|)
function_decl|;
comment|/* The first callback made to the front end, for simple      initialization needed before any calls to handle_option.  Return      the language mask to filter the switch array with.  */
name|unsigned
name|int
function_decl|(
modifier|*
name|init_options
function_decl|)
parameter_list|(
name|unsigned
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
comment|/* Callback used to perform language-specific initialization for the      global diagnostic context structure.  */
name|void
function_decl|(
modifier|*
name|initialize_diagnostics
function_decl|)
parameter_list|(
name|struct
name|diagnostic_context
modifier|*
parameter_list|)
function_decl|;
comment|/* Handle the switch CODE, which has real type enum opt_code from      options.h.  If the switch takes an argument, it is passed in ARG      which points to permanent storage.  The handler is responsible for      checking whether ARG is NULL, which indicates that no argument      was in fact supplied.  For -f and -W switches, VALUE is 1 or 0      for the positive and negative forms respectively.       Return 1 if the switch is valid, 0 if invalid, and -1 if it's      valid and should not be treated as language-independent too.  */
name|int
function_decl|(
modifier|*
name|handle_option
function_decl|)
parameter_list|(
name|size_t
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
comment|/* Return false to use the default complaint about a missing      argument, otherwise output a complaint and return true.  */
name|bool
function_decl|(
modifier|*
name|missing_argument
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|opt
parameter_list|,
name|size_t
name|code
parameter_list|)
function_decl|;
comment|/* Called when all command line options have been parsed to allow      further processing and initialization       Should return true to indicate that a compiler back-end is      not required, such as with the -E option.       If errorcount is nonzero after this call the compiler exits      immediately and the finish hook is not called.  */
name|bool
function_decl|(
modifier|*
name|post_options
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
comment|/* Called after post_options to initialize the front end.  Return      false to indicate that no further compilation be performed, in      which case the finish hook is called immediately.  */
name|bool
function_decl|(
modifier|*
name|init
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Called at the end of compilation, as a finalizer.  */
name|void
function_decl|(
modifier|*
name|finish
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Parses the entire file.  The argument is nonzero to cause bison      parsers to dump debugging information during parsing.  */
name|void
function_decl|(
modifier|*
name|parse_file
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
comment|/* Called immediately after parsing to clear the binding stack.  */
name|void
function_decl|(
modifier|*
name|clear_binding_stack
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Called to obtain the alias set to be used for an expression or type.      Returns -1 if the language does nothing special for it.  */
name|HOST_WIDE_INT
function_decl|(
modifier|*
name|get_alias_set
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Called with an expression that is to be processed as a constant.      Returns either the same expression or a language-independent      constant equivalent to its input.  */
name|tree
function_decl|(
modifier|*
name|expand_constant
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Called by expand_expr for language-specific tree codes.      Fourth argument is actually an enum expand_modifier.  */
name|rtx
function_decl|(
modifier|*
name|expand_expr
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
comment|/* Prepare expr to be an argument of a TRUTH_NOT_EXPR or other logical      operation.       This preparation consists of taking the ordinary representation      of an expression expr and producing a valid tree boolean      expression describing whether expr is nonzero.  We could simply      always do build_binary_op (NE_EXPR, expr, integer_zero_node, 1),      but we optimize comparisons,&&, ||, and !.       The result should be an expression of boolean type (if not an      error_mark_node).  */
name|tree
function_decl|(
modifier|*
name|truthvalue_conversion
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Hook called by safe_from_p for language-specific tree codes.  It is      up to the language front-end to install a hook if it has any such      codes that safe_from_p needs to know about.  Since same_from_p will      recursively explore the TREE_OPERANDs of an expression, this hook      should not reexamine those pieces.  This routine may recursively      call safe_from_p; it should always pass `0' as the TOP_P      parameter.  */
name|int
function_decl|(
modifier|*
name|safe_from_p
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|tree
parameter_list|)
function_decl|;
comment|/* Function to finish handling an incomplete decl at the end of      compilation.  Default hook is does nothing.  */
name|void
function_decl|(
modifier|*
name|finish_incomplete_decl
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Function used by unsafe_for_reeval.  A non-negative number is      returned directly from unsafe_for_reeval, a negative number falls      through.  The default hook returns a negative number.  */
name|int
function_decl|(
modifier|*
name|unsafe_for_reeval
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Mark EXP saying that we need to be able to take the address of      it; it should not be allocated in a register.  Return true if      successful.  */
name|bool
function_decl|(
modifier|*
name|mark_addressable
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Hook called by staticp for language-specific tree codes.  */
name|int
function_decl|(
modifier|*
name|staticp
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Replace the DECL_LANG_SPECIFIC data, which may be NULL, of the      DECL_NODE with a newly GC-allocated copy.  */
name|void
function_decl|(
modifier|*
name|dup_lang_specific_decl
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Called before its argument, an UNSAVE_EXPR, is to be      unsaved.  Modify it in-place so that all the evaluate only once      things are cleared out.  */
name|tree
function_decl|(
modifier|*
name|unsave_expr_now
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Called by expand_expr to build and return the cleanup-expression      for the passed TARGET_EXPR.  Return NULL if there is none.  */
name|tree
function_decl|(
modifier|*
name|maybe_build_cleanup
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Set the DECL_ASSEMBLER_NAME for a node.  If it is the sort of      thing that the assembler should talk about, set      DECL_ASSEMBLER_NAME to an appropriate IDENTIFIER_NODE.      Otherwise, set it to the ERROR_MARK_NODE to ensure that the      assembler does not talk about it.  */
name|void
function_decl|(
modifier|*
name|set_decl_assembler_name
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Return nonzero if fold-const is free to use bit-field      optimizations, for instance in fold_truthop().  */
name|bool
function_decl|(
modifier|*
name|can_use_bit_fields_p
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Nonzero if TYPE_READONLY and TREE_READONLY should always be honored.  */
name|bool
name|honor_readonly
decl_stmt|;
comment|/* Nonzero if this front end does not generate a dummy BLOCK between      the outermost scope of the function and the FUNCTION_DECL.  See      is_body_block in stmt.c, and its callers.  */
name|bool
name|no_body_blocks
decl_stmt|;
comment|/* The front end can add its own statistics to -fmem-report with      this hook.  It should output to stderr.  */
name|void
function_decl|(
modifier|*
name|print_statistics
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Called by print_tree when there is a tree of class 'x' that it      doesn't know how to display.  */
name|lang_print_tree_hook
name|print_xnode
decl_stmt|;
comment|/* Called to print language-dependent parts of a class 'd', class      't', and IDENTIFIER_NODE nodes.  */
name|lang_print_tree_hook
name|print_decl
decl_stmt|;
name|lang_print_tree_hook
name|print_type
decl_stmt|;
name|lang_print_tree_hook
name|print_identifier
decl_stmt|;
comment|/* Computes the name to use to print a declaration.  DECL is the      non-NULL declaration in question.  VERBOSITY determines what      information will be printed: 0: DECL_NAME, demangled as      necessary.  1: and scope information.  2: and any other      information that might be interesting, such as function parameter      types in C++.  */
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|decl_printable_name
function_decl|)
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|verbosity
parameter_list|)
function_decl|;
comment|/* Given a CALL_EXPR, return a function decl that is its target.  */
name|tree
function_decl|(
modifier|*
name|lang_get_callee_fndecl
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Called by report_error_function to print out function name.  */
name|void
function_decl|(
modifier|*
name|print_error_function
function_decl|)
parameter_list|(
name|struct
name|diagnostic_context
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
comment|/* Called from expr_size to calculate the size of the value of an      expression in a language-dependent way.  Returns a tree for the size      in bytes.  A frontend can call lhd_expr_size to get the default      semantics in cases that it doesn't want to handle specially.  */
name|tree
function_decl|(
modifier|*
name|expr_size
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Called from uninitialized_vars_warning to find out if a variable is      uninitialized based on DECL_INITIAL.  */
name|bool
function_decl|(
modifier|*
name|decl_uninit
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Pointers to machine-independent attribute tables, for front ends      using attribs.c.  If one is NULL, it is ignored.  Respectively, a      table of attributes specific to the language, a table of      attributes common to two or more languages (to allow easy      sharing), and a table of attributes for checking formats.  */
specifier|const
name|struct
name|attribute_spec
modifier|*
name|attribute_table
decl_stmt|;
specifier|const
name|struct
name|attribute_spec
modifier|*
name|common_attribute_table
decl_stmt|;
specifier|const
name|struct
name|attribute_spec
modifier|*
name|format_attribute_table
decl_stmt|;
comment|/* Function-related language hooks.  */
name|struct
name|lang_hooks_for_functions
name|function
decl_stmt|;
name|struct
name|lang_hooks_for_tree_inlining
name|tree_inlining
decl_stmt|;
name|struct
name|lang_hooks_for_callgraph
name|callgraph
decl_stmt|;
name|struct
name|lang_hooks_for_tree_dump
name|tree_dump
decl_stmt|;
name|struct
name|lang_hooks_for_decls
name|decls
decl_stmt|;
name|struct
name|lang_hooks_for_types
name|types
decl_stmt|;
name|struct
name|lang_hooks_for_rtl_expansion
name|rtl_expand
decl_stmt|;
comment|/* Whenever you add entries here, make sure you adjust langhooks-def.h      and langhooks.c accordingly.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Each front end provides its own.  */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|lang_hooks
name|lang_hooks
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GCC_LANG_HOOKS_H */
end_comment

end_unit

