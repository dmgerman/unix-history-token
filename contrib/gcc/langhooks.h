begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The lang_hooks data structure.    Copyright 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GCC_LANG_HOOKS_H
end_ifndef

begin_define
define|#
directive|define
name|GCC_LANG_HOOKS_H
end_define

begin_comment
comment|/* This file should be #include-d after tree.h.  */
end_comment

begin_struct_decl
struct_decl|struct
name|diagnostic_context
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|gimplify_omp_ctx
struct_decl|;
end_struct_decl

begin_comment
comment|/* A print hook for print_tree ().  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|lang_print_tree_hook
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* The following hooks are documented in langhooks.c.  Must not be    NULL.  */
end_comment

begin_struct
struct|struct
name|lang_hooks_for_tree_inlining
block|{
name|tree
function_decl|(
modifier|*
name|walk_subtrees
function_decl|)
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|tree
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|pointer_set_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|cannot_inline_tree_fn
function_decl|)
parameter_list|(
name|tree
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|disregard_inline_limits
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
name|tree
function_decl|(
modifier|*
name|add_pending_fn_decls
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|auto_var_in_fn_p
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|anon_aggr_type_p
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
name|bool
function_decl|(
modifier|*
name|var_mod_type_p
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|start_inlining
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|end_inlining
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
name|tree
function_decl|(
modifier|*
name|convert_parm_for_inlining
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|lang_hooks_for_callgraph
block|{
comment|/* The node passed is a language-specific tree node.  If its contents      are relevant to use of other declarations, mark them.  */
name|tree
function_decl|(
modifier|*
name|analyze_expr
function_decl|)
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
comment|/* Produce RTL for function passed as argument.  */
name|void
function_decl|(
modifier|*
name|expand_function
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* Lang hooks for management of language-specific data or status    when entering / leaving functions etc.  */
end_comment

begin_struct
struct|struct
name|lang_hooks_for_functions
block|{
comment|/* Called when entering a function.  */
name|void
function_decl|(
modifier|*
name|init
function_decl|)
parameter_list|(
name|struct
name|function
modifier|*
parameter_list|)
function_decl|;
comment|/* Called when leaving a function.  */
name|void
function_decl|(
modifier|*
name|final
function_decl|)
parameter_list|(
name|struct
name|function
modifier|*
parameter_list|)
function_decl|;
comment|/* Called when entering a nested function.  */
name|void
function_decl|(
modifier|*
name|enter_nested
function_decl|)
parameter_list|(
name|struct
name|function
modifier|*
parameter_list|)
function_decl|;
comment|/* Called when leaving a nested function.  */
name|void
function_decl|(
modifier|*
name|leave_nested
function_decl|)
parameter_list|(
name|struct
name|function
modifier|*
parameter_list|)
function_decl|;
comment|/* Determines if it's ok for a function to have no noreturn attribute.  */
name|bool
function_decl|(
modifier|*
name|missing_noreturn_ok_p
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following hooks are used by tree-dump.c.  */
end_comment

begin_struct
struct|struct
name|lang_hooks_for_tree_dump
block|{
comment|/* Dump language-specific parts of tree nodes.  Returns nonzero if it      does not want the usual dumping of the second argument.  */
name|bool
function_decl|(
modifier|*
name|dump_tree
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
comment|/* Determine type qualifiers in a language-specific way.  */
name|int
function_decl|(
modifier|*
name|type_quals
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* Hooks related to types.  */
end_comment

begin_struct
struct|struct
name|lang_hooks_for_types
block|{
comment|/* Return a new type (with the indicated CODE), doing whatever      language-specific processing is required.  */
name|tree
function_decl|(
modifier|*
name|make_type
function_decl|)
parameter_list|(
name|enum
name|tree_code
parameter_list|)
function_decl|;
comment|/* Given MODE and UNSIGNEDP, return a suitable type-tree with that      mode.  */
name|tree
function_decl|(
modifier|*
name|type_for_mode
function_decl|)
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* Given PRECISION and UNSIGNEDP, return a suitable type-tree for an      integer type with at least that precision.  */
name|tree
function_decl|(
modifier|*
name|type_for_size
function_decl|)
parameter_list|(
name|unsigned
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* Given an integer type T, return a type like T but unsigned.      If T is unsigned, the value is T.  */
name|tree
function_decl|(
modifier|*
name|unsigned_type
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Given an integer type T, return a type like T but signed.      If T is signed, the value is T.  */
name|tree
function_decl|(
modifier|*
name|signed_type
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Return a type the same as TYPE except unsigned or signed      according to UNSIGNEDP.  */
name|tree
function_decl|(
modifier|*
name|signed_or_unsigned_type
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
comment|/* True if the type is an instantiation of a generic type,      e.g. C++ template implicit specializations.  */
name|bool
function_decl|(
modifier|*
name|generic_p
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Given a type, apply default promotions to unnamed function      arguments and return the new type.  Return the same type if no      change.  Required by any language that supports variadic      arguments.  The default hook dies.  */
name|tree
function_decl|(
modifier|*
name|type_promotes_to
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Register TYPE as a builtin type with the indicated NAME.  The      TYPE is placed in the outermost lexical scope.  The semantics      should be analogous to:         typedef TYPE NAME;       in C.  The default hook ignores the declaration.  */
name|void
function_decl|(
modifier|*
name|register_builtin_type
function_decl|)
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
comment|/* This routine is called in tree.c to print an error message for      invalid use of an incomplete type.  VALUE is the expression that      was used (or 0 if that isn't known) and TYPE is the type that was      invalid.  */
name|void
function_decl|(
modifier|*
name|incomplete_type_error
function_decl|)
parameter_list|(
name|tree
name|value
parameter_list|,
name|tree
name|type
parameter_list|)
function_decl|;
comment|/* Called from assign_temp to return the maximum size, if there is one,      for a type.  */
name|tree
function_decl|(
modifier|*
name|max_size
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Register language specific type size variables as potentially OpenMP      firstprivate variables.  */
name|void
function_decl|(
modifier|*
name|omp_firstprivatize_type_sizes
function_decl|)
parameter_list|(
name|struct
name|gimplify_omp_ctx
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
comment|/* APPLE LOCAL begin radar 6386976  */
comment|/* Determine whether the type-tree passed in is specific to the      language/runtime definitions, e.g. is an Objective-C class...  */
name|bool
function_decl|(
modifier|*
name|is_runtime_specific_type
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* APPLE LOCAL end radar 6386976  */
comment|/* Nonzero if types that are identical are to be hashed so that only      one copy is kept.  If a language requires unique types for each      user-specified type, such as Ada, this should be set to TRUE.  */
name|bool
name|hash_types
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Language hooks related to decls and the symbol table.  */
end_comment

begin_struct
struct|struct
name|lang_hooks_for_decls
block|{
comment|/* Returns nonzero if we are in the global binding level.  Ada      returns -1 for an undocumented reason used in stor-layout.c.  */
name|int
function_decl|(
modifier|*
name|global_bindings_p
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Insert BLOCK at the end of the list of subblocks of the      current binding level.  This is used when a BIND_EXPR is expanded,      to handle the BLOCK node inside the BIND_EXPR.  */
name|void
function_decl|(
modifier|*
name|insert_block
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Function to add a decl to the current scope level.  Takes one      argument, a decl to add.  Returns that decl, or, if the same      symbol is already declared, may return a different decl for that      name.  */
name|tree
function_decl|(
modifier|*
name|pushdecl
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Returns the chain of decls so far in the current scope level.  */
name|tree
function_decl|(
modifier|*
name|getdecls
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Returns true when we should warn for an unused global DECL.      We will already have checked that it has static binding.  */
name|bool
function_decl|(
modifier|*
name|warn_unused_global
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Obtain a list of globals and do final output on them at end      of compilation */
name|void
function_decl|(
modifier|*
name|final_write_globals
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Do necessary preparations before assemble_variable can proceed.  */
name|void
function_decl|(
modifier|*
name|prepare_assemble_variable
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* True if this decl may be called via a sibcall.  */
name|bool
function_decl|(
modifier|*
name|ok_for_sibcall
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Return the COMDAT group into which this DECL should be placed.      It is known that the DECL belongs in *some* COMDAT group when      this hook is called.  The return value will be used immediately,      but not explicitly deallocated, so implementations should not use      xmalloc to allocate the string returned.  (Typically, the return      value will be the string already stored in an      IDENTIFIER_NODE.)  */
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|comdat_group
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* True if OpenMP should privatize what this DECL points to rather      than the DECL itself.  */
name|bool
function_decl|(
modifier|*
name|omp_privatize_by_reference
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Return sharing kind if OpenMP sharing attribute of DECL is      predetermined, OMP_CLAUSE_DEFAULT_UNSPECIFIED otherwise.  */
name|enum
name|omp_clause_default_kind
function_decl|(
modifier|*
name|omp_predetermined_sharing
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Return true if DECL's DECL_VALUE_EXPR (if any) should be      disregarded in OpenMP construct, because it is going to be      remapped during OpenMP lowering.  SHARED is true if DECL      is going to be shared, false if it is going to be privatized.  */
name|bool
function_decl|(
modifier|*
name|omp_disregard_value_expr
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
comment|/* Return true if DECL that is shared iff SHARED is true should      be put into OMP_CLAUSE_PRIVATE_DEBUG.  */
name|bool
function_decl|(
modifier|*
name|omp_private_debug_clause
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
comment|/* Build and return code for a default constructor for DECL in      response to CLAUSE.  Return NULL if nothing to be done.  */
name|tree
function_decl|(
modifier|*
name|omp_clause_default_ctor
function_decl|)
parameter_list|(
name|tree
name|clause
parameter_list|,
name|tree
name|decl
parameter_list|)
function_decl|;
comment|/* Build and return code for a copy constructor from SRC to DST.  */
name|tree
function_decl|(
modifier|*
name|omp_clause_copy_ctor
function_decl|)
parameter_list|(
name|tree
name|clause
parameter_list|,
name|tree
name|dst
parameter_list|,
name|tree
name|src
parameter_list|)
function_decl|;
comment|/* Similarly, except use an assignment operator instead.  */
name|tree
function_decl|(
modifier|*
name|omp_clause_assign_op
function_decl|)
parameter_list|(
name|tree
name|clause
parameter_list|,
name|tree
name|dst
parameter_list|,
name|tree
name|src
parameter_list|)
function_decl|;
comment|/* Build and return code destructing DECL.  Return NULL if nothing      to be done.  */
name|tree
function_decl|(
modifier|*
name|omp_clause_dtor
function_decl|)
parameter_list|(
name|tree
name|clause
parameter_list|,
name|tree
name|decl
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* Language-specific hooks.  See langhooks-def.h for defaults.  */
end_comment

begin_struct
struct|struct
name|lang_hooks
block|{
comment|/* String identifying the front end.  e.g. "GNU C++".  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* sizeof (struct lang_identifier), so make_node () creates      identifier nodes long enough for the language-specific slots.  */
name|size_t
name|identifier_size
decl_stmt|;
comment|/* Determines the size of any language-specific tcc_constant or      tcc_exceptional nodes.  Since it is called from make_node, the      only information available is the tree code.  Expected to die      on unrecognized codes.  */
name|size_t
function_decl|(
modifier|*
name|tree_size
function_decl|)
parameter_list|(
name|enum
name|tree_code
parameter_list|)
function_decl|;
comment|/* The first callback made to the front end, for simple      initialization needed before any calls to handle_option.  Return      the language mask to filter the switch array with.  */
name|unsigned
name|int
function_decl|(
modifier|*
name|init_options
function_decl|)
parameter_list|(
name|unsigned
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
comment|/* Callback used to perform language-specific initialization for the      global diagnostic context structure.  */
name|void
function_decl|(
modifier|*
name|initialize_diagnostics
function_decl|)
parameter_list|(
name|struct
name|diagnostic_context
modifier|*
parameter_list|)
function_decl|;
comment|/* Handle the switch CODE, which has real type enum opt_code from      options.h.  If the switch takes an argument, it is passed in ARG      which points to permanent storage.  The handler is responsible for      checking whether ARG is NULL, which indicates that no argument      was in fact supplied.  For -f and -W switches, VALUE is 1 or 0      for the positive and negative forms respectively.       Return 1 if the switch is valid, 0 if invalid, and -1 if it's      valid and should not be treated as language-independent too.  */
name|int
function_decl|(
modifier|*
name|handle_option
function_decl|)
parameter_list|(
name|size_t
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
comment|/* Return false to use the default complaint about a missing      argument, otherwise output a complaint and return true.  */
name|bool
function_decl|(
modifier|*
name|missing_argument
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|opt
parameter_list|,
name|size_t
name|code
parameter_list|)
function_decl|;
comment|/* Called when all command line options have been parsed to allow      further processing and initialization       Should return true to indicate that a compiler back-end is      not required, such as with the -E option.       If errorcount is nonzero after this call the compiler exits      immediately and the finish hook is not called.  */
name|bool
function_decl|(
modifier|*
name|post_options
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
comment|/* Called after post_options to initialize the front end.  Return      false to indicate that no further compilation be performed, in      which case the finish hook is called immediately.  */
name|bool
function_decl|(
modifier|*
name|init
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Called at the end of compilation, as a finalizer.  */
name|void
function_decl|(
modifier|*
name|finish
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Parses the entire file.  The argument is nonzero to cause bison      parsers to dump debugging information during parsing.  */
name|void
function_decl|(
modifier|*
name|parse_file
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
comment|/* Called immediately after parsing to clear the binding stack.  */
name|void
function_decl|(
modifier|*
name|clear_binding_stack
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Called to obtain the alias set to be used for an expression or type.      Returns -1 if the language does nothing special for it.  */
name|HOST_WIDE_INT
function_decl|(
modifier|*
name|get_alias_set
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Called with an expression that is to be processed as a constant.      Returns either the same expression or a language-independent      constant equivalent to its input.  */
name|tree
function_decl|(
modifier|*
name|expand_constant
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Called by expand_expr for language-specific tree codes.      Fourth argument is actually an enum expand_modifier.  */
name|rtx
function_decl|(
modifier|*
name|expand_expr
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
comment|/* Called by expand_expr to generate the definition of a decl.  Returns      1 if handled, 0 otherwise.  */
name|int
function_decl|(
modifier|*
name|expand_decl
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Hook called by safe_from_p for language-specific tree codes.  It is      up to the language front-end to install a hook if it has any such      codes that safe_from_p needs to know about.  Since same_from_p will      recursively explore the TREE_OPERANDs of an expression, this hook      should not reexamine those pieces.  This routine may recursively      call safe_from_p; it should always pass `0' as the TOP_P      parameter.  */
name|int
function_decl|(
modifier|*
name|safe_from_p
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|tree
parameter_list|)
function_decl|;
comment|/* Function to finish handling an incomplete decl at the end of      compilation.  Default hook is does nothing.  */
name|void
function_decl|(
modifier|*
name|finish_incomplete_decl
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Mark EXP saying that we need to be able to take the address of      it; it should not be allocated in a register.  Return true if      successful.  */
name|bool
function_decl|(
modifier|*
name|mark_addressable
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Hook called by staticp for language-specific tree codes.  */
name|tree
function_decl|(
modifier|*
name|staticp
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Replace the DECL_LANG_SPECIFIC data, which may be NULL, of the      DECL_NODE with a newly GC-allocated copy.  */
name|void
function_decl|(
modifier|*
name|dup_lang_specific_decl
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Set the DECL_ASSEMBLER_NAME for a node.  If it is the sort of      thing that the assembler should talk about, set      DECL_ASSEMBLER_NAME to an appropriate IDENTIFIER_NODE.      Otherwise, set it to the ERROR_MARK_NODE to ensure that the      assembler does not talk about it.  */
name|void
function_decl|(
modifier|*
name|set_decl_assembler_name
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Return nonzero if fold-const is free to use bit-field      optimizations, for instance in fold_truthop().  */
name|bool
function_decl|(
modifier|*
name|can_use_bit_fields_p
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Nonzero if operations on types narrower than their mode should      have their results reduced to the precision of the type.  */
name|bool
name|reduce_bit_field_operations
decl_stmt|;
comment|/* Nonzero if this front end does not generate a dummy BLOCK between      the outermost scope of the function and the FUNCTION_DECL.  See      is_body_block in stmt.c, and its callers.  */
name|bool
name|no_body_blocks
decl_stmt|;
comment|/* The front end can add its own statistics to -fmem-report with      this hook.  It should output to stderr.  */
name|void
function_decl|(
modifier|*
name|print_statistics
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Called by print_tree when there is a tree of class tcc_exceptional      that it doesn't know how to display.  */
name|lang_print_tree_hook
name|print_xnode
decl_stmt|;
comment|/* Called to print language-dependent parts of tcc_decl, tcc_type,      and IDENTIFIER_NODE nodes.  */
name|lang_print_tree_hook
name|print_decl
decl_stmt|;
name|lang_print_tree_hook
name|print_type
decl_stmt|;
name|lang_print_tree_hook
name|print_identifier
decl_stmt|;
comment|/* Computes the name to use to print a declaration.  DECL is the      non-NULL declaration in question.  VERBOSITY determines what      information will be printed: 0: DECL_NAME, demangled as      necessary.  1: and scope information.  2: and any other      information that might be interesting, such as function parameter      types in C++.  */
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|decl_printable_name
function_decl|)
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|verbosity
parameter_list|)
function_decl|;
comment|/* Computes the dwarf-2/3 name for a tree.  VERBOSITY determines what      information will be printed: 0: DECL_NAME, demangled as      necessary.  1: and scope information.  */
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|dwarf_name
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|int
name|verbosity
parameter_list|)
function_decl|;
comment|/* This compares two types for equivalence ("compatible" in C-based languages).      This routine should only return 1 if it is sure.  It should not be used      in contexts where erroneously returning 0 causes problems.  */
name|int
function_decl|(
modifier|*
name|types_compatible_p
function_decl|)
parameter_list|(
name|tree
name|x
parameter_list|,
name|tree
name|y
parameter_list|)
function_decl|;
comment|/* Given a CALL_EXPR, return a function decl that is its target.  */
name|tree
function_decl|(
modifier|*
name|lang_get_callee_fndecl
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Called by report_error_function to print out function name.  */
name|void
function_decl|(
modifier|*
name|print_error_function
function_decl|)
parameter_list|(
name|struct
name|diagnostic_context
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
comment|/* Called from expr_size to calculate the size of the value of an      expression in a language-dependent way.  Returns a tree for the size      in bytes.  A frontend can call lhd_expr_size to get the default      semantics in cases that it doesn't want to handle specially.  */
name|tree
function_decl|(
modifier|*
name|expr_size
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Convert a character from the host's to the target's character      set.  The character should be in what C calls the "basic source      character set" (roughly, the set of characters defined by plain      old ASCII).  The default is to return the character unchanged,      which is correct in most circumstances.  Note that both argument      and result should be sign-extended under -fsigned-char,      zero-extended under -fno-signed-char.  */
name|HOST_WIDE_INT
function_decl|(
modifier|*
name|to_target_charset
function_decl|)
parameter_list|(
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
comment|/* Pointers to machine-independent attribute tables, for front ends      using attribs.c.  If one is NULL, it is ignored.  Respectively, a      table of attributes specific to the language, a table of      attributes common to two or more languages (to allow easy      sharing), and a table of attributes for checking formats.  */
specifier|const
name|struct
name|attribute_spec
modifier|*
name|attribute_table
decl_stmt|;
specifier|const
name|struct
name|attribute_spec
modifier|*
name|common_attribute_table
decl_stmt|;
specifier|const
name|struct
name|attribute_spec
modifier|*
name|format_attribute_table
decl_stmt|;
comment|/* Function-related language hooks.  */
name|struct
name|lang_hooks_for_functions
name|function
decl_stmt|;
name|struct
name|lang_hooks_for_tree_inlining
name|tree_inlining
decl_stmt|;
name|struct
name|lang_hooks_for_callgraph
name|callgraph
decl_stmt|;
name|struct
name|lang_hooks_for_tree_dump
name|tree_dump
decl_stmt|;
name|struct
name|lang_hooks_for_decls
name|decls
decl_stmt|;
name|struct
name|lang_hooks_for_types
name|types
decl_stmt|;
comment|/* Perform language-specific gimplification on the argument.  Returns an      enum gimplify_status, though we can't see that type here.  */
name|int
function_decl|(
modifier|*
name|gimplify_expr
function_decl|)
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
comment|/* Fold an OBJ_TYPE_REF expression to the address of a function.      KNOWN_TYPE carries the true type of the OBJ_TYPE_REF_OBJECT.  */
name|tree
function_decl|(
modifier|*
name|fold_obj_type_ref
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
comment|/* Return a definition for a builtin function named NAME and whose data type      is TYPE.  TYPE should be a function type with argument types.      FUNCTION_CODE tells later passes how to compile calls to this function.      See tree.h for its possible values.       If LIBRARY_NAME is nonzero, use that for DECL_ASSEMBLER_NAME,      the name to be called if we can't opencode the function.  If      ATTRS is nonzero, use that for the function's attribute list.  */
name|tree
function_decl|(
modifier|*
name|builtin_function
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|function_code
parameter_list|,
name|enum
name|built_in_class
name|bt_class
parameter_list|,
specifier|const
name|char
modifier|*
name|library_name
parameter_list|,
name|tree
name|attrs
parameter_list|)
function_decl|;
comment|/* Used to set up the tree_contains_structure array for a frontend. */
name|void
function_decl|(
modifier|*
name|init_ts
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Called by recompute_tree_invariant_for_addr_expr to go from EXPR      to a contained expression or DECL, possibly updating *TC, *TI or      *SE if in the process TREE_CONSTANT, TREE_INVARIANT or      TREE_SIDE_EFFECTS need updating.  */
name|tree
function_decl|(
modifier|*
name|expr_to_decl
function_decl|)
parameter_list|(
name|tree
name|expr
parameter_list|,
name|bool
modifier|*
name|tc
parameter_list|,
name|bool
modifier|*
name|ti
parameter_list|,
name|bool
modifier|*
name|se
parameter_list|)
function_decl|;
comment|/* APPLE LOCAL begin radar 6353006  */
comment|/*  For c-based languages, builds a generic type for Blocks pointers (for    emitting debug information.  For other languages, returns NULL.  */
name|tree
function_decl|(
modifier|*
name|build_generic_block_struct_type
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* APPLE LOCAL end radar 6353006  */
comment|/* Whenever you add entries here, make sure you adjust langhooks-def.h      and langhooks.c accordingly.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Each front end provides its own.  */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|lang_hooks
name|lang_hooks
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GCC_LANG_HOOKS_H */
end_comment

end_unit

