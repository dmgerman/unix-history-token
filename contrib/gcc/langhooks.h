begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The lang_hooks data structure.    Copyright 2001 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GCC_LANG_HOOKS_H
end_ifndef

begin_define
define|#
directive|define
name|GCC_LANG_HOOKS_H
end_define

begin_comment
comment|/* A print hook for print_tree ().  */
end_comment

begin_typedef
typedef|typedef
name|void
argument_list|(
argument|*lang_print_tree_hook
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|tree
operator|,
name|int
name|indent
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_comment
comment|/* The following hooks are documented in langhooks.c.  Must not be    NULL.  */
end_comment

begin_struct
struct|struct
name|lang_hooks_for_tree_inlining
block|{
name|union
name|tree_node
modifier|*
argument_list|(
operator|*
name|walk_subtrees
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|union
name|tree_node
operator|*
operator|*
operator|,
name|int
operator|*
operator|,
expr|union
name|tree_node
operator|*
call|(
modifier|*
call|)
argument_list|(
expr|union
name|tree_node
operator|*
operator|*
argument_list|,
name|int
operator|*
argument_list|,
name|void
operator|*
argument_list|)
operator|,
name|void
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
name|int
argument_list|(
argument|*cannot_inline_tree_fn
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|union
name|tree_node
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
name|int
argument_list|(
argument|*disregard_inline_limits
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|union
name|tree_node
operator|*
operator|)
argument_list|)
expr_stmt|;
name|union
name|tree_node
modifier|*
argument_list|(
operator|*
name|add_pending_fn_decls
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
expr|union
name|tree_node
operator|*
operator|)
argument_list|)
decl_stmt|;
name|int
argument_list|(
argument|*tree_chain_matters_p
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|union
name|tree_node
operator|*
operator|)
argument_list|)
expr_stmt|;
name|int
argument_list|(
argument|*auto_var_in_fn_p
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|union
name|tree_node
operator|*
operator|,
expr|union
name|tree_node
operator|*
operator|)
argument_list|)
expr_stmt|;
name|union
name|tree_node
modifier|*
argument_list|(
operator|*
name|copy_res_decl_for_inlining
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|union
name|tree_node
operator|*
operator|,
expr|union
name|tree_node
operator|*
operator|,
expr|union
name|tree_node
operator|*
operator|,
name|void
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
name|int
argument_list|(
argument|*anon_aggr_type_p
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|union
name|tree_node
operator|*
operator|)
argument_list|)
expr_stmt|;
name|int
argument_list|(
argument|*start_inlining
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|union
name|tree_node
operator|*
operator|)
argument_list|)
expr_stmt|;
name|void
argument_list|(
argument|*end_inlining
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|union
name|tree_node
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following hooks are used by tree-dump.c.  */
end_comment

begin_struct
struct|struct
name|lang_hooks_for_tree_dump
block|{
comment|/* Dump language-specific parts of tree nodes.  Returns non-zero if it       does not want the usual dumping of the second argument.  */
name|int
argument_list|(
argument|*dump_tree
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|tree
operator|)
argument_list|)
expr_stmt|;
comment|/* Determine type qualifiers in a language-specific way.  */
name|int
argument_list|(
argument|*type_quals
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Language-specific hooks.  See langhooks-def.h for defaults.  */
end_comment

begin_struct
struct|struct
name|lang_hooks
block|{
comment|/* String identifying the front end.  e.g. "GNU C++".  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* sizeof (struct lang_identifier), so make_node () creates      identifier nodes long enough for the language-specific slots.  */
name|size_t
name|identifier_size
decl_stmt|;
comment|/* The first callback made to the front end, for simple      initialization needed before any calls to decode_option.  */
name|void
argument_list|(
argument|*init_options
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
comment|/* Function called with an option vector as argument, to decode a      single option (typically starting with -f or -W or +).  It should      return the number of command-line arguments it uses if it handles      the option, or 0 and not complain if it does not recognise the      option.  If this function returns a negative number, then its      absolute value is the number of command-line arguments used, but,      in addition, no language-independent option processing should be      done for this option.  */
name|int
argument_list|(
argument|*decode_option
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Called when all command line options have been parsed.  Should do      any required consistency checks, modifications etc.  Complex      initialization should be left to the "init" callback, since GC      and the identifier hashes are set up between now and then.  */
name|void
argument_list|(
argument|*post_options
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
comment|/* Called after post_options, to initialize the front end.  The main      input filename is passed, which may be NULL; the front end should      return the original filename (e.g. foo.i -> foo.c).  Return NULL      to indicate a serious error of some sort; in that case no      compilation is performed, and the finish hook is called      immediately.  */
specifier|const
name|char
operator|*
operator|(
operator|*
name|init
operator|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Called at the end of compilation, as a finalizer.  */
name|void
argument_list|(
argument|*finish
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
comment|/* Called immediately after parsing to clear the binding stack.  */
name|void
argument_list|(
argument|*clear_binding_stack
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
comment|/* Called to obtain the alias set to be used for an expression or type.      Returns -1 if the language does nothing special for it.  */
name|HOST_WIDE_INT
argument_list|(
argument|*get_alias_set
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
expr_stmt|;
comment|/* Called with an expression that is to be processed as a constant.      Returns either the same expression or a language-independent      constant equivalent to its input.  */
name|tree
argument_list|(
argument|*expand_constant
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
expr_stmt|;
comment|/* Hook called by safe_from_p for language-specific tree codes.  It is      up to the language front-end to install a hook if it has any such      codes that safe_from_p needs to know about.  Since same_from_p will      recursively explore the TREE_OPERANDs of an expression, this hook      should not reexamine those pieces.  This routine may recursively      call safe_from_p; it should always pass `0' as the TOP_P      parameter.  */
name|int
argument_list|(
argument|*safe_from_p
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|tree
operator|)
argument_list|)
expr_stmt|;
comment|/* Hook called by staticp for language-specific tree codes.  */
name|int
argument_list|(
argument|*staticp
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
expr_stmt|;
comment|/* Nonzero if TYPE_READONLY and TREE_READONLY should always be honored.  */
name|bool
name|honor_readonly
decl_stmt|;
comment|/* The front end can add its own statistics to -fmem-report with      this hook.  It should output to stderr.  */
name|void
argument_list|(
argument|*print_statistics
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
comment|/* Called by print_tree when there is a tree of class 'x' that it      doesn't know how to display.  */
name|lang_print_tree_hook
name|print_xnode
decl_stmt|;
comment|/* Called to print language-dependent parts of a class 'd', class      't', and IDENTIFIER_NODE nodes.  */
name|lang_print_tree_hook
name|print_decl
decl_stmt|;
name|lang_print_tree_hook
name|print_type
decl_stmt|;
name|lang_print_tree_hook
name|print_identifier
decl_stmt|;
comment|/* Set yydebug for bison-based parsers, when -dy is given on the      command line.  By default, if the parameter is non-zero, prints a      warning that the front end does not use such a parser.  */
name|void
argument_list|(
argument|*set_yydebug
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
name|struct
name|lang_hooks_for_tree_inlining
name|tree_inlining
decl_stmt|;
name|struct
name|lang_hooks_for_tree_dump
name|tree_dump
decl_stmt|;
comment|/* Whenever you add entries here, make sure you adjust langhooks-def.h      and langhooks.c accordingly.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Each front end provides its own.  */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|lang_hooks
name|lang_hooks
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GCC_LANG_HOOKS_H */
end_comment

end_unit

