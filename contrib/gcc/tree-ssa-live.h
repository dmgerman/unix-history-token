begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Routines for liveness in SSA trees.    Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Andrew MacLeod<amacleod@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_TREE_SSA_LIVE_H
end_ifndef

begin_define
define|#
directive|define
name|_TREE_SSA_LIVE_H
value|1
end_define

begin_include
include|#
directive|include
file|"partition.h"
end_include

begin_include
include|#
directive|include
file|"vecprim.h"
end_include

begin_comment
comment|/* Used to create the variable mapping when we go out of SSA form.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_var_map
block|{
comment|/* The partition of all variables.  */
name|partition
name|var_partition
decl_stmt|;
comment|/* Vector for compacting partitions.  */
name|int
modifier|*
name|partition_to_compact
decl_stmt|;
name|int
modifier|*
name|compact_to_partition
decl_stmt|;
comment|/* Mapping of partition numbers to vars.  */
name|tree
modifier|*
name|partition_to_var
decl_stmt|;
comment|/* Current number of partitions.  */
name|unsigned
name|int
name|num_partitions
decl_stmt|;
comment|/* Original partition size.  */
name|unsigned
name|int
name|partition_size
decl_stmt|;
comment|/* Reference count, if required.  */
name|int
modifier|*
name|ref_count
decl_stmt|;
block|}
typedef|*
name|var_map
typedef|;
end_typedef

begin_define
define|#
directive|define
name|VAR_ANN_PARTITION
parameter_list|(
name|ann
parameter_list|)
value|(ann->partition)
end_define

begin_define
define|#
directive|define
name|VAR_ANN_ROOT_INDEX
parameter_list|(
name|ann
parameter_list|)
value|(ann->root_index)
end_define

begin_define
define|#
directive|define
name|NO_PARTITION
value|-1
end_define

begin_comment
comment|/* Flags to pass to compact_var_map  */
end_comment

begin_define
define|#
directive|define
name|VARMAP_NORMAL
value|0
end_define

begin_define
define|#
directive|define
name|VARMAP_NO_SINGLE_DEFS
value|1
end_define

begin_function_decl
specifier|extern
name|var_map
name|init_var_map
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|delete_var_map
parameter_list|(
name|var_map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|dump_var_map
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|var_map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|var_union
parameter_list|(
name|var_map
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|change_partition_var
parameter_list|(
name|var_map
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|compact_var_map
parameter_list|(
name|var_map
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_function_decl
specifier|extern
name|void
name|register_ssa_partition_check
parameter_list|(
name|tree
name|ssa_var
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
specifier|inline
name|unsigned
name|num_var_partitions
parameter_list|(
name|var_map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|tree
name|var_to_partition_to_var
parameter_list|(
name|var_map
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|tree
name|partition_to_var
parameter_list|(
name|var_map
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|var_to_partition
parameter_list|(
name|var_map
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|tree
name|version_to_var
parameter_list|(
name|var_map
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|version_ref_count
parameter_list|(
name|var_map
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|register_ssa_partition
parameter_list|(
name|var_map
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SSA_VAR_MAP_REF_COUNT
value|0x01
end_define

begin_function_decl
specifier|extern
name|var_map
name|create_ssa_var_map
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Number of partitions in MAP.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|num_var_partitions
parameter_list|(
name|var_map
name|map
parameter_list|)
block|{
return|return
name|map
operator|->
name|num_partitions
return|;
block|}
end_function

begin_comment
comment|/* Return the reference count for SSA_VAR's partition in MAP.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|version_ref_count
parameter_list|(
name|var_map
name|map
parameter_list|,
name|tree
name|ssa_var
parameter_list|)
block|{
name|int
name|version
init|=
name|SSA_NAME_VERSION
argument_list|(
name|ssa_var
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|map
operator|->
name|ref_count
argument_list|)
expr_stmt|;
return|return
name|map
operator|->
name|ref_count
index|[
name|version
index|]
return|;
block|}
end_function

begin_comment
comment|/* Given partition index I from MAP, return the variable which represents that     partition.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|partition_to_var
parameter_list|(
name|var_map
name|map
parameter_list|,
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|map
operator|->
name|compact_to_partition
condition|)
name|i
operator|=
name|map
operator|->
name|compact_to_partition
index|[
name|i
index|]
expr_stmt|;
name|i
operator|=
name|partition_find
argument_list|(
name|map
operator|->
name|var_partition
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|map
operator|->
name|partition_to_var
index|[
name|i
index|]
return|;
block|}
end_function

begin_comment
comment|/* Given ssa_name VERSION, if it has a partition in MAP,  return the var it     is associated with.  Otherwise return NULL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|version_to_var
parameter_list|(
name|var_map
name|map
parameter_list|,
name|int
name|version
parameter_list|)
block|{
name|int
name|part
decl_stmt|;
name|part
operator|=
name|partition_find
argument_list|(
name|map
operator|->
name|var_partition
argument_list|,
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|partition_to_compact
condition|)
name|part
operator|=
name|map
operator|->
name|partition_to_compact
index|[
name|part
index|]
expr_stmt|;
if|if
condition|(
name|part
operator|==
name|NO_PARTITION
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|part
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given VAR, return the partition number in MAP which contains it.      NO_PARTITION is returned if it's not in any partition.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|var_to_partition
parameter_list|(
name|var_map
name|map
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|var_ann_t
name|ann
decl_stmt|;
name|int
name|part
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|part
operator|=
name|partition_find
argument_list|(
name|map
operator|->
name|var_partition
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|partition_to_compact
condition|)
name|part
operator|=
name|map
operator|->
name|partition_to_compact
index|[
name|part
index|]
expr_stmt|;
block|}
else|else
block|{
name|ann
operator|=
name|var_ann
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|ann
operator|->
name|out_of_ssa_tag
condition|)
name|part
operator|=
name|VAR_ANN_PARTITION
argument_list|(
name|ann
argument_list|)
expr_stmt|;
else|else
name|part
operator|=
name|NO_PARTITION
expr_stmt|;
block|}
return|return
name|part
return|;
block|}
end_function

begin_comment
comment|/* Given VAR, return the variable which represents the entire partition    it is a member of in MAP.  NULL is returned if it is not in a partition.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|var_to_partition_to_var
parameter_list|(
name|var_map
name|map
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|int
name|part
decl_stmt|;
name|part
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|==
name|NO_PARTITION
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|part
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This routine registers a partition for SSA_VAR with MAP.  IS_USE is used     to count references.  Any unregistered partitions may be compacted out     later.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|register_ssa_partition
parameter_list|(
name|var_map
name|map
parameter_list|,
name|tree
name|ssa_var
parameter_list|,
name|bool
name|is_use
parameter_list|)
block|{
name|int
name|version
decl_stmt|;
if|#
directive|if
name|defined
name|ENABLE_CHECKING
name|register_ssa_partition_check
argument_list|(
name|ssa_var
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|version
operator|=
name|SSA_NAME_VERSION
argument_list|(
name|ssa_var
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_use
operator|&&
name|map
operator|->
name|ref_count
condition|)
name|map
operator|->
name|ref_count
index|[
name|version
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|partition_to_var
index|[
name|version
index|]
operator|==
name|NULL_TREE
condition|)
name|map
operator|->
name|partition_to_var
index|[
name|SSA_NAME_VERSION
argument_list|(
name|ssa_var
argument_list|)
index|]
operator|=
name|ssa_var
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  ---------------- live on entry/exit info ------------------------------        This structure is used to represent live range information on SSA based     trees. A partition map must be provided, and based on the active partitions,     live-on-entry information and live-on-exit information can be calculated.     As well, partitions are marked as to whether they are global (live      outside the basic block they are defined in).      The live-on-entry information is per variable. It provide a bitmap for      each variable which has a bit set for each basic block that the variable     is live on entry to that block.      The live-on-exit information is per block. It provides a bitmap for each     block indicating which partitions are live on exit from the block.      For the purposes of this implementation, we treat the elements of a PHI      as follows:         Uses in a PHI are considered LIVE-ON-EXIT to the block from which they        originate. They are *NOT* considered live on entry to the block        containing the PHI node.         The Def of a PHI node is *not* considered live on entry to the block.        It is considered to be "define early" in the block. Picture it as each        block having a stmt (or block-preheader) before the first real stmt in         the block which defines all the variables that are defined by PHIs.         -----------------------------------------------------------------------  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|tree_live_info_d
block|{
comment|/* Var map this relates to.  */
name|var_map
name|map
decl_stmt|;
comment|/* Bitmap indicating which partitions are global.  */
name|bitmap
name|global
decl_stmt|;
comment|/* Bitmap of live on entry blocks for partition elements.  */
name|bitmap
modifier|*
name|livein
decl_stmt|;
comment|/* Number of basic blocks when live on exit calculated.  */
name|int
name|num_blocks
decl_stmt|;
comment|/* Bitmap of what variables are live on exit for a basic blocks.  */
name|bitmap
modifier|*
name|liveout
decl_stmt|;
block|}
typedef|*
name|tree_live_info_p
typedef|;
end_typedef

begin_function_decl
specifier|extern
name|tree_live_info_p
name|calculate_live_on_entry
parameter_list|(
name|var_map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|calculate_live_on_exit
parameter_list|(
name|tree_live_info_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|delete_tree_live_info
parameter_list|(
name|tree_live_info_p
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|LIVEDUMP_ENTRY
value|0x01
end_define

begin_define
define|#
directive|define
name|LIVEDUMP_EXIT
value|0x02
end_define

begin_define
define|#
directive|define
name|LIVEDUMP_ALL
value|(LIVEDUMP_ENTRY | LIVEDUMP_EXIT)
end_define

begin_function_decl
specifier|extern
name|void
name|dump_live_info
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree_live_info_p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|partition_is_global
parameter_list|(
name|tree_live_info_p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|bitmap
name|live_entry_blocks
parameter_list|(
name|tree_live_info_p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|bitmap
name|live_on_exit
parameter_list|(
name|tree_live_info_p
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|var_map
name|live_var_map
parameter_list|(
name|tree_live_info_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|live_merge_and_clear
parameter_list|(
name|tree_live_info_p
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|make_live_on_entry
parameter_list|(
name|tree_live_info_p
parameter_list|,
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  Return TRUE if P is marked as a global in LIVE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|partition_is_global
parameter_list|(
name|tree_live_info_p
name|live
parameter_list|,
name|int
name|p
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|live
operator|->
name|global
argument_list|)
expr_stmt|;
return|return
name|bitmap_bit_p
argument_list|(
name|live
operator|->
name|global
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the bitmap from LIVE representing the live on entry blocks for     partition P.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bitmap
name|live_entry_blocks
parameter_list|(
name|tree_live_info_p
name|live
parameter_list|,
name|int
name|p
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|live
operator|->
name|livein
argument_list|)
expr_stmt|;
return|return
name|live
operator|->
name|livein
index|[
name|p
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the bitmap from LIVE representing the live on exit partitions from    block BB.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bitmap
name|live_on_exit
parameter_list|(
name|tree_live_info_p
name|live
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|live
operator|->
name|liveout
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|bb
operator|!=
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|bb
operator|!=
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
return|return
name|live
operator|->
name|liveout
index|[
name|bb
operator|->
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the partition map which the information in LIVE utilizes.  */
end_comment

begin_function
specifier|static
specifier|inline
name|var_map
name|live_var_map
parameter_list|(
name|tree_live_info_p
name|live
parameter_list|)
block|{
return|return
name|live
operator|->
name|map
return|;
block|}
end_function

begin_comment
comment|/* Merge the live on entry information in LIVE for partitions P1 and P2. Place    the result into P1.  Clear P2.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|live_merge_and_clear
parameter_list|(
name|tree_live_info_p
name|live
parameter_list|,
name|int
name|p1
parameter_list|,
name|int
name|p2
parameter_list|)
block|{
name|bitmap_ior_into
argument_list|(
name|live
operator|->
name|livein
index|[
name|p1
index|]
argument_list|,
name|live
operator|->
name|livein
index|[
name|p2
index|]
argument_list|)
expr_stmt|;
name|bitmap_zero
argument_list|(
name|live
operator|->
name|livein
index|[
name|p2
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark partition P as live on entry to basic block BB in LIVE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|make_live_on_entry
parameter_list|(
name|tree_live_info_p
name|live
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|int
name|p
parameter_list|)
block|{
name|bitmap_set_bit
argument_list|(
name|live
operator|->
name|livein
index|[
name|p
index|]
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|live
operator|->
name|global
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A tree_partition_associator (TPA)object is a base structure which allows    partitions to be associated with a tree object.     A varray of tree elements represent each distinct tree item.    A parallel int array represents the first partition number associated with     the tree.    This partition number is then used as in index into the next_partition    array, which returns the index of the next partition which is associated    with the tree. TPA_NONE indicates the end of the list.      A varray paralleling the partition list 'partition_to_tree_map' is used    to indicate which tree index the partition is in.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|tree_partition_associator_d
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|trees
expr_stmt|;
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
name|first_partition
expr_stmt|;
name|int
modifier|*
name|next_partition
decl_stmt|;
name|int
modifier|*
name|partition_to_tree_map
decl_stmt|;
name|int
name|num_trees
decl_stmt|;
name|int
name|uncompressed_num
decl_stmt|;
name|var_map
name|map
decl_stmt|;
block|}
typedef|*
name|tpa_p
typedef|;
end_typedef

begin_comment
comment|/* Value returned when there are no more partitions associated with a tree.  */
end_comment

begin_define
define|#
directive|define
name|TPA_NONE
value|-1
end_define

begin_function_decl
specifier|static
specifier|inline
name|tree
name|tpa_tree
parameter_list|(
name|tpa_p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|tpa_first_partition
parameter_list|(
name|tpa_p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|tpa_next_partition
parameter_list|(
name|tpa_p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|tpa_num_trees
parameter_list|(
name|tpa_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|tpa_find_tree
parameter_list|(
name|tpa_p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|tpa_decompact
parameter_list|(
name|tpa_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|tpa_delete
parameter_list|(
name|tpa_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|tpa_dump
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tpa_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|tpa_remove_partition
parameter_list|(
name|tpa_p
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|tpa_compact
parameter_list|(
name|tpa_p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return the number of distinct tree nodes in TPA.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|tpa_num_trees
parameter_list|(
name|tpa_p
name|tpa
parameter_list|)
block|{
return|return
name|tpa
operator|->
name|num_trees
return|;
block|}
end_function

begin_comment
comment|/* Return the tree node for index I in TPA.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|tpa_tree
parameter_list|(
name|tpa_p
name|tpa
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|tpa
operator|->
name|trees
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the first partition associated with tree list I in TPA.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|tpa_first_partition
parameter_list|(
name|tpa_p
name|tpa
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|VEC_index
argument_list|(
name|int
argument_list|,
name|tpa
operator|->
name|first_partition
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the next partition after partition I in TPA's list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|tpa_next_partition
parameter_list|(
name|tpa_p
name|tpa
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|tpa
operator|->
name|next_partition
index|[
name|i
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the tree index from TPA whose list contains partition I.      TPA_NONE is returned if I is not associated with any list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|tpa_find_tree
parameter_list|(
name|tpa_p
name|tpa
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|index
operator|=
name|tpa
operator|->
name|partition_to_tree_map
index|[
name|i
index|]
expr_stmt|;
comment|/* When compressed, any index higher than the number of tree elements is       a compressed element, so return TPA_NONE.  */
if|if
condition|(
name|index
operator|!=
name|TPA_NONE
operator|&&
name|index
operator|>=
name|tpa_num_trees
argument_list|(
name|tpa
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|tpa
operator|->
name|uncompressed_num
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|index
operator|=
name|TPA_NONE
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* This function removes any compaction which was performed on TPA.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|tpa_decompact
parameter_list|(
name|tpa_p
name|tpa
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|tpa
operator|->
name|uncompressed_num
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tpa
operator|->
name|num_trees
operator|=
name|tpa
operator|->
name|uncompressed_num
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Once a var_map has been created and compressed, a complementary root_var    object can be built.  This creates a list of all the root variables from    which ssa version names are derived.  Each root variable has a list of     which partitions are versions of that root.       This is implemented using the tree_partition_associator.     The tree vector is used to represent the root variable.    The list of partitions represent SSA versions of the root variable.  */
end_comment

begin_typedef
typedef|typedef
name|tpa_p
name|root_var_p
typedef|;
end_typedef

begin_function_decl
specifier|static
specifier|inline
name|tree
name|root_var
parameter_list|(
name|root_var_p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|root_var_first_partition
parameter_list|(
name|root_var_p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|root_var_next_partition
parameter_list|(
name|root_var_p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|root_var_num
parameter_list|(
name|root_var_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|root_var_dump
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|root_var_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|root_var_remove_partition
parameter_list|(
name|root_var_p
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|root_var_delete
parameter_list|(
name|root_var_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|root_var_find
parameter_list|(
name|root_var_p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|root_var_compact
parameter_list|(
name|root_var_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|root_var_decompact
parameter_list|(
name|tpa_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|root_var_p
name|root_var_init
parameter_list|(
name|var_map
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Value returned when there are no more partitions associated with a root    variable.  */
end_comment

begin_define
define|#
directive|define
name|ROOT_VAR_NONE
value|TPA_NONE
end_define

begin_comment
comment|/* Return the number of distinct root variables in RV.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|root_var_num
parameter_list|(
name|root_var_p
name|rv
parameter_list|)
block|{
return|return
name|tpa_num_trees
argument_list|(
name|rv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return root variable I from RV.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|root_var
parameter_list|(
name|root_var_p
name|rv
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|tpa_tree
argument_list|(
name|rv
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the first partition in RV belonging to root variable list I.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|root_var_first_partition
parameter_list|(
name|root_var_p
name|rv
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|tpa_first_partition
argument_list|(
name|rv
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the next partition after partition I in a root list from RV.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|root_var_next_partition
parameter_list|(
name|root_var_p
name|rv
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|tpa_next_partition
argument_list|(
name|rv
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Send debug info for root_var list RV to file F.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|root_var_dump
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|root_var_p
name|rv
parameter_list|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nRoot Var dump\n"
argument_list|)
expr_stmt|;
name|tpa_dump
argument_list|(
name|f
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Destroy root_var object RV.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|root_var_delete
parameter_list|(
name|root_var_p
name|rv
parameter_list|)
block|{
name|tpa_delete
argument_list|(
name|rv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove partition PARTITION_INDEX from root_var list ROOT_INDEX in RV.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|root_var_remove_partition
parameter_list|(
name|root_var_p
name|rv
parameter_list|,
name|int
name|root_index
parameter_list|,
name|int
name|partition_index
parameter_list|)
block|{
name|tpa_remove_partition
argument_list|(
name|rv
argument_list|,
name|root_index
argument_list|,
name|partition_index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the root_var list index for partition I in RV.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|root_var_find
parameter_list|(
name|root_var_p
name|rv
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|tpa_find_tree
argument_list|(
name|rv
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Hide single element lists in RV.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|root_var_compact
parameter_list|(
name|root_var_p
name|rv
parameter_list|)
block|{
return|return
name|tpa_compact
argument_list|(
name|rv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expose the single element lists in RV.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|root_var_decompact
parameter_list|(
name|root_var_p
name|rv
parameter_list|)
block|{
name|tpa_decompact
argument_list|(
name|rv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A TYPE_VAR object is similar to a root_var object, except this associates     partitions with their type rather than their root variable.  This is used to     coalesce memory locations based on type.  */
end_comment

begin_typedef
typedef|typedef
name|tpa_p
name|type_var_p
typedef|;
end_typedef

begin_function_decl
specifier|static
specifier|inline
name|tree
name|type_var
parameter_list|(
name|type_var_p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|type_var_first_partition
parameter_list|(
name|type_var_p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|type_var_next_partition
parameter_list|(
name|type_var_p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|type_var_num
parameter_list|(
name|type_var_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|type_var_dump
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|type_var_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|type_var_remove_partition
parameter_list|(
name|type_var_p
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|type_var_delete
parameter_list|(
name|type_var_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|type_var_find
parameter_list|(
name|type_var_p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|type_var_compact
parameter_list|(
name|type_var_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|type_var_decompact
parameter_list|(
name|type_var_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|type_var_p
name|type_var_init
parameter_list|(
name|var_map
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Value returned when there is no partitions associated with a list.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_VAR_NONE
value|TPA_NONE
end_define

begin_comment
comment|/* Return the number of distinct type lists in TV.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|type_var_num
parameter_list|(
name|type_var_p
name|tv
parameter_list|)
block|{
return|return
name|tpa_num_trees
argument_list|(
name|tv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the type of list I in TV.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|type_var
parameter_list|(
name|type_var_p
name|tv
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|tpa_tree
argument_list|(
name|tv
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the first partition belonging to type list I in TV.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|type_var_first_partition
parameter_list|(
name|type_var_p
name|tv
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|tpa_first_partition
argument_list|(
name|tv
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the next partition after partition I in a type list within TV.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|type_var_next_partition
parameter_list|(
name|type_var_p
name|tv
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|tpa_next_partition
argument_list|(
name|tv
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Send debug info for type_var object TV to file F.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|type_var_dump
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|type_var_p
name|tv
parameter_list|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nType Var dump\n"
argument_list|)
expr_stmt|;
name|tpa_dump
argument_list|(
name|f
argument_list|,
name|tv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete type_var object TV.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|type_var_delete
parameter_list|(
name|type_var_p
name|tv
parameter_list|)
block|{
name|tpa_delete
argument_list|(
name|tv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove partition PARTITION_INDEX from type list TYPE_INDEX in TV.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|type_var_remove_partition
parameter_list|(
name|type_var_p
name|tv
parameter_list|,
name|int
name|type_index
parameter_list|,
name|int
name|partition_index
parameter_list|)
block|{
name|tpa_remove_partition
argument_list|(
name|tv
argument_list|,
name|type_index
argument_list|,
name|partition_index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the type index in TV for the list partition I is in.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|type_var_find
parameter_list|(
name|type_var_p
name|tv
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|tpa_find_tree
argument_list|(
name|tv
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Hide single element lists in TV.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|type_var_compact
parameter_list|(
name|type_var_p
name|tv
parameter_list|)
block|{
return|return
name|tpa_compact
argument_list|(
name|tv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expose single element lists in TV.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|type_var_decompact
parameter_list|(
name|type_var_p
name|tv
parameter_list|)
block|{
name|tpa_decompact
argument_list|(
name|tv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This set of routines implements a coalesce_list. This is an object which    is used to track pairs of partitions which are desirable to coalesce    together at some point.  Costs are associated with each pair, and when     all desired information has been collected, the object can be used to     order the pairs for processing.  */
end_comment

begin_comment
comment|/* This structure defines a pair for coalescing.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|partition_pair_d
block|{
name|int
name|first_partition
decl_stmt|;
name|int
name|second_partition
decl_stmt|;
name|int
name|cost
decl_stmt|;
name|struct
name|partition_pair_d
modifier|*
name|next
decl_stmt|;
block|}
typedef|*
name|partition_pair_p
typedef|;
end_typedef

begin_comment
comment|/* This structure maintains the list of coalesce pairs.      When add_mode is true, list is a triangular shaped list of coalesce pairs.    The smaller partition number is used to index the list, and the larger is    index is located in a partition_pair_p object. These lists are sorted from     smallest to largest by 'second_partition'.  New coalesce pairs are allowed    to be added in this mode.    When add_mode is false, the lists have all been merged into list[0]. The    rest of the lists are not used. list[0] is ordered from most desirable    coalesce to least desirable. pop_best_coalesce() retrieves the pairs    one at a time.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|coalesce_list_d
block|{
name|var_map
name|map
decl_stmt|;
name|partition_pair_p
modifier|*
name|list
decl_stmt|;
name|bool
name|add_mode
decl_stmt|;
block|}
typedef|*
name|coalesce_list_p
typedef|;
end_typedef

begin_function_decl
specifier|extern
name|coalesce_list_p
name|create_coalesce_list
parameter_list|(
name|var_map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|add_coalesce
parameter_list|(
name|coalesce_list_p
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|coalesce_cost
parameter_list|(
name|int
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|sort_coalesce_list
parameter_list|(
name|coalesce_list_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|dump_coalesce_list
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|coalesce_list_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|delete_coalesce_list
parameter_list|(
name|coalesce_list_p
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NO_BEST_COALESCE
value|-1
end_define

begin_function_decl
specifier|extern
name|conflict_graph
name|build_tree_conflict_graph
parameter_list|(
name|tree_live_info_p
parameter_list|,
name|tpa_p
parameter_list|,
name|coalesce_list_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|coalesce_tpa_members
parameter_list|(
name|tpa_p
name|tpa
parameter_list|,
name|conflict_graph
name|graph
parameter_list|,
name|var_map
name|map
parameter_list|,
name|coalesce_list_p
name|cl
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _TREE_SSA_LIVE_H  */
end_comment

end_unit

