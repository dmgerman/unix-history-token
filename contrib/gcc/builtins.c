begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Expand builtin functions.    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"typeclass.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"predict.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"tree-mudflap.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PAD_VARARGS_DOWN
end_ifndef

begin_define
define|#
directive|define
name|PAD_VARARGS_DOWN
value|BYTES_BIG_ENDIAN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define the names of the builtin function types and codes.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|built_in_class_names
index|[
literal|4
index|]
init|=
block|{
literal|"NOT_BUILT_IN"
block|,
literal|"BUILT_IN_FRONTEND"
block|,
literal|"BUILT_IN_MD"
block|,
literal|"BUILT_IN_NORMAL"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEF_BUILTIN
parameter_list|(
name|X
parameter_list|,
name|N
parameter_list|,
name|C
parameter_list|,
name|T
parameter_list|,
name|LT
parameter_list|,
name|B
parameter_list|,
name|F
parameter_list|,
name|NA
parameter_list|,
name|AT
parameter_list|,
name|IM
parameter_list|,
name|COND
parameter_list|)
value|#X,
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|built_in_names
index|[
operator|(
name|int
operator|)
name|END_BUILTINS
index|]
init|=
block|{
include|#
directive|include
file|"builtins.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_BUILTIN
end_undef

begin_comment
comment|/* Setup an array of _DECL trees, make sure each element is    initialized to NULL_TREE.  */
end_comment

begin_decl_stmt
name|tree
name|built_in_decls
index|[
operator|(
name|int
operator|)
name|END_BUILTINS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declarations used when constructing the builtin implicitly in the compiler.    It may be NULL_TREE when this is invalid (for instance runtime is not    required to implement the function call in all cases).  */
end_comment

begin_decl_stmt
name|tree
name|implicit_built_in_decls
index|[
operator|(
name|int
operator|)
name|END_BUILTINS
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|get_pointer_alignment
parameter_list|(
name|tree
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|c_getstr
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|c_readstr
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|target_char_cast
parameter_list|(
name|tree
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|get_memory_rtx
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|apply_args_size
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|apply_result_size
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_untyped_call
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_untyped_return
argument_list|)
end_if

begin_function_decl
specifier|static
name|rtx
name|result_vector
parameter_list|(
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|expand_builtin_update_setjmp_buf
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_builtin_prefetch
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_apply_args
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_apply_args_1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_apply
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_builtin_return
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|type_class
name|type_to_class
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_classify_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_errno_check
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_mathfn
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_mathfn_2
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_mathfn_3
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_sincos
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_int_roundingfn
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_args_info
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_next_arg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_va_start
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_va_end
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_va_copy
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_memcmp
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strcmp
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strncmp
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|builtin_memcpy_read_str
parameter_list|(
name|void
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strcat
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strncat
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strspn
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strcspn
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_memcpy
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_mempcpy
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_memmove
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_bcopy
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strcpy
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_stpcpy
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|builtin_strncpy_read_str
parameter_list|(
name|void
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strncpy
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|builtin_memset_read_str
parameter_list|(
name|void
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|builtin_memset_gen_str
parameter_list|(
name|void
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_memset
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_bzero
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strlen
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strstr
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strpbrk
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strchr
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strrchr
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_alloca
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_unop
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|optab
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_frame_address
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_fputs
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_printf
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_fprintf
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_sprintf
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|stabilize_va_list
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_expect
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_constant_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_classify_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_strlen
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_inf
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_nan
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|validate_arglist
parameter_list|(
name|tree
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|integer_valued_real_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_trunc_transparent_mathfn
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|readonly_data_expr
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_fabs
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_signbit
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_sqrt
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_cbrt
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_pow
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_powi
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_sin
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_cos
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_tan
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_atan
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_trunc
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_floor
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_ceil
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_round
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_int_roundingfn
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_bitop
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_memory_op
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_strchr
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_memcmp
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_strcmp
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_strncmp
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_signbit
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_copysign
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_isascii
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_toascii
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_isdigit
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_fabs
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_abs
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_unordered_cmp
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|enum
name|tree_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_1
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_strpbrk
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_strstr
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_strrchr
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_strcat
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_strncat
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_strspn
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_strcspn
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_sprintf
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_object_size
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_memory_chk
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|enum
name|built_in_function
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_emit_chk_warning
parameter_list|(
name|tree
parameter_list|,
name|enum
name|built_in_function
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_emit_sprintf_chk_warning
parameter_list|(
name|tree
parameter_list|,
name|enum
name|built_in_function
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_object_size
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_strcat_chk
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_strncat_chk
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_sprintf_chk
parameter_list|(
name|tree
parameter_list|,
name|enum
name|built_in_function
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_printf
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|,
name|enum
name|built_in_function
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_fprintf
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|,
name|enum
name|built_in_function
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|init_target_chars
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|target_newline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|target_percent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|target_c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|target_s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|target_percent_c
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|target_percent_s
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|target_percent_s_newline
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return true if NODE should be considered for inline expansion regardless    of the optimization level.  This means whenever a function is invoked with    its "internal" name, which normally contains the prefix "__builtin".  */
end_comment

begin_function
specifier|static
name|bool
name|called_as_built_in
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"__sync_"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return the alignment in bits of EXP, a pointer valued expression.    But don't return more than MAX_ALIGN no matter what.    The alignment returned is, by default, the alignment of the thing that    EXP points to.  If it is not a POINTER_TYPE, 0 is returned.     Otherwise, look at the expression to see if we can do better, i.e., if the    expression is actually pointing at an object whose alignment is tighter.  */
end_comment

begin_function
specifier|static
name|int
name|get_pointer_alignment
parameter_list|(
name|tree
name|exp
parameter_list|,
name|unsigned
name|int
name|max_align
parameter_list|)
block|{
name|unsigned
name|int
name|align
decl_stmt|,
name|inner
decl_stmt|;
comment|/* We rely on TER to compute accurate alignment information.  */
if|if
condition|(
operator|!
operator|(
name|optimize
operator|&&
name|flag_tree_ter
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
name|MIN
argument_list|(
name|align
argument_list|,
name|max_align
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
name|align
return|;
name|inner
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
name|MIN
argument_list|(
name|inner
argument_list|,
name|max_align
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
comment|/* If sum of pointer + int, restrict our maximum alignment to that 	     imposed by the integer.  If not, we can't do any better than 	     ALIGN.  */
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|align
return|;
while|while
condition|(
operator|(
operator|(
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|&
operator|(
name|max_align
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|max_align
operator|>>=
literal|1
expr_stmt|;
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
comment|/* See what we are pointing at and look at its alignment.  */
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inner
operator|=
name|max_align
expr_stmt|;
if|if
condition|(
name|handled_component_p
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|,
name|volatilep
decl_stmt|;
name|exp
operator|=
name|get_inner_reference
argument_list|(
name|exp
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitpos
condition|)
name|inner
operator|=
name|MIN
argument_list|(
name|inner
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|bitpos
operator|&
operator|-
name|bitpos
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|&&
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
name|host_integerp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* Any overflow in calculating offset_bits won't change 		     the alignment.  */
name|unsigned
name|offset_bits
init|=
operator|(
operator|(
name|unsigned
operator|)
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
decl_stmt|;
if|if
condition|(
name|offset_bits
condition|)
name|inner
operator|=
name|MIN
argument_list|(
name|inner
argument_list|,
operator|(
name|offset_bits
operator|&
operator|-
name|offset_bits
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|&&
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|host_integerp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* Any overflow in calculating offset_factor won't change 		     the alignment.  */
name|unsigned
name|offset_factor
init|=
operator|(
operator|(
name|unsigned
operator|)
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
decl_stmt|;
if|if
condition|(
name|offset_factor
condition|)
name|inner
operator|=
name|MIN
argument_list|(
name|inner
argument_list|,
operator|(
name|offset_factor
operator|&
operator|-
name|offset_factor
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
condition|)
name|inner
operator|=
name|MIN
argument_list|(
name|inner
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_P
argument_list|(
name|exp
argument_list|)
condition|)
name|align
operator|=
name|MIN
argument_list|(
name|inner
argument_list|,
name|DECL_ALIGN
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
elseif|else
if|if
condition|(
name|CONSTANT_CLASS_P
argument_list|(
name|exp
argument_list|)
condition|)
name|align
operator|=
name|MIN
argument_list|(
name|inner
argument_list|,
operator|(
name|unsigned
operator|)
name|CONSTANT_ALIGNMENT
argument_list|(
name|exp
argument_list|,
name|align
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|align
operator|=
name|MIN
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|inner
argument_list|)
expr_stmt|;
else|else
name|align
operator|=
name|MIN
argument_list|(
name|align
argument_list|,
name|inner
argument_list|)
expr_stmt|;
return|return
name|MIN
argument_list|(
name|align
argument_list|,
name|max_align
argument_list|)
return|;
default|default:
return|return
name|align
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Compute the length of a C string.  TREE_STRING_LENGTH is not the right    way, because it could contain a zero byte in the middle.    TREE_STRING_LENGTH is the size of the character array, not the string.     ONLY_VALUE should be nonzero if the result is not going to be emitted    into the instruction stream and zero if it is going to be expanded.    E.g. with i++ ? "foo" : "bar", if ONLY_VALUE is nonzero, constant 3    is returned, otherwise NULL, since    len = c_strlen (src, 1); if (len) expand_expr (len, ...); would not    evaluate the side-effects.     The value returned is of type `ssizetype'.     Unfortunately, string_constant can't access the values of const char    arrays with initializers, so neither can we do so here.  */
end_comment

begin_function
name|tree
name|c_strlen
parameter_list|(
name|tree
name|src
parameter_list|,
name|int
name|only_value
parameter_list|)
block|{
name|tree
name|offset_node
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|max
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|COND_EXPR
operator|&&
operator|(
name|only_value
operator|||
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tree
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|len1
operator|=
name|c_strlen
argument_list|(
name|TREE_OPERAND
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|only_value
argument_list|)
expr_stmt|;
name|len2
operator|=
name|c_strlen
argument_list|(
name|TREE_OPERAND
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
argument_list|,
name|only_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|len1
argument_list|,
name|len2
argument_list|)
condition|)
return|return
name|len1
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|&&
operator|(
name|only_value
operator|||
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|c_strlen
argument_list|(
name|TREE_OPERAND
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|only_value
argument_list|)
return|;
name|src
operator|=
name|string_constant
argument_list|(
name|src
argument_list|,
operator|&
name|offset_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|max
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|src
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ptr
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_node
operator|&&
name|TREE_CODE
argument_list|(
name|offset_node
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
comment|/* If the string has an internal zero byte (e.g., "foo\0bar"), we can't 	 compute the offset to the following null if we don't know where to 	 start searching for it.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ptr
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* We don't know the starting offset, but we do know that the string 	 has no internal zero bytes.  We can assume that the offset falls 	 within the bounds of the string; otherwise, the programmer deserves 	 what he gets.  Subtract the offset from the length of the string, 	 and return that.  This would perhaps not be valid if we were dealing 	 with named arrays in addition to literal string constants.  */
return|return
name|size_diffop
argument_list|(
name|size_int
argument_list|(
name|max
argument_list|)
argument_list|,
name|offset_node
argument_list|)
return|;
block|}
comment|/* We have a known offset into the string.  Start searching there for      a null character if we can represent it as a single HOST_WIDE_INT.  */
if|if
condition|(
name|offset_node
operator|==
literal|0
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|offset_node
argument_list|,
literal|0
argument_list|)
condition|)
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|offset
operator|=
name|tree_low_cst
argument_list|(
name|offset_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the offset is known to be out of bounds, warn, and call strlen at      runtime.  */
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|>
name|max
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"offset outside bounds of constant string"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Use strlen to search for the first zero byte.  Since any strings      constructed with build_string will have nulls appended, we win even      if we get handed something like (char[4])"abcd".       Since OFFSET is our starting index into the string, no further      calculation is needed.  */
return|return
name|ssize_int
argument_list|(
name|strlen
argument_list|(
name|ptr
operator|+
name|offset
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a char pointer for a C string if it is a string constant    or sum of string constant and integer constant.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|c_getstr
parameter_list|(
name|tree
name|src
parameter_list|)
block|{
name|tree
name|offset_node
decl_stmt|;
name|src
operator|=
name|string_constant
argument_list|(
name|src
argument_list|,
operator|&
name|offset_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|offset_node
operator|==
literal|0
condition|)
return|return
name|TREE_STRING_POINTER
argument_list|(
name|src
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|offset_node
argument_list|,
literal|1
argument_list|)
operator|||
name|compare_tree_int
argument_list|(
name|offset_node
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|src
argument_list|)
operator|-
literal|1
argument_list|)
operator|>
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|TREE_STRING_POINTER
argument_list|(
name|src
argument_list|)
operator|+
name|tree_low_cst
argument_list|(
name|offset_node
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a CONST_INT or CONST_DOUBLE corresponding to target reading    GET_MODE_BITSIZE (MODE) bits from string constant STR.  */
end_comment

begin_function
specifier|static
name|rtx
name|c_readstr
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|HOST_WIDE_INT
name|c
index|[
literal|2
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|ch
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
argument_list|)
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|j
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|!=
name|WORDS_BIG_ENDIAN
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
name|j
operator|=
name|j
operator|+
name|UNITS_PER_WORD
operator|-
literal|2
operator|*
operator|(
name|j
operator|%
name|UNITS_PER_WORD
operator|)
operator|-
literal|1
expr_stmt|;
name|j
operator|*=
name|BITS_PER_UNIT
expr_stmt|;
name|gcc_assert
argument_list|(
name|j
operator|<=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
condition|)
name|ch
operator|=
operator|(
name|unsigned
name|char
operator|)
name|str
index|[
name|i
index|]
expr_stmt|;
name|c
index|[
name|j
operator|/
name|HOST_BITS_PER_WIDE_INT
index|]
operator||=
name|ch
operator|<<
operator|(
name|j
operator|%
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
return|return
name|immed_double_const
argument_list|(
name|c
index|[
literal|0
index|]
argument_list|,
name|c
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Cast a target constant CST to target CHAR and if that value fits into    host char type, return zero and put that value into variable pointed to by    P.  */
end_comment

begin_function
specifier|static
name|int
name|target_char_cast
parameter_list|(
name|tree
name|cst
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|val
decl_stmt|,
name|hostval
decl_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|cst
argument_list|,
literal|1
argument_list|)
operator|||
name|CHAR_TYPE_SIZE
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
literal|1
return|;
name|val
operator|=
name|tree_low_cst
argument_list|(
name|cst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHAR_TYPE_SIZE
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|val
operator|&=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|CHAR_TYPE_SIZE
operator|)
operator|-
literal|1
expr_stmt|;
name|hostval
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_CHAR
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|hostval
operator|&=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|HOST_BITS_PER_CHAR
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|hostval
condition|)
return|return
literal|1
return|;
operator|*
name|p
operator|=
name|hostval
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Similar to save_expr, but assumes that arbitrary code is not executed    in between the multiple evaluations.  In particular, we assume that a    non-addressable local variable will not be modified.  */
end_comment

begin_function
specifier|static
name|tree
name|builtin_save_expr
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PARM_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|)
operator|)
condition|)
return|return
name|exp
return|;
return|return
name|save_expr
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given TEM, a pointer to a stack frame, follow the dynamic chain COUNT    times to get the address of either a higher stack frame, or a return    address located within it (depending on FNDECL_CODE).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_return_addr
parameter_list|(
name|enum
name|built_in_function
name|fndecl_code
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|INITIAL_FRAME_ADDRESS_RTX
name|rtx
name|tem
init|=
name|INITIAL_FRAME_ADDRESS_RTX
decl_stmt|;
else|#
directive|else
name|rtx
name|tem
decl_stmt|;
comment|/* For a zero count with __builtin_return_address, we don't care what      frame address we return, because target-specific definitions will      override us.  Therefore frame pointer elimination is OK, and using      the soft frame pointer is OK.       For a non-zero count, or a zero count with __builtin_frame_address,      we require a stable offset from the current frame pointer to the      previous one, so we must use the hard frame pointer, and      we must disable frame pointer elimination.  */
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|fndecl_code
operator|==
name|BUILT_IN_RETURN_ADDRESS
condition|)
name|tem
operator|=
name|frame_pointer_rtx
expr_stmt|;
else|else
block|{
name|tem
operator|=
name|hard_frame_pointer_rtx
expr_stmt|;
comment|/* Tell reload not to eliminate the frame pointer.  */
name|current_function_accesses_prior_frames
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Some machines need special handling before we can access      arbitrary frames.  For example, on the SPARC, we must first flush      all register windows to the stack.  */
ifdef|#
directive|ifdef
name|SETUP_FRAME_ADDRESSES
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|SETUP_FRAME_ADDRESSES
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* On the SPARC, the return address is not in the frame, it is in a      register.  There is no way to access it off of the current frame      pointer, but it can be accessed off the previous frame pointer by      reading the value from the register window save area.  */
ifdef|#
directive|ifdef
name|RETURN_ADDR_IN_PREVIOUS_FRAME
if|if
condition|(
name|fndecl_code
operator|==
name|BUILT_IN_RETURN_ADDRESS
condition|)
name|count
operator|--
expr_stmt|;
endif|#
directive|endif
comment|/* Scan back COUNT frames to the specified frame.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* Assume the dynamic chain pointer is in the word that the 	 frame address points to, unless otherwise specified.  */
ifdef|#
directive|ifdef
name|DYNAMIC_CHAIN_ADDRESS
name|tem
operator|=
name|DYNAMIC_CHAIN_ADDRESS
argument_list|(
name|tem
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tem
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gen_frame_mem
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|copy_to_reg
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
comment|/* For __builtin_frame_address, return what we've got.  But, on      the SPARC for example, we may have to add a bias.  */
if|if
condition|(
name|fndecl_code
operator|==
name|BUILT_IN_FRAME_ADDRESS
condition|)
ifdef|#
directive|ifdef
name|FRAME_ADDR_RTX
return|return
name|FRAME_ADDR_RTX
argument_list|(
name|tem
argument_list|)
return|;
else|#
directive|else
return|return
name|tem
return|;
endif|#
directive|endif
comment|/* For __builtin_return_address, get the return address from that frame.  */
ifdef|#
directive|ifdef
name|RETURN_ADDR_RTX
name|tem
operator|=
name|RETURN_ADDR_RTX
argument_list|(
name|count
argument_list|,
name|tem
argument_list|)
expr_stmt|;
else|#
directive|else
name|tem
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|tem
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gen_frame_mem
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Alias set used for setjmp buffer.  */
end_comment

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|setjmp_alias_set
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Construct the leading half of a __builtin_setjmp call.  Control will    return to RECEIVER_LABEL.  This is also called directly by the SJLJ    exception handling code.  */
end_comment

begin_function
name|void
name|expand_builtin_setjmp_setup
parameter_list|(
name|rtx
name|buf_addr
parameter_list|,
name|rtx
name|receiver_label
parameter_list|)
block|{
name|enum
name|machine_mode
name|sa_mode
init|=
name|STACK_SAVEAREA_MODE
argument_list|(
name|SAVE_NONLOCAL
argument_list|)
decl_stmt|;
name|rtx
name|stack_save
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
if|if
condition|(
name|setjmp_alias_set
operator|==
operator|-
literal|1
condition|)
name|setjmp_alias_set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
name|buf_addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
name|buf_addr
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|buf_addr
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We store the frame pointer and the address of receiver_label in      the buffer and use the rest of it for the stack save area, which      is machine-dependent.  */
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|setjmp_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|targetm
operator|.
name|builtin_setjmp_frame_value
argument_list|()
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|buf_addr
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
operator|,
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|setjmp_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|validize_mem
argument_list|(
name|mem
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|receiver_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stack_save
operator|=
name|gen_rtx_MEM
argument_list|(
name|sa_mode
argument_list|,
name|plus_constant
argument_list|(
name|buf_addr
argument_list|,
literal|2
operator|*
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|stack_save
argument_list|,
name|setjmp_alias_set
argument_list|)
expr_stmt|;
name|emit_stack_save
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
operator|&
name|stack_save
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* If there is further processing to do, do it.  */
ifdef|#
directive|ifdef
name|HAVE_builtin_setjmp_setup
if|if
condition|(
name|HAVE_builtin_setjmp_setup
condition|)
name|emit_insn
argument_list|(
name|gen_builtin_setjmp_setup
argument_list|(
name|buf_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Tell optimize_save_area_alloca that extra work is going to      need to go on during alloca.  */
name|current_function_calls_setjmp
operator|=
literal|1
expr_stmt|;
comment|/* Set this so all the registers get saved in our frame; we need to be      able to copy the saved values for any registers from frames we unwind.  */
name|current_function_has_nonlocal_label
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Construct the trailing part of a __builtin_setjmp call.  This is    also called directly by the SJLJ exception handling code.  */
end_comment

begin_function
name|void
name|expand_builtin_setjmp_receiver
parameter_list|(
name|rtx
name|receiver_label
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Clobber the FP when we get here, so we have to make sure it's      marked as used by this function.  */
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the static chain as clobbered here so life information      doesn't get messed up for it.  */
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|static_chain_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now put in the code to restore the frame pointer, and argument      pointer, if needed.  */
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto
if|if
condition|(
operator|!
name|HAVE_nonlocal_goto
condition|)
endif|#
directive|endif
block|{
name|emit_move_insn
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
comment|/* This might change the hard frame pointer in ways that aren't 	 apparent to early optimization passes, so force a clobber.  */
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
if|if
condition|(
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
name|size_t
name|i
decl_stmt|;
specifier|static
specifier|const
struct|struct
name|elims
block|{
specifier|const
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|elim_regs
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|elim_regs
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elim_regs
index|[
name|i
index|]
operator|.
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|elim_regs
index|[
name|i
index|]
operator|.
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|ARRAY_SIZE
argument_list|(
name|elim_regs
argument_list|)
condition|)
endif|#
directive|endif
block|{
comment|/* Now restore our arg pointer from the address at which it 	     was saved in our stack frame.  */
name|emit_move_insn
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|copy_to_reg
argument_list|(
name|get_arg_pointer_save_area
argument_list|(
name|cfun
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_builtin_setjmp_receiver
if|if
condition|(
name|HAVE_builtin_setjmp_receiver
condition|)
name|emit_insn
argument_list|(
name|gen_builtin_setjmp_receiver
argument_list|(
name|receiver_label
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto_receiver
if|if
condition|(
name|HAVE_nonlocal_goto_receiver
condition|)
name|emit_insn
argument_list|(
name|gen_nonlocal_goto_receiver
argument_list|()
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
comment|/* Nothing */
block|}
comment|/* @@@ This is a kludge.  Not all machine descriptions define a blockage      insn, but we must not allow the code we just generated to be reordered      by scheduling.  Specifically, the update of the frame pointer must      happen immediately, not later.  So emit an ASM_INPUT to act as blockage      insn.  */
name|emit_insn
argument_list|(
name|gen_rtx_ASM_INPUT
argument_list|(
name|VOIDmode
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __builtin_longjmp is passed a pointer to an array of five words (not    all will be used on all machines).  It operates similarly to the C    library function of the same name, but is more efficient.  Much of    the code below is copied from the handling of non-local gotos.  */
end_comment

begin_function
specifier|static
name|void
name|expand_builtin_longjmp
parameter_list|(
name|rtx
name|buf_addr
parameter_list|,
name|rtx
name|value
parameter_list|)
block|{
name|rtx
name|fp
decl_stmt|,
name|lab
decl_stmt|,
name|stack
decl_stmt|,
name|insn
decl_stmt|,
name|last
decl_stmt|;
name|enum
name|machine_mode
name|sa_mode
init|=
name|STACK_SAVEAREA_MODE
argument_list|(
name|SAVE_NONLOCAL
argument_list|)
decl_stmt|;
if|if
condition|(
name|setjmp_alias_set
operator|==
operator|-
literal|1
condition|)
name|setjmp_alias_set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
name|buf_addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
name|buf_addr
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
comment|/* We used to store value in static_chain_rtx, but that fails if pointers      are smaller than integers.  We instead require that the user must pass      a second argument of 1, because that is what builtin_setjmp will      return.  This also makes EH slightly more efficient, since we are no      longer copying around a value that we don't care about.  */
name|gcc_assert
argument_list|(
name|value
operator|==
name|const1_rtx
argument_list|)
expr_stmt|;
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_builtin_longjmp
if|if
condition|(
name|HAVE_builtin_longjmp
condition|)
name|emit_insn
argument_list|(
name|gen_builtin_longjmp
argument_list|(
name|buf_addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|fp
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
name|lab
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|buf_addr
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|=
name|gen_rtx_MEM
argument_list|(
name|sa_mode
argument_list|,
name|plus_constant
argument_list|(
name|buf_addr
argument_list|,
literal|2
operator|*
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|fp
argument_list|,
name|setjmp_alias_set
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|lab
argument_list|,
name|setjmp_alias_set
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|stack
argument_list|,
name|setjmp_alias_set
argument_list|)
expr_stmt|;
comment|/* Pick up FP, label, and SP from the block and jump.  This code is 	 from expand_goto in stmt.c; see there for detailed comments.  */
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto
if|if
condition|(
name|HAVE_nonlocal_goto
condition|)
comment|/* We have to pass a value to the nonlocal_goto pattern that will 	   get copied into the static_chain pointer, but it does not matter 	   what that value is, because builtin_setjmp does not use it.  */
name|emit_insn
argument_list|(
name|gen_nonlocal_goto
argument_list|(
name|value
argument_list|,
name|lab
argument_list|,
name|stack
argument_list|,
name|fp
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|lab
operator|=
name|copy_to_reg
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|VOIDmode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|emit_stack_restore
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
name|stack
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_indirect_jump
argument_list|(
name|lab
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Search backwards and mark the jump insn as a non-local goto.      Note that this precludes the use of __builtin_longjmp to a      __builtin_setjmp target in the same function.  However, we've      already cautioned the user that these functions are for      internal exception handling use only.  */
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|gcc_assert
argument_list|(
name|insn
operator|!=
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_NON_LOCAL_GOTO
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to __builtin_nonlocal_goto.  We're passed the target label    and the address of the save area.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_nonlocal_goto
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|t_label
decl_stmt|,
name|t_save_area
decl_stmt|;
name|rtx
name|r_label
decl_stmt|,
name|r_save_area
decl_stmt|,
name|r_fp
decl_stmt|,
name|r_sp
decl_stmt|,
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|t_label
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|t_save_area
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|r_label
operator|=
name|expand_normal
argument_list|(
name|t_label
argument_list|)
expr_stmt|;
name|r_label
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|r_label
argument_list|)
expr_stmt|;
name|r_save_area
operator|=
name|expand_normal
argument_list|(
name|t_save_area
argument_list|)
expr_stmt|;
name|r_save_area
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|r_save_area
argument_list|)
expr_stmt|;
name|r_fp
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|r_save_area
argument_list|)
expr_stmt|;
name|r_sp
operator|=
name|gen_rtx_MEM
argument_list|(
name|STACK_SAVEAREA_MODE
argument_list|(
name|SAVE_NONLOCAL
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|r_save_area
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_has_nonlocal_goto
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto
comment|/* ??? We no longer need to pass the static chain value, afaik.  */
if|if
condition|(
name|HAVE_nonlocal_goto
condition|)
name|emit_insn
argument_list|(
name|gen_nonlocal_goto
argument_list|(
name|const0_rtx
argument_list|,
name|r_label
argument_list|,
name|r_sp
argument_list|,
name|r_fp
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|r_label
operator|=
name|copy_to_reg
argument_list|(
name|r_label
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|VOIDmode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore frame pointer for containing function. 	 This sets the actual hard register used for the frame pointer 	 to the location of the function's incoming static chain info. 	 The non-local goto handler will then adjust it to contain the 	 proper value and reload the argument pointer, if needed.  */
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|r_fp
argument_list|)
expr_stmt|;
name|emit_stack_restore
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
name|r_sp
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* USE of hard_frame_pointer_rtx added for consistency; 	 not clear if really needed.  */
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_indirect_jump
argument_list|(
name|r_label
argument_list|)
expr_stmt|;
block|}
comment|/* Search backwards to the jump insn and mark it as a      non-local goto.  */
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_NON_LOCAL_GOTO
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
block|}
return|return
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* __builtin_update_setjmp_buf is passed a pointer to an array of five words    (not all will be used on all machines) that was passed to __builtin_setjmp.    It updates the stack pointer in that block to correspond to the current    stack pointer.  */
end_comment

begin_function
specifier|static
name|void
name|expand_builtin_update_setjmp_buf
parameter_list|(
name|rtx
name|buf_addr
parameter_list|)
block|{
name|enum
name|machine_mode
name|sa_mode
init|=
name|Pmode
decl_stmt|;
name|rtx
name|stack_save
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_save_stack_nonlocal
if|if
condition|(
name|HAVE_save_stack_nonlocal
condition|)
name|sa_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_save_stack_nonlocal
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STACK_SAVEAREA_MODE
name|sa_mode
operator|=
name|STACK_SAVEAREA_MODE
argument_list|(
name|SAVE_NONLOCAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stack_save
operator|=
name|gen_rtx_MEM
argument_list|(
name|sa_mode
argument_list|,
name|memory_address
argument_list|(
name|sa_mode
argument_list|,
name|plus_constant
argument_list|(
name|buf_addr
argument_list|,
literal|2
operator|*
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_setjmp
if|if
condition|(
name|HAVE_setjmp
condition|)
name|emit_insn
argument_list|(
name|gen_setjmp
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_stack_save
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
operator|&
name|stack_save
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand a call to __builtin_prefetch.  For a target that does not support    data prefetch, evaluate the memory address argument in case it has side    effects.  */
end_comment

begin_function
specifier|static
name|void
name|expand_builtin_prefetch
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* Arguments 1 and 2 are optional; argument 1 (read/write) defaults to      zero (read) and argument 2 (locality) defaults to 3 (high degree of      locality).  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
block|{
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
condition|)
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|arg2
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg1
operator|=
name|integer_zero_node
expr_stmt|;
name|arg2
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/* Argument 0 is an address.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Argument 1 (read/write flag) must be a compile-time constant int.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"second argument to %<__builtin_prefetch%> must be a constant"
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|integer_zero_node
expr_stmt|;
block|}
name|op1
operator|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* Argument 1 must be either zero or one.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|!=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"invalid second argument to %<__builtin_prefetch%>;"
literal|" using zero"
argument_list|)
expr_stmt|;
name|op1
operator|=
name|const0_rtx
expr_stmt|;
block|}
comment|/* Argument 2 (locality) must be a compile-time constant int.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"third argument to %<__builtin_prefetch%> must be a constant"
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|integer_zero_node
expr_stmt|;
block|}
name|op2
operator|=
name|expand_normal
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* Argument 2 must be 0, 1, 2, or 3.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|<
literal|0
operator|||
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|>
literal|3
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"invalid third argument to %<__builtin_prefetch%>; using zero"
argument_list|)
expr_stmt|;
name|op2
operator|=
name|const0_rtx
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_prefetch
if|if
condition|(
name|HAVE_prefetch
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
operator|*
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_prefetch
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_prefetch
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|)
operator|)
operator|||
operator|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|Pmode
operator|)
condition|)
block|{
name|op0
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_prefetch
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Don't do anything with direct references to volatile memory, but      generate code to handle other side effects.  */
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a MEM rtx for expression EXP which is the address of an operand    to be used in a string instruction (cmpstrsi, movmemsi, ..).  LEN is    the maximum length of the block of memory that might be accessed or    NULL if unknown.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_memory_rtx
parameter_list|(
name|tree
name|exp
parameter_list|,
name|tree
name|len
parameter_list|)
block|{
name|rtx
name|addr
init|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|ptr_mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|addr
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Get an expression we can use to find the attributes to assign to MEM.      If it is an ADDR_EXPR, use the operand.  Otherwise, dereference it if      we can.  First remove any nops.  */
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|exp
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
else|else
name|exp
operator|=
name|NULL
expr_stmt|;
comment|/* Honor attributes derived from exp, except for the alias set      (as builtin stringops may alias with anything) and the size      (as stringops may access multiple array elements).  */
if|if
condition|(
name|exp
condition|)
block|{
name|set_mem_attributes
argument_list|(
name|mem
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allow the string and memory builtins to overflow from one 	 field into another, see http://gcc.gnu.org/PR23561. 	 Thus avoid COMPONENT_REFs in MEM_EXPR unless we know the whole 	 memory accessed by the string or memory builtin will fit 	 within the field.  */
if|if
condition|(
name|MEM_EXPR
argument_list|(
name|mem
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|MEM_EXPR
argument_list|(
name|mem
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|tree
name|mem_expr
init|=
name|MEM_EXPR
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
operator|-
literal|1
decl_stmt|,
name|length
init|=
operator|-
literal|1
decl_stmt|;
name|tree
name|inner
init|=
name|exp
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|COMPONENT_REF
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_OFFSET
argument_list|(
name|mem
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|MEM_OFFSET
argument_list|(
name|mem
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|MEM_OFFSET
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
literal|0
operator|&&
name|len
operator|&&
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|0
argument_list|)
condition|)
name|length
operator|=
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|mem_expr
argument_list|)
operator|==
name|COMPONENT_REF
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|field
operator|==
name|TREE_OPERAND
argument_list|(
name|mem_expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>=
literal|0
operator|&&
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If we can prove the memory starting at XEXP (mem, 0) 		     and ending at XEXP (mem, 0) + LENGTH will fit into 		     this field, we can keep that COMPONENT_REF in MEM_EXPR.  */
if|if
condition|(
name|offset
operator|<=
name|size
operator|&&
name|length
operator|<=
name|size
operator|&&
name|offset
operator|+
name|length
operator|<=
name|size
condition|)
break|break;
block|}
if|if
condition|(
name|offset
operator|>=
literal|0
operator|&&
name|host_integerp
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|offset
operator|+=
name|tree_low_cst
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|+
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
else|else
block|{
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
name|length
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|mem_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|mem_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mem_expr
operator|==
name|NULL
condition|)
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|mem_expr
operator|!=
name|MEM_EXPR
argument_list|(
name|mem
argument_list|)
condition|)
block|{
name|set_mem_expr
argument_list|(
name|mem
argument_list|,
name|mem_expr
argument_list|)
expr_stmt|;
name|set_mem_offset
argument_list|(
name|mem
argument_list|,
name|offset
operator|>=
literal|0
condition|?
name|GEN_INT
argument_list|(
name|offset
argument_list|)
else|:
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
block|}
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_size
argument_list|(
name|mem
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
return|return
name|mem
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Built-in functions to perform an untyped call and return.  */
end_comment

begin_comment
comment|/* For each register that may be used for calling a function, this    gives a mode used to copy the register's value.  VOIDmode indicates    the register is not used for calling a function.  If the machine    has register windows, this gives only the outbound registers.    INCOMING_REGNO gives the corresponding inbound register.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|apply_args_mode
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each register that may be used for returning values, this gives    a mode used to copy the register's value.  VOIDmode indicates the    register is not used for returning values.  If the machine has    register windows, this gives only the outbound registers.    INCOMING_REGNO gives the corresponding inbound register.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|apply_result_mode
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each register that may be used for calling a function, this    gives the offset of that register into the block returned by    __builtin_apply_args.  0 indicates that the register is not    used for calling a function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|apply_args_reg_offset
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the size required for the block returned by __builtin_apply_args,    and initialize apply_args_mode.  */
end_comment

begin_function
specifier|static
name|int
name|apply_args_size
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|size
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|align
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* The values computed by this function never change.  */
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
comment|/* The first value is the incoming arg-pointer.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* The second value is the structure value address unless this is 	 passed as an "invisible" first argument.  */
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|struct_value_rtx
argument_list|(
name|cfun
condition|?
name|TREE_TYPE
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
else|:
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|mode
operator|=
name|reg_raw_mode
index|[
name|regno
index|]
expr_stmt|;
name|gcc_assert
argument_list|(
name|mode
operator|!=
name|VOIDmode
argument_list|)
expr_stmt|;
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|apply_args_reg_offset
index|[
name|regno
index|]
operator|=
name|size
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|apply_args_mode
index|[
name|regno
index|]
operator|=
name|mode
expr_stmt|;
block|}
else|else
block|{
name|apply_args_mode
index|[
name|regno
index|]
operator|=
name|VOIDmode
expr_stmt|;
name|apply_args_reg_offset
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the size required for the block returned by __builtin_apply,    and initialize apply_result_mode.  */
end_comment

begin_function
specifier|static
name|int
name|apply_result_size
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|size
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* The values computed by this function never change.  */
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|FUNCTION_VALUE_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|mode
operator|=
name|reg_raw_mode
index|[
name|regno
index|]
expr_stmt|;
name|gcc_assert
argument_list|(
name|mode
operator|!=
name|VOIDmode
argument_list|)
expr_stmt|;
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|apply_result_mode
index|[
name|regno
index|]
operator|=
name|mode
expr_stmt|;
block|}
else|else
name|apply_result_mode
index|[
name|regno
index|]
operator|=
name|VOIDmode
expr_stmt|;
comment|/* Allow targets that use untyped_call and untyped_return to override 	 the size so that machine-specific information can be stored here.  */
ifdef|#
directive|ifdef
name|APPLY_RESULT_SIZE
name|size
operator|=
name|APPLY_RESULT_SIZE
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|size
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_untyped_call
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_untyped_return
argument_list|)
end_if

begin_comment
comment|/* Create a vector describing the result block RESULT.  If SAVEP is true,    the result block is used to save the values; otherwise it is used to    restore the values.  */
end_comment

begin_function
specifier|static
name|rtx
name|result_vector
parameter_list|(
name|int
name|savep
parameter_list|,
name|rtx
name|result
parameter_list|)
block|{
name|int
name|regno
decl_stmt|,
name|size
decl_stmt|,
name|align
decl_stmt|,
name|nelts
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|rtx
modifier|*
name|savevec
init|=
name|alloca
argument_list|(
name|FIRST_PSEUDO_REGISTER
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|size
operator|=
name|nelts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_result_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|savep
condition|?
name|regno
else|:
name|INCOMING_REGNO
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|adjust_address
argument_list|(
name|result
argument_list|,
name|mode
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|savevec
index|[
name|nelts
operator|++
index|]
operator|=
operator|(
name|savep
condition|?
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
else|:
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|mem
argument_list|)
operator|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|nelts
argument_list|,
name|savevec
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_untyped_call or HAVE_untyped_return */
end_comment

begin_comment
comment|/* Save the state required to perform an untyped call with the same    arguments as were passed to the current function.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_apply_args_1
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|registers
decl_stmt|,
name|tem
decl_stmt|;
name|int
name|size
decl_stmt|,
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|struct_incoming_value
init|=
name|targetm
operator|.
name|calls
operator|.
name|struct_value_rtx
argument_list|(
name|cfun
condition|?
name|TREE_TYPE
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
else|:
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Create a block where the arg-pointer, structure value address,      and argument registers can be saved.  */
name|registers
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|apply_args_size
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Walk past the arg-pointer and structure value address.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|struct_value_rtx
argument_list|(
name|cfun
condition|?
name|TREE_TYPE
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
else|:
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Save each register used in calling a function to the block.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_args_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|tem
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|INCOMING_REGNO
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|registers
argument_list|,
name|mode
argument_list|,
name|size
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Save the arg pointer to the block.  */
name|tem
operator|=
name|copy_to_reg
argument_list|(
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
comment|/* We need the pointer as the caller actually passed them to us, not      as we might have pretended they were passed.  Make sure it's a valid      operand, as emit_move_insn isn't expected to handle a PLUS.  */
name|tem
operator|=
name|force_operand
argument_list|(
name|plus_constant
argument_list|(
name|tem
argument_list|,
name|current_function_pretend_args_size
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|registers
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Save the structure value address unless this is passed as an      "invisible" first argument.  */
if|if
condition|(
name|struct_incoming_value
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|registers
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|struct_incoming_value
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
comment|/* Return the address of the block.  */
return|return
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|registers
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* __builtin_apply_args returns block of memory allocated on    the stack into which is stored the arg pointer, structure    value address, static chain, and all the registers that might    possibly be used in performing a function call.  The code is    moved to the start of the function so the incoming values are    saved.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_apply_args
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Don't do __builtin_apply_args more than once in a function.      Save the result of the first call and reuse it.  */
if|if
condition|(
name|apply_args_value
operator|!=
literal|0
condition|)
return|return
name|apply_args_value
return|;
block|{
comment|/* When this function is called, it means that registers must be        saved on entry to this function.  So we migrate the        call to the first insn of this function.  */
name|rtx
name|temp
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|temp
operator|=
name|expand_builtin_apply_args_1
argument_list|()
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|apply_args_value
operator|=
name|temp
expr_stmt|;
comment|/* Put the insns after the NOTE that starts the function.        If this is inside a start_sequence, make the outer-level insn        chain current, so the code is placed at the start of the        function.  */
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|NEXT_INSN
argument_list|(
name|entry_of_function
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
end_function

begin_comment
comment|/* Perform an untyped call and save the state required to perform an    untyped return of whatever value was returned by the given function.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_apply
parameter_list|(
name|rtx
name|function
parameter_list|,
name|rtx
name|arguments
parameter_list|,
name|rtx
name|argsize
parameter_list|)
block|{
name|int
name|size
decl_stmt|,
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|incoming_args
decl_stmt|,
name|result
decl_stmt|,
name|reg
decl_stmt|,
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|call_insn
decl_stmt|;
name|rtx
name|old_stack_level
init|=
literal|0
decl_stmt|;
name|rtx
name|call_fusage
init|=
literal|0
decl_stmt|;
name|rtx
name|struct_value
init|=
name|targetm
operator|.
name|calls
operator|.
name|struct_value_rtx
argument_list|(
name|cfun
condition|?
name|TREE_TYPE
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
else|:
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|arguments
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
comment|/* Create a block where the return registers can be saved.  */
name|result
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|apply_result_size
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Fetch the arg pointer from the ARGUMENTS block.  */
name|incoming_args
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|incoming_args
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|arguments
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|STACK_GROWS_DOWNWARD
name|incoming_args
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|MINUS
argument_list|,
name|incoming_args
argument_list|,
name|argsize
argument_list|,
name|incoming_args
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Push a new argument block and copy the arguments.  Do not allow      the (potential) memcpy call below to interfere with our stack      manipulations.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
comment|/* Save the stack with nonlocal if available.  */
ifdef|#
directive|ifdef
name|HAVE_save_stack_nonlocal
if|if
condition|(
name|HAVE_save_stack_nonlocal
condition|)
name|emit_stack_save
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
operator|&
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|emit_stack_save
argument_list|(
name|SAVE_BLOCK
argument_list|,
operator|&
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Allocate a block of memory onto the stack and copy the memory      arguments to the outgoing arguments address.  */
name|allocate_dynamic_stack_space
argument_list|(
name|argsize
argument_list|,
literal|0
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|dest
operator|=
name|virtual_outgoing_args_rtx
expr_stmt|;
ifndef|#
directive|ifndef
name|STACK_GROWS_DOWNWARD
if|if
condition|(
name|GET_CODE
argument_list|(
name|argsize
argument_list|)
operator|==
name|CONST_INT
condition|)
name|dest
operator|=
name|plus_constant
argument_list|(
name|dest
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|argsize
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dest
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|dest
argument_list|,
name|negate_rtx
argument_list|(
name|Pmode
argument_list|,
name|argsize
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dest
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|dest
argument_list|,
name|PARM_BOUNDARY
argument_list|)
expr_stmt|;
name|src
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|incoming_args
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|src
argument_list|,
name|PARM_BOUNDARY
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|argsize
argument_list|,
name|BLOCK_OP_NORMAL
argument_list|)
expr_stmt|;
comment|/* Refer to the argument block.  */
name|apply_args_size
argument_list|()
expr_stmt|;
name|arguments
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|arguments
argument_list|,
name|PARM_BOUNDARY
argument_list|)
expr_stmt|;
comment|/* Walk past the arg-pointer and structure value address.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_value
condition|)
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Restore each of the registers previously saved.  Make USE insns      for each of these registers for use in making the call.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_args_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|adjust_address
argument_list|(
name|arguments
argument_list|,
name|mode
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the structure value address unless this is passed as an      "invisible" first argument.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_value
condition|)
block|{
name|rtx
name|value
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|value
argument_list|,
name|adjust_address
argument_list|(
name|arguments
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|struct_value
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|struct_value
argument_list|)
condition|)
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|struct_value
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
comment|/* All arguments and registers used for the call are set up by now!  */
name|function
operator|=
name|prepare_call_address
argument_list|(
name|function
argument_list|,
name|NULL
argument_list|,
operator|&
name|call_fusage
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Ensure address is valid.  SYMBOL_REF is already valid, so no need,      and we don't want to load it into a register as an optimization,      because prepare_call_address already did it if it should be done.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|function
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|function
operator|=
name|memory_address
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|function
argument_list|)
expr_stmt|;
comment|/* Generate the actual call instruction and save the return value.  */
ifdef|#
directive|ifdef
name|HAVE_untyped_call
if|if
condition|(
name|HAVE_untyped_call
condition|)
name|emit_call_insn
argument_list|(
name|gen_untyped_call
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|function
argument_list|)
argument_list|,
name|result
argument_list|,
name|result_vector
argument_list|(
literal|1
argument_list|,
name|result
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_call_value
if|if
condition|(
name|HAVE_call_value
condition|)
block|{
name|rtx
name|valreg
init|=
literal|0
decl_stmt|;
comment|/* Locate the unique return register.  It is not possible to 	 express a call that sets more than one return register using 	 call_value; use untyped_call for that.  In fact, untyped_call 	 only needs to save the return registers in the given block.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_result_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|valreg
argument_list|)
expr_stmt|;
comment|/* HAVE_untyped_call required.  */
name|valreg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|emit_call_insn
argument_list|(
name|GEN_CALL_VALUE
argument_list|(
name|valreg
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|function
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|NULL_RTX
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|result
argument_list|,
name|GET_MODE
argument_list|(
name|valreg
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|valreg
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|gcc_unreachable
argument_list|()
expr_stmt|;
comment|/* Find the CALL insn we just emitted, and attach the register usage      information.  */
name|call_insn
operator|=
name|last_call_insn
argument_list|()
expr_stmt|;
name|add_function_usage_to
argument_list|(
name|call_insn
argument_list|,
name|call_fusage
argument_list|)
expr_stmt|;
comment|/* Restore the stack.  */
ifdef|#
directive|ifdef
name|HAVE_save_stack_nonlocal
if|if
condition|(
name|HAVE_save_stack_nonlocal
condition|)
name|emit_stack_restore
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|emit_stack_restore
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
comment|/* Return the address of the result block.  */
name|result
operator|=
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|result
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform an untyped return.  */
end_comment

begin_function
specifier|static
name|void
name|expand_builtin_return
parameter_list|(
name|rtx
name|result
parameter_list|)
block|{
name|int
name|size
decl_stmt|,
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|call_fusage
init|=
literal|0
decl_stmt|;
name|result
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|apply_result_size
argument_list|()
expr_stmt|;
name|result
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|result
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_untyped_return
if|if
condition|(
name|HAVE_untyped_return
condition|)
block|{
name|emit_jump_insn
argument_list|(
name|gen_untyped_return
argument_list|(
name|result
argument_list|,
name|result_vector
argument_list|(
literal|0
argument_list|,
name|result
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Restore the return value and note that each value is used.  */
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_result_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|INCOMING_REGNO
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|adjust_address
argument_list|(
name|result
argument_list|,
name|mode
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|push_to_sequence
argument_list|(
name|call_fusage
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|call_fusage
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Put the USE insns before the return.  */
name|emit_insn
argument_list|(
name|call_fusage
argument_list|)
expr_stmt|;
comment|/* Return whatever values was restored by jumping directly to the end      of the function.  */
name|expand_naked_return
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used by expand_builtin_classify_type and fold_builtin_classify_type.  */
end_comment

begin_function
specifier|static
name|enum
name|type_class
name|type_to_class
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|VOID_TYPE
case|:
return|return
name|void_type_class
return|;
case|case
name|INTEGER_TYPE
case|:
return|return
name|integer_type_class
return|;
case|case
name|ENUMERAL_TYPE
case|:
return|return
name|enumeral_type_class
return|;
case|case
name|BOOLEAN_TYPE
case|:
return|return
name|boolean_type_class
return|;
case|case
name|POINTER_TYPE
case|:
return|return
name|pointer_type_class
return|;
case|case
name|REFERENCE_TYPE
case|:
return|return
name|reference_type_class
return|;
case|case
name|OFFSET_TYPE
case|:
return|return
name|offset_type_class
return|;
case|case
name|REAL_TYPE
case|:
return|return
name|real_type_class
return|;
case|case
name|COMPLEX_TYPE
case|:
return|return
name|complex_type_class
return|;
case|case
name|FUNCTION_TYPE
case|:
return|return
name|function_type_class
return|;
case|case
name|METHOD_TYPE
case|:
return|return
name|method_type_class
return|;
case|case
name|RECORD_TYPE
case|:
return|return
name|record_type_class
return|;
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
return|return
name|union_type_class
return|;
case|case
name|ARRAY_TYPE
case|:
return|return
operator|(
name|TYPE_STRING_FLAG
argument_list|(
name|type
argument_list|)
condition|?
name|string_type_class
else|:
name|array_type_class
operator|)
return|;
case|case
name|LANG_TYPE
case|:
return|return
name|lang_type_class
return|;
default|default:
return|return
name|no_type_class
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to __builtin_classify_type with arguments found in    ARGLIST.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_classify_type
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
if|if
condition|(
name|arglist
operator|!=
literal|0
condition|)
return|return
name|GEN_INT
argument_list|(
name|type_to_class
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|GEN_INT
argument_list|(
name|no_type_class
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This helper macro, meant to be used in mathfn_built_in below,    determines which among a set of three builtin math functions is    appropriate for a given type mode.  The `F' and `L' cases are    automatically generated from the `double' case.  */
end_comment

begin_define
define|#
directive|define
name|CASE_MATHFN
parameter_list|(
name|BUILT_IN_MATHFN
parameter_list|)
define|\
value|case BUILT_IN_MATHFN: case BUILT_IN_MATHFN##F: case BUILT_IN_MATHFN##L: \   fcode = BUILT_IN_MATHFN; fcodef = BUILT_IN_MATHFN##F ; \   fcodel = BUILT_IN_MATHFN##L ; break;
end_define

begin_comment
comment|/* Return mathematic function equivalent to FN but operating directly    on TYPE, if available.  If we can't do the conversion, return zero.  */
end_comment

begin_function
name|tree
name|mathfn_built_in
parameter_list|(
name|tree
name|type
parameter_list|,
name|enum
name|built_in_function
name|fn
parameter_list|)
block|{
name|enum
name|built_in_function
name|fcode
decl_stmt|,
name|fcodef
decl_stmt|,
name|fcodel
decl_stmt|;
switch|switch
condition|(
name|fn
condition|)
block|{
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ACOS
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ACOSH
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ASIN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ASINH
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ATAN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ATAN2
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ATANH
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_CBRT
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_CEIL
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_COPYSIGN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_COS
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_COSH
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_DREM
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ERF
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ERFC
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_EXP
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_EXP10
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_EXP2
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_EXPM1
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_FABS
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_FDIM
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_FLOOR
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_FMA
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_FMAX
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_FMIN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_FMOD
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_FREXP
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_GAMMA
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_HUGE_VAL
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_HYPOT
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ILOGB
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_INF
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_J0
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_J1
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_JN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LCEIL
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LDEXP
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LFLOOR
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LGAMMA
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LLCEIL
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LLFLOOR
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LLRINT
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LLROUND
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LOG
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LOG10
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LOG1P
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LOG2
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LOGB
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LRINT
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LROUND
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_MODF
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_NAN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_NANS
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_NEARBYINT
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_NEXTAFTER
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_NEXTTOWARD
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_POW
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_POWI
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_POW10
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_REMAINDER
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_REMQUO
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_RINT
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ROUND
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_SCALB
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_SCALBLN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_SCALBN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_SIGNIFICAND
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_SIN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_SINCOS
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_SINH
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_SQRT
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_TAN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_TANH
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_TGAMMA
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_TRUNC
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_Y0
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_Y1
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_YN
argument_list|)
default|default:
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|double_type_node
condition|)
return|return
name|implicit_built_in_decls
index|[
name|fcode
index|]
return|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
return|return
name|implicit_built_in_decls
index|[
name|fcodef
index|]
return|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|long_double_type_node
condition|)
return|return
name|implicit_built_in_decls
index|[
name|fcodel
index|]
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If errno must be maintained, expand the RTL to check if the result,    TARGET, of a built-in function call, EXP, is NaN, and if so set    errno to EDOM.  */
end_comment

begin_function
specifier|static
name|void
name|expand_errno_check
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|lab
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
comment|/* Test the result; if it is NaN, set errno=EDOM because      the argument was not in the domain.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|target
argument_list|,
name|target
argument_list|,
name|EQ
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|,
name|lab
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_EDOM
comment|/* If this built-in doesn't throw an exception, set errno directly.  */
if|if
condition|(
name|TREE_NOTHROW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|GEN_ERRNO_RTX
name|rtx
name|errno_rtx
init|=
name|GEN_ERRNO_RTX
decl_stmt|;
else|#
directive|else
name|rtx
name|errno_rtx
init|=
name|gen_rtx_MEM
argument_list|(
name|word_mode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"errno"
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|errno_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|TARGET_EDOM
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|lab
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* We can't set errno=EDOM directly; let the library call do it.      Pop the arguments right away in case the call gets deleted.  */
name|NO_DEFER_POP
expr_stmt|;
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
name|emit_label
argument_list|(
name|lab
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand a call to one of the builtin math functions (sqrt, exp, or log).    Return 0 if a normal call should be emitted rather than expanding the    function in-line.  EXP is the expression that is a call to the builtin    function; if convenient, the result should be placed in TARGET.    SUBTARGET may be used as the target for computing one of EXP's operands.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_mathfn
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
parameter_list|)
block|{
name|optab
name|builtin_optab
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|insns
decl_stmt|,
name|before_call
decl_stmt|;
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|bool
name|errno_set
init|=
name|false
decl_stmt|;
name|tree
name|arg
decl_stmt|,
name|narg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_SQRT
argument_list|)
operator|:
name|errno_set
operator|=
operator|!
name|tree_expr_nonnegative_p
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|builtin_optab
operator|=
name|sqrt_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_EXP
argument_list|)
operator|:
name|errno_set
operator|=
name|true
expr_stmt|;
name|builtin_optab
operator|=
name|exp_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_EXP10
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_POW10
argument_list|)
operator|:
name|errno_set
operator|=
name|true
expr_stmt|;
name|builtin_optab
operator|=
name|exp10_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_EXP2
argument_list|)
operator|:
name|errno_set
operator|=
name|true
expr_stmt|;
name|builtin_optab
operator|=
name|exp2_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_EXPM1
argument_list|)
operator|:
name|errno_set
operator|=
name|true
expr_stmt|;
name|builtin_optab
operator|=
name|expm1_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LOGB
argument_list|)
operator|:
name|errno_set
operator|=
name|true
expr_stmt|;
name|builtin_optab
operator|=
name|logb_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ILOGB
argument_list|)
operator|:
name|errno_set
operator|=
name|true
expr_stmt|;
name|builtin_optab
operator|=
name|ilogb_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LOG
argument_list|)
operator|:
name|errno_set
operator|=
name|true
expr_stmt|;
name|builtin_optab
operator|=
name|log_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LOG10
argument_list|)
operator|:
name|errno_set
operator|=
name|true
expr_stmt|;
name|builtin_optab
operator|=
name|log10_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LOG2
argument_list|)
operator|:
name|errno_set
operator|=
name|true
expr_stmt|;
name|builtin_optab
operator|=
name|log2_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LOG1P
argument_list|)
operator|:
name|errno_set
operator|=
name|true
expr_stmt|;
name|builtin_optab
operator|=
name|log1p_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ASIN
argument_list|)
operator|:
name|builtin_optab
operator|=
name|asin_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ACOS
argument_list|)
operator|:
name|builtin_optab
operator|=
name|acos_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_TAN
argument_list|)
operator|:
name|builtin_optab
operator|=
name|tan_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ATAN
argument_list|)
operator|:
name|builtin_optab
operator|=
name|atan_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_FLOOR
argument_list|)
operator|:
name|builtin_optab
operator|=
name|floor_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_CEIL
argument_list|)
operator|:
name|builtin_optab
operator|=
name|ceil_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_TRUNC
argument_list|)
operator|:
name|builtin_optab
operator|=
name|btrunc_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ROUND
argument_list|)
operator|:
name|builtin_optab
operator|=
name|round_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_NEARBYINT
argument_list|)
operator|:
name|builtin_optab
operator|=
name|nearbyint_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_RINT
argument_list|)
operator|:
name|builtin_optab
operator|=
name|rint_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LRINT
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLRINT
argument_list|)
operator|:
name|builtin_optab
operator|=
name|lrint_optab
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Make a suitable register to place result in.  */
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_errno_math
operator|||
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
condition|)
name|errno_set
operator|=
name|false
expr_stmt|;
comment|/* Before working hard, check whether the instruction is available.  */
if|if
condition|(
name|builtin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Wrap the computation of the argument in a SAVE_EXPR, as we may 	 need to expand the argument again.  This way, we will not perform 	 side-effects more the once.  */
name|narg
operator|=
name|builtin_save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|narg
operator|!=
name|arg
condition|)
block|{
name|arg
operator|=
name|narg
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Compute into TARGET. 	 Set TARGET to wherever the result comes back.  */
name|target
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|builtin_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno_set
condition|)
name|expand_errno_check
argument_list|(
name|exp
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* Output the entire sequence.  */
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|insns
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* If we were unable to expand via the builtin, stop the sequence 	 (without outputting the insns) and call to the library function 	 with the stabilized argument list.  */
name|end_sequence
argument_list|()
expr_stmt|;
block|}
name|before_call
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|target
operator|=
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|target
operator|==
name|const0_rtx
argument_list|)
expr_stmt|;
comment|/* If this is a sqrt operation and we don't care about errno, try to      attach a REG_EQUAL note with a SQRT rtx to the emitted libcall.      This allows the semantics of the libcall to be visible to the RTL      optimizers.  */
if|if
condition|(
name|builtin_optab
operator|==
name|sqrt_optab
operator|&&
operator|!
name|errno_set
condition|)
block|{
comment|/* Search backwards through the insns emitted by expand_call looking 	 for the instruction with the REG_RETVAL note.  */
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
while|while
condition|(
name|last
operator|!=
name|before_call
condition|)
block|{
if|if
condition|(
name|find_reg_note
argument_list|(
name|last
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|last
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
comment|/* Check that the REQ_EQUAL note is an EXPR_LIST with 		 two elements, i.e. symbol_ref(sqrt) and the operand.  */
if|if
condition|(
name|note
operator|&&
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|==
name|EXPR_LIST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EXPR_LIST
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|NULL_RTX
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|NULL_RTX
condition|)
block|{
name|rtx
name|operand
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Check operand is a register with expected mode.  */
if|if
condition|(
name|operand
operator|&&
name|REG_P
argument_list|(
name|operand
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|operand
argument_list|)
operator|==
name|mode
condition|)
block|{
comment|/* Replace the REG_EQUAL note with a SQRT rtx.  */
name|rtx
name|equiv
init|=
name|gen_rtx_SQRT
argument_list|(
name|mode
argument_list|,
name|operand
argument_list|)
decl_stmt|;
name|set_unique_reg_note
argument_list|(
name|last
argument_list|,
name|REG_EQUAL
argument_list|,
name|equiv
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
name|last
operator|=
name|PREV_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to the builtin binary math functions (pow and atan2).    Return 0 if a normal call should be emitted rather than expanding the    function in-line.  EXP is the expression that is a call to the builtin    function; if convenient, the result should be placed in TARGET.    SUBTARGET may be used as the target for computing one of EXP's    operands.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_mathfn_2
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
parameter_list|)
block|{
name|optab
name|builtin_optab
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|insns
decl_stmt|;
name|int
name|op1_type
init|=
name|REAL_TYPE
decl_stmt|;
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|temp
decl_stmt|,
name|narg
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|bool
name|errno_set
init|=
name|true
decl_stmt|;
name|bool
name|stable
init|=
name|true
decl_stmt|;
if|if
condition|(
operator|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_LDEXP
operator|)
operator|||
operator|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_LDEXPF
operator|)
operator|||
operator|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_LDEXPL
operator|)
condition|)
name|op1_type
operator|=
name|INTEGER_TYPE
expr_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|op1_type
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_POW
argument_list|)
operator|:
name|builtin_optab
operator|=
name|pow_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ATAN2
argument_list|)
operator|:
name|builtin_optab
operator|=
name|atan2_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LDEXP
argument_list|)
operator|:
name|builtin_optab
operator|=
name|ldexp_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_FMOD
argument_list|)
operator|:
name|builtin_optab
operator|=
name|fmod_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_DREM
argument_list|)
operator|:
name|builtin_optab
operator|=
name|drem_optab
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Make a suitable register to place result in.  */
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Before working hard, check whether the instruction is available.  */
if|if
condition|(
name|builtin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|==
name|CODE_FOR_nothing
condition|)
return|return
literal|0
return|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_errno_math
operator|||
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
condition|)
name|errno_set
operator|=
name|false
expr_stmt|;
comment|/* Always stabilize the argument list.  */
name|narg
operator|=
name|builtin_save_expr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|narg
operator|!=
name|arg1
condition|)
block|{
name|arg1
operator|=
name|narg
expr_stmt|;
name|temp
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|narg
argument_list|)
expr_stmt|;
name|stable
operator|=
name|false
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|narg
operator|=
name|builtin_save_expr
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|narg
operator|!=
name|arg0
condition|)
block|{
name|arg0
operator|=
name|narg
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|narg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|stable
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|stable
condition|)
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg0
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stable
condition|)
name|exp
operator|=
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Compute into TARGET.      Set TARGET to wherever the result comes back.  */
name|target
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|builtin_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
comment|/* If we were unable to expand via the builtin, stop the sequence      (without outputting the insns) and call to the library function      with the stabilized argument list.  */
if|if
condition|(
name|target
operator|==
literal|0
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|target
operator|==
name|const0_rtx
argument_list|)
return|;
block|}
if|if
condition|(
name|errno_set
condition|)
name|expand_errno_check
argument_list|(
name|exp
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* Output the entire sequence.  */
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|insns
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to the builtin sin and cos math functions.    Return 0 if a normal call should be emitted rather than expanding the    function in-line.  EXP is the expression that is a call to the builtin    function; if convenient, the result should be placed in TARGET.    SUBTARGET may be used as the target for computing one of EXP's    operands.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_mathfn_3
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
parameter_list|)
block|{
name|optab
name|builtin_optab
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|insns
decl_stmt|;
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|arg
decl_stmt|,
name|narg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_SIN
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_COS
argument_list|)
operator|:
name|builtin_optab
operator|=
name|sincos_optab
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Make a suitable register to place result in.  */
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check if sincos insn is available, otherwise fallback      to sin or cos insn.  */
if|if
condition|(
name|builtin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|==
name|CODE_FOR_nothing
condition|)
block|{
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_SIN
argument_list|)
operator|:
name|builtin_optab
operator|=
name|sin_optab
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_COS
argument_list|)
operator|:
name|builtin_optab
operator|=
name|cos_optab
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Before working hard, check whether the instruction is available.  */
if|if
condition|(
name|builtin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Wrap the computation of the argument in a SAVE_EXPR, as we may 	 need to expand the argument again.  This way, we will not perform 	 side-effects more the once.  */
name|narg
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|narg
operator|!=
name|arg
condition|)
block|{
name|arg
operator|=
name|narg
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Compute into TARGET. 	 Set TARGET to wherever the result comes back.  */
if|if
condition|(
name|builtin_optab
operator|==
name|sincos_optab
condition|)
block|{
name|int
name|result
decl_stmt|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_SIN
argument_list|)
operator|:
name|result
operator|=
name|expand_twoval_unop
argument_list|(
name|builtin_optab
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_COS
argument_list|)
operator|:
name|result
operator|=
name|expand_twoval_unop
argument_list|(
name|builtin_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|builtin_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target
operator|!=
literal|0
condition|)
block|{
comment|/* Output the entire sequence.  */
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|insns
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* If we were unable to expand via the builtin, stop the sequence 	 (without outputting the insns) and call to the library function 	 with the stabilized argument list.  */
name|end_sequence
argument_list|()
expr_stmt|;
block|}
name|target
operator|=
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|target
operator|==
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to the builtin sincos math function.    Return 0 if a normal call should be emitted rather than expanding the    function in-line.  EXP is the expression that is a call to the builtin    function.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_sincos
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|target1
decl_stmt|,
name|target2
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|arg
decl_stmt|,
name|sinp
decl_stmt|,
name|cosp
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|sinp
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|cosp
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a suitable register to place result in.  */
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check if sincos insn is available, otherwise emit the call.  */
if|if
condition|(
name|sincos_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|==
name|CODE_FOR_nothing
condition|)
return|return
name|NULL_RTX
return|;
name|target1
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|target2
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|build_fold_indirect_ref
argument_list|(
name|sinp
argument_list|)
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_normal
argument_list|(
name|build_fold_indirect_ref
argument_list|(
name|cosp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute into target1 and target2.      Set TARGET to wherever the result comes back.  */
name|result
operator|=
name|expand_twoval_unop
argument_list|(
name|sincos_optab
argument_list|,
name|op0
argument_list|,
name|target2
argument_list|,
name|target1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* Move target1 and target2 to the memory locations indicated      by op1 and op2.  */
name|emit_move_insn
argument_list|(
name|op1
argument_list|,
name|target1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|op2
argument_list|,
name|target2
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to one of the builtin rounding functions (lfloor).    If expanding via optab fails, lower expression to (int)(floor(x)).    EXP is the expression that is a call to the builtin function;    if convenient, the result should be placed in TARGET.  SUBTARGET may    be used as the target for computing one of EXP's operands.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_int_roundingfn
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
parameter_list|)
block|{
name|optab
name|builtin_optab
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|insns
decl_stmt|,
name|tmp
decl_stmt|;
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|built_in_function
name|fallback_fn
decl_stmt|;
name|tree
name|fallback_fndecl
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|arg
decl_stmt|,
name|narg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LCEIL
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLCEIL
argument_list|)
operator|:
name|builtin_optab
operator|=
name|lceil_optab
expr_stmt|;
name|fallback_fn
operator|=
name|BUILT_IN_CEIL
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LFLOOR
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLFLOOR
argument_list|)
operator|:
name|builtin_optab
operator|=
name|lfloor_optab
expr_stmt|;
name|fallback_fn
operator|=
name|BUILT_IN_FLOOR
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Make a suitable register to place result in.  */
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Before working hard, check whether the instruction is available.  */
if|if
condition|(
name|builtin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Wrap the computation of the argument in a SAVE_EXPR, as we may 	 need to expand the argument again.  This way, we will not perform 	 side-effects more the once.  */
name|narg
operator|=
name|builtin_save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|narg
operator|!=
name|arg
condition|)
block|{
name|arg
operator|=
name|narg
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Compute into TARGET. 	 Set TARGET to wherever the result comes back.  */
name|target
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|builtin_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
literal|0
condition|)
block|{
comment|/* Output the entire sequence.  */
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|insns
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* If we were unable to expand via the builtin, stop the sequence 	 (without outputting the insns).  */
name|end_sequence
argument_list|()
expr_stmt|;
block|}
comment|/* Fall back to floating point rounding optab.  */
name|fallback_fndecl
operator|=
name|mathfn_built_in
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|fallback_fn
argument_list|)
expr_stmt|;
comment|/* We shouldn't get here on targets without TARGET_C99_FUNCTIONS.      ??? Perhaps convert (int)floorf(x) into (int)floor((double)x).  */
name|gcc_assert
argument_list|(
name|fallback_fndecl
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_function_call_expr
argument_list|(
name|fallback_fndecl
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_normal
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Truncate the result of floating point optab to integer      via expand_fix ().  */
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|expand_fix
argument_list|(
name|target
argument_list|,
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* To evaluate powi(x,n), the floating point value x raised to the    constant integer exponent n, we use a hybrid algorithm that    combines the "window method" with look-up tables.  For an    introduction to exponentiation algorithms and "addition chains",    see section 4.6.3, "Evaluation of Powers" of Donald E. Knuth,    "Seminumerical Algorithms", Vol. 2, "The Art of Computer Programming",    3rd Edition, 1998, and Daniel M. Gordon, "A Survey of Fast Exponentiation    Methods", Journal of Algorithms, Vol. 27, pp. 129-146, 1998.  */
end_comment

begin_comment
comment|/* Provide a default value for POWI_MAX_MULTS, the maximum number of    multiplications to inline before calling the system library's pow    function.  powi(x,n) requires at worst 2*bits(n)-2 multiplications,    so this default never requires calling pow, powf or powl.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|POWI_MAX_MULTS
end_ifndef

begin_define
define|#
directive|define
name|POWI_MAX_MULTS
value|(2*HOST_BITS_PER_WIDE_INT-2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The size of the "optimal power tree" lookup table.  All    exponents less than this value are simply looked up in the    powi_table below.  This threshold is also used to size the    cache of pseudo registers that hold intermediate results.  */
end_comment

begin_define
define|#
directive|define
name|POWI_TABLE_SIZE
value|256
end_define

begin_comment
comment|/* The size, in bits of the window, used in the "window method"    exponentiation algorithm.  This is equivalent to a radix of    (1<<POWI_WINDOW_SIZE) in the corresponding "m-ary method".  */
end_comment

begin_define
define|#
directive|define
name|POWI_WINDOW_SIZE
value|3
end_define

begin_comment
comment|/* The following table is an efficient representation of an    "optimal power tree".  For each value, i, the corresponding    value, j, in the table states than an optimal evaluation    sequence for calculating pow(x,i) can be found by evaluating    pow(x,j)*pow(x,i-j).  An optimal power tree for the first    100 integers is given in Knuth's "Seminumerical algorithms".  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|powi_table
index|[
name|POWI_TABLE_SIZE
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
comment|/*   0 -   7 */
literal|4
block|,
literal|6
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|10
block|,
literal|7
block|,
literal|9
block|,
comment|/*   8 -  15 */
literal|8
block|,
literal|16
block|,
literal|9
block|,
literal|16
block|,
literal|10
block|,
literal|12
block|,
literal|11
block|,
literal|13
block|,
comment|/*  16 -  23 */
literal|12
block|,
literal|17
block|,
literal|13
block|,
literal|18
block|,
literal|14
block|,
literal|24
block|,
literal|15
block|,
literal|26
block|,
comment|/*  24 -  31 */
literal|16
block|,
literal|17
block|,
literal|17
block|,
literal|19
block|,
literal|18
block|,
literal|33
block|,
literal|19
block|,
literal|26
block|,
comment|/*  32 -  39 */
literal|20
block|,
literal|25
block|,
literal|21
block|,
literal|40
block|,
literal|22
block|,
literal|27
block|,
literal|23
block|,
literal|44
block|,
comment|/*  40 -  47 */
literal|24
block|,
literal|32
block|,
literal|25
block|,
literal|34
block|,
literal|26
block|,
literal|29
block|,
literal|27
block|,
literal|44
block|,
comment|/*  48 -  55 */
literal|28
block|,
literal|31
block|,
literal|29
block|,
literal|34
block|,
literal|30
block|,
literal|60
block|,
literal|31
block|,
literal|36
block|,
comment|/*  56 -  63 */
literal|32
block|,
literal|64
block|,
literal|33
block|,
literal|34
block|,
literal|34
block|,
literal|46
block|,
literal|35
block|,
literal|37
block|,
comment|/*  64 -  71 */
literal|36
block|,
literal|65
block|,
literal|37
block|,
literal|50
block|,
literal|38
block|,
literal|48
block|,
literal|39
block|,
literal|69
block|,
comment|/*  72 -  79 */
literal|40
block|,
literal|49
block|,
literal|41
block|,
literal|43
block|,
literal|42
block|,
literal|51
block|,
literal|43
block|,
literal|58
block|,
comment|/*  80 -  87 */
literal|44
block|,
literal|64
block|,
literal|45
block|,
literal|47
block|,
literal|46
block|,
literal|59
block|,
literal|47
block|,
literal|76
block|,
comment|/*  88 -  95 */
literal|48
block|,
literal|65
block|,
literal|49
block|,
literal|66
block|,
literal|50
block|,
literal|67
block|,
literal|51
block|,
literal|66
block|,
comment|/*  96 - 103 */
literal|52
block|,
literal|70
block|,
literal|53
block|,
literal|74
block|,
literal|54
block|,
literal|104
block|,
literal|55
block|,
literal|74
block|,
comment|/* 104 - 111 */
literal|56
block|,
literal|64
block|,
literal|57
block|,
literal|69
block|,
literal|58
block|,
literal|78
block|,
literal|59
block|,
literal|68
block|,
comment|/* 112 - 119 */
literal|60
block|,
literal|61
block|,
literal|61
block|,
literal|80
block|,
literal|62
block|,
literal|75
block|,
literal|63
block|,
literal|68
block|,
comment|/* 120 - 127 */
literal|64
block|,
literal|65
block|,
literal|65
block|,
literal|128
block|,
literal|66
block|,
literal|129
block|,
literal|67
block|,
literal|90
block|,
comment|/* 128 - 135 */
literal|68
block|,
literal|73
block|,
literal|69
block|,
literal|131
block|,
literal|70
block|,
literal|94
block|,
literal|71
block|,
literal|88
block|,
comment|/* 136 - 143 */
literal|72
block|,
literal|128
block|,
literal|73
block|,
literal|98
block|,
literal|74
block|,
literal|132
block|,
literal|75
block|,
literal|121
block|,
comment|/* 144 - 151 */
literal|76
block|,
literal|102
block|,
literal|77
block|,
literal|124
block|,
literal|78
block|,
literal|132
block|,
literal|79
block|,
literal|106
block|,
comment|/* 152 - 159 */
literal|80
block|,
literal|97
block|,
literal|81
block|,
literal|160
block|,
literal|82
block|,
literal|99
block|,
literal|83
block|,
literal|134
block|,
comment|/* 160 - 167 */
literal|84
block|,
literal|86
block|,
literal|85
block|,
literal|95
block|,
literal|86
block|,
literal|160
block|,
literal|87
block|,
literal|100
block|,
comment|/* 168 - 175 */
literal|88
block|,
literal|113
block|,
literal|89
block|,
literal|98
block|,
literal|90
block|,
literal|107
block|,
literal|91
block|,
literal|122
block|,
comment|/* 176 - 183 */
literal|92
block|,
literal|111
block|,
literal|93
block|,
literal|102
block|,
literal|94
block|,
literal|126
block|,
literal|95
block|,
literal|150
block|,
comment|/* 184 - 191 */
literal|96
block|,
literal|128
block|,
literal|97
block|,
literal|130
block|,
literal|98
block|,
literal|133
block|,
literal|99
block|,
literal|195
block|,
comment|/* 192 - 199 */
literal|100
block|,
literal|128
block|,
literal|101
block|,
literal|123
block|,
literal|102
block|,
literal|164
block|,
literal|103
block|,
literal|138
block|,
comment|/* 200 - 207 */
literal|104
block|,
literal|145
block|,
literal|105
block|,
literal|146
block|,
literal|106
block|,
literal|109
block|,
literal|107
block|,
literal|149
block|,
comment|/* 208 - 215 */
literal|108
block|,
literal|200
block|,
literal|109
block|,
literal|146
block|,
literal|110
block|,
literal|170
block|,
literal|111
block|,
literal|157
block|,
comment|/* 216 - 223 */
literal|112
block|,
literal|128
block|,
literal|113
block|,
literal|130
block|,
literal|114
block|,
literal|182
block|,
literal|115
block|,
literal|132
block|,
comment|/* 224 - 231 */
literal|116
block|,
literal|200
block|,
literal|117
block|,
literal|132
block|,
literal|118
block|,
literal|158
block|,
literal|119
block|,
literal|206
block|,
comment|/* 232 - 239 */
literal|120
block|,
literal|240
block|,
literal|121
block|,
literal|162
block|,
literal|122
block|,
literal|147
block|,
literal|123
block|,
literal|152
block|,
comment|/* 240 - 247 */
literal|124
block|,
literal|166
block|,
literal|125
block|,
literal|214
block|,
literal|126
block|,
literal|138
block|,
literal|127
block|,
literal|153
block|,
comment|/* 248 - 255 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the number of multiplications required to calculate    powi(x,n) where n is less than POWI_TABLE_SIZE.  This is a    subroutine of powi_cost.  CACHE is an array indicating    which exponents have already been calculated.  */
end_comment

begin_function
specifier|static
name|int
name|powi_lookup_cost
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|n
parameter_list|,
name|bool
modifier|*
name|cache
parameter_list|)
block|{
comment|/* If we've already calculated this exponent, then this evaluation      doesn't require any additional multiplications.  */
if|if
condition|(
name|cache
index|[
name|n
index|]
condition|)
return|return
literal|0
return|;
name|cache
index|[
name|n
index|]
operator|=
name|true
expr_stmt|;
return|return
name|powi_lookup_cost
argument_list|(
name|n
operator|-
name|powi_table
index|[
name|n
index|]
argument_list|,
name|cache
argument_list|)
operator|+
name|powi_lookup_cost
argument_list|(
name|powi_table
index|[
name|n
index|]
argument_list|,
name|cache
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the number of multiplications required to calculate    powi(x,n) for an arbitrary x, given the exponent N.  This    function needs to be kept in sync with expand_powi below.  */
end_comment

begin_function
specifier|static
name|int
name|powi_cost
parameter_list|(
name|HOST_WIDE_INT
name|n
parameter_list|)
block|{
name|bool
name|cache
index|[
name|POWI_TABLE_SIZE
index|]
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|digit
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Ignore the reciprocal when calculating the cost.  */
name|val
operator|=
operator|(
name|n
operator|<
literal|0
operator|)
condition|?
operator|-
name|n
else|:
name|n
expr_stmt|;
comment|/* Initialize the exponent cache.  */
name|memset
argument_list|(
name|cache
argument_list|,
literal|0
argument_list|,
name|POWI_TABLE_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
argument_list|)
expr_stmt|;
name|cache
index|[
literal|1
index|]
operator|=
name|true
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|val
operator|>=
name|POWI_TABLE_SIZE
condition|)
block|{
if|if
condition|(
name|val
operator|&
literal|1
condition|)
block|{
name|digit
operator|=
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|POWI_WINDOW_SIZE
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|result
operator|+=
name|powi_lookup_cost
argument_list|(
name|digit
argument_list|,
name|cache
argument_list|)
operator|+
name|POWI_WINDOW_SIZE
operator|+
literal|1
expr_stmt|;
name|val
operator|>>=
name|POWI_WINDOW_SIZE
expr_stmt|;
block|}
else|else
block|{
name|val
operator|>>=
literal|1
expr_stmt|;
name|result
operator|++
expr_stmt|;
block|}
block|}
return|return
name|result
operator|+
name|powi_lookup_cost
argument_list|(
name|val
argument_list|,
name|cache
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Recursive subroutine of expand_powi.  This function takes the array,    CACHE, of already calculated exponents and an exponent N and returns    an RTX that corresponds to CACHE[1]**N, as calculated in mode MODE.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_powi_1
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|n
parameter_list|,
name|rtx
modifier|*
name|cache
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|digit
decl_stmt|;
name|rtx
name|target
decl_stmt|,
name|result
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
if|if
condition|(
name|n
operator|<
name|POWI_TABLE_SIZE
condition|)
block|{
if|if
condition|(
name|cache
index|[
name|n
index|]
condition|)
return|return
name|cache
index|[
name|n
index|]
return|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|cache
index|[
name|n
index|]
operator|=
name|target
expr_stmt|;
name|op0
operator|=
name|expand_powi_1
argument_list|(
name|mode
argument_list|,
name|n
operator|-
name|powi_table
index|[
name|n
index|]
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_powi_1
argument_list|(
name|mode
argument_list|,
name|powi_table
index|[
name|n
index|]
argument_list|,
name|cache
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|&
literal|1
condition|)
block|{
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|digit
operator|=
name|n
operator|&
operator|(
operator|(
literal|1
operator|<<
name|POWI_WINDOW_SIZE
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|op0
operator|=
name|expand_powi_1
argument_list|(
name|mode
argument_list|,
name|n
operator|-
name|digit
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_powi_1
argument_list|(
name|mode
argument_list|,
name|digit
argument_list|,
name|cache
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_powi_1
argument_list|(
name|mode
argument_list|,
name|n
operator|>>
literal|1
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
block|}
name|result
operator|=
name|expand_mult
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand the RTL to evaluate powi(x,n) in mode MODE.  X is the    floating point operand in mode MODE, and N is the exponent.  This    function needs to be kept in sync with powi_cost above.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_powi
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|HOST_WIDE_INT
name|n
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|rtx
name|cache
index|[
name|POWI_TABLE_SIZE
index|]
decl_stmt|;
name|rtx
name|result
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
return|;
name|val
operator|=
operator|(
name|n
operator|<
literal|0
operator|)
condition|?
operator|-
name|n
else|:
name|n
expr_stmt|;
name|memset
argument_list|(
name|cache
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cache
argument_list|)
argument_list|)
expr_stmt|;
name|cache
index|[
literal|1
index|]
operator|=
name|x
expr_stmt|;
name|result
operator|=
name|expand_powi_1
argument_list|(
name|mode
argument_list|,
operator|(
name|n
operator|<
literal|0
operator|)
condition|?
operator|-
name|n
else|:
name|n
argument_list|,
name|cache
argument_list|)
expr_stmt|;
comment|/* If the original exponent was negative, reciprocate the result.  */
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|result
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|sdiv_optab
argument_list|,
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
argument_list|,
name|result
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to the pow built-in mathematical function.  Return 0 if    a normal call should be emitted rather than expanding the function    in-line.  EXP is the expression that is a call to the builtin    function; if convenient, the result should be placed in TARGET.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_pow
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|cint
decl_stmt|;
name|REAL_VALUE_TYPE
name|c
decl_stmt|;
name|HOST_WIDE_INT
name|n
decl_stmt|;
name|c
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|n
operator|=
name|real_to_integer
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|real_from_integer
argument_list|(
operator|&
name|cint
argument_list|,
name|VOIDmode
argument_list|,
name|n
argument_list|,
name|n
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_identical
argument_list|(
operator|&
name|c
argument_list|,
operator|&
name|cint
argument_list|)
condition|)
block|{
comment|/* If the exponent is -1, 0, 1 or 2, then expand_powi is exact. 	     Otherwise, check the number of multiplications required. 	     Note that pow never sets errno for an integer exponent.  */
if|if
condition|(
operator|(
name|n
operator|>=
operator|-
literal|1
operator|&&
name|n
operator|<=
literal|2
operator|)
operator|||
operator|(
name|flag_unsafe_math_optimizations
operator|&&
operator|!
name|optimize_size
operator|&&
name|powi_cost
argument_list|(
name|n
argument_list|)
operator|<=
name|POWI_MAX_MULTS
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|op
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
name|expand_powi
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|n
argument_list|)
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|flag_unsafe_math_optimizations
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|expand_builtin_mathfn_2
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to the powi built-in mathematical function.  Return 0 if    a normal call should be emitted rather than expanding the function    in-line.  EXP is the expression that is a call to the builtin    function; if convenient, the result should be placed in TARGET.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_powi
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode2
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle constant power.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|n
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
comment|/* If the exponent is -1, 0, 1 or 2, then expand_powi is exact. 	 Otherwise, check the number of multiplications required.  */
if|if
condition|(
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
literal|0
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|n
operator|>=
operator|-
literal|1
operator|&&
name|n
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|!
name|optimize_size
operator|&&
name|powi_cost
argument_list|(
name|n
argument_list|)
operator|<=
name|POWI_MAX_MULTS
operator|)
operator|)
condition|)
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
return|return
name|expand_powi
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|,
name|n
argument_list|)
return|;
block|}
block|}
comment|/* Emit a libcall to libgcc.  */
comment|/* Mode of the 2nd argument must match that of an int. */
name|mode2
operator|=
name|mode_for_size
argument_list|(
name|INT_TYPE_SIZE
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL_RTX
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|subtarget
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode
condition|)
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|,
name|mode2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|mode2
condition|)
name|op1
operator|=
name|convert_to_mode
argument_list|(
name|mode2
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|target
operator|=
name|emit_library_call_value
argument_list|(
name|powi_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
argument_list|,
name|target
argument_list|,
name|LCT_CONST_MAKE_BLOCK
argument_list|,
name|mode
argument_list|,
literal|2
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|mode2
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP which is a call to the strlen builtin.  Return 0    if we failed the caller should emit a normal call, otherwise    try to get the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strlen
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|target_mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|len
decl_stmt|,
name|src
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|result
decl_stmt|,
name|src_reg
decl_stmt|,
name|char_rtx
decl_stmt|,
name|before_strlen
decl_stmt|;
name|enum
name|machine_mode
name|insn_mode
init|=
name|target_mode
decl_stmt|,
name|char_mode
decl_stmt|;
name|enum
name|insn_code
name|icode
init|=
name|CODE_FOR_nothing
decl_stmt|;
name|int
name|align
decl_stmt|;
comment|/* If the length can be computed at compile-time, return it.  */
name|len
operator|=
name|c_strlen
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
return|return
name|expand_expr
argument_list|(
name|len
argument_list|,
name|target
argument_list|,
name|target_mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
comment|/* If the length can be computed at compile-time and is constant 	 integer, but there are side-effects in src, evaluate 	 src for side-effects, then return len. 	 E.g. x = strlen (i++ ? "xfoo" + 1 : "bar"); 	 can be optimized into: i++; x = 3;  */
name|len
operator|=
name|c_strlen
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|TREE_CODE
argument_list|(
name|len
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|expand_expr
argument_list|(
name|src
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|len
argument_list|,
name|target
argument_list|,
name|target_mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
name|align
operator|=
name|get_pointer_alignment
argument_list|(
name|src
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* If SRC is not a pointer type, don't do this operation inline.  */
if|if
condition|(
name|align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Bail out if we can't compute strlen in the right mode.  */
while|while
condition|(
name|insn_mode
operator|!=
name|VOIDmode
condition|)
block|{
name|icode
operator|=
name|strlen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|insn_mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
break|break;
name|insn_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn_mode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
comment|/* Make a place to write the result of the instruction.  */
name|result
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|result
operator|!=
literal|0
operator|&&
name|REG_P
argument_list|(
name|result
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|insn_mode
operator|&&
name|REGNO
argument_list|(
name|result
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
comment|/* Make a place to hold the source address.  We will not expand 	 the actual source until we are sure that the expansion will 	 not fail -- there are trees that cannot be expanded twice.  */
name|src_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Mark the beginning of the strlen sequence so we can emit the 	 source operand later.  */
name|before_strlen
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|char_rtx
operator|=
name|const0_rtx
expr_stmt|;
name|char_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|char_rtx
operator|,
name|char_mode
operator|)
condition|)
name|char_rtx
operator|=
name|copy_to_mode_reg
argument_list|(
name|char_mode
argument_list|,
name|char_rtx
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|result
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|src_reg
argument_list|)
argument_list|,
name|char_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|align
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* Now that we are assured of success, expand the source.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|pat
operator|=
name|expand_expr
argument_list|(
name|src
argument_list|,
name|src_reg
argument_list|,
name|ptr_mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
operator|!=
name|src_reg
condition|)
name|emit_move_insn
argument_list|(
name|src_reg
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|pat
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|before_strlen
condition|)
name|emit_insn_after
argument_list|(
name|pat
argument_list|,
name|before_strlen
argument_list|)
expr_stmt|;
else|else
name|emit_insn_before
argument_list|(
name|pat
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Return the value in the proper mode for this function.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|target_mode
condition|)
name|target
operator|=
name|result
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|!=
literal|0
condition|)
name|convert_move
argument_list|(
name|target
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|target
operator|=
name|convert_to_mode
argument_list|(
name|target_mode
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to the strstr builtin.  Return 0 if we failed the    caller should emit a normal call, otherwise try to get the result    in TARGET, if convenient (and in mode MODE if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strstr
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|result
init|=
name|fold_builtin_strstr
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to the strchr builtin.  Return 0 if we failed the    caller should emit a normal call, otherwise try to get the result    in TARGET, if convenient (and in mode MODE if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strchr
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|result
init|=
name|fold_builtin_strchr
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
comment|/* FIXME: Should use strchrM optab so that ports can optimize this.  */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to the strrchr builtin.  Return 0 if we failed the    caller should emit a normal call, otherwise try to get the result    in TARGET, if convenient (and in mode MODE if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strrchr
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|result
init|=
name|fold_builtin_strrchr
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to the strpbrk builtin.  Return 0 if we failed the    caller should emit a normal call, otherwise try to get the result    in TARGET, if convenient (and in mode MODE if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strpbrk
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|result
init|=
name|fold_builtin_strpbrk
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)    bytes from constant string DATA + OFFSET and return it as target    constant.  */
end_comment

begin_function
specifier|static
name|rtx
name|builtin_memcpy_read_str
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
decl_stmt|;
name|gcc_assert
argument_list|(
name|offset
operator|>=
literal|0
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|offset
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|c_readstr
argument_list|(
name|str
operator|+
name|offset
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to the memcpy builtin, with arguments in ARGLIST.    Return 0 if we failed, the caller should emit a normal call,    otherwise try to get the result in TARGET, if convenient (and in    mode MODE if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_memcpy
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|dest
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|src
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_str
decl_stmt|;
name|unsigned
name|int
name|src_align
init|=
name|get_pointer_alignment
argument_list|(
name|src
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dest_align
init|=
name|get_pointer_alignment
argument_list|(
name|dest
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
name|rtx
name|dest_mem
decl_stmt|,
name|src_mem
decl_stmt|,
name|dest_addr
decl_stmt|,
name|len_rtx
decl_stmt|;
name|tree
name|result
init|=
name|fold_builtin_memory_op
argument_list|(
name|arglist
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|false
argument_list|,
comment|/*endp=*/
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TREE_OPERAND
argument_list|(
name|result
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If DEST is not a pointer type, call the normal function.  */
if|if
condition|(
name|dest_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If either SRC is not a pointer type, don't do this 	 operation in-line.  */
if|if
condition|(
name|src_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|dest_mem
operator|=
name|get_memory_rtx
argument_list|(
name|dest
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|dest_mem
argument_list|,
name|dest_align
argument_list|)
expr_stmt|;
name|len_rtx
operator|=
name|expand_normal
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|src_str
operator|=
name|c_getstr
argument_list|(
name|src
argument_list|)
expr_stmt|;
comment|/* If SRC is a string constant and block move would be done 	 by pieces, we can avoid loading the string from memory 	 and only stored the computed constants.  */
if|if
condition|(
name|src_str
operator|&&
name|GET_CODE
argument_list|(
name|len_rtx
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
operator|<=
name|strlen
argument_list|(
name|src_str
argument_list|)
operator|+
literal|1
operator|&&
name|can_store_by_pieces
argument_list|(
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
argument_list|,
name|builtin_memcpy_read_str
argument_list|,
operator|(
name|void
operator|*
operator|)
name|src_str
argument_list|,
name|dest_align
argument_list|)
condition|)
block|{
name|dest_mem
operator|=
name|store_by_pieces
argument_list|(
name|dest_mem
argument_list|,
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
argument_list|,
name|builtin_memcpy_read_str
argument_list|,
operator|(
name|void
operator|*
operator|)
name|src_str
argument_list|,
name|dest_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|dest_mem
argument_list|)
expr_stmt|;
return|return
name|dest_mem
return|;
block|}
name|src_mem
operator|=
name|get_memory_rtx
argument_list|(
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|src_mem
argument_list|,
name|src_align
argument_list|)
expr_stmt|;
comment|/* Copy word part most expediently.  */
name|dest_addr
operator|=
name|emit_block_move
argument_list|(
name|dest_mem
argument_list|,
name|src_mem
argument_list|,
name|len_rtx
argument_list|,
name|CALL_EXPR_TAILCALL
argument_list|(
name|exp
argument_list|)
condition|?
name|BLOCK_OP_TAILCALL
else|:
name|BLOCK_OP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_addr
operator|==
literal|0
condition|)
block|{
name|dest_addr
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|dest_addr
argument_list|)
expr_stmt|;
block|}
return|return
name|dest_addr
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to the mempcpy builtin, with arguments in ARGLIST.    Return 0 if we failed; the caller should emit a normal call,    otherwise try to get the result in TARGET, if convenient (and in    mode MODE if that's convenient).  If ENDP is 0 return the    destination pointer, if ENDP is 1 return the end pointer ala    mempcpy, and if ENDP is 2 return the end pointer minus one ala    stpcpy.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_mempcpy
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|endp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If return value is ignored, transform mempcpy into memcpy.  */
elseif|else
if|if
condition|(
name|target
operator|==
name|const0_rtx
condition|)
block|{
name|tree
name|fn
init|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_MEMCPY
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
else|else
block|{
name|tree
name|dest
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|src
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_str
decl_stmt|;
name|unsigned
name|int
name|src_align
init|=
name|get_pointer_alignment
argument_list|(
name|src
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dest_align
init|=
name|get_pointer_alignment
argument_list|(
name|dest
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
name|rtx
name|dest_mem
decl_stmt|,
name|src_mem
decl_stmt|,
name|len_rtx
decl_stmt|;
name|tree
name|result
init|=
name|fold_builtin_memory_op
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|,
name|false
argument_list|,
name|endp
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TREE_OPERAND
argument_list|(
name|result
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If either SRC or DEST is not a pointer type, don't do this 	 operation in-line.  */
if|if
condition|(
name|dest_align
operator|==
literal|0
operator|||
name|src_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If LEN is not constant, call the normal function.  */
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
name|len_rtx
operator|=
name|expand_normal
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|src_str
operator|=
name|c_getstr
argument_list|(
name|src
argument_list|)
expr_stmt|;
comment|/* If SRC is a string constant and block move would be done 	 by pieces, we can avoid loading the string from memory 	 and only stored the computed constants.  */
if|if
condition|(
name|src_str
operator|&&
name|GET_CODE
argument_list|(
name|len_rtx
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
operator|<=
name|strlen
argument_list|(
name|src_str
argument_list|)
operator|+
literal|1
operator|&&
name|can_store_by_pieces
argument_list|(
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
argument_list|,
name|builtin_memcpy_read_str
argument_list|,
operator|(
name|void
operator|*
operator|)
name|src_str
argument_list|,
name|dest_align
argument_list|)
condition|)
block|{
name|dest_mem
operator|=
name|get_memory_rtx
argument_list|(
name|dest
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|dest_mem
argument_list|,
name|dest_align
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|store_by_pieces
argument_list|(
name|dest_mem
argument_list|,
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
argument_list|,
name|builtin_memcpy_read_str
argument_list|,
operator|(
name|void
operator|*
operator|)
name|src_str
argument_list|,
name|dest_align
argument_list|,
name|endp
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|dest_mem
argument_list|)
expr_stmt|;
return|return
name|dest_mem
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|len_rtx
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|can_move_by_pieces
argument_list|(
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|dest_align
argument_list|,
name|src_align
argument_list|)
argument_list|)
condition|)
block|{
name|dest_mem
operator|=
name|get_memory_rtx
argument_list|(
name|dest
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|dest_mem
argument_list|,
name|dest_align
argument_list|)
expr_stmt|;
name|src_mem
operator|=
name|get_memory_rtx
argument_list|(
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|src_mem
argument_list|,
name|src_align
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|move_by_pieces
argument_list|(
name|dest_mem
argument_list|,
name|src_mem
argument_list|,
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|dest_align
argument_list|,
name|src_align
argument_list|)
argument_list|,
name|endp
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|dest_mem
argument_list|)
expr_stmt|;
return|return
name|dest_mem
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the memmove builtin.  Return 0    if we failed; the caller should emit a normal call.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_memmove
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|orig_exp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|dest
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|src
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|src_align
init|=
name|get_pointer_alignment
argument_list|(
name|src
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dest_align
init|=
name|get_pointer_alignment
argument_list|(
name|dest
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|fold_builtin_memory_op
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|,
name|false
argument_list|,
comment|/*endp=*/
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TREE_OPERAND
argument_list|(
name|result
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If DEST is not a pointer type, call the normal function.  */
if|if
condition|(
name|dest_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If either SRC is not a pointer type, don't do this 	 operation in-line.  */
if|if
condition|(
name|src_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If src is categorized for a readonly section we can use 	 normal memcpy.  */
if|if
condition|(
name|readonly_data_expr
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|tree
name|fn
init|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_MEMCPY
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|CALL_EXPR_TAILCALL
argument_list|(
name|fn
argument_list|)
operator|=
name|CALL_EXPR_TAILCALL
argument_list|(
name|orig_exp
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|fn
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If length is 1 and we can expand memcpy call inline, 	 it is ok to use memcpy as well.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|len
argument_list|)
condition|)
block|{
name|rtx
name|ret
init|=
name|expand_builtin_mempcpy
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
comment|/*endp=*/
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
comment|/* Otherwise, call the normal function.  */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the bcopy builtin.  Return 0    if we failed the caller should emit a normal call.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_bcopy
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|src
decl_stmt|,
name|dest
decl_stmt|,
name|size
decl_stmt|,
name|newarglist
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* New argument list transforming bcopy(ptr x, ptr y, int z) to      memmove(ptr y, ptr x, size_t z).   This is done this way      so that if it isn't expanded inline, we fallback to      calling bcopy instead of memmove.  */
name|newarglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|newarglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
name|newarglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
return|return
name|expand_builtin_memmove
argument_list|(
name|newarglist
argument_list|,
name|type
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|exp
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_movstr
end_ifndef

begin_define
define|#
directive|define
name|HAVE_movstr
value|0
end_define

begin_define
define|#
directive|define
name|CODE_FOR_movstr
value|CODE_FOR_nothing
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Expand into a movstr instruction, if one is available.  Return 0 if    we failed, the caller should emit a normal call, otherwise try to    get the result in TARGET, if convenient.  If ENDP is 0 return the    destination pointer, if ENDP is 1 return the end pointer ala    mempcpy, and if ENDP is 2 return the end pointer minus one ala    stpcpy.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_movstr
parameter_list|(
name|tree
name|dest
parameter_list|,
name|tree
name|src
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|endp
parameter_list|)
block|{
name|rtx
name|end
decl_stmt|;
name|rtx
name|dest_mem
decl_stmt|;
name|rtx
name|src_mem
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
specifier|const
name|struct
name|insn_data
modifier|*
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|HAVE_movstr
condition|)
return|return
literal|0
return|;
name|dest_mem
operator|=
name|get_memory_rtx
argument_list|(
name|dest
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|src_mem
operator|=
name|get_memory_rtx
argument_list|(
name|src
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|endp
condition|)
block|{
name|target
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|replace_equiv_address
argument_list|(
name|dest_mem
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|end
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|target
operator|==
name|const0_rtx
condition|)
block|{
name|end
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|end
expr_stmt|;
block|}
else|else
name|end
operator|=
name|target
expr_stmt|;
block|}
name|data
operator|=
name|insn_data
operator|+
name|CODE_FOR_movstr
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|!=
name|VOIDmode
condition|)
name|end
operator|=
name|gen_lowpart
argument_list|(
name|data
operator|->
name|operand
index|[
literal|0
index|]
operator|.
name|mode
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|insn
operator|=
name|data
operator|->
name|genfun
argument_list|(
name|end
argument_list|,
name|dest_mem
argument_list|,
name|src_mem
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* movstr is supposed to set end to the address of the NUL      terminator.  If the caller requested a mempcpy-like return value,      adjust it.  */
if|if
condition|(
name|endp
operator|==
literal|1
operator|&&
name|target
operator|!=
name|const0_rtx
condition|)
block|{
name|rtx
name|tem
init|=
name|plus_constant
argument_list|(
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|end
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|force_operand
argument_list|(
name|tem
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strcpy builtin.  Return 0    if we failed the caller should emit a normal call, otherwise try to get    the result in TARGET, if convenient (and in mode MODE if that's    convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strcpy
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|result
init|=
name|fold_builtin_strcpy
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TREE_OPERAND
argument_list|(
name|result
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
return|return
name|expand_movstr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
comment|/*endp=*/
literal|0
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to the stpcpy builtin, with arguments in ARGLIST.    Return 0 if we failed the caller should emit a normal call,    otherwise try to get the result in TARGET, if convenient (and in    mode MODE if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_stpcpy
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* If return value is ignored, transform stpcpy into strcpy.  */
if|if
condition|(
name|target
operator|==
name|const0_rtx
condition|)
block|{
name|tree
name|fn
init|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRCPY
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|dst
decl_stmt|,
name|src
decl_stmt|,
name|len
decl_stmt|,
name|lenp1
decl_stmt|;
name|tree
name|narglist
decl_stmt|;
name|rtx
name|ret
decl_stmt|;
comment|/* Ensure we get an actual string whose length can be evaluated at 	 compile-time, not an expression containing a string.  This is 	 because the latter will potentially produce pessimized code 	 when used to produce the return value.  */
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_getstr
argument_list|(
name|src
argument_list|)
operator|||
operator|!
operator|(
name|len
operator|=
name|c_strlen
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|expand_movstr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
comment|/*endp=*/
literal|2
argument_list|)
return|;
name|dst
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|lenp1
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|len
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|narglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|lenp1
argument_list|)
expr_stmt|;
name|narglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|,
name|narglist
argument_list|)
expr_stmt|;
name|narglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dst
argument_list|,
name|narglist
argument_list|)
expr_stmt|;
name|ret
operator|=
name|expand_builtin_mempcpy
argument_list|(
name|narglist
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
comment|/*endp=*/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|len
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|rtx
name|len_rtx
init|=
name|expand_normal
argument_list|(
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|len_rtx
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|ret
operator|=
name|expand_builtin_strcpy
argument_list|(
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
operator|!
name|target
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|ret
argument_list|)
condition|)
name|ret
operator|=
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|plus_constant
argument_list|(
name|ret
argument_list|,
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|force_operand
argument_list|(
name|ret
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
block|}
block|}
return|return
name|expand_movstr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
comment|/*endp=*/
literal|2
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)    bytes from constant string DATA + OFFSET and return it as target    constant.  */
end_comment

begin_function
specifier|static
name|rtx
name|builtin_strncpy_read_str
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|offset
operator|>
name|strlen
argument_list|(
name|str
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
return|return
name|c_readstr
argument_list|(
name|str
operator|+
name|offset
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strncpy builtin.  Return 0    if we failed the caller should emit a normal call.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strncpy
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|slen
init|=
name|c_strlen
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|fold_builtin_strncpy
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|slen
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|result
operator|=
name|TREE_OPERAND
argument_list|(
name|result
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* We must be passed a constant len and src parameter.  */
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|slen
operator|||
operator|!
name|host_integerp
argument_list|(
name|slen
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
name|slen
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|slen
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We're required to pad with trailing zeros if the requested 	 len is greater than strlen(s2)+1.  In that case try to 	 use store_by_pieces, if it fails, punt.  */
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|slen
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|tree
name|dest
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dest_align
init|=
name|get_pointer_alignment
argument_list|(
name|dest
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|c_getstr
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|dest_mem
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
name|dest_align
operator|==
literal|0
operator|||
operator|!
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|can_store_by_pieces
argument_list|(
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|,
name|builtin_strncpy_read_str
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p
argument_list|,
name|dest_align
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest_mem
operator|=
name|get_memory_rtx
argument_list|(
name|dest
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|store_by_pieces
argument_list|(
name|dest_mem
argument_list|,
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|,
name|builtin_strncpy_read_str
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p
argument_list|,
name|dest_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|dest_mem
argument_list|)
expr_stmt|;
return|return
name|dest_mem
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)    bytes from constant string DATA + OFFSET and return it as target    constant.  */
end_comment

begin_function
specifier|static
name|rtx
name|builtin_memset_read_str
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|HOST_WIDE_INT
name|offset
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|alloca
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
operator|*
name|c
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|c_readstr
argument_list|(
name|p
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Callback routine for store_by_pieces.  Return the RTL of a register    containing GET_MODE_SIZE (MODE) consecutive copies of the unsigned    char value given in the RTL register data.  For example, if mode is    4 bytes wide, return the RTL for 0x01010101*data.  */
end_comment

begin_function
specifier|static
name|rtx
name|builtin_memset_gen_str
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|HOST_WIDE_INT
name|offset
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|target
decl_stmt|,
name|coeff
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
condition|)
return|return
operator|(
name|rtx
operator|)
name|data
return|;
name|p
operator|=
name|alloca
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|coeff
operator|=
name|c_readstr
argument_list|(
name|p
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|target
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
operator|(
name|rtx
operator|)
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_mult
argument_list|(
name|mode
argument_list|,
name|target
argument_list|,
name|coeff
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|force_reg
argument_list|(
name|mode
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the memset builtin.  Return 0    if we failed the caller should emit a normal call, otherwise try to get    the result in TARGET, if convenient (and in mode MODE if that's    convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_memset
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|orig_exp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|dest
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fndecl
decl_stmt|,
name|fn
decl_stmt|;
name|enum
name|built_in_function
name|fcode
decl_stmt|;
name|char
name|c
decl_stmt|;
name|unsigned
name|int
name|dest_align
decl_stmt|;
name|rtx
name|dest_mem
decl_stmt|,
name|dest_addr
decl_stmt|,
name|len_rtx
decl_stmt|;
name|dest_align
operator|=
name|get_pointer_alignment
argument_list|(
name|dest
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
comment|/* If DEST is not a pointer type, don't do this 	 operation in-line.  */
if|if
condition|(
name|dest_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If the LEN parameter is zero, return DEST.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
condition|)
block|{
comment|/* Evaluate and ignore VAL in case it has side-effects.  */
name|expand_expr
argument_list|(
name|val
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|dest
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* Stabilize the arguments in case we fail.  */
name|dest
operator|=
name|builtin_save_expr
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|val
operator|=
name|builtin_save_expr
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|len
operator|=
name|builtin_save_expr
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|len_rtx
operator|=
name|expand_normal
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|get_memory_rtx
argument_list|(
name|dest
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|rtx
name|val_rtx
decl_stmt|;
name|val_rtx
operator|=
name|expand_normal
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val_rtx
operator|=
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|unsigned_char_type_node
argument_list|)
argument_list|,
name|val_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Assume that we can memset by pieces if we can store the 	   * the coefficients by pieces (in the required modes). 	   * We can't pass builtin_memset_gen_str as that emits RTL.  */
name|c
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
operator|(
name|optimize_size
operator|&&
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|>
literal|1
operator|)
operator|&&
name|can_store_by_pieces
argument_list|(
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|,
name|builtin_memset_read_str
argument_list|,
operator|&
name|c
argument_list|,
name|dest_align
argument_list|)
condition|)
block|{
name|val_rtx
operator|=
name|force_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|unsigned_char_type_node
argument_list|)
argument_list|,
name|val_rtx
argument_list|)
expr_stmt|;
name|store_by_pieces
argument_list|(
name|dest_mem
argument_list|,
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|,
name|builtin_memset_gen_str
argument_list|,
name|val_rtx
argument_list|,
name|dest_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|set_storage_via_setmem
argument_list|(
name|dest_mem
argument_list|,
name|len_rtx
argument_list|,
name|val_rtx
argument_list|,
name|dest_align
argument_list|)
condition|)
goto|goto
name|do_libcall
goto|;
name|dest_mem
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|dest_mem
argument_list|)
expr_stmt|;
return|return
name|dest_mem
return|;
block|}
if|if
condition|(
name|target_char_cast
argument_list|(
name|val
argument_list|,
operator|&
name|c
argument_list|)
condition|)
goto|goto
name|do_libcall
goto|;
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
operator|(
name|optimize_size
operator|&&
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|>
literal|1
operator|)
operator|&&
name|can_store_by_pieces
argument_list|(
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|,
name|builtin_memset_read_str
argument_list|,
operator|&
name|c
argument_list|,
name|dest_align
argument_list|)
condition|)
name|store_by_pieces
argument_list|(
name|dest_mem
argument_list|,
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|,
name|builtin_memset_read_str
argument_list|,
operator|&
name|c
argument_list|,
name|dest_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|set_storage_via_setmem
argument_list|(
name|dest_mem
argument_list|,
name|len_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|c
argument_list|)
argument_list|,
name|dest_align
argument_list|)
condition|)
goto|goto
name|do_libcall
goto|;
name|dest_mem
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|dest_mem
argument_list|)
expr_stmt|;
return|return
name|dest_mem
return|;
block|}
name|set_mem_align
argument_list|(
name|dest_mem
argument_list|,
name|dest_align
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|clear_storage
argument_list|(
name|dest_mem
argument_list|,
name|len_rtx
argument_list|,
name|CALL_EXPR_TAILCALL
argument_list|(
name|orig_exp
argument_list|)
condition|?
name|BLOCK_OP_TAILCALL
else|:
name|BLOCK_OP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_addr
operator|==
literal|0
condition|)
block|{
name|dest_addr
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|dest_addr
argument_list|)
expr_stmt|;
block|}
return|return
name|dest_addr
return|;
name|do_libcall
label|:
name|fndecl
operator|=
name|get_callee_fndecl
argument_list|(
name|orig_exp
argument_list|)
expr_stmt|;
name|fcode
operator|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|fcode
operator|==
name|BUILT_IN_MEMSET
operator|||
name|fcode
operator|==
name|BUILT_IN_BZERO
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_MEMSET
condition|)
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|val
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|CALL_EXPR_TAILCALL
argument_list|(
name|fn
argument_list|)
operator|=
name|CALL_EXPR_TAILCALL
argument_list|(
name|orig_exp
argument_list|)
expr_stmt|;
return|return
name|expand_call
argument_list|(
name|fn
argument_list|,
name|target
argument_list|,
name|target
operator|==
name|const0_rtx
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the bzero builtin.  Return 0    if we failed the caller should emit a normal call.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_bzero
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|dest
decl_stmt|,
name|size
decl_stmt|,
name|newarglist
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|size
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* New argument list transforming bzero(ptr x, int y) to      memset(ptr x, int 0, size_t y).   This is done this way      so that if it isn't expanded inline, we fallback to      calling bzero instead of memset.  */
name|newarglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|newarglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
name|newarglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
return|return
name|expand_builtin_memset
argument_list|(
name|newarglist
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|exp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the memcmp built-in function.    ARGLIST is the argument list for this call.  Return 0 if we failed and the    caller should emit a normal call, otherwise try to get the result in    TARGET, if convenient (and in mode MODE, if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_memcmp
parameter_list|(
name|tree
name|exp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|result
init|=
name|fold_builtin_memcmp
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
if|#
directive|if
name|defined
name|HAVE_cmpmemsi
operator|||
name|defined
name|HAVE_cmpstrnsi
block|{
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|arg1_rtx
decl_stmt|,
name|arg2_rtx
decl_stmt|,
name|arg3_rtx
decl_stmt|;
name|rtx
name|result
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|arg1_align
init|=
name|get_pointer_alignment
argument_list|(
name|arg1
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|arg2_align
init|=
name|get_pointer_alignment
argument_list|(
name|arg2
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|enum
name|machine_mode
name|insn_mode
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cmpmemsi
if|if
condition|(
name|HAVE_cmpmemsi
condition|)
name|insn_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_cmpmemsi
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpstrnsi
if|if
condition|(
name|HAVE_cmpstrnsi
condition|)
name|insn_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_cmpstrnsi
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
else|else
endif|#
directive|endif
return|return
literal|0
return|;
comment|/* If we don't have POINTER_TYPE, call the function.  */
if|if
condition|(
name|arg1_align
operator|==
literal|0
operator|||
name|arg2_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Make a place to write the result of the instruction.  */
name|result
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|result
operator|!=
literal|0
operator|&&
name|REG_P
argument_list|(
name|result
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|insn_mode
operator|&&
name|REGNO
argument_list|(
name|result
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
name|arg1_rtx
operator|=
name|get_memory_rtx
argument_list|(
name|arg1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|arg2_rtx
operator|=
name|get_memory_rtx
argument_list|(
name|arg2
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|arg3_rtx
operator|=
name|expand_normal
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* Set MEM_SIZE as appropriate.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg3_rtx
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|set_mem_size
argument_list|(
name|arg1_rtx
argument_list|,
name|arg3_rtx
argument_list|)
expr_stmt|;
name|set_mem_size
argument_list|(
name|arg2_rtx
argument_list|,
name|arg3_rtx
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_cmpmemsi
if|if
condition|(
name|HAVE_cmpmemsi
condition|)
name|insn
operator|=
name|gen_cmpmemsi
argument_list|(
name|result
argument_list|,
name|arg1_rtx
argument_list|,
name|arg2_rtx
argument_list|,
name|arg3_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|MIN
argument_list|(
name|arg1_align
argument_list|,
name|arg2_align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpstrnsi
if|if
condition|(
name|HAVE_cmpstrnsi
condition|)
name|insn
operator|=
name|gen_cmpstrnsi
argument_list|(
name|result
argument_list|,
name|arg1_rtx
argument_list|,
name|arg2_rtx
argument_list|,
name|arg3_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|MIN
argument_list|(
name|arg1_align
argument_list|,
name|arg2_align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|gcc_unreachable
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn
condition|)
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|emit_library_call_value
argument_list|(
name|memcmp_libfunc
argument_list|,
name|result
argument_list|,
name|LCT_PURE_MAKE_BLOCK
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|arg1_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|arg2_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|arg3_rtx
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the value in the proper mode for this function.  */
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|mode
condition|)
return|return
name|result
return|;
elseif|else
if|if
condition|(
name|target
operator|!=
literal|0
condition|)
block|{
name|convert_move
argument_list|(
name|target
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strcmp builtin.  Return 0    if we failed the caller should emit a normal call, otherwise try to get    the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strcmp
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|result
init|=
name|fold_builtin_strcmp
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
if|#
directive|if
name|defined
name|HAVE_cmpstrsi
operator|||
name|defined
name|HAVE_cmpstrnsi
if|if
condition|(
name|cmpstr_optab
index|[
name|SImode
index|]
operator|!=
name|CODE_FOR_nothing
operator|||
name|cmpstrn_optab
index|[
name|SImode
index|]
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|arg1_rtx
decl_stmt|,
name|arg2_rtx
decl_stmt|;
name|rtx
name|result
decl_stmt|,
name|insn
init|=
name|NULL_RTX
decl_stmt|;
name|tree
name|fndecl
decl_stmt|,
name|fn
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|arg1_align
init|=
name|get_pointer_alignment
argument_list|(
name|arg1
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|arg2_align
init|=
name|get_pointer_alignment
argument_list|(
name|arg2
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
comment|/* If we don't have POINTER_TYPE, call the function.  */
if|if
condition|(
name|arg1_align
operator|==
literal|0
operator|||
name|arg2_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Stabilize the arguments in case gen_cmpstr(n)si fail.  */
name|arg1
operator|=
name|builtin_save_expr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|builtin_save_expr
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|arg1_rtx
operator|=
name|get_memory_rtx
argument_list|(
name|arg1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|arg2_rtx
operator|=
name|get_memory_rtx
argument_list|(
name|arg2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cmpstrsi
comment|/* Try to call cmpstrsi.  */
if|if
condition|(
name|HAVE_cmpstrsi
condition|)
block|{
name|enum
name|machine_mode
name|insn_mode
init|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_cmpstrsi
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
comment|/* Make a place to write the result of the instruction.  */
name|result
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|result
operator|!=
literal|0
operator|&&
name|REG_P
argument_list|(
name|result
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|insn_mode
operator|&&
name|REGNO
argument_list|(
name|result
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_cmpstrsi
argument_list|(
name|result
argument_list|,
name|arg1_rtx
argument_list|,
name|arg2_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|MIN
argument_list|(
name|arg1_align
argument_list|,
name|arg2_align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpstrnsi
comment|/* Try to determine at least one length and call cmpstrnsi.  */
if|if
condition|(
operator|!
name|insn
operator|&&
name|HAVE_cmpstrnsi
condition|)
block|{
name|tree
name|len
decl_stmt|;
name|rtx
name|arg3_rtx
decl_stmt|;
name|enum
name|machine_mode
name|insn_mode
init|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_cmpstrnsi
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|tree
name|len1
init|=
name|c_strlen
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|len2
init|=
name|c_strlen
argument_list|(
name|arg2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|len1
condition|)
name|len1
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|,
name|len1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len2
condition|)
name|len2
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|,
name|len2
argument_list|)
expr_stmt|;
comment|/* If we don't have a constant length for the first, use the length 	     of the second, if we know it.  We don't require a constant for 	     this case; some cost analysis could be done if both are available 	     but neither is constant.  For now, assume they're equally cheap, 	     unless one has side effects.  If both strings have constant lengths, 	     use the smaller.  */
if|if
condition|(
operator|!
name|len1
condition|)
name|len
operator|=
name|len2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|len2
condition|)
name|len
operator|=
name|len1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|len1
argument_list|)
condition|)
name|len
operator|=
name|len2
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|len2
argument_list|)
condition|)
name|len
operator|=
name|len1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|len1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|len
operator|=
name|len2
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|len2
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|len
operator|=
name|len1
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|len1
argument_list|,
name|len2
argument_list|)
condition|)
name|len
operator|=
name|len1
expr_stmt|;
else|else
name|len
operator|=
name|len2
expr_stmt|;
comment|/* If both arguments have side effects, we cannot optimize.  */
if|if
condition|(
operator|!
name|len
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|len
argument_list|)
condition|)
goto|goto
name|do_libcall
goto|;
name|arg3_rtx
operator|=
name|expand_normal
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* Make a place to write the result of the instruction.  */
name|result
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|result
operator|!=
literal|0
operator|&&
name|REG_P
argument_list|(
name|result
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|insn_mode
operator|&&
name|REGNO
argument_list|(
name|result
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_cmpstrnsi
argument_list|(
name|result
argument_list|,
name|arg1_rtx
argument_list|,
name|arg2_rtx
argument_list|,
name|arg3_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|MIN
argument_list|(
name|arg1_align
argument_list|,
name|arg2_align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|insn
condition|)
block|{
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Return the value in the proper mode for this function.  */
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|mode
condition|)
return|return
name|result
return|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
return|return
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
return|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* Expand the library call ourselves using a stabilized argument 	 list to avoid re-evaluating the function's arguments twice.  */
ifdef|#
directive|ifdef
name|HAVE_cmpstrnsi
name|do_libcall
label|:
endif|#
directive|endif
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|CALL_EXPR_TAILCALL
argument_list|(
name|fn
argument_list|)
operator|=
name|CALL_EXPR_TAILCALL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|expand_call
argument_list|(
name|fn
argument_list|,
name|target
argument_list|,
name|target
operator|==
name|const0_rtx
argument_list|)
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strncmp builtin.  Return 0    if we failed the caller should emit a normal call, otherwise try to get    the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strncmp
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|result
init|=
name|fold_builtin_strncmp
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If c_strlen can determine an expression for one of the string      lengths, and it doesn't have side effects, then emit cmpstrnsi      using length MIN(strlen(string)+1, arg3).  */
ifdef|#
directive|ifdef
name|HAVE_cmpstrnsi
if|if
condition|(
name|HAVE_cmpstrnsi
condition|)
block|{
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg3
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
decl_stmt|,
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|rtx
name|arg1_rtx
decl_stmt|,
name|arg2_rtx
decl_stmt|,
name|arg3_rtx
decl_stmt|;
name|rtx
name|result
decl_stmt|,
name|insn
decl_stmt|;
name|tree
name|fndecl
decl_stmt|,
name|fn
decl_stmt|;
name|int
name|arg1_align
init|=
name|get_pointer_alignment
argument_list|(
name|arg1
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|arg2_align
init|=
name|get_pointer_alignment
argument_list|(
name|arg2
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|enum
name|machine_mode
name|insn_mode
init|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_cmpstrnsi
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|len1
operator|=
name|c_strlen
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|len2
operator|=
name|c_strlen
argument_list|(
name|arg2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len1
condition|)
name|len1
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|,
name|len1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len2
condition|)
name|len2
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|,
name|len2
argument_list|)
expr_stmt|;
comment|/* If we don't have a constant length for the first, use the length        of the second, if we know it.  We don't require a constant for        this case; some cost analysis could be done if both are available        but neither is constant.  For now, assume they're equally cheap,        unless one has side effects.  If both strings have constant lengths,        use the smaller.  */
if|if
condition|(
operator|!
name|len1
condition|)
name|len
operator|=
name|len2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|len2
condition|)
name|len
operator|=
name|len1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|len1
argument_list|)
condition|)
name|len
operator|=
name|len2
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|len2
argument_list|)
condition|)
name|len
operator|=
name|len1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|len1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|len
operator|=
name|len2
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|len2
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|len
operator|=
name|len1
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|len1
argument_list|,
name|len2
argument_list|)
condition|)
name|len
operator|=
name|len1
expr_stmt|;
else|else
name|len
operator|=
name|len2
expr_stmt|;
comment|/* If both arguments have side effects, we cannot optimize.  */
if|if
condition|(
operator|!
name|len
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* The actual new length parameter is MIN(len,arg3).  */
name|len
operator|=
name|fold_build2
argument_list|(
name|MIN_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|len
argument_list|)
argument_list|,
name|len
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|len
argument_list|)
argument_list|,
name|arg3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we don't have POINTER_TYPE, call the function.  */
if|if
condition|(
name|arg1_align
operator|==
literal|0
operator|||
name|arg2_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Make a place to write the result of the instruction.  */
name|result
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|result
operator|!=
literal|0
operator|&&
name|REG_P
argument_list|(
name|result
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|insn_mode
operator|&&
name|REGNO
argument_list|(
name|result
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
comment|/* Stabilize the arguments in case gen_cmpstrnsi fails.  */
name|arg1
operator|=
name|builtin_save_expr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|builtin_save_expr
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|len
operator|=
name|builtin_save_expr
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|arg1_rtx
operator|=
name|get_memory_rtx
argument_list|(
name|arg1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|arg2_rtx
operator|=
name|get_memory_rtx
argument_list|(
name|arg2
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|arg3_rtx
operator|=
name|expand_normal
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_cmpstrnsi
argument_list|(
name|result
argument_list|,
name|arg1_rtx
argument_list|,
name|arg2_rtx
argument_list|,
name|arg3_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|MIN
argument_list|(
name|arg1_align
argument_list|,
name|arg2_align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
block|{
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Return the value in the proper mode for this function.  */
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|mode
condition|)
return|return
name|result
return|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
return|return
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
return|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* Expand the library call ourselves using a stabilized argument        list to avoid re-evaluating the function's arguments twice.  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|CALL_EXPR_TAILCALL
argument_list|(
name|fn
argument_list|)
operator|=
name|CALL_EXPR_TAILCALL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|expand_call
argument_list|(
name|fn
argument_list|,
name|target
argument_list|,
name|target
operator|==
name|const0_rtx
argument_list|)
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strcat builtin.    Return 0 if we failed the caller should emit a normal call,    otherwise try to get the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strcat
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|dst
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|src
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|c_getstr
argument_list|(
name|src
argument_list|)
decl_stmt|;
comment|/* If the string length is zero, return the dst parameter.  */
if|if
condition|(
name|p
operator|&&
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|expand_expr
argument_list|(
name|dst
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
if|if
condition|(
operator|!
name|optimize_size
condition|)
block|{
comment|/* See if we can store by pieces into (dst + strlen(dst)).  */
name|tree
name|newsrc
decl_stmt|,
name|newdst
decl_stmt|,
name|strlen_fn
init|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRLEN
index|]
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
comment|/* Stabilize the argument list.  */
name|newsrc
operator|=
name|builtin_save_expr
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsrc
operator|!=
name|src
condition|)
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|newsrc
argument_list|)
expr_stmt|;
else|else
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* Reusing arglist if safe.  */
name|dst
operator|=
name|builtin_save_expr
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Create strlen (dst).  */
name|newdst
operator|=
name|build_function_call_expr
argument_list|(
name|strlen_fn
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create (dst + (cast) strlen (dst)).  */
name|newdst
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|newdst
argument_list|)
expr_stmt|;
name|newdst
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|dst
argument_list|,
name|newdst
argument_list|)
expr_stmt|;
name|newdst
operator|=
name|builtin_save_expr
argument_list|(
name|newdst
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|newdst
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand_builtin_strcpy
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Stop sequence.  */
return|return
literal|0
return|;
block|}
comment|/* Output the entire sequence.  */
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|insns
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|dst
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strncat builtin.    Return 0 if we failed the caller should emit a normal call,    otherwise try to get the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strncat
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|result
init|=
name|fold_builtin_strncat
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strspn builtin.    Return 0 if we failed the caller should emit a normal call,    otherwise try to get the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strspn
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|result
init|=
name|fold_builtin_strspn
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strcspn builtin.    Return 0 if we failed the caller should emit a normal call,    otherwise try to get the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strcspn
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|result
init|=
name|fold_builtin_strcspn
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to __builtin_saveregs, generating the result in TARGET,    if that's convenient.  */
end_comment

begin_function
name|rtx
name|expand_builtin_saveregs
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|val
decl_stmt|,
name|seq
decl_stmt|;
comment|/* Don't do __builtin_saveregs more than once in a function.      Save the result of the first call and reuse it.  */
if|if
condition|(
name|saveregs_value
operator|!=
literal|0
condition|)
return|return
name|saveregs_value
return|;
comment|/* When this function is called, it means that registers must be      saved on entry to this function.  So we migrate the call to the      first insn of this function.  */
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Do whatever the machine needs done in this case.  */
name|val
operator|=
name|targetm
operator|.
name|calls
operator|.
name|expand_builtin_saveregs
argument_list|()
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|saveregs_value
operator|=
name|val
expr_stmt|;
comment|/* Put the insns after the NOTE that starts the function.  If this      is inside a start_sequence, make the outer-level insn chain current, so      the code is placed at the start of the function.  */
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|entry_of_function
argument_list|()
argument_list|)
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* __builtin_args_info (N) returns word N of the arg space info    for the current function.  The number and meanings of words    is controlled by the definition of CUMULATIVE_ARGS.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_args_info
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|int
name|nwords
init|=
sizeof|sizeof
argument_list|(
name|CUMULATIVE_ARGS
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
name|int
modifier|*
name|word_ptr
init|=
operator|(
name|int
operator|*
operator|)
operator|&
name|current_function_args_info
decl_stmt|;
name|gcc_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|CUMULATIVE_ARGS
argument_list|)
operator|%
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|error
argument_list|(
literal|"argument of %<__builtin_args_info%> must be constant"
argument_list|)
expr_stmt|;
else|else
block|{
name|HOST_WIDE_INT
name|wordnum
init|=
name|tree_low_cst
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|wordnum
operator|<
literal|0
operator|||
name|wordnum
operator|>=
name|nwords
condition|)
name|error
argument_list|(
literal|"argument of %<__builtin_args_info%> out of range"
argument_list|)
expr_stmt|;
else|else
return|return
name|GEN_INT
argument_list|(
name|word_ptr
index|[
name|wordnum
index|]
argument_list|)
return|;
block|}
block|}
else|else
name|error
argument_list|(
literal|"missing argument in %<__builtin_args_info%>"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to __builtin_next_arg.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_next_arg
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Checking arguments is already done in fold_builtin_next_arg      that must be called before this function.  */
return|return
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|current_function_internal_arg_pointer
argument_list|,
name|current_function_arg_offset_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make it easier for the backends by protecting the valist argument    from multiple evaluations.  */
end_comment

begin_function
specifier|static
name|tree
name|stabilize_va_list
parameter_list|(
name|tree
name|valist
parameter_list|,
name|int
name|needs_lvalue
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|va_list_type_node
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|valist
argument_list|)
condition|)
name|valist
operator|=
name|save_expr
argument_list|(
name|valist
argument_list|)
expr_stmt|;
comment|/* For this case, the backends will be expecting a pointer to 	 TREE_TYPE (va_list_type_node), but it's possible we've 	 actually been given an array (an actual va_list_type_node). 	 So fix it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|p1
init|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
decl_stmt|;
name|valist
operator|=
name|build_fold_addr_expr_with_type
argument_list|(
name|valist
argument_list|,
name|p1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|pt
decl_stmt|;
if|if
condition|(
operator|!
name|needs_lvalue
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|valist
argument_list|)
condition|)
return|return
name|valist
return|;
name|pt
operator|=
name|build_pointer_type
argument_list|(
name|va_list_type_node
argument_list|)
expr_stmt|;
name|valist
operator|=
name|fold_build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|pt
argument_list|,
name|valist
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|valist
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|valist
argument_list|)
condition|)
name|valist
operator|=
name|save_expr
argument_list|(
name|valist
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build_fold_indirect_ref
argument_list|(
name|valist
argument_list|)
expr_stmt|;
block|}
return|return
name|valist
return|;
block|}
end_function

begin_comment
comment|/* The "standard" definition of va_list is void*.  */
end_comment

begin_function
name|tree
name|std_build_builtin_va_list
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ptr_type_node
return|;
block|}
end_function

begin_comment
comment|/* The "standard" implementation of va_start: just assign `nextarg' to    the variable.  */
end_comment

begin_function
name|void
name|std_expand_builtin_va_start
parameter_list|(
name|tree
name|valist
parameter_list|,
name|rtx
name|nextarg
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|make_tree
argument_list|(
name|ptr_type_node
argument_list|,
name|nextarg
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand ARGLIST, from a call to __builtin_va_start.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_va_start
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|rtx
name|nextarg
decl_stmt|;
name|tree
name|chain
decl_stmt|,
name|valist
decl_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chain
condition|)
block|{
name|error
argument_list|(
literal|"too few arguments to function %<va_start%>"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|fold_builtin_next_arg
argument_list|(
name|chain
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
name|nextarg
operator|=
name|expand_builtin_next_arg
argument_list|()
expr_stmt|;
name|valist
operator|=
name|stabilize_va_list
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXPAND_BUILTIN_VA_START
name|EXPAND_BUILTIN_VA_START
argument_list|(
name|valist
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
else|#
directive|else
name|std_expand_builtin_va_start
argument_list|(
name|valist
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* The "standard" implementation of va_arg: read the value from the    current (padded) address and increment by the (padded) size.  */
end_comment

begin_function
name|tree
name|std_gimplify_va_arg_expr
parameter_list|(
name|tree
name|valist
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|)
block|{
name|tree
name|addr
decl_stmt|,
name|t
decl_stmt|,
name|type_size
decl_stmt|,
name|rounded_size
decl_stmt|,
name|valist_tmp
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|align
decl_stmt|,
name|boundary
decl_stmt|;
name|bool
name|indirect
decl_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
comment|/* All of the alignment and movement below is for args-grow-up machines.      As of 2004, there are only 3 ARGS_GROW_DOWNWARD targets, and they all      implement their own specialized gimplify_va_arg_expr routines.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|indirect
operator|=
name|pass_by_reference
argument_list|(
name|NULL
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect
condition|)
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|align
operator|=
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|boundary
operator|=
name|FUNCTION_ARG_BOUNDARY
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Hoist the valist value into a temporary for the moment.  */
name|valist_tmp
operator|=
name|get_initialized_tmp_var
argument_list|(
name|valist
argument_list|,
name|pre_p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* va_list pointer is aligned to PARM_BOUNDARY.  If argument actually      requires greater alignment, we must perform dynamic alignment.  */
if|if
condition|(
name|boundary
operator|>
name|align
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|t
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|boundary
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist_tmp
argument_list|,
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist_tmp
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|size_int
argument_list|(
operator|-
name|boundary
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist_tmp
argument_list|,
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist_tmp
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
else|else
name|boundary
operator|=
name|align
expr_stmt|;
comment|/* If the actual alignment is less than the alignment of the type,      adjust the type accordingly so that we don't assume strict alignment      when deferencing the pointer.  */
name|boundary
operator|*=
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|boundary
operator|<
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|type
operator|=
name|build_variant_type_copy
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|boundary
expr_stmt|;
block|}
comment|/* Compute the rounded size of the type.  */
name|type_size
operator|=
name|size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|rounded_size
operator|=
name|round_up
argument_list|(
name|type_size
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* Reduce rounded_size so it's sharable with the postqueue.  */
name|gimplify_expr
argument_list|(
operator|&
name|rounded_size
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
comment|/* Get AP.  */
name|addr
operator|=
name|valist_tmp
expr_stmt|;
if|if
condition|(
name|PAD_VARARGS_DOWN
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|rounded_size
argument_list|)
condition|)
block|{
comment|/* Small args are padded downward.  */
name|t
operator|=
name|fold_build2
argument_list|(
name|GT_EXPR
argument_list|,
name|sizetype
argument_list|,
name|rounded_size
argument_list|,
name|size_int
argument_list|(
name|align
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_build3
argument_list|(
name|COND_EXPR
argument_list|,
name|sizetype
argument_list|,
name|t
argument_list|,
name|size_zero_node
argument_list|,
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|rounded_size
argument_list|,
name|type_size
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|addr
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|,
name|addr
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Compute new value for AP.  */
name|t
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|rounded_size
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist_tmp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|addr
operator|=
name|fold_convert
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect
condition|)
name|addr
operator|=
name|build_va_arg_indirect_ref
argument_list|(
name|addr
argument_list|)
expr_stmt|;
return|return
name|build_va_arg_indirect_ref
argument_list|(
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an indirect-ref expression over the given TREE, which represents a    piece of a va_arg() expansion.  */
end_comment

begin_function
name|tree
name|build_va_arg_indirect_ref
parameter_list|(
name|tree
name|addr
parameter_list|)
block|{
name|addr
operator|=
name|build_fold_indirect_ref
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_mudflap
condition|)
comment|/* Don't instrument va_arg INDIRECT_REF.  */
name|mf_mark
argument_list|(
name|addr
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Return a dummy expression of type TYPE in order to keep going after an    error.  */
end_comment

begin_function
specifier|static
name|tree
name|dummy_object
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|t
init|=
name|build_int_cst
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Gimplify __builtin_va_arg, aka VA_ARG_EXPR, which is not really a    builtin function, but a very special sort of operator.  */
end_comment

begin_function
name|enum
name|gimplify_status
name|gimplify_va_arg_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|)
block|{
name|tree
name|promoted_type
decl_stmt|,
name|want_va_type
decl_stmt|,
name|have_va_type
decl_stmt|;
name|tree
name|valist
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
operator|*
name|expr_p
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Verify that valist is of the proper type.  */
name|want_va_type
operator|=
name|va_list_type_node
expr_stmt|;
name|have_va_type
operator|=
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_va_type
operator|==
name|error_mark_node
condition|)
return|return
name|GS_ERROR
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|want_va_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* If va_list is an array type, the argument may have decayed 	 to a pointer type, e.g. by being passed to another function. 	 In that case, unwrap both types so that we can compare the 	 underlying records.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|have_va_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|POINTER_TYPE_P
argument_list|(
name|have_va_type
argument_list|)
condition|)
block|{
name|want_va_type
operator|=
name|TREE_TYPE
argument_list|(
name|want_va_type
argument_list|)
expr_stmt|;
name|have_va_type
operator|=
name|TREE_TYPE
argument_list|(
name|have_va_type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|want_va_type
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|have_va_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"first argument to %<va_arg%> not of type %<va_list%>"
argument_list|)
expr_stmt|;
return|return
name|GS_ERROR
return|;
block|}
comment|/* Generate a diagnostic for requesting data of a type that cannot      be passed through `...' due to type promotion at the call site.  */
elseif|else
if|if
condition|(
operator|(
name|promoted_type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_promotes_to
argument_list|(
name|type
argument_list|)
operator|)
operator|!=
name|type
condition|)
block|{
specifier|static
name|bool
name|gave_help
decl_stmt|;
comment|/* Unfortunately, this is merely undefined, rather than a constraint 	 violation, so we cannot make this an error.  If this call is never 	 executed, the program is still strictly conforming.  */
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%qT is promoted to %qT when passed through %<...%>"
argument_list|,
name|type
argument_list|,
name|promoted_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gave_help
condition|)
block|{
name|gave_help
operator|=
name|true
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"(so you should pass %qT not %qT to %<va_arg%>)"
argument_list|,
name|promoted_type
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* We can, however, treat "undefined" any way we please. 	 Call abort to encourage the user to fix the program.  */
name|inform
argument_list|(
literal|"if this code is reached, the program will abort"
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|implicit_built_in_decls
index|[
name|BUILT_IN_TRAP
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
comment|/* This is dead code, but go ahead and finish so that the 	 mode of the result comes out right.  */
operator|*
name|expr_p
operator|=
name|dummy_object
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|GS_ALL_DONE
return|;
block|}
else|else
block|{
comment|/* Make it easier for the backends by protecting the valist argument 	 from multiple evaluations.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|va_list_type_node
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* For this case, the backends will be expecting a pointer to 	     TREE_TYPE (va_list_type_node), but it's possible we've 	     actually been given an array (an actual va_list_type_node). 	     So fix it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|p1
init|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
decl_stmt|;
name|valist
operator|=
name|build_fold_addr_expr_with_type
argument_list|(
name|valist
argument_list|,
name|p1
argument_list|)
expr_stmt|;
block|}
name|gimplify_expr
argument_list|(
operator|&
name|valist
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
block|}
else|else
name|gimplify_expr
argument_list|(
operator|&
name|valist
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_min_lval
argument_list|,
name|fb_lvalue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|targetm
operator|.
name|gimplify_va_arg_expr
condition|)
comment|/* FIXME:Once most targets are converted we should merely 	   assert this is non-null.  */
return|return
name|GS_ALL_DONE
return|;
operator|*
name|expr_p
operator|=
name|targetm
operator|.
name|gimplify_va_arg_expr
argument_list|(
name|valist
argument_list|,
name|type
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand ARGLIST, from a call to __builtin_va_end.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_va_end
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|valist
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
comment|/* Evaluate for side effects, if needed.  I hate macros that don't      do that.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|valist
argument_list|)
condition|)
name|expand_expr
argument_list|(
name|valist
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* Expand ARGLIST, from a call to __builtin_va_copy.  We do this as a    builtin rather than just as an assignment in stdarg.h because of the    nastiness of array-type va_list types.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_va_copy
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|dst
decl_stmt|,
name|src
decl_stmt|,
name|t
decl_stmt|;
name|dst
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|stabilize_va_list
argument_list|(
name|dst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|src
operator|=
name|stabilize_va_list
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|va_list_type_node
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|va_list_type_node
argument_list|,
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|dstb
decl_stmt|,
name|srcb
decl_stmt|,
name|size
decl_stmt|;
comment|/* Evaluate to pointers.  */
name|dstb
operator|=
name|expand_expr
argument_list|(
name|dst
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|srcb
operator|=
name|expand_expr
argument_list|(
name|src
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|size
operator|=
name|expand_expr
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|dstb
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|dstb
argument_list|)
expr_stmt|;
name|srcb
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|srcb
argument_list|)
expr_stmt|;
comment|/* "Dereference" to BLKmode memories.  */
name|dstb
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|dstb
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|dstb
argument_list|,
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|dstb
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|srcb
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|srcb
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|srcb
argument_list|,
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|srcb
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy.  */
name|emit_block_move
argument_list|(
name|dstb
argument_list|,
name|srcb
argument_list|,
name|size
argument_list|,
name|BLOCK_OP_NORMAL
argument_list|)
expr_stmt|;
block|}
return|return
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to one of the builtin functions __builtin_frame_address or    __builtin_return_address.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_frame_address
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
comment|/* The argument must be a nonnegative integer constant.      It counts the number of frames to scan up the stack.      The value is the return address saved in that frame.  */
if|if
condition|(
name|arglist
operator|==
literal|0
condition|)
comment|/* Warning about missing arg was already issued.  */
return|return
name|const0_rtx
return|;
elseif|else
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_FRAME_ADDRESS
condition|)
name|error
argument_list|(
literal|"invalid argument to %<__builtin_frame_address%>"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid argument to %<__builtin_return_address%>"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
else|else
block|{
name|rtx
name|tem
init|=
name|expand_builtin_return_addr
argument_list|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|tree_low_cst
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Some ports cannot access arbitrary stack frames.  */
if|if
condition|(
name|tem
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_FRAME_ADDRESS
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"unsupported argument to %<__builtin_frame_address%>"
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"unsupported argument to %<__builtin_return_address%>"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
comment|/* For __builtin_frame_address, return what we've got.  */
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_FRAME_ADDRESS
condition|)
return|return
name|tem
return|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|tem
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|tem
argument_list|)
condition|)
name|tem
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to the alloca builtin, with arguments ARGLIST.  Return 0 if    we failed and the caller should emit a normal call, otherwise try to get    the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_alloca
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|;
name|rtx
name|result
decl_stmt|;
comment|/* In -fmudflap-instrumented code, alloca() and __builtin_alloca()      should always expand to function calls.  These can be intercepted      in libmudflap.  */
if|if
condition|(
name|flag_mudflap
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Compute the argument.  */
name|op0
operator|=
name|expand_normal
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate the desired space.  */
name|result
operator|=
name|allocate_dynamic_stack_space
argument_list|(
name|op0
argument_list|,
name|target
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|result
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to a unary builtin.  The arguments are in ARGLIST.    Return 0 if a normal call should be emitted rather than expanding the    function in-line.  If convenient, the result should be placed in TARGET.    SUBTARGET may be used as the target for computing one of EXP's operands.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_unop
parameter_list|(
name|enum
name|machine_mode
name|target_mode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
parameter_list|,
name|optab
name|op_optab
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Compute the argument.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Compute op, into TARGET if possible.      Set TARGET to wherever the result comes back.  */
name|target
operator|=
name|expand_unop
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|op_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|target
argument_list|)
expr_stmt|;
return|return
name|convert_to_mode
argument_list|(
name|target_mode
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If the string passed to fputs is a constant and is one character    long, we attempt to transform this call into __builtin_fputc().  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_fputs
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|bool
name|unlocked
parameter_list|)
block|{
comment|/* Verify the arguments in the original call.  */
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|result
init|=
name|fold_builtin_fputs
argument_list|(
name|arglist
argument_list|,
operator|(
name|target
operator|==
name|const0_rtx
operator|)
argument_list|,
name|unlocked
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to __builtin_expect.  We return our argument and emit a    NOTE_INSN_EXPECTED_VALUE note.  This is the expansion of __builtin_expect in    a non-jump context.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_expect
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|tree
name|exp
decl_stmt|,
name|c
decl_stmt|;
name|rtx
name|note
decl_stmt|,
name|rtx_c
decl_stmt|;
if|if
condition|(
name|arglist
operator|==
name|NULL_TREE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|const0_rtx
return|;
name|exp
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|c
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|c
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"second argument to %<__builtin_expect%> must be a constant"
argument_list|)
expr_stmt|;
name|c
operator|=
name|integer_zero_node
expr_stmt|;
block|}
name|target
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Don't bother with expected value notes for integral constants.  */
if|if
condition|(
name|flag_guess_branch_prob
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
comment|/* We do need to force this into a register so that we can be 	 moderately sure to be able to correctly interpret the branch 	 condition later.  */
name|target
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|rtx_c
operator|=
name|expand_expr
argument_list|(
name|c
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|note
operator|=
name|emit_note
argument_list|(
name|NOTE_INSN_EXPECTED_VALUE
argument_list|)
expr_stmt|;
name|NOTE_EXPECTED_VALUE
argument_list|(
name|note
argument_list|)
operator|=
name|gen_rtx_EQ
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|rtx_c
argument_list|)
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Like expand_builtin_expect, except do this in a jump context.  This is    called from do_jump if the conditional is a __builtin_expect.  Return either    a list of insns to emit the jump or NULL if we cannot optimize    __builtin_expect.  We need to optimize this at jump time so that machines    like the PowerPC don't turn the test into a SCC operation, and then jump    based on the test being 0/1.  */
end_comment

begin_function
name|rtx
name|expand_builtin_expect_jump
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|if_false_label
parameter_list|,
name|rtx
name|if_true_label
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|ret
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Only handle __builtin_expect (test, 0) and      __builtin_expect (test, 1).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|arg1
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|insn
decl_stmt|,
name|drop_through_label
decl_stmt|,
name|temp
decl_stmt|;
comment|/* Expand the jump insns.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|arg0
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|ret
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|drop_through_label
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|drop_through_label
operator|&&
name|NOTE_P
argument_list|(
name|drop_through_label
argument_list|)
condition|)
name|drop_through_label
operator|=
name|prev_nonnote_insn
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_through_label
operator|&&
operator|!
name|LABEL_P
argument_list|(
name|drop_through_label
argument_list|)
condition|)
name|drop_through_label
operator|=
name|NULL_RTX
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|if_true_label
condition|)
name|if_true_label
operator|=
name|drop_through_label
expr_stmt|;
if|if
condition|(
operator|!
name|if_false_label
condition|)
name|if_false_label
operator|=
name|drop_through_label
expr_stmt|;
comment|/* Go through and add the expect's to each of the conditional jumps.  */
name|insn
operator|=
name|ret
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|NULL_RTX
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|ifelse
init|=
name|SET_SRC
argument_list|(
name|pc_set
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|then_dest
init|=
name|XEXP
argument_list|(
name|ifelse
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|else_dest
init|=
name|XEXP
argument_list|(
name|ifelse
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|int
name|taken
init|=
operator|-
literal|1
decl_stmt|;
comment|/* First check if we recognize any of the labels.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|then_dest
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|then_dest
argument_list|,
literal|0
argument_list|)
operator|==
name|if_true_label
condition|)
name|taken
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|then_dest
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|then_dest
argument_list|,
literal|0
argument_list|)
operator|==
name|if_false_label
condition|)
name|taken
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|else_dest
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|else_dest
argument_list|,
literal|0
argument_list|)
operator|==
name|if_false_label
condition|)
name|taken
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|else_dest
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|else_dest
argument_list|,
literal|0
argument_list|)
operator|==
name|if_true_label
condition|)
name|taken
operator|=
literal|0
expr_stmt|;
comment|/* Otherwise check where we drop through.  */
elseif|else
if|if
condition|(
name|else_dest
operator|==
name|pc_rtx
condition|)
block|{
if|if
condition|(
name|next
operator|&&
name|NOTE_P
argument_list|(
name|next
argument_list|)
condition|)
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|&&
name|JUMP_P
argument_list|(
name|next
argument_list|)
operator|&&
name|any_uncondjump_p
argument_list|(
name|next
argument_list|)
condition|)
name|temp
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pc_set
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|next
expr_stmt|;
comment|/* TEMP is either a CODE_LABEL, NULL_RTX or something 		     else that can't possibly match either target label.  */
if|if
condition|(
name|temp
operator|==
name|if_false_label
condition|)
name|taken
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|==
name|if_true_label
condition|)
name|taken
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|then_dest
operator|==
name|pc_rtx
condition|)
block|{
if|if
condition|(
name|next
operator|&&
name|NOTE_P
argument_list|(
name|next
argument_list|)
condition|)
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|&&
name|JUMP_P
argument_list|(
name|next
argument_list|)
operator|&&
name|any_uncondjump_p
argument_list|(
name|next
argument_list|)
condition|)
name|temp
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pc_set
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|if_false_label
condition|)
name|taken
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|==
name|if_true_label
condition|)
name|taken
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|taken
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* If the test is expected to fail, reverse the 		     probabilities.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
name|taken
operator|=
literal|1
operator|-
name|taken
expr_stmt|;
name|predict_insn_def
argument_list|(
name|insn
argument_list|,
name|PRED_BUILTIN_EXPECT
argument_list|,
name|taken
argument_list|)
expr_stmt|;
block|}
block|}
name|insn
operator|=
name|next
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|expand_builtin_trap
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_trap
if|if
condition|(
name|HAVE_trap
condition|)
name|emit_insn
argument_list|(
name|gen_trap
argument_list|()
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|emit_library_call
argument_list|(
name|abort_libfunc
argument_list|,
name|LCT_NORETURN
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand a call to fabs, fabsf or fabsl with arguments ARGLIST.    Return 0 if a normal call should be emitted rather than expanding    the function inline.  If convenient, the result should be placed    in TARGET.  SUBTARGET may be used as the target for computing    the operand.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_fabs
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_abs
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to copysign, copysignf, or copysignl with arguments ARGLIST.    Return NULL is a normal call should be emitted rather than expanding the    function inline.  If convenient, the result should be placed in TARGET.    SUBTARGET may be used as the target for computing the operand.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_copysign
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|tree
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|expand_copysign
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a new constant string literal and return a char* pointer to it.    The STRING_CST value is the LEN characters at STR.  */
end_comment

begin_function
name|tree
name|build_string_literal
parameter_list|(
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|elem
decl_stmt|,
name|index
decl_stmt|,
name|type
decl_stmt|;
name|t
operator|=
name|build_string
argument_list|(
name|len
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|elem
operator|=
name|build_type_variant
argument_list|(
name|char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|index
operator|=
name|build_index_type
argument_list|(
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|len
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_array_type
argument_list|(
name|elem
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|elem
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Expand EXP, a call to printf or printf_unlocked.    Return 0 if a normal call should be emitted rather than transforming    the function inline.  If convenient, the result should be placed in    TARGET with mode MODE.  UNLOCKED indicates this is a printf_unlocked    call.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_printf
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|bool
name|unlocked
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* If we're using an unlocked function, assume the other unlocked      functions exist explicitly.  */
name|tree
specifier|const
name|fn_putchar
init|=
name|unlocked
condition|?
name|built_in_decls
index|[
name|BUILT_IN_PUTCHAR_UNLOCKED
index|]
else|:
name|implicit_built_in_decls
index|[
name|BUILT_IN_PUTCHAR
index|]
decl_stmt|;
name|tree
specifier|const
name|fn_puts
init|=
name|unlocked
condition|?
name|built_in_decls
index|[
name|BUILT_IN_PUTS_UNLOCKED
index|]
else|:
name|implicit_built_in_decls
index|[
name|BUILT_IN_PUTS
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt_str
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|fmt
decl_stmt|,
name|arg
decl_stmt|;
comment|/* If the return value is used, don't do the transformation.  */
if|if
condition|(
name|target
operator|!=
name|const0_rtx
condition|)
return|return
literal|0
return|;
comment|/* Verify the required arguments in the original call.  */
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|fmt
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fmt
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* Check whether the format is a literal string constant.  */
name|fmt_str
operator|=
name|c_getstr
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt_str
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|init_target_chars
argument_list|()
condition|)
return|return
literal|0
return|;
comment|/* If the format specifier was "%s\n", call __builtin_puts(arg).  */
if|if
condition|(
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
name|target_percent_s_newline
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|arglist
operator|||
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|fn_puts
expr_stmt|;
block|}
comment|/* If the format specifier was "%c", call __builtin_putchar(arg).  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
name|target_percent_c
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|arglist
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|fn_putchar
expr_stmt|;
block|}
else|else
block|{
comment|/* We can't handle anything else with % args or %% ... yet.  */
if|if
condition|(
name|strchr
argument_list|(
name|fmt_str
argument_list|,
name|target_percent
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|arglist
condition|)
return|return
literal|0
return|;
comment|/* If the format specifier was "", printf does nothing.  */
if|if
condition|(
name|fmt_str
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|const0_rtx
return|;
comment|/* If the format specifier has length of 1, call putchar.  */
if|if
condition|(
name|fmt_str
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Given printf("c"), (where c is any one character,) 	     convert "c"[0] to an int and pass that to the replacement 	     function.  */
name|arg
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|fmt_str
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_putchar
expr_stmt|;
block|}
else|else
block|{
comment|/* If the format specifier was "string\n", call puts("string").  */
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|fmt_str
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|fmt_str
index|[
name|len
operator|-
literal|1
index|]
operator|==
name|target_newline
condition|)
block|{
comment|/* Create a NUL-terminated string that's one char shorter 		 than the original, stripping off the trailing '\n'.  */
name|char
modifier|*
name|newstr
init|=
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newstr
argument_list|,
name|fmt_str
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|newstr
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|arg
operator|=
name|build_string_literal
argument_list|(
name|len
argument_list|,
name|newstr
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_puts
expr_stmt|;
block|}
else|else
comment|/* We'd like to arrange to call fputs(string,stdout) here, 	       but we need stdout and don't have a way to get it yet.  */
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|CALL_EXPR_TAILCALL
argument_list|(
name|fn
argument_list|)
operator|=
name|CALL_EXPR_TAILCALL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|fn
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand EXP, a call to fprintf or fprintf_unlocked.    Return 0 if a normal call should be emitted rather than transforming    the function inline.  If convenient, the result should be placed in    TARGET with mode MODE.  UNLOCKED indicates this is a fprintf_unlocked    call.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_fprintf
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|bool
name|unlocked
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* If we're using an unlocked function, assume the other unlocked      functions exist explicitly.  */
name|tree
specifier|const
name|fn_fputc
init|=
name|unlocked
condition|?
name|built_in_decls
index|[
name|BUILT_IN_FPUTC_UNLOCKED
index|]
else|:
name|implicit_built_in_decls
index|[
name|BUILT_IN_FPUTC
index|]
decl_stmt|;
name|tree
specifier|const
name|fn_fputs
init|=
name|unlocked
condition|?
name|built_in_decls
index|[
name|BUILT_IN_FPUTS_UNLOCKED
index|]
else|:
name|implicit_built_in_decls
index|[
name|BUILT_IN_FPUTS
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt_str
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|fmt
decl_stmt|,
name|fp
decl_stmt|,
name|arg
decl_stmt|;
comment|/* If the return value is used, don't do the transformation.  */
if|if
condition|(
name|target
operator|!=
name|const0_rtx
condition|)
return|return
literal|0
return|;
comment|/* Verify the required arguments in the original call.  */
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|fp
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|fmt
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fmt
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* Check whether the format is a literal string constant.  */
name|fmt_str
operator|=
name|c_getstr
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt_str
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|init_target_chars
argument_list|()
condition|)
return|return
literal|0
return|;
comment|/* If the format specifier was "%s", call __builtin_fputs(arg,fp).  */
if|if
condition|(
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
name|target_percent_s
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|arglist
operator|||
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fputs
expr_stmt|;
block|}
comment|/* If the format specifier was "%c", call __builtin_fputc(arg,fp).  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
name|target_percent_c
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|arglist
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fputc
expr_stmt|;
block|}
else|else
block|{
comment|/* We can't handle anything else with % args or %% ... yet.  */
if|if
condition|(
name|strchr
argument_list|(
name|fmt_str
argument_list|,
name|target_percent
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|arglist
condition|)
return|return
literal|0
return|;
comment|/* If the format specifier was "", fprintf does nothing.  */
if|if
condition|(
name|fmt_str
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Evaluate and ignore FILE* argument for side-effects.  */
name|expand_expr
argument_list|(
name|fp
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
comment|/* When "string" doesn't contain %, replace all cases of 	 fprintf(stream,string) with fputs(string,stream).  The fputs 	 builtin will take care of special cases like length == 1.  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fmt
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fputs
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|CALL_EXPR_TAILCALL
argument_list|(
name|fn
argument_list|)
operator|=
name|CALL_EXPR_TAILCALL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|fn
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to sprintf with argument list ARGLIST.  Return 0 if    a normal call should be emitted rather than expanding the function    inline.  If convenient, the result should be placed in TARGET with    mode MODE.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_sprintf
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|tree
name|orig_arglist
decl_stmt|,
name|dest
decl_stmt|,
name|fmt
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt_str
decl_stmt|;
name|orig_arglist
operator|=
name|arglist
expr_stmt|;
comment|/* Verify the required arguments in the original call.  */
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|fmt
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fmt
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* Check whether the format is a literal string constant.  */
name|fmt_str
operator|=
name|c_getstr
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt_str
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|init_target_chars
argument_list|()
condition|)
return|return
literal|0
return|;
comment|/* If the format doesn't contain % args or %%, use strcpy.  */
if|if
condition|(
name|strchr
argument_list|(
name|fmt_str
argument_list|,
name|target_percent
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|fn
init|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRCPY
index|]
decl_stmt|;
name|tree
name|exp
decl_stmt|;
if|if
condition|(
name|arglist
operator|||
operator|!
name|fn
condition|)
return|return
literal|0
return|;
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|orig_arglist
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|const0_rtx
condition|)
return|return
name|const0_rtx
return|;
name|exp
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|strlen
argument_list|(
name|fmt_str
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If the format is "%s", use strcpy if the result isn't used.  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
name|target_percent_s
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|fn
decl_stmt|,
name|arg
decl_stmt|,
name|len
decl_stmt|;
name|fn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRCPY
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|arglist
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|target
operator|!=
name|const0_rtx
condition|)
block|{
name|len
operator|=
name|c_strlen
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
name|TREE_CODE
argument_list|(
name|len
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
block|}
else|else
name|len
operator|=
name|NULL_TREE
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|const0_rtx
condition|)
return|return
name|const0_rtx
return|;
return|return
name|expand_expr
argument_list|(
name|len
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to either the entry or exit function profiler.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_profile_func
parameter_list|(
name|bool
name|exitp
parameter_list|)
block|{
name|rtx
name|this
decl_stmt|,
name|which
decl_stmt|;
name|this
operator|=
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|=
name|XEXP
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exitp
condition|)
name|which
operator|=
name|profile_function_exit_libfunc
expr_stmt|;
else|else
name|which
operator|=
name|profile_function_entry_libfunc
expr_stmt|;
name|emit_library_call
argument_list|(
name|which
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|2
argument_list|,
name|this
argument_list|,
name|Pmode
argument_list|,
name|expand_builtin_return_addr
argument_list|(
name|BUILT_IN_RETURN_ADDRESS
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* Given a trampoline address, make sure it satisfies TRAMPOLINE_ALIGNMENT.  */
end_comment

begin_function
specifier|static
name|rtx
name|round_trampoline_addr
parameter_list|(
name|rtx
name|tramp
parameter_list|)
block|{
name|rtx
name|temp
decl_stmt|,
name|addend
decl_stmt|,
name|mask
decl_stmt|;
comment|/* If we don't need too much alignment, we'll have been guaranteed      proper alignment by get_trampoline_type.  */
if|if
condition|(
name|TRAMPOLINE_ALIGNMENT
operator|<=
name|STACK_BOUNDARY
condition|)
return|return
name|tramp
return|;
comment|/* Round address up to desired boundary.  */
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|addend
operator|=
name|GEN_INT
argument_list|(
name|TRAMPOLINE_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mask
operator|=
name|GEN_INT
argument_list|(
operator|-
name|TRAMPOLINE_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|PLUS
argument_list|,
name|tramp
argument_list|,
name|addend
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|tramp
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|AND
argument_list|,
name|temp
argument_list|,
name|mask
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
return|return
name|tramp
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|expand_builtin_init_trampoline
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|t_tramp
decl_stmt|,
name|t_func
decl_stmt|,
name|t_chain
decl_stmt|;
name|rtx
name|r_tramp
decl_stmt|,
name|r_func
decl_stmt|,
name|r_chain
decl_stmt|;
ifdef|#
directive|ifdef
name|TRAMPOLINE_TEMPLATE
name|rtx
name|blktramp
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|t_tramp
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|t_func
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|t_chain
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|r_tramp
operator|=
name|expand_normal
argument_list|(
name|t_tramp
argument_list|)
expr_stmt|;
name|r_func
operator|=
name|expand_normal
argument_list|(
name|t_func
argument_list|)
expr_stmt|;
name|r_chain
operator|=
name|expand_normal
argument_list|(
name|t_chain
argument_list|)
expr_stmt|;
comment|/* Generate insns to initialize the trampoline.  */
name|r_tramp
operator|=
name|round_trampoline_addr
argument_list|(
name|r_tramp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRAMPOLINE_TEMPLATE
name|blktramp
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|r_tramp
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|blktramp
argument_list|,
name|TRAMPOLINE_ALIGNMENT
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|blktramp
argument_list|,
name|assemble_trampoline_template
argument_list|()
argument_list|,
name|GEN_INT
argument_list|(
name|TRAMPOLINE_SIZE
argument_list|)
argument_list|,
name|BLOCK_OP_NORMAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|trampolines_created
operator|=
literal|1
expr_stmt|;
name|INITIALIZE_TRAMPOLINE
argument_list|(
name|r_tramp
argument_list|,
name|r_func
argument_list|,
name|r_chain
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|expand_builtin_adjust_trampoline
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|rtx
name|tramp
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|tramp
operator|=
name|expand_normal
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|tramp
operator|=
name|round_trampoline_addr
argument_list|(
name|tramp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRAMPOLINE_ADJUST_ADDRESS
name|TRAMPOLINE_ADJUST_ADDRESS
argument_list|(
name|tramp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|tramp
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to the built-in signbit, signbitf or signbitl function.    Return NULL_RTX if a normal call should be emitted rather than expanding    the function in-line.  EXP is the expression that is a call to the builtin    function; if convenient, the result should be placed in TARGET.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_signbit
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
decl_stmt|;
name|enum
name|machine_mode
name|fmode
decl_stmt|,
name|imode
decl_stmt|,
name|rmode
decl_stmt|;
name|HOST_WIDE_INT
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|tree
name|arg
decl_stmt|,
name|arglist
decl_stmt|;
name|int
name|word
decl_stmt|,
name|bitpos
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|fmode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|rmode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|REAL_MODE_FORMAT
argument_list|(
name|fmode
argument_list|)
expr_stmt|;
comment|/* For floating point formats without a sign bit, implement signbit      as "ARG< 0.0".  */
name|bitpos
operator|=
name|fmt
operator|->
name|signbit_ro
expr_stmt|;
if|if
condition|(
name|bitpos
operator|<
literal|0
condition|)
block|{
comment|/* But we can't do this if the format supports signed zero.  */
if|if
condition|(
name|fmt
operator|->
name|has_signed_zero
operator|&&
name|HONOR_SIGNED_ZEROS
argument_list|(
name|fmode
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|fold_build2
argument_list|(
name|LT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|dconst0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
name|temp
operator|=
name|expand_normal
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|fmode
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|)
block|{
name|imode
operator|=
name|int_mode_for_mode
argument_list|(
name|fmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|imode
operator|==
name|BLKmode
condition|)
return|return
literal|0
return|;
name|temp
operator|=
name|gen_lowpart
argument_list|(
name|imode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|imode
operator|=
name|word_mode
expr_stmt|;
comment|/* Handle targets with different FP word orders.  */
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
name|word
operator|=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|fmode
argument_list|)
operator|-
name|bitpos
operator|)
operator|/
name|BITS_PER_WORD
expr_stmt|;
else|else
name|word
operator|=
name|bitpos
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|temp
operator|=
name|operand_subword_force
argument_list|(
name|temp
argument_list|,
name|word
argument_list|,
name|fmode
argument_list|)
expr_stmt|;
name|bitpos
operator|=
name|bitpos
operator|%
name|BITS_PER_WORD
expr_stmt|;
block|}
comment|/* Force the intermediate word_mode (or narrower) result into a      register.  This avoids attempting to create paradoxical SUBREGs      of floating point modes below.  */
name|temp
operator|=
name|force_reg
argument_list|(
name|imode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* If the bitpos is within the "result mode" lowpart, the operation      can be implement with a single bitwise AND.  Otherwise, we need      a right shift and an AND.  */
if|if
condition|(
name|bitpos
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|rmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitpos
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|hi
operator|=
literal|0
expr_stmt|;
name|lo
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitpos
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitpos
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|imode
operator|!=
name|rmode
condition|)
name|temp
operator|=
name|gen_lowpart
argument_list|(
name|rmode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|rmode
argument_list|,
name|and_optab
argument_list|,
name|temp
argument_list|,
name|immed_double_const
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|,
name|rmode
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Perform a logical right shift to place the signbit in the least 	 significant bit, then truncate the result to the desired mode 	 and mask just this bit.  */
name|temp
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|imode
argument_list|,
name|temp
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|bitpos
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_lowpart
argument_list|(
name|rmode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|rmode
argument_list|,
name|and_optab
argument_list|,
name|temp
argument_list|,
name|const1_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Expand fork or exec calls.  TARGET is the desired target of the    call.  ARGLIST is the list of arguments of the call.  FN is the    identificator of the actual function.  IGNORE is nonzero if the    value is to be ignored.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_fork_or_exec
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|ignore
parameter_list|)
block|{
name|tree
name|id
decl_stmt|,
name|decl
decl_stmt|;
name|tree
name|call
decl_stmt|;
comment|/* If we are not profiling, just call the function.  */
if|if
condition|(
operator|!
name|profile_arc_flag
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Otherwise call the wrapper.  This should be equivalent for the rest of      compiler, so the code does not diverge, and the wrapper may run the      code necessary for keeping the profiling sane.  */
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fn
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_FORK
case|:
name|id
operator|=
name|get_identifier
argument_list|(
literal|"__gcov_fork"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUILT_IN_EXECL
case|:
name|id
operator|=
name|get_identifier
argument_list|(
literal|"__gcov_execl"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUILT_IN_EXECV
case|:
name|id
operator|=
name|get_identifier
argument_list|(
literal|"__gcov_execv"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUILT_IN_EXECLP
case|:
name|id
operator|=
name|get_identifier
argument_list|(
literal|"__gcov_execlp"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUILT_IN_EXECLE
case|:
name|id
operator|=
name|get_identifier
argument_list|(
literal|"__gcov_execle"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUILT_IN_EXECVP
case|:
name|id
operator|=
name|get_identifier
argument_list|(
literal|"__gcov_execvp"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUILT_IN_EXECVE
case|:
name|id
operator|=
name|get_identifier
argument_list|(
literal|"__gcov_execve"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|id
argument_list|,
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
operator|=
name|VISIBILITY_DEFAULT
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|call
operator|=
name|build_function_call_expr
argument_list|(
name|decl
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|expand_call
argument_list|(
name|call
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reconstitute a mode for a __sync intrinsic operation.  Since the type of    the pointer in these functions is void*, the tree optimizers may remove    casts.  The mode computed in expand_builtin isn't reliable either, due    to __sync_bool_compare_and_swap.     FCODE_DIFF should be fcode - base, where base is the FOO_1 code for the    group of builtins.  This gives us log2 of the mode size.  */
end_comment

begin_function
specifier|static
specifier|inline
name|enum
name|machine_mode
name|get_builtin_sync_mode
parameter_list|(
name|int
name|fcode_diff
parameter_list|)
block|{
comment|/* The size is not negotiable, so ask not to get BLKmode in return      if the target indicates that a smaller size would be better.  */
return|return
name|mode_for_size
argument_list|(
name|BITS_PER_UNIT
operator|<<
name|fcode_diff
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand the memory expression LOC and return the appropriate memory operand    for the builtin_sync operations.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_builtin_sync_mem
parameter_list|(
name|tree
name|loc
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|,
name|mem
decl_stmt|;
name|addr
operator|=
name|expand_expr
argument_list|(
name|loc
argument_list|,
name|NULL
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
comment|/* Note that we explicitly do not want any alias information for this      memory, so that we kill all other live memories.  Otherwise we don't      satisfy the full barrier semantics of the intrinsic.  */
name|mem
operator|=
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|mem
argument_list|,
name|get_pointer_alignment
argument_list|(
name|loc
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|ALIAS_SET_MEMORY_BARRIER
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_comment
comment|/* Expand the __sync_xxx_and_fetch and __sync_fetch_and_xxx intrinsics.    ARGLIST is the operands list to the function.  CODE is the rtx code    that corresponds to the arithmetic or logical operation from the name;    an exception here is that NOT actually means NAND.  TARGET is an optional    place for us to store the results; AFTER is true if this is the    fetch_and_xxx form.  IGNORE is true if we don't actually care about    the result of the operation at all.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_sync_operation
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|bool
name|after
parameter_list|,
name|rtx
name|target
parameter_list|,
name|bool
name|ignore
parameter_list|)
block|{
name|rtx
name|val
decl_stmt|,
name|mem
decl_stmt|;
name|enum
name|machine_mode
name|old_mode
decl_stmt|;
comment|/* Expand the operands.  */
name|mem
operator|=
name|get_builtin_sync_mem
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|val
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* If VAL is promoted to a wider mode, convert it back to MODE.  Take care      of CONST_INTs, where we know the old_mode only from the call argument.  */
name|old_mode
operator|=
name|GET_MODE
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_mode
operator|==
name|VOIDmode
condition|)
name|old_mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|old_mode
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore
condition|)
return|return
name|expand_sync_operation
argument_list|(
name|mem
argument_list|,
name|val
argument_list|,
name|code
argument_list|)
return|;
else|else
return|return
name|expand_sync_fetch_operation
argument_list|(
name|mem
argument_list|,
name|val
argument_list|,
name|code
argument_list|,
name|after
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand the __sync_val_compare_and_swap and __sync_bool_compare_and_swap    intrinsics.  ARGLIST is the operands list to the function.  IS_BOOL is    true if this is the boolean form.  TARGET is a place for us to store the    results; this is NOT optional if IS_BOOL is true.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_compare_and_swap
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|bool
name|is_bool
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|old_val
decl_stmt|,
name|new_val
decl_stmt|,
name|mem
decl_stmt|;
name|enum
name|machine_mode
name|old_mode
decl_stmt|;
comment|/* Expand the operands.  */
name|mem
operator|=
name|get_builtin_sync_mem
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|old_val
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* If VAL is promoted to a wider mode, convert it back to MODE.  Take care      of CONST_INTs, where we know the old_mode only from the call argument.  */
name|old_mode
operator|=
name|GET_MODE
argument_list|(
name|old_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_mode
operator|==
name|VOIDmode
condition|)
name|old_mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|old_val
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|old_mode
argument_list|,
name|old_val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|new_val
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* If VAL is promoted to a wider mode, convert it back to MODE.  Take care      of CONST_INTs, where we know the old_mode only from the call argument.  */
name|old_mode
operator|=
name|GET_MODE
argument_list|(
name|new_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_mode
operator|==
name|VOIDmode
condition|)
name|old_mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|new_val
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|old_mode
argument_list|,
name|new_val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_bool
condition|)
return|return
name|expand_bool_compare_and_swap
argument_list|(
name|mem
argument_list|,
name|old_val
argument_list|,
name|new_val
argument_list|,
name|target
argument_list|)
return|;
else|else
return|return
name|expand_val_compare_and_swap
argument_list|(
name|mem
argument_list|,
name|old_val
argument_list|,
name|new_val
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand the __sync_lock_test_and_set intrinsic.  Note that the most    general form is actually an atomic exchange, and some targets only    support a reduced form with the second argument being a constant 1.    ARGLIST is the operands list to the function; TARGET is an optional    place for us to store the results.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_lock_test_and_set
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|val
decl_stmt|,
name|mem
decl_stmt|;
name|enum
name|machine_mode
name|old_mode
decl_stmt|;
comment|/* Expand the operands.  */
name|mem
operator|=
name|get_builtin_sync_mem
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|val
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* If VAL is promoted to a wider mode, convert it back to MODE.  Take care      of CONST_INTs, where we know the old_mode only from the call argument.  */
name|old_mode
operator|=
name|GET_MODE
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_mode
operator|==
name|VOIDmode
condition|)
name|old_mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|old_mode
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|expand_sync_lock_test_and_set
argument_list|(
name|mem
argument_list|,
name|val
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand the __sync_synchronize intrinsic.  */
end_comment

begin_function
specifier|static
name|void
name|expand_builtin_synchronize
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|x
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_memory_barrier
if|if
condition|(
name|HAVE_memory_barrier
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_memory_barrier
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* If no explicit memory barrier instruction is available, create an      empty asm stmt with a memory clobber.  */
name|x
operator|=
name|build4
argument_list|(
name|ASM_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build_string
argument_list|(
literal|0
argument_list|,
literal|""
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|build_string
argument_list|(
literal|6
argument_list|,
literal|"memory"
argument_list|)
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_asm_expr
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand the __sync_lock_release intrinsic.  ARGLIST is the operands list    to the function.  */
end_comment

begin_function
specifier|static
name|void
name|expand_builtin_lock_release
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|mem
decl_stmt|,
name|insn
decl_stmt|;
name|rtx
name|val
init|=
name|const0_rtx
decl_stmt|;
comment|/* Expand the operands.  */
name|mem
operator|=
name|get_builtin_sync_mem
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* If there is an explicit operation in the md file, use it.  */
name|icode
operator|=
name|sync_lock_release
index|[
name|mode
index|]
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
condition|)
name|val
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|insn
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|mem
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
block|{
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Otherwise we can implement this operation by emitting a barrier      followed by a store of zero.  */
name|expand_builtin_synchronize
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand an expression EXP that calls a built-in function,    with result going to TARGET if that's convenient    (and in mode MODE if that's convenient).    SUBTARGET may be used as the target for computing one of EXP's operands.    IGNORE is nonzero if the value is to be ignored.  */
end_comment

begin_function
name|rtx
name|expand_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|ignore
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|built_in_function
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|target_mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_MD
condition|)
return|return
name|targetm
operator|.
name|expand_builtin
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|,
name|mode
argument_list|,
name|ignore
argument_list|)
return|;
comment|/* When not optimizing, generate calls to library functions for a certain      set of builtins.  */
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|!
name|called_as_built_in
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|fcode
operator|!=
name|BUILT_IN_ALLOCA
condition|)
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
return|;
comment|/* The built-in function expanders test for target == const0_rtx      to determine whether the function's result will be ignored.  */
if|if
condition|(
name|ignore
condition|)
name|target
operator|=
name|const0_rtx
expr_stmt|;
comment|/* If the result of a pure or const built-in function is ignored, and      none of its arguments are volatile, we can avoid expanding the      built-in call and just evaluate the arguments for side-effects.  */
if|if
condition|(
name|target
operator|==
name|const0_rtx
operator|&&
operator|(
name|DECL_IS_PURE
argument_list|(
name|fndecl
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|fndecl
argument_list|)
operator|)
condition|)
block|{
name|bool
name|volatilep
init|=
name|false
decl_stmt|;
name|tree
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|arglist
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
block|{
name|volatilep
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|volatilep
condition|)
block|{
for|for
control|(
name|arg
operator|=
name|arglist
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
block|}
switch|switch
condition|(
name|fcode
condition|)
block|{
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_FABS
argument_list|)
operator|:
name|target
operator|=
name|expand_builtin_fabs
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_COPYSIGN
argument_list|)
operator|:
name|target
operator|=
name|expand_builtin_copysign
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
comment|/* Just do a normal library call if we were unable to fold 	 the values.  */
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_CABS
argument_list|)
operator|:
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_EXP
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_EXP10
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_POW10
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_EXP2
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_EXPM1
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LOGB
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ILOGB
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LOG
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LOG10
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LOG2
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LOG1P
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_TAN
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ASIN
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ACOS
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ATAN
argument_list|)
operator|:
comment|/* Treat these like sqrt only if unsafe math optimizations are allowed, 	 because of possible accuracy problems.  */
if|if
condition|(
operator|!
name|flag_unsafe_math_optimizations
condition|)
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_SQRT
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_FLOOR
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_CEIL
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_TRUNC
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ROUND
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_NEARBYINT
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_RINT
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LRINT
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLRINT
argument_list|)
operator|:
name|target
operator|=
name|expand_builtin_mathfn
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LCEIL
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLCEIL
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LFLOOR
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLFLOOR
argument_list|)
operator|:
name|target
operator|=
name|expand_builtin_int_roundingfn
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_POW
argument_list|)
operator|:
name|target
operator|=
name|expand_builtin_pow
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_POWI
argument_list|)
operator|:
name|target
operator|=
name|expand_builtin_powi
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ATAN2
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LDEXP
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_FMOD
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_DREM
argument_list|)
operator|:
if|if
condition|(
operator|!
name|flag_unsafe_math_optimizations
condition|)
break|break;
name|target
operator|=
name|expand_builtin_mathfn_2
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_SIN
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_COS
argument_list|)
operator|:
if|if
condition|(
operator|!
name|flag_unsafe_math_optimizations
condition|)
break|break;
name|target
operator|=
name|expand_builtin_mathfn_3
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_SINCOS
argument_list|)
operator|:
if|if
condition|(
operator|!
name|flag_unsafe_math_optimizations
condition|)
break|break;
name|target
operator|=
name|expand_builtin_sincos
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_APPLY_ARGS
case|:
return|return
name|expand_builtin_apply_args
argument_list|()
return|;
comment|/* __builtin_apply (FUNCTION, ARGUMENTS, ARGSIZE) invokes 	 FUNCTION with a copy of the parameters described by 	 ARGUMENTS, and ARGSIZE.  It returns a block of memory 	 allocated on the stack into which is stored all the registers 	 that might possibly be used for returning the result of a 	 function.  ARGUMENTS is the value returned by 	 __builtin_apply_args.  ARGSIZE is the number of bytes of 	 arguments that must be copied.  ??? How should this value be 	 computed?  We'll also need a safe worst case value for varargs 	 functions.  */
case|case
name|BUILT_IN_APPLY
case|:
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
operator|&&
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REFERENCE_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|rtx
name|ops
index|[
literal|3
index|]
decl_stmt|;
for|for
control|(
name|t
operator|=
name|arglist
operator|,
name|i
operator|=
literal|0
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|i
operator|++
control|)
name|ops
index|[
name|i
index|]
operator|=
name|expand_normal
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expand_builtin_apply
argument_list|(
name|ops
index|[
literal|0
index|]
argument_list|,
name|ops
index|[
literal|1
index|]
argument_list|,
name|ops
index|[
literal|2
index|]
argument_list|)
return|;
block|}
comment|/* __builtin_return (RESULT) causes the function to return the 	 value described by RESULT.  RESULT is address of the block of 	 memory returned by __builtin_apply.  */
case|case
name|BUILT_IN_RETURN
case|:
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
name|expand_builtin_return
argument_list|(
name|expand_normal
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|BUILT_IN_SAVEREGS
case|:
return|return
name|expand_builtin_saveregs
argument_list|()
return|;
case|case
name|BUILT_IN_ARGS_INFO
case|:
return|return
name|expand_builtin_args_info
argument_list|(
name|arglist
argument_list|)
return|;
comment|/* Return the address of the first anonymous stack arg.  */
case|case
name|BUILT_IN_NEXT_ARG
case|:
if|if
condition|(
name|fold_builtin_next_arg
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
return|return
name|expand_builtin_next_arg
argument_list|()
return|;
case|case
name|BUILT_IN_CLASSIFY_TYPE
case|:
return|return
name|expand_builtin_classify_type
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_CONSTANT_P
case|:
return|return
name|const0_rtx
return|;
case|case
name|BUILT_IN_FRAME_ADDRESS
case|:
case|case
name|BUILT_IN_RETURN_ADDRESS
case|:
return|return
name|expand_builtin_frame_address
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
comment|/* Returns the address of the area where the structure is returned.        0 otherwise.  */
case|case
name|BUILT_IN_AGGREGATE_INCOMING_ADDRESS
case|:
if|if
condition|(
name|arglist
operator|!=
literal|0
operator|||
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|||
operator|!
name|MEM_P
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
else|else
return|return
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|BUILT_IN_ALLOCA
case|:
name|target
operator|=
name|expand_builtin_alloca
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STACK_SAVE
case|:
return|return
name|expand_stack_save
argument_list|()
return|;
case|case
name|BUILT_IN_STACK_RESTORE
case|:
name|expand_stack_restore
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
name|CASE_INT_FN
argument_list|(
name|BUILT_IN_FFS
argument_list|)
operator|:
case|case
name|BUILT_IN_FFSIMAX
case|:
name|target
operator|=
name|expand_builtin_unop
argument_list|(
name|target_mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|,
name|ffs_optab
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
name|CASE_INT_FN
argument_list|(
name|BUILT_IN_CLZ
argument_list|)
operator|:
case|case
name|BUILT_IN_CLZIMAX
case|:
name|target
operator|=
name|expand_builtin_unop
argument_list|(
name|target_mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|,
name|clz_optab
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
name|CASE_INT_FN
argument_list|(
name|BUILT_IN_CTZ
argument_list|)
operator|:
case|case
name|BUILT_IN_CTZIMAX
case|:
name|target
operator|=
name|expand_builtin_unop
argument_list|(
name|target_mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|,
name|ctz_optab
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
name|CASE_INT_FN
argument_list|(
name|BUILT_IN_POPCOUNT
argument_list|)
operator|:
case|case
name|BUILT_IN_POPCOUNTIMAX
case|:
name|target
operator|=
name|expand_builtin_unop
argument_list|(
name|target_mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|,
name|popcount_optab
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
name|CASE_INT_FN
argument_list|(
name|BUILT_IN_PARITY
argument_list|)
operator|:
case|case
name|BUILT_IN_PARITYIMAX
case|:
name|target
operator|=
name|expand_builtin_unop
argument_list|(
name|target_mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|,
name|parity_optab
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRLEN
case|:
name|target
operator|=
name|expand_builtin_strlen
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|target_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRCPY
case|:
name|target
operator|=
name|expand_builtin_strcpy
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRNCPY
case|:
name|target
operator|=
name|expand_builtin_strncpy
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STPCPY
case|:
name|target
operator|=
name|expand_builtin_stpcpy
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRCAT
case|:
name|target
operator|=
name|expand_builtin_strcat
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRNCAT
case|:
name|target
operator|=
name|expand_builtin_strncat
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRSPN
case|:
name|target
operator|=
name|expand_builtin_strspn
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRCSPN
case|:
name|target
operator|=
name|expand_builtin_strcspn
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRSTR
case|:
name|target
operator|=
name|expand_builtin_strstr
argument_list|(
name|arglist
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRPBRK
case|:
name|target
operator|=
name|expand_builtin_strpbrk
argument_list|(
name|arglist
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_INDEX
case|:
case|case
name|BUILT_IN_STRCHR
case|:
name|target
operator|=
name|expand_builtin_strchr
argument_list|(
name|arglist
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_RINDEX
case|:
case|case
name|BUILT_IN_STRRCHR
case|:
name|target
operator|=
name|expand_builtin_strrchr
argument_list|(
name|arglist
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_MEMCPY
case|:
name|target
operator|=
name|expand_builtin_memcpy
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_MEMPCPY
case|:
name|target
operator|=
name|expand_builtin_mempcpy
argument_list|(
name|arglist
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
comment|/*endp=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_MEMMOVE
case|:
name|target
operator|=
name|expand_builtin_memmove
argument_list|(
name|arglist
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_BCOPY
case|:
name|target
operator|=
name|expand_builtin_bcopy
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_MEMSET
case|:
name|target
operator|=
name|expand_builtin_memset
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_BZERO
case|:
name|target
operator|=
name|expand_builtin_bzero
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRCMP
case|:
name|target
operator|=
name|expand_builtin_strcmp
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRNCMP
case|:
name|target
operator|=
name|expand_builtin_strncmp
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_BCMP
case|:
case|case
name|BUILT_IN_MEMCMP
case|:
name|target
operator|=
name|expand_builtin_memcmp
argument_list|(
name|exp
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_SETJMP
case|:
comment|/* This should have been lowered to the builtins below.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|BUILT_IN_SETJMP_SETUP
case|:
comment|/* __builtin_setjmp_setup is passed a pointer to an array of five words           and the receiver label.  */
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|rtx
name|buf_addr
init|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
decl_stmt|;
name|tree
name|label
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|label_r
init|=
name|label_rtx
argument_list|(
name|label
argument_list|)
decl_stmt|;
comment|/* This is copied from the handling of non-local gotos.  */
name|expand_builtin_setjmp_setup
argument_list|(
name|buf_addr
argument_list|,
name|label_r
argument_list|)
expr_stmt|;
name|nonlocal_goto_handler_labels
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|label_r
argument_list|,
name|nonlocal_goto_handler_labels
argument_list|)
expr_stmt|;
comment|/* ??? Do not let expand_label treat us as such since we would 	     not want to be both on the list of non-local labels and on 	     the list of forced labels.  */
name|FORCED_LABEL
argument_list|(
name|label
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
break|break;
case|case
name|BUILT_IN_SETJMP_DISPATCHER
case|:
comment|/* __builtin_setjmp_dispatcher is passed the dispatcher label.  */
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|label
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|label_r
init|=
name|label_rtx
argument_list|(
name|label
argument_list|)
decl_stmt|;
comment|/* Remove the dispatcher label from the list of non-local labels 	     since the receiver labels have been added to it above.  */
name|remove_node_from_expr_list
argument_list|(
name|label_r
argument_list|,
operator|&
name|nonlocal_goto_handler_labels
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
break|break;
case|case
name|BUILT_IN_SETJMP_RECEIVER
case|:
comment|/* __builtin_setjmp_receiver is passed the receiver label.  */
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|label
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|label_r
init|=
name|label_rtx
argument_list|(
name|label
argument_list|)
decl_stmt|;
name|expand_builtin_setjmp_receiver
argument_list|(
name|label_r
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
break|break;
comment|/* __builtin_longjmp is passed a pointer to an array of five words. 	 It's similar to the C library longjmp function but works with 	 __builtin_setjmp above.  */
case|case
name|BUILT_IN_LONGJMP
case|:
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|rtx
name|buf_addr
init|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
decl_stmt|;
name|rtx
name|value
init|=
name|expand_normal
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|const1_rtx
condition|)
block|{
name|error
argument_list|(
literal|"%<__builtin_longjmp%> second argument must be 1"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|expand_builtin_longjmp
argument_list|(
name|buf_addr
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
break|break;
case|case
name|BUILT_IN_NONLOCAL_GOTO
case|:
name|target
operator|=
name|expand_builtin_nonlocal_goto
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
comment|/* This updates the setjmp buffer that is its argument with the value 	 of the current stack pointer.  */
case|case
name|BUILT_IN_UPDATE_SETJMP_BUF
case|:
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|rtx
name|buf_addr
init|=
name|expand_normal
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|expand_builtin_update_setjmp_buf
argument_list|(
name|buf_addr
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
break|break;
case|case
name|BUILT_IN_TRAP
case|:
name|expand_builtin_trap
argument_list|()
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|BUILT_IN_PRINTF
case|:
name|target
operator|=
name|expand_builtin_printf
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_PRINTF_UNLOCKED
case|:
name|target
operator|=
name|expand_builtin_printf
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FPUTS
case|:
name|target
operator|=
name|expand_builtin_fputs
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FPUTS_UNLOCKED
case|:
name|target
operator|=
name|expand_builtin_fputs
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FPRINTF
case|:
name|target
operator|=
name|expand_builtin_fprintf
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FPRINTF_UNLOCKED
case|:
name|target
operator|=
name|expand_builtin_fprintf
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_SPRINTF
case|:
name|target
operator|=
name|expand_builtin_sprintf
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_SIGNBIT
argument_list|)
operator|:
name|target
operator|=
name|expand_builtin_signbit
argument_list|(
name|exp
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
comment|/* Various hooks for the DWARF 2 __throw routine.  */
case|case
name|BUILT_IN_UNWIND_INIT
case|:
name|expand_builtin_unwind_init
argument_list|()
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|BUILT_IN_DWARF_CFA
case|:
return|return
name|virtual_cfa_rtx
return|;
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
case|case
name|BUILT_IN_DWARF_SP_COLUMN
case|:
return|return
name|expand_builtin_dwarf_sp_column
argument_list|()
return|;
case|case
name|BUILT_IN_INIT_DWARF_REG_SIZES
case|:
name|expand_builtin_init_dwarf_reg_sizes
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
endif|#
directive|endif
case|case
name|BUILT_IN_FROB_RETURN_ADDR
case|:
return|return
name|expand_builtin_frob_return_addr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
return|;
case|case
name|BUILT_IN_EXTRACT_RETURN_ADDR
case|:
return|return
name|expand_builtin_extract_return_addr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
return|;
case|case
name|BUILT_IN_EH_RETURN
case|:
name|expand_builtin_eh_return
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
ifdef|#
directive|ifdef
name|EH_RETURN_DATA_REGNO
case|case
name|BUILT_IN_EH_RETURN_DATA_REGNO
case|:
return|return
name|expand_builtin_eh_return_data_regno
argument_list|(
name|arglist
argument_list|)
return|;
endif|#
directive|endif
case|case
name|BUILT_IN_EXTEND_POINTER
case|:
return|return
name|expand_builtin_extend_pointer
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
return|;
case|case
name|BUILT_IN_VA_START
case|:
case|case
name|BUILT_IN_STDARG_START
case|:
return|return
name|expand_builtin_va_start
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_VA_END
case|:
return|return
name|expand_builtin_va_end
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_VA_COPY
case|:
return|return
name|expand_builtin_va_copy
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_EXPECT
case|:
return|return
name|expand_builtin_expect
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|BUILT_IN_PREFETCH
case|:
name|expand_builtin_prefetch
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|BUILT_IN_PROFILE_FUNC_ENTER
case|:
return|return
name|expand_builtin_profile_func
argument_list|(
name|false
argument_list|)
return|;
case|case
name|BUILT_IN_PROFILE_FUNC_EXIT
case|:
return|return
name|expand_builtin_profile_func
argument_list|(
name|true
argument_list|)
return|;
case|case
name|BUILT_IN_INIT_TRAMPOLINE
case|:
return|return
name|expand_builtin_init_trampoline
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_ADJUST_TRAMPOLINE
case|:
return|return
name|expand_builtin_adjust_trampoline
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_FORK
case|:
case|case
name|BUILT_IN_EXECL
case|:
case|case
name|BUILT_IN_EXECV
case|:
case|case
name|BUILT_IN_EXECLP
case|:
case|case
name|BUILT_IN_EXECLE
case|:
case|case
name|BUILT_IN_EXECVP
case|:
case|case
name|BUILT_IN_EXECVE
case|:
name|target
operator|=
name|expand_builtin_fork_or_exec
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FETCH_AND_ADD_1
case|:
case|case
name|BUILT_IN_FETCH_AND_ADD_2
case|:
case|case
name|BUILT_IN_FETCH_AND_ADD_4
case|:
case|case
name|BUILT_IN_FETCH_AND_ADD_8
case|:
case|case
name|BUILT_IN_FETCH_AND_ADD_16
case|:
name|mode
operator|=
name|get_builtin_sync_mode
argument_list|(
name|fcode
operator|-
name|BUILT_IN_FETCH_AND_ADD_1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_builtin_sync_operation
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|,
name|PLUS
argument_list|,
name|false
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FETCH_AND_SUB_1
case|:
case|case
name|BUILT_IN_FETCH_AND_SUB_2
case|:
case|case
name|BUILT_IN_FETCH_AND_SUB_4
case|:
case|case
name|BUILT_IN_FETCH_AND_SUB_8
case|:
case|case
name|BUILT_IN_FETCH_AND_SUB_16
case|:
name|mode
operator|=
name|get_builtin_sync_mode
argument_list|(
name|fcode
operator|-
name|BUILT_IN_FETCH_AND_SUB_1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_builtin_sync_operation
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|,
name|MINUS
argument_list|,
name|false
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FETCH_AND_OR_1
case|:
case|case
name|BUILT_IN_FETCH_AND_OR_2
case|:
case|case
name|BUILT_IN_FETCH_AND_OR_4
case|:
case|case
name|BUILT_IN_FETCH_AND_OR_8
case|:
case|case
name|BUILT_IN_FETCH_AND_OR_16
case|:
name|mode
operator|=
name|get_builtin_sync_mode
argument_list|(
name|fcode
operator|-
name|BUILT_IN_FETCH_AND_OR_1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_builtin_sync_operation
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|,
name|IOR
argument_list|,
name|false
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FETCH_AND_AND_1
case|:
case|case
name|BUILT_IN_FETCH_AND_AND_2
case|:
case|case
name|BUILT_IN_FETCH_AND_AND_4
case|:
case|case
name|BUILT_IN_FETCH_AND_AND_8
case|:
case|case
name|BUILT_IN_FETCH_AND_AND_16
case|:
name|mode
operator|=
name|get_builtin_sync_mode
argument_list|(
name|fcode
operator|-
name|BUILT_IN_FETCH_AND_AND_1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_builtin_sync_operation
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|,
name|AND
argument_list|,
name|false
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FETCH_AND_XOR_1
case|:
case|case
name|BUILT_IN_FETCH_AND_XOR_2
case|:
case|case
name|BUILT_IN_FETCH_AND_XOR_4
case|:
case|case
name|BUILT_IN_FETCH_AND_XOR_8
case|:
case|case
name|BUILT_IN_FETCH_AND_XOR_16
case|:
name|mode
operator|=
name|get_builtin_sync_mode
argument_list|(
name|fcode
operator|-
name|BUILT_IN_FETCH_AND_XOR_1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_builtin_sync_operation
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|,
name|XOR
argument_list|,
name|false
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FETCH_AND_NAND_1
case|:
case|case
name|BUILT_IN_FETCH_AND_NAND_2
case|:
case|case
name|BUILT_IN_FETCH_AND_NAND_4
case|:
case|case
name|BUILT_IN_FETCH_AND_NAND_8
case|:
case|case
name|BUILT_IN_FETCH_AND_NAND_16
case|:
name|mode
operator|=
name|get_builtin_sync_mode
argument_list|(
name|fcode
operator|-
name|BUILT_IN_FETCH_AND_NAND_1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_builtin_sync_operation
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|,
name|NOT
argument_list|,
name|false
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_ADD_AND_FETCH_1
case|:
case|case
name|BUILT_IN_ADD_AND_FETCH_2
case|:
case|case
name|BUILT_IN_ADD_AND_FETCH_4
case|:
case|case
name|BUILT_IN_ADD_AND_FETCH_8
case|:
case|case
name|BUILT_IN_ADD_AND_FETCH_16
case|:
name|mode
operator|=
name|get_builtin_sync_mode
argument_list|(
name|fcode
operator|-
name|BUILT_IN_ADD_AND_FETCH_1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_builtin_sync_operation
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|,
name|PLUS
argument_list|,
name|true
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_SUB_AND_FETCH_1
case|:
case|case
name|BUILT_IN_SUB_AND_FETCH_2
case|:
case|case
name|BUILT_IN_SUB_AND_FETCH_4
case|:
case|case
name|BUILT_IN_SUB_AND_FETCH_8
case|:
case|case
name|BUILT_IN_SUB_AND_FETCH_16
case|:
name|mode
operator|=
name|get_builtin_sync_mode
argument_list|(
name|fcode
operator|-
name|BUILT_IN_SUB_AND_FETCH_1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_builtin_sync_operation
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|,
name|MINUS
argument_list|,
name|true
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_OR_AND_FETCH_1
case|:
case|case
name|BUILT_IN_OR_AND_FETCH_2
case|:
case|case
name|BUILT_IN_OR_AND_FETCH_4
case|:
case|case
name|BUILT_IN_OR_AND_FETCH_8
case|:
case|case
name|BUILT_IN_OR_AND_FETCH_16
case|:
name|mode
operator|=
name|get_builtin_sync_mode
argument_list|(
name|fcode
operator|-
name|BUILT_IN_OR_AND_FETCH_1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_builtin_sync_operation
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|,
name|IOR
argument_list|,
name|true
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_AND_AND_FETCH_1
case|:
case|case
name|BUILT_IN_AND_AND_FETCH_2
case|:
case|case
name|BUILT_IN_AND_AND_FETCH_4
case|:
case|case
name|BUILT_IN_AND_AND_FETCH_8
case|:
case|case
name|BUILT_IN_AND_AND_FETCH_16
case|:
name|mode
operator|=
name|get_builtin_sync_mode
argument_list|(
name|fcode
operator|-
name|BUILT_IN_AND_AND_FETCH_1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_builtin_sync_operation
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|,
name|AND
argument_list|,
name|true
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_XOR_AND_FETCH_1
case|:
case|case
name|BUILT_IN_XOR_AND_FETCH_2
case|:
case|case
name|BUILT_IN_XOR_AND_FETCH_4
case|:
case|case
name|BUILT_IN_XOR_AND_FETCH_8
case|:
case|case
name|BUILT_IN_XOR_AND_FETCH_16
case|:
name|mode
operator|=
name|get_builtin_sync_mode
argument_list|(
name|fcode
operator|-
name|BUILT_IN_XOR_AND_FETCH_1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_builtin_sync_operation
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|,
name|XOR
argument_list|,
name|true
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_NAND_AND_FETCH_1
case|:
case|case
name|BUILT_IN_NAND_AND_FETCH_2
case|:
case|case
name|BUILT_IN_NAND_AND_FETCH_4
case|:
case|case
name|BUILT_IN_NAND_AND_FETCH_8
case|:
case|case
name|BUILT_IN_NAND_AND_FETCH_16
case|:
name|mode
operator|=
name|get_builtin_sync_mode
argument_list|(
name|fcode
operator|-
name|BUILT_IN_NAND_AND_FETCH_1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_builtin_sync_operation
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|,
name|NOT
argument_list|,
name|true
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_BOOL_COMPARE_AND_SWAP_1
case|:
case|case
name|BUILT_IN_BOOL_COMPARE_AND_SWAP_2
case|:
case|case
name|BUILT_IN_BOOL_COMPARE_AND_SWAP_4
case|:
case|case
name|BUILT_IN_BOOL_COMPARE_AND_SWAP_8
case|:
case|case
name|BUILT_IN_BOOL_COMPARE_AND_SWAP_16
case|:
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|boolean_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
operator|!
name|register_operand
argument_list|(
name|target
argument_list|,
name|mode
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|mode
operator|=
name|get_builtin_sync_mode
argument_list|(
name|fcode
operator|-
name|BUILT_IN_BOOL_COMPARE_AND_SWAP_1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_builtin_compare_and_swap
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|,
name|true
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_VAL_COMPARE_AND_SWAP_1
case|:
case|case
name|BUILT_IN_VAL_COMPARE_AND_SWAP_2
case|:
case|case
name|BUILT_IN_VAL_COMPARE_AND_SWAP_4
case|:
case|case
name|BUILT_IN_VAL_COMPARE_AND_SWAP_8
case|:
case|case
name|BUILT_IN_VAL_COMPARE_AND_SWAP_16
case|:
name|mode
operator|=
name|get_builtin_sync_mode
argument_list|(
name|fcode
operator|-
name|BUILT_IN_VAL_COMPARE_AND_SWAP_1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_builtin_compare_and_swap
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|,
name|false
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_LOCK_TEST_AND_SET_1
case|:
case|case
name|BUILT_IN_LOCK_TEST_AND_SET_2
case|:
case|case
name|BUILT_IN_LOCK_TEST_AND_SET_4
case|:
case|case
name|BUILT_IN_LOCK_TEST_AND_SET_8
case|:
case|case
name|BUILT_IN_LOCK_TEST_AND_SET_16
case|:
name|mode
operator|=
name|get_builtin_sync_mode
argument_list|(
name|fcode
operator|-
name|BUILT_IN_LOCK_TEST_AND_SET_1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_builtin_lock_test_and_set
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_LOCK_RELEASE_1
case|:
case|case
name|BUILT_IN_LOCK_RELEASE_2
case|:
case|case
name|BUILT_IN_LOCK_RELEASE_4
case|:
case|case
name|BUILT_IN_LOCK_RELEASE_8
case|:
case|case
name|BUILT_IN_LOCK_RELEASE_16
case|:
name|mode
operator|=
name|get_builtin_sync_mode
argument_list|(
name|fcode
operator|-
name|BUILT_IN_LOCK_RELEASE_1
argument_list|)
expr_stmt|;
name|expand_builtin_lock_release
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|BUILT_IN_SYNCHRONIZE
case|:
name|expand_builtin_synchronize
argument_list|()
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|BUILT_IN_OBJECT_SIZE
case|:
return|return
name|expand_builtin_object_size
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|BUILT_IN_MEMCPY_CHK
case|:
case|case
name|BUILT_IN_MEMPCPY_CHK
case|:
case|case
name|BUILT_IN_MEMMOVE_CHK
case|:
case|case
name|BUILT_IN_MEMSET_CHK
case|:
name|target
operator|=
name|expand_builtin_memory_chk
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|fcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRCPY_CHK
case|:
case|case
name|BUILT_IN_STPCPY_CHK
case|:
case|case
name|BUILT_IN_STRNCPY_CHK
case|:
case|case
name|BUILT_IN_STRCAT_CHK
case|:
case|case
name|BUILT_IN_SNPRINTF_CHK
case|:
case|case
name|BUILT_IN_VSNPRINTF_CHK
case|:
name|maybe_emit_chk_warning
argument_list|(
name|exp
argument_list|,
name|fcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUILT_IN_SPRINTF_CHK
case|:
case|case
name|BUILT_IN_VSPRINTF_CHK
case|:
name|maybe_emit_sprintf_chk_warning
argument_list|(
name|exp
argument_list|,
name|fcode
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* just do library call, if unknown builtin */
break|break;
block|}
comment|/* The switch statement above can drop through to cause the function      to be called normally.  */
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine whether a tree node represents a call to a built-in    function.  If the tree T is a call to a built-in function with    the right number of arguments of the appropriate types, return    the DECL_FUNCTION_CODE of the call, e.g. BUILT_IN_SQRT.    Otherwise the return value is END_BUILTINS.  */
end_comment

begin_function
name|enum
name|built_in_function
name|builtin_mathfn_code
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|fndecl
decl_stmt|,
name|arglist
decl_stmt|,
name|parmlist
decl_stmt|;
name|tree
name|argtype
decl_stmt|,
name|parmtype
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|CALL_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
return|return
name|END_BUILTINS
return|;
name|fndecl
operator|=
name|get_callee_fndecl
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
operator|||
name|DECL_BUILT_IN_CLASS
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_MD
condition|)
return|return
name|END_BUILTINS
return|;
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|parmlist
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|parmlist
condition|;
name|parmlist
operator|=
name|TREE_CHAIN
argument_list|(
name|parmlist
argument_list|)
control|)
block|{
comment|/* If a function doesn't take a variable number of arguments, 	 the last element in the list will have type `void'.  */
name|parmtype
operator|=
name|TREE_VALUE
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
if|if
condition|(
name|arglist
condition|)
return|return
name|END_BUILTINS
return|;
return|return
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
name|END_BUILTINS
return|;
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|argtype
argument_list|)
condition|)
return|return
name|END_BUILTINS
return|;
block|}
elseif|else
if|if
condition|(
name|COMPLEX_FLOAT_TYPE_P
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|COMPLEX_FLOAT_TYPE_P
argument_list|(
name|argtype
argument_list|)
condition|)
return|return
name|END_BUILTINS
return|;
block|}
elseif|else
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|argtype
argument_list|)
condition|)
return|return
name|END_BUILTINS
return|;
block|}
elseif|else
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|argtype
argument_list|)
condition|)
return|return
name|END_BUILTINS
return|;
block|}
else|else
return|return
name|END_BUILTINS
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
block|}
comment|/* Variable-length argument list.  */
return|return
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to __builtin_constant_p, if we know it will evaluate to a    constant.  ARGLIST is the argument list of the call.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_constant_p
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
if|if
condition|(
name|arglist
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* We return 1 for a numeric type that's known to be a constant      value at compile-time or for an aggregate type that's a      literal constant.  */
name|STRIP_NOPS
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* If we know this is a constant, emit the constant of one.  */
if|if
condition|(
name|CONSTANT_CLASS_P
argument_list|(
name|arglist
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arglist
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_CONSTANT
argument_list|(
name|arglist
argument_list|)
operator|)
condition|)
return|return
name|integer_one_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arglist
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|arglist
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|STRING_CST
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ARRAY_REF
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
operator|)
condition|)
return|return
name|integer_one_node
return|;
block|}
comment|/* If this expression has side effects, show we don't know it to be a      constant.  Likewise if it's a pointer or aggregate type since in      those case we only want literals, since those are only optimized      when generating RTL, not later.      And finally, if we are compiling an initializer, not code, we      need to return a definite result now; there's not going to be any      more optimization done.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|arglist
argument_list|)
operator|||
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|||
name|cfun
operator|==
literal|0
operator|||
name|folding_initializer
condition|)
return|return
name|integer_zero_node
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to __builtin_expect, if we expect that a comparison against    the argument will fold to a constant.  In practice, this means a true    constant or the address of a non-weak symbol.  ARGLIST is the argument    list of the call.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_expect
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|arg
decl_stmt|,
name|inner
decl_stmt|;
if|if
condition|(
name|arglist
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* If the argument isn't invariant, then there's nothing we can do.  */
if|if
condition|(
operator|!
name|TREE_INVARIANT
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If we're looking at an address of a weak decl, then do not fold.  */
name|inner
operator|=
name|arg
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|inner
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
do|do
block|{
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|ARRAY_REF
condition|)
do|;
if|if
condition|(
name|DECL_P
argument_list|(
name|inner
argument_list|)
operator|&&
name|DECL_WEAK
argument_list|(
name|inner
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Otherwise, ARG already has the proper type for the return value.  */
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to __builtin_classify_type.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_classify_type
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
if|if
condition|(
name|arglist
operator|==
literal|0
condition|)
return|return
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|no_type_class
argument_list|)
return|;
return|return
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|type_to_class
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to __builtin_strlen.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_strlen
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
else|else
block|{
name|tree
name|len
init|=
name|c_strlen
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
condition|)
block|{
comment|/* Convert from the internal "sizetype" type to "size_t".  */
if|if
condition|(
name|size_type_node
condition|)
name|len
operator|=
name|fold_convert
argument_list|(
name|size_type_node
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Fold a call to __builtin_inf or __builtin_huge_val.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_inf
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|warn
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|real
decl_stmt|;
comment|/* __builtin_inff is intended to be usable to define INFINITY on all      targets.  If an infinity is not available, INFINITY expands "to a      positive constant of type float that overflows at translation      time", footnote "In this case, using INFINITY will violate the      constraint in 6.4.4 and thus require a diagnostic." (C99 7.12#4).      Thus we pedwarn to ensure this constraint violation is      diagnosed.  */
if|if
condition|(
operator|!
name|MODE_HAS_INFINITIES
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|warn
condition|)
name|pedwarn
argument_list|(
literal|"target format does not support infinity"
argument_list|)
expr_stmt|;
name|real_inf
argument_list|(
operator|&
name|real
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|real
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to __builtin_nan or __builtin_nans.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_nan
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|real
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|str
operator|=
name|c_getstr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|real_nan
argument_list|(
operator|&
name|real
argument_list|,
name|str
argument_list|,
name|quiet
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|real
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the floating point expression T has an integer value.    We also allow +Inf, -Inf and NaN to be considered integer values.  */
end_comment

begin_function
specifier|static
name|bool
name|integer_valued_real_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FLOAT_EXPR
case|:
return|return
name|true
return|;
case|case
name|ABS_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|integer_valued_real_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|BIND_EXPR
case|:
return|return
name|integer_valued_real_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
return|return
name|integer_valued_real_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|integer_valued_real_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
return|return
name|integer_valued_real_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_valued_real_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
case|case
name|REAL_CST
case|:
if|if
condition|(
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|c
decl_stmt|,
name|cint
decl_stmt|;
name|c
operator|=
name|TREE_REAL_CST
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|real_trunc
argument_list|(
operator|&
name|cint
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
return|return
name|real_identical
argument_list|(
operator|&
name|c
argument_list|,
operator|&
name|cint
argument_list|)
return|;
block|}
break|break;
case|case
name|NOP_EXPR
case|:
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
return|return
name|integer_valued_real_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
block|}
case|case
name|CALL_EXPR
case|:
switch|switch
condition|(
name|builtin_mathfn_code
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_CEIL
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_FLOOR
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_NEARBYINT
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_RINT
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ROUND
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_TRUNC
argument_list|)
operator|:
return|return
name|true
return|;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* EXP is assumed to be builtin call where truncation can be propagated    across (for instance floor((double)f) == (double)floorf (f).    Do the transformation.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_trunc_transparent_mathfn
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|enum
name|built_in_function
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* Integer rounding functions are idempotent.  */
if|if
condition|(
name|fcode
operator|==
name|builtin_mathfn_code
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|arg
return|;
comment|/* If argument is already integer valued, and we don't need to worry      about setting errno, there's no need to perform rounding.  */
if|if
condition|(
operator|!
name|flag_errno_math
operator|&&
name|integer_valued_real_p
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|arg
return|;
if|if
condition|(
name|optimize
condition|)
block|{
name|tree
name|arg0
init|=
name|strip_float_extensions
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|ftype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|newtype
init|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|newtype
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|ftype
argument_list|)
operator|&&
operator|(
name|decl
operator|=
name|mathfn_built_in
argument_list|(
name|newtype
argument_list|,
name|fcode
argument_list|)
operator|)
condition|)
block|{
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fold_convert
argument_list|(
name|newtype
argument_list|,
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|ftype
argument_list|,
name|build_function_call_expr
argument_list|(
name|decl
argument_list|,
name|arglist
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* EXP is assumed to be builtin call which can narrow the FP type of    the argument, for instance lround((double)f) -> lroundf (f).  */
end_comment

begin_function
specifier|static
name|tree
name|fold_fixed_mathfn
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|enum
name|built_in_function
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* If argument is already integer valued, and we don't need to worry      about setting errno, there's no need to perform rounding.  */
if|if
condition|(
operator|!
name|flag_errno_math
operator|&&
name|integer_valued_real_p
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|fold_build1
argument_list|(
name|FIX_TRUNC_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
return|;
if|if
condition|(
name|optimize
condition|)
block|{
name|tree
name|ftype
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|arg0
init|=
name|strip_float_extensions
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|newtype
init|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|newtype
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|ftype
argument_list|)
operator|&&
operator|(
name|decl
operator|=
name|mathfn_built_in
argument_list|(
name|newtype
argument_list|,
name|fcode
argument_list|)
operator|)
condition|)
block|{
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fold_convert
argument_list|(
name|newtype
argument_list|,
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|decl
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
comment|/* Canonicalize llround (x) to lround (x) on LP64 targets where      sizeof (long long) == sizeof (long).  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
block|{
name|tree
name|newfn
init|=
name|NULL_TREE
decl_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLCEIL
argument_list|)
operator|:
name|newfn
operator|=
name|mathfn_built_in
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|BUILT_IN_LCEIL
argument_list|)
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLFLOOR
argument_list|)
operator|:
name|newfn
operator|=
name|mathfn_built_in
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|BUILT_IN_LFLOOR
argument_list|)
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLROUND
argument_list|)
operator|:
name|newfn
operator|=
name|mathfn_built_in
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|BUILT_IN_LROUND
argument_list|)
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLRINT
argument_list|)
operator|:
name|newfn
operator|=
name|mathfn_built_in
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|BUILT_IN_LRINT
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|newfn
condition|)
block|{
name|tree
name|newcall
init|=
name|build_function_call_expr
argument_list|(
name|newfn
argument_list|,
name|arglist
argument_list|)
decl_stmt|;
return|return
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|newcall
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin cabs, cabsf or cabsl.  ARGLIST    is the argument list, TYPE is the return type and FNDECL is the    original function DECL.  Return NULL_TREE if no if no simplification    can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_cabs
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|fndecl
parameter_list|)
block|{
name|tree
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|arglist
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
name|COMPLEX_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Evaluate cabs of a constant at compile-time.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_REALPART
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|TREE_REALPART
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|,
name|i
decl_stmt|;
name|r
operator|=
name|TREE_REAL_CST
argument_list|(
name|TREE_REALPART
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|TREE_REAL_CST
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|r
argument_list|,
name|MULT_EXPR
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|i
argument_list|,
name|MULT_EXPR
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|r
argument_list|,
name|PLUS_EXPR
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_sqrt
argument_list|(
operator|&
name|r
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|r
argument_list|)
operator|||
operator|!
name|flag_trapping_math
condition|)
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|r
argument_list|)
return|;
block|}
comment|/* If either part is zero, cabs is fabs of the other.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_EXPR
operator|&&
name|real_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold_build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_EXPR
operator|&&
name|real_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|fold_build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Optimize cabs(-z) and cabs(conj(z)) as cabs(z).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NEGATE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONJ_EXPR
condition|)
block|{
name|tree
name|arglist
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
block|}
comment|/* Don't do this when optimizing for size.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|optimize
operator|&&
operator|!
name|optimize_size
condition|)
block|{
name|tree
name|sqrtfn
init|=
name|mathfn_built_in
argument_list|(
name|type
argument_list|,
name|BUILT_IN_SQRT
argument_list|)
decl_stmt|;
if|if
condition|(
name|sqrtfn
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|rpart
decl_stmt|,
name|ipart
decl_stmt|,
name|result
decl_stmt|,
name|arglist
decl_stmt|;
name|arg
operator|=
name|builtin_save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|rpart
operator|=
name|fold_build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|ipart
operator|=
name|fold_build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|rpart
operator|=
name|builtin_save_expr
argument_list|(
name|rpart
argument_list|)
expr_stmt|;
name|ipart
operator|=
name|builtin_save_expr
argument_list|(
name|ipart
argument_list|)
expr_stmt|;
name|result
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|rpart
argument_list|,
name|rpart
argument_list|)
argument_list|,
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|ipart
argument_list|,
name|ipart
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|sqrtfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Fold a builtin function call to sqrt, sqrtf, or sqrtl.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_sqrt
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|enum
name|built_in_function
name|fcode
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Optimize sqrt of constant value.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|,
name|x
decl_stmt|;
name|x
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_sqrt
argument_list|(
operator|&
name|r
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|x
argument_list|)
operator|||
operator|(
operator|!
name|flag_trapping_math
operator|&&
operator|!
name|flag_errno_math
operator|)
condition|)
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|r
argument_list|)
return|;
block|}
comment|/* Optimize sqrt(expN(x)) = expN(x*0.5).  */
name|fcode
operator|=
name|builtin_mathfn_code
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|BUILTIN_EXPONENT_P
argument_list|(
name|fcode
argument_list|)
condition|)
block|{
name|tree
name|expfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|arg
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconsthalf
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|expfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
comment|/* Optimize sqrt(Nroot(x)) -> pow(x,1/(2*N)).  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|BUILTIN_ROOT_P
argument_list|(
name|fcode
argument_list|)
condition|)
block|{
name|tree
name|powfn
init|=
name|mathfn_built_in
argument_list|(
name|type
argument_list|,
name|BUILT_IN_POW
argument_list|)
decl_stmt|;
if|if
condition|(
name|powfn
condition|)
block|{
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tree_root
decl_stmt|;
comment|/* The inner root was either sqrt or cbrt.  */
name|REAL_VALUE_TYPE
name|dconstroot
init|=
name|BUILTIN_SQRT_P
argument_list|(
name|fcode
argument_list|)
condition|?
name|dconsthalf
else|:
name|dconstthird
decl_stmt|;
comment|/* Adjust for the outer root.  */
name|SET_REAL_EXP
argument_list|(
operator|&
name|dconstroot
argument_list|,
name|REAL_EXP
argument_list|(
operator|&
name|dconstroot
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dconstroot
operator|=
name|real_value_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|dconstroot
argument_list|)
expr_stmt|;
name|tree_root
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|dconstroot
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg0
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|tree_root
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
comment|/* Optimize sqrt(pow(x,y)) = pow(|x|,y*0.5).  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
operator|(
name|fcode
operator|==
name|BUILT_IN_POW
operator|||
name|fcode
operator|==
name|BUILT_IN_POWF
operator|||
name|fcode
operator|==
name|BUILT_IN_POWL
operator|)
condition|)
block|{
name|tree
name|powfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|narg1
decl_stmt|;
if|if
condition|(
operator|!
name|tree_expr_nonnegative_p
argument_list|(
name|arg0
argument_list|)
condition|)
name|arg0
operator|=
name|build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|narg1
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconsthalf
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg0
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|narg1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Fold a builtin function call to cbrt, cbrtf, or cbrtl.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_cbrt
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
specifier|const
name|enum
name|built_in_function
name|fcode
init|=
name|builtin_mathfn_code
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Optimize cbrt of constant value.  */
if|if
condition|(
name|real_zerop
argument_list|(
name|arg
argument_list|)
operator|||
name|real_onep
argument_list|(
name|arg
argument_list|)
operator|||
name|real_minus_onep
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|arg
return|;
if|if
condition|(
name|flag_unsafe_math_optimizations
condition|)
block|{
comment|/* Optimize cbrt(expN(x)) -> expN(x/3).  */
if|if
condition|(
name|BUILTIN_EXPONENT_P
argument_list|(
name|fcode
argument_list|)
condition|)
block|{
name|tree
name|expfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|REAL_VALUE_TYPE
name|third_trunc
init|=
name|real_value_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|dconstthird
argument_list|)
decl_stmt|;
name|arg
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|third_trunc
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|expfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
comment|/* Optimize cbrt(sqrt(x)) -> pow(x,1/6).  */
if|if
condition|(
name|BUILTIN_SQRT_P
argument_list|(
name|fcode
argument_list|)
condition|)
block|{
name|tree
name|powfn
init|=
name|mathfn_built_in
argument_list|(
name|type
argument_list|,
name|BUILT_IN_POW
argument_list|)
decl_stmt|;
if|if
condition|(
name|powfn
condition|)
block|{
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tree_root
decl_stmt|;
name|REAL_VALUE_TYPE
name|dconstroot
init|=
name|dconstthird
decl_stmt|;
name|SET_REAL_EXP
argument_list|(
operator|&
name|dconstroot
argument_list|,
name|REAL_EXP
argument_list|(
operator|&
name|dconstroot
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dconstroot
operator|=
name|real_value_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|dconstroot
argument_list|)
expr_stmt|;
name|tree_root
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|dconstroot
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg0
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|tree_root
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
comment|/* Optimize cbrt(cbrt(x)) -> pow(x,1/9) iff x is nonnegative.  */
if|if
condition|(
name|BUILTIN_CBRT_P
argument_list|(
name|fcode
argument_list|)
condition|)
block|{
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tree_expr_nonnegative_p
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
name|tree
name|powfn
init|=
name|mathfn_built_in
argument_list|(
name|type
argument_list|,
name|BUILT_IN_POW
argument_list|)
decl_stmt|;
if|if
condition|(
name|powfn
condition|)
block|{
name|tree
name|tree_root
decl_stmt|;
name|REAL_VALUE_TYPE
name|dconstroot
decl_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|dconstroot
argument_list|,
name|MULT_EXPR
argument_list|,
operator|&
name|dconstthird
argument_list|,
operator|&
name|dconstthird
argument_list|)
expr_stmt|;
name|dconstroot
operator|=
name|real_value_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|dconstroot
argument_list|)
expr_stmt|;
name|tree_root
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|dconstroot
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg0
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|tree_root
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
block|}
comment|/* Optimize cbrt(pow(x,y)) -> pow(x,y/3) iff x is nonnegative.  */
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_POW
operator|||
name|fcode
operator|==
name|BUILT_IN_POWF
operator|||
name|fcode
operator|==
name|BUILT_IN_POWL
condition|)
block|{
name|tree
name|arg00
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg01
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tree_expr_nonnegative_p
argument_list|(
name|arg00
argument_list|)
condition|)
block|{
name|tree
name|powfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|REAL_VALUE_TYPE
name|dconstroot
init|=
name|real_value_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|dconstthird
argument_list|)
decl_stmt|;
name|tree
name|narg01
init|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg01
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconstroot
argument_list|)
argument_list|)
decl_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg00
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|narg01
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin sin, sinf, or sinl.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_sin
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Optimize sin (0.0) = 0.0.  */
if|if
condition|(
name|real_zerop
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|arg
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin cos, cosf, or cosl.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_cos
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|fndecl
parameter_list|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Optimize cos (0.0) = 1.0.  */
if|if
condition|(
name|real_zerop
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
return|;
comment|/* Optimize cos(-x) into cos (x).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
block|{
name|tree
name|args
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|args
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin tan, tanf, or tanl.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_tan
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|enum
name|built_in_function
name|fcode
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Optimize tan(0.0) = 0.0.  */
if|if
condition|(
name|real_zerop
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|arg
return|;
comment|/* Optimize tan(atan(x)) = x.  */
name|fcode
operator|=
name|builtin_mathfn_code
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
operator|(
name|fcode
operator|==
name|BUILT_IN_ATAN
operator|||
name|fcode
operator|==
name|BUILT_IN_ATANF
operator|||
name|fcode
operator|==
name|BUILT_IN_ATANL
operator|)
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin atan, atanf, or atanl.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_atan
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Optimize atan(0.0) = 0.0.  */
if|if
condition|(
name|real_zerop
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|arg
return|;
comment|/* Optimize atan(1.0) = pi/4.  */
if|if
condition|(
name|real_onep
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|cst
decl_stmt|;
name|real_convert
argument_list|(
operator|&
name|cst
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|dconstpi
argument_list|)
expr_stmt|;
name|SET_REAL_EXP
argument_list|(
operator|&
name|cst
argument_list|,
name|REAL_EXP
argument_list|(
operator|&
name|cst
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|cst
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin trunc, truncf or truncl.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_trunc
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Optimize trunc of constant value.  */
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|,
name|x
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|x
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|real_trunc
argument_list|(
operator|&
name|r
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|r
argument_list|)
return|;
block|}
return|return
name|fold_trunc_transparent_mathfn
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin floor, floorf or floorl.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_floor
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Optimize floor of constant value.  */
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
name|x
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REAL_VALUE_ISNAN
argument_list|(
name|x
argument_list|)
operator|||
operator|!
name|flag_errno_math
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|real_floor
argument_list|(
operator|&
name|r
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|r
argument_list|)
return|;
block|}
block|}
return|return
name|fold_trunc_transparent_mathfn
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin ceil, ceilf or ceill.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_ceil
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Optimize ceil of constant value.  */
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
name|x
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REAL_VALUE_ISNAN
argument_list|(
name|x
argument_list|)
operator|||
operator|!
name|flag_errno_math
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|real_ceil
argument_list|(
operator|&
name|r
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|r
argument_list|)
return|;
block|}
block|}
return|return
name|fold_trunc_transparent_mathfn
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin round, roundf or roundl.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_round
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Optimize round of constant value.  */
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
name|x
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REAL_VALUE_ISNAN
argument_list|(
name|x
argument_list|)
operator|||
operator|!
name|flag_errno_math
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|real_round
argument_list|(
operator|&
name|r
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|r
argument_list|)
return|;
block|}
block|}
return|return
name|fold_trunc_transparent_mathfn
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin lround, lroundf or lroundl (or the    corresponding long long versions) and other rounding functions.    Return NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_int_roundingfn
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Optimize lround of constant value.  */
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg
argument_list|)
condition|)
block|{
specifier|const
name|REAL_VALUE_TYPE
name|x
init|=
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|REAL_VALUE_ISNAN
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|REAL_VALUE_ISINF
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|tree
name|itype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ftype
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|,
name|result
decl_stmt|;
name|HOST_WIDE_INT
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LFLOOR
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLFLOOR
argument_list|)
operator|:
name|real_floor
argument_list|(
operator|&
name|r
argument_list|,
name|TYPE_MODE
argument_list|(
name|ftype
argument_list|)
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LCEIL
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLCEIL
argument_list|)
operator|:
name|real_ceil
argument_list|(
operator|&
name|r
argument_list|,
name|TYPE_MODE
argument_list|(
name|ftype
argument_list|)
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LROUND
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLROUND
argument_list|)
operator|:
name|real_round
argument_list|(
operator|&
name|r
argument_list|,
name|TYPE_MODE
argument_list|(
name|ftype
argument_list|)
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|REAL_VALUE_TO_INT
argument_list|(
operator|&
name|lo
argument_list|,
operator|&
name|hi
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_int_cst_wide
argument_list|(
name|NULL_TREE
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|int_fits_type_p
argument_list|(
name|result
argument_list|,
name|itype
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|itype
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
return|return
name|fold_fixed_mathfn
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin ffs, clz, ctz, popcount and parity    and their long and long long variants (i.e. ffsl and ffsll).    Return NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_bitop
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Optimize for constant argument.  */
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|hi
decl_stmt|,
name|width
decl_stmt|,
name|result
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|lo
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|width
operator|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|lo
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Clear all the bits that are beyond the type's precision.  */
if|if
condition|(
name|width
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|hi
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
name|hi
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|>>
operator|(
name|width
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|lo
operator|&=
operator|~
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|CASE_INT_FN
argument_list|(
name|BUILT_IN_FFS
argument_list|)
operator|:
if|if
condition|(
name|lo
operator|!=
literal|0
condition|)
name|result
operator|=
name|exact_log2
argument_list|(
name|lo
operator|&
operator|-
name|lo
argument_list|)
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|hi
operator|!=
literal|0
condition|)
name|result
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|+
name|exact_log2
argument_list|(
name|hi
operator|&
operator|-
name|hi
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|result
operator|=
literal|0
expr_stmt|;
break|break;
name|CASE_INT_FN
argument_list|(
name|BUILT_IN_CLZ
argument_list|)
operator|:
if|if
condition|(
name|hi
operator|!=
literal|0
condition|)
name|result
operator|=
name|width
operator|-
name|floor_log2
argument_list|(
name|hi
argument_list|)
operator|-
literal|1
operator|-
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
elseif|else
if|if
condition|(
name|lo
operator|!=
literal|0
condition|)
name|result
operator|=
name|width
operator|-
name|floor_log2
argument_list|(
name|lo
argument_list|)
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|CLZ_DEFINED_VALUE_AT_ZERO
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|result
argument_list|)
condition|)
name|result
operator|=
name|width
expr_stmt|;
break|break;
name|CASE_INT_FN
argument_list|(
name|BUILT_IN_CTZ
argument_list|)
operator|:
if|if
condition|(
name|lo
operator|!=
literal|0
condition|)
name|result
operator|=
name|exact_log2
argument_list|(
name|lo
operator|&
operator|-
name|lo
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hi
operator|!=
literal|0
condition|)
name|result
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|+
name|exact_log2
argument_list|(
name|hi
operator|&
operator|-
name|hi
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|CTZ_DEFINED_VALUE_AT_ZERO
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|result
argument_list|)
condition|)
name|result
operator|=
name|width
expr_stmt|;
break|break;
name|CASE_INT_FN
argument_list|(
name|BUILT_IN_POPCOUNT
argument_list|)
operator|:
name|result
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lo
condition|)
name|result
operator|++
operator|,
name|lo
operator|&=
name|lo
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|hi
condition|)
name|result
operator|++
operator|,
name|hi
operator|&=
name|hi
operator|-
literal|1
expr_stmt|;
break|break;
name|CASE_INT_FN
argument_list|(
name|BUILT_IN_PARITY
argument_list|)
operator|:
name|result
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lo
condition|)
name|result
operator|++
operator|,
name|lo
operator|&=
name|lo
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|hi
condition|)
name|result
operator|++
operator|,
name|hi
operator|&=
name|hi
operator|-
literal|1
expr_stmt|;
name|result
operator|&=
literal|1
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|result
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return true if EXPR is the real constant contained in VALUE.  */
end_comment

begin_function
specifier|static
name|bool
name|real_dconstp
parameter_list|(
name|tree
name|expr
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|value
parameter_list|)
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|expr
argument_list|)
argument_list|,
operator|*
name|value
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|real_dconstp
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|,
name|value
argument_list|)
operator|&&
name|real_zerop
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of fold_builtin to fold the various logarithmic    functions.  EXP is the CALL_EXPR of a call to a builtin logN    function.  VALUE is the base of the logN function.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_logarithm
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
specifier|const
name|enum
name|built_in_function
name|fcode
init|=
name|builtin_mathfn_code
argument_list|(
name|arg
argument_list|)
decl_stmt|;
comment|/* Optimize logN(1.0) = 0.0.  */
if|if
condition|(
name|real_onep
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst0
argument_list|)
return|;
comment|/* Optimize logN(N) = 1.0.  If N can't be truncated to MODE 	 exactly, then only do this if flag_unsafe_math_optimizations.  */
if|if
condition|(
name|exact_real_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|value
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
condition|)
block|{
specifier|const
name|REAL_VALUE_TYPE
name|value_truncate
init|=
name|real_value_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|*
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|real_dconstp
argument_list|(
name|arg
argument_list|,
operator|&
name|value_truncate
argument_list|)
condition|)
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
return|;
block|}
comment|/* Special case, optimize logN(expN(x)) = x.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
operator|(
operator|(
name|value
operator|==
operator|&
name|dconste
operator|&&
operator|(
name|fcode
operator|==
name|BUILT_IN_EXP
operator|||
name|fcode
operator|==
name|BUILT_IN_EXPF
operator|||
name|fcode
operator|==
name|BUILT_IN_EXPL
operator|)
operator|)
operator|||
operator|(
name|value
operator|==
operator|&
name|dconst2
operator|&&
operator|(
name|fcode
operator|==
name|BUILT_IN_EXP2
operator|||
name|fcode
operator|==
name|BUILT_IN_EXP2F
operator|||
name|fcode
operator|==
name|BUILT_IN_EXP2L
operator|)
operator|)
operator|||
operator|(
name|value
operator|==
operator|&
name|dconst10
operator|&&
operator|(
name|BUILTIN_EXP10_P
argument_list|(
name|fcode
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Optimize logN(func()) for various exponential functions.  We 	 want to determine the value "x" and the power "exponent" in 	 order to transform logN(x**exponent) into exponent*logN(x).  */
if|if
condition|(
name|flag_unsafe_math_optimizations
condition|)
block|{
name|tree
name|exponent
init|=
literal|0
decl_stmt|,
name|x
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_EXP
argument_list|)
operator|:
comment|/* Prepare to do logN(exp(exponent) -> exponent*logN(e).  */
name|x
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|real_value_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|dconste
argument_list|)
argument_list|)
expr_stmt|;
name|exponent
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_EXP2
argument_list|)
operator|:
comment|/* Prepare to do logN(exp2(exponent) -> exponent*logN(2).  */
name|x
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst2
argument_list|)
expr_stmt|;
name|exponent
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_EXP10
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_POW10
argument_list|)
operator|:
comment|/* Prepare to do logN(exp10(exponent) -> exponent*logN(10).  */
name|x
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst10
argument_list|)
expr_stmt|;
name|exponent
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_SQRT
argument_list|)
operator|:
comment|/* Prepare to do logN(sqrt(x) -> 0.5*logN(x).  */
name|x
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|exponent
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|dconsthalf
argument_list|)
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_CBRT
argument_list|)
operator|:
comment|/* Prepare to do logN(cbrt(x) -> (1/3)*logN(x).  */
name|x
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|exponent
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|real_value_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|dconstthird
argument_list|)
argument_list|)
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_POW
argument_list|)
operator|:
comment|/* Prepare to do logN(pow(x,exponent) -> exponent*logN(x).  */
name|x
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|exponent
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Now perform the optimization.  */
if|if
condition|(
name|x
operator|&&
name|exponent
condition|)
block|{
name|tree
name|logfn
decl_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|logfn
operator|=
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|exponent
argument_list|,
name|logfn
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fold a builtin function call to pow, powf, or powl.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_pow
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Optimize pow(1.0,y) = 1.0.  */
if|if
condition|(
name|real_onep
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|cint
decl_stmt|;
name|REAL_VALUE_TYPE
name|c
decl_stmt|;
name|HOST_WIDE_INT
name|n
decl_stmt|;
name|c
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* Optimize pow(x,0.0) = 1.0.  */
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|c
argument_list|,
name|dconst0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* Optimize pow(x,1.0) = x.  */
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|c
argument_list|,
name|dconst1
argument_list|)
condition|)
return|return
name|arg0
return|;
comment|/* Optimize pow(x,-1.0) = 1.0/x.  */
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|c
argument_list|,
name|dconstm1
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* Optimize pow(x,0.5) = sqrt(x).  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|c
argument_list|,
name|dconsthalf
argument_list|)
condition|)
block|{
name|tree
name|sqrtfn
init|=
name|mathfn_built_in
argument_list|(
name|type
argument_list|,
name|BUILT_IN_SQRT
argument_list|)
decl_stmt|;
if|if
condition|(
name|sqrtfn
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|arglist
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg0
argument_list|)
decl_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|sqrtfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
comment|/* Check for an integer exponent.  */
name|n
operator|=
name|real_to_integer
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|real_from_integer
argument_list|(
operator|&
name|cint
argument_list|,
name|VOIDmode
argument_list|,
name|n
argument_list|,
name|n
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_identical
argument_list|(
operator|&
name|c
argument_list|,
operator|&
name|cint
argument_list|)
condition|)
block|{
comment|/* Attempt to evaluate pow at compile-time.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
name|bool
name|inexact
decl_stmt|;
name|x
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|inexact
operator|=
name|real_powi
argument_list|(
operator|&
name|x
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|x
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|||
operator|!
name|inexact
condition|)
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|x
argument_list|)
return|;
block|}
comment|/* Strip sign ops from even integer powers.  */
if|if
condition|(
operator|(
name|n
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|flag_unsafe_math_optimizations
condition|)
block|{
name|tree
name|narg0
init|=
name|fold_strip_sign_ops
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
if|if
condition|(
name|narg0
condition|)
block|{
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|narg0
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|flag_unsafe_math_optimizations
condition|)
block|{
specifier|const
name|enum
name|built_in_function
name|fcode
init|=
name|builtin_mathfn_code
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
comment|/* Optimize pow(expN(x),y) = expN(x*y).  */
if|if
condition|(
name|BUILTIN_EXPONENT_P
argument_list|(
name|fcode
argument_list|)
condition|)
block|{
name|tree
name|expfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|arg
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|expfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
comment|/* Optimize pow(sqrt(x),y) = pow(x,y*0.5).  */
if|if
condition|(
name|BUILTIN_SQRT_P
argument_list|(
name|fcode
argument_list|)
condition|)
block|{
name|tree
name|narg0
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|narg1
init|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconsthalf
argument_list|)
argument_list|)
decl_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|narg0
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|narg1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
block|}
comment|/* Optimize pow(cbrt(x),y) = pow(x,y/3) iff x is nonnegative.  */
if|if
condition|(
name|BUILTIN_CBRT_P
argument_list|(
name|fcode
argument_list|)
condition|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tree_expr_nonnegative_p
argument_list|(
name|arg
argument_list|)
condition|)
block|{
specifier|const
name|REAL_VALUE_TYPE
name|dconstroot
init|=
name|real_value_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|dconstthird
argument_list|)
decl_stmt|;
name|tree
name|narg1
init|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconstroot
argument_list|)
argument_list|)
decl_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|narg1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
comment|/* Optimize pow(pow(x,y),z) = pow(x,y*z).  */
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_POW
operator|||
name|fcode
operator|==
name|BUILT_IN_POWF
operator|||
name|fcode
operator|==
name|BUILT_IN_POWL
condition|)
block|{
name|tree
name|arg00
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg01
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|narg1
init|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg01
argument_list|,
name|arg1
argument_list|)
decl_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg00
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|narg1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Fold a builtin function call to powi, powif, or powil.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_powi
parameter_list|(
name|tree
name|fndecl
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Optimize pow(1.0,y) = 1.0.  */
if|if
condition|(
name|real_onep
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|host_integerp
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|c
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
comment|/* Evaluate powi at compile-time.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
name|x
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|real_powi
argument_list|(
operator|&
name|x
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|x
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|x
argument_list|)
return|;
block|}
comment|/* Optimize pow(x,0) = 1.0.  */
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* Optimize pow(x,1) = x.  */
if|if
condition|(
name|c
operator|==
literal|1
condition|)
return|return
name|arg0
return|;
comment|/* Optimize pow(x,-1) = 1.0/x.  */
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
return|return
name|fold_build2
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of fold_builtin to fold the various exponent    functions.  EXP is the CALL_EXPR of a call to a builtin function.    VALUE is the value which will be raised to a power.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_exponent
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
comment|/* Optimize exp*(0.0) = 1.0.  */
if|if
condition|(
name|real_zerop
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
return|;
comment|/* Optimize expN(1.0) = N.  */
if|if
condition|(
name|real_onep
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|cst
decl_stmt|;
name|real_convert
argument_list|(
operator|&
name|cst
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|cst
argument_list|)
return|;
block|}
comment|/* Attempt to evaluate expN(integer) at compile-time.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|cint
decl_stmt|;
name|REAL_VALUE_TYPE
name|c
decl_stmt|;
name|HOST_WIDE_INT
name|n
decl_stmt|;
name|c
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|n
operator|=
name|real_to_integer
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|real_from_integer
argument_list|(
operator|&
name|cint
argument_list|,
name|VOIDmode
argument_list|,
name|n
argument_list|,
name|n
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_identical
argument_list|(
operator|&
name|c
argument_list|,
operator|&
name|cint
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
name|real_powi
argument_list|(
operator|&
name|x
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|value
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|x
argument_list|)
return|;
block|}
block|}
comment|/* Optimize expN(logN(x)) = x.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
condition|)
block|{
specifier|const
name|enum
name|built_in_function
name|fcode
init|=
name|builtin_mathfn_code
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|value
operator|==
operator|&
name|dconste
operator|&&
operator|(
name|fcode
operator|==
name|BUILT_IN_LOG
operator|||
name|fcode
operator|==
name|BUILT_IN_LOGF
operator|||
name|fcode
operator|==
name|BUILT_IN_LOGL
operator|)
operator|)
operator|||
operator|(
name|value
operator|==
operator|&
name|dconst2
operator|&&
operator|(
name|fcode
operator|==
name|BUILT_IN_LOG2
operator|||
name|fcode
operator|==
name|BUILT_IN_LOG2F
operator|||
name|fcode
operator|==
name|BUILT_IN_LOG2L
operator|)
operator|)
operator|||
operator|(
name|value
operator|==
operator|&
name|dconst10
operator|&&
operator|(
name|fcode
operator|==
name|BUILT_IN_LOG10
operator|||
name|fcode
operator|==
name|BUILT_IN_LOG10F
operator|||
name|fcode
operator|==
name|BUILT_IN_LOG10L
operator|)
operator|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if VAR is a VAR_DECL or a component thereof.  */
end_comment

begin_function
specifier|static
name|bool
name|var_decl_component_p
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|tree
name|inner
init|=
name|var
decl_stmt|;
while|while
condition|(
name|handled_component_p
argument_list|(
name|inner
argument_list|)
condition|)
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|SSA_VAR_P
argument_list|(
name|inner
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin memset.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_memset
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|ignore
parameter_list|)
block|{
name|tree
name|dest
decl_stmt|,
name|c
decl_stmt|,
name|len
decl_stmt|,
name|var
decl_stmt|,
name|ret
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|length
decl_stmt|,
name|cval
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|c
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If the LEN parameter is zero, return DEST.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|dest
argument_list|,
name|c
argument_list|)
return|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|dest
argument_list|)
condition|)
return|return
literal|0
return|;
name|var
operator|=
name|dest
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
return|return
literal|0
return|;
name|var
operator|=
name|TREE_OPERAND
argument_list|(
name|var
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|var
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|var_decl_component_p
argument_list|(
name|var
argument_list|)
condition|)
return|return
literal|0
return|;
name|length
operator|=
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|length
operator|||
name|get_pointer_alignment
argument_list|(
name|dest
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|<
operator|(
name|int
operator|)
name|length
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|length
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|/
name|BITS_PER_UNIT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|c
argument_list|)
condition|)
name|cval
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|CHAR_BIT
operator|!=
literal|8
operator|||
name|BITS_PER_UNIT
operator|!=
literal|8
operator|||
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|64
condition|)
return|return
literal|0
return|;
name|cval
operator|=
name|tree_low_cst
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cval
operator|&=
literal|0xff
expr_stmt|;
name|cval
operator||=
name|cval
operator|<<
literal|8
expr_stmt|;
name|cval
operator||=
name|cval
operator|<<
literal|16
expr_stmt|;
name|cval
operator||=
operator|(
name|cval
operator|<<
literal|31
operator|)
operator|<<
literal|1
expr_stmt|;
block|}
name|ret
operator|=
name|build_int_cst_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|,
name|cval
argument_list|)
expr_stmt|;
name|ret
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|,
name|var
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore
condition|)
return|return
name|ret
return|;
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|dest
argument_list|,
name|ret
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin memset.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_bzero
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|bool
name|ignore
parameter_list|)
block|{
name|tree
name|dest
decl_stmt|,
name|size
decl_stmt|,
name|newarglist
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ignore
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|size
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* New argument list transforming bzero(ptr x, int y) to      memset(ptr x, int 0, size_t y).   This is done this way      so that if it isn't expanded inline, we fallback to      calling bzero instead of memset.  */
name|newarglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|newarglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
name|newarglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
return|return
name|fold_builtin_memset
argument_list|(
name|newarglist
argument_list|,
name|void_type_node
argument_list|,
name|ignore
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin mem{{,p}cpy,move}.  Return    NULL_TREE if no simplification can be made.    If ENDP is 0, return DEST (like memcpy).    If ENDP is 1, return DEST+LEN (like mempcpy).    If ENDP is 2, return DEST+LEN-1 (like stpcpy).    If ENDP is 3, return DEST, additionally *SRC and *DEST may overlap    (memmove).   */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_memory_op
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|ignore
parameter_list|,
name|int
name|endp
parameter_list|)
block|{
name|tree
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|len
decl_stmt|,
name|destvar
decl_stmt|,
name|srcvar
decl_stmt|,
name|expr
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|length
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the LEN parameter is zero, return DEST.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
return|;
comment|/* If SRC and DEST are the same (and not volatile), return      DEST{,+LEN,+LEN-1}.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
condition|)
name|expr
operator|=
name|len
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|dest
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|src
argument_list|)
condition|)
return|return
literal|0
return|;
name|destvar
operator|=
name|dest
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|destvar
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|destvar
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
return|return
literal|0
return|;
name|destvar
operator|=
name|TREE_OPERAND
argument_list|(
name|destvar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|destvar
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|destvar
argument_list|)
argument_list|)
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|destvar
argument_list|)
argument_list|)
operator|&&
operator|!
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|destvar
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|var_decl_component_p
argument_list|(
name|destvar
argument_list|)
condition|)
return|return
literal|0
return|;
name|srcvar
operator|=
name|src
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|srcvar
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|srcvar
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
return|return
literal|0
return|;
name|srcvar
operator|=
name|TREE_OPERAND
argument_list|(
name|srcvar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|srcvar
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|srcvar
argument_list|)
argument_list|)
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|srcvar
argument_list|)
argument_list|)
operator|&&
operator|!
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|srcvar
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|var_decl_component_p
argument_list|(
name|srcvar
argument_list|)
condition|)
return|return
literal|0
return|;
name|length
operator|=
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|destvar
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|length
operator|||
name|get_pointer_alignment
argument_list|(
name|dest
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|<
operator|(
name|int
operator|)
name|length
operator|||
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|srcvar
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|length
operator|||
name|get_pointer_alignment
argument_list|(
name|src
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|<
operator|(
name|int
operator|)
name|length
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|srcvar
argument_list|)
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|srcvar
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|destvar
argument_list|)
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|destvar
argument_list|)
argument_list|)
operator|)
condition|)
name|expr
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|destvar
argument_list|)
argument_list|,
name|srcvar
argument_list|)
expr_stmt|;
else|else
name|expr
operator|=
name|fold_build1
argument_list|(
name|VIEW_CONVERT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|destvar
argument_list|)
argument_list|,
name|srcvar
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|destvar
argument_list|)
argument_list|,
name|destvar
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ignore
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|endp
operator|==
literal|0
operator|||
name|endp
operator|==
literal|3
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|dest
argument_list|,
name|expr
argument_list|)
return|;
if|if
condition|(
name|expr
operator|==
name|len
condition|)
name|expr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|endp
operator|==
literal|2
condition|)
name|len
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|len
argument_list|)
argument_list|,
name|len
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dest
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|dest
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dest
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
condition|)
name|dest
operator|=
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|dest
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|dest
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin bcopy.  Return NULL_TREE if no    simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_bcopy
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|bool
name|ignore
parameter_list|)
block|{
name|tree
name|src
decl_stmt|,
name|dest
decl_stmt|,
name|size
decl_stmt|,
name|newarglist
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ignore
condition|)
return|return
literal|0
return|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* New argument list transforming bcopy(ptr x, ptr y, int z) to      memmove(ptr y, ptr x, size_t z).   This is done this way      so that if it isn't expanded inline, we fallback to      calling bcopy instead of memmove.  */
name|newarglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|newarglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
name|newarglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
return|return
name|fold_builtin_memory_op
argument_list|(
name|newarglist
argument_list|,
name|void_type_node
argument_list|,
name|true
argument_list|,
comment|/*endp=*/
literal|3
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin strcpy.  If LEN is not NULL, it represents    the length of the string to be copied.  Return NULL_TREE if no    simplification can be made.  */
end_comment

begin_function
name|tree
name|fold_builtin_strcpy
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|tree
name|len
parameter_list|)
block|{
name|tree
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|fn
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If SRC and DEST are the same (and not volatile), return DEST.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|dest
argument_list|)
return|;
if|if
condition|(
name|optimize_size
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_MEMCPY
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|len
condition|)
block|{
name|len
operator|=
name|c_strlen
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|len
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|len
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin strncpy.  If SLEN is not NULL, it represents    the length of the source string.  Return NULL_TREE if no simplification    can be made.  */
end_comment

begin_function
name|tree
name|fold_builtin_strncpy
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|tree
name|slen
parameter_list|)
block|{
name|tree
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|len
decl_stmt|,
name|fn
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the LEN parameter is zero, return DEST.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
return|;
comment|/* We can't compare slen with len as constants below if len is not a      constant.  */
if|if
condition|(
name|len
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|len
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|slen
condition|)
name|slen
operator|=
name|c_strlen
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now, we must be passed a constant src ptr parameter.  */
if|if
condition|(
name|slen
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|slen
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
name|slen
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|slen
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We do not support simplification of this case, though we do      support it when expanding trees into RTL.  */
comment|/* FIXME: generate a call to __builtin_memset.  */
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|slen
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* OK transform into builtin memcpy.  */
name|fn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_MEMCPY
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin memcmp.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_memcmp
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the LEN parameter is zero, return zero.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
condition|)
return|return
name|omit_two_operands
argument_list|(
name|integer_type_node
argument_list|,
name|integer_zero_node
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
comment|/* If ARG1 and ARG2 are the same (and not volatile), return zero.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|integer_type_node
argument_list|,
name|integer_zero_node
argument_list|,
name|len
argument_list|)
return|;
name|p1
operator|=
name|c_getstr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|c_getstr
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* If all arguments are constant, and the value of len is not greater      than the lengths of arg1 and arg2, evaluate at compile-time.  */
if|if
condition|(
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|&&
name|p1
operator|&&
name|p2
operator|&&
name|compare_tree_int
argument_list|(
name|len
argument_list|,
name|strlen
argument_list|(
name|p1
argument_list|)
operator|+
literal|1
argument_list|)
operator|<=
literal|0
operator|&&
name|compare_tree_int
argument_list|(
name|len
argument_list|,
name|strlen
argument_list|(
name|p2
argument_list|)
operator|+
literal|1
argument_list|)
operator|<=
literal|0
condition|)
block|{
specifier|const
name|int
name|r
init|=
name|memcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|>
literal|0
condition|)
return|return
name|integer_one_node
return|;
elseif|else
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
name|integer_minus_one_node
return|;
else|else
return|return
name|integer_zero_node
return|;
block|}
comment|/* If len parameter is one, return an expression corresponding to      (*(const unsigned char*)arg1 - (const unsigned char*)arg2).  */
if|if
condition|(
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|&&
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|tree
name|cst_uchar_node
init|=
name|build_type_variant
argument_list|(
name|unsigned_char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|cst_uchar_ptr_node
init|=
name|build_pointer_type_for_mode
argument_list|(
name|cst_uchar_node
argument_list|,
name|ptr_mode
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|tree
name|ind1
init|=
name|fold_convert
argument_list|(
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|fold_convert
argument_list|(
name|cst_uchar_ptr_node
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ind2
init|=
name|fold_convert
argument_list|(
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|fold_convert
argument_list|(
name|cst_uchar_ptr_node
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ind1
argument_list|,
name|ind2
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin strcmp.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_strcmp
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If ARG1 and ARG2 are the same (and not volatile), return zero.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|integer_zero_node
return|;
name|p1
operator|=
name|c_getstr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|c_getstr
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|&&
name|p2
condition|)
block|{
specifier|const
name|int
name|i
init|=
name|strcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
name|integer_minus_one_node
return|;
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return
name|integer_one_node
return|;
else|else
return|return
name|integer_zero_node
return|;
block|}
comment|/* If the second arg is "", return *(const unsigned char*)arg1.  */
if|if
condition|(
name|p2
operator|&&
operator|*
name|p2
operator|==
literal|'\0'
condition|)
block|{
name|tree
name|cst_uchar_node
init|=
name|build_type_variant
argument_list|(
name|unsigned_char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|cst_uchar_ptr_node
init|=
name|build_pointer_type_for_mode
argument_list|(
name|cst_uchar_node
argument_list|,
name|ptr_mode
argument_list|,
name|true
argument_list|)
decl_stmt|;
return|return
name|fold_convert
argument_list|(
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|fold_convert
argument_list|(
name|cst_uchar_ptr_node
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* If the first arg is "", return -*(const unsigned char*)arg2.  */
if|if
condition|(
name|p1
operator|&&
operator|*
name|p1
operator|==
literal|'\0'
condition|)
block|{
name|tree
name|cst_uchar_node
init|=
name|build_type_variant
argument_list|(
name|unsigned_char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|cst_uchar_ptr_node
init|=
name|build_pointer_type_for_mode
argument_list|(
name|cst_uchar_node
argument_list|,
name|ptr_mode
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|tree
name|temp
init|=
name|fold_convert
argument_list|(
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|fold_convert
argument_list|(
name|cst_uchar_ptr_node
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|fold_build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|temp
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin strncmp.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_strncmp
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the LEN parameter is zero, return zero.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
condition|)
return|return
name|omit_two_operands
argument_list|(
name|integer_type_node
argument_list|,
name|integer_zero_node
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
comment|/* If ARG1 and ARG2 are the same (and not volatile), return zero.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|integer_type_node
argument_list|,
name|integer_zero_node
argument_list|,
name|len
argument_list|)
return|;
name|p1
operator|=
name|c_getstr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|c_getstr
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|&&
name|p1
operator|&&
name|p2
condition|)
block|{
specifier|const
name|int
name|i
init|=
name|strncmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return
name|integer_one_node
return|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
name|integer_minus_one_node
return|;
else|else
return|return
name|integer_zero_node
return|;
block|}
comment|/* If the second arg is "", and the length is greater than zero,      return *(const unsigned char*)arg1.  */
if|if
condition|(
name|p2
operator|&&
operator|*
name|p2
operator|==
literal|'\0'
operator|&&
name|TREE_CODE
argument_list|(
name|len
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|len
argument_list|)
operator|==
literal|1
condition|)
block|{
name|tree
name|cst_uchar_node
init|=
name|build_type_variant
argument_list|(
name|unsigned_char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|cst_uchar_ptr_node
init|=
name|build_pointer_type_for_mode
argument_list|(
name|cst_uchar_node
argument_list|,
name|ptr_mode
argument_list|,
name|true
argument_list|)
decl_stmt|;
return|return
name|fold_convert
argument_list|(
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|fold_convert
argument_list|(
name|cst_uchar_ptr_node
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* If the first arg is "", and the length is greater than zero,      return -*(const unsigned char*)arg2.  */
if|if
condition|(
name|p1
operator|&&
operator|*
name|p1
operator|==
literal|'\0'
operator|&&
name|TREE_CODE
argument_list|(
name|len
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|len
argument_list|)
operator|==
literal|1
condition|)
block|{
name|tree
name|cst_uchar_node
init|=
name|build_type_variant
argument_list|(
name|unsigned_char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|cst_uchar_ptr_node
init|=
name|build_pointer_type_for_mode
argument_list|(
name|cst_uchar_node
argument_list|,
name|ptr_mode
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|tree
name|temp
init|=
name|fold_convert
argument_list|(
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|fold_convert
argument_list|(
name|cst_uchar_ptr_node
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|fold_build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|temp
argument_list|)
return|;
block|}
comment|/* If len parameter is one, return an expression corresponding to      (*(const unsigned char*)arg1 - (const unsigned char*)arg2).  */
if|if
condition|(
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|&&
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|tree
name|cst_uchar_node
init|=
name|build_type_variant
argument_list|(
name|unsigned_char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|cst_uchar_ptr_node
init|=
name|build_pointer_type_for_mode
argument_list|(
name|cst_uchar_node
argument_list|,
name|ptr_mode
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|tree
name|ind1
init|=
name|fold_convert
argument_list|(
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|fold_convert
argument_list|(
name|cst_uchar_ptr_node
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ind2
init|=
name|fold_convert
argument_list|(
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|fold_convert
argument_list|(
name|cst_uchar_ptr_node
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ind1
argument_list|,
name|ind2
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin signbit, signbitf or signbitl.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_signbit
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg
decl_stmt|,
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* If ARG is a compile-time constant, determine the result.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|c
decl_stmt|;
name|c
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|temp
operator|=
name|REAL_VALUE_NEGATIVE
argument_list|(
name|c
argument_list|)
condition|?
name|integer_one_node
else|:
name|integer_zero_node
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|temp
argument_list|)
return|;
block|}
comment|/* If ARG is non-negative, the result is always zero.  */
if|if
condition|(
name|tree_expr_nonnegative_p
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg
argument_list|)
return|;
comment|/* If ARG's format doesn't have signed zeros, return "arg< 0.0".  */
if|if
condition|(
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|LT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|dconst0
argument_list|)
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin copysign, copysignf or copysignl.    Return NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_copysign
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|tem
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copysign(X,X) is X.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
comment|/* If ARG1 and ARG2 are compile-time constants, determine the result.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg2
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|c1
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|c2
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* c1.sign := c2.sign.  */
name|real_copysign
argument_list|(
operator|&
name|c1
argument_list|,
operator|&
name|c2
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|c1
argument_list|)
return|;
block|}
comment|/* copysign(X, Y) is fabs(X) when Y is always non-negative.      Remember to evaluate Y for side-effects.  */
if|if
condition|(
name|tree_expr_nonnegative_p
argument_list|(
name|arg2
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|fold_build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|,
name|arg2
argument_list|)
return|;
comment|/* Strip sign changing operations for the first argument.  */
name|tem
operator|=
name|fold_strip_sign_ops
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
block|{
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tem
argument_list|,
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to builtin isascii.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_isascii
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
comment|/* Transform isascii(c) -> ((c& ~0x7f) == 0).  */
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|arg
operator|=
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0x7f
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|fold_build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_gimple_form
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
else|else
return|return
name|arg
return|;
block|}
block|}
end_function

begin_comment
comment|/* Fold a call to builtin toascii.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_toascii
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
comment|/* Transform toascii(c) -> (c& 0x7f).  */
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
return|return
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0x7f
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Fold a call to builtin isdigit.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_isdigit
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
comment|/* Transform isdigit(c) -> (unsigned)(c) - '0'<= 9.  */
comment|/* According to the C standard, isdigit is unaffected by locale. 	 However, it definitely is affected by the target character set.  */
name|tree
name|arg
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|target_digit0
init|=
name|lang_hooks
operator|.
name|to_target_charset
argument_list|(
literal|'0'
argument_list|)
decl_stmt|;
if|if
condition|(
name|target_digit0
operator|==
literal|0
condition|)
return|return
name|NULL_TREE
return|;
name|arg
operator|=
name|fold_convert
argument_list|(
name|unsigned_type_node
argument_list|,
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|unsigned_type_node
argument_list|,
name|arg
argument_list|,
name|build_int_cst
argument_list|(
name|unsigned_type_node
argument_list|,
name|target_digit0
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|fold_build2
argument_list|(
name|LE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg
argument_list|,
name|build_int_cst
argument_list|(
name|unsigned_type_node
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_gimple_form
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
else|else
return|return
name|arg
return|;
block|}
block|}
end_function

begin_comment
comment|/* Fold a call to fabs, fabsf or fabsl.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_fabs
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
condition|)
return|return
name|fold_abs_const
argument_list|(
name|arg
argument_list|,
name|type
argument_list|)
return|;
return|return
name|fold_build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to abs, labs, llabs or imaxabs.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_abs
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|fold_abs_const
argument_list|(
name|arg
argument_list|,
name|type
argument_list|)
return|;
return|return
name|fold_build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to __builtin_isnan(), __builtin_isinf, __builtin_finite.    EXP is the CALL_EXPR for the call.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_classify
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|int
name|builtin_index
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
comment|/* Check that we have exactly one argument.  */
if|if
condition|(
name|arglist
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"too few arguments to function %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"too many arguments to function %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"non-floating-point argument to function %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|builtin_index
condition|)
block|{
case|case
name|BUILT_IN_ISINF
case|:
if|if
condition|(
operator|!
name|HONOR_INFINITIES
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|r
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_isinf
argument_list|(
operator|&
name|r
argument_list|)
condition|)
return|return
name|real_compare
argument_list|(
name|GT_EXPR
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|dconst0
argument_list|)
condition|?
name|integer_one_node
else|:
name|integer_minus_one_node
return|;
else|else
return|return
name|integer_zero_node
return|;
block|}
return|return
name|NULL_TREE
return|;
case|case
name|BUILT_IN_FINITE
case|:
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|HONOR_INFINITIES
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|arg
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|r
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|real_isinf
argument_list|(
operator|&
name|r
argument_list|)
operator|||
name|real_isnan
argument_list|(
operator|&
name|r
argument_list|)
condition|?
name|integer_zero_node
else|:
name|integer_one_node
return|;
block|}
return|return
name|NULL_TREE
return|;
case|case
name|BUILT_IN_ISNAN
case|:
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|r
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|real_isnan
argument_list|(
operator|&
name|r
argument_list|)
condition|?
name|integer_one_node
else|:
name|integer_zero_node
return|;
block|}
name|arg
operator|=
name|builtin_save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|UNORDERED_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|arg
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fold a call to an unordered comparison function such as    __builtin_isgreater().  FNDECL is the FUNCTION_DECL for the function    being called and ARGLIST is the argument list for the call.    UNORDERED_CODE and ORDERED_CODE are comparison codes that give    the opposite of the desired result.  UNORDERED_CODE is used    for modes that can hold NaNs and ORDERED_CODE is used for    the rest.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_unordered_cmp
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|enum
name|tree_code
name|unordered_code
parameter_list|,
name|enum
name|tree_code
name|ordered_code
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|tree
name|type0
decl_stmt|,
name|type1
decl_stmt|;
name|enum
name|tree_code
name|code0
decl_stmt|,
name|code1
decl_stmt|;
name|tree
name|cmp_type
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
comment|/* Check that we have exactly two arguments.  */
if|if
condition|(
name|arglist
operator|==
literal|0
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"too few arguments to function %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"too many arguments to function %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|type0
operator|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|code0
operator|=
name|TREE_CODE
argument_list|(
name|type0
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code0
operator|==
name|REAL_TYPE
operator|&&
name|code1
operator|==
name|REAL_TYPE
condition|)
comment|/* Choose the wider of two real types.  */
name|cmp_type
operator|=
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|type1
argument_list|)
condition|?
name|type0
else|:
name|type1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|REAL_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
name|cmp_type
operator|=
name|type0
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|REAL_TYPE
condition|)
name|cmp_type
operator|=
name|type1
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"non-floating-point argument to function %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|arg0
operator|=
name|fold_convert
argument_list|(
name|cmp_type
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|fold_convert
argument_list|(
name|cmp_type
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|unordered_code
operator|==
name|UNORDERED_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|omit_two_operands
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
return|return
name|fold_build2
argument_list|(
name|UNORDERED_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
block|}
name|code
operator|=
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
condition|?
name|unordered_code
else|:
name|ordered_code
expr_stmt|;
return|return
name|fold_build1
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Used by constant folding to simplify calls to builtin functions.  EXP is    the CALL_EXPR of a call to a builtin function.  IGNORE is true if the    result of the function call is ignored.  This function returns NULL_TREE    if no simplification was possible.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_1
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|bool
name|ignore
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|built_in_function
name|fcode
decl_stmt|;
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_MD
condition|)
return|return
name|targetm
operator|.
name|fold_builtin
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|ignore
argument_list|)
return|;
name|fcode
operator|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|BUILT_IN_FPUTS
case|:
return|return
name|fold_builtin_fputs
argument_list|(
name|arglist
argument_list|,
name|ignore
argument_list|,
name|false
argument_list|,
name|NULL_TREE
argument_list|)
return|;
case|case
name|BUILT_IN_FPUTS_UNLOCKED
case|:
return|return
name|fold_builtin_fputs
argument_list|(
name|arglist
argument_list|,
name|ignore
argument_list|,
name|true
argument_list|,
name|NULL_TREE
argument_list|)
return|;
case|case
name|BUILT_IN_STRSTR
case|:
return|return
name|fold_builtin_strstr
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|)
return|;
case|case
name|BUILT_IN_STRCAT
case|:
return|return
name|fold_builtin_strcat
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_STRNCAT
case|:
return|return
name|fold_builtin_strncat
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_STRSPN
case|:
return|return
name|fold_builtin_strspn
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_STRCSPN
case|:
return|return
name|fold_builtin_strcspn
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_STRCHR
case|:
case|case
name|BUILT_IN_INDEX
case|:
return|return
name|fold_builtin_strchr
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|)
return|;
case|case
name|BUILT_IN_STRRCHR
case|:
case|case
name|BUILT_IN_RINDEX
case|:
return|return
name|fold_builtin_strrchr
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|)
return|;
case|case
name|BUILT_IN_STRCPY
case|:
return|return
name|fold_builtin_strcpy
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|NULL_TREE
argument_list|)
return|;
case|case
name|BUILT_IN_STRNCPY
case|:
return|return
name|fold_builtin_strncpy
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|NULL_TREE
argument_list|)
return|;
case|case
name|BUILT_IN_STRCMP
case|:
return|return
name|fold_builtin_strcmp
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_STRNCMP
case|:
return|return
name|fold_builtin_strncmp
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_STRPBRK
case|:
return|return
name|fold_builtin_strpbrk
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|)
return|;
case|case
name|BUILT_IN_BCMP
case|:
case|case
name|BUILT_IN_MEMCMP
case|:
return|return
name|fold_builtin_memcmp
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_SPRINTF
case|:
return|return
name|fold_builtin_sprintf
argument_list|(
name|arglist
argument_list|,
name|ignore
argument_list|)
return|;
case|case
name|BUILT_IN_CONSTANT_P
case|:
block|{
name|tree
name|val
decl_stmt|;
name|val
operator|=
name|fold_builtin_constant_p
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* Gimplification will pull the CALL_EXPR for the builtin out of 	   an if condition.  When not optimizing, we'll not CSE it back. 	   To avoid link error types of regressions, return false now.  */
if|if
condition|(
operator|!
name|val
operator|&&
operator|!
name|optimize
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
return|return
name|val
return|;
block|}
case|case
name|BUILT_IN_EXPECT
case|:
return|return
name|fold_builtin_expect
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_CLASSIFY_TYPE
case|:
return|return
name|fold_builtin_classify_type
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_STRLEN
case|:
return|return
name|fold_builtin_strlen
argument_list|(
name|arglist
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_FABS
argument_list|)
operator|:
return|return
name|fold_builtin_fabs
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|)
return|;
case|case
name|BUILT_IN_ABS
case|:
case|case
name|BUILT_IN_LABS
case|:
case|case
name|BUILT_IN_LLABS
case|:
case|case
name|BUILT_IN_IMAXABS
case|:
return|return
name|fold_builtin_abs
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_CONJ
argument_list|)
operator|:
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|COMPLEX_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|fold_build1
argument_list|(
name|CONJ_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
return|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_CREAL
argument_list|)
operator|:
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|COMPLEX_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_CIMAG
argument_list|)
operator|:
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|COMPLEX_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_CABS
argument_list|)
operator|:
return|return
name|fold_builtin_cabs
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|,
name|fndecl
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_SQRT
argument_list|)
operator|:
return|return
name|fold_builtin_sqrt
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_CBRT
argument_list|)
operator|:
return|return
name|fold_builtin_cbrt
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_SIN
argument_list|)
operator|:
return|return
name|fold_builtin_sin
argument_list|(
name|arglist
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_COS
argument_list|)
operator|:
return|return
name|fold_builtin_cos
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|,
name|fndecl
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_EXP
argument_list|)
operator|:
return|return
name|fold_builtin_exponent
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
operator|&
name|dconste
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_EXP2
argument_list|)
operator|:
return|return
name|fold_builtin_exponent
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
operator|&
name|dconst2
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_EXP10
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_POW10
argument_list|)
operator|:
return|return
name|fold_builtin_exponent
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
operator|&
name|dconst10
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LOG
argument_list|)
operator|:
return|return
name|fold_builtin_logarithm
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
operator|&
name|dconste
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LOG2
argument_list|)
operator|:
return|return
name|fold_builtin_logarithm
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
operator|&
name|dconst2
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LOG10
argument_list|)
operator|:
return|return
name|fold_builtin_logarithm
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
operator|&
name|dconst10
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_TAN
argument_list|)
operator|:
return|return
name|fold_builtin_tan
argument_list|(
name|arglist
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ATAN
argument_list|)
operator|:
return|return
name|fold_builtin_atan
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_POW
argument_list|)
operator|:
return|return
name|fold_builtin_pow
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|type
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_POWI
argument_list|)
operator|:
return|return
name|fold_builtin_powi
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|type
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_INF
argument_list|)
operator|:
case|case
name|BUILT_IN_INFD32
case|:
case|case
name|BUILT_IN_INFD64
case|:
case|case
name|BUILT_IN_INFD128
case|:
return|return
name|fold_builtin_inf
argument_list|(
name|type
argument_list|,
name|true
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_HUGE_VAL
argument_list|)
operator|:
return|return
name|fold_builtin_inf
argument_list|(
name|type
argument_list|,
name|false
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_NAN
argument_list|)
operator|:
case|case
name|BUILT_IN_NAND32
case|:
case|case
name|BUILT_IN_NAND64
case|:
case|case
name|BUILT_IN_NAND128
case|:
return|return
name|fold_builtin_nan
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|,
name|true
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_NANS
argument_list|)
operator|:
return|return
name|fold_builtin_nan
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|,
name|false
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_FLOOR
argument_list|)
operator|:
return|return
name|fold_builtin_floor
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_CEIL
argument_list|)
operator|:
return|return
name|fold_builtin_ceil
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_TRUNC
argument_list|)
operator|:
return|return
name|fold_builtin_trunc
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ROUND
argument_list|)
operator|:
return|return
name|fold_builtin_round
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_NEARBYINT
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_RINT
argument_list|)
operator|:
return|return
name|fold_trunc_transparent_mathfn
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LCEIL
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLCEIL
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LFLOOR
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLFLOOR
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LROUND
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLROUND
argument_list|)
operator|:
return|return
name|fold_builtin_int_roundingfn
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LRINT
argument_list|)
operator|:
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_LLRINT
argument_list|)
operator|:
return|return
name|fold_fixed_mathfn
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
name|CASE_INT_FN
argument_list|(
name|BUILT_IN_FFS
argument_list|)
operator|:
name|CASE_INT_FN
argument_list|(
name|BUILT_IN_CLZ
argument_list|)
operator|:
name|CASE_INT_FN
argument_list|(
name|BUILT_IN_CTZ
argument_list|)
operator|:
name|CASE_INT_FN
argument_list|(
name|BUILT_IN_POPCOUNT
argument_list|)
operator|:
name|CASE_INT_FN
argument_list|(
name|BUILT_IN_PARITY
argument_list|)
operator|:
return|return
name|fold_builtin_bitop
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_MEMSET
case|:
return|return
name|fold_builtin_memset
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|,
name|ignore
argument_list|)
return|;
case|case
name|BUILT_IN_MEMCPY
case|:
return|return
name|fold_builtin_memory_op
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|,
name|ignore
argument_list|,
comment|/*endp=*/
literal|0
argument_list|)
return|;
case|case
name|BUILT_IN_MEMPCPY
case|:
return|return
name|fold_builtin_memory_op
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|,
name|ignore
argument_list|,
comment|/*endp=*/
literal|1
argument_list|)
return|;
case|case
name|BUILT_IN_MEMMOVE
case|:
return|return
name|fold_builtin_memory_op
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|,
name|ignore
argument_list|,
comment|/*endp=*/
literal|3
argument_list|)
return|;
case|case
name|BUILT_IN_BZERO
case|:
return|return
name|fold_builtin_bzero
argument_list|(
name|arglist
argument_list|,
name|ignore
argument_list|)
return|;
case|case
name|BUILT_IN_BCOPY
case|:
return|return
name|fold_builtin_bcopy
argument_list|(
name|arglist
argument_list|,
name|ignore
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_SIGNBIT
argument_list|)
operator|:
return|return
name|fold_builtin_signbit
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_ISASCII
case|:
return|return
name|fold_builtin_isascii
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_TOASCII
case|:
return|return
name|fold_builtin_toascii
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_ISDIGIT
case|:
return|return
name|fold_builtin_isdigit
argument_list|(
name|arglist
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_COPYSIGN
argument_list|)
operator|:
return|return
name|fold_builtin_copysign
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|type
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_FINITE
argument_list|)
operator|:
case|case
name|BUILT_IN_FINITED32
case|:
case|case
name|BUILT_IN_FINITED64
case|:
case|case
name|BUILT_IN_FINITED128
case|:
return|return
name|fold_builtin_classify
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|BUILT_IN_FINITE
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ISINF
argument_list|)
operator|:
case|case
name|BUILT_IN_ISINFD32
case|:
case|case
name|BUILT_IN_ISINFD64
case|:
case|case
name|BUILT_IN_ISINFD128
case|:
return|return
name|fold_builtin_classify
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|BUILT_IN_ISINF
argument_list|)
return|;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ISNAN
argument_list|)
operator|:
case|case
name|BUILT_IN_ISNAND32
case|:
case|case
name|BUILT_IN_ISNAND64
case|:
case|case
name|BUILT_IN_ISNAND128
case|:
return|return
name|fold_builtin_classify
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|BUILT_IN_ISNAN
argument_list|)
return|;
case|case
name|BUILT_IN_ISGREATER
case|:
return|return
name|fold_builtin_unordered_cmp
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|UNLE_EXPR
argument_list|,
name|LE_EXPR
argument_list|)
return|;
case|case
name|BUILT_IN_ISGREATEREQUAL
case|:
return|return
name|fold_builtin_unordered_cmp
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|UNLT_EXPR
argument_list|,
name|LT_EXPR
argument_list|)
return|;
case|case
name|BUILT_IN_ISLESS
case|:
return|return
name|fold_builtin_unordered_cmp
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|UNGE_EXPR
argument_list|,
name|GE_EXPR
argument_list|)
return|;
case|case
name|BUILT_IN_ISLESSEQUAL
case|:
return|return
name|fold_builtin_unordered_cmp
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|UNGT_EXPR
argument_list|,
name|GT_EXPR
argument_list|)
return|;
case|case
name|BUILT_IN_ISLESSGREATER
case|:
return|return
name|fold_builtin_unordered_cmp
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|UNEQ_EXPR
argument_list|,
name|EQ_EXPR
argument_list|)
return|;
case|case
name|BUILT_IN_ISUNORDERED
case|:
return|return
name|fold_builtin_unordered_cmp
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|UNORDERED_EXPR
argument_list|,
name|NOP_EXPR
argument_list|)
return|;
comment|/* We do the folding for va_start in the expander.  */
case|case
name|BUILT_IN_VA_START
case|:
break|break;
case|case
name|BUILT_IN_OBJECT_SIZE
case|:
return|return
name|fold_builtin_object_size
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_MEMCPY_CHK
case|:
case|case
name|BUILT_IN_MEMPCPY_CHK
case|:
case|case
name|BUILT_IN_MEMMOVE_CHK
case|:
case|case
name|BUILT_IN_MEMSET_CHK
case|:
return|return
name|fold_builtin_memory_chk
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|NULL_TREE
argument_list|,
name|ignore
argument_list|,
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
return|;
case|case
name|BUILT_IN_STRCPY_CHK
case|:
case|case
name|BUILT_IN_STPCPY_CHK
case|:
return|return
name|fold_builtin_stxcpy_chk
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|NULL_TREE
argument_list|,
name|ignore
argument_list|,
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
return|;
case|case
name|BUILT_IN_STRNCPY_CHK
case|:
return|return
name|fold_builtin_strncpy_chk
argument_list|(
name|arglist
argument_list|,
name|NULL_TREE
argument_list|)
return|;
case|case
name|BUILT_IN_STRCAT_CHK
case|:
return|return
name|fold_builtin_strcat_chk
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_STRNCAT_CHK
case|:
return|return
name|fold_builtin_strncat_chk
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_SPRINTF_CHK
case|:
case|case
name|BUILT_IN_VSPRINTF_CHK
case|:
return|return
name|fold_builtin_sprintf_chk
argument_list|(
name|arglist
argument_list|,
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
return|;
case|case
name|BUILT_IN_SNPRINTF_CHK
case|:
case|case
name|BUILT_IN_VSNPRINTF_CHK
case|:
return|return
name|fold_builtin_snprintf_chk
argument_list|(
name|arglist
argument_list|,
name|NULL_TREE
argument_list|,
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
return|;
case|case
name|BUILT_IN_PRINTF
case|:
case|case
name|BUILT_IN_PRINTF_UNLOCKED
case|:
case|case
name|BUILT_IN_VPRINTF
case|:
case|case
name|BUILT_IN_PRINTF_CHK
case|:
case|case
name|BUILT_IN_VPRINTF_CHK
case|:
return|return
name|fold_builtin_printf
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|ignore
argument_list|,
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
return|;
case|case
name|BUILT_IN_FPRINTF
case|:
case|case
name|BUILT_IN_FPRINTF_UNLOCKED
case|:
case|case
name|BUILT_IN_VFPRINTF
case|:
case|case
name|BUILT_IN_FPRINTF_CHK
case|:
case|case
name|BUILT_IN_VFPRINTF_CHK
case|:
return|return
name|fold_builtin_fprintf
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|ignore
argument_list|,
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A wrapper function for builtin folding that prevents warnings for    "statement without effect" and the like, caused by removing the    call node earlier than the warning is generated.  */
end_comment

begin_function
name|tree
name|fold_builtin
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|bool
name|ignore
parameter_list|)
block|{
name|tree
name|exp
init|=
name|fold_builtin_1
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|ignore
argument_list|)
decl_stmt|;
if|if
condition|(
name|exp
condition|)
block|{
name|exp
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|TREE_NO_WARNING
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Conveniently construct a function call expression.  */
end_comment

begin_function
name|tree
name|build_function_call_expr
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|call_expr
decl_stmt|;
name|call_expr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|fold_build3
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|call_expr
argument_list|,
name|arglist
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function validates the types of a function call argument list    represented as a tree chain of parameters against a specified list    of tree_codes.  If the last specifier is a 0, that represents an    ellipses, otherwise the last specifier must be a VOID_TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|validate_arglist
parameter_list|(
name|tree
name|arglist
parameter_list|,
modifier|...
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
do|do
block|{
name|code
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
expr|enum
name|tree_code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0
case|:
comment|/* This signifies an ellipses, any further arguments are all ok.  */
name|res
operator|=
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
case|case
name|VOID_TYPE
case|:
comment|/* This signifies an endlink, if no arguments remain, return 	     true, otherwise return false.  */
name|res
operator|=
name|arglist
operator|==
literal|0
expr_stmt|;
goto|goto
name|end
goto|;
default|default:
comment|/* If no parameters remain or the parameter's code does not 	     match the specified code, return false.  Otherwise continue 	     checking any remaining arguments.  */
if|if
condition|(
name|arglist
operator|==
literal|0
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
condition|)
goto|goto
name|end
goto|;
block|}
elseif|else
if|if
condition|(
name|code
operator|!=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
condition|)
goto|goto
name|end
goto|;
break|break;
block|}
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
comment|/* We need gotos here since we can only have one VA_CLOSE in a      function.  */
name|end
label|:
empty_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Default target-specific builtin expander that does nothing.  */
end_comment

begin_function
name|rtx
name|default_expand_builtin
parameter_list|(
name|tree
name|exp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|target
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Returns true is EXP represents data that would potentially reside    in a readonly section.  */
end_comment

begin_function
specifier|static
name|bool
name|readonly_data_expr
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|STRIP_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
return|return
name|false
return|;
name|exp
operator|=
name|get_base_address
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exp
condition|)
return|return
name|false
return|;
comment|/* Make sure we call decl_readonly_section only for trees it      can handle (since it returns true for everything it doesn't      understand).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
return|return
name|decl_readonly_section
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Simplify a call to the strstr builtin.     Return 0 if no simplification was possible, otherwise return the    simplified form of the call as a tree.     The simplified form may be a constant or other expression which    computes the same value, but in a more efficient manner (including    calls to other builtin functions).     The call may contain arguments which need to be evaluated, but    which are not useful to determine the result of the call.  In    this case we return a chain of COMPOUND_EXPRs.  The LHS of each    COMPOUND_EXPR will be an argument which must be evaluated.    COMPOUND_EXPRs are chained through their RHS.  The RHS of the last    COMPOUND_EXPR in the chain will contain the tree for the simplified    form of the builtin function call.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_strstr
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|s1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|s2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|p2
operator|=
name|c_getstr
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|p1
operator|=
name|c_getstr
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|r
init|=
name|strstr
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
decl_stmt|;
name|tree
name|tem
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Return an offset into the constant string argument.  */
name|tem
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|s1
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|r
operator|-
name|p1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
comment|/* The argument is const char *, and the result is char *, so we need 	 a type conversion here to avoid a warning.  */
if|if
condition|(
name|p2
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|s1
argument_list|)
return|;
if|if
condition|(
name|p2
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRCHR
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
comment|/* New argument list transforming strstr(s1, s2) to 	 strchr(s1, s2[0]).  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|p2
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|s1
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Simplify a call to the strchr builtin.     Return 0 if no simplification was possible, otherwise return the    simplified form of the call as a tree.     The simplified form may be a constant or other expression which    computes the same value, but in a more efficient manner (including    calls to other builtin functions).     The call may contain arguments which need to be evaluated, but    which are not useful to determine the result of the call.  In    this case we return a chain of COMPOUND_EXPRs.  The LHS of each    COMPOUND_EXPR will be an argument which must be evaluated.    COMPOUND_EXPRs are chained through their RHS.  The RHS of the last    COMPOUND_EXPR in the chain will contain the tree for the simplified    form of the builtin function call.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_strchr
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|s1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|s2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|s2
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
name|p1
operator|=
name|c_getstr
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
block|{
name|char
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|r
decl_stmt|;
name|tree
name|tem
decl_stmt|;
if|if
condition|(
name|target_char_cast
argument_list|(
name|s2
argument_list|,
operator|&
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
name|r
operator|=
name|strchr
argument_list|(
name|p1
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Return an offset into the constant string argument.  */
name|tem
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|s1
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|r
operator|-
name|p1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Simplify a call to the strrchr builtin.     Return 0 if no simplification was possible, otherwise return the    simplified form of the call as a tree.     The simplified form may be a constant or other expression which    computes the same value, but in a more efficient manner (including    calls to other builtin functions).     The call may contain arguments which need to be evaluated, but    which are not useful to determine the result of the call.  In    this case we return a chain of COMPOUND_EXPRs.  The LHS of each    COMPOUND_EXPR will be an argument which must be evaluated.    COMPOUND_EXPRs are chained through their RHS.  The RHS of the last    COMPOUND_EXPR in the chain will contain the tree for the simplified    form of the builtin function call.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_strrchr
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|s1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|s2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|s2
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
name|p1
operator|=
name|c_getstr
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
block|{
name|char
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|r
decl_stmt|;
name|tree
name|tem
decl_stmt|;
if|if
condition|(
name|target_char_cast
argument_list|(
name|s2
argument_list|,
operator|&
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
name|r
operator|=
name|strrchr
argument_list|(
name|p1
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Return an offset into the constant string argument.  */
name|tem
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|s1
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|r
operator|-
name|p1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|s2
argument_list|)
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRCHR
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
comment|/* Transform strrchr(s1, '\0') to strchr(s1, '\0').  */
return|return
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Simplify a call to the strpbrk builtin.     Return 0 if no simplification was possible, otherwise return the    simplified form of the call as a tree.     The simplified form may be a constant or other expression which    computes the same value, but in a more efficient manner (including    calls to other builtin functions).     The call may contain arguments which need to be evaluated, but    which are not useful to determine the result of the call.  In    this case we return a chain of COMPOUND_EXPRs.  The LHS of each    COMPOUND_EXPR will be an argument which must be evaluated.    COMPOUND_EXPRs are chained through their RHS.  The RHS of the last    COMPOUND_EXPR in the chain will contain the tree for the simplified    form of the builtin function call.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_strpbrk
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|s1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|s2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|p2
operator|=
name|c_getstr
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|p1
operator|=
name|c_getstr
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|r
init|=
name|strpbrk
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
decl_stmt|;
name|tree
name|tem
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Return an offset into the constant string argument.  */
name|tem
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|s1
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|r
operator|-
name|p1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
if|if
condition|(
name|p2
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* strpbrk(x, "") == NULL. 	   Evaluate and ignore s1 in case it had side-effects.  */
return|return
name|omit_one_operand
argument_list|(
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|,
name|s1
argument_list|)
return|;
if|if
condition|(
name|p2
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
literal|0
return|;
comment|/* Really call strpbrk.  */
name|fn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRCHR
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
comment|/* New argument list transforming strpbrk(s1, s2) to 	 strchr(s1, s2[0]).  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|p2
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|s1
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Simplify a call to the strcat builtin.     Return 0 if no simplification was possible, otherwise return the    simplified form of the call as a tree.     The simplified form may be a constant or other expression which    computes the same value, but in a more efficient manner (including    calls to other builtin functions).     The call may contain arguments which need to be evaluated, but    which are not useful to determine the result of the call.  In    this case we return a chain of COMPOUND_EXPRs.  The LHS of each    COMPOUND_EXPR will be an argument which must be evaluated.    COMPOUND_EXPRs are chained through their RHS.  The RHS of the last    COMPOUND_EXPR in the chain will contain the tree for the simplified    form of the builtin function call.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_strcat
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|dst
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|src
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|c_getstr
argument_list|(
name|src
argument_list|)
decl_stmt|;
comment|/* If the string length is zero, return the dst parameter.  */
if|if
condition|(
name|p
operator|&&
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|dst
return|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Simplify a call to the strncat builtin.     Return 0 if no simplification was possible, otherwise return the    simplified form of the call as a tree.     The simplified form may be a constant or other expression which    computes the same value, but in a more efficient manner (including    calls to other builtin functions).     The call may contain arguments which need to be evaluated, but    which are not useful to determine the result of the call.  In    this case we return a chain of COMPOUND_EXPRs.  The LHS of each    COMPOUND_EXPR will be an argument which must be evaluated.    COMPOUND_EXPRs are chained through their RHS.  The RHS of the last    COMPOUND_EXPR in the chain will contain the tree for the simplified    form of the builtin function call.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_strncat
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|dst
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|src
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|c_getstr
argument_list|(
name|src
argument_list|)
decl_stmt|;
comment|/* If the requested length is zero, or the src parameter string 	 length is zero, return the dst parameter.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
operator|||
operator|(
name|p
operator|&&
operator|*
name|p
operator|==
literal|'\0'
operator|)
condition|)
return|return
name|omit_two_operands
argument_list|(
name|TREE_TYPE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|dst
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
return|;
comment|/* If the requested len is greater than or equal to the string 	 length, call strcat.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|len
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|p
operator|&&
name|compare_tree_int
argument_list|(
name|len
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|tree
name|newarglist
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dst
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
init|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRCAT
index|]
decl_stmt|;
comment|/* If the replacement _DECL isn't initialized, don't do the 	     transformation.  */
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|newarglist
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Simplify a call to the strspn builtin.     Return 0 if no simplification was possible, otherwise return the    simplified form of the call as a tree.     The simplified form may be a constant or other expression which    computes the same value, but in a more efficient manner (including    calls to other builtin functions).     The call may contain arguments which need to be evaluated, but    which are not useful to determine the result of the call.  In    this case we return a chain of COMPOUND_EXPRs.  The LHS of each    COMPOUND_EXPR will be an argument which must be evaluated.    COMPOUND_EXPRs are chained through their RHS.  The RHS of the last    COMPOUND_EXPR in the chain will contain the tree for the simplified    form of the builtin function call.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_strspn
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|s1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|s2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
init|=
name|c_getstr
argument_list|(
name|s1
argument_list|)
decl_stmt|,
modifier|*
name|p2
init|=
name|c_getstr
argument_list|(
name|s2
argument_list|)
decl_stmt|;
comment|/* If both arguments are constants, evaluate at compile-time.  */
if|if
condition|(
name|p1
operator|&&
name|p2
condition|)
block|{
specifier|const
name|size_t
name|r
init|=
name|strspn
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
decl_stmt|;
return|return
name|size_int
argument_list|(
name|r
argument_list|)
return|;
block|}
comment|/* If either argument is "", return 0.  */
if|if
condition|(
operator|(
name|p1
operator|&&
operator|*
name|p1
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|p2
operator|&&
operator|*
name|p2
operator|==
literal|'\0'
operator|)
condition|)
comment|/* Evaluate and ignore both arguments in case either one has 	   side-effects.  */
return|return
name|omit_two_operands
argument_list|(
name|integer_type_node
argument_list|,
name|integer_zero_node
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
return|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Simplify a call to the strcspn builtin.     Return 0 if no simplification was possible, otherwise return the    simplified form of the call as a tree.     The simplified form may be a constant or other expression which    computes the same value, but in a more efficient manner (including    calls to other builtin functions).     The call may contain arguments which need to be evaluated, but    which are not useful to determine the result of the call.  In    this case we return a chain of COMPOUND_EXPRs.  The LHS of each    COMPOUND_EXPR will be an argument which must be evaluated.    COMPOUND_EXPRs are chained through their RHS.  The RHS of the last    COMPOUND_EXPR in the chain will contain the tree for the simplified    form of the builtin function call.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_strcspn
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|s1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|s2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
init|=
name|c_getstr
argument_list|(
name|s1
argument_list|)
decl_stmt|,
modifier|*
name|p2
init|=
name|c_getstr
argument_list|(
name|s2
argument_list|)
decl_stmt|;
comment|/* If both arguments are constants, evaluate at compile-time.  */
if|if
condition|(
name|p1
operator|&&
name|p2
condition|)
block|{
specifier|const
name|size_t
name|r
init|=
name|strcspn
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
decl_stmt|;
return|return
name|size_int
argument_list|(
name|r
argument_list|)
return|;
block|}
comment|/* If the first argument is "", return 0.  */
if|if
condition|(
name|p1
operator|&&
operator|*
name|p1
operator|==
literal|'\0'
condition|)
block|{
comment|/* Evaluate and ignore argument s2 in case it has 	     side-effects.  */
return|return
name|omit_one_operand
argument_list|(
name|integer_type_node
argument_list|,
name|integer_zero_node
argument_list|,
name|s2
argument_list|)
return|;
block|}
comment|/* If the second argument is "", return __builtin_strlen(s1).  */
if|if
condition|(
name|p2
operator|&&
operator|*
name|p2
operator|==
literal|'\0'
condition|)
block|{
name|tree
name|newarglist
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|s1
argument_list|)
decl_stmt|,
name|fn
init|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRLEN
index|]
decl_stmt|;
comment|/* If the replacement _DECL isn't initialized, don't do the 	     transformation.  */
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|newarglist
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Fold a call to the fputs builtin.  IGNORE is true if the value returned    by the builtin will be ignored.  UNLOCKED is true is true if this    actually a call to fputs_unlocked.  If LEN in non-NULL, it represents    the known length of the string.  Return NULL_TREE if no simplification    was possible.  */
end_comment

begin_function
name|tree
name|fold_builtin_fputs
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|bool
name|ignore
parameter_list|,
name|bool
name|unlocked
parameter_list|,
name|tree
name|len
parameter_list|)
block|{
name|tree
name|fn
decl_stmt|;
comment|/* If we're using an unlocked function, assume the other unlocked      functions exist explicitly.  */
name|tree
specifier|const
name|fn_fputc
init|=
name|unlocked
condition|?
name|built_in_decls
index|[
name|BUILT_IN_FPUTC_UNLOCKED
index|]
else|:
name|implicit_built_in_decls
index|[
name|BUILT_IN_FPUTC
index|]
decl_stmt|;
name|tree
specifier|const
name|fn_fwrite
init|=
name|unlocked
condition|?
name|built_in_decls
index|[
name|BUILT_IN_FWRITE_UNLOCKED
index|]
else|:
name|implicit_built_in_decls
index|[
name|BUILT_IN_FWRITE
index|]
decl_stmt|;
comment|/* If the return value is used, don't do the transformation.  */
if|if
condition|(
operator|!
name|ignore
condition|)
return|return
literal|0
return|;
comment|/* Verify the arguments in the original call.  */
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|len
condition|)
name|len
operator|=
name|c_strlen
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Get the length of the string passed to fputs.  If the length      can't be determined, punt.  */
if|if
condition|(
operator|!
name|len
operator|||
name|TREE_CODE
argument_list|(
name|len
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|compare_tree_int
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* length is 0, delete the call entirely .  */
return|return
name|omit_one_operand
argument_list|(
name|integer_type_node
argument_list|,
name|integer_zero_node
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
literal|0
case|:
comment|/* length is 1, call fputc.  */
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|c_getstr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* New argument list transforming fputs(string, stream) to 	       fputc(string[0], stream).  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fputc
expr_stmt|;
break|break;
block|}
block|}
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
comment|/* length is greater than 1, call fwrite.  */
block|{
name|tree
name|string_arg
decl_stmt|;
comment|/* If optimizing for size keep fputs.  */
if|if
condition|(
name|optimize_size
condition|)
return|return
literal|0
return|;
name|string_arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* New argument list transforming fputs(string, stream) to 	   fwrite(string, 1, len, stream).  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size_one_node
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|string_arg
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fwrite
expr_stmt|;
break|break;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* If the replacement _DECL isn't initialized, don't do the      transformation.  */
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
comment|/* These optimizations are only performed when the result is ignored,      hence there's no need to cast the result to integer_type_node.  */
return|return
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold the new_arg's arguments (ARGLIST). Returns true if there was an error    produced.  False otherwise.  This is done so that we don't output the error    or warning twice or three times.  */
end_comment

begin_function
name|bool
name|fold_builtin_next_arg
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"%<va_start%> used in function with fixed args"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|arglist
condition|)
block|{
comment|/* Evidently an out of date version of<stdarg.h>; can't validate 	 va_start's second argument, but can still work as intended.  */
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%<__builtin_next_arg%> called without an argument"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* We use __builtin_va_start (ap, 0, 0) or __builtin_next_arg (0, 0)      when we checked the arguments and if needed issued a warning.  */
elseif|else
if|if
condition|(
operator|!
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|||
operator|!
name|integer_zerop
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|||
operator|!
name|integer_zerop
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|||
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|last_parm
init|=
name|tree_last
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%<va_start%> used with too many arguments"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Strip off all nops for the sake of the comparison.  This 	 is not quite the same as STRIP_NOPS.  It does more. 	 We must also strip off INDIRECT_EXPR for C++ reference 	 parameters.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
name|last_parm
condition|)
block|{
comment|/* FIXME: Sometimes with the tree optimizers we can get the 	     not the last argument even though the user used the last 	     argument.  We just warn and set the arg to be the last 	     argument so that we will get wrong-code because of 	     it.  */
name|warning
argument_list|(
literal|0
argument_list|,
literal|"second parameter of %<va_start%> not last named argument"
argument_list|)
expr_stmt|;
block|}
comment|/* We want to verify the second parameter just once before the tree 	 optimizers are run and then avoid keeping it in the tree, 	 as otherwise we could warn even for correct code like: 	 void foo (int i, ...) 	 { va_list ap; i++; va_start (ap, i); va_end (ap); }  */
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Simplify a call to the sprintf builtin.     Return 0 if no simplification was possible, otherwise return the    simplified form of the call as a tree.  If IGNORED is true, it means that    the caller does not use the returned value of the function.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_sprintf
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|int
name|ignored
parameter_list|)
block|{
name|tree
name|call
decl_stmt|,
name|retval
decl_stmt|,
name|dest
decl_stmt|,
name|fmt
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt_str
init|=
name|NULL
decl_stmt|;
comment|/* Verify the required arguments in the original call.  We deal with two      types of sprintf() calls: 'sprintf (str, fmt)' and      'sprintf (dest, "%s", orig)'.  */
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
operator|&&
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Get the destination string and the format specifier.  */
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check whether the format is a literal string constant.  */
name|fmt_str
operator|=
name|c_getstr
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt_str
operator|==
name|NULL
condition|)
return|return
name|NULL_TREE
return|;
name|call
operator|=
name|NULL_TREE
expr_stmt|;
name|retval
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|init_target_chars
argument_list|()
condition|)
return|return
literal|0
return|;
comment|/* If the format doesn't contain % args or %%, use strcpy.  */
if|if
condition|(
name|strchr
argument_list|(
name|fmt_str
argument_list|,
name|target_percent
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|tree
name|fn
init|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRCPY
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Don't optimize sprintf (buf, "abc", ptr++).  */
if|if
condition|(
name|arglist
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Convert sprintf (str, fmt) into strcpy (str, fmt) when 	 'format' is known to contain no % formats.  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|call
operator|=
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ignored
condition|)
name|retval
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|strlen
argument_list|(
name|fmt_str
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the format is "%s", use strcpy if the result isn't used.  */
elseif|else
if|if
condition|(
name|fmt_str
operator|&&
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
name|target_percent_s
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|fn
decl_stmt|,
name|orig
decl_stmt|;
name|fn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRCPY
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Don't crash on sprintf (str1, "%s").  */
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Convert sprintf (str1, "%s", str2) into strcpy (str1, str2).  */
name|orig
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|orig
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ignored
condition|)
block|{
name|retval
operator|=
name|c_strlen
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
operator|||
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|NULL_TREE
return|;
block|}
name|call
operator|=
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|call
operator|&&
name|retval
condition|)
block|{
name|retval
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|implicit_built_in_decls
index|[
name|BUILT_IN_SPRINTF
index|]
argument_list|)
argument_list|)
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
argument_list|,
name|call
argument_list|,
name|retval
argument_list|)
return|;
block|}
else|else
return|return
name|call
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to __builtin_object_size.  */
end_comment

begin_function
name|rtx
name|expand_builtin_object_size
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|ost
decl_stmt|;
name|int
name|object_size_type
decl_stmt|;
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|location_t
name|locus
init|=
name|EXPR_LOCATION
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Hfirst argument of %D must be a pointer, second integer constant"
argument_list|,
operator|&
name|locus
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|expand_builtin_trap
argument_list|()
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|ost
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|ost
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ost
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|tree_int_cst_sgn
argument_list|(
name|ost
argument_list|)
operator|<
literal|0
operator|||
name|compare_tree_int
argument_list|(
name|ost
argument_list|,
literal|3
argument_list|)
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%Hlast argument of %D is not integer constant between 0 and 3"
argument_list|,
operator|&
name|locus
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|expand_builtin_trap
argument_list|()
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|object_size_type
operator|=
name|tree_low_cst
argument_list|(
name|ost
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|object_size_type
operator|<
literal|2
condition|?
name|constm1_rtx
else|:
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* Expand EXP, a call to the __mem{cpy,pcpy,move,set}_chk builtin.    FCODE is the BUILT_IN_* to use.    Return 0 if we failed; the caller should emit a normal call,    otherwise try to get the result in TARGET, if convenient (and in    mode MODE if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_memory_chk
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|built_in_function
name|fcode
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|len
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|fcode
operator|==
name|BUILT_IN_MEMSET_CHK
condition|?
name|INTEGER_TYPE
else|:
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|||
name|integer_all_onesp
argument_list|(
name|size
argument_list|)
condition|)
block|{
name|tree
name|fn
decl_stmt|;
if|if
condition|(
operator|!
name|integer_all_onesp
argument_list|(
name|size
argument_list|)
operator|&&
name|tree_int_cst_lt
argument_list|(
name|size
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|location_t
name|locus
init|=
name|EXPR_LOCATION
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%Hcall to %D will always overflow destination buffer"
argument_list|,
operator|&
name|locus
argument_list|,
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If __builtin_mem{cpy,pcpy,move,set}_chk is used, assume 	 mem{cpy,pcpy,move,set} is available.  */
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|BUILT_IN_MEMCPY_CHK
case|:
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_MEMCPY
index|]
expr_stmt|;
break|break;
case|case
name|BUILT_IN_MEMPCPY_CHK
case|:
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_MEMPCPY
index|]
expr_stmt|;
break|break;
case|case
name|BUILT_IN_MEMMOVE_CHK
case|:
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_MEMMOVE
index|]
expr_stmt|;
break|break;
case|case
name|BUILT_IN_MEMSET_CHK
case|:
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_MEMSET
index|]
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|CALL_EXPR_TAILCALL
argument_list|(
name|fn
argument_list|)
operator|=
name|CALL_EXPR_TAILCALL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|fn
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_MEMSET_CHK
condition|)
return|return
literal|0
return|;
else|else
block|{
name|unsigned
name|int
name|dest_align
init|=
name|get_pointer_alignment
argument_list|(
name|dest
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
comment|/* If DEST is not a pointer type, call the normal function.  */
if|if
condition|(
name|dest_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If SRC and DEST are the same (and not volatile), do nothing.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|expr
decl_stmt|;
if|if
condition|(
name|fcode
operator|!=
name|BUILT_IN_MEMPCPY_CHK
condition|)
block|{
comment|/* Evaluate and ignore LEN in case it has side-effects.  */
name|expand_expr
argument_list|(
name|len
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|dest
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
name|len
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|expr
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|dest
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|expr
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* __memmove_chk special case.  */
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_MEMMOVE_CHK
condition|)
block|{
name|unsigned
name|int
name|src_align
init|=
name|get_pointer_alignment
argument_list|(
name|src
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
if|if
condition|(
name|src_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If src is categorized for a readonly section we can use 	     normal __memcpy_chk.  */
if|if
condition|(
name|readonly_data_expr
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|tree
name|fn
init|=
name|built_in_decls
index|[
name|BUILT_IN_MEMCPY_CHK
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|CALL_EXPR_TAILCALL
argument_list|(
name|fn
argument_list|)
operator|=
name|CALL_EXPR_TAILCALL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|fn
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Emit warning if a buffer overflow is detected at compile time.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_emit_chk_warning
parameter_list|(
name|tree
name|exp
parameter_list|,
name|enum
name|built_in_function
name|fcode
parameter_list|)
block|{
name|int
name|arg_mask
decl_stmt|,
name|is_strlen
init|=
literal|0
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|,
name|a
decl_stmt|;
name|tree
name|len
decl_stmt|,
name|size
decl_stmt|;
name|location_t
name|locus
decl_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|BUILT_IN_STRCPY_CHK
case|:
case|case
name|BUILT_IN_STPCPY_CHK
case|:
comment|/* For __strcat_chk the warning will be emitted only if overflowing        by at least strlen (dest) + 1 bytes.  */
case|case
name|BUILT_IN_STRCAT_CHK
case|:
name|arg_mask
operator|=
literal|6
expr_stmt|;
name|is_strlen
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BUILT_IN_STRNCPY_CHK
case|:
name|arg_mask
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|BUILT_IN_SNPRINTF_CHK
case|:
case|case
name|BUILT_IN_VSNPRINTF_CHK
case|:
name|arg_mask
operator|=
literal|10
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|len
operator|=
name|NULL_TREE
expr_stmt|;
name|size
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|a
operator|=
name|arglist
init|;
name|a
operator|&&
name|arg_mask
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|,
name|arg_mask
operator|>>=
literal|1
control|)
if|if
condition|(
name|arg_mask
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|len
condition|)
name|size
operator|=
name|a
expr_stmt|;
else|else
name|len
operator|=
name|a
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|len
operator|||
operator|!
name|size
condition|)
return|return;
name|len
operator|=
name|TREE_VALUE
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|size
operator|=
name|TREE_VALUE
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
operator|||
name|integer_all_onesp
argument_list|(
name|size
argument_list|)
condition|)
return|return;
if|if
condition|(
name|is_strlen
condition|)
block|{
name|len
operator|=
name|c_strlen
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
operator|!
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|||
name|tree_int_cst_lt
argument_list|(
name|len
argument_list|,
name|size
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|tree_int_cst_lt
argument_list|(
name|size
argument_list|,
name|len
argument_list|)
condition|)
return|return;
name|locus
operator|=
name|EXPR_LOCATION
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%Hcall to %D will always overflow destination buffer"
argument_list|,
operator|&
name|locus
argument_list|,
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit warning if a buffer overflow is detected at compile time    in __sprintf_chk/__vsprintf_chk calls.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_emit_sprintf_chk_warning
parameter_list|(
name|tree
name|exp
parameter_list|,
name|enum
name|built_in_function
name|fcode
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|dest
decl_stmt|,
name|size
decl_stmt|,
name|len
decl_stmt|,
name|fmt
decl_stmt|,
name|flag
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt_str
decl_stmt|;
comment|/* Verify the required arguments in the original call.  */
if|if
condition|(
operator|!
name|arglist
condition|)
return|return;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arglist
condition|)
return|return;
name|flag
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arglist
condition|)
return|return;
name|size
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arglist
condition|)
return|return;
name|fmt
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
operator|||
name|integer_all_onesp
argument_list|(
name|size
argument_list|)
condition|)
return|return;
comment|/* Check whether the format is a literal string constant.  */
name|fmt_str
operator|=
name|c_getstr
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt_str
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|init_target_chars
argument_list|()
condition|)
return|return;
comment|/* If the format doesn't contain % args or %%, we know its size.  */
if|if
condition|(
name|strchr
argument_list|(
name|fmt_str
argument_list|,
name|target_percent
argument_list|)
operator|==
literal|0
condition|)
name|len
operator|=
name|build_int_cstu
argument_list|(
name|size_type_node
argument_list|,
name|strlen
argument_list|(
name|fmt_str
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the format is "%s" and first ... argument is a string literal,      we know it too.  */
elseif|else
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_SPRINTF_CHK
operator|&&
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
name|target_percent_s
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|arglist
condition|)
return|return;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
return|return;
name|len
operator|=
name|c_strlen
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
operator|!
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
block|}
else|else
return|return;
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|len
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|location_t
name|locus
init|=
name|EXPR_LOCATION
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%Hcall to %D will always overflow destination buffer"
argument_list|,
operator|&
name|locus
argument_list|,
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fold a call to __builtin_object_size, if possible.  */
end_comment

begin_function
name|tree
name|fold_builtin_object_size
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|ptr
decl_stmt|,
name|ost
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|object_size_type
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|ptr
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|ost
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|ost
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ost
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|tree_int_cst_sgn
argument_list|(
name|ost
argument_list|)
operator|<
literal|0
operator|||
name|compare_tree_int
argument_list|(
name|ost
argument_list|,
literal|3
argument_list|)
operator|>
literal|0
condition|)
return|return
literal|0
return|;
name|object_size_type
operator|=
name|tree_low_cst
argument_list|(
name|ost
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* __builtin_object_size doesn't evaluate side-effects in its arguments;      if there are any side-effects, it returns (size_t) -1 for types 0 and 1      and (size_t) 0 for types 2 and 3.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|ptr
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|size_type_node
argument_list|,
name|object_size_type
operator|<
literal|2
condition|?
name|integer_minus_one_node
else|:
name|integer_zero_node
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ptr
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|ret
operator|=
name|build_int_cstu
argument_list|(
name|size_type_node
argument_list|,
name|compute_builtin_object_size
argument_list|(
name|ptr
argument_list|,
name|object_size_type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ptr
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|bytes
decl_stmt|;
comment|/* If object size is not known yet, delay folding until        later.  Maybe subsequent passes will help determining        it.  */
name|bytes
operator|=
name|compute_builtin_object_size
argument_list|(
name|ptr
argument_list|,
name|object_size_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|!=
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|object_size_type
operator|<
literal|2
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|)
condition|)
name|ret
operator|=
name|build_int_cstu
argument_list|(
name|size_type_node
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
block|{
name|ret
operator|=
name|force_fit_type
argument_list|(
name|ret
argument_list|,
operator|-
literal|1
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|ret
argument_list|)
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to the __mem{cpy,pcpy,move,set}_chk builtin.    IGNORE is true, if return value can be ignored.  FCODE is the BUILT_IN_*    code of the builtin.  If MAXLEN is not NULL, it is maximum length    passed as third argument.  */
end_comment

begin_function
name|tree
name|fold_builtin_memory_chk
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|tree
name|maxlen
parameter_list|,
name|bool
name|ignore
parameter_list|,
name|enum
name|built_in_function
name|fcode
parameter_list|)
block|{
name|tree
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|len
decl_stmt|,
name|size
decl_stmt|,
name|fn
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|fcode
operator|==
name|BUILT_IN_MEMSET_CHK
condition|?
name|INTEGER_TYPE
else|:
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* Actually val for __memset_chk, but it doesn't matter.  */
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If SRC and DEST are the same (and not volatile), return DEST      (resp. DEST+LEN for __mempcpy_chk).  */
if|if
condition|(
name|fcode
operator|!=
name|BUILT_IN_MEMSET_CHK
operator|&&
name|operand_equal_p
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|fcode
operator|!=
name|BUILT_IN_MEMPCPY_CHK
condition|)
return|return
name|omit_one_operand
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|dest
argument_list|,
name|len
argument_list|)
return|;
else|else
block|{
name|tree
name|temp
init|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|temp
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|dest
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|integer_all_onesp
argument_list|(
name|size
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* If LEN is not constant, try MAXLEN too. 	     For MAXLEN only allow optimizing into non-_ocs function 	     if SIZE is>= MAXLEN, never convert to __ocs_fail ().  */
if|if
condition|(
name|maxlen
operator|==
name|NULL_TREE
operator|||
operator|!
name|host_integerp
argument_list|(
name|maxlen
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_MEMPCPY_CHK
operator|&&
name|ignore
condition|)
block|{
comment|/* (void) __mempcpy_chk () can be optimized into 		     (void) __memcpy_chk ().  */
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_MEMCPY_CHK
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
else|else
name|maxlen
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|size
argument_list|,
name|maxlen
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If __builtin_mem{cpy,pcpy,move,set}_chk is used, assume      mem{cpy,pcpy,move,set} is available.  */
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|BUILT_IN_MEMCPY_CHK
case|:
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_MEMCPY
index|]
expr_stmt|;
break|break;
case|case
name|BUILT_IN_MEMPCPY_CHK
case|:
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_MEMPCPY
index|]
expr_stmt|;
break|break;
case|case
name|BUILT_IN_MEMMOVE_CHK
case|:
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_MEMMOVE
index|]
expr_stmt|;
break|break;
case|case
name|BUILT_IN_MEMSET_CHK
case|:
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_MEMSET
index|]
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to the __st[rp]cpy_chk builtin.    IGNORE is true, if return value can be ignored.  FCODE is the BUILT_IN_*    code of the builtin.  If MAXLEN is not NULL, it is maximum length of    strings passed as second argument.  */
end_comment

begin_function
name|tree
name|fold_builtin_stxcpy_chk
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|tree
name|maxlen
parameter_list|,
name|bool
name|ignore
parameter_list|,
name|enum
name|built_in_function
name|fcode
parameter_list|)
block|{
name|tree
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|size
decl_stmt|,
name|len
decl_stmt|,
name|fn
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If SRC and DEST are the same (and not volatile), return DEST.  */
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_STRCPY_CHK
operator|&&
name|operand_equal_p
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|dest
argument_list|)
return|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|integer_all_onesp
argument_list|(
name|size
argument_list|)
condition|)
block|{
name|len
operator|=
name|c_strlen
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
operator|!
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* If LEN is not constant, try MAXLEN too. 	     For MAXLEN only allow optimizing into non-_ocs function 	     if SIZE is>= MAXLEN, never convert to __ocs_fail ().  */
if|if
condition|(
name|maxlen
operator|==
name|NULL_TREE
operator|||
operator|!
name|host_integerp
argument_list|(
name|maxlen
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_STPCPY_CHK
condition|)
block|{
if|if
condition|(
operator|!
name|ignore
condition|)
return|return
literal|0
return|;
comment|/* If return value of __stpcpy_chk is ignored, 		     optimize into __strcpy_chk.  */
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_STRCPY_CHK
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|len
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If c_strlen returned something, but not a constant, 		 transform __strcpy_chk into __memcpy_chk.  */
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_MEMCPY_CHK
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|len
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|)
return|;
block|}
block|}
else|else
name|maxlen
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|maxlen
argument_list|,
name|size
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
comment|/* If __builtin_st{r,p}cpy_chk is used, assume st{r,p}cpy is available.  */
name|fn
operator|=
name|built_in_decls
index|[
name|fcode
operator|==
name|BUILT_IN_STPCPY_CHK
condition|?
name|BUILT_IN_STPCPY
else|:
name|BUILT_IN_STRCPY
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to the __strncpy_chk builtin.    If MAXLEN is not NULL, it is maximum length passed as third argument.  */
end_comment

begin_function
name|tree
name|fold_builtin_strncpy_chk
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|maxlen
parameter_list|)
block|{
name|tree
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|size
decl_stmt|,
name|len
decl_stmt|,
name|fn
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|integer_all_onesp
argument_list|(
name|size
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* If LEN is not constant, try MAXLEN too. 	     For MAXLEN only allow optimizing into non-_ocs function 	     if SIZE is>= MAXLEN, never convert to __ocs_fail ().  */
if|if
condition|(
name|maxlen
operator|==
name|NULL_TREE
operator|||
operator|!
name|host_integerp
argument_list|(
name|maxlen
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
name|maxlen
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|size
argument_list|,
name|maxlen
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
comment|/* If __builtin_strncpy_chk is used, assume strncpy is available.  */
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_STRNCPY
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to the __strcat_chk builtin FNDECL with ARGLIST.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_strcat_chk
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|size
decl_stmt|,
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|c_getstr
argument_list|(
name|src
argument_list|)
expr_stmt|;
comment|/* If the SRC parameter is "", return DEST.  */
if|if
condition|(
name|p
operator|&&
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|omit_one_operand
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
return|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|integer_all_onesp
argument_list|(
name|size
argument_list|)
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
comment|/* If __builtin_strcat_chk is used, assume strcat is available.  */
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_STRCAT
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to the __strncat_chk builtin EXP.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_strncat_chk
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|size
decl_stmt|,
name|len
decl_stmt|,
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|c_getstr
argument_list|(
name|src
argument_list|)
expr_stmt|;
comment|/* If the SRC parameter is "" or if LEN is 0, return DEST.  */
if|if
condition|(
name|p
operator|&&
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|omit_one_operand
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|dest
argument_list|,
name|len
argument_list|)
return|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
return|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|integer_all_onesp
argument_list|(
name|size
argument_list|)
condition|)
block|{
name|tree
name|src_len
init|=
name|c_strlen
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|src_len
operator|&&
name|host_integerp
argument_list|(
name|src_len
argument_list|,
literal|1
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|tree_int_cst_lt
argument_list|(
name|len
argument_list|,
name|src_len
argument_list|)
condition|)
block|{
comment|/* If LEN>= strlen (SRC), optimize into __strcat_chk.  */
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_STRCAT_CHK
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
comment|/* If __builtin_strncat_chk is used, assume strncat is available.  */
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_STRNCAT
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to __{,v}sprintf_chk with argument list ARGLIST.  Return 0 if    a normal call should be emitted rather than expanding the function    inline.  FCODE is either BUILT_IN_SPRINTF_CHK or BUILT_IN_VSPRINTF_CHK.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_sprintf_chk
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|enum
name|built_in_function
name|fcode
parameter_list|)
block|{
name|tree
name|dest
decl_stmt|,
name|size
decl_stmt|,
name|len
decl_stmt|,
name|fn
decl_stmt|,
name|fmt
decl_stmt|,
name|flag
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt_str
decl_stmt|;
comment|/* Verify the required arguments in the original call.  */
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|flag
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|flag
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|size
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|fmt
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fmt
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|init_target_chars
argument_list|()
condition|)
return|return
literal|0
return|;
comment|/* Check whether the format is a literal string constant.  */
name|fmt_str
operator|=
name|c_getstr
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt_str
operator|!=
name|NULL
condition|)
block|{
comment|/* If the format doesn't contain % args or %%, we know the size.  */
if|if
condition|(
name|strchr
argument_list|(
name|fmt_str
argument_list|,
name|target_percent
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fcode
operator|!=
name|BUILT_IN_SPRINTF_CHK
operator|||
name|arglist
operator|==
name|NULL_TREE
condition|)
name|len
operator|=
name|build_int_cstu
argument_list|(
name|size_type_node
argument_list|,
name|strlen
argument_list|(
name|fmt_str
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the format is "%s" and first ... argument is a string literal, 	 we know the size too.  */
elseif|else
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_SPRINTF_CHK
operator|&&
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
name|target_percent_s
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|arg
decl_stmt|;
if|if
condition|(
name|arglist
operator|&&
operator|!
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
block|{
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
block|{
name|len
operator|=
name|c_strlen
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
operator|!
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
condition|)
name|len
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|integer_all_onesp
argument_list|(
name|size
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|len
operator|||
operator|!
name|tree_int_cst_lt
argument_list|(
name|len
argument_list|,
name|size
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Only convert __{,v}sprintf_chk to {,v}sprintf if flag is 0      or if format doesn't contain % chars or is "%s".  */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|flag
argument_list|)
condition|)
block|{
if|if
condition|(
name|fmt_str
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strchr
argument_list|(
name|fmt_str
argument_list|,
name|target_percent
argument_list|)
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
name|target_percent_s
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fmt
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
comment|/* If __builtin_{,v}sprintf_chk is used, assume {,v}sprintf is available.  */
name|fn
operator|=
name|built_in_decls
index|[
name|fcode
operator|==
name|BUILT_IN_VSPRINTF_CHK
condition|?
name|BUILT_IN_VSPRINTF
else|:
name|BUILT_IN_SPRINTF
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to {,v}snprintf with argument list ARGLIST.  Return 0 if    a normal call should be emitted rather than expanding the function    inline.  FCODE is either BUILT_IN_SNPRINTF_CHK or    BUILT_IN_VSNPRINTF_CHK.  If MAXLEN is not NULL, it is maximum length    passed as second argument.  */
end_comment

begin_function
name|tree
name|fold_builtin_snprintf_chk
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|maxlen
parameter_list|,
name|enum
name|built_in_function
name|fcode
parameter_list|)
block|{
name|tree
name|dest
decl_stmt|,
name|size
decl_stmt|,
name|len
decl_stmt|,
name|fn
decl_stmt|,
name|fmt
decl_stmt|,
name|flag
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt_str
decl_stmt|;
comment|/* Verify the required arguments in the original call.  */
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|len
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|flag
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|len
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|size
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|fmt
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fmt
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|integer_all_onesp
argument_list|(
name|size
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* If LEN is not constant, try MAXLEN too. 	     For MAXLEN only allow optimizing into non-_ocs function 	     if SIZE is>= MAXLEN, never convert to __ocs_fail ().  */
if|if
condition|(
name|maxlen
operator|==
name|NULL_TREE
operator|||
operator|!
name|host_integerp
argument_list|(
name|maxlen
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
name|maxlen
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|size
argument_list|,
name|maxlen
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|init_target_chars
argument_list|()
condition|)
return|return
literal|0
return|;
comment|/* Only convert __{,v}snprintf_chk to {,v}snprintf if flag is 0      or if format doesn't contain % chars or is "%s".  */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|flag
argument_list|)
condition|)
block|{
name|fmt_str
operator|=
name|c_getstr
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt_str
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strchr
argument_list|(
name|fmt_str
argument_list|,
name|target_percent
argument_list|)
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
name|target_percent_s
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fmt
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
comment|/* If __builtin_{,v}snprintf_chk is used, assume {,v}snprintf is      available.  */
name|fn
operator|=
name|built_in_decls
index|[
name|fcode
operator|==
name|BUILT_IN_VSNPRINTF_CHK
condition|?
name|BUILT_IN_VSNPRINTF
else|:
name|BUILT_IN_SNPRINTF
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to the {,v}printf{,_unlocked} and __{,v}printf_chk builtins.     Return 0 if no simplification was possible, otherwise return the    simplified form of the call as a tree.  FCODE is the BUILT_IN_*    code of the function to be simplified.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_printf
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|bool
name|ignore
parameter_list|,
name|enum
name|built_in_function
name|fcode
parameter_list|)
block|{
name|tree
name|fmt
decl_stmt|,
name|fn
init|=
name|NULL_TREE
decl_stmt|,
name|fn_putchar
decl_stmt|,
name|fn_puts
decl_stmt|,
name|arg
decl_stmt|,
name|call
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt_str
init|=
name|NULL
decl_stmt|;
comment|/* If the return value is used, don't do the transformation.  */
if|if
condition|(
operator|!
name|ignore
condition|)
return|return
literal|0
return|;
comment|/* Verify the required arguments in the original call.  */
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_PRINTF_CHK
operator|||
name|fcode
operator|==
name|BUILT_IN_VPRINTF_CHK
condition|)
block|{
name|tree
name|flag
decl_stmt|;
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|flag
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|flag
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|flag
argument_list|)
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|fmt
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fmt
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* Check whether the format is a literal string constant.  */
name|fmt_str
operator|=
name|c_getstr
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt_str
operator|==
name|NULL
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_PRINTF_UNLOCKED
condition|)
block|{
comment|/* If we're using an unlocked function, assume the other 	 unlocked functions exist explicitly.  */
name|fn_putchar
operator|=
name|built_in_decls
index|[
name|BUILT_IN_PUTCHAR_UNLOCKED
index|]
expr_stmt|;
name|fn_puts
operator|=
name|built_in_decls
index|[
name|BUILT_IN_PUTS_UNLOCKED
index|]
expr_stmt|;
block|}
else|else
block|{
name|fn_putchar
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_PUTCHAR
index|]
expr_stmt|;
name|fn_puts
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_PUTS
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|init_target_chars
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
name|target_percent_s
argument_list|)
operator|==
literal|0
operator|||
name|strchr
argument_list|(
name|fmt_str
argument_list|,
name|target_percent
argument_list|)
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
name|target_percent_s
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_VPRINTF
operator|||
name|fcode
operator|==
name|BUILT_IN_VPRINTF_CHK
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|arglist
operator|||
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
literal|0
return|;
name|str
operator|=
name|c_getstr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* The format specifier doesn't contain any '%' characters.  */
if|if
condition|(
name|fcode
operator|!=
name|BUILT_IN_VPRINTF
operator|&&
name|fcode
operator|!=
name|BUILT_IN_VPRINTF_CHK
operator|&&
name|arglist
condition|)
return|return
literal|0
return|;
name|str
operator|=
name|fmt_str
expr_stmt|;
block|}
comment|/* If the string was "", printf does nothing.  */
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
comment|/* If the string has length of 1, call putchar.  */
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Given printf("c"), (where c is any one character,) 	     convert "c"[0] to an int and pass that to the replacement 	     function.  */
name|arg
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|str
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_putchar
expr_stmt|;
block|}
else|else
block|{
comment|/* If the string was "string\n", call puts("string").  */
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|str
index|[
name|len
operator|-
literal|1
index|]
operator|==
name|target_newline
condition|)
block|{
comment|/* Create a NUL-terminated string that's one char shorter 		 than the original, stripping off the trailing '\n'.  */
name|char
modifier|*
name|newstr
init|=
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newstr
argument_list|,
name|str
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|newstr
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|arg
operator|=
name|build_string_literal
argument_list|(
name|len
argument_list|,
name|newstr
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_puts
expr_stmt|;
block|}
else|else
comment|/* We'd like to arrange to call fputs(string,stdout) here, 	       but we need stdout and don't have a way to get it yet.  */
return|return
literal|0
return|;
block|}
block|}
comment|/* The other optimizations can be done only on the non-va_list variants.  */
elseif|else
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_VPRINTF
operator|||
name|fcode
operator|==
name|BUILT_IN_VPRINTF_CHK
condition|)
return|return
literal|0
return|;
comment|/* If the format specifier was "%s\n", call __builtin_puts(arg).  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
name|target_percent_s_newline
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|arglist
operator|||
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|fn_puts
expr_stmt|;
block|}
comment|/* If the format specifier was "%c", call __builtin_putchar(arg).  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
name|target_percent_c
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|arglist
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|fn_putchar
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
name|call
operator|=
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|call
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to the {,v}fprintf{,_unlocked} and __{,v}printf_chk builtins.     Return 0 if no simplification was possible, otherwise return the    simplified form of the call as a tree.  FCODE is the BUILT_IN_*    code of the function to be simplified.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_fprintf
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|bool
name|ignore
parameter_list|,
name|enum
name|built_in_function
name|fcode
parameter_list|)
block|{
name|tree
name|fp
decl_stmt|,
name|fmt
decl_stmt|,
name|fn
init|=
name|NULL_TREE
decl_stmt|,
name|fn_fputc
decl_stmt|,
name|fn_fputs
decl_stmt|,
name|arg
decl_stmt|,
name|call
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt_str
init|=
name|NULL
decl_stmt|;
comment|/* If the return value is used, don't do the transformation.  */
if|if
condition|(
operator|!
name|ignore
condition|)
return|return
literal|0
return|;
comment|/* Verify the required arguments in the original call.  */
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|fp
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_FPRINTF_CHK
operator|||
name|fcode
operator|==
name|BUILT_IN_VFPRINTF_CHK
condition|)
block|{
name|tree
name|flag
decl_stmt|;
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|flag
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|flag
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|flag
argument_list|)
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|fmt
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fmt
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* Check whether the format is a literal string constant.  */
name|fmt_str
operator|=
name|c_getstr
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt_str
operator|==
name|NULL
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_FPRINTF_UNLOCKED
condition|)
block|{
comment|/* If we're using an unlocked function, assume the other 	 unlocked functions exist explicitly.  */
name|fn_fputc
operator|=
name|built_in_decls
index|[
name|BUILT_IN_FPUTC_UNLOCKED
index|]
expr_stmt|;
name|fn_fputs
operator|=
name|built_in_decls
index|[
name|BUILT_IN_FPUTS_UNLOCKED
index|]
expr_stmt|;
block|}
else|else
block|{
name|fn_fputc
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_FPUTC
index|]
expr_stmt|;
name|fn_fputs
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_FPUTS
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|init_target_chars
argument_list|()
condition|)
return|return
literal|0
return|;
comment|/* If the format doesn't contain % args or %%, use strcpy.  */
if|if
condition|(
name|strchr
argument_list|(
name|fmt_str
argument_list|,
name|target_percent
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|fcode
operator|!=
name|BUILT_IN_VFPRINTF
operator|&&
name|fcode
operator|!=
name|BUILT_IN_VFPRINTF_CHK
operator|&&
name|arglist
condition|)
return|return
literal|0
return|;
comment|/* If the format specifier was "", fprintf does nothing.  */
if|if
condition|(
name|fmt_str
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* If FP has side-effects, just wait until gimplification is 	     done.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|fp
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* When "string" doesn't contain %, replace all cases of 	 fprintf (fp, string) with fputs (string, fp).  The fputs 	 builtin will take care of special cases like length == 1.  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fmt
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fputs
expr_stmt|;
block|}
comment|/* The other optimizations can be done only on the non-va_list variants.  */
elseif|else
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_VFPRINTF
operator|||
name|fcode
operator|==
name|BUILT_IN_VFPRINTF_CHK
condition|)
return|return
literal|0
return|;
comment|/* If the format specifier was "%s", call __builtin_fputs (arg, fp).  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
name|target_percent_s
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|arglist
operator|||
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fputs
expr_stmt|;
block|}
comment|/* If the format specifier was "%c", call __builtin_fputc (arg, fp).  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
name|target_percent_c
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|arglist
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fputc
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
name|call
operator|=
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|call
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize format string characters in the target charset.  */
end_comment

begin_function
specifier|static
name|bool
name|init_target_chars
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|bool
name|init
decl_stmt|;
if|if
condition|(
operator|!
name|init
condition|)
block|{
name|target_newline
operator|=
name|lang_hooks
operator|.
name|to_target_charset
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|target_percent
operator|=
name|lang_hooks
operator|.
name|to_target_charset
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
name|target_c
operator|=
name|lang_hooks
operator|.
name|to_target_charset
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
name|target_s
operator|=
name|lang_hooks
operator|.
name|to_target_charset
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_newline
operator|==
literal|0
operator|||
name|target_percent
operator|==
literal|0
operator|||
name|target_c
operator|==
literal|0
operator|||
name|target_s
operator|==
literal|0
condition|)
return|return
name|false
return|;
name|target_percent_c
index|[
literal|0
index|]
operator|=
name|target_percent
expr_stmt|;
name|target_percent_c
index|[
literal|1
index|]
operator|=
name|target_c
expr_stmt|;
name|target_percent_c
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|target_percent_s
index|[
literal|0
index|]
operator|=
name|target_percent
expr_stmt|;
name|target_percent_s
index|[
literal|1
index|]
operator|=
name|target_s
expr_stmt|;
name|target_percent_s
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|target_percent_s_newline
index|[
literal|0
index|]
operator|=
name|target_percent
expr_stmt|;
name|target_percent_s_newline
index|[
literal|1
index|]
operator|=
name|target_s
expr_stmt|;
name|target_percent_s_newline
index|[
literal|2
index|]
operator|=
name|target_newline
expr_stmt|;
name|target_percent_s_newline
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|init
operator|=
name|true
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

end_unit

