begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Expand builtin functions.    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"typeclass.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"predict.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_define
define|#
directive|define
name|CALLED_AS_BUILT_IN
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(!strncmp (IDENTIFIER_POINTER (DECL_NAME (NODE)), "__builtin_", 10))
end_define

begin_comment
comment|/* Register mappings for target machines without register windows.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INCOMING_REGNO
end_ifndef

begin_define
define|#
directive|define
name|INCOMING_REGNO
parameter_list|(
name|OUT
parameter_list|)
value|(OUT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OUTGOING_REGNO
end_ifndef

begin_define
define|#
directive|define
name|OUTGOING_REGNO
parameter_list|(
name|IN
parameter_list|)
value|(IN)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PAD_VARARGS_DOWN
end_ifndef

begin_define
define|#
directive|define
name|PAD_VARARGS_DOWN
value|BYTES_BIG_ENDIAN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define the names of the builtin function types and codes.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|built_in_class_names
index|[
literal|4
index|]
init|=
block|{
literal|"NOT_BUILT_IN"
block|,
literal|"BUILT_IN_FRONTEND"
block|,
literal|"BUILT_IN_MD"
block|,
literal|"BUILT_IN_NORMAL"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEF_BUILTIN
parameter_list|(
name|X
parameter_list|,
name|N
parameter_list|,
name|C
parameter_list|,
name|T
parameter_list|,
name|LT
parameter_list|,
name|B
parameter_list|,
name|F
parameter_list|,
name|NA
parameter_list|)
value|STRINGX(X),
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|built_in_names
index|[
operator|(
name|int
operator|)
name|END_BUILTINS
index|]
init|=
block|{
include|#
directive|include
file|"builtins.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_BUILTIN
end_undef

begin_comment
comment|/* Setup an array of _DECL trees, make sure each element is    initialized to NULL_TREE.  */
end_comment

begin_decl_stmt
name|tree
name|built_in_decls
index|[
operator|(
name|int
operator|)
name|END_BUILTINS
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|tree
argument_list|(
argument|*lang_type_promotes_to
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|get_pointer_alignment
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|c_strlen
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|c_getstr
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|c_readstr
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|target_char_cast
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|get_memory_rtx
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|apply_args_size
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|apply_result_size
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_untyped_call
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_untyped_return
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|rtx
name|result_vector
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_setjmp
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_builtin_prefetch
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_apply_args
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_apply_args_1
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_apply
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_builtin_return
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|type_class
name|type_to_class
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_classify_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_mathfn
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_constant_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_args_info
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_next_arg
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_va_start
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_va_end
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_va_copy
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_memcmp
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_strcmp
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_strncmp
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|builtin_memcpy_read_str
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|HOST_WIDE_INT
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_strcat
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_strncat
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_strspn
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_strcspn
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_memcpy
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_strcpy
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|builtin_strncpy_read_str
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|HOST_WIDE_INT
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_strncpy
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|builtin_memset_read_str
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|HOST_WIDE_INT
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_memset
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_bzero
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_strlen
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_strstr
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_strpbrk
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_strchr
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_strrchr
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_alloca
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_ffs
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_frame_address
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_fputs
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|stabilize_va_list
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_expect
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|fold_builtin_constant_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|fold_builtin_classify_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_function_call_expr
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|validate_arglist
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the alignment in bits of EXP, a pointer valued expression.    But don't return more than MAX_ALIGN no matter what.    The alignment returned is, by default, the alignment of the thing that    EXP points to.  If it is not a POINTER_TYPE, 0 is returned.     Otherwise, look at the expression to see if we can do better, i.e., if the    expression is actually pointing at an object whose alignment is tighter.  */
end_comment

begin_function
specifier|static
name|int
name|get_pointer_alignment
parameter_list|(
name|exp
parameter_list|,
name|max_align
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|unsigned
name|int
name|max_align
decl_stmt|;
block|{
name|unsigned
name|int
name|align
decl_stmt|,
name|inner
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|0
return|;
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
name|MIN
argument_list|(
name|align
argument_list|,
name|max_align
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
name|align
return|;
name|inner
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
name|MIN
argument_list|(
name|inner
argument_list|,
name|max_align
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
comment|/* If sum of pointer + int, restrict our maximum alignment to that 	     imposed by the integer.  If not, we can't do any better than 	     ALIGN.  */
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|align
return|;
while|while
condition|(
operator|(
operator|(
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|&
operator|(
name|max_align
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|max_align
operator|>>=
literal|1
expr_stmt|;
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
comment|/* See what we are pointing at and look at its alignment.  */
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|align
operator|=
name|FUNCTION_BOUNDARY
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|exp
argument_list|)
condition|)
name|align
operator|=
name|DECL_ALIGN
argument_list|(
name|exp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'c'
condition|)
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|exp
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|MIN
argument_list|(
name|align
argument_list|,
name|max_align
argument_list|)
return|;
default|default:
return|return
name|align
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Compute the length of a C string.  TREE_STRING_LENGTH is not the right    way, because it could contain a zero byte in the middle.    TREE_STRING_LENGTH is the size of the character array, not the string.     The value returned is of type `ssizetype'.     Unfortunately, string_constant can't access the values of const char    arrays with initializers, so neither can we do so here.  */
end_comment

begin_function
specifier|static
name|tree
name|c_strlen
parameter_list|(
name|src
parameter_list|)
name|tree
name|src
decl_stmt|;
block|{
name|tree
name|offset_node
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|max
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|src
operator|=
name|string_constant
argument_list|(
name|src
argument_list|,
operator|&
name|offset_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|max
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|src
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ptr
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_node
operator|&&
name|TREE_CODE
argument_list|(
name|offset_node
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
comment|/* If the string has an internal zero byte (e.g., "foo\0bar"), we can't 	 compute the offset to the following null if we don't know where to 	 start searching for it.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ptr
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* We don't know the starting offset, but we do know that the string 	 has no internal zero bytes.  We can assume that the offset falls 	 within the bounds of the string; otherwise, the programmer deserves 	 what he gets.  Subtract the offset from the length of the string, 	 and return that.  This would perhaps not be valid if we were dealing 	 with named arrays in addition to literal string constants.  */
return|return
name|size_diffop
argument_list|(
name|size_int
argument_list|(
name|max
argument_list|)
argument_list|,
name|offset_node
argument_list|)
return|;
block|}
comment|/* We have a known offset into the string.  Start searching there for      a null character if we can represent it as a single HOST_WIDE_INT.  */
if|if
condition|(
name|offset_node
operator|==
literal|0
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|offset_node
argument_list|,
literal|0
argument_list|)
condition|)
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|offset
operator|=
name|tree_low_cst
argument_list|(
name|offset_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the offset is known to be out of bounds, warn, and call strlen at      runtime.  */
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|>
name|max
condition|)
block|{
name|warning
argument_list|(
literal|"offset outside bounds of constant string"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Use strlen to search for the first zero byte.  Since any strings      constructed with build_string will have nulls appended, we win even      if we get handed something like (char[4])"abcd".       Since OFFSET is our starting index into the string, no further      calculation is needed.  */
return|return
name|ssize_int
argument_list|(
name|strlen
argument_list|(
name|ptr
operator|+
name|offset
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a char pointer for a C string if it is a string constant    or sum of string constant and integer constant.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|c_getstr
parameter_list|(
name|src
parameter_list|)
name|tree
name|src
decl_stmt|;
block|{
name|tree
name|offset_node
decl_stmt|;
name|src
operator|=
name|string_constant
argument_list|(
name|src
argument_list|,
operator|&
name|offset_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|offset_node
operator|==
literal|0
condition|)
return|return
name|TREE_STRING_POINTER
argument_list|(
name|src
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|offset_node
argument_list|,
literal|1
argument_list|)
operator|||
name|compare_tree_int
argument_list|(
name|offset_node
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|src
argument_list|)
operator|-
literal|1
argument_list|)
operator|>
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|TREE_STRING_POINTER
argument_list|(
name|src
argument_list|)
operator|+
name|tree_low_cst
argument_list|(
name|offset_node
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a CONST_INT or CONST_DOUBLE corresponding to target reading    GET_MODE_BITSIZE (MODE) bits from string constant STR.  */
end_comment

begin_function
specifier|static
name|rtx
name|c_readstr
parameter_list|(
name|str
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|c
index|[
literal|2
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|ch
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|j
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|!=
name|WORDS_BIG_ENDIAN
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
name|j
operator|=
name|j
operator|+
name|UNITS_PER_WORD
operator|-
literal|2
operator|*
operator|(
name|j
operator|%
name|UNITS_PER_WORD
operator|)
operator|-
literal|1
expr_stmt|;
name|j
operator|*=
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
condition|)
name|ch
operator|=
operator|(
name|unsigned
name|char
operator|)
name|str
index|[
name|i
index|]
expr_stmt|;
name|c
index|[
name|j
operator|/
name|HOST_BITS_PER_WIDE_INT
index|]
operator||=
name|ch
operator|<<
operator|(
name|j
operator|%
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
return|return
name|immed_double_const
argument_list|(
name|c
index|[
literal|0
index|]
argument_list|,
name|c
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Cast a target constant CST to target CHAR and if that value fits into    host char type, return zero and put that value into variable pointed by    P.  */
end_comment

begin_function
specifier|static
name|int
name|target_char_cast
parameter_list|(
name|cst
parameter_list|,
name|p
parameter_list|)
name|tree
name|cst
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|val
decl_stmt|,
name|hostval
decl_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|cst
argument_list|,
literal|1
argument_list|)
operator|||
name|CHAR_TYPE_SIZE
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
literal|1
return|;
name|val
operator|=
name|tree_low_cst
argument_list|(
name|cst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHAR_TYPE_SIZE
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|val
operator|&=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|CHAR_TYPE_SIZE
operator|)
operator|-
literal|1
expr_stmt|;
name|hostval
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_CHAR
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|hostval
operator|&=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|HOST_BITS_PER_CHAR
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|hostval
condition|)
return|return
literal|1
return|;
operator|*
name|p
operator|=
name|hostval
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given TEM, a pointer to a stack frame, follow the dynamic chain COUNT    times to get the address of either a higher stack frame, or a return    address located within it (depending on FNDECL_CODE).  */
end_comment

begin_function
name|rtx
name|expand_builtin_return_addr
parameter_list|(
name|fndecl_code
parameter_list|,
name|count
parameter_list|,
name|tem
parameter_list|)
name|enum
name|built_in_function
name|fndecl_code
decl_stmt|;
name|int
name|count
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Some machines need special handling before we can access      arbitrary frames.  For example, on the sparc, we must first flush      all register windows to the stack.  */
ifdef|#
directive|ifdef
name|SETUP_FRAME_ADDRESSES
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|SETUP_FRAME_ADDRESSES
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* On the sparc, the return address is not in the frame, it is in a      register.  There is no way to access it off of the current frame      pointer, but it can be accessed off the previous frame pointer by      reading the value from the register window save area.  */
ifdef|#
directive|ifdef
name|RETURN_ADDR_IN_PREVIOUS_FRAME
if|if
condition|(
name|fndecl_code
operator|==
name|BUILT_IN_RETURN_ADDRESS
condition|)
name|count
operator|--
expr_stmt|;
endif|#
directive|endif
comment|/* Scan back COUNT frames to the specified frame.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* Assume the dynamic chain pointer is in the word that the 	 frame address points to, unless otherwise specified.  */
ifdef|#
directive|ifdef
name|DYNAMIC_CHAIN_ADDRESS
name|tem
operator|=
name|DYNAMIC_CHAIN_ADDRESS
argument_list|(
name|tem
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tem
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|tem
argument_list|,
name|get_frame_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|tem
operator|=
name|copy_to_reg
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
comment|/* For __builtin_frame_address, return what we've got.  */
if|if
condition|(
name|fndecl_code
operator|==
name|BUILT_IN_FRAME_ADDRESS
condition|)
return|return
name|tem
return|;
comment|/* For __builtin_return_address, Get the return address from that      frame.  */
ifdef|#
directive|ifdef
name|RETURN_ADDR_RTX
name|tem
operator|=
name|RETURN_ADDR_RTX
argument_list|(
name|count
argument_list|,
name|tem
argument_list|)
expr_stmt|;
else|#
directive|else
name|tem
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|tem
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|tem
argument_list|,
name|get_frame_alias_set
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Alias set used for setjmp buffer.  */
end_comment

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|setjmp_alias_set
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Construct the leading half of a __builtin_setjmp call.  Control will    return to RECEIVER_LABEL.  This is used directly by sjlj exception    handling code.  */
end_comment

begin_function
name|void
name|expand_builtin_setjmp_setup
parameter_list|(
name|buf_addr
parameter_list|,
name|receiver_label
parameter_list|)
name|rtx
name|buf_addr
decl_stmt|;
name|rtx
name|receiver_label
decl_stmt|;
block|{
name|enum
name|machine_mode
name|sa_mode
init|=
name|STACK_SAVEAREA_MODE
argument_list|(
name|SAVE_NONLOCAL
argument_list|)
decl_stmt|;
name|rtx
name|stack_save
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
if|if
condition|(
name|setjmp_alias_set
operator|==
operator|-
literal|1
condition|)
name|setjmp_alias_set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|buf_addr
argument_list|)
operator|!=
name|Pmode
condition|)
name|buf_addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buf_addr
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|buf_addr
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* We store the frame pointer and the address of receiver_label in      the buffer and use the rest of it for the stack save area, which      is machine-dependent.  */
ifndef|#
directive|ifndef
name|BUILTIN_SETJMP_FRAME_VALUE
define|#
directive|define
name|BUILTIN_SETJMP_FRAME_VALUE
value|virtual_stack_vars_rtx
endif|#
directive|endif
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|setjmp_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|BUILTIN_SETJMP_FRAME_VALUE
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|buf_addr
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
operator|,
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|setjmp_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|validize_mem
argument_list|(
name|mem
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|receiver_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stack_save
operator|=
name|gen_rtx_MEM
argument_list|(
name|sa_mode
argument_list|,
name|plus_constant
argument_list|(
name|buf_addr
argument_list|,
literal|2
operator|*
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|stack_save
argument_list|,
name|setjmp_alias_set
argument_list|)
expr_stmt|;
name|emit_stack_save
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
operator|&
name|stack_save
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* If there is further processing to do, do it.  */
ifdef|#
directive|ifdef
name|HAVE_builtin_setjmp_setup
if|if
condition|(
name|HAVE_builtin_setjmp_setup
condition|)
name|emit_insn
argument_list|(
name|gen_builtin_setjmp_setup
argument_list|(
name|buf_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Tell optimize_save_area_alloca that extra work is going to      need to go on during alloca.  */
name|current_function_calls_setjmp
operator|=
literal|1
expr_stmt|;
comment|/* Set this so all the registers get saved in our frame; we need to be      able to copy the saved values for any registers from frames we unwind.  */
name|current_function_has_nonlocal_label
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Construct the trailing part of a __builtin_setjmp call.    This is used directly by sjlj exception handling code.  */
end_comment

begin_function
name|void
name|expand_builtin_setjmp_receiver
parameter_list|(
name|receiver_label
parameter_list|)
name|rtx
name|receiver_label
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Clobber the FP when we get here, so we have to make sure it's      marked as used by this function.  */
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the static chain as clobbered here so life information      doesn't get messed up for it.  */
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|static_chain_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now put in the code to restore the frame pointer, and argument      pointer, if needed.  The code below is from expand_end_bindings      in stmt.c; see detailed documentation there.  */
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto
if|if
condition|(
operator|!
name|HAVE_nonlocal_goto
condition|)
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
if|if
condition|(
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
name|size_t
name|i
decl_stmt|;
specifier|static
specifier|const
struct|struct
name|elims
block|{
specifier|const
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|elim_regs
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|elim_regs
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elim_regs
index|[
name|i
index|]
operator|.
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|elim_regs
index|[
name|i
index|]
operator|.
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|ARRAY_SIZE
argument_list|(
name|elim_regs
argument_list|)
condition|)
endif|#
directive|endif
block|{
comment|/* Now restore our arg pointer from the address at which it 	     was saved in our stack frame.  */
name|emit_move_insn
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|copy_to_reg
argument_list|(
name|get_arg_pointer_save_area
argument_list|(
name|cfun
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_builtin_setjmp_receiver
if|if
condition|(
name|HAVE_builtin_setjmp_receiver
condition|)
name|emit_insn
argument_list|(
name|gen_builtin_setjmp_receiver
argument_list|(
name|receiver_label
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto_receiver
if|if
condition|(
name|HAVE_nonlocal_goto_receiver
condition|)
name|emit_insn
argument_list|(
name|gen_nonlocal_goto_receiver
argument_list|()
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
comment|/* Nothing */
block|}
comment|/* @@@ This is a kludge.  Not all machine descriptions define a blockage      insn, but we must not allow the code we just generated to be reordered      by scheduling.  Specifically, the update of the frame pointer must      happen immediately, not later.  So emit an ASM_INPUT to act as blockage      insn.  */
name|emit_insn
argument_list|(
name|gen_rtx_ASM_INPUT
argument_list|(
name|VOIDmode
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __builtin_setjmp is passed a pointer to an array of five words (not    all will be used on all machines).  It operates similarly to the C    library function of the same name, but is more efficient.  Much of    the code below (and for longjmp) is copied from the handling of    non-local gotos.     NOTE: This is intended for use by GNAT and the exception handling    scheme in the compiler and will only work in the method used by    them.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_setjmp
parameter_list|(
name|arglist
parameter_list|,
name|target
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|buf_addr
decl_stmt|,
name|next_lab
decl_stmt|,
name|cont_lab
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|buf_addr
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|next_lab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|cont_lab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|expand_builtin_setjmp_setup
argument_list|(
name|buf_addr
argument_list|,
name|next_lab
argument_list|)
expr_stmt|;
comment|/* Set TARGET to zero and branch to the continue label.  */
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|cont_lab
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|next_lab
argument_list|)
expr_stmt|;
name|expand_builtin_setjmp_receiver
argument_list|(
name|next_lab
argument_list|)
expr_stmt|;
comment|/* Set TARGET to one.  */
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|cont_lab
argument_list|)
expr_stmt|;
comment|/* Tell flow about the strange goings on.  Putting `next_lab' on      `nonlocal_goto_handler_labels' to indicates that function      calls may traverse the arc back to this label.  */
name|current_function_has_nonlocal_label
operator|=
literal|1
expr_stmt|;
name|nonlocal_goto_handler_labels
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|next_lab
argument_list|,
name|nonlocal_goto_handler_labels
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* __builtin_longjmp is passed a pointer to an array of five words (not    all will be used on all machines).  It operates similarly to the C    library function of the same name, but is more efficient.  Much of    the code below is copied from the handling of non-local gotos.     NOTE: This is intended for use by GNAT and the exception handling    scheme in the compiler and will only work in the method used by    them.  */
end_comment

begin_function
name|void
name|expand_builtin_longjmp
parameter_list|(
name|buf_addr
parameter_list|,
name|value
parameter_list|)
name|rtx
name|buf_addr
decl_stmt|,
name|value
decl_stmt|;
block|{
name|rtx
name|fp
decl_stmt|,
name|lab
decl_stmt|,
name|stack
decl_stmt|,
name|insn
decl_stmt|;
name|enum
name|machine_mode
name|sa_mode
init|=
name|STACK_SAVEAREA_MODE
argument_list|(
name|SAVE_NONLOCAL
argument_list|)
decl_stmt|;
if|if
condition|(
name|setjmp_alias_set
operator|==
operator|-
literal|1
condition|)
name|setjmp_alias_set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|buf_addr
argument_list|)
operator|!=
name|Pmode
condition|)
name|buf_addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buf_addr
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
comment|/* We used to store value in static_chain_rtx, but that fails if pointers      are smaller than integers.  We instead require that the user must pass      a second argument of 1, because that is what builtin_setjmp will      return.  This also makes EH slightly more efficient, since we are no      longer copying around a value that we don't care about.  */
if|if
condition|(
name|value
operator|!=
name|const1_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
name|current_function_calls_longjmp
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_builtin_longjmp
if|if
condition|(
name|HAVE_builtin_longjmp
condition|)
name|emit_insn
argument_list|(
name|gen_builtin_longjmp
argument_list|(
name|buf_addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|fp
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
name|lab
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|buf_addr
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|=
name|gen_rtx_MEM
argument_list|(
name|sa_mode
argument_list|,
name|plus_constant
argument_list|(
name|buf_addr
argument_list|,
literal|2
operator|*
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|fp
argument_list|,
name|setjmp_alias_set
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|lab
argument_list|,
name|setjmp_alias_set
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|stack
argument_list|,
name|setjmp_alias_set
argument_list|)
expr_stmt|;
comment|/* Pick up FP, label, and SP from the block and jump.  This code is 	 from expand_goto in stmt.c; see there for detailed comments.  */
if|#
directive|if
name|HAVE_nonlocal_goto
if|if
condition|(
name|HAVE_nonlocal_goto
condition|)
comment|/* We have to pass a value to the nonlocal_goto pattern that will 	   get copied into the static_chain pointer, but it does not matter 	   what that value is, because builtin_setjmp does not use it.  */
name|emit_insn
argument_list|(
name|gen_nonlocal_goto
argument_list|(
name|value
argument_list|,
name|lab
argument_list|,
name|stack
argument_list|,
name|fp
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|lab
operator|=
name|copy_to_reg
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|emit_stack_restore
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
name|stack
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_indirect_jump
argument_list|(
name|lab
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Search backwards and mark the jump insn as a non-local goto.      Note that this precludes the use of __builtin_longjmp to a      __builtin_setjmp target in the same function.  However, we've      already cautioned the user that these functions are for      internal exception handling use only.  */
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_NON_LOCAL_GOTO
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to __builtin_prefetch.  For a target that does not support    data prefetch, evaluate the memory address argument in case it has side    effects.  */
end_comment

begin_function
specifier|static
name|void
name|expand_builtin_prefetch
parameter_list|(
name|arglist
parameter_list|)
name|tree
name|arglist
decl_stmt|;
block|{
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* Arguments 1 and 2 are optional; argument 1 (read/write) defaults to      zero (read) and argument 2 (locality) defaults to 3 (high degree of      locality).  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
block|{
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
condition|)
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|arg2
operator|=
name|build_int_2
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg1
operator|=
name|integer_zero_node
expr_stmt|;
name|arg2
operator|=
name|build_int_2
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Argument 0 is an address.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Argument 1 (read/write flag) must be a compile-time constant int.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"second arg to `__builtin_prefetch' must be a constant"
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|integer_zero_node
expr_stmt|;
block|}
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Argument 1 must be either zero or one.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|!=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"invalid second arg to __builtin_prefetch; using zero"
argument_list|)
expr_stmt|;
name|op1
operator|=
name|const0_rtx
expr_stmt|;
block|}
comment|/* Argument 2 (locality) must be a compile-time constant int.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"third arg to `__builtin_prefetch' must be a constant"
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|integer_zero_node
expr_stmt|;
block|}
name|op2
operator|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Argument 2 must be 0, 1, 2, or 3.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|<
literal|0
operator|||
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|>
literal|3
condition|)
block|{
name|warning
argument_list|(
literal|"invalid third arg to __builtin_prefetch; using zero"
argument_list|)
expr_stmt|;
name|op2
operator|=
name|const0_rtx
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_prefetch
if|if
condition|(
name|HAVE_prefetch
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_prefetch
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_prefetch
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_prefetch
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't do anything with direct references to volatile memory, but        generate code to handle other side effects.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
operator|&&
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a MEM rtx for expression EXP which is the address of an operand    to be used to be used in a string instruction (cmpstrsi, movstrsi, ..).  */
end_comment

begin_function
specifier|static
name|rtx
name|get_memory_rtx
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|rtx
name|addr
init|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|ptr_mode
argument_list|,
name|EXPAND_SUM
argument_list|)
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|Pmode
condition|)
name|addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get an expression we can use to find the attributes to assign to MEM.      If it is an ADDR_EXPR, use the operand.  Otherwise, dereference it if      we can.  First remove any nops.  */
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|mem
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
name|exp
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
comment|/* memcpy, memset and other builtin stringops can alias with anything.  */
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|mem
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Built-in functions to perform an untyped call and return.  */
end_comment

begin_comment
comment|/* For each register that may be used for calling a function, this    gives a mode used to copy the register's value.  VOIDmode indicates    the register is not used for calling a function.  If the machine    has register windows, this gives only the outbound registers.    INCOMING_REGNO gives the corresponding inbound register.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|apply_args_mode
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each register that may be used for returning values, this gives    a mode used to copy the register's value.  VOIDmode indicates the    register is not used for returning values.  If the machine has    register windows, this gives only the outbound registers.    INCOMING_REGNO gives the corresponding inbound register.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|apply_result_mode
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each register that may be used for calling a function, this    gives the offset of that register into the block returned by    __builtin_apply_args.  0 indicates that the register is not    used for calling a function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|apply_args_reg_offset
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the offset of register REGNO into the block returned by    __builtin_apply_args.  This is not declared static, since it is    needed in objc-act.c.  */
end_comment

begin_function
name|int
name|apply_args_register_offset
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|apply_args_size
argument_list|()
expr_stmt|;
comment|/* Arguments are always put in outgoing registers (in the argument      block) if such make sense.  */
ifdef|#
directive|ifdef
name|OUTGOING_REGNO
name|regno
operator|=
name|OUTGOING_REGNO
argument_list|(
name|regno
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|apply_args_reg_offset
index|[
name|regno
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the size required for the block returned by __builtin_apply_args,    and initialize apply_args_mode.  */
end_comment

begin_function
specifier|static
name|int
name|apply_args_size
parameter_list|()
block|{
specifier|static
name|int
name|size
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|align
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* The values computed by this function never change.  */
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
comment|/* The first value is the incoming arg-pointer.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* The second value is the structure value address unless this is 	 passed as an "invisible" first argument.  */
if|if
condition|(
name|struct_value_rtx
condition|)
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
comment|/* Search for the proper mode for copying this register's 	       value.  I'm not sure this is right, but it works so far.  */
name|enum
name|machine_mode
name|best_mode
init|=
name|VOIDmode
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|==
literal|1
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|best_mode
operator|==
name|VOIDmode
condition|)
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
name|have_insn_for
argument_list|(
name|SET
argument_list|,
name|mode
argument_list|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|best_mode
operator|==
name|VOIDmode
condition|)
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_VECTOR_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
name|have_insn_for
argument_list|(
name|SET
argument_list|,
name|mode
argument_list|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|best_mode
operator|==
name|VOIDmode
condition|)
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_VECTOR_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
name|have_insn_for
argument_list|(
name|SET
argument_list|,
name|mode
argument_list|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
name|mode
operator|=
name|best_mode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|apply_args_reg_offset
index|[
name|regno
index|]
operator|=
name|size
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|apply_args_mode
index|[
name|regno
index|]
operator|=
name|mode
expr_stmt|;
block|}
else|else
block|{
name|apply_args_mode
index|[
name|regno
index|]
operator|=
name|VOIDmode
expr_stmt|;
name|apply_args_reg_offset
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the size required for the block returned by __builtin_apply,    and initialize apply_result_mode.  */
end_comment

begin_function
specifier|static
name|int
name|apply_result_size
parameter_list|()
block|{
specifier|static
name|int
name|size
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* The values computed by this function never change.  */
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|FUNCTION_VALUE_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
comment|/* Search for the proper mode for copying this register's 	       value.  I'm not sure this is right, but it works so far.  */
name|enum
name|machine_mode
name|best_mode
init|=
name|VOIDmode
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|TImode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|best_mode
operator|==
name|VOIDmode
condition|)
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
name|have_insn_for
argument_list|(
name|SET
argument_list|,
name|mode
argument_list|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|best_mode
operator|==
name|VOIDmode
condition|)
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_VECTOR_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
name|have_insn_for
argument_list|(
name|SET
argument_list|,
name|mode
argument_list|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|best_mode
operator|==
name|VOIDmode
condition|)
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_VECTOR_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
name|have_insn_for
argument_list|(
name|SET
argument_list|,
name|mode
argument_list|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
name|mode
operator|=
name|best_mode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|apply_result_mode
index|[
name|regno
index|]
operator|=
name|mode
expr_stmt|;
block|}
else|else
name|apply_result_mode
index|[
name|regno
index|]
operator|=
name|VOIDmode
expr_stmt|;
comment|/* Allow targets that use untyped_call and untyped_return to override 	 the size so that machine-specific information can be stored here.  */
ifdef|#
directive|ifdef
name|APPLY_RESULT_SIZE
name|size
operator|=
name|APPLY_RESULT_SIZE
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|size
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_untyped_call
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_untyped_return
argument_list|)
end_if

begin_comment
comment|/* Create a vector describing the result block RESULT.  If SAVEP is true,    the result block is used to save the values; otherwise it is used to    restore the values.  */
end_comment

begin_function
specifier|static
name|rtx
name|result_vector
parameter_list|(
name|savep
parameter_list|,
name|result
parameter_list|)
name|int
name|savep
decl_stmt|;
name|rtx
name|result
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|size
decl_stmt|,
name|align
decl_stmt|,
name|nelts
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|rtx
modifier|*
name|savevec
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|FIRST_PSEUDO_REGISTER
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|size
operator|=
name|nelts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_result_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|savep
condition|?
name|regno
else|:
name|INCOMING_REGNO
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|adjust_address
argument_list|(
name|result
argument_list|,
name|mode
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|savevec
index|[
name|nelts
operator|++
index|]
operator|=
operator|(
name|savep
condition|?
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
else|:
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|mem
argument_list|)
operator|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|nelts
argument_list|,
name|savevec
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_untyped_call or HAVE_untyped_return */
end_comment

begin_comment
comment|/* Save the state required to perform an untyped call with the same    arguments as were passed to the current function.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_apply_args_1
parameter_list|()
block|{
name|rtx
name|registers
decl_stmt|;
name|int
name|size
decl_stmt|,
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Create a block where the arg-pointer, structure value address,      and argument registers can be saved.  */
name|registers
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|apply_args_size
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Walk past the arg-pointer and structure value address.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_value_rtx
condition|)
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Save each register used in calling a function to the block.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_args_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|tem
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|INCOMING_REGNO
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|registers
argument_list|,
name|mode
argument_list|,
name|size
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Save the arg pointer to the block.  */
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|registers
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|virtual_incoming_args_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Save the structure value address unless this is passed as an      "invisible" first argument.  */
if|if
condition|(
name|struct_value_incoming_rtx
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|registers
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|struct_value_incoming_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
comment|/* Return the address of the block.  */
return|return
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|registers
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* __builtin_apply_args returns block of memory allocated on    the stack into which is stored the arg pointer, structure    value address, static chain, and all the registers that might    possibly be used in performing a function call.  The code is    moved to the start of the function so the incoming values are    saved.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_apply_args
parameter_list|()
block|{
comment|/* Don't do __builtin_apply_args more than once in a function.      Save the result of the first call and reuse it.  */
if|if
condition|(
name|apply_args_value
operator|!=
literal|0
condition|)
return|return
name|apply_args_value
return|;
block|{
comment|/* When this function is called, it means that registers must be        saved on entry to this function.  So we migrate the        call to the first insn of this function.  */
name|rtx
name|temp
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|temp
operator|=
name|expand_builtin_apply_args_1
argument_list|()
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|apply_args_value
operator|=
name|temp
expr_stmt|;
comment|/* Put the sequence after the NOTE that starts the function.        If this is inside a SEQUENCE, make the outer-level insn        chain current, so the code is placed at the start of the        function.  */
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|NEXT_INSN
argument_list|(
name|get_insns
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
end_function

begin_comment
comment|/* Perform an untyped call and save the state required to perform an    untyped return of whatever value was returned by the given function.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_apply
parameter_list|(
name|function
parameter_list|,
name|arguments
parameter_list|,
name|argsize
parameter_list|)
name|rtx
name|function
decl_stmt|,
name|arguments
decl_stmt|,
name|argsize
decl_stmt|;
block|{
name|int
name|size
decl_stmt|,
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|incoming_args
decl_stmt|,
name|result
decl_stmt|,
name|reg
decl_stmt|,
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|call_insn
decl_stmt|;
name|rtx
name|old_stack_level
init|=
literal|0
decl_stmt|;
name|rtx
name|call_fusage
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|arguments
argument_list|)
operator|!=
name|Pmode
condition|)
name|arguments
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Create a block where the return registers can be saved.  */
name|result
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|apply_result_size
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Fetch the arg pointer from the ARGUMENTS block.  */
name|incoming_args
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|incoming_args
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|arguments
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|STACK_GROWS_DOWNWARD
name|incoming_args
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|MINUS
argument_list|,
name|incoming_args
argument_list|,
name|argsize
argument_list|,
name|incoming_args
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Perform postincrements before actually calling the function.  */
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Push a new argument block and copy the arguments.  Do not allow      the (potential) memcpy call below to interfere with our stack      manipulations.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
comment|/* Save the stack with nonlocal if available */
ifdef|#
directive|ifdef
name|HAVE_save_stack_nonlocal
if|if
condition|(
name|HAVE_save_stack_nonlocal
condition|)
name|emit_stack_save
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
operator|&
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|emit_stack_save
argument_list|(
name|SAVE_BLOCK
argument_list|,
operator|&
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Push a block of memory onto the stack to store the memory arguments.      Save the address in a register, and copy the memory arguments.  ??? I      haven't figured out how the calling convention macros effect this,      but it's likely that the source and/or destination addresses in      the block copy will need updating in machine specific ways.  */
name|dest
operator|=
name|allocate_dynamic_stack_space
argument_list|(
name|argsize
argument_list|,
literal|0
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|dest
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|dest
argument_list|,
name|PARM_BOUNDARY
argument_list|)
expr_stmt|;
name|src
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|incoming_args
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|src
argument_list|,
name|PARM_BOUNDARY
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|argsize
argument_list|)
expr_stmt|;
comment|/* Refer to the argument block.  */
name|apply_args_size
argument_list|()
expr_stmt|;
name|arguments
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|arguments
argument_list|,
name|PARM_BOUNDARY
argument_list|)
expr_stmt|;
comment|/* Walk past the arg-pointer and structure value address.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_value_rtx
condition|)
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Restore each of the registers previously saved.  Make USE insns      for each of these registers for use in making the call.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_args_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|adjust_address
argument_list|(
name|arguments
argument_list|,
name|mode
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the structure value address unless this is passed as an      "invisible" first argument.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_value_rtx
condition|)
block|{
name|rtx
name|value
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|value
argument_list|,
name|adjust_address
argument_list|(
name|arguments
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|struct_value_rtx
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|struct_value_rtx
argument_list|)
operator|==
name|REG
condition|)
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|struct_value_rtx
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
comment|/* All arguments and registers used for the call are set up by now!  */
name|function
operator|=
name|prepare_call_address
argument_list|(
name|function
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|call_fusage
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Ensure address is valid.  SYMBOL_REF is already valid, so no need,      and we don't want to load it into a register as an optimization,      because prepare_call_address already did it if it should be done.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|function
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|function
operator|=
name|memory_address
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|function
argument_list|)
expr_stmt|;
comment|/* Generate the actual call instruction and save the return value.  */
ifdef|#
directive|ifdef
name|HAVE_untyped_call
if|if
condition|(
name|HAVE_untyped_call
condition|)
name|emit_call_insn
argument_list|(
name|gen_untyped_call
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|function
argument_list|)
argument_list|,
name|result
argument_list|,
name|result_vector
argument_list|(
literal|1
argument_list|,
name|result
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_call_value
if|if
condition|(
name|HAVE_call_value
condition|)
block|{
name|rtx
name|valreg
init|=
literal|0
decl_stmt|;
comment|/* Locate the unique return register.  It is not possible to 	 express a call that sets more than one return register using 	 call_value; use untyped_call for that.  In fact, untyped_call 	 only needs to save the return registers in the given block.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_result_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|valreg
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* HAVE_untyped_call required.  */
name|valreg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|emit_call_insn
argument_list|(
name|GEN_CALL_VALUE
argument_list|(
name|valreg
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|function
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|NULL_RTX
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|result
argument_list|,
name|GET_MODE
argument_list|(
name|valreg
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|valreg
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
comment|/* Find the CALL insn we just emitted.  */
for|for
control|(
name|call_insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|call_insn
operator|&&
name|GET_CODE
argument_list|(
name|call_insn
argument_list|)
operator|!=
name|CALL_INSN
condition|;
name|call_insn
operator|=
name|PREV_INSN
argument_list|(
name|call_insn
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|call_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Put the register usage information on the CALL.  If there is already      some usage information, put ours at the end.  */
if|if
condition|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
condition|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
init|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
empty_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|call_fusage
expr_stmt|;
block|}
else|else
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
operator|=
name|call_fusage
expr_stmt|;
comment|/* Restore the stack.  */
ifdef|#
directive|ifdef
name|HAVE_save_stack_nonlocal
if|if
condition|(
name|HAVE_save_stack_nonlocal
condition|)
name|emit_stack_restore
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|emit_stack_restore
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
comment|/* Return the address of the result block.  */
return|return
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform an untyped return.  */
end_comment

begin_function
specifier|static
name|void
name|expand_builtin_return
parameter_list|(
name|result
parameter_list|)
name|rtx
name|result
decl_stmt|;
block|{
name|int
name|size
decl_stmt|,
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|call_fusage
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|!=
name|Pmode
condition|)
name|result
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|apply_result_size
argument_list|()
expr_stmt|;
name|result
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|result
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_untyped_return
if|if
condition|(
name|HAVE_untyped_return
condition|)
block|{
name|emit_jump_insn
argument_list|(
name|gen_untyped_return
argument_list|(
name|result
argument_list|,
name|result_vector
argument_list|(
literal|0
argument_list|,
name|result
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Restore the return value and note that each value is used.  */
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_result_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|INCOMING_REGNO
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|adjust_address
argument_list|(
name|result
argument_list|,
name|mode
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|push_to_sequence
argument_list|(
name|call_fusage
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|call_fusage
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Put the USE insns before the return.  */
name|emit_insns
argument_list|(
name|call_fusage
argument_list|)
expr_stmt|;
comment|/* Return whatever values was restored by jumping directly to the end      of the function.  */
name|expand_null_return
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used by expand_builtin_classify_type and fold_builtin_classify_type.  */
end_comment

begin_function
specifier|static
name|enum
name|type_class
name|type_to_class
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|VOID_TYPE
case|:
return|return
name|void_type_class
return|;
case|case
name|INTEGER_TYPE
case|:
return|return
name|integer_type_class
return|;
case|case
name|CHAR_TYPE
case|:
return|return
name|char_type_class
return|;
case|case
name|ENUMERAL_TYPE
case|:
return|return
name|enumeral_type_class
return|;
case|case
name|BOOLEAN_TYPE
case|:
return|return
name|boolean_type_class
return|;
case|case
name|POINTER_TYPE
case|:
return|return
name|pointer_type_class
return|;
case|case
name|REFERENCE_TYPE
case|:
return|return
name|reference_type_class
return|;
case|case
name|OFFSET_TYPE
case|:
return|return
name|offset_type_class
return|;
case|case
name|REAL_TYPE
case|:
return|return
name|real_type_class
return|;
case|case
name|COMPLEX_TYPE
case|:
return|return
name|complex_type_class
return|;
case|case
name|FUNCTION_TYPE
case|:
return|return
name|function_type_class
return|;
case|case
name|METHOD_TYPE
case|:
return|return
name|method_type_class
return|;
case|case
name|RECORD_TYPE
case|:
return|return
name|record_type_class
return|;
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
return|return
name|union_type_class
return|;
case|case
name|ARRAY_TYPE
case|:
return|return
operator|(
name|TYPE_STRING_FLAG
argument_list|(
name|type
argument_list|)
condition|?
name|string_type_class
else|:
name|array_type_class
operator|)
return|;
case|case
name|SET_TYPE
case|:
return|return
name|set_type_class
return|;
case|case
name|FILE_TYPE
case|:
return|return
name|file_type_class
return|;
case|case
name|LANG_TYPE
case|:
return|return
name|lang_type_class
return|;
default|default:
return|return
name|no_type_class
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to __builtin_classify_type with arguments found in    ARGLIST.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_classify_type
parameter_list|(
name|arglist
parameter_list|)
name|tree
name|arglist
decl_stmt|;
block|{
if|if
condition|(
name|arglist
operator|!=
literal|0
condition|)
return|return
name|GEN_INT
argument_list|(
name|type_to_class
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|GEN_INT
argument_list|(
name|no_type_class
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to __builtin_constant_p.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_constant_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|value_mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
name|arglist
operator|==
literal|0
condition|)
return|return
name|const0_rtx
return|;
name|arglist
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* We have taken care of the easy cases during constant folding.  This      case is not obvious, so emit (constant_p_rtx (ARGLIST)) and let CSE get a      chance to see if it can deduce whether ARGLIST is constant.  */
name|tmp
operator|=
name|expand_expr
argument_list|(
name|arglist
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_CONSTANT_P_RTX
argument_list|(
name|value_mode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to one of the builtin math functions (sin, cos, or sqrt).    Return 0 if a normal call should be emitted rather than expanding the    function in-line.  EXP is the expression that is a call to the builtin    function; if convenient, the result should be placed in TARGET.    SUBTARGET may be used as the target for computing one of EXP's operands.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_mathfn
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|subtarget
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|,
name|subtarget
decl_stmt|;
block|{
name|optab
name|builtin_optab
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|insns
decl_stmt|;
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Stabilize and compute the argument.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
name|exp
operator|=
name|copy_node
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|arglist
expr_stmt|;
comment|/* Wrap the computation of the argument in a SAVE_EXPR.  That 	 way, if we need to expand the argument again (as in the 	 flag_errno_math case below where we cannot directly set 	 errno), we will not perform side-effects more than once. 	 Note that here we're mutating the original EXP as well as the 	 copy; that's the right thing to do in case the original EXP 	 is expanded later.  */
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
operator|=
name|save_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|copy_node
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make a suitable register to place result in.  */
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_SIN
case|:
case|case
name|BUILT_IN_SINF
case|:
case|case
name|BUILT_IN_SINL
case|:
name|builtin_optab
operator|=
name|sin_optab
expr_stmt|;
break|break;
case|case
name|BUILT_IN_COS
case|:
case|case
name|BUILT_IN_COSF
case|:
case|case
name|BUILT_IN_COSL
case|:
name|builtin_optab
operator|=
name|cos_optab
expr_stmt|;
break|break;
case|case
name|BUILT_IN_SQRT
case|:
case|case
name|BUILT_IN_SQRTF
case|:
case|case
name|BUILT_IN_SQRTL
case|:
name|builtin_optab
operator|=
name|sqrt_optab
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Compute into TARGET.      Set TARGET to wherever the result comes back.  */
name|target
operator|=
name|expand_unop
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|builtin_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we were unable to expand via the builtin, stop the      sequence (without outputting the insns) and return 0, causing      a call to the library function.  */
if|if
condition|(
name|target
operator|==
literal|0
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If errno must be maintained and if we are not allowing unsafe      math optimizations, check the result.  */
if|if
condition|(
name|flag_errno_math
operator|&&
operator|!
name|flag_unsafe_math_optimizations
condition|)
block|{
name|rtx
name|lab1
decl_stmt|;
comment|/* Don't define the builtin FP instructions 	 if your machine is not IEEE.  */
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|lab1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Test the result; if it is NaN, set errno=EDOM because 	 the argument was not in the domain.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|target
argument_list|,
name|target
argument_list|,
name|EQ
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|,
name|lab1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_EDOM
block|{
ifdef|#
directive|ifdef
name|GEN_ERRNO_RTX
name|rtx
name|errno_rtx
init|=
name|GEN_ERRNO_RTX
decl_stmt|;
else|#
directive|else
name|rtx
name|errno_rtx
init|=
name|gen_rtx_MEM
argument_list|(
name|word_mode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"errno"
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|errno_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|TARGET_EDOM
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* We can't set errno=EDOM directly; let the library call do it. 	 Pop the arguments right away in case the call gets deleted.  */
name|NO_DEFER_POP
expr_stmt|;
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
endif|#
directive|endif
name|emit_label
argument_list|(
name|lab1
argument_list|)
expr_stmt|;
block|}
comment|/* Output the entire sequence.  */
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP which is a call to the strlen builtin.  Return 0    if we failed the caller should emit a normal call, otherwise    try to get the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strlen
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|value_mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|src
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|int
name|align
init|=
name|get_pointer_alignment
argument_list|(
name|src
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|result
decl_stmt|,
name|src_reg
decl_stmt|,
name|char_rtx
decl_stmt|,
name|before_strlen
decl_stmt|;
name|enum
name|machine_mode
name|insn_mode
init|=
name|value_mode
decl_stmt|,
name|char_mode
decl_stmt|;
name|enum
name|insn_code
name|icode
init|=
name|CODE_FOR_nothing
decl_stmt|;
comment|/* If SRC is not a pointer type, don't do this operation inline.  */
if|if
condition|(
name|align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Bail out if we can't compute strlen in the right mode.  */
while|while
condition|(
name|insn_mode
operator|!=
name|VOIDmode
condition|)
block|{
name|icode
operator|=
name|strlen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|insn_mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
break|break;
name|insn_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn_mode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
comment|/* Make a place to write the result of the instruction.  */
name|result
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|result
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|insn_mode
operator|&&
name|REGNO
argument_list|(
name|result
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
comment|/* Make a place to hold the source address.  We will not expand 	 the actual source until we are sure that the expansion will 	 not fail -- there are trees that cannot be expanded twice.  */
name|src_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Mark the beginning of the strlen sequence so we can emit the 	 source operand later.  */
name|before_strlen
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|char_rtx
operator|=
name|const0_rtx
expr_stmt|;
name|char_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|char_rtx
operator|,
name|char_mode
operator|)
condition|)
name|char_rtx
operator|=
name|copy_to_mode_reg
argument_list|(
name|char_mode
argument_list|,
name|char_rtx
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|result
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|src_reg
argument_list|)
argument_list|,
name|char_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|align
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* Now that we are assured of success, expand the source.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|pat
operator|=
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|expand_expr
argument_list|(
name|src
argument_list|,
name|src_reg
argument_list|,
name|ptr_mode
argument_list|,
name|EXPAND_SUM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
operator|!=
name|src_reg
condition|)
name|emit_move_insn
argument_list|(
name|src_reg
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|pat
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|before_strlen
condition|)
name|emit_insn_after
argument_list|(
name|pat
argument_list|,
name|before_strlen
argument_list|)
expr_stmt|;
else|else
name|emit_insn_before
argument_list|(
name|pat
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Return the value in the proper mode for this function.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|value_mode
condition|)
name|target
operator|=
name|result
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|!=
literal|0
condition|)
name|convert_move
argument_list|(
name|target
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|target
operator|=
name|convert_to_mode
argument_list|(
name|value_mode
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to the strstr builtin.  Return 0 if we failed the    caller should emit a normal call, otherwise try to get the result    in TARGET, if convenient (and in mode MODE if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strstr
parameter_list|(
name|arglist
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|s1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|s2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|p2
operator|=
name|c_getstr
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|p1
operator|=
name|c_getstr
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|r
init|=
name|strstr
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|const0_rtx
return|;
comment|/* Return an offset into the constant string argument.  */
return|return
name|expand_expr
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|s1
argument_list|,
name|ssize_int
argument_list|(
name|r
operator|-
name|p1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
if|if
condition|(
name|p2
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|expand_expr
argument_list|(
name|s1
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
if|if
condition|(
name|p2
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_STRCHR
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
comment|/* New argument list transforming strstr(s1, s2) to 	 strchr(s1, s2[0]).  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|p2
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|s1
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to the strchr builtin.  Return 0 if we failed the    caller should emit a normal call, otherwise try to get the result    in TARGET, if convenient (and in mode MODE if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strchr
parameter_list|(
name|arglist
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|s1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|s2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|s2
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
name|p1
operator|=
name|c_getstr
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
block|{
name|char
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|target_char_cast
argument_list|(
name|s2
argument_list|,
operator|&
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
name|r
operator|=
name|strchr
argument_list|(
name|p1
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|const0_rtx
return|;
comment|/* Return an offset into the constant string argument.  */
return|return
name|expand_expr
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|s1
argument_list|,
name|ssize_int
argument_list|(
name|r
operator|-
name|p1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* FIXME: Should use here strchrM optab so that ports can optimize 	 this.  */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to the strrchr builtin.  Return 0 if we failed the    caller should emit a normal call, otherwise try to get the result    in TARGET, if convenient (and in mode MODE if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strrchr
parameter_list|(
name|arglist
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|s1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|s2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|s2
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
name|p1
operator|=
name|c_getstr
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
block|{
name|char
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|target_char_cast
argument_list|(
name|s2
argument_list|,
operator|&
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
name|r
operator|=
name|strrchr
argument_list|(
name|p1
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|const0_rtx
return|;
comment|/* Return an offset into the constant string argument.  */
return|return
name|expand_expr
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|s1
argument_list|,
name|ssize_int
argument_list|(
name|r
operator|-
name|p1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|s2
argument_list|)
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_STRCHR
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
comment|/* Transform strrchr(s1, '\0') to strchr(s1, '\0').  */
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to the strpbrk builtin.  Return 0 if we failed the    caller should emit a normal call, otherwise try to get the result    in TARGET, if convenient (and in mode MODE if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strpbrk
parameter_list|(
name|arglist
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|s1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|s2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|p2
operator|=
name|c_getstr
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|p1
operator|=
name|c_getstr
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|r
init|=
name|strpbrk
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|const0_rtx
return|;
comment|/* Return an offset into the constant string argument.  */
return|return
name|expand_expr
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|s1
argument_list|,
name|ssize_int
argument_list|(
name|r
operator|-
name|p1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
if|if
condition|(
name|p2
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* strpbrk(x, "") == NULL. 	     Evaluate and ignore the arguments in case they had 	     side-effects.  */
name|expand_expr
argument_list|(
name|s1
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|p2
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
literal|0
return|;
comment|/* Really call strpbrk.  */
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_STRCHR
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
comment|/* New argument list transforming strpbrk(s1, s2) to 	 strchr(s1, s2[0]).  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|p2
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|s1
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)    bytes from constant string DATA + OFFSET and return it as target    constant.  */
end_comment

begin_function
specifier|static
name|rtx
name|builtin_memcpy_read_str
parameter_list|(
name|data
parameter_list|,
name|offset
parameter_list|,
name|mode
parameter_list|)
name|PTR
name|data
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|str
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|offset
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Attempt to read past the end of constant string.  */
return|return
name|c_readstr
argument_list|(
name|str
operator|+
name|offset
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to the memcpy builtin, with arguments in ARGLIST.    Return 0 if we failed, the caller should emit a normal call, otherwise    try to get the result in TARGET, if convenient (and in mode MODE if    that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_memcpy
parameter_list|(
name|arglist
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|dest
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|src
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_str
decl_stmt|;
name|unsigned
name|int
name|src_align
init|=
name|get_pointer_alignment
argument_list|(
name|src
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dest_align
init|=
name|get_pointer_alignment
argument_list|(
name|dest
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
name|rtx
name|dest_mem
decl_stmt|,
name|src_mem
decl_stmt|,
name|dest_addr
decl_stmt|,
name|len_rtx
decl_stmt|;
comment|/* If DEST is not a pointer type, call the normal function.  */
if|if
condition|(
name|dest_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If the LEN parameter is zero, return DEST.  */
if|if
condition|(
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|&&
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Evaluate and ignore SRC in case it has side-effects.  */
name|expand_expr
argument_list|(
name|src
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|dest
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If either SRC is not a pointer type, don't do this          operation in-line.  */
if|if
condition|(
name|src_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|dest_mem
operator|=
name|get_memory_rtx
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|dest_mem
argument_list|,
name|dest_align
argument_list|)
expr_stmt|;
name|len_rtx
operator|=
name|expand_expr
argument_list|(
name|len
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|src_str
operator|=
name|c_getstr
argument_list|(
name|src
argument_list|)
expr_stmt|;
comment|/* If SRC is a string constant and block move would be done 	 by pieces, we can avoid loading the string from memory 	 and only stored the computed constants.  */
if|if
condition|(
name|src_str
operator|&&
name|GET_CODE
argument_list|(
name|len_rtx
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
operator|<=
name|strlen
argument_list|(
name|src_str
argument_list|)
operator|+
literal|1
operator|&&
name|can_store_by_pieces
argument_list|(
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
argument_list|,
name|builtin_memcpy_read_str
argument_list|,
operator|(
name|PTR
operator|)
name|src_str
argument_list|,
name|dest_align
argument_list|)
condition|)
block|{
name|store_by_pieces
argument_list|(
name|dest_mem
argument_list|,
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
argument_list|,
name|builtin_memcpy_read_str
argument_list|,
operator|(
name|PTR
operator|)
name|src_str
argument_list|,
name|dest_align
argument_list|)
expr_stmt|;
return|return
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
return|;
block|}
name|src_mem
operator|=
name|get_memory_rtx
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|src_mem
argument_list|,
name|src_align
argument_list|)
expr_stmt|;
comment|/* Copy word part most expediently.  */
name|dest_addr
operator|=
name|emit_block_move
argument_list|(
name|dest_mem
argument_list|,
name|src_mem
argument_list|,
name|len_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_addr
operator|==
literal|0
condition|)
name|dest_addr
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
name|dest_addr
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strcpy builtin.  Return 0    if we failed the caller should emit a normal call, otherwise try to get    the result in TARGET, if convenient (and in mode MODE if that's    convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strcpy
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_MEMCPY
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|c_strlen
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|len
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|arglist
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)    bytes from constant string DATA + OFFSET and return it as target    constant.  */
end_comment

begin_function
specifier|static
name|rtx
name|builtin_strncpy_read_str
parameter_list|(
name|data
parameter_list|,
name|offset
parameter_list|,
name|mode
parameter_list|)
name|PTR
name|data
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|str
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|offset
operator|>
name|strlen
argument_list|(
name|str
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
return|return
name|c_readstr
argument_list|(
name|str
operator|+
name|offset
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strncpy builtin.  Return 0    if we failed the caller should emit a normal call.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strncpy
parameter_list|(
name|arglist
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|slen
init|=
name|c_strlen
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
decl_stmt|;
comment|/* We must be passed a constant len parameter.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|len
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
comment|/* If the len parameter is zero, return the dst parameter.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
condition|)
block|{
comment|/* Evaluate and ignore the src argument in case it has            side-effects.  */
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Return the dst parameter.  */
return|return
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* Now, we must be passed a constant src ptr parameter.  */
if|if
condition|(
name|slen
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|slen
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
name|slen
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|slen
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We're required to pad with trailing zeros if the requested          len is greater than strlen(s2)+1.  In that case try to 	 use store_by_pieces, if it fails, punt.  */
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|slen
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|tree
name|dest
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dest_align
init|=
name|get_pointer_alignment
argument_list|(
name|dest
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|c_getstr
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|dest_mem
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
name|dest_align
operator|==
literal|0
operator|||
operator|!
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|can_store_by_pieces
argument_list|(
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|,
name|builtin_strncpy_read_str
argument_list|,
operator|(
name|PTR
operator|)
name|p
argument_list|,
name|dest_align
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest_mem
operator|=
name|get_memory_rtx
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|store_by_pieces
argument_list|(
name|dest_mem
argument_list|,
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|,
name|builtin_strncpy_read_str
argument_list|,
operator|(
name|PTR
operator|)
name|p
argument_list|,
name|dest_align
argument_list|)
expr_stmt|;
return|return
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
return|;
block|}
comment|/* OK transform into builtin memcpy.  */
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_MEMCPY
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)    bytes from constant string DATA + OFFSET and return it as target    constant.  */
end_comment

begin_function
specifier|static
name|rtx
name|builtin_memset_read_str
parameter_list|(
name|data
parameter_list|,
name|offset
parameter_list|,
name|mode
parameter_list|)
name|PTR
name|data
decl_stmt|;
name|HOST_WIDE_INT
name|offset
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|c
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|alloca
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
operator|*
name|c
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|c_readstr
argument_list|(
name|p
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the memset builtin.  Return 0    if we failed the caller should emit a normal call, otherwise try to get    the result in TARGET, if convenient (and in mode MODE if that's    convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_memset
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|dest
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|c
decl_stmt|;
name|unsigned
name|int
name|dest_align
init|=
name|get_pointer_alignment
argument_list|(
name|dest
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
name|rtx
name|dest_mem
decl_stmt|,
name|dest_addr
decl_stmt|,
name|len_rtx
decl_stmt|;
comment|/* If DEST is not a pointer type, don't do this 	 operation in-line.  */
if|if
condition|(
name|dest_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If the LEN parameter is zero, return DEST.  */
if|if
condition|(
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|&&
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Evaluate and ignore VAL in case it has side-effects.  */
name|expand_expr
argument_list|(
name|val
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|dest
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|target_char_cast
argument_list|(
name|val
argument_list|,
operator|&
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|can_store_by_pieces
argument_list|(
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|,
name|builtin_memset_read_str
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|c
argument_list|,
name|dest_align
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest_mem
operator|=
name|get_memory_rtx
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|store_by_pieces
argument_list|(
name|dest_mem
argument_list|,
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|,
name|builtin_memset_read_str
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|c
argument_list|,
name|dest_align
argument_list|)
expr_stmt|;
return|return
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
return|;
block|}
name|len_rtx
operator|=
name|expand_expr
argument_list|(
name|len
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|get_memory_rtx
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|dest_mem
argument_list|,
name|dest_align
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|clear_storage
argument_list|(
name|dest_mem
argument_list|,
name|len_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_addr
operator|==
literal|0
condition|)
name|dest_addr
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
name|dest_addr
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the bzero builtin.  Return 0    if we failed the caller should emit a normal call.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_bzero
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|dest
decl_stmt|,
name|size
decl_stmt|,
name|newarglist
decl_stmt|;
name|rtx
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|size
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* New argument list transforming bzero(ptr x, int y) to      memset(ptr x, int 0, size_t y).   This is done this way      so that if it isn't expanded inline, we fallback to      calling bzero instead of memset.  */
name|newarglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|newarglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
name|newarglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|newarglist
expr_stmt|;
name|result
operator|=
name|expand_builtin_memset
argument_list|(
name|exp
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
comment|/* Always restore the original arguments.  */
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|arglist
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the memcmp or the strcmp builtin.    ARGLIST is the argument list for this call.  Return 0 if we failed and the    caller should emit a normal call, otherwise try to get the result in    TARGET, if convenient (and in mode MODE, if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_memcmp
parameter_list|(
name|exp
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|)
name|tree
name|exp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the len parameter is zero, return zero.  */
if|if
condition|(
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|&&
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Evaluate and ignore arg1 and arg2 in case they have          side-effects.  */
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|p1
operator|=
name|c_getstr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|c_getstr
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* If all arguments are constant, and the value of len is not greater      than the lengths of arg1 and arg2, evaluate at compile-time.  */
if|if
condition|(
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|&&
name|p1
operator|&&
name|p2
operator|&&
name|compare_tree_int
argument_list|(
name|len
argument_list|,
name|strlen
argument_list|(
name|p1
argument_list|)
operator|+
literal|1
argument_list|)
operator|<=
literal|0
operator|&&
name|compare_tree_int
argument_list|(
name|len
argument_list|,
name|strlen
argument_list|(
name|p2
argument_list|)
operator|+
literal|1
argument_list|)
operator|<=
literal|0
condition|)
block|{
specifier|const
name|int
name|r
init|=
name|memcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|r
operator|<
literal|0
condition|?
name|constm1_rtx
else|:
operator|(
name|r
operator|>
literal|0
condition|?
name|const1_rtx
else|:
name|const0_rtx
operator|)
operator|)
return|;
block|}
comment|/* If len parameter is one, return an expression corresponding to      (*(const unsigned char*)arg1 - (const unsigned char*)arg2).  */
if|if
condition|(
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|&&
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|tree
name|cst_uchar_node
init|=
name|build_type_variant
argument_list|(
name|unsigned_char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|cst_uchar_ptr_node
init|=
name|build_pointer_type
argument_list|(
name|cst_uchar_node
argument_list|)
decl_stmt|;
name|tree
name|ind1
init|=
name|fold
argument_list|(
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|cst_uchar_ptr_node
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ind2
init|=
name|fold
argument_list|(
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|cst_uchar_ptr_node
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ind1
argument_list|,
name|ind2
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_cmpstrsi
block|{
name|rtx
name|arg1_rtx
decl_stmt|,
name|arg2_rtx
decl_stmt|,
name|arg3_rtx
decl_stmt|;
name|rtx
name|result
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|arg1_align
init|=
name|get_pointer_alignment
argument_list|(
name|arg1
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|arg2_align
init|=
name|get_pointer_alignment
argument_list|(
name|arg2
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|enum
name|machine_mode
name|insn_mode
init|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_cmpstrsi
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
comment|/* If we don't have POINTER_TYPE, call the function.  */
if|if
condition|(
name|arg1_align
operator|==
literal|0
operator|||
name|arg2_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Make a place to write the result of the instruction.  */
name|result
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|result
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|insn_mode
operator|&&
name|REGNO
argument_list|(
name|result
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
name|arg1_rtx
operator|=
name|get_memory_rtx
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg2_rtx
operator|=
name|get_memory_rtx
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|arg3_rtx
operator|=
name|expand_expr
argument_list|(
name|len
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HAVE_cmpstrsi
condition|)
name|insn
operator|=
name|NULL_RTX
expr_stmt|;
else|else
name|insn
operator|=
name|gen_cmpstrsi
argument_list|(
name|result
argument_list|,
name|arg1_rtx
argument_list|,
name|arg2_rtx
argument_list|,
name|arg3_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|MIN
argument_list|(
name|arg1_align
argument_list|,
name|arg2_align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|emit_library_call_value
argument_list|(
name|memcmp_libfunc
argument_list|,
name|result
argument_list|,
name|LCT_PURE_MAKE_BLOCK
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|arg1_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|arg2_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|arg3_rtx
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the value in the proper mode for this function.  */
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|mode
condition|)
return|return
name|result
return|;
elseif|else
if|if
condition|(
name|target
operator|!=
literal|0
condition|)
block|{
name|convert_move
argument_list|(
name|target
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strcmp builtin.  Return 0    if we failed the caller should emit a normal call, otherwise try to get    the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strcmp
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|len
decl_stmt|,
name|len2
decl_stmt|,
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|p1
operator|=
name|c_getstr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|c_getstr
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|&&
name|p2
condition|)
block|{
specifier|const
name|int
name|i
init|=
name|strcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
decl_stmt|;
return|return
operator|(
name|i
operator|<
literal|0
condition|?
name|constm1_rtx
else|:
operator|(
name|i
operator|>
literal|0
condition|?
name|const1_rtx
else|:
name|const0_rtx
operator|)
operator|)
return|;
block|}
comment|/* If either arg is "", return an expression corresponding to      (*(const unsigned char*)arg1 - (const unsigned char*)arg2).  */
if|if
condition|(
operator|(
name|p1
operator|&&
operator|*
name|p1
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|p2
operator|&&
operator|*
name|p2
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|tree
name|cst_uchar_node
init|=
name|build_type_variant
argument_list|(
name|unsigned_char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|cst_uchar_ptr_node
init|=
name|build_pointer_type
argument_list|(
name|cst_uchar_node
argument_list|)
decl_stmt|;
name|tree
name|ind1
init|=
name|fold
argument_list|(
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|cst_uchar_ptr_node
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ind2
init|=
name|fold
argument_list|(
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|cst_uchar_ptr_node
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ind1
argument_list|,
name|ind2
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
name|len
operator|=
name|c_strlen
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|len2
operator|=
name|c_strlen
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|len
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len2
condition|)
name|len2
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|,
name|len2
argument_list|)
expr_stmt|;
comment|/* If we don't have a constant length for the first, use the length      of the second, if we know it.  We don't require a constant for      this case; some cost analysis could be done if both are available      but neither is constant.  For now, assume they're equally cheap      unless one has side effects.       If both strings have constant lengths, use the smaller.  This      could arise if optimization results in strcpy being called with      two fixed strings, or if the code was machine-generated.  We should      add some code to the `memcmp' handler below to deal with such      situations, someday.  */
if|if
condition|(
operator|!
name|len
operator|||
name|TREE_CODE
argument_list|(
name|len
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|len2
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|len2
argument_list|)
condition|)
name|len
operator|=
name|len2
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|len2
operator|&&
name|TREE_CODE
argument_list|(
name|len2
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_lt
argument_list|(
name|len2
argument_list|,
name|len
argument_list|)
condition|)
name|len
operator|=
name|len2
expr_stmt|;
comment|/* If both arguments have side effects, we cannot optimize.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_MEMCMP
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
name|chainon
argument_list|(
name|arglist
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strncmp builtin.  Return 0    if we failed the caller should emit a normal call, otherwise try to get    the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strncmp
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|newarglist
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|arg3
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the len parameter is zero, return zero.  */
if|if
condition|(
name|host_integerp
argument_list|(
name|arg3
argument_list|,
literal|1
argument_list|)
operator|&&
name|tree_low_cst
argument_list|(
name|arg3
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Evaluate and ignore arg1 and arg2 in case they have        side-effects.  */
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|p1
operator|=
name|c_getstr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|c_getstr
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* If all arguments are constant, evaluate at compile-time.  */
if|if
condition|(
name|host_integerp
argument_list|(
name|arg3
argument_list|,
literal|1
argument_list|)
operator|&&
name|p1
operator|&&
name|p2
condition|)
block|{
specifier|const
name|int
name|r
init|=
name|strncmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|tree_low_cst
argument_list|(
name|arg3
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|r
operator|<
literal|0
condition|?
name|constm1_rtx
else|:
operator|(
name|r
operator|>
literal|0
condition|?
name|const1_rtx
else|:
name|const0_rtx
operator|)
operator|)
return|;
block|}
comment|/* If len == 1 or (either string parameter is "" and (len>= 1)),       return (*(const u_char*)arg1 - *(const u_char*)arg2).  */
if|if
condition|(
name|host_integerp
argument_list|(
name|arg3
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|tree_low_cst
argument_list|(
name|arg3
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
operator|||
operator|(
name|tree_low_cst
argument_list|(
name|arg3
argument_list|,
literal|1
argument_list|)
operator|>
literal|1
operator|&&
operator|(
operator|(
name|p1
operator|&&
operator|*
name|p1
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|p2
operator|&&
operator|*
name|p2
operator|==
literal|'\0'
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|tree
name|cst_uchar_node
init|=
name|build_type_variant
argument_list|(
name|unsigned_char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|cst_uchar_ptr_node
init|=
name|build_pointer_type
argument_list|(
name|cst_uchar_node
argument_list|)
decl_stmt|;
name|tree
name|ind1
init|=
name|fold
argument_list|(
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|cst_uchar_ptr_node
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ind2
init|=
name|fold
argument_list|(
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|cst_uchar_ptr_node
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ind1
argument_list|,
name|ind2
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If c_strlen can determine an expression for one of the string      lengths, and it doesn't have side effects, then call      expand_builtin_memcmp() using length MIN(strlen(string)+1, arg3).  */
comment|/* Perhaps one of the strings is really constant, if so prefer      that constant length over the other string's length.  */
if|if
condition|(
name|p1
condition|)
name|len
operator|=
name|c_strlen
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p2
condition|)
name|len
operator|=
name|c_strlen
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* If we still don't have a len, try either string arg as long      as they don't have side effects.  */
if|if
condition|(
operator|!
name|len
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg1
argument_list|)
condition|)
name|len
operator|=
name|c_strlen
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg2
argument_list|)
condition|)
name|len
operator|=
name|c_strlen
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* If we still don't have a length, punt.  */
if|if
condition|(
operator|!
name|len
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|built_in_decls
index|[
name|BUILT_IN_MEMCMP
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
comment|/* Add one to the string length.  */
name|len
operator|=
name|fold
argument_list|(
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|len
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The actual new length parameter is MIN(len,arg3).  */
name|len
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MIN_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|len
argument_list|)
argument_list|,
name|len
argument_list|,
name|arg3
argument_list|)
argument_list|)
expr_stmt|;
name|newarglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newarglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
name|newarglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|newarglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strcat builtin.    Return 0 if we failed the caller should emit a normal call,    otherwise try to get the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strcat
parameter_list|(
name|arglist
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|dst
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|src
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|c_getstr
argument_list|(
name|src
argument_list|)
decl_stmt|;
comment|/* If the string length is zero, return the dst parameter.  */
if|if
condition|(
name|p
operator|&&
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|expand_expr
argument_list|(
name|dst
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strncat builtin.    Return 0 if we failed the caller should emit a normal call,    otherwise try to get the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strncat
parameter_list|(
name|arglist
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|dst
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|src
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|,
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|c_getstr
argument_list|(
name|src
argument_list|)
decl_stmt|;
comment|/* If the requested length is zero, or the src parameter string           length is zero, return the dst parameter.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
operator|||
operator|(
name|p
operator|&&
operator|*
name|p
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|/* Evaluate and ignore the src and len parameters in case 	     they have side-effects.  */
name|expand_expr
argument_list|(
name|src
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|len
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|dst
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If the requested len is greater than or equal to the string          length, call strcat.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|len
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|p
operator|&&
name|compare_tree_int
argument_list|(
name|len
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|tree
name|newarglist
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dst
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
init|=
name|built_in_decls
index|[
name|BUILT_IN_STRCAT
index|]
decl_stmt|;
comment|/* If the replacement _DECL isn't initialized, don't do the 	     transformation.  */
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|newarglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strspn builtin.    Return 0 if we failed the caller should emit a normal call,    otherwise try to get the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strspn
parameter_list|(
name|arglist
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|s1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|s2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
init|=
name|c_getstr
argument_list|(
name|s1
argument_list|)
decl_stmt|,
modifier|*
name|p2
init|=
name|c_getstr
argument_list|(
name|s2
argument_list|)
decl_stmt|;
comment|/* If both arguments are constants, evaluate at compile-time.  */
if|if
condition|(
name|p1
operator|&&
name|p2
condition|)
block|{
specifier|const
name|size_t
name|r
init|=
name|strspn
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
decl_stmt|;
return|return
name|expand_expr
argument_list|(
name|size_int
argument_list|(
name|r
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If either argument is "", return 0.  */
if|if
condition|(
operator|(
name|p1
operator|&&
operator|*
name|p1
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|p2
operator|&&
operator|*
name|p2
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|/* Evaluate and ignore both arguments in case either one has 	     side-effects.  */
name|expand_expr
argument_list|(
name|s1
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|s2
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strcspn builtin.    Return 0 if we failed the caller should emit a normal call,    otherwise try to get the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strcspn
parameter_list|(
name|arglist
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|s1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|s2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
init|=
name|c_getstr
argument_list|(
name|s1
argument_list|)
decl_stmt|,
modifier|*
name|p2
init|=
name|c_getstr
argument_list|(
name|s2
argument_list|)
decl_stmt|;
comment|/* If both arguments are constants, evaluate at compile-time.  */
if|if
condition|(
name|p1
operator|&&
name|p2
condition|)
block|{
specifier|const
name|size_t
name|r
init|=
name|strcspn
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
decl_stmt|;
return|return
name|expand_expr
argument_list|(
name|size_int
argument_list|(
name|r
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If the first argument is "", return 0.  */
if|if
condition|(
name|p1
operator|&&
operator|*
name|p1
operator|==
literal|'\0'
condition|)
block|{
comment|/* Evaluate and ignore argument s2 in case it has 	     side-effects.  */
name|expand_expr
argument_list|(
name|s2
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
comment|/* If the second argument is "", return __builtin_strlen(s1).  */
if|if
condition|(
name|p2
operator|&&
operator|*
name|p2
operator|==
literal|'\0'
condition|)
block|{
name|tree
name|newarglist
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|s1
argument_list|)
decl_stmt|,
name|fn
init|=
name|built_in_decls
index|[
name|BUILT_IN_STRLEN
index|]
decl_stmt|;
comment|/* If the replacement _DECL isn't initialized, don't do the 	     transformation.  */
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|newarglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to __builtin_saveregs, generating the result in TARGET,    if that's convenient.  */
end_comment

begin_function
name|rtx
name|expand_builtin_saveregs
parameter_list|()
block|{
name|rtx
name|val
decl_stmt|,
name|seq
decl_stmt|;
comment|/* Don't do __builtin_saveregs more than once in a function.      Save the result of the first call and reuse it.  */
if|if
condition|(
name|saveregs_value
operator|!=
literal|0
condition|)
return|return
name|saveregs_value
return|;
comment|/* When this function is called, it means that registers must be      saved on entry to this function.  So we migrate the call to the      first insn of this function.  */
name|start_sequence
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|EXPAND_BUILTIN_SAVEREGS
comment|/* Do whatever the machine needs done in this case.  */
name|val
operator|=
name|EXPAND_BUILTIN_SAVEREGS
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* ??? We used to try and build up a call to the out of line function,      guessing about what registers needed saving etc.  This became much      harder with __builtin_va_start, since we don't have a tree for a      call to __builtin_saveregs to fall back on.  There was exactly one      port (i860) that used this code, and I'm unconvinced it could actually      handle the general case.  So we no longer try to handle anything      weird and make the backend absorb the evil.  */
name|error
argument_list|(
literal|"__builtin_saveregs not supported by this target"
argument_list|)
expr_stmt|;
name|val
operator|=
name|const0_rtx
expr_stmt|;
endif|#
directive|endif
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|saveregs_value
operator|=
name|val
expr_stmt|;
comment|/* Put the sequence after the NOTE that starts the function.  If this      is inside a SEQUENCE, make the outer-level insn chain current, so      the code is placed at the start of the function.  */
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|emit_insns_after
argument_list|(
name|seq
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* __builtin_args_info (N) returns word N of the arg space info    for the current function.  The number and meanings of words    is controlled by the definition of CUMULATIVE_ARGS.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_args_info
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|nwords
init|=
sizeof|sizeof
argument_list|(
name|CUMULATIVE_ARGS
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
name|int
modifier|*
name|word_ptr
init|=
operator|(
name|int
operator|*
operator|)
operator|&
name|current_function_args_info
decl_stmt|;
if|#
directive|if
literal|0
comment|/* These are used by the code below that is if 0'ed away */
block|int i;   tree type, elts, result;
endif|#
directive|endif
if|if
condition|(
sizeof|sizeof
argument_list|(
name|CUMULATIVE_ARGS
argument_list|)
operator|%
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|arglist
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|error
argument_list|(
literal|"argument of `__builtin_args_info' must be constant"
argument_list|)
expr_stmt|;
else|else
block|{
name|HOST_WIDE_INT
name|wordnum
init|=
name|tree_low_cst
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|wordnum
operator|<
literal|0
operator|||
name|wordnum
operator|>=
name|nwords
condition|)
name|error
argument_list|(
literal|"argument of `__builtin_args_info' out of range"
argument_list|)
expr_stmt|;
else|else
return|return
name|GEN_INT
argument_list|(
name|word_ptr
index|[
name|wordnum
index|]
argument_list|)
return|;
block|}
block|}
else|else
name|error
argument_list|(
literal|"missing argument in `__builtin_args_info'"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
if|#
directive|if
literal|0
block|for (i = 0; i< nwords; i++)     elts = tree_cons (NULL_TREE, build_int_2 (word_ptr[i], 0));    type = build_array_type (integer_type_node, 			   build_index_type (build_int_2 (nwords, 0)));   result = build (CONSTRUCTOR, type, NULL_TREE, nreverse (elts));   TREE_CONSTANT (result) = 1;   TREE_STATIC (result) = 1;   result = build1 (INDIRECT_REF, build_pointer_type (type), result);   TREE_CONSTANT (result) = 1;   return expand_expr (result, NULL_RTX, VOIDmode, 0);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Expand ARGLIST, from a call to __builtin_next_arg.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_next_arg
parameter_list|(
name|arglist
parameter_list|)
name|tree
name|arglist
decl_stmt|;
block|{
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|)
operator|)
operator|&&
operator|!
name|current_function_varargs
condition|)
block|{
name|error
argument_list|(
literal|"`va_start' used in function with fixed args"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|arglist
condition|)
block|{
name|tree
name|last_parm
init|=
name|tree_last
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
comment|/* Strip off all nops for the sake of the comparison.  This 	 is not quite the same as STRIP_NOPS.  It does more. 	 We must also strip off INDIRECT_EXPR for C++ reference 	 parameters.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
name|last_parm
condition|)
name|warning
argument_list|(
literal|"second parameter of `va_start' not last named argument"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|current_function_varargs
condition|)
comment|/* Evidently an out of date version of<stdarg.h>; can't validate        va_start's second argument, but can still work as intended.  */
name|warning
argument_list|(
literal|"`__builtin_next_arg' called without an argument"
argument_list|)
expr_stmt|;
return|return
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|current_function_internal_arg_pointer
argument_list|,
name|current_function_arg_offset_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make it easier for the backends by protecting the valist argument    from multiple evaluations.  */
end_comment

begin_function
specifier|static
name|tree
name|stabilize_va_list
parameter_list|(
name|valist
parameter_list|,
name|needs_lvalue
parameter_list|)
name|tree
name|valist
decl_stmt|;
name|int
name|needs_lvalue
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|va_list_type_node
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|valist
argument_list|)
condition|)
name|valist
operator|=
name|save_expr
argument_list|(
name|valist
argument_list|)
expr_stmt|;
comment|/* For this case, the backends will be expecting a pointer to 	 TREE_TYPE (va_list_type_node), but it's possible we've 	 actually been given an array (an actual va_list_type_node). 	 So fix it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|p1
init|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|build_pointer_type
argument_list|(
name|va_list_type_node
argument_list|)
decl_stmt|;
name|valist
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|p2
argument_list|,
name|valist
argument_list|)
expr_stmt|;
name|valist
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|p1
argument_list|,
name|valist
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|pt
decl_stmt|;
if|if
condition|(
operator|!
name|needs_lvalue
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|valist
argument_list|)
condition|)
return|return
name|valist
return|;
name|pt
operator|=
name|build_pointer_type
argument_list|(
name|va_list_type_node
argument_list|)
expr_stmt|;
name|valist
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|pt
argument_list|,
name|valist
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|valist
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|valist
argument_list|)
condition|)
name|valist
operator|=
name|save_expr
argument_list|(
name|valist
argument_list|)
expr_stmt|;
name|valist
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
argument_list|,
name|valist
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|valist
return|;
block|}
end_function

begin_comment
comment|/* The "standard" implementation of va_start: just assign `nextarg' to    the variable.  */
end_comment

begin_function
name|void
name|std_expand_builtin_va_start
parameter_list|(
name|stdarg_p
parameter_list|,
name|valist
parameter_list|,
name|nextarg
parameter_list|)
name|int
name|stdarg_p
decl_stmt|;
name|tree
name|valist
decl_stmt|;
name|rtx
name|nextarg
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|stdarg_p
condition|)
block|{
comment|/* The dummy named parameter is declared as a 'word' sized 	 object, but if a 'word' is smaller than an 'int', it would 	 have been promoted to int when it was added to the arglist.  */
name|int
name|align
init|=
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|size
init|=
name|MAX
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
operator|(
operator|(
name|size
operator|+
name|align
operator|-
literal|1
operator|)
operator|/
name|align
operator|)
operator|*
name|align
decl_stmt|;
name|nextarg
operator|=
name|plus_constant
argument_list|(
name|nextarg
argument_list|,
operator|-
name|offset
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|make_tree
argument_list|(
name|ptr_type_node
argument_list|,
name|nextarg
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand ARGLIST, which from a call to __builtin_stdarg_va_start or    __builtin_varargs_va_start, depending on STDARG_P.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_va_start
parameter_list|(
name|stdarg_p
parameter_list|,
name|arglist
parameter_list|)
name|int
name|stdarg_p
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
block|{
name|rtx
name|nextarg
decl_stmt|;
name|tree
name|chain
init|=
name|arglist
decl_stmt|,
name|valist
decl_stmt|;
if|if
condition|(
name|stdarg_p
condition|)
name|nextarg
operator|=
name|expand_builtin_next_arg
argument_list|(
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|nextarg
operator|=
name|expand_builtin_next_arg
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
condition|)
name|error
argument_list|(
literal|"too many arguments to function `va_start'"
argument_list|)
expr_stmt|;
name|valist
operator|=
name|stabilize_va_list
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXPAND_BUILTIN_VA_START
name|EXPAND_BUILTIN_VA_START
argument_list|(
name|stdarg_p
argument_list|,
name|valist
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
else|#
directive|else
name|std_expand_builtin_va_start
argument_list|(
name|stdarg_p
argument_list|,
name|valist
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* The "standard" implementation of va_arg: read the value from the    current (padded) address and increment by the (padded) size.  */
end_comment

begin_function
name|rtx
name|std_expand_builtin_va_arg
parameter_list|(
name|valist
parameter_list|,
name|type
parameter_list|)
name|tree
name|valist
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|addr_tree
decl_stmt|,
name|t
decl_stmt|,
name|type_size
init|=
name|NULL
decl_stmt|;
name|tree
name|align
decl_stmt|,
name|alignm1
decl_stmt|;
name|tree
name|rounded_size
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
comment|/* Compute the rounded size of the type.  */
name|align
operator|=
name|size_int
argument_list|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|alignm1
operator|=
name|size_int
argument_list|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
operator|(
name|type_size
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|TREE_OVERFLOW
argument_list|(
name|type_size
argument_list|)
condition|)
name|rounded_size
operator|=
name|size_zero_node
expr_stmt|;
else|else
name|rounded_size
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|sizetype
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|sizetype
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|type_size
argument_list|,
name|alignm1
argument_list|)
argument_list|)
argument_list|,
name|align
argument_list|)
argument_list|)
argument_list|,
name|align
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get AP.  */
name|addr_tree
operator|=
name|valist
expr_stmt|;
if|if
condition|(
name|PAD_VARARGS_DOWN
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|rounded_size
argument_list|)
condition|)
block|{
comment|/* Small args are padded downward.  */
name|addr_tree
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|addr_tree
argument_list|)
argument_list|,
name|addr_tree
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|sizetype
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|GT_EXPR
argument_list|,
name|sizetype
argument_list|,
name|rounded_size
argument_list|,
name|align
argument_list|)
argument_list|)
argument_list|,
name|size_zero_node
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|rounded_size
argument_list|,
name|type_size
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|expand_expr
argument_list|(
name|addr_tree
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|addr
operator|=
name|copy_to_reg
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* Compute new value for AP.  */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|rounded_size
argument_list|)
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|rounded_size
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Expand __builtin_va_arg, which is not really a builtin function, but    a very special sort of operator.  */
end_comment

begin_function
name|rtx
name|expand_builtin_va_arg
parameter_list|(
name|valist
parameter_list|,
name|type
parameter_list|)
name|tree
name|valist
decl_stmt|,
name|type
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|,
name|result
decl_stmt|;
name|tree
name|promoted_type
decl_stmt|,
name|want_va_type
decl_stmt|,
name|have_va_type
decl_stmt|;
comment|/* Verify that valist is of the proper type.  */
name|want_va_type
operator|=
name|va_list_type_node
expr_stmt|;
name|have_va_type
operator|=
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|want_va_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* If va_list is an array type, the argument may have decayed 	 to a pointer type, e.g. by being passed to another function.          In that case, unwrap both types so that we can compare the 	 underlying records.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|have_va_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|have_va_type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|want_va_type
operator|=
name|TREE_TYPE
argument_list|(
name|want_va_type
argument_list|)
expr_stmt|;
name|have_va_type
operator|=
name|TREE_TYPE
argument_list|(
name|have_va_type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|want_va_type
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|have_va_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"first argument to `va_arg' not of type `va_list'"
argument_list|)
expr_stmt|;
name|addr
operator|=
name|const0_rtx
expr_stmt|;
block|}
comment|/* Generate a diagnostic for requesting data of a type that cannot      be passed through `...' due to type promotion at the call site.  */
elseif|else
if|if
condition|(
operator|(
name|promoted_type
operator|=
call|(
modifier|*
name|lang_type_promotes_to
call|)
argument_list|(
name|type
argument_list|)
operator|)
operator|!=
name|NULL_TREE
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
literal|"<anonymous type>"
decl_stmt|,
modifier|*
name|pname
init|=
literal|0
decl_stmt|;
specifier|static
name|bool
name|gave_help
decl_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|promoted_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|promoted_type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|pname
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|promoted_type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|promoted_type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|promoted_type
argument_list|)
argument_list|)
condition|)
name|pname
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|promoted_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Unfortunately, this is merely undefined, rather than a constraint 	 violation, so we cannot make this an error.  If this call is never 	 executed, the program is still strictly conforming.  */
name|warning
argument_list|(
literal|"`%s' is promoted to `%s' when passed through `...'"
argument_list|,
name|name
argument_list|,
name|pname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gave_help
condition|)
block|{
name|gave_help
operator|=
name|true
expr_stmt|;
name|warning
argument_list|(
literal|"(so you should pass `%s' not `%s' to `va_arg')"
argument_list|,
name|pname
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* We can, however, treat "undefined" any way we please. 	 Call abort to encourage the user to fix the program.  */
name|expand_builtin_trap
argument_list|()
expr_stmt|;
comment|/* This is dead code, but go ahead and finish so that the 	 mode of the result comes out right.  */
name|addr
operator|=
name|const0_rtx
expr_stmt|;
block|}
else|else
block|{
comment|/* Make it easier for the backends by protecting the valist argument          from multiple evaluations.  */
name|valist
operator|=
name|stabilize_va_list
argument_list|(
name|valist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXPAND_BUILTIN_VA_ARG
name|addr
operator|=
name|EXPAND_BUILTIN_VA_ARG
argument_list|(
name|valist
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|#
directive|else
name|addr
operator|=
name|std_expand_builtin_va_arg
argument_list|(
name|valist
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|Pmode
condition|)
name|addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|result
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Expand ARGLIST, from a call to __builtin_va_end.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_va_end
parameter_list|(
name|arglist
parameter_list|)
name|tree
name|arglist
decl_stmt|;
block|{
name|tree
name|valist
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|EXPAND_BUILTIN_VA_END
name|valist
operator|=
name|stabilize_va_list
argument_list|(
name|valist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EXPAND_BUILTIN_VA_END
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Evaluate for side effects, if needed.  I hate macros that don't      do that.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|valist
argument_list|)
condition|)
name|expand_expr
argument_list|(
name|valist
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* Expand ARGLIST, from a call to __builtin_va_copy.  We do this as a    builtin rather than just as an assignment in stdarg.h because of the    nastiness of array-type va_list types.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_va_copy
parameter_list|(
name|arglist
parameter_list|)
name|tree
name|arglist
decl_stmt|;
block|{
name|tree
name|dst
decl_stmt|,
name|src
decl_stmt|,
name|t
decl_stmt|;
name|dst
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|stabilize_va_list
argument_list|(
name|dst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|src
operator|=
name|stabilize_va_list
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|va_list_type_node
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|va_list_type_node
argument_list|,
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|dstb
decl_stmt|,
name|srcb
decl_stmt|,
name|size
decl_stmt|;
comment|/* Evaluate to pointers.  */
name|dstb
operator|=
name|expand_expr
argument_list|(
name|dst
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|srcb
operator|=
name|expand_expr
argument_list|(
name|src
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|size
operator|=
name|expand_expr
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|dstb
argument_list|)
operator|!=
name|Pmode
condition|)
name|dstb
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|dstb
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|srcb
argument_list|)
operator|!=
name|Pmode
condition|)
name|srcb
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|srcb
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* "Dereference" to BLKmode memories.  */
name|dstb
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|dstb
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|dstb
argument_list|,
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|dstb
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|srcb
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|srcb
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|srcb
argument_list|,
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|srcb
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy.  */
name|emit_block_move
argument_list|(
name|dstb
argument_list|,
name|srcb
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to one of the builtin functions __builtin_frame_address or    __builtin_return_address.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_frame_address
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* The argument must be a nonnegative integer constant.      It counts the number of frames to scan up the stack.      The value is the return address saved in that frame.  */
if|if
condition|(
name|arglist
operator|==
literal|0
condition|)
comment|/* Warning about missing arg was already issued.  */
return|return
name|const0_rtx
return|;
elseif|else
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_FRAME_ADDRESS
condition|)
name|error
argument_list|(
literal|"invalid arg to `__builtin_frame_address'"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid arg to `__builtin_return_address'"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
else|else
block|{
name|rtx
name|tem
init|=
name|expand_builtin_return_addr
argument_list|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|tree_low_cst
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
decl_stmt|;
comment|/* Some ports cannot access arbitrary stack frames.  */
if|if
condition|(
name|tem
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_FRAME_ADDRESS
condition|)
name|warning
argument_list|(
literal|"unsupported arg to `__builtin_frame_address'"
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"unsupported arg to `__builtin_return_address'"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
comment|/* For __builtin_frame_address, return what we've got.  */
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_FRAME_ADDRESS
condition|)
return|return
name|tem
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|tem
argument_list|)
condition|)
name|tem
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to the alloca builtin, with arguments ARGLIST.  Return 0 if    we failed and the caller should emit a normal call, otherwise try to get    the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_alloca
parameter_list|(
name|arglist
parameter_list|,
name|target
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|op0
decl_stmt|;
name|rtx
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Compute the argument.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allocate the desired space.  */
name|result
operator|=
name|allocate_dynamic_stack_space
argument_list|(
name|op0
argument_list|,
name|target
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|!=
name|ptr_mode
condition|)
name|result
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to the ffs builtin.  The arguments are in ARGLIST.    Return 0 if a normal call should be emitted rather than expanding the    function in-line.  If convenient, the result should be placed in TARGET.    SUBTARGET may be used as the target for computing one of EXP's operands.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_ffs
parameter_list|(
name|arglist
parameter_list|,
name|target
parameter_list|,
name|subtarget
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|,
name|subtarget
decl_stmt|;
block|{
name|rtx
name|op0
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Compute the argument.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Compute ffs, into TARGET if possible.      Set TARGET to wherever the result comes back.  */
name|target
operator|=
name|expand_unop
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|ffs_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* If the string passed to fputs is a constant and is one character    long, we attempt to transform this call into __builtin_fputc().  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_fputs
parameter_list|(
name|arglist
parameter_list|,
name|ignore
parameter_list|,
name|unlocked
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|int
name|ignore
decl_stmt|;
name|int
name|unlocked
decl_stmt|;
block|{
name|tree
name|len
decl_stmt|,
name|fn
decl_stmt|;
name|tree
name|fn_fputc
init|=
name|unlocked
condition|?
name|built_in_decls
index|[
name|BUILT_IN_FPUTC_UNLOCKED
index|]
else|:
name|built_in_decls
index|[
name|BUILT_IN_FPUTC
index|]
decl_stmt|;
name|tree
name|fn_fwrite
init|=
name|unlocked
condition|?
name|built_in_decls
index|[
name|BUILT_IN_FWRITE_UNLOCKED
index|]
else|:
name|built_in_decls
index|[
name|BUILT_IN_FWRITE
index|]
decl_stmt|;
comment|/* If the return value is used, or the replacement _DECL isn't      initialized, don't do the transformation.  */
if|if
condition|(
operator|!
name|ignore
operator|||
operator|!
name|fn_fputc
operator|||
operator|!
name|fn_fwrite
condition|)
return|return
literal|0
return|;
comment|/* Verify the arguments in the original call.  */
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Get the length of the string passed to fputs.  If the length      can't be determined, punt.  */
if|if
condition|(
operator|!
operator|(
name|len
operator|=
name|c_strlen
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|len
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|compare_tree_int
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* length is 0, delete the call entirely .  */
block|{
comment|/* Evaluate and ignore the argument in case it has            side-effects.  */
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
case|case
literal|0
case|:
comment|/* length is 1, call fputc.  */
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|c_getstr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* New argument list transforming fputs(string, stream) to 	       fputc(string[0], stream).  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fputc
expr_stmt|;
break|break;
block|}
block|}
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
comment|/* length is greater than 1, call fwrite.  */
block|{
name|tree
name|string_arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
comment|/* New argument list transforming fputs(string, stream) to 	   fwrite(string, 1, len, stream).  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size_one_node
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|string_arg
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fwrite
expr_stmt|;
break|break;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
operator|(
name|ignore
condition|?
name|const0_rtx
else|:
name|NULL_RTX
operator|)
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to __builtin_expect.  We return our argument and emit a    NOTE_INSN_EXPECTED_VALUE note.  This is the expansion of __builtin_expect in    a non-jump context.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_expect
parameter_list|(
name|arglist
parameter_list|,
name|target
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|tree
name|exp
decl_stmt|,
name|c
decl_stmt|;
name|rtx
name|note
decl_stmt|,
name|rtx_c
decl_stmt|;
if|if
condition|(
name|arglist
operator|==
name|NULL_TREE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|const0_rtx
return|;
name|exp
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|c
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|c
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"second arg to `__builtin_expect' must be a constant"
argument_list|)
expr_stmt|;
name|c
operator|=
name|integer_zero_node
expr_stmt|;
block|}
name|target
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Don't bother with expected value notes for integral constants.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
comment|/* We do need to force this into a register so that we can be 	 moderately sure to be able to correctly interpret the branch 	 condition later.  */
name|target
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|rtx_c
operator|=
name|expand_expr
argument_list|(
name|c
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|note
operator|=
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_EXPECTED_VALUE
argument_list|)
expr_stmt|;
name|NOTE_EXPECTED_VALUE
argument_list|(
name|note
argument_list|)
operator|=
name|gen_rtx_EQ
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|rtx_c
argument_list|)
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Like expand_builtin_expect, except do this in a jump context.  This is    called from do_jump if the conditional is a __builtin_expect.  Return either    a SEQUENCE of insns to emit the jump or NULL if we cannot optimize    __builtin_expect.  We need to optimize this at jump time so that machines    like the PowerPC don't turn the test into a SCC operation, and then jump    based on the test being 0/1.  */
end_comment

begin_function
name|rtx
name|expand_builtin_expect_jump
parameter_list|(
name|exp
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|if_false_label
decl_stmt|;
name|rtx
name|if_true_label
decl_stmt|;
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|ret
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Only handle __builtin_expect (test, 0) and      __builtin_expect (test, 1).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|arg1
argument_list|)
operator|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|num_jumps
init|=
literal|0
decl_stmt|;
comment|/* If we fail to locate an appropriate conditional jump, we'll 	 fall back to normal evaluation.  Ensure that the expression 	 can be re-evaluated.  */
switch|switch
condition|(
name|unsafe_for_reeval
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* Safe.  */
break|break;
case|case
literal|1
case|:
comment|/* Mildly unsafe.  */
name|arg0
operator|=
name|unsave_expr
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Wildly unsafe.  */
return|return
name|NULL_RTX
return|;
block|}
comment|/* Expand the jump insns.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|arg0
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Now that the __builtin_expect has been validated, go through and add 	 the expect's to each of the conditional jumps.  If we run into an 	 error, just give up and generate the 'safe' code of doing a SCC 	 operation and then doing a branch on that.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|rtx
name|insn
init|=
name|XVECEXP
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|pattern
operator|=
name|pc_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
condition|)
block|{
name|rtx
name|ifelse
init|=
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|int
name|taken
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ifelse
argument_list|)
operator|!=
name|IF_THEN_ELSE
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ifelse
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|taken
operator|=
literal|1
expr_stmt|;
name|label
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ifelse
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* An inverted jump reverses the probabilities.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ifelse
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|taken
operator|=
literal|0
expr_stmt|;
name|label
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ifelse
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We shouldn't have to worry about conditional returns during 		 the expansion stage, but handle it gracefully anyway.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ifelse
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|taken
operator|=
literal|1
expr_stmt|;
name|label
operator|=
name|NULL_RTX
expr_stmt|;
block|}
comment|/* An inverted return reverses the probabilities.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ifelse
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|taken
operator|=
literal|0
expr_stmt|;
name|label
operator|=
name|NULL_RTX
expr_stmt|;
block|}
else|else
continue|continue;
comment|/* If the test is expected to fail, reverse the 		 probabilities.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
name|taken
operator|=
literal|1
operator|-
name|taken
expr_stmt|;
comment|/* If we are jumping to the false label, reverse the 		 probabilities.  */
if|if
condition|(
name|label
operator|==
name|NULL_RTX
condition|)
empty_stmt|;
comment|/* conditional return */
elseif|else
if|if
condition|(
name|label
operator|==
name|if_false_label
condition|)
name|taken
operator|=
literal|1
operator|-
name|taken
expr_stmt|;
elseif|else
if|if
condition|(
name|label
operator|!=
name|if_true_label
condition|)
continue|continue;
name|num_jumps
operator|++
expr_stmt|;
name|predict_insn_def
argument_list|(
name|insn
argument_list|,
name|PRED_BUILTIN_EXPECT
argument_list|,
name|taken
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If no jumps were modified, fail and do __builtin_expect the normal 	 way.  */
if|if
condition|(
name|num_jumps
operator|==
literal|0
condition|)
name|ret
operator|=
name|NULL_RTX
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|expand_builtin_trap
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|HAVE_trap
if|if
condition|(
name|HAVE_trap
condition|)
name|emit_insn
argument_list|(
name|gen_trap
argument_list|()
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|emit_library_call
argument_list|(
name|abort_libfunc
argument_list|,
name|LCT_NORETURN
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand an expression EXP that calls a built-in function,    with result going to TARGET if that's convenient    (and in mode MODE if that's convenient).    SUBTARGET may be used as the target for computing one of EXP's operands.    IGNORE is nonzero if the value is to be ignored.  */
end_comment

begin_function
name|rtx
name|expand_builtin
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|subtarget
parameter_list|,
name|mode
parameter_list|,
name|ignore
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|subtarget
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|ignore
decl_stmt|;
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|built_in_function
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_MD
condition|)
return|return
call|(
modifier|*
name|targetm
operator|.
name|expand_builtin
call|)
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|,
name|mode
argument_list|,
name|ignore
argument_list|)
return|;
comment|/* When not optimizing, generate calls to library functions for a certain      set of builtins.  */
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|!
name|CALLED_AS_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
condition|)
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|BUILT_IN_SIN
case|:
case|case
name|BUILT_IN_COS
case|:
case|case
name|BUILT_IN_SQRT
case|:
case|case
name|BUILT_IN_SQRTF
case|:
case|case
name|BUILT_IN_SQRTL
case|:
case|case
name|BUILT_IN_MEMSET
case|:
case|case
name|BUILT_IN_MEMCPY
case|:
case|case
name|BUILT_IN_MEMCMP
case|:
case|case
name|BUILT_IN_BCMP
case|:
case|case
name|BUILT_IN_BZERO
case|:
case|case
name|BUILT_IN_INDEX
case|:
case|case
name|BUILT_IN_RINDEX
case|:
case|case
name|BUILT_IN_STRCHR
case|:
case|case
name|BUILT_IN_STRRCHR
case|:
case|case
name|BUILT_IN_STRLEN
case|:
case|case
name|BUILT_IN_STRCPY
case|:
case|case
name|BUILT_IN_STRNCPY
case|:
case|case
name|BUILT_IN_STRNCMP
case|:
case|case
name|BUILT_IN_STRSTR
case|:
case|case
name|BUILT_IN_STRPBRK
case|:
case|case
name|BUILT_IN_STRCAT
case|:
case|case
name|BUILT_IN_STRNCAT
case|:
case|case
name|BUILT_IN_STRSPN
case|:
case|case
name|BUILT_IN_STRCSPN
case|:
case|case
name|BUILT_IN_STRCMP
case|:
case|case
name|BUILT_IN_FFS
case|:
case|case
name|BUILT_IN_PUTCHAR
case|:
case|case
name|BUILT_IN_PUTS
case|:
case|case
name|BUILT_IN_PRINTF
case|:
case|case
name|BUILT_IN_FPUTC
case|:
case|case
name|BUILT_IN_FPUTS
case|:
case|case
name|BUILT_IN_FWRITE
case|:
case|case
name|BUILT_IN_PUTCHAR_UNLOCKED
case|:
case|case
name|BUILT_IN_PUTS_UNLOCKED
case|:
case|case
name|BUILT_IN_PRINTF_UNLOCKED
case|:
case|case
name|BUILT_IN_FPUTC_UNLOCKED
case|:
case|case
name|BUILT_IN_FPUTS_UNLOCKED
case|:
case|case
name|BUILT_IN_FWRITE_UNLOCKED
case|:
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|BUILT_IN_ABS
case|:
case|case
name|BUILT_IN_LABS
case|:
case|case
name|BUILT_IN_LLABS
case|:
case|case
name|BUILT_IN_IMAXABS
case|:
case|case
name|BUILT_IN_FABS
case|:
case|case
name|BUILT_IN_FABSF
case|:
case|case
name|BUILT_IN_FABSL
case|:
comment|/* build_function_call changes these into ABS_EXPR.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|BUILT_IN_CONJ
case|:
case|case
name|BUILT_IN_CONJF
case|:
case|case
name|BUILT_IN_CONJL
case|:
case|case
name|BUILT_IN_CREAL
case|:
case|case
name|BUILT_IN_CREALF
case|:
case|case
name|BUILT_IN_CREALL
case|:
case|case
name|BUILT_IN_CIMAG
case|:
case|case
name|BUILT_IN_CIMAGF
case|:
case|case
name|BUILT_IN_CIMAGL
case|:
comment|/* expand_tree_builtin changes these into CONJ_EXPR, REALPART_EXPR 	 and IMAGPART_EXPR.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|BUILT_IN_SIN
case|:
case|case
name|BUILT_IN_SINF
case|:
case|case
name|BUILT_IN_SINL
case|:
case|case
name|BUILT_IN_COS
case|:
case|case
name|BUILT_IN_COSF
case|:
case|case
name|BUILT_IN_COSL
case|:
comment|/* Treat these like sqrt only if unsafe math optimizations are allowed, 	 because of possible accuracy problems.  */
if|if
condition|(
operator|!
name|flag_unsafe_math_optimizations
condition|)
break|break;
case|case
name|BUILT_IN_SQRT
case|:
case|case
name|BUILT_IN_SQRTF
case|:
case|case
name|BUILT_IN_SQRTL
case|:
name|target
operator|=
name|expand_builtin_mathfn
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FMOD
case|:
break|break;
case|case
name|BUILT_IN_APPLY_ARGS
case|:
return|return
name|expand_builtin_apply_args
argument_list|()
return|;
comment|/* __builtin_apply (FUNCTION, ARGUMENTS, ARGSIZE) invokes 	 FUNCTION with a copy of the parameters described by 	 ARGUMENTS, and ARGSIZE.  It returns a block of memory 	 allocated on the stack into which is stored all the registers 	 that might possibly be used for returning the result of a 	 function.  ARGUMENTS is the value returned by 	 __builtin_apply_args.  ARGSIZE is the number of bytes of 	 arguments that must be copied.  ??? How should this value be 	 computed?  We'll also need a safe worst case value for varargs 	 functions.  */
case|case
name|BUILT_IN_APPLY
case|:
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
operator|&&
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REFERENCE_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|rtx
name|ops
index|[
literal|3
index|]
decl_stmt|;
for|for
control|(
name|t
operator|=
name|arglist
operator|,
name|i
operator|=
literal|0
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|i
operator|++
control|)
name|ops
index|[
name|i
index|]
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_builtin_apply
argument_list|(
name|ops
index|[
literal|0
index|]
argument_list|,
name|ops
index|[
literal|1
index|]
argument_list|,
name|ops
index|[
literal|2
index|]
argument_list|)
return|;
block|}
comment|/* __builtin_return (RESULT) causes the function to return the 	 value described by RESULT.  RESULT is address of the block of 	 memory returned by __builtin_apply.  */
case|case
name|BUILT_IN_RETURN
case|:
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
name|expand_builtin_return
argument_list|(
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|BUILT_IN_SAVEREGS
case|:
return|return
name|expand_builtin_saveregs
argument_list|()
return|;
case|case
name|BUILT_IN_ARGS_INFO
case|:
return|return
name|expand_builtin_args_info
argument_list|(
name|exp
argument_list|)
return|;
comment|/* Return the address of the first anonymous stack arg.  */
case|case
name|BUILT_IN_NEXT_ARG
case|:
return|return
name|expand_builtin_next_arg
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_CLASSIFY_TYPE
case|:
return|return
name|expand_builtin_classify_type
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_CONSTANT_P
case|:
return|return
name|expand_builtin_constant_p
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|BUILT_IN_FRAME_ADDRESS
case|:
case|case
name|BUILT_IN_RETURN_ADDRESS
case|:
return|return
name|expand_builtin_frame_address
argument_list|(
name|exp
argument_list|)
return|;
comment|/* Returns the address of the area where the structure is returned.        0 otherwise.  */
case|case
name|BUILT_IN_AGGREGATE_INCOMING_ADDRESS
case|:
if|if
condition|(
name|arglist
operator|!=
literal|0
operator|||
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|const0_rtx
return|;
else|else
return|return
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|BUILT_IN_ALLOCA
case|:
name|target
operator|=
name|expand_builtin_alloca
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FFS
case|:
name|target
operator|=
name|expand_builtin_ffs
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRLEN
case|:
name|target
operator|=
name|expand_builtin_strlen
argument_list|(
name|exp
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRCPY
case|:
name|target
operator|=
name|expand_builtin_strcpy
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRNCPY
case|:
name|target
operator|=
name|expand_builtin_strncpy
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRCAT
case|:
name|target
operator|=
name|expand_builtin_strcat
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRNCAT
case|:
name|target
operator|=
name|expand_builtin_strncat
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRSPN
case|:
name|target
operator|=
name|expand_builtin_strspn
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRCSPN
case|:
name|target
operator|=
name|expand_builtin_strcspn
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRSTR
case|:
name|target
operator|=
name|expand_builtin_strstr
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRPBRK
case|:
name|target
operator|=
name|expand_builtin_strpbrk
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_INDEX
case|:
case|case
name|BUILT_IN_STRCHR
case|:
name|target
operator|=
name|expand_builtin_strchr
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_RINDEX
case|:
case|case
name|BUILT_IN_STRRCHR
case|:
name|target
operator|=
name|expand_builtin_strrchr
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_MEMCPY
case|:
name|target
operator|=
name|expand_builtin_memcpy
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_MEMSET
case|:
name|target
operator|=
name|expand_builtin_memset
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_BZERO
case|:
name|target
operator|=
name|expand_builtin_bzero
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRCMP
case|:
name|target
operator|=
name|expand_builtin_strcmp
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRNCMP
case|:
name|target
operator|=
name|expand_builtin_strncmp
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_BCMP
case|:
case|case
name|BUILT_IN_MEMCMP
case|:
name|target
operator|=
name|expand_builtin_memcmp
argument_list|(
name|exp
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_SETJMP
case|:
name|target
operator|=
name|expand_builtin_setjmp
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
comment|/* __builtin_longjmp is passed a pointer to an array of five words. 	 It's similar to the C library longjmp function but works with 	 __builtin_setjmp above.  */
case|case
name|BUILT_IN_LONGJMP
case|:
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
break|break;
else|else
block|{
name|rtx
name|buf_addr
init|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|value
init|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|const1_rtx
condition|)
block|{
name|error
argument_list|(
literal|"__builtin_longjmp second argument must be 1"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|expand_builtin_longjmp
argument_list|(
name|buf_addr
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
case|case
name|BUILT_IN_TRAP
case|:
name|expand_builtin_trap
argument_list|()
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|BUILT_IN_PUTCHAR
case|:
case|case
name|BUILT_IN_PUTS
case|:
case|case
name|BUILT_IN_FPUTC
case|:
case|case
name|BUILT_IN_FWRITE
case|:
case|case
name|BUILT_IN_PUTCHAR_UNLOCKED
case|:
case|case
name|BUILT_IN_PUTS_UNLOCKED
case|:
case|case
name|BUILT_IN_FPUTC_UNLOCKED
case|:
case|case
name|BUILT_IN_FWRITE_UNLOCKED
case|:
break|break;
case|case
name|BUILT_IN_FPUTS
case|:
name|target
operator|=
name|expand_builtin_fputs
argument_list|(
name|arglist
argument_list|,
name|ignore
argument_list|,
comment|/*unlocked=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FPUTS_UNLOCKED
case|:
name|target
operator|=
name|expand_builtin_fputs
argument_list|(
name|arglist
argument_list|,
name|ignore
argument_list|,
comment|/*unlocked=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
comment|/* Various hooks for the DWARF 2 __throw routine.  */
case|case
name|BUILT_IN_UNWIND_INIT
case|:
name|expand_builtin_unwind_init
argument_list|()
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|BUILT_IN_DWARF_CFA
case|:
return|return
name|virtual_cfa_rtx
return|;
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
case|case
name|BUILT_IN_DWARF_FP_REGNUM
case|:
return|return
name|expand_builtin_dwarf_fp_regnum
argument_list|()
return|;
case|case
name|BUILT_IN_INIT_DWARF_REG_SIZES
case|:
name|expand_builtin_init_dwarf_reg_sizes
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
endif|#
directive|endif
case|case
name|BUILT_IN_FROB_RETURN_ADDR
case|:
return|return
name|expand_builtin_frob_return_addr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
return|;
case|case
name|BUILT_IN_EXTRACT_RETURN_ADDR
case|:
return|return
name|expand_builtin_extract_return_addr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
return|;
case|case
name|BUILT_IN_EH_RETURN
case|:
name|expand_builtin_eh_return
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
ifdef|#
directive|ifdef
name|EH_RETURN_DATA_REGNO
case|case
name|BUILT_IN_EH_RETURN_DATA_REGNO
case|:
return|return
name|expand_builtin_eh_return_data_regno
argument_list|(
name|arglist
argument_list|)
return|;
endif|#
directive|endif
case|case
name|BUILT_IN_VARARGS_START
case|:
return|return
name|expand_builtin_va_start
argument_list|(
literal|0
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_STDARG_START
case|:
return|return
name|expand_builtin_va_start
argument_list|(
literal|1
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_VA_END
case|:
return|return
name|expand_builtin_va_end
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_VA_COPY
case|:
return|return
name|expand_builtin_va_copy
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_EXPECT
case|:
return|return
name|expand_builtin_expect
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|BUILT_IN_PREFETCH
case|:
name|expand_builtin_prefetch
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
default|default:
comment|/* just do library call, if unknown builtin */
name|error
argument_list|(
literal|"built-in function `%s' not currently supported"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The switch statement above can drop through to cause the function      to be called normally.  */
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to __builtin_constant_p, if we know it will evaluate to a    constant.  ARGLIST is the argument list of the call.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_constant_p
parameter_list|(
name|arglist
parameter_list|)
name|tree
name|arglist
decl_stmt|;
block|{
if|if
condition|(
name|arglist
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* We return 1 for a numeric type that's known to be a constant      value at compile-time or for an aggregate type that's a      literal constant.  */
name|STRIP_NOPS
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* If we know this is a constant, emit the constant of one.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arglist
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_CONSTANT
argument_list|(
name|arglist
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arglist
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arglist
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
operator|)
condition|)
return|return
name|integer_one_node
return|;
comment|/* If we aren't going to be running CSE or this expression      has side effects, show we don't know it to be a constant.      Likewise if it's a pointer or aggregate type since in those      case we only want literals, since those are only optimized      when generating RTL, not later.      And finally, if we are compiling an initializer, not code, we      need to return a definite result now; there's not going to be any      more optimization done.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|arglist
argument_list|)
operator|||
name|cse_not_expected
operator|||
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|||
name|cfun
operator|==
literal|0
condition|)
return|return
name|integer_zero_node
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to __builtin_classify_type.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_classify_type
parameter_list|(
name|arglist
parameter_list|)
name|tree
name|arglist
decl_stmt|;
block|{
if|if
condition|(
name|arglist
operator|==
literal|0
condition|)
return|return
name|build_int_2
argument_list|(
name|no_type_class
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|build_int_2
argument_list|(
name|type_to_class
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Used by constant folding to eliminate some builtin calls early.  EXP is    the CALL_EXPR of a call to a builtin function.  */
end_comment

begin_function
name|tree
name|fold_builtin
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|built_in_function
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_MD
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|BUILT_IN_CONSTANT_P
case|:
return|return
name|fold_builtin_constant_p
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_CLASSIFY_TYPE
case|:
return|return
name|fold_builtin_classify_type
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_STRLEN
case|:
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|len
init|=
name|c_strlen
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
condition|)
block|{
comment|/* Convert from the internal "sizetype" type to "size_t".  */
if|if
condition|(
name|size_type_node
condition|)
name|len
operator|=
name|convert
argument_list|(
name|size_type_node
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_function_call_expr
parameter_list|(
name|fn
parameter_list|,
name|arglist
parameter_list|)
name|tree
name|fn
decl_stmt|,
name|arglist
decl_stmt|;
block|{
name|tree
name|call_expr
decl_stmt|;
name|call_expr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|call_expr
operator|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|call_expr
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|call_expr
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|fold
argument_list|(
name|call_expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function validates the types of a function call argument list    represented as a tree chain of parameters against a specified list    of tree_codes.  If the last specifier is a 0, that represents an    ellipses, otherwise the last specifier must be a VOID_TYPE.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|validate_arglist
name|VPARAMS
argument_list|(
operator|(
name|tree
name|arglist
operator|,
operator|...
operator|)
argument_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|tree
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
do|do
block|{
name|code
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
expr|enum
name|tree_code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0
case|:
comment|/* This signifies an ellipses, any further arguments are all ok.  */
name|res
operator|=
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
case|case
name|VOID_TYPE
case|:
comment|/* This signifies an endlink, if no arguments remain, return          true, otherwise return false.  */
name|res
operator|=
name|arglist
operator|==
literal|0
expr_stmt|;
goto|goto
name|end
goto|;
default|default:
comment|/* If no parameters remain or the parameter's code does not          match the specified code, return false.  Otherwise continue          checking any remaining arguments.  */
if|if
condition|(
name|arglist
operator|==
literal|0
operator|||
name|code
operator|!=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
condition|)
goto|goto
name|end
goto|;
break|break;
block|}
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
comment|/* We need gotos here since we can only have one VA_CLOSE in a      function.  */
name|end
label|:
empty_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Default version of target-specific builtin setup that does nothing.  */
end_comment

begin_function
name|void
name|default_init_builtins
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* Default target-specific builtin expander that does nothing.  */
end_comment

begin_function
name|rtx
name|default_expand_builtin
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|subtarget
parameter_list|,
name|mode
parameter_list|,
name|ignore
parameter_list|)
name|tree
name|exp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|target
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|NULL_RTX
return|;
block|}
end_function

end_unit

