begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Expand builtin functions.    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"typeclass.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"predict.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_define
define|#
directive|define
name|CALLED_AS_BUILT_IN
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(!strncmp (IDENTIFIER_POINTER (DECL_NAME (NODE)), "__builtin_", 10))
end_define

begin_comment
comment|/* Register mappings for target machines without register windows.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INCOMING_REGNO
end_ifndef

begin_define
define|#
directive|define
name|INCOMING_REGNO
parameter_list|(
name|OUT
parameter_list|)
value|(OUT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OUTGOING_REGNO
end_ifndef

begin_define
define|#
directive|define
name|OUTGOING_REGNO
parameter_list|(
name|IN
parameter_list|)
value|(IN)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PAD_VARARGS_DOWN
end_ifndef

begin_define
define|#
directive|define
name|PAD_VARARGS_DOWN
value|BYTES_BIG_ENDIAN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define the names of the builtin function types and codes.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|built_in_class_names
index|[
literal|4
index|]
init|=
block|{
literal|"NOT_BUILT_IN"
block|,
literal|"BUILT_IN_FRONTEND"
block|,
literal|"BUILT_IN_MD"
block|,
literal|"BUILT_IN_NORMAL"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEF_BUILTIN
parameter_list|(
name|X
parameter_list|,
name|N
parameter_list|,
name|C
parameter_list|,
name|T
parameter_list|,
name|LT
parameter_list|,
name|B
parameter_list|,
name|F
parameter_list|,
name|NA
parameter_list|,
name|AT
parameter_list|,
name|IM
parameter_list|)
value|#X,
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|built_in_names
index|[
operator|(
name|int
operator|)
name|END_BUILTINS
index|]
init|=
block|{
include|#
directive|include
file|"builtins.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_BUILTIN
end_undef

begin_comment
comment|/* Setup an array of _DECL trees, make sure each element is    initialized to NULL_TREE.  */
end_comment

begin_decl_stmt
name|tree
name|built_in_decls
index|[
operator|(
name|int
operator|)
name|END_BUILTINS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declarations used when constructing the builtin implicitly in the compiler.    It may be NULL_TREE when this is invalid (for instance runtime is not    required to implement the function call in all cases.  */
end_comment

begin_decl_stmt
name|tree
name|implicit_built_in_decls
index|[
operator|(
name|int
operator|)
name|END_BUILTINS
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|get_pointer_alignment
parameter_list|(
name|tree
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|c_strlen
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|c_getstr
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|c_readstr
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|target_char_cast
parameter_list|(
name|tree
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|get_memory_rtx
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_string_literal
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|apply_args_size
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|apply_result_size
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_untyped_call
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_untyped_return
argument_list|)
end_if

begin_function_decl
specifier|static
name|rtx
name|result_vector
parameter_list|(
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_setjmp
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_builtin_prefetch
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_apply_args
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_apply_args_1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_apply
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_builtin_return
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|type_class
name|type_to_class
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_classify_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_errno_check
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_mathfn
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_mathfn_2
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_constant_p
parameter_list|(
name|tree
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_args_info
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_next_arg
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_va_start
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_va_end
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_va_copy
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_memcmp
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strcmp
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strncmp
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|builtin_memcpy_read_str
parameter_list|(
name|void
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strcat
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strncat
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strspn
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strcspn
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_memcpy
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_mempcpy
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_memmove
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_bcopy
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strcpy
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_stpcpy
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|builtin_strncpy_read_str
parameter_list|(
name|void
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strncpy
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|builtin_memset_read_str
parameter_list|(
name|void
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|builtin_memset_gen_str
parameter_list|(
name|void
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_memset
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_bzero
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strlen
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strstr
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strpbrk
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strchr
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_strrchr
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_alloca
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_unop
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|optab
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_frame_address
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_fputs
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_printf
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_fprintf
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_sprintf
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|stabilize_va_list
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_expect
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_constant_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_classify_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_inf
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_nan
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|validate_arglist
parameter_list|(
name|tree
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|integer_valued_real_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_trunc_transparent_mathfn
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|readonly_data_expr
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_fabs
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_builtin_cabs
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_cabs
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_trunc
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_floor
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_ceil
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_bitop
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_memcpy
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_mempcpy
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_memmove
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_strcpy
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_strncpy
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_memcmp
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_strcmp
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_builtin_strncmp
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return the alignment in bits of EXP, a pointer valued expression.    But don't return more than MAX_ALIGN no matter what.    The alignment returned is, by default, the alignment of the thing that    EXP points to.  If it is not a POINTER_TYPE, 0 is returned.     Otherwise, look at the expression to see if we can do better, i.e., if the    expression is actually pointing at an object whose alignment is tighter.  */
end_comment

begin_function
specifier|static
name|int
name|get_pointer_alignment
parameter_list|(
name|tree
name|exp
parameter_list|,
name|unsigned
name|int
name|max_align
parameter_list|)
block|{
name|unsigned
name|int
name|align
decl_stmt|,
name|inner
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|0
return|;
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
name|MIN
argument_list|(
name|align
argument_list|,
name|max_align
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
name|align
return|;
name|inner
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
name|MIN
argument_list|(
name|inner
argument_list|,
name|max_align
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
comment|/* If sum of pointer + int, restrict our maximum alignment to that 	     imposed by the integer.  If not, we can't do any better than 	     ALIGN.  */
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|align
return|;
while|while
condition|(
operator|(
operator|(
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|&
operator|(
name|max_align
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|max_align
operator|>>=
literal|1
expr_stmt|;
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
comment|/* See what we are pointing at and look at its alignment.  */
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|align
operator|=
name|FUNCTION_BOUNDARY
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|exp
argument_list|)
condition|)
name|align
operator|=
name|DECL_ALIGN
argument_list|(
name|exp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'c'
condition|)
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|exp
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|MIN
argument_list|(
name|align
argument_list|,
name|max_align
argument_list|)
return|;
default|default:
return|return
name|align
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Compute the length of a C string.  TREE_STRING_LENGTH is not the right    way, because it could contain a zero byte in the middle.    TREE_STRING_LENGTH is the size of the character array, not the string.     ONLY_VALUE should be nonzero if the result is not going to be emitted    into the instruction stream and zero if it is going to be expanded.    E.g. with i++ ? "foo" : "bar", if ONLY_VALUE is nonzero, constant 3    is returned, otherwise NULL, since    len = c_strlen (src, 1); if (len) expand_expr (len, ...); would not    evaluate the side-effects.     The value returned is of type `ssizetype'.     Unfortunately, string_constant can't access the values of const char    arrays with initializers, so neither can we do so here.  */
end_comment

begin_function
specifier|static
name|tree
name|c_strlen
parameter_list|(
name|tree
name|src
parameter_list|,
name|int
name|only_value
parameter_list|)
block|{
name|tree
name|offset_node
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|max
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|COND_EXPR
operator|&&
operator|(
name|only_value
operator|||
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tree
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|len1
operator|=
name|c_strlen
argument_list|(
name|TREE_OPERAND
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|only_value
argument_list|)
expr_stmt|;
name|len2
operator|=
name|c_strlen
argument_list|(
name|TREE_OPERAND
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
argument_list|,
name|only_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|len1
argument_list|,
name|len2
argument_list|)
condition|)
return|return
name|len1
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|&&
operator|(
name|only_value
operator|||
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|c_strlen
argument_list|(
name|TREE_OPERAND
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|only_value
argument_list|)
return|;
name|src
operator|=
name|string_constant
argument_list|(
name|src
argument_list|,
operator|&
name|offset_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|max
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|src
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ptr
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_node
operator|&&
name|TREE_CODE
argument_list|(
name|offset_node
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
comment|/* If the string has an internal zero byte (e.g., "foo\0bar"), we can't 	 compute the offset to the following null if we don't know where to 	 start searching for it.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ptr
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* We don't know the starting offset, but we do know that the string 	 has no internal zero bytes.  We can assume that the offset falls 	 within the bounds of the string; otherwise, the programmer deserves 	 what he gets.  Subtract the offset from the length of the string, 	 and return that.  This would perhaps not be valid if we were dealing 	 with named arrays in addition to literal string constants.  */
return|return
name|size_diffop
argument_list|(
name|size_int
argument_list|(
name|max
argument_list|)
argument_list|,
name|offset_node
argument_list|)
return|;
block|}
comment|/* We have a known offset into the string.  Start searching there for      a null character if we can represent it as a single HOST_WIDE_INT.  */
if|if
condition|(
name|offset_node
operator|==
literal|0
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|offset_node
argument_list|,
literal|0
argument_list|)
condition|)
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|offset
operator|=
name|tree_low_cst
argument_list|(
name|offset_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the offset is known to be out of bounds, warn, and call strlen at      runtime.  */
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|>
name|max
condition|)
block|{
name|warning
argument_list|(
literal|"offset outside bounds of constant string"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Use strlen to search for the first zero byte.  Since any strings      constructed with build_string will have nulls appended, we win even      if we get handed something like (char[4])"abcd".       Since OFFSET is our starting index into the string, no further      calculation is needed.  */
return|return
name|ssize_int
argument_list|(
name|strlen
argument_list|(
name|ptr
operator|+
name|offset
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a char pointer for a C string if it is a string constant    or sum of string constant and integer constant.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|c_getstr
parameter_list|(
name|tree
name|src
parameter_list|)
block|{
name|tree
name|offset_node
decl_stmt|;
name|src
operator|=
name|string_constant
argument_list|(
name|src
argument_list|,
operator|&
name|offset_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|offset_node
operator|==
literal|0
condition|)
return|return
name|TREE_STRING_POINTER
argument_list|(
name|src
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|offset_node
argument_list|,
literal|1
argument_list|)
operator|||
name|compare_tree_int
argument_list|(
name|offset_node
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|src
argument_list|)
operator|-
literal|1
argument_list|)
operator|>
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|TREE_STRING_POINTER
argument_list|(
name|src
argument_list|)
operator|+
name|tree_low_cst
argument_list|(
name|offset_node
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a CONST_INT or CONST_DOUBLE corresponding to target reading    GET_MODE_BITSIZE (MODE) bits from string constant STR.  */
end_comment

begin_function
specifier|static
name|rtx
name|c_readstr
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|HOST_WIDE_INT
name|c
index|[
literal|2
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|ch
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|j
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|!=
name|WORDS_BIG_ENDIAN
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
name|j
operator|=
name|j
operator|+
name|UNITS_PER_WORD
operator|-
literal|2
operator|*
operator|(
name|j
operator|%
name|UNITS_PER_WORD
operator|)
operator|-
literal|1
expr_stmt|;
name|j
operator|*=
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
condition|)
name|ch
operator|=
operator|(
name|unsigned
name|char
operator|)
name|str
index|[
name|i
index|]
expr_stmt|;
name|c
index|[
name|j
operator|/
name|HOST_BITS_PER_WIDE_INT
index|]
operator||=
name|ch
operator|<<
operator|(
name|j
operator|%
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
return|return
name|immed_double_const
argument_list|(
name|c
index|[
literal|0
index|]
argument_list|,
name|c
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Cast a target constant CST to target CHAR and if that value fits into    host char type, return zero and put that value into variable pointed by    P.  */
end_comment

begin_function
specifier|static
name|int
name|target_char_cast
parameter_list|(
name|tree
name|cst
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|val
decl_stmt|,
name|hostval
decl_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|cst
argument_list|,
literal|1
argument_list|)
operator|||
name|CHAR_TYPE_SIZE
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
literal|1
return|;
name|val
operator|=
name|tree_low_cst
argument_list|(
name|cst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHAR_TYPE_SIZE
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|val
operator|&=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|CHAR_TYPE_SIZE
operator|)
operator|-
literal|1
expr_stmt|;
name|hostval
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_CHAR
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|hostval
operator|&=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|HOST_BITS_PER_CHAR
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|hostval
condition|)
return|return
literal|1
return|;
operator|*
name|p
operator|=
name|hostval
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given TEM, a pointer to a stack frame, follow the dynamic chain COUNT    times to get the address of either a higher stack frame, or a return    address located within it (depending on FNDECL_CODE).  */
end_comment

begin_function
name|rtx
name|expand_builtin_return_addr
parameter_list|(
name|enum
name|built_in_function
name|fndecl_code
parameter_list|,
name|int
name|count
parameter_list|,
name|rtx
name|tem
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Some machines need special handling before we can access      arbitrary frames.  For example, on the sparc, we must first flush      all register windows to the stack.  */
ifdef|#
directive|ifdef
name|SETUP_FRAME_ADDRESSES
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|SETUP_FRAME_ADDRESSES
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* On the sparc, the return address is not in the frame, it is in a      register.  There is no way to access it off of the current frame      pointer, but it can be accessed off the previous frame pointer by      reading the value from the register window save area.  */
ifdef|#
directive|ifdef
name|RETURN_ADDR_IN_PREVIOUS_FRAME
if|if
condition|(
name|fndecl_code
operator|==
name|BUILT_IN_RETURN_ADDRESS
condition|)
name|count
operator|--
expr_stmt|;
endif|#
directive|endif
comment|/* Scan back COUNT frames to the specified frame.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* Assume the dynamic chain pointer is in the word that the 	 frame address points to, unless otherwise specified.  */
ifdef|#
directive|ifdef
name|DYNAMIC_CHAIN_ADDRESS
name|tem
operator|=
name|DYNAMIC_CHAIN_ADDRESS
argument_list|(
name|tem
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tem
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|tem
argument_list|,
name|get_frame_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|tem
operator|=
name|copy_to_reg
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
comment|/* For __builtin_frame_address, return what we've got.  */
if|if
condition|(
name|fndecl_code
operator|==
name|BUILT_IN_FRAME_ADDRESS
condition|)
return|return
name|tem
return|;
comment|/* For __builtin_return_address, Get the return address from that      frame.  */
ifdef|#
directive|ifdef
name|RETURN_ADDR_RTX
name|tem
operator|=
name|RETURN_ADDR_RTX
argument_list|(
name|count
argument_list|,
name|tem
argument_list|)
expr_stmt|;
else|#
directive|else
name|tem
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|tem
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|tem
argument_list|,
name|get_frame_alias_set
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Alias set used for setjmp buffer.  */
end_comment

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|setjmp_alias_set
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Construct the leading half of a __builtin_setjmp call.  Control will    return to RECEIVER_LABEL.  This is used directly by sjlj exception    handling code.  */
end_comment

begin_function
name|void
name|expand_builtin_setjmp_setup
parameter_list|(
name|rtx
name|buf_addr
parameter_list|,
name|rtx
name|receiver_label
parameter_list|)
block|{
name|enum
name|machine_mode
name|sa_mode
init|=
name|STACK_SAVEAREA_MODE
argument_list|(
name|SAVE_NONLOCAL
argument_list|)
decl_stmt|;
name|rtx
name|stack_save
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
if|if
condition|(
name|setjmp_alias_set
operator|==
operator|-
literal|1
condition|)
name|setjmp_alias_set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
name|buf_addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
name|buf_addr
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|buf_addr
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* We store the frame pointer and the address of receiver_label in      the buffer and use the rest of it for the stack save area, which      is machine-dependent.  */
ifndef|#
directive|ifndef
name|BUILTIN_SETJMP_FRAME_VALUE
define|#
directive|define
name|BUILTIN_SETJMP_FRAME_VALUE
value|virtual_stack_vars_rtx
endif|#
directive|endif
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|setjmp_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|BUILTIN_SETJMP_FRAME_VALUE
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|buf_addr
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
operator|,
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|setjmp_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|validize_mem
argument_list|(
name|mem
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|receiver_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stack_save
operator|=
name|gen_rtx_MEM
argument_list|(
name|sa_mode
argument_list|,
name|plus_constant
argument_list|(
name|buf_addr
argument_list|,
literal|2
operator|*
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|stack_save
argument_list|,
name|setjmp_alias_set
argument_list|)
expr_stmt|;
name|emit_stack_save
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
operator|&
name|stack_save
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* If there is further processing to do, do it.  */
ifdef|#
directive|ifdef
name|HAVE_builtin_setjmp_setup
if|if
condition|(
name|HAVE_builtin_setjmp_setup
condition|)
name|emit_insn
argument_list|(
name|gen_builtin_setjmp_setup
argument_list|(
name|buf_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Tell optimize_save_area_alloca that extra work is going to      need to go on during alloca.  */
name|current_function_calls_setjmp
operator|=
literal|1
expr_stmt|;
comment|/* Set this so all the registers get saved in our frame; we need to be      able to copy the saved values for any registers from frames we unwind.  */
name|current_function_has_nonlocal_label
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Construct the trailing part of a __builtin_setjmp call.    This is used directly by sjlj exception handling code.  */
end_comment

begin_function
name|void
name|expand_builtin_setjmp_receiver
parameter_list|(
name|rtx
name|receiver_label
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Clobber the FP when we get here, so we have to make sure it's      marked as used by this function.  */
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the static chain as clobbered here so life information      doesn't get messed up for it.  */
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|static_chain_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now put in the code to restore the frame pointer, and argument      pointer, if needed.  The code below is from expand_end_bindings      in stmt.c; see detailed documentation there.  */
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto
if|if
condition|(
operator|!
name|HAVE_nonlocal_goto
condition|)
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
if|if
condition|(
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
name|size_t
name|i
decl_stmt|;
specifier|static
specifier|const
struct|struct
name|elims
block|{
specifier|const
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|elim_regs
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|elim_regs
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elim_regs
index|[
name|i
index|]
operator|.
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|elim_regs
index|[
name|i
index|]
operator|.
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|ARRAY_SIZE
argument_list|(
name|elim_regs
argument_list|)
condition|)
endif|#
directive|endif
block|{
comment|/* Now restore our arg pointer from the address at which it 	     was saved in our stack frame.  */
name|emit_move_insn
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|copy_to_reg
argument_list|(
name|get_arg_pointer_save_area
argument_list|(
name|cfun
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_builtin_setjmp_receiver
if|if
condition|(
name|HAVE_builtin_setjmp_receiver
condition|)
name|emit_insn
argument_list|(
name|gen_builtin_setjmp_receiver
argument_list|(
name|receiver_label
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto_receiver
if|if
condition|(
name|HAVE_nonlocal_goto_receiver
condition|)
name|emit_insn
argument_list|(
name|gen_nonlocal_goto_receiver
argument_list|()
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
comment|/* Nothing */
block|}
comment|/* @@@ This is a kludge.  Not all machine descriptions define a blockage      insn, but we must not allow the code we just generated to be reordered      by scheduling.  Specifically, the update of the frame pointer must      happen immediately, not later.  So emit an ASM_INPUT to act as blockage      insn.  */
name|emit_insn
argument_list|(
name|gen_rtx_ASM_INPUT
argument_list|(
name|VOIDmode
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __builtin_setjmp is passed a pointer to an array of five words (not    all will be used on all machines).  It operates similarly to the C    library function of the same name, but is more efficient.  Much of    the code below (and for longjmp) is copied from the handling of    non-local gotos.     NOTE: This is intended for use by GNAT and the exception handling    scheme in the compiler and will only work in the method used by    them.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_setjmp
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|buf_addr
decl_stmt|,
name|next_lab
decl_stmt|,
name|cont_lab
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|buf_addr
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|next_lab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|cont_lab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|expand_builtin_setjmp_setup
argument_list|(
name|buf_addr
argument_list|,
name|next_lab
argument_list|)
expr_stmt|;
comment|/* Set TARGET to zero and branch to the continue label.  Use emit_jump to      ensure that pending stack adjustments are flushed.  */
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|cont_lab
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|next_lab
argument_list|)
expr_stmt|;
name|expand_builtin_setjmp_receiver
argument_list|(
name|next_lab
argument_list|)
expr_stmt|;
comment|/* Set TARGET to one.  */
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|cont_lab
argument_list|)
expr_stmt|;
comment|/* Tell flow about the strange goings on.  Putting `next_lab' on      `nonlocal_goto_handler_labels' to indicates that function      calls may traverse the arc back to this label.  */
name|current_function_has_nonlocal_label
operator|=
literal|1
expr_stmt|;
name|nonlocal_goto_handler_labels
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|next_lab
argument_list|,
name|nonlocal_goto_handler_labels
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* __builtin_longjmp is passed a pointer to an array of five words (not    all will be used on all machines).  It operates similarly to the C    library function of the same name, but is more efficient.  Much of    the code below is copied from the handling of non-local gotos.     NOTE: This is intended for use by GNAT and the exception handling    scheme in the compiler and will only work in the method used by    them.  */
end_comment

begin_function
name|void
name|expand_builtin_longjmp
parameter_list|(
name|rtx
name|buf_addr
parameter_list|,
name|rtx
name|value
parameter_list|)
block|{
name|rtx
name|fp
decl_stmt|,
name|lab
decl_stmt|,
name|stack
decl_stmt|,
name|insn
decl_stmt|,
name|last
decl_stmt|;
name|enum
name|machine_mode
name|sa_mode
init|=
name|STACK_SAVEAREA_MODE
argument_list|(
name|SAVE_NONLOCAL
argument_list|)
decl_stmt|;
if|if
condition|(
name|setjmp_alias_set
operator|==
operator|-
literal|1
condition|)
name|setjmp_alias_set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
name|buf_addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
name|buf_addr
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
comment|/* We used to store value in static_chain_rtx, but that fails if pointers      are smaller than integers.  We instead require that the user must pass      a second argument of 1, because that is what builtin_setjmp will      return.  This also makes EH slightly more efficient, since we are no      longer copying around a value that we don't care about.  */
if|if
condition|(
name|value
operator|!=
name|const1_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
name|current_function_calls_longjmp
operator|=
literal|1
expr_stmt|;
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_builtin_longjmp
if|if
condition|(
name|HAVE_builtin_longjmp
condition|)
name|emit_insn
argument_list|(
name|gen_builtin_longjmp
argument_list|(
name|buf_addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|fp
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
name|lab
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|buf_addr
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|=
name|gen_rtx_MEM
argument_list|(
name|sa_mode
argument_list|,
name|plus_constant
argument_list|(
name|buf_addr
argument_list|,
literal|2
operator|*
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|fp
argument_list|,
name|setjmp_alias_set
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|lab
argument_list|,
name|setjmp_alias_set
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|stack
argument_list|,
name|setjmp_alias_set
argument_list|)
expr_stmt|;
comment|/* Pick up FP, label, and SP from the block and jump.  This code is 	 from expand_goto in stmt.c; see there for detailed comments.  */
if|#
directive|if
name|HAVE_nonlocal_goto
if|if
condition|(
name|HAVE_nonlocal_goto
condition|)
comment|/* We have to pass a value to the nonlocal_goto pattern that will 	   get copied into the static_chain pointer, but it does not matter 	   what that value is, because builtin_setjmp does not use it.  */
name|emit_insn
argument_list|(
name|gen_nonlocal_goto
argument_list|(
name|value
argument_list|,
name|lab
argument_list|,
name|stack
argument_list|,
name|fp
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|lab
operator|=
name|copy_to_reg
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|VOIDmode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|emit_stack_restore
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
name|stack
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_indirect_jump
argument_list|(
name|lab
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Search backwards and mark the jump insn as a non-local goto.      Note that this precludes the use of __builtin_longjmp to a      __builtin_setjmp target in the same function.  However, we've      already cautioned the user that these functions are for      internal exception handling use only.  */
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|insn
operator|==
name|last
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_NON_LOCAL_GOTO
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to __builtin_prefetch.  For a target that does not support    data prefetch, evaluate the memory address argument in case it has side    effects.  */
end_comment

begin_function
specifier|static
name|void
name|expand_builtin_prefetch
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* Arguments 1 and 2 are optional; argument 1 (read/write) defaults to      zero (read) and argument 2 (locality) defaults to 3 (high degree of      locality).  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
block|{
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
condition|)
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|arg2
operator|=
name|build_int_2
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg1
operator|=
name|integer_zero_node
expr_stmt|;
name|arg2
operator|=
name|build_int_2
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Argument 0 is an address.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Argument 1 (read/write flag) must be a compile-time constant int.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"second arg to `__builtin_prefetch' must be a constant"
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|integer_zero_node
expr_stmt|;
block|}
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Argument 1 must be either zero or one.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|!=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"invalid second arg to __builtin_prefetch; using zero"
argument_list|)
expr_stmt|;
name|op1
operator|=
name|const0_rtx
expr_stmt|;
block|}
comment|/* Argument 2 (locality) must be a compile-time constant int.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"third arg to `__builtin_prefetch' must be a constant"
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|integer_zero_node
expr_stmt|;
block|}
name|op2
operator|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Argument 2 must be 0, 1, 2, or 3.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|<
literal|0
operator|||
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|>
literal|3
condition|)
block|{
name|warning
argument_list|(
literal|"invalid third arg to __builtin_prefetch; using zero"
argument_list|)
expr_stmt|;
name|op2
operator|=
name|const0_rtx
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_prefetch
if|if
condition|(
name|HAVE_prefetch
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
operator|*
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_prefetch
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_prefetch
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|)
operator|)
operator|||
operator|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|Pmode
operator|)
condition|)
block|{
name|op0
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_prefetch
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't do anything with direct references to volatile memory, but      generate code to handle other side effects.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
operator|&&
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a MEM rtx for expression EXP which is the address of an operand    to be used to be used in a string instruction (cmpstrsi, movstrsi, ..).  */
end_comment

begin_function
specifier|static
name|rtx
name|get_memory_rtx
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|rtx
name|addr
init|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|ptr_mode
argument_list|,
name|EXPAND_SUM
argument_list|)
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get an expression we can use to find the attributes to assign to MEM.      If it is an ADDR_EXPR, use the operand.  Otherwise, dereference it if      we can.  First remove any nops.  */
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|mem
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
name|exp
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
comment|/* memcpy, memset and other builtin stringops can alias with anything.  */
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|mem
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Built-in functions to perform an untyped call and return.  */
end_comment

begin_comment
comment|/* For each register that may be used for calling a function, this    gives a mode used to copy the register's value.  VOIDmode indicates    the register is not used for calling a function.  If the machine    has register windows, this gives only the outbound registers.    INCOMING_REGNO gives the corresponding inbound register.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|apply_args_mode
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each register that may be used for returning values, this gives    a mode used to copy the register's value.  VOIDmode indicates the    register is not used for returning values.  If the machine has    register windows, this gives only the outbound registers.    INCOMING_REGNO gives the corresponding inbound register.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|apply_result_mode
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each register that may be used for calling a function, this    gives the offset of that register into the block returned by    __builtin_apply_args.  0 indicates that the register is not    used for calling a function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|apply_args_reg_offset
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the offset of register REGNO into the block returned by    __builtin_apply_args.  This is not declared static, since it is    needed in objc-act.c.  */
end_comment

begin_function
name|int
name|apply_args_register_offset
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|apply_args_size
argument_list|()
expr_stmt|;
comment|/* Arguments are always put in outgoing registers (in the argument      block) if such make sense.  */
ifdef|#
directive|ifdef
name|OUTGOING_REGNO
name|regno
operator|=
name|OUTGOING_REGNO
argument_list|(
name|regno
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|apply_args_reg_offset
index|[
name|regno
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the size required for the block returned by __builtin_apply_args,    and initialize apply_args_mode.  */
end_comment

begin_function
specifier|static
name|int
name|apply_args_size
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|size
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|align
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* The values computed by this function never change.  */
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
comment|/* The first value is the incoming arg-pointer.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* The second value is the structure value address unless this is 	 passed as an "invisible" first argument.  */
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|struct_value_rtx
argument_list|(
name|cfun
condition|?
name|TREE_TYPE
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
else|:
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
comment|/* Search for the proper mode for copying this register's 	       value.  I'm not sure this is right, but it works so far.  */
name|enum
name|machine_mode
name|best_mode
init|=
name|VOIDmode
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|==
literal|1
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|best_mode
operator|==
name|VOIDmode
condition|)
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
name|have_insn_for
argument_list|(
name|SET
argument_list|,
name|mode
argument_list|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|best_mode
operator|==
name|VOIDmode
condition|)
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_VECTOR_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
name|have_insn_for
argument_list|(
name|SET
argument_list|,
name|mode
argument_list|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|best_mode
operator|==
name|VOIDmode
condition|)
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_VECTOR_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
name|have_insn_for
argument_list|(
name|SET
argument_list|,
name|mode
argument_list|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
name|mode
operator|=
name|best_mode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|apply_args_reg_offset
index|[
name|regno
index|]
operator|=
name|size
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|apply_args_mode
index|[
name|regno
index|]
operator|=
name|mode
expr_stmt|;
block|}
else|else
block|{
name|apply_args_mode
index|[
name|regno
index|]
operator|=
name|VOIDmode
expr_stmt|;
name|apply_args_reg_offset
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the size required for the block returned by __builtin_apply,    and initialize apply_result_mode.  */
end_comment

begin_function
specifier|static
name|int
name|apply_result_size
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|size
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* The values computed by this function never change.  */
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|FUNCTION_VALUE_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
comment|/* Search for the proper mode for copying this register's 	       value.  I'm not sure this is right, but it works so far.  */
name|enum
name|machine_mode
name|best_mode
init|=
name|VOIDmode
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|TImode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|best_mode
operator|==
name|VOIDmode
condition|)
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
name|have_insn_for
argument_list|(
name|SET
argument_list|,
name|mode
argument_list|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|best_mode
operator|==
name|VOIDmode
condition|)
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_VECTOR_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
name|have_insn_for
argument_list|(
name|SET
argument_list|,
name|mode
argument_list|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|best_mode
operator|==
name|VOIDmode
condition|)
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_VECTOR_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
name|have_insn_for
argument_list|(
name|SET
argument_list|,
name|mode
argument_list|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
name|mode
operator|=
name|best_mode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|apply_result_mode
index|[
name|regno
index|]
operator|=
name|mode
expr_stmt|;
block|}
else|else
name|apply_result_mode
index|[
name|regno
index|]
operator|=
name|VOIDmode
expr_stmt|;
comment|/* Allow targets that use untyped_call and untyped_return to override 	 the size so that machine-specific information can be stored here.  */
ifdef|#
directive|ifdef
name|APPLY_RESULT_SIZE
name|size
operator|=
name|APPLY_RESULT_SIZE
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|size
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_untyped_call
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_untyped_return
argument_list|)
end_if

begin_comment
comment|/* Create a vector describing the result block RESULT.  If SAVEP is true,    the result block is used to save the values; otherwise it is used to    restore the values.  */
end_comment

begin_function
specifier|static
name|rtx
name|result_vector
parameter_list|(
name|int
name|savep
parameter_list|,
name|rtx
name|result
parameter_list|)
block|{
name|int
name|regno
decl_stmt|,
name|size
decl_stmt|,
name|align
decl_stmt|,
name|nelts
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|rtx
modifier|*
name|savevec
init|=
name|alloca
argument_list|(
name|FIRST_PSEUDO_REGISTER
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|size
operator|=
name|nelts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_result_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|savep
condition|?
name|regno
else|:
name|INCOMING_REGNO
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|adjust_address
argument_list|(
name|result
argument_list|,
name|mode
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|savevec
index|[
name|nelts
operator|++
index|]
operator|=
operator|(
name|savep
condition|?
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
else|:
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|mem
argument_list|)
operator|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|nelts
argument_list|,
name|savevec
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_untyped_call or HAVE_untyped_return */
end_comment

begin_comment
comment|/* Save the state required to perform an untyped call with the same    arguments as were passed to the current function.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_apply_args_1
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|registers
decl_stmt|,
name|tem
decl_stmt|;
name|int
name|size
decl_stmt|,
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|struct_incoming_value
init|=
name|targetm
operator|.
name|calls
operator|.
name|struct_value_rtx
argument_list|(
name|cfun
condition|?
name|TREE_TYPE
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
else|:
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Create a block where the arg-pointer, structure value address,      and argument registers can be saved.  */
name|registers
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|apply_args_size
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Walk past the arg-pointer and structure value address.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|struct_value_rtx
argument_list|(
name|cfun
condition|?
name|TREE_TYPE
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
else|:
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Save each register used in calling a function to the block.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_args_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|tem
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|INCOMING_REGNO
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|registers
argument_list|,
name|mode
argument_list|,
name|size
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Save the arg pointer to the block.  */
name|tem
operator|=
name|copy_to_reg
argument_list|(
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
comment|/* We need the pointer as the caller actually passed them to us, not      as we might have pretended they were passed.  Make sure it's a valid      operand, as emit_move_insn isn't expected to handle a PLUS.  */
name|tem
operator|=
name|force_operand
argument_list|(
name|plus_constant
argument_list|(
name|tem
argument_list|,
name|current_function_pretend_args_size
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|registers
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Save the structure value address unless this is passed as an      "invisible" first argument.  */
if|if
condition|(
name|struct_incoming_value
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|registers
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|struct_incoming_value
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
comment|/* Return the address of the block.  */
return|return
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|registers
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* __builtin_apply_args returns block of memory allocated on    the stack into which is stored the arg pointer, structure    value address, static chain, and all the registers that might    possibly be used in performing a function call.  The code is    moved to the start of the function so the incoming values are    saved.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_apply_args
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Don't do __builtin_apply_args more than once in a function.      Save the result of the first call and reuse it.  */
if|if
condition|(
name|apply_args_value
operator|!=
literal|0
condition|)
return|return
name|apply_args_value
return|;
block|{
comment|/* When this function is called, it means that registers must be        saved on entry to this function.  So we migrate the        call to the first insn of this function.  */
name|rtx
name|temp
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|temp
operator|=
name|expand_builtin_apply_args_1
argument_list|()
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|apply_args_value
operator|=
name|temp
expr_stmt|;
comment|/* Put the insns after the NOTE that starts the function.        If this is inside a start_sequence, make the outer-level insn        chain current, so the code is placed at the start of the        function.  */
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|NEXT_INSN
argument_list|(
name|get_insns
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
end_function

begin_comment
comment|/* Perform an untyped call and save the state required to perform an    untyped return of whatever value was returned by the given function.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_apply
parameter_list|(
name|rtx
name|function
parameter_list|,
name|rtx
name|arguments
parameter_list|,
name|rtx
name|argsize
parameter_list|)
block|{
name|int
name|size
decl_stmt|,
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|incoming_args
decl_stmt|,
name|result
decl_stmt|,
name|reg
decl_stmt|,
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|call_insn
decl_stmt|;
name|rtx
name|old_stack_level
init|=
literal|0
decl_stmt|;
name|rtx
name|call_fusage
init|=
literal|0
decl_stmt|;
name|rtx
name|struct_value
init|=
name|targetm
operator|.
name|calls
operator|.
name|struct_value_rtx
argument_list|(
name|cfun
condition|?
name|TREE_TYPE
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
else|:
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|arguments
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
comment|/* Create a block where the return registers can be saved.  */
name|result
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|apply_result_size
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Fetch the arg pointer from the ARGUMENTS block.  */
name|incoming_args
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|incoming_args
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|arguments
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|STACK_GROWS_DOWNWARD
name|incoming_args
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|MINUS
argument_list|,
name|incoming_args
argument_list|,
name|argsize
argument_list|,
name|incoming_args
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Perform postincrements before actually calling the function.  */
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Push a new argument block and copy the arguments.  Do not allow      the (potential) memcpy call below to interfere with our stack      manipulations.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
comment|/* Save the stack with nonlocal if available.  */
ifdef|#
directive|ifdef
name|HAVE_save_stack_nonlocal
if|if
condition|(
name|HAVE_save_stack_nonlocal
condition|)
name|emit_stack_save
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
operator|&
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|emit_stack_save
argument_list|(
name|SAVE_BLOCK
argument_list|,
operator|&
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Allocate a block of memory onto the stack and copy the memory      arguments to the outgoing arguments address.  */
name|allocate_dynamic_stack_space
argument_list|(
name|argsize
argument_list|,
literal|0
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|dest
operator|=
name|virtual_outgoing_args_rtx
expr_stmt|;
ifndef|#
directive|ifndef
name|STACK_GROWS_DOWNWARD
if|if
condition|(
name|GET_CODE
argument_list|(
name|argsize
argument_list|)
operator|==
name|CONST_INT
condition|)
name|dest
operator|=
name|plus_constant
argument_list|(
name|dest
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|argsize
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dest
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|dest
argument_list|,
name|negate_rtx
argument_list|(
name|Pmode
argument_list|,
name|argsize
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dest
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|dest
argument_list|,
name|PARM_BOUNDARY
argument_list|)
expr_stmt|;
name|src
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|incoming_args
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|src
argument_list|,
name|PARM_BOUNDARY
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|argsize
argument_list|,
name|BLOCK_OP_NORMAL
argument_list|)
expr_stmt|;
comment|/* Refer to the argument block.  */
name|apply_args_size
argument_list|()
expr_stmt|;
name|arguments
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|arguments
argument_list|,
name|PARM_BOUNDARY
argument_list|)
expr_stmt|;
comment|/* Walk past the arg-pointer and structure value address.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_value
condition|)
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Restore each of the registers previously saved.  Make USE insns      for each of these registers for use in making the call.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_args_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|adjust_address
argument_list|(
name|arguments
argument_list|,
name|mode
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the structure value address unless this is passed as an      "invisible" first argument.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_value
condition|)
block|{
name|rtx
name|value
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|value
argument_list|,
name|adjust_address
argument_list|(
name|arguments
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|struct_value
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|struct_value
argument_list|)
operator|==
name|REG
condition|)
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|struct_value
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
comment|/* All arguments and registers used for the call are set up by now!  */
name|function
operator|=
name|prepare_call_address
argument_list|(
name|function
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|call_fusage
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Ensure address is valid.  SYMBOL_REF is already valid, so no need,      and we don't want to load it into a register as an optimization,      because prepare_call_address already did it if it should be done.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|function
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|function
operator|=
name|memory_address
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|function
argument_list|)
expr_stmt|;
comment|/* Generate the actual call instruction and save the return value.  */
ifdef|#
directive|ifdef
name|HAVE_untyped_call
if|if
condition|(
name|HAVE_untyped_call
condition|)
name|emit_call_insn
argument_list|(
name|gen_untyped_call
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|function
argument_list|)
argument_list|,
name|result
argument_list|,
name|result_vector
argument_list|(
literal|1
argument_list|,
name|result
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_call_value
if|if
condition|(
name|HAVE_call_value
condition|)
block|{
name|rtx
name|valreg
init|=
literal|0
decl_stmt|;
comment|/* Locate the unique return register.  It is not possible to 	 express a call that sets more than one return register using 	 call_value; use untyped_call for that.  In fact, untyped_call 	 only needs to save the return registers in the given block.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_result_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|valreg
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* HAVE_untyped_call required.  */
name|valreg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|emit_call_insn
argument_list|(
name|GEN_CALL_VALUE
argument_list|(
name|valreg
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|function
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|NULL_RTX
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|result
argument_list|,
name|GET_MODE
argument_list|(
name|valreg
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|valreg
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
comment|/* Find the CALL insn we just emitted, and attach the register usage      information.  */
name|call_insn
operator|=
name|last_call_insn
argument_list|()
expr_stmt|;
name|add_function_usage_to
argument_list|(
name|call_insn
argument_list|,
name|call_fusage
argument_list|)
expr_stmt|;
comment|/* Restore the stack.  */
ifdef|#
directive|ifdef
name|HAVE_save_stack_nonlocal
if|if
condition|(
name|HAVE_save_stack_nonlocal
condition|)
name|emit_stack_restore
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|emit_stack_restore
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
comment|/* Return the address of the result block.  */
name|result
operator|=
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|result
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform an untyped return.  */
end_comment

begin_function
specifier|static
name|void
name|expand_builtin_return
parameter_list|(
name|rtx
name|result
parameter_list|)
block|{
name|int
name|size
decl_stmt|,
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|call_fusage
init|=
literal|0
decl_stmt|;
name|result
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|apply_result_size
argument_list|()
expr_stmt|;
name|result
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|result
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_untyped_return
if|if
condition|(
name|HAVE_untyped_return
condition|)
block|{
name|emit_jump_insn
argument_list|(
name|gen_untyped_return
argument_list|(
name|result
argument_list|,
name|result_vector
argument_list|(
literal|0
argument_list|,
name|result
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Restore the return value and note that each value is used.  */
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_result_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|INCOMING_REGNO
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|adjust_address
argument_list|(
name|result
argument_list|,
name|mode
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|push_to_sequence
argument_list|(
name|call_fusage
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|call_fusage
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Put the USE insns before the return.  */
name|emit_insn
argument_list|(
name|call_fusage
argument_list|)
expr_stmt|;
comment|/* Return whatever values was restored by jumping directly to the end      of the function.  */
name|expand_naked_return
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used by expand_builtin_classify_type and fold_builtin_classify_type.  */
end_comment

begin_function
specifier|static
name|enum
name|type_class
name|type_to_class
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|VOID_TYPE
case|:
return|return
name|void_type_class
return|;
case|case
name|INTEGER_TYPE
case|:
return|return
name|integer_type_class
return|;
case|case
name|CHAR_TYPE
case|:
return|return
name|char_type_class
return|;
case|case
name|ENUMERAL_TYPE
case|:
return|return
name|enumeral_type_class
return|;
case|case
name|BOOLEAN_TYPE
case|:
return|return
name|boolean_type_class
return|;
case|case
name|POINTER_TYPE
case|:
return|return
name|pointer_type_class
return|;
case|case
name|REFERENCE_TYPE
case|:
return|return
name|reference_type_class
return|;
case|case
name|OFFSET_TYPE
case|:
return|return
name|offset_type_class
return|;
case|case
name|REAL_TYPE
case|:
return|return
name|real_type_class
return|;
case|case
name|COMPLEX_TYPE
case|:
return|return
name|complex_type_class
return|;
case|case
name|FUNCTION_TYPE
case|:
return|return
name|function_type_class
return|;
case|case
name|METHOD_TYPE
case|:
return|return
name|method_type_class
return|;
case|case
name|RECORD_TYPE
case|:
return|return
name|record_type_class
return|;
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
return|return
name|union_type_class
return|;
case|case
name|ARRAY_TYPE
case|:
return|return
operator|(
name|TYPE_STRING_FLAG
argument_list|(
name|type
argument_list|)
condition|?
name|string_type_class
else|:
name|array_type_class
operator|)
return|;
case|case
name|SET_TYPE
case|:
return|return
name|set_type_class
return|;
case|case
name|FILE_TYPE
case|:
return|return
name|file_type_class
return|;
case|case
name|LANG_TYPE
case|:
return|return
name|lang_type_class
return|;
default|default:
return|return
name|no_type_class
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to __builtin_classify_type with arguments found in    ARGLIST.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_classify_type
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
if|if
condition|(
name|arglist
operator|!=
literal|0
condition|)
return|return
name|GEN_INT
argument_list|(
name|type_to_class
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|GEN_INT
argument_list|(
name|no_type_class
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to __builtin_constant_p.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_constant_p
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|enum
name|machine_mode
name|target_mode
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
name|arglist
operator|==
literal|0
condition|)
return|return
name|const0_rtx
return|;
name|arglist
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* We have taken care of the easy cases during constant folding.  This      case is not obvious, so emit (constant_p_rtx (ARGLIST)) and let CSE      get a chance to see if it can deduce whether ARGLIST is constant.      If CSE isn't going to run, of course, don't bother waiting.  */
if|if
condition|(
name|cse_not_expected
condition|)
return|return
name|const0_rtx
return|;
name|current_function_calls_constant_p
operator|=
literal|1
expr_stmt|;
name|tmp
operator|=
name|expand_expr
argument_list|(
name|arglist
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_CONSTANT_P_RTX
argument_list|(
name|target_mode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* This helper macro, meant to be used in mathfn_built_in below,    determines which among a set of three builtin math functions is    appropriate for a given type mode.  The `F' and `L' cases are    automatically generated from the `double' case.  */
end_comment

begin_define
define|#
directive|define
name|CASE_MATHFN
parameter_list|(
name|BUILT_IN_MATHFN
parameter_list|)
define|\
value|case BUILT_IN_MATHFN: case BUILT_IN_MATHFN##F: case BUILT_IN_MATHFN##L: \   fcode = BUILT_IN_MATHFN; fcodef = BUILT_IN_MATHFN##F ; \   fcodel = BUILT_IN_MATHFN##L ; break;
end_define

begin_comment
comment|/* Return mathematic function equivalent to FN but operating directly    on TYPE, if available.  If we can't do the conversion, return zero.  */
end_comment

begin_function
name|tree
name|mathfn_built_in
parameter_list|(
name|tree
name|type
parameter_list|,
name|enum
name|built_in_function
name|fn
parameter_list|)
block|{
specifier|const
name|enum
name|machine_mode
name|type_mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|built_in_function
name|fcode
decl_stmt|,
name|fcodef
decl_stmt|,
name|fcodel
decl_stmt|;
switch|switch
condition|(
name|fn
condition|)
block|{
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ACOS
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ACOSH
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ASIN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ASINH
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ATAN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ATAN2
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ATANH
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_CBRT
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_CEIL
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_COPYSIGN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_COS
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_COSH
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_DREM
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ERF
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ERFC
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_EXP
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_EXP10
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_EXP2
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_EXPM1
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_FABS
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_FDIM
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_FLOOR
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_FMA
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_FMAX
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_FMIN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_FMOD
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_FREXP
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_GAMMA
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_HUGE_VAL
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_HYPOT
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ILOGB
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_INF
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_J0
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_J1
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_JN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LDEXP
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LGAMMA
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LLRINT
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LLROUND
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LOG
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LOG10
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LOG1P
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LOG2
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LOGB
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LRINT
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_LROUND
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_MODF
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_NAN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_NANS
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_NEARBYINT
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_NEXTAFTER
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_NEXTTOWARD
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_POW
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_POW10
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_REMAINDER
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_REMQUO
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_RINT
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_ROUND
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_SCALB
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_SCALBLN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_SCALBN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_SIGNIFICAND
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_SIN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_SINCOS
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_SINH
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_SQRT
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_TAN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_TANH
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_TGAMMA
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_TRUNC
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_Y0
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_Y1
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|BUILT_IN_YN
argument_list|)
default|default:
return|return
literal|0
return|;
block|}
if|if
condition|(
name|type_mode
operator|==
name|TYPE_MODE
argument_list|(
name|double_type_node
argument_list|)
condition|)
return|return
name|implicit_built_in_decls
index|[
name|fcode
index|]
return|;
elseif|else
if|if
condition|(
name|type_mode
operator|==
name|TYPE_MODE
argument_list|(
name|float_type_node
argument_list|)
condition|)
return|return
name|implicit_built_in_decls
index|[
name|fcodef
index|]
return|;
elseif|else
if|if
condition|(
name|type_mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_double_type_node
argument_list|)
condition|)
return|return
name|implicit_built_in_decls
index|[
name|fcodel
index|]
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If errno must be maintained, expand the RTL to check if the result,    TARGET, of a built-in function call, EXP, is NaN, and if so set    errno to EDOM.  */
end_comment

begin_function
specifier|static
name|void
name|expand_errno_check
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|lab
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
comment|/* Test the result; if it is NaN, set errno=EDOM because      the argument was not in the domain.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|target
argument_list|,
name|target
argument_list|,
name|EQ
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|,
name|lab
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_EDOM
comment|/* If this built-in doesn't throw an exception, set errno directly.  */
if|if
condition|(
name|TREE_NOTHROW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|GEN_ERRNO_RTX
name|rtx
name|errno_rtx
init|=
name|GEN_ERRNO_RTX
decl_stmt|;
else|#
directive|else
name|rtx
name|errno_rtx
init|=
name|gen_rtx_MEM
argument_list|(
name|word_mode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"errno"
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|errno_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|TARGET_EDOM
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|lab
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* We can't set errno=EDOM directly; let the library call do it.      Pop the arguments right away in case the call gets deleted.  */
name|NO_DEFER_POP
expr_stmt|;
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
name|emit_label
argument_list|(
name|lab
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand a call to one of the builtin math functions (sin, cos, or sqrt).    Return 0 if a normal call should be emitted rather than expanding the    function in-line.  EXP is the expression that is a call to the builtin    function; if convenient, the result should be placed in TARGET.    SUBTARGET may be used as the target for computing one of EXP's operands.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_mathfn
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
parameter_list|)
block|{
name|optab
name|builtin_optab
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|insns
decl_stmt|,
name|before_call
decl_stmt|;
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|bool
name|errno_set
init|=
name|false
decl_stmt|;
name|tree
name|arg
decl_stmt|,
name|narg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_SIN
case|:
case|case
name|BUILT_IN_SINF
case|:
case|case
name|BUILT_IN_SINL
case|:
name|builtin_optab
operator|=
name|sin_optab
expr_stmt|;
break|break;
case|case
name|BUILT_IN_COS
case|:
case|case
name|BUILT_IN_COSF
case|:
case|case
name|BUILT_IN_COSL
case|:
name|builtin_optab
operator|=
name|cos_optab
expr_stmt|;
break|break;
case|case
name|BUILT_IN_SQRT
case|:
case|case
name|BUILT_IN_SQRTF
case|:
case|case
name|BUILT_IN_SQRTL
case|:
name|errno_set
operator|=
operator|!
name|tree_expr_nonnegative_p
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|builtin_optab
operator|=
name|sqrt_optab
expr_stmt|;
break|break;
case|case
name|BUILT_IN_EXP
case|:
case|case
name|BUILT_IN_EXPF
case|:
case|case
name|BUILT_IN_EXPL
case|:
name|errno_set
operator|=
name|true
expr_stmt|;
name|builtin_optab
operator|=
name|exp_optab
expr_stmt|;
break|break;
case|case
name|BUILT_IN_LOG
case|:
case|case
name|BUILT_IN_LOGF
case|:
case|case
name|BUILT_IN_LOGL
case|:
name|errno_set
operator|=
name|true
expr_stmt|;
name|builtin_optab
operator|=
name|log_optab
expr_stmt|;
break|break;
case|case
name|BUILT_IN_TAN
case|:
case|case
name|BUILT_IN_TANF
case|:
case|case
name|BUILT_IN_TANL
case|:
name|builtin_optab
operator|=
name|tan_optab
expr_stmt|;
break|break;
case|case
name|BUILT_IN_ATAN
case|:
case|case
name|BUILT_IN_ATANF
case|:
case|case
name|BUILT_IN_ATANL
case|:
name|builtin_optab
operator|=
name|atan_optab
expr_stmt|;
break|break;
case|case
name|BUILT_IN_FLOOR
case|:
case|case
name|BUILT_IN_FLOORF
case|:
case|case
name|BUILT_IN_FLOORL
case|:
name|builtin_optab
operator|=
name|floor_optab
expr_stmt|;
break|break;
case|case
name|BUILT_IN_CEIL
case|:
case|case
name|BUILT_IN_CEILF
case|:
case|case
name|BUILT_IN_CEILL
case|:
name|builtin_optab
operator|=
name|ceil_optab
expr_stmt|;
break|break;
case|case
name|BUILT_IN_TRUNC
case|:
case|case
name|BUILT_IN_TRUNCF
case|:
case|case
name|BUILT_IN_TRUNCL
case|:
name|builtin_optab
operator|=
name|btrunc_optab
expr_stmt|;
break|break;
case|case
name|BUILT_IN_ROUND
case|:
case|case
name|BUILT_IN_ROUNDF
case|:
case|case
name|BUILT_IN_ROUNDL
case|:
name|builtin_optab
operator|=
name|round_optab
expr_stmt|;
break|break;
case|case
name|BUILT_IN_NEARBYINT
case|:
case|case
name|BUILT_IN_NEARBYINTF
case|:
case|case
name|BUILT_IN_NEARBYINTL
case|:
name|builtin_optab
operator|=
name|nearbyint_optab
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Make a suitable register to place result in.  */
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_errno_math
operator|||
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
condition|)
name|errno_set
operator|=
name|false
expr_stmt|;
comment|/* Before working hard, check whether the instruction is available.  */
if|if
condition|(
name|builtin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Wrap the computation of the argument in a SAVE_EXPR, as we may 	 need to expand the argument again.  This way, we will not perform 	 side-effects more the once.  */
name|narg
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|narg
operator|!=
name|arg
condition|)
block|{
name|arg
operator|=
name|narg
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Compute into TARGET. 	 Set TARGET to wherever the result comes back.  */
name|target
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|builtin_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno_set
condition|)
name|expand_errno_check
argument_list|(
name|exp
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* Output the entire sequence.  */
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|insns
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* If we were unable to expand via the builtin, stop the sequence 	 (without outputting the insns) and call to the library function 	 with the stabilized argument list.  */
name|end_sequence
argument_list|()
expr_stmt|;
block|}
name|before_call
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|target
operator|=
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|target
operator|==
name|const0_rtx
argument_list|)
expr_stmt|;
comment|/* If this is a sqrt operation and we don't care about errno, try to      attach a REG_EQUAL note with a SQRT rtx to the emitted libcall.      This allows the semantics of the libcall to be visible to the RTL      optimizers.  */
if|if
condition|(
name|builtin_optab
operator|==
name|sqrt_optab
operator|&&
operator|!
name|errno_set
condition|)
block|{
comment|/* Search backwards through the insns emitted by expand_call looking 	 for the instruction with the REG_RETVAL note.  */
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
while|while
condition|(
name|last
operator|!=
name|before_call
condition|)
block|{
if|if
condition|(
name|find_reg_note
argument_list|(
name|last
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|last
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
comment|/* Check that the REQ_EQUAL note is an EXPR_LIST with 		 two elements, i.e. symbol_ref(sqrt) and the operand.  */
if|if
condition|(
name|note
operator|&&
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|==
name|EXPR_LIST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EXPR_LIST
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|NULL_RTX
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|NULL_RTX
condition|)
block|{
name|rtx
name|operand
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Check operand is a register with expected mode.  */
if|if
condition|(
name|operand
operator|&&
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|operand
argument_list|)
operator|==
name|mode
condition|)
block|{
comment|/* Replace the REG_EQUAL note with a SQRT rtx.  */
name|rtx
name|equiv
init|=
name|gen_rtx_SQRT
argument_list|(
name|mode
argument_list|,
name|operand
argument_list|)
decl_stmt|;
name|set_unique_reg_note
argument_list|(
name|last
argument_list|,
name|REG_EQUAL
argument_list|,
name|equiv
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
name|last
operator|=
name|PREV_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to the builtin binary math functions (pow and atan2).    Return 0 if a normal call should be emitted rather than expanding the    function in-line.  EXP is the expression that is a call to the builtin    function; if convenient, the result should be placed in TARGET.    SUBTARGET may be used as the target for computing one of EXP's    operands.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_mathfn_2
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
parameter_list|)
block|{
name|optab
name|builtin_optab
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|insns
decl_stmt|;
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|temp
decl_stmt|,
name|narg
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|bool
name|errno_set
init|=
name|true
decl_stmt|;
name|bool
name|stable
init|=
name|true
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_POW
case|:
case|case
name|BUILT_IN_POWF
case|:
case|case
name|BUILT_IN_POWL
case|:
name|builtin_optab
operator|=
name|pow_optab
expr_stmt|;
break|break;
case|case
name|BUILT_IN_ATAN2
case|:
case|case
name|BUILT_IN_ATAN2F
case|:
case|case
name|BUILT_IN_ATAN2L
case|:
name|builtin_optab
operator|=
name|atan2_optab
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Make a suitable register to place result in.  */
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Before working hard, check whether the instruction is available.  */
if|if
condition|(
name|builtin_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|==
name|CODE_FOR_nothing
condition|)
return|return
literal|0
return|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_errno_math
operator|||
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
condition|)
name|errno_set
operator|=
name|false
expr_stmt|;
comment|/* Alway stabilize the argument list.  */
name|narg
operator|=
name|save_expr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|narg
operator|!=
name|arg1
condition|)
block|{
name|arg1
operator|=
name|narg
expr_stmt|;
name|temp
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|narg
argument_list|)
expr_stmt|;
name|stable
operator|=
name|false
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|narg
operator|=
name|save_expr
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|narg
operator|!=
name|arg0
condition|)
block|{
name|arg0
operator|=
name|narg
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|narg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|stable
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|stable
condition|)
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg0
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stable
condition|)
name|exp
operator|=
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Compute into TARGET.      Set TARGET to wherever the result comes back.  */
name|target
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|builtin_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
comment|/* If we were unable to expand via the builtin, stop the sequence      (without outputting the insns) and call to the library function      with the stabilized argument list.  */
if|if
condition|(
name|target
operator|==
literal|0
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|target
operator|==
name|const0_rtx
argument_list|)
return|;
block|}
if|if
condition|(
name|errno_set
condition|)
name|expand_errno_check
argument_list|(
name|exp
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* Output the entire sequence.  */
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|insns
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* To evaluate powi(x,n), the floating point value x raised to the    constant integer exponent n, we use a hybrid algorithm that    combines the "window method" with look-up tables.  For an    introduction to exponentiation algorithms and "addition chains",    see section 4.6.3, "Evaluation of Powers" of Donald E. Knuth,    "Seminumerical Algorithms", Vol. 2, "The Art of Computer Programming",    3rd Edition, 1998, and Daniel M. Gordon, "A Survey of Fast Exponentiation    Methods", Journal of Algorithms, Vol. 27, pp. 129-146, 1998.  */
end_comment

begin_comment
comment|/* Provide a default value for POWI_MAX_MULTS, the maximum number of    multiplications to inline before calling the system library's pow    function.  powi(x,n) requires at worst 2*bits(n)-2 multiplications,    so this default never requires calling pow, powf or powl.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|POWI_MAX_MULTS
end_ifndef

begin_define
define|#
directive|define
name|POWI_MAX_MULTS
value|(2*HOST_BITS_PER_WIDE_INT-2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The size of the "optimal power tree" lookup table.  All    exponents less than this value are simply looked up in the    powi_table below.  This threshold is also used to size the    cache of pseudo registers that hold intermediate results.  */
end_comment

begin_define
define|#
directive|define
name|POWI_TABLE_SIZE
value|256
end_define

begin_comment
comment|/* The size, in bits of the window, used in the "window method"    exponentiation algorithm.  This is equivalent to a radix of    (1<<POWI_WINDOW_SIZE) in the corresponding "m-ary method".  */
end_comment

begin_define
define|#
directive|define
name|POWI_WINDOW_SIZE
value|3
end_define

begin_comment
comment|/* The following table is an efficient representation of an    "optimal power tree".  For each value, i, the corresponding    value, j, in the table states than an optimal evaluation    sequence for calculating pow(x,i) can be found by evaluating    pow(x,j)*pow(x,i-j).  An optimal power tree for the first    100 integers is given in Knuth's "Seminumerical algorithms".  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|powi_table
index|[
name|POWI_TABLE_SIZE
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
comment|/*   0 -   7 */
literal|4
block|,
literal|6
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|10
block|,
literal|7
block|,
literal|9
block|,
comment|/*   8 -  15 */
literal|8
block|,
literal|16
block|,
literal|9
block|,
literal|16
block|,
literal|10
block|,
literal|12
block|,
literal|11
block|,
literal|13
block|,
comment|/*  16 -  23 */
literal|12
block|,
literal|17
block|,
literal|13
block|,
literal|18
block|,
literal|14
block|,
literal|24
block|,
literal|15
block|,
literal|26
block|,
comment|/*  24 -  31 */
literal|16
block|,
literal|17
block|,
literal|17
block|,
literal|19
block|,
literal|18
block|,
literal|33
block|,
literal|19
block|,
literal|26
block|,
comment|/*  32 -  39 */
literal|20
block|,
literal|25
block|,
literal|21
block|,
literal|40
block|,
literal|22
block|,
literal|27
block|,
literal|23
block|,
literal|44
block|,
comment|/*  40 -  47 */
literal|24
block|,
literal|32
block|,
literal|25
block|,
literal|34
block|,
literal|26
block|,
literal|29
block|,
literal|27
block|,
literal|44
block|,
comment|/*  48 -  55 */
literal|28
block|,
literal|31
block|,
literal|29
block|,
literal|34
block|,
literal|30
block|,
literal|60
block|,
literal|31
block|,
literal|36
block|,
comment|/*  56 -  63 */
literal|32
block|,
literal|64
block|,
literal|33
block|,
literal|34
block|,
literal|34
block|,
literal|46
block|,
literal|35
block|,
literal|37
block|,
comment|/*  64 -  71 */
literal|36
block|,
literal|65
block|,
literal|37
block|,
literal|50
block|,
literal|38
block|,
literal|48
block|,
literal|39
block|,
literal|69
block|,
comment|/*  72 -  79 */
literal|40
block|,
literal|49
block|,
literal|41
block|,
literal|43
block|,
literal|42
block|,
literal|51
block|,
literal|43
block|,
literal|58
block|,
comment|/*  80 -  87 */
literal|44
block|,
literal|64
block|,
literal|45
block|,
literal|47
block|,
literal|46
block|,
literal|59
block|,
literal|47
block|,
literal|76
block|,
comment|/*  88 -  95 */
literal|48
block|,
literal|65
block|,
literal|49
block|,
literal|66
block|,
literal|50
block|,
literal|67
block|,
literal|51
block|,
literal|66
block|,
comment|/*  96 - 103 */
literal|52
block|,
literal|70
block|,
literal|53
block|,
literal|74
block|,
literal|54
block|,
literal|104
block|,
literal|55
block|,
literal|74
block|,
comment|/* 104 - 111 */
literal|56
block|,
literal|64
block|,
literal|57
block|,
literal|69
block|,
literal|58
block|,
literal|78
block|,
literal|59
block|,
literal|68
block|,
comment|/* 112 - 119 */
literal|60
block|,
literal|61
block|,
literal|61
block|,
literal|80
block|,
literal|62
block|,
literal|75
block|,
literal|63
block|,
literal|68
block|,
comment|/* 120 - 127 */
literal|64
block|,
literal|65
block|,
literal|65
block|,
literal|128
block|,
literal|66
block|,
literal|129
block|,
literal|67
block|,
literal|90
block|,
comment|/* 128 - 135 */
literal|68
block|,
literal|73
block|,
literal|69
block|,
literal|131
block|,
literal|70
block|,
literal|94
block|,
literal|71
block|,
literal|88
block|,
comment|/* 136 - 143 */
literal|72
block|,
literal|128
block|,
literal|73
block|,
literal|98
block|,
literal|74
block|,
literal|132
block|,
literal|75
block|,
literal|121
block|,
comment|/* 144 - 151 */
literal|76
block|,
literal|102
block|,
literal|77
block|,
literal|124
block|,
literal|78
block|,
literal|132
block|,
literal|79
block|,
literal|106
block|,
comment|/* 152 - 159 */
literal|80
block|,
literal|97
block|,
literal|81
block|,
literal|160
block|,
literal|82
block|,
literal|99
block|,
literal|83
block|,
literal|134
block|,
comment|/* 160 - 167 */
literal|84
block|,
literal|86
block|,
literal|85
block|,
literal|95
block|,
literal|86
block|,
literal|160
block|,
literal|87
block|,
literal|100
block|,
comment|/* 168 - 175 */
literal|88
block|,
literal|113
block|,
literal|89
block|,
literal|98
block|,
literal|90
block|,
literal|107
block|,
literal|91
block|,
literal|122
block|,
comment|/* 176 - 183 */
literal|92
block|,
literal|111
block|,
literal|93
block|,
literal|102
block|,
literal|94
block|,
literal|126
block|,
literal|95
block|,
literal|150
block|,
comment|/* 184 - 191 */
literal|96
block|,
literal|128
block|,
literal|97
block|,
literal|130
block|,
literal|98
block|,
literal|133
block|,
literal|99
block|,
literal|195
block|,
comment|/* 192 - 199 */
literal|100
block|,
literal|128
block|,
literal|101
block|,
literal|123
block|,
literal|102
block|,
literal|164
block|,
literal|103
block|,
literal|138
block|,
comment|/* 200 - 207 */
literal|104
block|,
literal|145
block|,
literal|105
block|,
literal|146
block|,
literal|106
block|,
literal|109
block|,
literal|107
block|,
literal|149
block|,
comment|/* 208 - 215 */
literal|108
block|,
literal|200
block|,
literal|109
block|,
literal|146
block|,
literal|110
block|,
literal|170
block|,
literal|111
block|,
literal|157
block|,
comment|/* 216 - 223 */
literal|112
block|,
literal|128
block|,
literal|113
block|,
literal|130
block|,
literal|114
block|,
literal|182
block|,
literal|115
block|,
literal|132
block|,
comment|/* 224 - 231 */
literal|116
block|,
literal|200
block|,
literal|117
block|,
literal|132
block|,
literal|118
block|,
literal|158
block|,
literal|119
block|,
literal|206
block|,
comment|/* 232 - 239 */
literal|120
block|,
literal|240
block|,
literal|121
block|,
literal|162
block|,
literal|122
block|,
literal|147
block|,
literal|123
block|,
literal|152
block|,
comment|/* 240 - 247 */
literal|124
block|,
literal|166
block|,
literal|125
block|,
literal|214
block|,
literal|126
block|,
literal|138
block|,
literal|127
block|,
literal|153
block|,
comment|/* 248 - 255 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the number of multiplications required to calculate    powi(x,n) where n is less than POWI_TABLE_SIZE.  This is a    subroutine of powi_cost.  CACHE is an array indicating    which exponents have already been calculated.  */
end_comment

begin_function
specifier|static
name|int
name|powi_lookup_cost
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|n
parameter_list|,
name|bool
modifier|*
name|cache
parameter_list|)
block|{
comment|/* If we've already calculated this exponent, then this evaluation      doesn't require any additional multiplications.  */
if|if
condition|(
name|cache
index|[
name|n
index|]
condition|)
return|return
literal|0
return|;
name|cache
index|[
name|n
index|]
operator|=
name|true
expr_stmt|;
return|return
name|powi_lookup_cost
argument_list|(
name|n
operator|-
name|powi_table
index|[
name|n
index|]
argument_list|,
name|cache
argument_list|)
operator|+
name|powi_lookup_cost
argument_list|(
name|powi_table
index|[
name|n
index|]
argument_list|,
name|cache
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the number of multiplications required to calculate    powi(x,n) for an arbitrary x, given the exponent N.  This    function needs to be kept in sync with expand_powi below.  */
end_comment

begin_function
specifier|static
name|int
name|powi_cost
parameter_list|(
name|HOST_WIDE_INT
name|n
parameter_list|)
block|{
name|bool
name|cache
index|[
name|POWI_TABLE_SIZE
index|]
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|digit
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Ignore the reciprocal when calculating the cost.  */
name|val
operator|=
operator|(
name|n
operator|<
literal|0
operator|)
condition|?
operator|-
name|n
else|:
name|n
expr_stmt|;
comment|/* Initialize the exponent cache.  */
name|memset
argument_list|(
name|cache
argument_list|,
literal|0
argument_list|,
name|POWI_TABLE_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
argument_list|)
expr_stmt|;
name|cache
index|[
literal|1
index|]
operator|=
name|true
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|val
operator|>=
name|POWI_TABLE_SIZE
condition|)
block|{
if|if
condition|(
name|val
operator|&
literal|1
condition|)
block|{
name|digit
operator|=
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|POWI_WINDOW_SIZE
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|result
operator|+=
name|powi_lookup_cost
argument_list|(
name|digit
argument_list|,
name|cache
argument_list|)
operator|+
name|POWI_WINDOW_SIZE
operator|+
literal|1
expr_stmt|;
name|val
operator|>>=
name|POWI_WINDOW_SIZE
expr_stmt|;
block|}
else|else
block|{
name|val
operator|>>=
literal|1
expr_stmt|;
name|result
operator|++
expr_stmt|;
block|}
block|}
return|return
name|result
operator|+
name|powi_lookup_cost
argument_list|(
name|val
argument_list|,
name|cache
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Recursive subroutine of expand_powi.  This function takes the array,    CACHE, of already calculated exponents and an exponent N and returns    an RTX that corresponds to CACHE[1]**N, as calculated in mode MODE.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_powi_1
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|n
parameter_list|,
name|rtx
modifier|*
name|cache
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|digit
decl_stmt|;
name|rtx
name|target
decl_stmt|,
name|result
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
if|if
condition|(
name|n
operator|<
name|POWI_TABLE_SIZE
condition|)
block|{
if|if
condition|(
name|cache
index|[
name|n
index|]
condition|)
return|return
name|cache
index|[
name|n
index|]
return|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|cache
index|[
name|n
index|]
operator|=
name|target
expr_stmt|;
name|op0
operator|=
name|expand_powi_1
argument_list|(
name|mode
argument_list|,
name|n
operator|-
name|powi_table
index|[
name|n
index|]
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_powi_1
argument_list|(
name|mode
argument_list|,
name|powi_table
index|[
name|n
index|]
argument_list|,
name|cache
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|&
literal|1
condition|)
block|{
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|digit
operator|=
name|n
operator|&
operator|(
operator|(
literal|1
operator|<<
name|POWI_WINDOW_SIZE
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|op0
operator|=
name|expand_powi_1
argument_list|(
name|mode
argument_list|,
name|n
operator|-
name|digit
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_powi_1
argument_list|(
name|mode
argument_list|,
name|digit
argument_list|,
name|cache
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_powi_1
argument_list|(
name|mode
argument_list|,
name|n
operator|>>
literal|1
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
block|}
name|result
operator|=
name|expand_mult
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand the RTL to evaluate powi(x,n) in mode MODE.  X is the    floating point operand in mode MODE, and N is the exponent.  This    function needs to be kept in sync with powi_cost above.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_powi
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|HOST_WIDE_INT
name|n
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|rtx
name|cache
index|[
name|POWI_TABLE_SIZE
index|]
decl_stmt|;
name|rtx
name|result
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
return|;
name|val
operator|=
operator|(
name|n
operator|<
literal|0
operator|)
condition|?
operator|-
name|n
else|:
name|n
expr_stmt|;
name|memset
argument_list|(
name|cache
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cache
argument_list|)
argument_list|)
expr_stmt|;
name|cache
index|[
literal|1
index|]
operator|=
name|x
expr_stmt|;
name|result
operator|=
name|expand_powi_1
argument_list|(
name|mode
argument_list|,
operator|(
name|n
operator|<
literal|0
operator|)
condition|?
operator|-
name|n
else|:
name|n
argument_list|,
name|cache
argument_list|)
expr_stmt|;
comment|/* If the original exponent was negative, reciprocate the result.  */
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|result
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|sdiv_optab
argument_list|,
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
argument_list|,
name|result
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to the pow built-in mathematical function.  Return 0 if    a normal call should be emitted rather than expanding the function    in-line.  EXP is the expression that is a call to the builtin    function; if convenient, the result should be placed in TARGET.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_pow
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|cint
decl_stmt|;
name|REAL_VALUE_TYPE
name|c
decl_stmt|;
name|HOST_WIDE_INT
name|n
decl_stmt|;
name|c
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|n
operator|=
name|real_to_integer
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|real_from_integer
argument_list|(
operator|&
name|cint
argument_list|,
name|VOIDmode
argument_list|,
name|n
argument_list|,
name|n
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_identical
argument_list|(
operator|&
name|c
argument_list|,
operator|&
name|cint
argument_list|)
condition|)
block|{
comment|/* If the exponent is -1, 0, 1 or 2, then expand_powi is exact. 	     Otherwise, check the number of multiplications required. 	     Note that pow never sets errno for an integer exponent.  */
if|if
condition|(
operator|(
name|n
operator|>=
operator|-
literal|1
operator|&&
name|n
operator|<=
literal|2
operator|)
operator|||
operator|(
name|flag_unsafe_math_optimizations
operator|&&
operator|!
name|optimize_size
operator|&&
name|powi_cost
argument_list|(
name|n
argument_list|)
operator|<=
name|POWI_MAX_MULTS
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|op
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
name|expand_powi
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|n
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|expand_builtin_mathfn_2
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|NULL_RTX
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP which is a call to the strlen builtin.  Return 0    if we failed the caller should emit a normal call, otherwise    try to get the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strlen
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|target_mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|len
decl_stmt|,
name|src
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|result
decl_stmt|,
name|src_reg
decl_stmt|,
name|char_rtx
decl_stmt|,
name|before_strlen
decl_stmt|;
name|enum
name|machine_mode
name|insn_mode
init|=
name|target_mode
decl_stmt|,
name|char_mode
decl_stmt|;
name|enum
name|insn_code
name|icode
init|=
name|CODE_FOR_nothing
decl_stmt|;
name|int
name|align
decl_stmt|;
comment|/* If the length can be computed at compile-time, return it.  */
name|len
operator|=
name|c_strlen
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
return|return
name|expand_expr
argument_list|(
name|len
argument_list|,
name|target
argument_list|,
name|target_mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
comment|/* If the length can be computed at compile-time and is constant 	 integer, but there are side-effects in src, evaluate 	 src for side-effects, then return len. 	 E.g. x = strlen (i++ ? "xfoo" + 1 : "bar"); 	 can be optimized into: i++; x = 3;  */
name|len
operator|=
name|c_strlen
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|TREE_CODE
argument_list|(
name|len
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|expand_expr
argument_list|(
name|src
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|len
argument_list|,
name|target
argument_list|,
name|target_mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
name|align
operator|=
name|get_pointer_alignment
argument_list|(
name|src
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* If SRC is not a pointer type, don't do this operation inline.  */
if|if
condition|(
name|align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Bail out if we can't compute strlen in the right mode.  */
while|while
condition|(
name|insn_mode
operator|!=
name|VOIDmode
condition|)
block|{
name|icode
operator|=
name|strlen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|insn_mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
break|break;
name|insn_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn_mode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
comment|/* Make a place to write the result of the instruction.  */
name|result
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|result
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|insn_mode
operator|&&
name|REGNO
argument_list|(
name|result
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
comment|/* Make a place to hold the source address.  We will not expand 	 the actual source until we are sure that the expansion will 	 not fail -- there are trees that cannot be expanded twice.  */
name|src_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Mark the beginning of the strlen sequence so we can emit the 	 source operand later.  */
name|before_strlen
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|char_rtx
operator|=
name|const0_rtx
expr_stmt|;
name|char_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|char_rtx
operator|,
name|char_mode
operator|)
condition|)
name|char_rtx
operator|=
name|copy_to_mode_reg
argument_list|(
name|char_mode
argument_list|,
name|char_rtx
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|result
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|src_reg
argument_list|)
argument_list|,
name|char_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|align
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* Now that we are assured of success, expand the source.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|pat
operator|=
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|expand_expr
argument_list|(
name|src
argument_list|,
name|src_reg
argument_list|,
name|ptr_mode
argument_list|,
name|EXPAND_SUM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
operator|!=
name|src_reg
condition|)
name|emit_move_insn
argument_list|(
name|src_reg
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|pat
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|before_strlen
condition|)
name|emit_insn_after
argument_list|(
name|pat
argument_list|,
name|before_strlen
argument_list|)
expr_stmt|;
else|else
name|emit_insn_before
argument_list|(
name|pat
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Return the value in the proper mode for this function.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|target_mode
condition|)
name|target
operator|=
name|result
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|!=
literal|0
condition|)
name|convert_move
argument_list|(
name|target
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|target
operator|=
name|convert_to_mode
argument_list|(
name|target_mode
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to the strstr builtin.  Return 0 if we failed the    caller should emit a normal call, otherwise try to get the result    in TARGET, if convenient (and in mode MODE if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strstr
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|s1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|s2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|p2
operator|=
name|c_getstr
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|p1
operator|=
name|c_getstr
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|r
init|=
name|strstr
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|const0_rtx
return|;
comment|/* Return an offset into the constant string argument.  */
return|return
name|expand_expr
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|s1
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|ssize_int
argument_list|(
name|r
operator|-
name|p1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
if|if
condition|(
name|p2
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|expand_expr
argument_list|(
name|s1
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
if|if
condition|(
name|p2
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRCHR
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
comment|/* New argument list transforming strstr(s1, s2) to 	 strchr(s1, s2[0]).  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|p2
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|s1
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to the strchr builtin.  Return 0 if we failed the    caller should emit a normal call, otherwise try to get the result    in TARGET, if convenient (and in mode MODE if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strchr
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|s1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|s2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|s2
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
name|p1
operator|=
name|c_getstr
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
block|{
name|char
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|target_char_cast
argument_list|(
name|s2
argument_list|,
operator|&
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
name|r
operator|=
name|strchr
argument_list|(
name|p1
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|const0_rtx
return|;
comment|/* Return an offset into the constant string argument.  */
return|return
name|expand_expr
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|s1
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|ssize_int
argument_list|(
name|r
operator|-
name|p1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* FIXME: Should use here strchrM optab so that ports can optimize 	 this.  */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to the strrchr builtin.  Return 0 if we failed the    caller should emit a normal call, otherwise try to get the result    in TARGET, if convenient (and in mode MODE if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strrchr
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|s1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|s2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|s2
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
name|p1
operator|=
name|c_getstr
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
block|{
name|char
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|target_char_cast
argument_list|(
name|s2
argument_list|,
operator|&
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
name|r
operator|=
name|strrchr
argument_list|(
name|p1
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|const0_rtx
return|;
comment|/* Return an offset into the constant string argument.  */
return|return
name|expand_expr
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|s1
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|ssize_int
argument_list|(
name|r
operator|-
name|p1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|s2
argument_list|)
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRCHR
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
comment|/* Transform strrchr(s1, '\0') to strchr(s1, '\0').  */
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to the strpbrk builtin.  Return 0 if we failed the    caller should emit a normal call, otherwise try to get the result    in TARGET, if convenient (and in mode MODE if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strpbrk
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|s1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|s2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|p2
operator|=
name|c_getstr
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|p1
operator|=
name|c_getstr
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|r
init|=
name|strpbrk
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|const0_rtx
return|;
comment|/* Return an offset into the constant string argument.  */
return|return
name|expand_expr
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|s1
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|s1
argument_list|)
argument_list|,
name|ssize_int
argument_list|(
name|r
operator|-
name|p1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
if|if
condition|(
name|p2
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* strpbrk(x, "") == NULL. 	     Evaluate and ignore the arguments in case they had 	     side-effects.  */
name|expand_expr
argument_list|(
name|s1
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|p2
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
literal|0
return|;
comment|/* Really call strpbrk.  */
name|fn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRCHR
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
comment|/* New argument list transforming strpbrk(s1, s2) to 	 strchr(s1, s2[0]).  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|p2
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|s1
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)    bytes from constant string DATA + OFFSET and return it as target    constant.  */
end_comment

begin_function
specifier|static
name|rtx
name|builtin_memcpy_read_str
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|offset
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Attempt to read past the end of constant string.  */
return|return
name|c_readstr
argument_list|(
name|str
operator|+
name|offset
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to the memcpy builtin, with arguments in ARGLIST.    Return 0 if we failed, the caller should emit a normal call,    otherwise try to get the result in TARGET, if convenient (and in    mode MODE if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_memcpy
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|dest
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|src
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_str
decl_stmt|;
name|unsigned
name|int
name|src_align
init|=
name|get_pointer_alignment
argument_list|(
name|src
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dest_align
init|=
name|get_pointer_alignment
argument_list|(
name|dest
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
name|rtx
name|dest_mem
decl_stmt|,
name|src_mem
decl_stmt|,
name|dest_addr
decl_stmt|,
name|len_rtx
decl_stmt|;
comment|/* If DEST is not a pointer type, call the normal function.  */
if|if
condition|(
name|dest_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If the LEN parameter is zero, return DEST.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
condition|)
block|{
comment|/* Evaluate and ignore SRC in case it has side-effects.  */
name|expand_expr
argument_list|(
name|src
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|dest
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If SRC and DEST are the same (and not volatile), return DEST.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Evaluate and ignore LEN in case it has side-effects.  */
name|expand_expr
argument_list|(
name|len
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|dest
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If either SRC is not a pointer type, don't do this          operation in-line.  */
if|if
condition|(
name|src_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|dest_mem
operator|=
name|get_memory_rtx
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|dest_mem
argument_list|,
name|dest_align
argument_list|)
expr_stmt|;
name|len_rtx
operator|=
name|expand_expr
argument_list|(
name|len
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|src_str
operator|=
name|c_getstr
argument_list|(
name|src
argument_list|)
expr_stmt|;
comment|/* If SRC is a string constant and block move would be done 	 by pieces, we can avoid loading the string from memory 	 and only stored the computed constants.  */
if|if
condition|(
name|src_str
operator|&&
name|GET_CODE
argument_list|(
name|len_rtx
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
operator|<=
name|strlen
argument_list|(
name|src_str
argument_list|)
operator|+
literal|1
operator|&&
name|can_store_by_pieces
argument_list|(
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
argument_list|,
name|builtin_memcpy_read_str
argument_list|,
operator|(
name|void
operator|*
operator|)
name|src_str
argument_list|,
name|dest_align
argument_list|)
condition|)
block|{
name|dest_mem
operator|=
name|store_by_pieces
argument_list|(
name|dest_mem
argument_list|,
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
argument_list|,
name|builtin_memcpy_read_str
argument_list|,
operator|(
name|void
operator|*
operator|)
name|src_str
argument_list|,
name|dest_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|dest_mem
argument_list|)
expr_stmt|;
return|return
name|dest_mem
return|;
block|}
name|src_mem
operator|=
name|get_memory_rtx
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|src_mem
argument_list|,
name|src_align
argument_list|)
expr_stmt|;
comment|/* Copy word part most expediently.  */
name|dest_addr
operator|=
name|emit_block_move
argument_list|(
name|dest_mem
argument_list|,
name|src_mem
argument_list|,
name|len_rtx
argument_list|,
name|BLOCK_OP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_addr
operator|==
literal|0
condition|)
block|{
name|dest_addr
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|dest_addr
argument_list|)
expr_stmt|;
block|}
return|return
name|dest_addr
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to the mempcpy builtin, with arguments in ARGLIST.    Return 0 if we failed the caller should emit a normal call,    otherwise try to get the result in TARGET, if convenient (and in    mode MODE if that's convenient).  If ENDP is 0 return the    destination pointer, if ENDP is 1 return the end pointer ala    mempcpy, and if ENDP is 2 return the end pointer minus one ala    stpcpy.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_mempcpy
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|endp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If return value is ignored, transform mempcpy into memcpy.  */
elseif|else
if|if
condition|(
name|target
operator|==
name|const0_rtx
condition|)
block|{
name|tree
name|fn
init|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_MEMCPY
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
else|else
block|{
name|tree
name|dest
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|src
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_str
decl_stmt|;
name|unsigned
name|int
name|src_align
init|=
name|get_pointer_alignment
argument_list|(
name|src
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dest_align
init|=
name|get_pointer_alignment
argument_list|(
name|dest
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
name|rtx
name|dest_mem
decl_stmt|,
name|src_mem
decl_stmt|,
name|len_rtx
decl_stmt|;
comment|/* If DEST is not a pointer type, call the normal function.  */
if|if
condition|(
name|dest_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If SRC and DEST are the same (and not volatile), do nothing.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|expr
decl_stmt|;
if|if
condition|(
name|endp
operator|==
literal|0
condition|)
block|{
comment|/* Evaluate and ignore LEN in case it has side-effects.  */
name|expand_expr
argument_list|(
name|len
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|dest
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
if|if
condition|(
name|endp
operator|==
literal|2
condition|)
name|len
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|len
argument_list|)
argument_list|,
name|dest
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|expr
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|dest
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|expr
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If LEN is not constant, call the normal function.  */
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If the LEN parameter is zero, return DEST.  */
if|if
condition|(
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Evaluate and ignore SRC in case it has side-effects.  */
name|expand_expr
argument_list|(
name|src
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|dest
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If either SRC is not a pointer type, don't do this          operation in-line.  */
if|if
condition|(
name|src_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|len_rtx
operator|=
name|expand_expr
argument_list|(
name|len
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|src_str
operator|=
name|c_getstr
argument_list|(
name|src
argument_list|)
expr_stmt|;
comment|/* If SRC is a string constant and block move would be done 	 by pieces, we can avoid loading the string from memory 	 and only stored the computed constants.  */
if|if
condition|(
name|src_str
operator|&&
name|GET_CODE
argument_list|(
name|len_rtx
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
operator|<=
name|strlen
argument_list|(
name|src_str
argument_list|)
operator|+
literal|1
operator|&&
name|can_store_by_pieces
argument_list|(
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
argument_list|,
name|builtin_memcpy_read_str
argument_list|,
operator|(
name|void
operator|*
operator|)
name|src_str
argument_list|,
name|dest_align
argument_list|)
condition|)
block|{
name|dest_mem
operator|=
name|get_memory_rtx
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|dest_mem
argument_list|,
name|dest_align
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|store_by_pieces
argument_list|(
name|dest_mem
argument_list|,
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
argument_list|,
name|builtin_memcpy_read_str
argument_list|,
operator|(
name|void
operator|*
operator|)
name|src_str
argument_list|,
name|dest_align
argument_list|,
name|endp
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|dest_mem
argument_list|)
expr_stmt|;
return|return
name|dest_mem
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|len_rtx
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|can_move_by_pieces
argument_list|(
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|dest_align
argument_list|,
name|src_align
argument_list|)
argument_list|)
condition|)
block|{
name|dest_mem
operator|=
name|get_memory_rtx
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|dest_mem
argument_list|,
name|dest_align
argument_list|)
expr_stmt|;
name|src_mem
operator|=
name|get_memory_rtx
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|src_mem
argument_list|,
name|src_align
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|move_by_pieces
argument_list|(
name|dest_mem
argument_list|,
name|src_mem
argument_list|,
name|INTVAL
argument_list|(
name|len_rtx
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|dest_align
argument_list|,
name|src_align
argument_list|)
argument_list|,
name|endp
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|dest_mem
argument_list|)
expr_stmt|;
return|return
name|dest_mem
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the memmove builtin.  Return 0    if we failed the caller should emit a normal call.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_memmove
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|dest
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|src
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|src_align
init|=
name|get_pointer_alignment
argument_list|(
name|src
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dest_align
init|=
name|get_pointer_alignment
argument_list|(
name|dest
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
comment|/* If DEST is not a pointer type, call the normal function.  */
if|if
condition|(
name|dest_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If the LEN parameter is zero, return DEST.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
condition|)
block|{
comment|/* Evaluate and ignore SRC in case it has side-effects.  */
name|expand_expr
argument_list|(
name|src
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|dest
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If SRC and DEST are the same (and not volatile), return DEST.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Evaluate and ignore LEN in case it has side-effects.  */
name|expand_expr
argument_list|(
name|len
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|dest
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If either SRC is not a pointer type, don't do this          operation in-line.  */
if|if
condition|(
name|src_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If src is categorized for a readonly section we can use 	 normal memcpy.  */
if|if
condition|(
name|readonly_data_expr
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|tree
specifier|const
name|fn
init|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_MEMCPY
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* Otherwise, call the normal function.  */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the bcopy builtin.  Return 0    if we failed the caller should emit a normal call.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_bcopy
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|src
decl_stmt|,
name|dest
decl_stmt|,
name|size
decl_stmt|,
name|newarglist
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* New argument list transforming bcopy(ptr x, ptr y, int z) to      memmove(ptr y, ptr x, size_t z).   This is done this way      so that if it isn't expanded inline, we fallback to      calling bcopy instead of memmove.  */
name|newarglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|newarglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
name|newarglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
return|return
name|expand_builtin_memmove
argument_list|(
name|newarglist
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strcpy builtin.  Return 0    if we failed the caller should emit a normal call, otherwise try to get    the result in TARGET, if convenient (and in mode MODE if that's    convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strcpy
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|tree
name|fn
decl_stmt|,
name|len
decl_stmt|,
name|src
decl_stmt|,
name|dst
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* If SRC and DST are equal (and not volatile), return DST.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|expand_expr
argument_list|(
name|dst
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
name|fn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_MEMCPY
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|c_strlen
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|len
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dst
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to the stpcpy builtin, with arguments in ARGLIST.    Return 0 if we failed the caller should emit a normal call,    otherwise try to get the result in TARGET, if convenient (and in    mode MODE if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_stpcpy
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|dst
decl_stmt|,
name|src
decl_stmt|,
name|len
decl_stmt|;
comment|/* If return value is ignored, transform stpcpy into strcpy.  */
if|if
condition|(
name|target
operator|==
name|const0_rtx
condition|)
block|{
name|tree
name|fn
init|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRCPY
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* Ensure we get an actual string whose length can be evaluated at          compile-time, not an expression containing a string.  This is          because the latter will potentially produce pessimized code          when used to produce the return value.  */
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_getstr
argument_list|(
name|src
argument_list|)
operator|||
operator|!
operator|(
name|len
operator|=
name|c_strlen
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|dst
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|len
operator|=
name|fold
argument_list|(
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|len
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dst
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|expand_builtin_mempcpy
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
comment|/*endp=*/
literal|2
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)    bytes from constant string DATA + OFFSET and return it as target    constant.  */
end_comment

begin_function
specifier|static
name|rtx
name|builtin_strncpy_read_str
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|offset
operator|>
name|strlen
argument_list|(
name|str
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
return|return
name|c_readstr
argument_list|(
name|str
operator|+
name|offset
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strncpy builtin.  Return 0    if we failed the caller should emit a normal call.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strncpy
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|slen
init|=
name|c_strlen
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
decl_stmt|;
comment|/* We must be passed a constant len parameter.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|len
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
comment|/* If the len parameter is zero, return the dst parameter.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
condition|)
block|{
comment|/* Evaluate and ignore the src argument in case it has 	     side-effects.  */
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Return the dst parameter.  */
return|return
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* Now, we must be passed a constant src ptr parameter.  */
if|if
condition|(
name|slen
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|slen
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
name|slen
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|slen
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We're required to pad with trailing zeros if the requested          len is greater than strlen(s2)+1.  In that case try to 	 use store_by_pieces, if it fails, punt.  */
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|slen
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|tree
name|dest
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dest_align
init|=
name|get_pointer_alignment
argument_list|(
name|dest
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|c_getstr
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|dest_mem
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
name|dest_align
operator|==
literal|0
operator|||
operator|!
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|can_store_by_pieces
argument_list|(
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|,
name|builtin_strncpy_read_str
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p
argument_list|,
name|dest_align
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest_mem
operator|=
name|get_memory_rtx
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|store_by_pieces
argument_list|(
name|dest_mem
argument_list|,
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|,
name|builtin_strncpy_read_str
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p
argument_list|,
name|dest_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|dest_mem
argument_list|)
expr_stmt|;
return|return
name|dest_mem
return|;
block|}
comment|/* OK transform into builtin memcpy.  */
name|fn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_MEMCPY
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)    bytes from constant string DATA + OFFSET and return it as target    constant.  */
end_comment

begin_function
specifier|static
name|rtx
name|builtin_memset_read_str
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|HOST_WIDE_INT
name|offset
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|alloca
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
operator|*
name|c
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|c_readstr
argument_list|(
name|p
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Callback routine for store_by_pieces.  Return the RTL of a register    containing GET_MODE_SIZE (MODE) consecutive copies of the unsigned    char value given in the RTL register data.  For example, if mode is    4 bytes wide, return the RTL for 0x01010101*data.  */
end_comment

begin_function
specifier|static
name|rtx
name|builtin_memset_gen_str
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|HOST_WIDE_INT
name|offset
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|target
decl_stmt|,
name|coeff
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
condition|)
return|return
operator|(
name|rtx
operator|)
name|data
return|;
name|p
operator|=
name|alloca
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|coeff
operator|=
name|c_readstr
argument_list|(
name|p
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|target
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
operator|(
name|rtx
operator|)
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_mult
argument_list|(
name|mode
argument_list|,
name|target
argument_list|,
name|coeff
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|force_reg
argument_list|(
name|mode
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the memset builtin.  Return 0    if we failed the caller should emit a normal call, otherwise try to get    the result in TARGET, if convenient (and in mode MODE if that's    convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_memset
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|dest
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|c
decl_stmt|;
name|unsigned
name|int
name|dest_align
init|=
name|get_pointer_alignment
argument_list|(
name|dest
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
decl_stmt|;
name|rtx
name|dest_mem
decl_stmt|,
name|dest_addr
decl_stmt|,
name|len_rtx
decl_stmt|;
comment|/* If DEST is not a pointer type, don't do this 	 operation in-line.  */
if|if
condition|(
name|dest_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If the LEN parameter is zero, return DEST.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
condition|)
block|{
comment|/* Evaluate and ignore VAL in case it has side-effects.  */
name|expand_expr
argument_list|(
name|val
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|dest
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|rtx
name|val_rtx
decl_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|optimize_size
operator|&&
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|>
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Assume that we can memset by pieces if we can store the 	   * the coefficients by pieces (in the required modes). 	   * We can't pass builtin_memset_gen_str as that emits RTL.  */
name|c
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|can_store_by_pieces
argument_list|(
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|,
name|builtin_memset_read_str
argument_list|,
operator|&
name|c
argument_list|,
name|dest_align
argument_list|)
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|unsigned_char_type_node
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|val_rtx
operator|=
name|expand_expr
argument_list|(
name|val
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val_rtx
operator|=
name|force_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|unsigned_char_type_node
argument_list|)
argument_list|,
name|val_rtx
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|get_memory_rtx
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|store_by_pieces
argument_list|(
name|dest_mem
argument_list|,
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|,
name|builtin_memset_gen_str
argument_list|,
name|val_rtx
argument_list|,
name|dest_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|dest_mem
argument_list|)
expr_stmt|;
return|return
name|dest_mem
return|;
block|}
if|if
condition|(
name|target_char_cast
argument_list|(
name|val
argument_list|,
operator|&
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|can_store_by_pieces
argument_list|(
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|,
name|builtin_memset_read_str
argument_list|,
operator|&
name|c
argument_list|,
name|dest_align
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest_mem
operator|=
name|get_memory_rtx
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|store_by_pieces
argument_list|(
name|dest_mem
argument_list|,
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|,
name|builtin_memset_read_str
argument_list|,
operator|&
name|c
argument_list|,
name|dest_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|dest_mem
argument_list|)
expr_stmt|;
return|return
name|dest_mem
return|;
block|}
name|len_rtx
operator|=
name|expand_expr
argument_list|(
name|len
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|get_memory_rtx
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|dest_mem
argument_list|,
name|dest_align
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|clear_storage
argument_list|(
name|dest_mem
argument_list|,
name|len_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_addr
operator|==
literal|0
condition|)
block|{
name|dest_addr
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|dest_addr
argument_list|)
expr_stmt|;
block|}
return|return
name|dest_addr
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the bzero builtin.  Return 0    if we failed the caller should emit a normal call.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_bzero
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|dest
decl_stmt|,
name|size
decl_stmt|,
name|newarglist
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|size
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* New argument list transforming bzero(ptr x, int y) to      memset(ptr x, int 0, size_t y).   This is done this way      so that if it isn't expanded inline, we fallback to      calling bzero instead of memset.  */
name|newarglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|newarglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
name|newarglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
return|return
name|expand_builtin_memset
argument_list|(
name|newarglist
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the memcmp built-in function.    ARGLIST is the argument list for this call.  Return 0 if we failed and the    caller should emit a normal call, otherwise try to get the result in    TARGET, if convenient (and in mode MODE, if that's convenient).  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_memcmp
parameter_list|(
name|tree
name|exp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the len parameter is zero, return zero.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
condition|)
block|{
comment|/* Evaluate and ignore arg1 and arg2 in case they have          side-effects.  */
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
comment|/* If both arguments are equal (and not volatile), return zero.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Evaluate and ignore len in case it has side-effects.  */
name|expand_expr
argument_list|(
name|len
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|p1
operator|=
name|c_getstr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|c_getstr
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* If all arguments are constant, and the value of len is not greater      than the lengths of arg1 and arg2, evaluate at compile-time.  */
if|if
condition|(
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|&&
name|p1
operator|&&
name|p2
operator|&&
name|compare_tree_int
argument_list|(
name|len
argument_list|,
name|strlen
argument_list|(
name|p1
argument_list|)
operator|+
literal|1
argument_list|)
operator|<=
literal|0
operator|&&
name|compare_tree_int
argument_list|(
name|len
argument_list|,
name|strlen
argument_list|(
name|p2
argument_list|)
operator|+
literal|1
argument_list|)
operator|<=
literal|0
condition|)
block|{
specifier|const
name|int
name|r
init|=
name|memcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|r
operator|<
literal|0
condition|?
name|constm1_rtx
else|:
operator|(
name|r
operator|>
literal|0
condition|?
name|const1_rtx
else|:
name|const0_rtx
operator|)
operator|)
return|;
block|}
comment|/* If len parameter is one, return an expression corresponding to      (*(const unsigned char*)arg1 - (const unsigned char*)arg2).  */
if|if
condition|(
name|integer_onep
argument_list|(
name|len
argument_list|)
condition|)
block|{
name|tree
name|cst_uchar_node
init|=
name|build_type_variant
argument_list|(
name|unsigned_char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|cst_uchar_ptr_node
init|=
name|build_pointer_type
argument_list|(
name|cst_uchar_node
argument_list|)
decl_stmt|;
name|tree
name|ind1
init|=
name|fold
argument_list|(
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|cst_uchar_ptr_node
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ind2
init|=
name|fold
argument_list|(
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|cst_uchar_ptr_node
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ind1
argument_list|,
name|ind2
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
if|#
directive|if
name|defined
name|HAVE_cmpmemsi
operator|||
name|defined
name|HAVE_cmpstrsi
block|{
name|rtx
name|arg1_rtx
decl_stmt|,
name|arg2_rtx
decl_stmt|,
name|arg3_rtx
decl_stmt|;
name|rtx
name|result
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|arg1_align
init|=
name|get_pointer_alignment
argument_list|(
name|arg1
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|arg2_align
init|=
name|get_pointer_alignment
argument_list|(
name|arg2
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|enum
name|machine_mode
name|insn_mode
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cmpmemsi
if|if
condition|(
name|HAVE_cmpmemsi
condition|)
name|insn_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_cmpmemsi
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpstrsi
if|if
condition|(
name|HAVE_cmpstrsi
condition|)
name|insn_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_cmpstrsi
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
else|else
endif|#
directive|endif
return|return
literal|0
return|;
comment|/* If we don't have POINTER_TYPE, call the function.  */
if|if
condition|(
name|arg1_align
operator|==
literal|0
operator|||
name|arg2_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Make a place to write the result of the instruction.  */
name|result
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|result
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|insn_mode
operator|&&
name|REGNO
argument_list|(
name|result
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
name|arg1_rtx
operator|=
name|get_memory_rtx
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg2_rtx
operator|=
name|get_memory_rtx
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|arg3_rtx
operator|=
name|expand_expr
argument_list|(
name|len
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cmpmemsi
if|if
condition|(
name|HAVE_cmpmemsi
condition|)
name|insn
operator|=
name|gen_cmpmemsi
argument_list|(
name|result
argument_list|,
name|arg1_rtx
argument_list|,
name|arg2_rtx
argument_list|,
name|arg3_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|MIN
argument_list|(
name|arg1_align
argument_list|,
name|arg2_align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cmpstrsi
if|if
condition|(
name|HAVE_cmpstrsi
condition|)
name|insn
operator|=
name|gen_cmpstrsi
argument_list|(
name|result
argument_list|,
name|arg1_rtx
argument_list|,
name|arg2_rtx
argument_list|,
name|arg3_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|MIN
argument_list|(
name|arg1_align
argument_list|,
name|arg2_align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn
condition|)
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|emit_library_call_value
argument_list|(
name|memcmp_libfunc
argument_list|,
name|result
argument_list|,
name|LCT_PURE_MAKE_BLOCK
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|arg1_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|arg2_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|arg3_rtx
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the value in the proper mode for this function.  */
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|mode
condition|)
return|return
name|result
return|;
elseif|else
if|if
condition|(
name|target
operator|!=
literal|0
condition|)
block|{
name|convert_move
argument_list|(
name|target
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strcmp builtin.  Return 0    if we failed the caller should emit a normal call, otherwise try to get    the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strcmp
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If both arguments are equal (and not volatile), return zero.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
name|p1
operator|=
name|c_getstr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|c_getstr
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|&&
name|p2
condition|)
block|{
specifier|const
name|int
name|i
init|=
name|strcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
decl_stmt|;
return|return
operator|(
name|i
operator|<
literal|0
condition|?
name|constm1_rtx
else|:
operator|(
name|i
operator|>
literal|0
condition|?
name|const1_rtx
else|:
name|const0_rtx
operator|)
operator|)
return|;
block|}
comment|/* If either arg is "", return an expression corresponding to      (*(const unsigned char*)arg1 - (const unsigned char*)arg2).  */
if|if
condition|(
operator|(
name|p1
operator|&&
operator|*
name|p1
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|p2
operator|&&
operator|*
name|p2
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|tree
name|cst_uchar_node
init|=
name|build_type_variant
argument_list|(
name|unsigned_char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|cst_uchar_ptr_node
init|=
name|build_pointer_type
argument_list|(
name|cst_uchar_node
argument_list|)
decl_stmt|;
name|tree
name|ind1
init|=
name|fold
argument_list|(
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|cst_uchar_ptr_node
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ind2
init|=
name|fold
argument_list|(
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|cst_uchar_ptr_node
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ind1
argument_list|,
name|ind2
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_cmpstrsi
if|if
condition|(
name|HAVE_cmpstrsi
condition|)
block|{
name|tree
name|len
decl_stmt|,
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|rtx
name|arg1_rtx
decl_stmt|,
name|arg2_rtx
decl_stmt|,
name|arg3_rtx
decl_stmt|;
name|rtx
name|result
decl_stmt|,
name|insn
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|int
name|arg1_align
init|=
name|get_pointer_alignment
argument_list|(
name|arg1
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|arg2_align
init|=
name|get_pointer_alignment
argument_list|(
name|arg2
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|enum
name|machine_mode
name|insn_mode
init|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_cmpstrsi
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|len1
operator|=
name|c_strlen
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|len2
operator|=
name|c_strlen
argument_list|(
name|arg2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len1
condition|)
name|len1
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|,
name|len1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len2
condition|)
name|len2
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|,
name|len2
argument_list|)
expr_stmt|;
comment|/* If we don't have a constant length for the first, use the length        of the second, if we know it.  We don't require a constant for        this case; some cost analysis could be done if both are available        but neither is constant.  For now, assume they're equally cheap,        unless one has side effects.  If both strings have constant lengths,        use the smaller.  */
if|if
condition|(
operator|!
name|len1
condition|)
name|len
operator|=
name|len2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|len2
condition|)
name|len
operator|=
name|len1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|len1
argument_list|)
condition|)
name|len
operator|=
name|len2
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|len2
argument_list|)
condition|)
name|len
operator|=
name|len1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|len1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|len
operator|=
name|len2
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|len2
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|len
operator|=
name|len1
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|len1
argument_list|,
name|len2
argument_list|)
condition|)
name|len
operator|=
name|len1
expr_stmt|;
else|else
name|len
operator|=
name|len2
expr_stmt|;
comment|/* If both arguments have side effects, we cannot optimize.  */
if|if
condition|(
operator|!
name|len
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If we don't have POINTER_TYPE, call the function.  */
if|if
condition|(
name|arg1_align
operator|==
literal|0
operator|||
name|arg2_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Make a place to write the result of the instruction.  */
name|result
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|result
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|insn_mode
operator|&&
name|REGNO
argument_list|(
name|result
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
comment|/* Stabilize the arguments in case gen_cmpstrsi fails.  */
name|arg1
operator|=
name|save_expr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|save_expr
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|arg1_rtx
operator|=
name|get_memory_rtx
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg2_rtx
operator|=
name|get_memory_rtx
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|arg3_rtx
operator|=
name|expand_expr
argument_list|(
name|len
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_cmpstrsi
argument_list|(
name|result
argument_list|,
name|arg1_rtx
argument_list|,
name|arg2_rtx
argument_list|,
name|arg3_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|MIN
argument_list|(
name|arg1_align
argument_list|,
name|arg2_align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
block|{
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Return the value in the proper mode for this function.  */
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|mode
condition|)
return|return
name|result
return|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
return|return
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
return|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* Expand the library call ourselves using a stabilized argument        list to avoid re-evaluating the function's arguments twice.  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|target
operator|==
name|const0_rtx
argument_list|)
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strncmp builtin.  Return 0    if we failed the caller should emit a normal call, otherwise try to get    the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strncmp
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|arg3
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the len parameter is zero, return zero.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg3
argument_list|)
condition|)
block|{
comment|/* Evaluate and ignore arg1 and arg2 in case they have 	 side-effects.  */
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
comment|/* If arg1 and arg2 are equal (and not volatile), return zero.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Evaluate and ignore arg3 in case it has side-effects.  */
name|expand_expr
argument_list|(
name|arg3
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|p1
operator|=
name|c_getstr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|c_getstr
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* If all arguments are constant, evaluate at compile-time.  */
if|if
condition|(
name|host_integerp
argument_list|(
name|arg3
argument_list|,
literal|1
argument_list|)
operator|&&
name|p1
operator|&&
name|p2
condition|)
block|{
specifier|const
name|int
name|r
init|=
name|strncmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|tree_low_cst
argument_list|(
name|arg3
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|r
operator|<
literal|0
condition|?
name|constm1_rtx
else|:
operator|(
name|r
operator|>
literal|0
condition|?
name|const1_rtx
else|:
name|const0_rtx
operator|)
operator|)
return|;
block|}
comment|/* If len == 1 or (either string parameter is "" and (len>= 1)),       return (*(const u_char*)arg1 - *(const u_char*)arg2).  */
if|if
condition|(
name|host_integerp
argument_list|(
name|arg3
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|tree_low_cst
argument_list|(
name|arg3
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
operator|||
operator|(
name|tree_low_cst
argument_list|(
name|arg3
argument_list|,
literal|1
argument_list|)
operator|>
literal|1
operator|&&
operator|(
operator|(
name|p1
operator|&&
operator|*
name|p1
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|p2
operator|&&
operator|*
name|p2
operator|==
literal|'\0'
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|tree
name|cst_uchar_node
init|=
name|build_type_variant
argument_list|(
name|unsigned_char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|cst_uchar_ptr_node
init|=
name|build_pointer_type
argument_list|(
name|cst_uchar_node
argument_list|)
decl_stmt|;
name|tree
name|ind1
init|=
name|fold
argument_list|(
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|cst_uchar_ptr_node
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ind2
init|=
name|fold
argument_list|(
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|cst_uchar_node
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|cst_uchar_ptr_node
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|ind1
argument_list|,
name|ind2
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If c_strlen can determine an expression for one of the string      lengths, and it doesn't have side effects, then emit cmpstrsi      using length MIN(strlen(string)+1, arg3).  */
ifdef|#
directive|ifdef
name|HAVE_cmpstrsi
if|if
condition|(
name|HAVE_cmpstrsi
condition|)
block|{
name|tree
name|len
decl_stmt|,
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|rtx
name|arg1_rtx
decl_stmt|,
name|arg2_rtx
decl_stmt|,
name|arg3_rtx
decl_stmt|;
name|rtx
name|result
decl_stmt|,
name|insn
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|int
name|arg1_align
init|=
name|get_pointer_alignment
argument_list|(
name|arg1
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|arg2_align
init|=
name|get_pointer_alignment
argument_list|(
name|arg2
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|enum
name|machine_mode
name|insn_mode
init|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_cmpstrsi
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|len1
operator|=
name|c_strlen
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|len2
operator|=
name|c_strlen
argument_list|(
name|arg2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len1
condition|)
name|len1
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|,
name|len1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len2
condition|)
name|len2
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|,
name|len2
argument_list|)
expr_stmt|;
comment|/* If we don't have a constant length for the first, use the length        of the second, if we know it.  We don't require a constant for        this case; some cost analysis could be done if both are available        but neither is constant.  For now, assume they're equally cheap,        unless one has side effects.  If both strings have constant lengths,        use the smaller.  */
if|if
condition|(
operator|!
name|len1
condition|)
name|len
operator|=
name|len2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|len2
condition|)
name|len
operator|=
name|len1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|len1
argument_list|)
condition|)
name|len
operator|=
name|len2
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|len2
argument_list|)
condition|)
name|len
operator|=
name|len1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|len1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|len
operator|=
name|len2
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|len2
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|len
operator|=
name|len1
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|len1
argument_list|,
name|len2
argument_list|)
condition|)
name|len
operator|=
name|len1
expr_stmt|;
else|else
name|len
operator|=
name|len2
expr_stmt|;
comment|/* If both arguments have side effects, we cannot optimize.  */
if|if
condition|(
operator|!
name|len
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* The actual new length parameter is MIN(len,arg3).  */
name|len
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MIN_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|len
argument_list|)
argument_list|,
name|len
argument_list|,
name|arg3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we don't have POINTER_TYPE, call the function.  */
if|if
condition|(
name|arg1_align
operator|==
literal|0
operator|||
name|arg2_align
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Make a place to write the result of the instruction.  */
name|result
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|result
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|insn_mode
operator|&&
name|REGNO
argument_list|(
name|result
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
comment|/* Stabilize the arguments in case gen_cmpstrsi fails.  */
name|arg1
operator|=
name|save_expr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|save_expr
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|len
operator|=
name|save_expr
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|arg1_rtx
operator|=
name|get_memory_rtx
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg2_rtx
operator|=
name|get_memory_rtx
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|arg3_rtx
operator|=
name|expand_expr
argument_list|(
name|len
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_cmpstrsi
argument_list|(
name|result
argument_list|,
name|arg1_rtx
argument_list|,
name|arg2_rtx
argument_list|,
name|arg3_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|MIN
argument_list|(
name|arg1_align
argument_list|,
name|arg2_align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
block|{
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Return the value in the proper mode for this function.  */
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|mode
condition|)
return|return
name|result
return|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
return|return
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
return|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* Expand the library call ourselves using a stabilized argument        list to avoid re-evaluating the function's arguments twice.  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|target
operator|==
name|const0_rtx
argument_list|)
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strcat builtin.    Return 0 if we failed the caller should emit a normal call,    otherwise try to get the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strcat
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|dst
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|src
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|c_getstr
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
comment|/* If the string length is zero, return the dst parameter.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|expand_expr
argument_list|(
name|dst
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|optimize_size
condition|)
block|{
comment|/* Otherwise if !optimize_size, see if we can store by                  pieces into (dst + strlen(dst)).  */
name|tree
name|newdst
decl_stmt|,
name|arglist
decl_stmt|,
name|strlen_fn
init|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRLEN
index|]
decl_stmt|;
comment|/* This is the length argument.  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fold
argument_list|(
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|c_strlen
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prepend src argument.  */
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
comment|/* We're going to use dst more than once.  */
name|dst
operator|=
name|save_expr
argument_list|(
name|dst
argument_list|)
expr_stmt|;
comment|/* Create strlen (dst).  */
name|newdst
operator|=
name|fold
argument_list|(
name|build_function_call_expr
argument_list|(
name|strlen_fn
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create (dst + strlen (dst)).  */
name|newdst
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|dst
argument_list|,
name|newdst
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prepend the new dst argument.  */
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|newdst
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
comment|/* We don't want to get turned into a memcpy if the                  target is const0_rtx, i.e. when the return value                  isn't used.  That would produce pessimized code so                  pass in a target of zero, it should never actually be                  used.  If this was successful return the original                  dst, not the result of mempcpy.  */
if|if
condition|(
name|expand_builtin_mempcpy
argument_list|(
name|arglist
argument_list|,
comment|/*target=*/
literal|0
argument_list|,
name|mode
argument_list|,
comment|/*endp=*/
literal|0
argument_list|)
condition|)
return|return
name|expand_expr
argument_list|(
name|dst
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strncat builtin.    Return 0 if we failed the caller should emit a normal call,    otherwise try to get the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strncat
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|dst
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|src
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|,
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|c_getstr
argument_list|(
name|src
argument_list|)
decl_stmt|;
comment|/* If the requested length is zero, or the src parameter string           length is zero, return the dst parameter.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
operator|||
operator|(
name|p
operator|&&
operator|*
name|p
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|/* Evaluate and ignore the src and len parameters in case 	     they have side-effects.  */
name|expand_expr
argument_list|(
name|src
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|len
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|dst
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If the requested len is greater than or equal to the string          length, call strcat.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|len
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|p
operator|&&
name|compare_tree_int
argument_list|(
name|len
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|tree
name|newarglist
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dst
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
init|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRCAT
index|]
decl_stmt|;
comment|/* If the replacement _DECL isn't initialized, don't do the 	     transformation.  */
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|newarglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strspn builtin.    Return 0 if we failed the caller should emit a normal call,    otherwise try to get the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strspn
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|s1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|s2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
init|=
name|c_getstr
argument_list|(
name|s1
argument_list|)
decl_stmt|,
modifier|*
name|p2
init|=
name|c_getstr
argument_list|(
name|s2
argument_list|)
decl_stmt|;
comment|/* If both arguments are constants, evaluate at compile-time.  */
if|if
condition|(
name|p1
operator|&&
name|p2
condition|)
block|{
specifier|const
name|size_t
name|r
init|=
name|strspn
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
decl_stmt|;
return|return
name|expand_expr
argument_list|(
name|size_int
argument_list|(
name|r
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If either argument is "", return 0.  */
if|if
condition|(
operator|(
name|p1
operator|&&
operator|*
name|p1
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|p2
operator|&&
operator|*
name|p2
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|/* Evaluate and ignore both arguments in case either one has 	     side-effects.  */
name|expand_expr
argument_list|(
name|s1
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|s2
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand expression EXP, which is a call to the strcspn builtin.    Return 0 if we failed the caller should emit a normal call,    otherwise try to get the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_strcspn
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|tree
name|s1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|,
name|s2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
init|=
name|c_getstr
argument_list|(
name|s1
argument_list|)
decl_stmt|,
modifier|*
name|p2
init|=
name|c_getstr
argument_list|(
name|s2
argument_list|)
decl_stmt|;
comment|/* If both arguments are constants, evaluate at compile-time.  */
if|if
condition|(
name|p1
operator|&&
name|p2
condition|)
block|{
specifier|const
name|size_t
name|r
init|=
name|strcspn
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
decl_stmt|;
return|return
name|expand_expr
argument_list|(
name|size_int
argument_list|(
name|r
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If the first argument is "", return 0.  */
if|if
condition|(
name|p1
operator|&&
operator|*
name|p1
operator|==
literal|'\0'
condition|)
block|{
comment|/* Evaluate and ignore argument s2 in case it has 	     side-effects.  */
name|expand_expr
argument_list|(
name|s2
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
comment|/* If the second argument is "", return __builtin_strlen(s1).  */
if|if
condition|(
name|p2
operator|&&
operator|*
name|p2
operator|==
literal|'\0'
condition|)
block|{
name|tree
name|newarglist
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|s1
argument_list|)
decl_stmt|,
name|fn
init|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRLEN
index|]
decl_stmt|;
comment|/* If the replacement _DECL isn't initialized, don't do the 	     transformation.  */
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|newarglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to __builtin_saveregs, generating the result in TARGET,    if that's convenient.  */
end_comment

begin_function
name|rtx
name|expand_builtin_saveregs
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|val
decl_stmt|,
name|seq
decl_stmt|;
comment|/* Don't do __builtin_saveregs more than once in a function.      Save the result of the first call and reuse it.  */
if|if
condition|(
name|saveregs_value
operator|!=
literal|0
condition|)
return|return
name|saveregs_value
return|;
comment|/* When this function is called, it means that registers must be      saved on entry to this function.  So we migrate the call to the      first insn of this function.  */
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Do whatever the machine needs done in this case.  */
name|val
operator|=
name|targetm
operator|.
name|calls
operator|.
name|expand_builtin_saveregs
argument_list|()
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|saveregs_value
operator|=
name|val
expr_stmt|;
comment|/* Put the insns after the NOTE that starts the function.  If this      is inside a start_sequence, make the outer-level insn chain current, so      the code is placed at the start of the function.  */
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* __builtin_args_info (N) returns word N of the arg space info    for the current function.  The number and meanings of words    is controlled by the definition of CUMULATIVE_ARGS.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_args_info
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|int
name|nwords
init|=
sizeof|sizeof
argument_list|(
name|CUMULATIVE_ARGS
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
name|int
modifier|*
name|word_ptr
init|=
operator|(
name|int
operator|*
operator|)
operator|&
name|current_function_args_info
decl_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|CUMULATIVE_ARGS
argument_list|)
operator|%
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|arglist
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|error
argument_list|(
literal|"argument of `__builtin_args_info' must be constant"
argument_list|)
expr_stmt|;
else|else
block|{
name|HOST_WIDE_INT
name|wordnum
init|=
name|tree_low_cst
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|wordnum
operator|<
literal|0
operator|||
name|wordnum
operator|>=
name|nwords
condition|)
name|error
argument_list|(
literal|"argument of `__builtin_args_info' out of range"
argument_list|)
expr_stmt|;
else|else
return|return
name|GEN_INT
argument_list|(
name|word_ptr
index|[
name|wordnum
index|]
argument_list|)
return|;
block|}
block|}
else|else
name|error
argument_list|(
literal|"missing argument in `__builtin_args_info'"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* Expand ARGLIST, from a call to __builtin_next_arg.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_next_arg
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"`va_start' used in function with fixed args"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|arglist
condition|)
block|{
name|tree
name|last_parm
init|=
name|tree_last
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
comment|/* Strip off all nops for the sake of the comparison.  This 	 is not quite the same as STRIP_NOPS.  It does more. 	 We must also strip off INDIRECT_EXPR for C++ reference 	 parameters.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
name|last_parm
condition|)
name|warning
argument_list|(
literal|"second parameter of `va_start' not last named argument"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Evidently an out of date version of<stdarg.h>; can't validate        va_start's second argument, but can still work as intended.  */
name|warning
argument_list|(
literal|"`__builtin_next_arg' called without an argument"
argument_list|)
expr_stmt|;
return|return
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|current_function_internal_arg_pointer
argument_list|,
name|current_function_arg_offset_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make it easier for the backends by protecting the valist argument    from multiple evaluations.  */
end_comment

begin_function
specifier|static
name|tree
name|stabilize_va_list
parameter_list|(
name|tree
name|valist
parameter_list|,
name|int
name|needs_lvalue
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|va_list_type_node
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|valist
argument_list|)
condition|)
name|valist
operator|=
name|save_expr
argument_list|(
name|valist
argument_list|)
expr_stmt|;
comment|/* For this case, the backends will be expecting a pointer to 	 TREE_TYPE (va_list_type_node), but it's possible we've 	 actually been given an array (an actual va_list_type_node). 	 So fix it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|p1
init|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|build_pointer_type
argument_list|(
name|va_list_type_node
argument_list|)
decl_stmt|;
name|valist
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|p2
argument_list|,
name|valist
argument_list|)
expr_stmt|;
name|valist
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|p1
argument_list|,
name|valist
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|pt
decl_stmt|;
if|if
condition|(
operator|!
name|needs_lvalue
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|valist
argument_list|)
condition|)
return|return
name|valist
return|;
name|pt
operator|=
name|build_pointer_type
argument_list|(
name|va_list_type_node
argument_list|)
expr_stmt|;
name|valist
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|pt
argument_list|,
name|valist
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|valist
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|valist
argument_list|)
condition|)
name|valist
operator|=
name|save_expr
argument_list|(
name|valist
argument_list|)
expr_stmt|;
name|valist
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
argument_list|,
name|valist
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|valist
return|;
block|}
end_function

begin_comment
comment|/* The "standard" definition of va_list is void*.  */
end_comment

begin_function
name|tree
name|std_build_builtin_va_list
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ptr_type_node
return|;
block|}
end_function

begin_comment
comment|/* The "standard" implementation of va_start: just assign `nextarg' to    the variable.  */
end_comment

begin_function
name|void
name|std_expand_builtin_va_start
parameter_list|(
name|tree
name|valist
parameter_list|,
name|rtx
name|nextarg
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|make_tree
argument_list|(
name|ptr_type_node
argument_list|,
name|nextarg
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand ARGLIST, from a call to __builtin_va_start.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_va_start
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|rtx
name|nextarg
decl_stmt|;
name|tree
name|chain
decl_stmt|,
name|valist
decl_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
condition|)
name|error
argument_list|(
literal|"too many arguments to function `va_start'"
argument_list|)
expr_stmt|;
name|nextarg
operator|=
name|expand_builtin_next_arg
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|valist
operator|=
name|stabilize_va_list
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXPAND_BUILTIN_VA_START
name|EXPAND_BUILTIN_VA_START
argument_list|(
name|valist
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
else|#
directive|else
name|std_expand_builtin_va_start
argument_list|(
name|valist
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* The "standard" implementation of va_arg: read the value from the    current (padded) address and increment by the (padded) size.  */
end_comment

begin_function
name|rtx
name|std_expand_builtin_va_arg
parameter_list|(
name|tree
name|valist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|addr_tree
decl_stmt|,
name|t
decl_stmt|,
name|type_size
init|=
name|NULL
decl_stmt|;
name|tree
name|align
decl_stmt|,
name|alignm1
decl_stmt|;
name|tree
name|rounded_size
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
name|HOST_WIDE_INT
name|boundary
decl_stmt|;
comment|/* Compute the rounded size of the type.  */
name|align
operator|=
name|size_int
argument_list|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|alignm1
operator|=
name|size_int
argument_list|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
argument_list|)
expr_stmt|;
name|boundary
operator|=
name|FUNCTION_ARG_BOUNDARY
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* va_list pointer is aligned to PARM_BOUNDARY.  If argument actually      requires greater alignment, we must perform dynamic alignment.  */
if|if
condition|(
name|boundary
operator|>
name|PARM_BOUNDARY
condition|)
block|{
if|if
condition|(
operator|!
name|PAD_VARARGS_DOWN
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|build_int_2
argument_list|(
name|boundary
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|build_int_2
argument_list|(
operator|~
operator|(
name|boundary
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
operator|(
name|type_size
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|TREE_OVERFLOW
argument_list|(
name|type_size
argument_list|)
condition|)
name|rounded_size
operator|=
name|size_zero_node
expr_stmt|;
else|else
name|rounded_size
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|sizetype
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|sizetype
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|type_size
argument_list|,
name|alignm1
argument_list|)
argument_list|)
argument_list|,
name|align
argument_list|)
argument_list|)
argument_list|,
name|align
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get AP.  */
name|addr_tree
operator|=
name|valist
expr_stmt|;
if|if
condition|(
name|PAD_VARARGS_DOWN
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|rounded_size
argument_list|)
condition|)
block|{
comment|/* Small args are padded downward.  */
name|addr_tree
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|addr_tree
argument_list|)
argument_list|,
name|addr_tree
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|sizetype
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|GT_EXPR
argument_list|,
name|sizetype
argument_list|,
name|rounded_size
argument_list|,
name|align
argument_list|)
argument_list|)
argument_list|,
name|size_zero_node
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|rounded_size
argument_list|,
name|type_size
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|expand_expr
argument_list|(
name|addr_tree
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|addr
operator|=
name|copy_to_reg
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* Compute new value for AP.  */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|rounded_size
argument_list|)
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|rounded_size
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Expand __builtin_va_arg, which is not really a builtin function, but    a very special sort of operator.  */
end_comment

begin_function
name|rtx
name|expand_builtin_va_arg
parameter_list|(
name|tree
name|valist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|,
name|result
decl_stmt|;
name|tree
name|promoted_type
decl_stmt|,
name|want_va_type
decl_stmt|,
name|have_va_type
decl_stmt|;
comment|/* Verify that valist is of the proper type.  */
name|want_va_type
operator|=
name|va_list_type_node
expr_stmt|;
name|have_va_type
operator|=
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|want_va_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* If va_list is an array type, the argument may have decayed 	 to a pointer type, e.g. by being passed to another function.          In that case, unwrap both types so that we can compare the 	 underlying records.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|have_va_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|have_va_type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|want_va_type
operator|=
name|TREE_TYPE
argument_list|(
name|want_va_type
argument_list|)
expr_stmt|;
name|have_va_type
operator|=
name|TREE_TYPE
argument_list|(
name|have_va_type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|want_va_type
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|have_va_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"first argument to `va_arg' not of type `va_list'"
argument_list|)
expr_stmt|;
name|addr
operator|=
name|const0_rtx
expr_stmt|;
block|}
comment|/* Generate a diagnostic for requesting data of a type that cannot      be passed through `...' due to type promotion at the call site.  */
elseif|else
if|if
condition|(
operator|(
name|promoted_type
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_promotes_to
call|)
argument_list|(
name|type
argument_list|)
operator|)
operator|!=
name|type
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
literal|"<anonymous type>"
decl_stmt|,
modifier|*
name|pname
init|=
literal|0
decl_stmt|;
specifier|static
name|bool
name|gave_help
decl_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|promoted_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|promoted_type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|pname
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|promoted_type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|promoted_type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|promoted_type
argument_list|)
argument_list|)
condition|)
name|pname
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|promoted_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Unfortunately, this is merely undefined, rather than a constraint 	 violation, so we cannot make this an error.  If this call is never 	 executed, the program is still strictly conforming.  */
name|warning
argument_list|(
literal|"`%s' is promoted to `%s' when passed through `...'"
argument_list|,
name|name
argument_list|,
name|pname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gave_help
condition|)
block|{
name|gave_help
operator|=
name|true
expr_stmt|;
name|warning
argument_list|(
literal|"(so you should pass `%s' not `%s' to `va_arg')"
argument_list|,
name|pname
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* We can, however, treat "undefined" any way we please. 	 Call abort to encourage the user to fix the program.  */
name|inform
argument_list|(
literal|"if this code is reached, the program will abort"
argument_list|)
expr_stmt|;
name|expand_builtin_trap
argument_list|()
expr_stmt|;
comment|/* This is dead code, but go ahead and finish so that the 	 mode of the result comes out right.  */
name|addr
operator|=
name|const0_rtx
expr_stmt|;
block|}
else|else
block|{
comment|/* Make it easier for the backends by protecting the valist argument          from multiple evaluations.  */
name|valist
operator|=
name|stabilize_va_list
argument_list|(
name|valist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXPAND_BUILTIN_VA_ARG
name|addr
operator|=
name|EXPAND_BUILTIN_VA_ARG
argument_list|(
name|valist
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|#
directive|else
name|addr
operator|=
name|std_expand_builtin_va_arg
argument_list|(
name|valist
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|result
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|result
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Expand ARGLIST, from a call to __builtin_va_end.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_va_end
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|valist
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
comment|/* Evaluate for side effects, if needed.  I hate macros that don't      do that.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|valist
argument_list|)
condition|)
name|expand_expr
argument_list|(
name|valist
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* Expand ARGLIST, from a call to __builtin_va_copy.  We do this as a    builtin rather than just as an assignment in stdarg.h because of the    nastiness of array-type va_list types.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_va_copy
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|dst
decl_stmt|,
name|src
decl_stmt|,
name|t
decl_stmt|;
name|dst
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|stabilize_va_list
argument_list|(
name|dst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|src
operator|=
name|stabilize_va_list
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|va_list_type_node
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|va_list_type_node
argument_list|,
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|dstb
decl_stmt|,
name|srcb
decl_stmt|,
name|size
decl_stmt|;
comment|/* Evaluate to pointers.  */
name|dstb
operator|=
name|expand_expr
argument_list|(
name|dst
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|srcb
operator|=
name|expand_expr
argument_list|(
name|src
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|size
operator|=
name|expand_expr
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|dstb
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|dstb
argument_list|)
expr_stmt|;
name|srcb
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|srcb
argument_list|)
expr_stmt|;
comment|/* "Dereference" to BLKmode memories.  */
name|dstb
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|dstb
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|dstb
argument_list|,
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|dstb
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|srcb
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|srcb
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|srcb
argument_list|,
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|srcb
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy.  */
name|emit_block_move
argument_list|(
name|dstb
argument_list|,
name|srcb
argument_list|,
name|size
argument_list|,
name|BLOCK_OP_NORMAL
argument_list|)
expr_stmt|;
block|}
return|return
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to one of the builtin functions __builtin_frame_address or    __builtin_return_address.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_frame_address
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
comment|/* The argument must be a nonnegative integer constant.      It counts the number of frames to scan up the stack.      The value is the return address saved in that frame.  */
if|if
condition|(
name|arglist
operator|==
literal|0
condition|)
comment|/* Warning about missing arg was already issued.  */
return|return
name|const0_rtx
return|;
elseif|else
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_FRAME_ADDRESS
condition|)
name|error
argument_list|(
literal|"invalid arg to `__builtin_frame_address'"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid arg to `__builtin_return_address'"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
else|else
block|{
name|rtx
name|tem
init|=
name|expand_builtin_return_addr
argument_list|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|tree_low_cst
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
decl_stmt|;
comment|/* Some ports cannot access arbitrary stack frames.  */
if|if
condition|(
name|tem
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_FRAME_ADDRESS
condition|)
name|warning
argument_list|(
literal|"unsupported arg to `__builtin_frame_address'"
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"unsupported arg to `__builtin_return_address'"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
comment|/* For __builtin_frame_address, return what we've got.  */
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_FRAME_ADDRESS
condition|)
return|return
name|tem
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|tem
argument_list|)
condition|)
name|tem
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to the alloca builtin, with arguments ARGLIST.  Return 0 if    we failed and the caller should emit a normal call, otherwise try to get    the result in TARGET, if convenient.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_alloca
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|;
name|rtx
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Compute the argument.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allocate the desired space.  */
name|result
operator|=
name|allocate_dynamic_stack_space
argument_list|(
name|op0
argument_list|,
name|target
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|result
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to a unary builtin.  The arguments are in ARGLIST.    Return 0 if a normal call should be emitted rather than expanding the    function in-line.  If convenient, the result should be placed in TARGET.    SUBTARGET may be used as the target for computing one of EXP's operands.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_unop
parameter_list|(
name|enum
name|machine_mode
name|target_mode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
parameter_list|,
name|optab
name|op_optab
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Compute the argument.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Compute op, into TARGET if possible.      Set TARGET to wherever the result comes back.  */
name|target
operator|=
name|expand_unop
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|op_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|convert_to_mode
argument_list|(
name|target_mode
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If the string passed to fputs is a constant and is one character    long, we attempt to transform this call into __builtin_fputc().  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_fputs
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|bool
name|unlocked
parameter_list|)
block|{
name|tree
name|len
decl_stmt|,
name|fn
decl_stmt|;
name|tree
name|fn_fputc
init|=
name|unlocked
condition|?
name|implicit_built_in_decls
index|[
name|BUILT_IN_FPUTC_UNLOCKED
index|]
else|:
name|implicit_built_in_decls
index|[
name|BUILT_IN_FPUTC
index|]
decl_stmt|;
name|tree
name|fn_fwrite
init|=
name|unlocked
condition|?
name|implicit_built_in_decls
index|[
name|BUILT_IN_FWRITE_UNLOCKED
index|]
else|:
name|implicit_built_in_decls
index|[
name|BUILT_IN_FWRITE
index|]
decl_stmt|;
comment|/* If the return value is used, or the replacement _DECL isn't      initialized, don't do the transformation.  */
if|if
condition|(
name|target
operator|!=
name|const0_rtx
operator|||
operator|!
name|fn_fputc
operator|||
operator|!
name|fn_fwrite
condition|)
return|return
literal|0
return|;
comment|/* Verify the arguments in the original call.  */
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Get the length of the string passed to fputs.  If the length      can't be determined, punt.  */
if|if
condition|(
operator|!
operator|(
name|len
operator|=
name|c_strlen
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|len
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|compare_tree_int
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* length is 0, delete the call entirely .  */
block|{
comment|/* Evaluate and ignore the argument in case it has            side-effects.  */
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
case|case
literal|0
case|:
comment|/* length is 1, call fputc.  */
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|c_getstr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* New argument list transforming fputs(string, stream) to 	       fputc(string[0], stream).  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fputc
expr_stmt|;
break|break;
block|}
block|}
comment|/* Fall through.  */
case|case
literal|1
case|:
comment|/* length is greater than 1, call fwrite.  */
block|{
name|tree
name|string_arg
decl_stmt|;
comment|/* If optimizing for size keep fputs.  */
if|if
condition|(
name|optimize_size
condition|)
return|return
literal|0
return|;
name|string_arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* New argument list transforming fputs(string, stream) to 	   fwrite(string, 1, len, stream).  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size_one_node
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|string_arg
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fwrite
expr_stmt|;
break|break;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to __builtin_expect.  We return our argument and emit a    NOTE_INSN_EXPECTED_VALUE note.  This is the expansion of __builtin_expect in    a non-jump context.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_expect
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|tree
name|exp
decl_stmt|,
name|c
decl_stmt|;
name|rtx
name|note
decl_stmt|,
name|rtx_c
decl_stmt|;
if|if
condition|(
name|arglist
operator|==
name|NULL_TREE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|const0_rtx
return|;
name|exp
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|c
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|c
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"second arg to `__builtin_expect' must be a constant"
argument_list|)
expr_stmt|;
name|c
operator|=
name|integer_zero_node
expr_stmt|;
block|}
name|target
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Don't bother with expected value notes for integral constants.  */
if|if
condition|(
name|flag_guess_branch_prob
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
comment|/* We do need to force this into a register so that we can be 	 moderately sure to be able to correctly interpret the branch 	 condition later.  */
name|target
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|rtx_c
operator|=
name|expand_expr
argument_list|(
name|c
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|note
operator|=
name|emit_note
argument_list|(
name|NOTE_INSN_EXPECTED_VALUE
argument_list|)
expr_stmt|;
name|NOTE_EXPECTED_VALUE
argument_list|(
name|note
argument_list|)
operator|=
name|gen_rtx_EQ
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|rtx_c
argument_list|)
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Like expand_builtin_expect, except do this in a jump context.  This is    called from do_jump if the conditional is a __builtin_expect.  Return either    a list of insns to emit the jump or NULL if we cannot optimize    __builtin_expect.  We need to optimize this at jump time so that machines    like the PowerPC don't turn the test into a SCC operation, and then jump    based on the test being 0/1.  */
end_comment

begin_function
name|rtx
name|expand_builtin_expect_jump
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|if_false_label
parameter_list|,
name|rtx
name|if_true_label
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|ret
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Only handle __builtin_expect (test, 0) and      __builtin_expect (test, 1).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|arg1
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|insn
decl_stmt|,
name|drop_through_label
decl_stmt|,
name|temp
decl_stmt|;
comment|/* Expand the jump insns.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|arg0
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|ret
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|drop_through_label
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|drop_through_label
operator|&&
name|GET_CODE
argument_list|(
name|drop_through_label
argument_list|)
operator|==
name|NOTE
condition|)
name|drop_through_label
operator|=
name|prev_nonnote_insn
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_through_label
operator|&&
name|GET_CODE
argument_list|(
name|drop_through_label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|drop_through_label
operator|=
name|NULL_RTX
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|if_true_label
condition|)
name|if_true_label
operator|=
name|drop_through_label
expr_stmt|;
if|if
condition|(
operator|!
name|if_false_label
condition|)
name|if_false_label
operator|=
name|drop_through_label
expr_stmt|;
comment|/* Go through and add the expect's to each of the conditional jumps.  */
name|insn
operator|=
name|ret
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|NULL_RTX
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|ifelse
init|=
name|SET_SRC
argument_list|(
name|pc_set
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|then_dest
init|=
name|XEXP
argument_list|(
name|ifelse
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|else_dest
init|=
name|XEXP
argument_list|(
name|ifelse
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|int
name|taken
init|=
operator|-
literal|1
decl_stmt|;
comment|/* First check if we recognize any of the labels.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|then_dest
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|then_dest
argument_list|,
literal|0
argument_list|)
operator|==
name|if_true_label
condition|)
name|taken
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|then_dest
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|then_dest
argument_list|,
literal|0
argument_list|)
operator|==
name|if_false_label
condition|)
name|taken
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|else_dest
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|else_dest
argument_list|,
literal|0
argument_list|)
operator|==
name|if_false_label
condition|)
name|taken
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|else_dest
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|else_dest
argument_list|,
literal|0
argument_list|)
operator|==
name|if_true_label
condition|)
name|taken
operator|=
literal|0
expr_stmt|;
comment|/* Otherwise check where we drop through.  */
elseif|else
if|if
condition|(
name|else_dest
operator|==
name|pc_rtx
condition|)
block|{
if|if
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|NOTE
condition|)
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|any_uncondjump_p
argument_list|(
name|next
argument_list|)
condition|)
name|temp
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pc_set
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|next
expr_stmt|;
comment|/* TEMP is either a CODE_LABEL, NULL_RTX or something 		     else that can't possibly match either target label.  */
if|if
condition|(
name|temp
operator|==
name|if_false_label
condition|)
name|taken
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|==
name|if_true_label
condition|)
name|taken
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|then_dest
operator|==
name|pc_rtx
condition|)
block|{
if|if
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|NOTE
condition|)
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|any_uncondjump_p
argument_list|(
name|next
argument_list|)
condition|)
name|temp
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pc_set
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|if_false_label
condition|)
name|taken
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|==
name|if_true_label
condition|)
name|taken
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|taken
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* If the test is expected to fail, reverse the 		     probabilities.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
name|taken
operator|=
literal|1
operator|-
name|taken
expr_stmt|;
name|predict_insn_def
argument_list|(
name|insn
argument_list|,
name|PRED_BUILTIN_EXPECT
argument_list|,
name|taken
argument_list|)
expr_stmt|;
block|}
block|}
name|insn
operator|=
name|next
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|expand_builtin_trap
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_trap
if|if
condition|(
name|HAVE_trap
condition|)
name|emit_insn
argument_list|(
name|gen_trap
argument_list|()
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|emit_library_call
argument_list|(
name|abort_libfunc
argument_list|,
name|LCT_NORETURN
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand a call to fabs, fabsf or fabsl with arguments ARGLIST.    Return 0 if a normal call should be emitted rather than expanding    the function inline.  If convenient, the result should be placed    in TARGET.  SUBTARGET may be used as the target for computing    the operand.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_fabs
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_abs
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to cabs, cabsf or cabsl with arguments ARGLIST.    Return 0 if a normal call should be emitted rather than expanding    the function inline.  If convenient, the result should be placed    in target.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_cabs
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
if|if
condition|(
name|arglist
operator|==
literal|0
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
name|COMPLEX_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
return|return
literal|0
return|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_complex_abs
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a new constant string literal and return a char* pointer to it.    The STRING_CST value is the LEN characters at STR.  */
end_comment

begin_function
specifier|static
name|tree
name|build_string_literal
parameter_list|(
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|elem
decl_stmt|,
name|index
decl_stmt|,
name|type
decl_stmt|;
name|t
operator|=
name|build_string
argument_list|(
name|len
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|elem
operator|=
name|build_type_variant
argument_list|(
name|char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|index
operator|=
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|len
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_array_type
argument_list|(
name|elem
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|elem
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to printf or printf_unlocked with argument list ARGLIST.    Return 0 if a normal call should be emitted rather than transforming    the function inline.  If convenient, the result should be placed in    TARGET with mode MODE.  UNLOCKED indicates this is a printf_unlocked     call.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_printf
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|bool
name|unlocked
parameter_list|)
block|{
name|tree
name|fn_putchar
init|=
name|unlocked
condition|?
name|implicit_built_in_decls
index|[
name|BUILT_IN_PUTCHAR_UNLOCKED
index|]
else|:
name|implicit_built_in_decls
index|[
name|BUILT_IN_PUTCHAR
index|]
decl_stmt|;
name|tree
name|fn_puts
init|=
name|unlocked
condition|?
name|implicit_built_in_decls
index|[
name|BUILT_IN_PUTS_UNLOCKED
index|]
else|:
name|implicit_built_in_decls
index|[
name|BUILT_IN_PUTS
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt_str
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|fmt
decl_stmt|,
name|arg
decl_stmt|;
comment|/* If the return value is used, don't do the transformation.  */
if|if
condition|(
name|target
operator|!=
name|const0_rtx
condition|)
return|return
literal|0
return|;
comment|/* Verify the required arguments in the original call.  */
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|fmt
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fmt
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* Check whether the format is a literal string constant.  */
name|fmt_str
operator|=
name|c_getstr
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt_str
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* If the format specifier was "%s\n", call __builtin_puts(arg).  */
if|if
condition|(
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
literal|"%s\n"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|arglist
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|fn_puts
expr_stmt|;
block|}
comment|/* If the format specifier was "%c", call __builtin_putchar(arg).  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
literal|"%c"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|arglist
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
literal|0
return|;
name|fn
operator|=
name|fn_putchar
expr_stmt|;
block|}
else|else
block|{
comment|/* We can't handle anything else with % args or %% ... yet.  */
if|if
condition|(
name|strchr
argument_list|(
name|fmt_str
argument_list|,
literal|'%'
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|arglist
condition|)
return|return
literal|0
return|;
comment|/* If the format specifier was "", printf does nothing.  */
if|if
condition|(
name|fmt_str
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|const0_rtx
return|;
comment|/* If the format specifier has length of 1, call putchar.  */
if|if
condition|(
name|fmt_str
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Given printf("c"), (where c is any one character,) 	     convert "c"[0] to an int and pass that to the replacement 	     function.  */
name|arg
operator|=
name|build_int_2
argument_list|(
name|fmt_str
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_putchar
expr_stmt|;
block|}
else|else
block|{
comment|/* If the format specifier was "string\n", call puts("string").  */
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|fmt_str
argument_list|)
decl_stmt|;
if|if
condition|(
name|fmt_str
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* Create a NUL-terminated string that's one char shorter 		 than the original, stripping off the trailing '\n'.  */
name|char
modifier|*
name|newstr
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newstr
argument_list|,
name|fmt_str
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|newstr
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|arg
operator|=
name|build_string_literal
argument_list|(
name|len
argument_list|,
name|newstr
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_puts
expr_stmt|;
block|}
else|else
comment|/* We'd like to arrange to call fputs(string,stdout) here, 	       but we need stdout and don't have a way to get it yet.  */
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to fprintf or fprintf_unlocked with argument list ARGLIST.    Return 0 if a normal call should be emitted rather than transforming    the function inline.  If convenient, the result should be placed in    TARGET with mode MODE.  UNLOCKED indicates this is a fprintf_unlocked     call.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_fprintf
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|bool
name|unlocked
parameter_list|)
block|{
name|tree
name|fn_fputc
init|=
name|unlocked
condition|?
name|implicit_built_in_decls
index|[
name|BUILT_IN_FPUTC_UNLOCKED
index|]
else|:
name|implicit_built_in_decls
index|[
name|BUILT_IN_FPUTC
index|]
decl_stmt|;
name|tree
name|fn_fputs
init|=
name|unlocked
condition|?
name|implicit_built_in_decls
index|[
name|BUILT_IN_FPUTS_UNLOCKED
index|]
else|:
name|implicit_built_in_decls
index|[
name|BUILT_IN_FPUTS
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt_str
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|fmt
decl_stmt|,
name|fp
decl_stmt|,
name|arg
decl_stmt|;
comment|/* If the return value is used, don't do the transformation.  */
if|if
condition|(
name|target
operator|!=
name|const0_rtx
condition|)
return|return
literal|0
return|;
comment|/* Verify the required arguments in the original call.  */
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|fp
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fp
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|fmt
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fmt
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* Check whether the format is a literal string constant.  */
name|fmt_str
operator|=
name|c_getstr
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt_str
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* If the format specifier was "%s", call __builtin_fputs(arg,fp).  */
if|if
condition|(
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
literal|"%s"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|arglist
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fputs
expr_stmt|;
block|}
comment|/* If the format specifier was "%c", call __builtin_fputc(arg,fp).  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
literal|"%c"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|arglist
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fputc
expr_stmt|;
block|}
else|else
block|{
comment|/* We can't handle anything else with % args or %% ... yet.  */
if|if
condition|(
name|strchr
argument_list|(
name|fmt_str
argument_list|,
literal|'%'
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|arglist
condition|)
return|return
literal|0
return|;
comment|/* If the format specifier was "", fprintf does nothing.  */
if|if
condition|(
name|fmt_str
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Evaluate and ignore FILE* argument for side-effects.  */
name|expand_expr
argument_list|(
name|fp
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
comment|/* When "string" doesn't contain %, replace all cases of 	 fprintf(stream,string) with fputs(string,stream).  The fputs 	 builtin will take care of special cases like length == 1.  */
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fmt
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fputs
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
return|return
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand a call to sprintf with argument list ARGLIST.  Return 0 if    a normal call should be emitted rather than expanding the function    inline.  If convenient, the result should be placed in TARGET with    mode MODE.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_sprintf
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|tree
name|orig_arglist
decl_stmt|,
name|dest
decl_stmt|,
name|fmt
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt_str
decl_stmt|;
name|orig_arglist
operator|=
name|arglist
expr_stmt|;
comment|/* Verify the required arguments in the original call.  */
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
literal|0
return|;
name|fmt
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fmt
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* Check whether the format is a literal string constant.  */
name|fmt_str
operator|=
name|c_getstr
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt_str
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* If the format doesn't contain % args or %%, use strcpy.  */
if|if
condition|(
name|strchr
argument_list|(
name|fmt_str
argument_list|,
literal|'%'
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|fn
init|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRCPY
index|]
decl_stmt|;
name|tree
name|exp
decl_stmt|;
if|if
condition|(
name|arglist
operator|||
operator|!
name|fn
condition|)
return|return
literal|0
return|;
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|orig_arglist
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|const0_rtx
condition|)
return|return
name|const0_rtx
return|;
name|exp
operator|=
name|build_int_2
argument_list|(
name|strlen
argument_list|(
name|fmt_str
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exp
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* If the format is "%s", use strcpy if the result isn't used.  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fmt_str
argument_list|,
literal|"%s"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|fn
decl_stmt|,
name|arg
decl_stmt|,
name|len
decl_stmt|;
name|fn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_STRCPY
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|arglist
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|target
operator|!=
name|const0_rtx
condition|)
block|{
name|len
operator|=
name|c_strlen
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
name|TREE_CODE
argument_list|(
name|len
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
block|}
else|else
name|len
operator|=
name|NULL_TREE
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|const0_rtx
condition|)
return|return
name|const0_rtx
return|;
return|return
name|expand_expr
argument_list|(
name|len
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand an expression EXP that calls a built-in function,    with result going to TARGET if that's convenient    (and in mode MODE if that's convenient).    SUBTARGET may be used as the target for computing one of EXP's operands.    IGNORE is nonzero if the value is to be ignored.  */
end_comment

begin_function
name|rtx
name|expand_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|ignore
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|built_in_function
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|target_mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Perform postincrements before expanding builtin functions.  */
name|emit_queue
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_MD
condition|)
return|return
call|(
modifier|*
name|targetm
operator|.
name|expand_builtin
call|)
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|,
name|mode
argument_list|,
name|ignore
argument_list|)
return|;
comment|/* When not optimizing, generate calls to library functions for a certain      set of builtins.  */
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|!
name|CALLED_AS_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|fcode
operator|!=
name|BUILT_IN_ALLOCA
condition|)
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
return|;
comment|/* The built-in function expanders test for target == const0_rtx      to determine whether the function's result will be ignored.  */
if|if
condition|(
name|ignore
condition|)
name|target
operator|=
name|const0_rtx
expr_stmt|;
comment|/* If the result of a pure or const built-in function is ignored, and      none of its arguments are volatile, we can avoid expanding the      built-in call and just evaluate the arguments for side-effects.  */
if|if
condition|(
name|target
operator|==
name|const0_rtx
operator|&&
operator|(
name|DECL_IS_PURE
argument_list|(
name|fndecl
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|fndecl
argument_list|)
operator|)
condition|)
block|{
name|bool
name|volatilep
init|=
name|false
decl_stmt|;
name|tree
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|arglist
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
block|{
name|volatilep
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|volatilep
condition|)
block|{
for|for
control|(
name|arg
operator|=
name|arglist
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
block|}
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|BUILT_IN_ABS
case|:
case|case
name|BUILT_IN_LABS
case|:
case|case
name|BUILT_IN_LLABS
case|:
case|case
name|BUILT_IN_IMAXABS
case|:
comment|/* build_function_call changes these into ABS_EXPR.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|BUILT_IN_FABS
case|:
case|case
name|BUILT_IN_FABSF
case|:
case|case
name|BUILT_IN_FABSL
case|:
name|target
operator|=
name|expand_builtin_fabs
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_CABS
case|:
case|case
name|BUILT_IN_CABSF
case|:
case|case
name|BUILT_IN_CABSL
case|:
if|if
condition|(
name|flag_unsafe_math_optimizations
condition|)
block|{
name|target
operator|=
name|expand_builtin_cabs
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
block|}
break|break;
case|case
name|BUILT_IN_CONJ
case|:
case|case
name|BUILT_IN_CONJF
case|:
case|case
name|BUILT_IN_CONJL
case|:
case|case
name|BUILT_IN_CREAL
case|:
case|case
name|BUILT_IN_CREALF
case|:
case|case
name|BUILT_IN_CREALL
case|:
case|case
name|BUILT_IN_CIMAG
case|:
case|case
name|BUILT_IN_CIMAGF
case|:
case|case
name|BUILT_IN_CIMAGL
case|:
comment|/* expand_tree_builtin changes these into CONJ_EXPR, REALPART_EXPR 	 and IMAGPART_EXPR.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|BUILT_IN_SIN
case|:
case|case
name|BUILT_IN_SINF
case|:
case|case
name|BUILT_IN_SINL
case|:
case|case
name|BUILT_IN_COS
case|:
case|case
name|BUILT_IN_COSF
case|:
case|case
name|BUILT_IN_COSL
case|:
case|case
name|BUILT_IN_EXP
case|:
case|case
name|BUILT_IN_EXPF
case|:
case|case
name|BUILT_IN_EXPL
case|:
case|case
name|BUILT_IN_LOG
case|:
case|case
name|BUILT_IN_LOGF
case|:
case|case
name|BUILT_IN_LOGL
case|:
case|case
name|BUILT_IN_TAN
case|:
case|case
name|BUILT_IN_TANF
case|:
case|case
name|BUILT_IN_TANL
case|:
case|case
name|BUILT_IN_ATAN
case|:
case|case
name|BUILT_IN_ATANF
case|:
case|case
name|BUILT_IN_ATANL
case|:
comment|/* Treat these like sqrt only if unsafe math optimizations are allowed, 	 because of possible accuracy problems.  */
if|if
condition|(
operator|!
name|flag_unsafe_math_optimizations
condition|)
break|break;
case|case
name|BUILT_IN_SQRT
case|:
case|case
name|BUILT_IN_SQRTF
case|:
case|case
name|BUILT_IN_SQRTL
case|:
case|case
name|BUILT_IN_FLOOR
case|:
case|case
name|BUILT_IN_FLOORF
case|:
case|case
name|BUILT_IN_FLOORL
case|:
case|case
name|BUILT_IN_CEIL
case|:
case|case
name|BUILT_IN_CEILF
case|:
case|case
name|BUILT_IN_CEILL
case|:
case|case
name|BUILT_IN_TRUNC
case|:
case|case
name|BUILT_IN_TRUNCF
case|:
case|case
name|BUILT_IN_TRUNCL
case|:
case|case
name|BUILT_IN_ROUND
case|:
case|case
name|BUILT_IN_ROUNDF
case|:
case|case
name|BUILT_IN_ROUNDL
case|:
case|case
name|BUILT_IN_NEARBYINT
case|:
case|case
name|BUILT_IN_NEARBYINTF
case|:
case|case
name|BUILT_IN_NEARBYINTL
case|:
name|target
operator|=
name|expand_builtin_mathfn
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_POW
case|:
case|case
name|BUILT_IN_POWF
case|:
case|case
name|BUILT_IN_POWL
case|:
if|if
condition|(
operator|!
name|flag_unsafe_math_optimizations
condition|)
break|break;
name|target
operator|=
name|expand_builtin_pow
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_ATAN2
case|:
case|case
name|BUILT_IN_ATAN2F
case|:
case|case
name|BUILT_IN_ATAN2L
case|:
if|if
condition|(
operator|!
name|flag_unsafe_math_optimizations
condition|)
break|break;
name|target
operator|=
name|expand_builtin_mathfn_2
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_APPLY_ARGS
case|:
return|return
name|expand_builtin_apply_args
argument_list|()
return|;
comment|/* __builtin_apply (FUNCTION, ARGUMENTS, ARGSIZE) invokes 	 FUNCTION with a copy of the parameters described by 	 ARGUMENTS, and ARGSIZE.  It returns a block of memory 	 allocated on the stack into which is stored all the registers 	 that might possibly be used for returning the result of a 	 function.  ARGUMENTS is the value returned by 	 __builtin_apply_args.  ARGSIZE is the number of bytes of 	 arguments that must be copied.  ??? How should this value be 	 computed?  We'll also need a safe worst case value for varargs 	 functions.  */
case|case
name|BUILT_IN_APPLY
case|:
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
operator|&&
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REFERENCE_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|rtx
name|ops
index|[
literal|3
index|]
decl_stmt|;
for|for
control|(
name|t
operator|=
name|arglist
operator|,
name|i
operator|=
literal|0
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|i
operator|++
control|)
name|ops
index|[
name|i
index|]
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_builtin_apply
argument_list|(
name|ops
index|[
literal|0
index|]
argument_list|,
name|ops
index|[
literal|1
index|]
argument_list|,
name|ops
index|[
literal|2
index|]
argument_list|)
return|;
block|}
comment|/* __builtin_return (RESULT) causes the function to return the 	 value described by RESULT.  RESULT is address of the block of 	 memory returned by __builtin_apply.  */
case|case
name|BUILT_IN_RETURN
case|:
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
name|expand_builtin_return
argument_list|(
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|BUILT_IN_SAVEREGS
case|:
return|return
name|expand_builtin_saveregs
argument_list|()
return|;
case|case
name|BUILT_IN_ARGS_INFO
case|:
return|return
name|expand_builtin_args_info
argument_list|(
name|arglist
argument_list|)
return|;
comment|/* Return the address of the first anonymous stack arg.  */
case|case
name|BUILT_IN_NEXT_ARG
case|:
return|return
name|expand_builtin_next_arg
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_CLASSIFY_TYPE
case|:
return|return
name|expand_builtin_classify_type
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_CONSTANT_P
case|:
return|return
name|expand_builtin_constant_p
argument_list|(
name|arglist
argument_list|,
name|target_mode
argument_list|)
return|;
case|case
name|BUILT_IN_FRAME_ADDRESS
case|:
case|case
name|BUILT_IN_RETURN_ADDRESS
case|:
return|return
name|expand_builtin_frame_address
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
comment|/* Returns the address of the area where the structure is returned.        0 otherwise.  */
case|case
name|BUILT_IN_AGGREGATE_INCOMING_ADDRESS
case|:
if|if
condition|(
name|arglist
operator|!=
literal|0
operator|||
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|const0_rtx
return|;
else|else
return|return
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|BUILT_IN_ALLOCA
case|:
name|target
operator|=
name|expand_builtin_alloca
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FFS
case|:
case|case
name|BUILT_IN_FFSL
case|:
case|case
name|BUILT_IN_FFSLL
case|:
name|target
operator|=
name|expand_builtin_unop
argument_list|(
name|target_mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|,
name|ffs_optab
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_CLZ
case|:
case|case
name|BUILT_IN_CLZL
case|:
case|case
name|BUILT_IN_CLZLL
case|:
name|target
operator|=
name|expand_builtin_unop
argument_list|(
name|target_mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|,
name|clz_optab
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_CTZ
case|:
case|case
name|BUILT_IN_CTZL
case|:
case|case
name|BUILT_IN_CTZLL
case|:
name|target
operator|=
name|expand_builtin_unop
argument_list|(
name|target_mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|,
name|ctz_optab
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_POPCOUNT
case|:
case|case
name|BUILT_IN_POPCOUNTL
case|:
case|case
name|BUILT_IN_POPCOUNTLL
case|:
name|target
operator|=
name|expand_builtin_unop
argument_list|(
name|target_mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|,
name|popcount_optab
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_PARITY
case|:
case|case
name|BUILT_IN_PARITYL
case|:
case|case
name|BUILT_IN_PARITYLL
case|:
name|target
operator|=
name|expand_builtin_unop
argument_list|(
name|target_mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|,
name|parity_optab
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRLEN
case|:
name|target
operator|=
name|expand_builtin_strlen
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|target_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRCPY
case|:
name|target
operator|=
name|expand_builtin_strcpy
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRNCPY
case|:
name|target
operator|=
name|expand_builtin_strncpy
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STPCPY
case|:
name|target
operator|=
name|expand_builtin_stpcpy
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRCAT
case|:
name|target
operator|=
name|expand_builtin_strcat
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRNCAT
case|:
name|target
operator|=
name|expand_builtin_strncat
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRSPN
case|:
name|target
operator|=
name|expand_builtin_strspn
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRCSPN
case|:
name|target
operator|=
name|expand_builtin_strcspn
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRSTR
case|:
name|target
operator|=
name|expand_builtin_strstr
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRPBRK
case|:
name|target
operator|=
name|expand_builtin_strpbrk
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_INDEX
case|:
case|case
name|BUILT_IN_STRCHR
case|:
name|target
operator|=
name|expand_builtin_strchr
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_RINDEX
case|:
case|case
name|BUILT_IN_STRRCHR
case|:
name|target
operator|=
name|expand_builtin_strrchr
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_MEMCPY
case|:
name|target
operator|=
name|expand_builtin_memcpy
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_MEMPCPY
case|:
name|target
operator|=
name|expand_builtin_mempcpy
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
comment|/*endp=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_MEMMOVE
case|:
name|target
operator|=
name|expand_builtin_memmove
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_BCOPY
case|:
name|target
operator|=
name|expand_builtin_bcopy
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_MEMSET
case|:
name|target
operator|=
name|expand_builtin_memset
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_BZERO
case|:
name|target
operator|=
name|expand_builtin_bzero
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRCMP
case|:
name|target
operator|=
name|expand_builtin_strcmp
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_STRNCMP
case|:
name|target
operator|=
name|expand_builtin_strncmp
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_BCMP
case|:
case|case
name|BUILT_IN_MEMCMP
case|:
name|target
operator|=
name|expand_builtin_memcmp
argument_list|(
name|exp
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_SETJMP
case|:
name|target
operator|=
name|expand_builtin_setjmp
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
comment|/* __builtin_longjmp is passed a pointer to an array of five words. 	 It's similar to the C library longjmp function but works with 	 __builtin_setjmp above.  */
case|case
name|BUILT_IN_LONGJMP
case|:
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
break|break;
else|else
block|{
name|rtx
name|buf_addr
init|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|value
init|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|const1_rtx
condition|)
block|{
name|error
argument_list|(
literal|"__builtin_longjmp second argument must be 1"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|expand_builtin_longjmp
argument_list|(
name|buf_addr
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
case|case
name|BUILT_IN_TRAP
case|:
name|expand_builtin_trap
argument_list|()
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|BUILT_IN_PRINTF
case|:
name|target
operator|=
name|expand_builtin_printf
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_PRINTF_UNLOCKED
case|:
name|target
operator|=
name|expand_builtin_printf
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FPUTS
case|:
name|target
operator|=
name|expand_builtin_fputs
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FPUTS_UNLOCKED
case|:
name|target
operator|=
name|expand_builtin_fputs
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FPRINTF
case|:
name|target
operator|=
name|expand_builtin_fprintf
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FPRINTF_UNLOCKED
case|:
name|target
operator|=
name|expand_builtin_fprintf
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_SPRINTF
case|:
name|target
operator|=
name|expand_builtin_sprintf
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
comment|/* Various hooks for the DWARF 2 __throw routine.  */
case|case
name|BUILT_IN_UNWIND_INIT
case|:
name|expand_builtin_unwind_init
argument_list|()
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|BUILT_IN_DWARF_CFA
case|:
return|return
name|virtual_cfa_rtx
return|;
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
case|case
name|BUILT_IN_DWARF_SP_COLUMN
case|:
return|return
name|expand_builtin_dwarf_sp_column
argument_list|()
return|;
case|case
name|BUILT_IN_INIT_DWARF_REG_SIZES
case|:
name|expand_builtin_init_dwarf_reg_sizes
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
endif|#
directive|endif
case|case
name|BUILT_IN_FROB_RETURN_ADDR
case|:
return|return
name|expand_builtin_frob_return_addr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
return|;
case|case
name|BUILT_IN_EXTRACT_RETURN_ADDR
case|:
return|return
name|expand_builtin_extract_return_addr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
return|;
case|case
name|BUILT_IN_EH_RETURN
case|:
name|expand_builtin_eh_return
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
ifdef|#
directive|ifdef
name|EH_RETURN_DATA_REGNO
case|case
name|BUILT_IN_EH_RETURN_DATA_REGNO
case|:
return|return
name|expand_builtin_eh_return_data_regno
argument_list|(
name|arglist
argument_list|)
return|;
endif|#
directive|endif
case|case
name|BUILT_IN_EXTEND_POINTER
case|:
return|return
name|expand_builtin_extend_pointer
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
return|;
case|case
name|BUILT_IN_VA_START
case|:
case|case
name|BUILT_IN_STDARG_START
case|:
return|return
name|expand_builtin_va_start
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_VA_END
case|:
return|return
name|expand_builtin_va_end
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_VA_COPY
case|:
return|return
name|expand_builtin_va_copy
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_EXPECT
case|:
return|return
name|expand_builtin_expect
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|BUILT_IN_PREFETCH
case|:
name|expand_builtin_prefetch
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
default|default:
comment|/* just do library call, if unknown builtin */
if|if
condition|(
operator|!
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|error
argument_list|(
literal|"built-in function `%s' not currently supported"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The switch statement above can drop through to cause the function      to be called normally.  */
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine whether a tree node represents a call to a built-in    function.  If the tree T is a call to a built-in function with    the right number of arguments of the appropriate types, return    the DECL_FUNCTION_CODE of the call, e.g. BUILT_IN_SQRT.    Otherwise the return value is END_BUILTINS.  */
end_comment

begin_function
name|enum
name|built_in_function
name|builtin_mathfn_code
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|fndecl
decl_stmt|,
name|arglist
decl_stmt|,
name|parmlist
decl_stmt|;
name|tree
name|argtype
decl_stmt|,
name|parmtype
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|CALL_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
return|return
name|END_BUILTINS
return|;
name|fndecl
operator|=
name|get_callee_fndecl
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
operator|||
name|DECL_BUILT_IN_CLASS
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_MD
condition|)
return|return
name|END_BUILTINS
return|;
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|parmlist
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|parmlist
condition|;
name|parmlist
operator|=
name|TREE_CHAIN
argument_list|(
name|parmlist
argument_list|)
control|)
block|{
comment|/* If a function doesn't take a variable number of arguments, 	 the last element in the list will have type `void'.  */
name|parmtype
operator|=
name|TREE_VALUE
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
if|if
condition|(
name|arglist
condition|)
return|return
name|END_BUILTINS
return|;
return|return
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
name|END_BUILTINS
return|;
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|argtype
argument_list|)
condition|)
return|return
name|END_BUILTINS
return|;
block|}
elseif|else
if|if
condition|(
name|COMPLEX_FLOAT_TYPE_P
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|COMPLEX_FLOAT_TYPE_P
argument_list|(
name|argtype
argument_list|)
condition|)
return|return
name|END_BUILTINS
return|;
block|}
elseif|else
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|argtype
argument_list|)
condition|)
return|return
name|END_BUILTINS
return|;
block|}
elseif|else
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|argtype
argument_list|)
condition|)
return|return
name|END_BUILTINS
return|;
block|}
else|else
return|return
name|END_BUILTINS
return|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
block|}
comment|/* Variable-length argument list.  */
return|return
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to __builtin_constant_p, if we know it will evaluate to a    constant.  ARGLIST is the argument list of the call.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_constant_p
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
if|if
condition|(
name|arglist
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|arglist
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* We return 1 for a numeric type that's known to be a constant      value at compile-time or for an aggregate type that's a      literal constant.  */
name|STRIP_NOPS
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* If we know this is a constant, emit the constant of one.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arglist
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_CONSTANT
argument_list|(
name|arglist
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arglist
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arglist
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
operator|)
condition|)
return|return
name|integer_one_node
return|;
comment|/* If this expression has side effects, show we don't know it to be a      constant.  Likewise if it's a pointer or aggregate type since in      those case we only want literals, since those are only optimized      when generating RTL, not later.      And finally, if we are compiling an initializer, not code, we      need to return a definite result now; there's not going to be any      more optimization done.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|arglist
argument_list|)
operator|||
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|||
name|cfun
operator|==
literal|0
condition|)
return|return
name|integer_zero_node
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to __builtin_classify_type.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_classify_type
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
if|if
condition|(
name|arglist
operator|==
literal|0
condition|)
return|return
name|build_int_2
argument_list|(
name|no_type_class
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|build_int_2
argument_list|(
name|type_to_class
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to __builtin_inf or __builtin_huge_val.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_inf
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|warn
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|real
decl_stmt|;
if|if
condition|(
operator|!
name|MODE_HAS_INFINITIES
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|warn
condition|)
name|warning
argument_list|(
literal|"target format does not support infinity"
argument_list|)
expr_stmt|;
name|real_inf
argument_list|(
operator|&
name|real
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|real
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold a call to __builtin_nan or __builtin_nans.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_nan
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|real
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|str
operator|=
name|c_getstr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|real_nan
argument_list|(
operator|&
name|real
argument_list|,
name|str
argument_list|,
name|quiet
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|real
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the floating point expression T has an integer value.    We also allow +Inf, -Inf and NaN to be considered integer values.  */
end_comment

begin_function
specifier|static
name|bool
name|integer_valued_real_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FLOAT_EXPR
case|:
return|return
name|true
return|;
case|case
name|ABS_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|integer_valued_real_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|BIND_EXPR
case|:
return|return
name|integer_valued_real_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
return|return
name|integer_valued_real_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|integer_valued_real_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
return|return
name|integer_valued_real_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_valued_real_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
case|case
name|REAL_CST
case|:
if|if
condition|(
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|c
decl_stmt|,
name|cint
decl_stmt|;
name|c
operator|=
name|TREE_REAL_CST
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|real_trunc
argument_list|(
operator|&
name|cint
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
return|return
name|real_identical
argument_list|(
operator|&
name|c
argument_list|,
operator|&
name|cint
argument_list|)
return|;
block|}
case|case
name|NOP_EXPR
case|:
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
return|return
name|integer_valued_real_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
block|}
case|case
name|CALL_EXPR
case|:
switch|switch
condition|(
name|builtin_mathfn_code
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_CEIL
case|:
case|case
name|BUILT_IN_CEILF
case|:
case|case
name|BUILT_IN_CEILL
case|:
case|case
name|BUILT_IN_FLOOR
case|:
case|case
name|BUILT_IN_FLOORF
case|:
case|case
name|BUILT_IN_FLOORL
case|:
case|case
name|BUILT_IN_NEARBYINT
case|:
case|case
name|BUILT_IN_NEARBYINTF
case|:
case|case
name|BUILT_IN_NEARBYINTL
case|:
case|case
name|BUILT_IN_ROUND
case|:
case|case
name|BUILT_IN_ROUNDF
case|:
case|case
name|BUILT_IN_ROUNDL
case|:
case|case
name|BUILT_IN_TRUNC
case|:
case|case
name|BUILT_IN_TRUNCF
case|:
case|case
name|BUILT_IN_TRUNCL
case|:
return|return
name|true
return|;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* EXP is assumed to be builtin call where truncation can be propagated    across (for instance floor((double)f) == (double)floorf (f).    Do the transformation.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_trunc_transparent_mathfn
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|built_in_function
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* Integer rounding functions are idempotent.  */
if|if
condition|(
name|fcode
operator|==
name|builtin_mathfn_code
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|arg
return|;
comment|/* If argument is already integer valued, and we don't need to worry      about setting errno, there's no need to perform rounding.  */
if|if
condition|(
operator|!
name|flag_errno_math
operator|&&
name|integer_valued_real_p
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|arg
return|;
if|if
condition|(
name|optimize
condition|)
block|{
name|tree
name|arg0
init|=
name|strip_float_extensions
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|ftype
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|newtype
init|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|newtype
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|ftype
argument_list|)
operator|&&
operator|(
name|decl
operator|=
name|mathfn_built_in
argument_list|(
name|newtype
argument_list|,
name|fcode
argument_list|)
operator|)
condition|)
block|{
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fold
argument_list|(
name|convert
argument_list|(
name|newtype
argument_list|,
name|arg0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|ftype
argument_list|,
name|build_function_call_expr
argument_list|(
name|decl
argument_list|,
name|arglist
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin cabs, cabsf or cabsl.  FNDECL is the    function's DECL, ARGLIST is the argument list and TYPE is the return    type.  Return NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_cabs
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|arglist
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
name|COMPLEX_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Evaluate cabs of a constant at compile-time.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_REALPART
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|TREE_REALPART
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|,
name|i
decl_stmt|;
name|r
operator|=
name|TREE_REAL_CST
argument_list|(
name|TREE_REALPART
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|TREE_REAL_CST
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|r
argument_list|,
name|MULT_EXPR
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|i
argument_list|,
name|MULT_EXPR
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|r
argument_list|,
name|PLUS_EXPR
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_sqrt
argument_list|(
operator|&
name|r
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|r
argument_list|)
operator|||
operator|!
name|flag_trapping_math
condition|)
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|r
argument_list|)
return|;
block|}
comment|/* If either part is zero, cabs is fabs of the other.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_EXPR
operator|&&
name|real_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_EXPR
operator|&&
name|real_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|flag_unsafe_math_optimizations
condition|)
block|{
name|enum
name|built_in_function
name|fcode
decl_stmt|;
name|tree
name|sqrtfn
decl_stmt|;
name|fcode
operator|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_CABS
condition|)
name|sqrtfn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_SQRT
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_CABSF
condition|)
name|sqrtfn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_SQRTF
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_CABSL
condition|)
name|sqrtfn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_SQRTL
index|]
expr_stmt|;
else|else
name|sqrtfn
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|sqrtfn
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|rpart
decl_stmt|,
name|ipart
decl_stmt|,
name|result
decl_stmt|,
name|arglist
decl_stmt|;
name|arg
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|rpart
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|ipart
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|rpart
operator|=
name|save_expr
argument_list|(
name|rpart
argument_list|)
expr_stmt|;
name|ipart
operator|=
name|save_expr
argument_list|(
name|ipart
argument_list|)
expr_stmt|;
name|result
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|rpart
argument_list|,
name|rpart
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|ipart
argument_list|,
name|ipart
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|sqrtfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin trunc, truncf or truncl.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_trunc
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Optimize trunc of constant value.  */
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|,
name|x
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|x
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|real_trunc
argument_list|(
operator|&
name|r
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|r
argument_list|)
return|;
block|}
return|return
name|fold_trunc_transparent_mathfn
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin floor, floorf or floorl.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_floor
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Optimize floor of constant value.  */
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
name|x
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REAL_VALUE_ISNAN
argument_list|(
name|x
argument_list|)
operator|||
operator|!
name|flag_errno_math
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|real_floor
argument_list|(
operator|&
name|r
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|r
argument_list|)
return|;
block|}
block|}
return|return
name|fold_trunc_transparent_mathfn
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin ceil, ceilf or ceill.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_ceil
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Optimize ceil of constant value.  */
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
name|x
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REAL_VALUE_ISNAN
argument_list|(
name|x
argument_list|)
operator|||
operator|!
name|flag_errno_math
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|real_ceil
argument_list|(
operator|&
name|r
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|r
argument_list|)
return|;
block|}
block|}
return|return
name|fold_trunc_transparent_mathfn
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin ffs, clz, ctz, popcount and parity    and their long and long long variants (i.e. ffsl and ffsll).    Return NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_bitop
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Optimize for constant argument.  */
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|hi
decl_stmt|,
name|width
decl_stmt|,
name|result
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|lo
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|t
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|width
operator|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|lo
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Clear all the bits that are beyond the type's precision.  */
if|if
condition|(
name|width
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|hi
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
name|hi
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|>>
operator|(
name|width
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|lo
operator|&=
operator|~
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_FFS
case|:
case|case
name|BUILT_IN_FFSL
case|:
case|case
name|BUILT_IN_FFSLL
case|:
if|if
condition|(
name|lo
operator|!=
literal|0
condition|)
name|result
operator|=
name|exact_log2
argument_list|(
name|lo
operator|&
operator|-
name|lo
argument_list|)
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|hi
operator|!=
literal|0
condition|)
name|result
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|+
name|exact_log2
argument_list|(
name|hi
operator|&
operator|-
name|hi
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|result
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BUILT_IN_CLZ
case|:
case|case
name|BUILT_IN_CLZL
case|:
case|case
name|BUILT_IN_CLZLL
case|:
if|if
condition|(
name|hi
operator|!=
literal|0
condition|)
name|result
operator|=
name|width
operator|-
name|floor_log2
argument_list|(
name|hi
argument_list|)
operator|-
literal|1
operator|-
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
elseif|else
if|if
condition|(
name|lo
operator|!=
literal|0
condition|)
name|result
operator|=
name|width
operator|-
name|floor_log2
argument_list|(
name|lo
argument_list|)
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|CLZ_DEFINED_VALUE_AT_ZERO
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|result
argument_list|)
condition|)
name|result
operator|=
name|width
expr_stmt|;
break|break;
case|case
name|BUILT_IN_CTZ
case|:
case|case
name|BUILT_IN_CTZL
case|:
case|case
name|BUILT_IN_CTZLL
case|:
if|if
condition|(
name|lo
operator|!=
literal|0
condition|)
name|result
operator|=
name|exact_log2
argument_list|(
name|lo
operator|&
operator|-
name|lo
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hi
operator|!=
literal|0
condition|)
name|result
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|+
name|exact_log2
argument_list|(
name|hi
operator|&
operator|-
name|hi
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|CTZ_DEFINED_VALUE_AT_ZERO
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|result
argument_list|)
condition|)
name|result
operator|=
name|width
expr_stmt|;
break|break;
case|case
name|BUILT_IN_POPCOUNT
case|:
case|case
name|BUILT_IN_POPCOUNTL
case|:
case|case
name|BUILT_IN_POPCOUNTLL
case|:
name|result
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lo
condition|)
name|result
operator|++
operator|,
name|lo
operator|&=
name|lo
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|hi
condition|)
name|result
operator|++
operator|,
name|hi
operator|&=
name|hi
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|BUILT_IN_PARITY
case|:
case|case
name|BUILT_IN_PARITYL
case|:
case|case
name|BUILT_IN_PARITYLL
case|:
name|result
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lo
condition|)
name|result
operator|++
operator|,
name|lo
operator|&=
name|lo
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|hi
condition|)
name|result
operator|++
operator|,
name|hi
operator|&=
name|hi
operator|-
literal|1
expr_stmt|;
name|result
operator|&=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|t
operator|=
name|build_int_2
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return true if EXPR is the real constant contained in VALUE.  */
end_comment

begin_function
specifier|static
name|bool
name|real_dconstp
parameter_list|(
name|tree
name|expr
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|value
parameter_list|)
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|expr
argument_list|)
argument_list|,
operator|*
name|value
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|real_dconstp
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|,
name|value
argument_list|)
operator|&&
name|real_zerop
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of fold_builtin to fold the various logarithmic    functions.  EXP is the CALL_EXPR of a call to a builtin log*    function.  VALUE is the base of the log* function.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_logarithm
parameter_list|(
name|tree
name|exp
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|value
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
specifier|const
name|enum
name|built_in_function
name|fcode
init|=
name|builtin_mathfn_code
argument_list|(
name|arg
argument_list|)
decl_stmt|;
comment|/* Optimize log*(1.0) = 0.0.  */
if|if
condition|(
name|real_onep
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst0
argument_list|)
return|;
comment|/* Optimize logN(N) = 1.0.  If N can't be truncated to MODE          exactly, then only do this if flag_unsafe_math_optimizations.  */
if|if
condition|(
name|exact_real_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|value
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
condition|)
block|{
specifier|const
name|REAL_VALUE_TYPE
name|value_truncate
init|=
name|real_value_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|*
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|real_dconstp
argument_list|(
name|arg
argument_list|,
operator|&
name|value_truncate
argument_list|)
condition|)
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
return|;
block|}
comment|/* Special case, optimize logN(expN(x)) = x.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
operator|(
operator|(
name|value
operator|==
operator|&
name|dconste
operator|&&
operator|(
name|fcode
operator|==
name|BUILT_IN_EXP
operator|||
name|fcode
operator|==
name|BUILT_IN_EXPF
operator|||
name|fcode
operator|==
name|BUILT_IN_EXPL
operator|)
operator|)
operator|||
operator|(
name|value
operator|==
operator|&
name|dconst2
operator|&&
operator|(
name|fcode
operator|==
name|BUILT_IN_EXP2
operator|||
name|fcode
operator|==
name|BUILT_IN_EXP2F
operator|||
name|fcode
operator|==
name|BUILT_IN_EXP2L
operator|)
operator|)
operator|||
operator|(
name|value
operator|==
operator|&
name|dconst10
operator|&&
operator|(
name|fcode
operator|==
name|BUILT_IN_EXP10
operator|||
name|fcode
operator|==
name|BUILT_IN_EXP10F
operator|||
name|fcode
operator|==
name|BUILT_IN_EXP10L
operator|)
operator|)
operator|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Optimize log*(func()) for various exponential functions.  We          want to determine the value "x" and the power "exponent" in          order to transform logN(x**exponent) into exponent*logN(x).  */
if|if
condition|(
name|flag_unsafe_math_optimizations
condition|)
block|{
name|tree
name|exponent
init|=
literal|0
decl_stmt|,
name|x
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|BUILT_IN_EXP
case|:
case|case
name|BUILT_IN_EXPF
case|:
case|case
name|BUILT_IN_EXPL
case|:
comment|/* Prepare to do logN(exp(exponent) -> exponent*logN(e).  */
name|x
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|real_value_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|dconste
argument_list|)
argument_list|)
expr_stmt|;
name|exponent
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUILT_IN_EXP2
case|:
case|case
name|BUILT_IN_EXP2F
case|:
case|case
name|BUILT_IN_EXP2L
case|:
comment|/* Prepare to do logN(exp2(exponent) -> exponent*logN(2).  */
name|x
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst2
argument_list|)
expr_stmt|;
name|exponent
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUILT_IN_EXP10
case|:
case|case
name|BUILT_IN_EXP10F
case|:
case|case
name|BUILT_IN_EXP10L
case|:
case|case
name|BUILT_IN_POW10
case|:
case|case
name|BUILT_IN_POW10F
case|:
case|case
name|BUILT_IN_POW10L
case|:
comment|/* Prepare to do logN(exp10(exponent) -> exponent*logN(10).  */
name|x
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst10
argument_list|)
expr_stmt|;
name|exponent
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUILT_IN_SQRT
case|:
case|case
name|BUILT_IN_SQRTF
case|:
case|case
name|BUILT_IN_SQRTL
case|:
comment|/* Prepare to do logN(sqrt(x) -> 0.5*logN(x).  */
name|x
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|exponent
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|dconsthalf
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUILT_IN_CBRT
case|:
case|case
name|BUILT_IN_CBRTF
case|:
case|case
name|BUILT_IN_CBRTL
case|:
comment|/* Prepare to do logN(cbrt(x) -> (1/3)*logN(x).  */
name|x
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|exponent
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|real_value_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|dconstthird
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUILT_IN_POW
case|:
case|case
name|BUILT_IN_POWF
case|:
case|case
name|BUILT_IN_POWL
case|:
comment|/* Prepare to do logN(pow(x,exponent) -> exponent*logN(x).  */
name|x
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|exponent
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Now perform the optimization.  */
if|if
condition|(
name|x
operator|&&
name|exponent
condition|)
block|{
name|tree
name|logfn
decl_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|logfn
operator|=
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|exponent
argument_list|,
name|logfn
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of fold_builtin to fold the various exponent    functions.  EXP is the CALL_EXPR of a call to a builtin function.    VALUE is the value which will be raised to a power.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_exponent
parameter_list|(
name|tree
name|exp
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|value
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
comment|/* Optimize exp*(0.0) = 1.0.  */
if|if
condition|(
name|real_zerop
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
return|;
comment|/* Optimize expN(1.0) = N.  */
if|if
condition|(
name|real_onep
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|cst
decl_stmt|;
name|real_convert
argument_list|(
operator|&
name|cst
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|cst
argument_list|)
return|;
block|}
comment|/* Attempt to evaluate expN(integer) at compile-time.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|cint
decl_stmt|;
name|REAL_VALUE_TYPE
name|c
decl_stmt|;
name|HOST_WIDE_INT
name|n
decl_stmt|;
name|c
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|n
operator|=
name|real_to_integer
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|real_from_integer
argument_list|(
operator|&
name|cint
argument_list|,
name|VOIDmode
argument_list|,
name|n
argument_list|,
name|n
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_identical
argument_list|(
operator|&
name|c
argument_list|,
operator|&
name|cint
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
name|real_powi
argument_list|(
operator|&
name|x
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|value
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|x
argument_list|)
return|;
block|}
block|}
comment|/* Optimize expN(logN(x)) = x.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
condition|)
block|{
specifier|const
name|enum
name|built_in_function
name|fcode
init|=
name|builtin_mathfn_code
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|value
operator|==
operator|&
name|dconste
operator|&&
operator|(
name|fcode
operator|==
name|BUILT_IN_LOG
operator|||
name|fcode
operator|==
name|BUILT_IN_LOGF
operator|||
name|fcode
operator|==
name|BUILT_IN_LOGL
operator|)
operator|)
operator|||
operator|(
name|value
operator|==
operator|&
name|dconst2
operator|&&
operator|(
name|fcode
operator|==
name|BUILT_IN_LOG2
operator|||
name|fcode
operator|==
name|BUILT_IN_LOG2F
operator|||
name|fcode
operator|==
name|BUILT_IN_LOG2L
operator|)
operator|)
operator|||
operator|(
name|value
operator|==
operator|&
name|dconst10
operator|&&
operator|(
name|fcode
operator|==
name|BUILT_IN_LOG10
operator|||
name|fcode
operator|==
name|BUILT_IN_LOG10F
operator|||
name|fcode
operator|==
name|BUILT_IN_LOG10L
operator|)
operator|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin memcpy.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_memcpy
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the LEN parameter is zero, return DEST.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
return|;
comment|/* If SRC and DEST are the same (and not volatile), return DEST.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|dest
argument_list|,
name|len
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin mempcpy.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_mempcpy
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the LEN parameter is zero, return DEST.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
return|;
comment|/* If SRC and DEST are the same (and not volatile), return DEST+LEN.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|temp
init|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|temp
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|dest
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|temp
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin memmove.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_memmove
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the LEN parameter is zero, return DEST.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
return|;
comment|/* If SRC and DEST are the same (and not volatile), return DEST.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|dest
argument_list|,
name|len
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin strcpy.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_strcpy
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|dest
decl_stmt|,
name|src
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If SRC and DEST are the same (and not volatile), return DEST.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|dest
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin strncpy.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_strncpy
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|src
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the LEN parameter is zero, return DEST.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin memcmp.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_memcmp
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the LEN parameter is zero, return zero.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
condition|)
block|{
name|tree
name|temp
init|=
name|omit_one_operand
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|,
name|arg2
argument_list|)
decl_stmt|;
return|return
name|omit_one_operand
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|temp
argument_list|,
name|arg1
argument_list|)
return|;
block|}
comment|/* If ARG1 and ARG2 are the same (and not volatile), return zero.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|,
name|len
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin strcmp.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_strcmp
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If ARG1 and ARG2 are the same (and not volatile), return zero.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
return|;
name|p1
operator|=
name|c_getstr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|c_getstr
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|&&
name|p2
condition|)
block|{
name|tree
name|temp
decl_stmt|;
specifier|const
name|int
name|i
init|=
name|strcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|temp
operator|=
name|integer_minus_one_node
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|temp
operator|=
name|integer_one_node
expr_stmt|;
else|else
name|temp
operator|=
name|integer_zero_node
expr_stmt|;
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|temp
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fold function call to builtin strncmp.  Return    NULL_TREE if no simplification can be made.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_builtin_strncmp
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
operator|!
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|POINTER_TYPE
argument_list|,
name|INTEGER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the LEN parameter is zero, return zero.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|len
argument_list|)
condition|)
block|{
name|tree
name|temp
init|=
name|omit_one_operand
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|,
name|arg2
argument_list|)
decl_stmt|;
return|return
name|omit_one_operand
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|temp
argument_list|,
name|arg1
argument_list|)
return|;
block|}
comment|/* If ARG1 and ARG2 are the same (and not volatile), return zero.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|,
name|len
argument_list|)
return|;
name|p1
operator|=
name|c_getstr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|c_getstr
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
operator|&&
name|p1
operator|&&
name|p2
condition|)
block|{
name|tree
name|temp
decl_stmt|;
specifier|const
name|int
name|i
init|=
name|strncmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|tree_low_cst
argument_list|(
name|len
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|temp
operator|=
name|integer_minus_one_node
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|temp
operator|=
name|integer_one_node
expr_stmt|;
else|else
name|temp
operator|=
name|integer_zero_node
expr_stmt|;
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|temp
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Used by constant folding to eliminate some builtin calls early.  EXP is    the CALL_EXPR of a call to a builtin function.  */
end_comment

begin_function
name|tree
name|fold_builtin
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_MD
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_CONSTANT_P
case|:
return|return
name|fold_builtin_constant_p
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_CLASSIFY_TYPE
case|:
return|return
name|fold_builtin_classify_type
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|BUILT_IN_STRLEN
case|:
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|POINTER_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|len
init|=
name|c_strlen
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
condition|)
block|{
comment|/* Convert from the internal "sizetype" type to "size_t".  */
if|if
condition|(
name|size_type_node
condition|)
name|len
operator|=
name|convert
argument_list|(
name|size_type_node
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
block|}
break|break;
case|case
name|BUILT_IN_FABS
case|:
case|case
name|BUILT_IN_FABSF
case|:
case|case
name|BUILT_IN_FABSL
case|:
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|BUILT_IN_CABS
case|:
case|case
name|BUILT_IN_CABSF
case|:
case|case
name|BUILT_IN_CABSL
case|:
return|return
name|fold_builtin_cabs
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|type
argument_list|)
return|;
case|case
name|BUILT_IN_SQRT
case|:
case|case
name|BUILT_IN_SQRTF
case|:
case|case
name|BUILT_IN_SQRTL
case|:
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|enum
name|built_in_function
name|fcode
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
comment|/* Optimize sqrt of constant value.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|,
name|x
decl_stmt|;
name|x
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_sqrt
argument_list|(
operator|&
name|r
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|x
argument_list|)
operator|||
operator|(
operator|!
name|flag_trapping_math
operator|&&
operator|!
name|flag_errno_math
operator|)
condition|)
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|r
argument_list|)
return|;
block|}
comment|/* Optimize sqrt(exp(x)) = exp(x*0.5).  */
name|fcode
operator|=
name|builtin_mathfn_code
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
operator|(
name|fcode
operator|==
name|BUILT_IN_EXP
operator|||
name|fcode
operator|==
name|BUILT_IN_EXPF
operator|||
name|fcode
operator|==
name|BUILT_IN_EXPL
operator|)
condition|)
block|{
name|tree
name|expfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|arg
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconsthalf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|expfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
comment|/* Optimize sqrt(pow(x,y)) = pow(|x|,y*0.5).  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
operator|(
name|fcode
operator|==
name|BUILT_IN_POW
operator|||
name|fcode
operator|==
name|BUILT_IN_POWF
operator|||
name|fcode
operator|==
name|BUILT_IN_POWL
operator|)
condition|)
block|{
name|tree
name|powfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|narg1
decl_stmt|;
if|if
condition|(
operator|!
name|tree_expr_nonnegative_p
argument_list|(
name|arg0
argument_list|)
condition|)
name|arg0
operator|=
name|build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|narg1
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconsthalf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg0
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|narg1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|BUILT_IN_SIN
case|:
case|case
name|BUILT_IN_SINF
case|:
case|case
name|BUILT_IN_SINL
case|:
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
comment|/* Optimize sin(0.0) = 0.0.  */
if|if
condition|(
name|real_zerop
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|arg
return|;
block|}
break|break;
case|case
name|BUILT_IN_COS
case|:
case|case
name|BUILT_IN_COSF
case|:
case|case
name|BUILT_IN_COSL
case|:
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
comment|/* Optimize cos(0.0) = 1.0.  */
if|if
condition|(
name|real_zerop
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
return|;
comment|/* Optimize cos(-x) into cos(x).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
block|{
name|tree
name|arglist
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|BUILT_IN_EXP
case|:
case|case
name|BUILT_IN_EXPF
case|:
case|case
name|BUILT_IN_EXPL
case|:
return|return
name|fold_builtin_exponent
argument_list|(
name|exp
argument_list|,
operator|&
name|dconste
argument_list|)
return|;
case|case
name|BUILT_IN_EXP2
case|:
case|case
name|BUILT_IN_EXP2F
case|:
case|case
name|BUILT_IN_EXP2L
case|:
return|return
name|fold_builtin_exponent
argument_list|(
name|exp
argument_list|,
operator|&
name|dconst2
argument_list|)
return|;
case|case
name|BUILT_IN_EXP10
case|:
case|case
name|BUILT_IN_EXP10F
case|:
case|case
name|BUILT_IN_EXP10L
case|:
case|case
name|BUILT_IN_POW10
case|:
case|case
name|BUILT_IN_POW10F
case|:
case|case
name|BUILT_IN_POW10L
case|:
return|return
name|fold_builtin_exponent
argument_list|(
name|exp
argument_list|,
operator|&
name|dconst10
argument_list|)
return|;
case|case
name|BUILT_IN_LOG
case|:
case|case
name|BUILT_IN_LOGF
case|:
case|case
name|BUILT_IN_LOGL
case|:
return|return
name|fold_builtin_logarithm
argument_list|(
name|exp
argument_list|,
operator|&
name|dconste
argument_list|)
return|;
break|break;
case|case
name|BUILT_IN_LOG2
case|:
case|case
name|BUILT_IN_LOG2F
case|:
case|case
name|BUILT_IN_LOG2L
case|:
return|return
name|fold_builtin_logarithm
argument_list|(
name|exp
argument_list|,
operator|&
name|dconst2
argument_list|)
return|;
break|break;
case|case
name|BUILT_IN_LOG10
case|:
case|case
name|BUILT_IN_LOG10F
case|:
case|case
name|BUILT_IN_LOG10L
case|:
return|return
name|fold_builtin_logarithm
argument_list|(
name|exp
argument_list|,
operator|&
name|dconst10
argument_list|)
return|;
break|break;
case|case
name|BUILT_IN_TAN
case|:
case|case
name|BUILT_IN_TANF
case|:
case|case
name|BUILT_IN_TANL
case|:
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|enum
name|built_in_function
name|fcode
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
comment|/* Optimize tan(0.0) = 0.0.  */
if|if
condition|(
name|real_zerop
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|arg
return|;
comment|/* Optimize tan(atan(x)) = x.  */
name|fcode
operator|=
name|builtin_mathfn_code
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
operator|(
name|fcode
operator|==
name|BUILT_IN_ATAN
operator|||
name|fcode
operator|==
name|BUILT_IN_ATANF
operator|||
name|fcode
operator|==
name|BUILT_IN_ATANL
operator|)
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|BUILT_IN_ATAN
case|:
case|case
name|BUILT_IN_ATANF
case|:
case|case
name|BUILT_IN_ATANL
case|:
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
comment|/* Optimize atan(0.0) = 0.0.  */
if|if
condition|(
name|real_zerop
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|arg
return|;
comment|/* Optimize atan(1.0) = pi/4.  */
if|if
condition|(
name|real_onep
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|cst
decl_stmt|;
name|real_convert
argument_list|(
operator|&
name|cst
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|dconstpi
argument_list|)
expr_stmt|;
name|cst
operator|.
name|exp
operator|-=
literal|2
expr_stmt|;
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|cst
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|BUILT_IN_POW
case|:
case|case
name|BUILT_IN_POWF
case|:
case|case
name|BUILT_IN_POWL
case|:
if|if
condition|(
name|validate_arglist
argument_list|(
name|arglist
argument_list|,
name|REAL_TYPE
argument_list|,
name|REAL_TYPE
argument_list|,
name|VOID_TYPE
argument_list|)
condition|)
block|{
name|enum
name|built_in_function
name|fcode
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Optimize pow(1.0,y) = 1.0.  */
if|if
condition|(
name|real_onep
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|c
decl_stmt|;
name|c
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* Optimize pow(x,0.0) = 1.0.  */
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|c
argument_list|,
name|dconst0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* Optimize pow(x,1.0) = x.  */
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|c
argument_list|,
name|dconst1
argument_list|)
condition|)
return|return
name|arg0
return|;
comment|/* Optimize pow(x,-1.0) = 1.0/x.  */
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|c
argument_list|,
name|dconstm1
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* Optimize pow(x,0.5) = sqrt(x).  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|c
argument_list|,
name|dconsthalf
argument_list|)
condition|)
block|{
name|tree
name|sqrtfn
decl_stmt|;
name|fcode
operator|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_POW
condition|)
name|sqrtfn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_SQRT
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_POWF
condition|)
name|sqrtfn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_SQRTF
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_POWL
condition|)
name|sqrtfn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_SQRTL
index|]
expr_stmt|;
else|else
name|sqrtfn
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|sqrtfn
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|arglist
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg0
argument_list|)
decl_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|sqrtfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
comment|/* Attempt to evaluate pow at compile-time.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|cint
decl_stmt|;
name|HOST_WIDE_INT
name|n
decl_stmt|;
name|n
operator|=
name|real_to_integer
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|real_from_integer
argument_list|(
operator|&
name|cint
argument_list|,
name|VOIDmode
argument_list|,
name|n
argument_list|,
name|n
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_identical
argument_list|(
operator|&
name|c
argument_list|,
operator|&
name|cint
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
name|bool
name|inexact
decl_stmt|;
name|x
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|inexact
operator|=
name|real_powi
argument_list|(
operator|&
name|x
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|x
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|||
operator|!
name|inexact
condition|)
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|x
argument_list|)
return|;
block|}
block|}
block|}
comment|/* Optimize pow(exp(x),y) = exp(x*y).  */
name|fcode
operator|=
name|builtin_mathfn_code
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
operator|(
name|fcode
operator|==
name|BUILT_IN_EXP
operator|||
name|fcode
operator|==
name|BUILT_IN_EXPF
operator|||
name|fcode
operator|==
name|BUILT_IN_EXPL
operator|)
condition|)
block|{
name|tree
name|expfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|arg
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|expfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
comment|/* Optimize pow(sqrt(x),y) = pow(x,y*0.5).  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
operator|(
name|fcode
operator|==
name|BUILT_IN_SQRT
operator|||
name|fcode
operator|==
name|BUILT_IN_SQRTF
operator|||
name|fcode
operator|==
name|BUILT_IN_SQRTL
operator|)
condition|)
block|{
name|tree
name|narg0
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|narg1
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconsthalf
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|narg0
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|narg1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
block|}
comment|/* Optimize pow(pow(x,y),z) = pow(x,y*z).  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
operator|(
name|fcode
operator|==
name|BUILT_IN_POW
operator|||
name|fcode
operator|==
name|BUILT_IN_POWF
operator|||
name|fcode
operator|==
name|BUILT_IN_POWL
operator|)
condition|)
block|{
name|tree
name|arg00
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg01
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|narg1
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg01
argument_list|,
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg00
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|narg1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|BUILT_IN_INF
case|:
case|case
name|BUILT_IN_INFF
case|:
case|case
name|BUILT_IN_INFL
case|:
return|return
name|fold_builtin_inf
argument_list|(
name|type
argument_list|,
name|true
argument_list|)
return|;
case|case
name|BUILT_IN_HUGE_VAL
case|:
case|case
name|BUILT_IN_HUGE_VALF
case|:
case|case
name|BUILT_IN_HUGE_VALL
case|:
return|return
name|fold_builtin_inf
argument_list|(
name|type
argument_list|,
name|false
argument_list|)
return|;
case|case
name|BUILT_IN_NAN
case|:
case|case
name|BUILT_IN_NANF
case|:
case|case
name|BUILT_IN_NANL
case|:
return|return
name|fold_builtin_nan
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|,
name|true
argument_list|)
return|;
case|case
name|BUILT_IN_NANS
case|:
case|case
name|BUILT_IN_NANSF
case|:
case|case
name|BUILT_IN_NANSL
case|:
return|return
name|fold_builtin_nan
argument_list|(
name|arglist
argument_list|,
name|type
argument_list|,
name|false
argument_list|)
return|;
case|case
name|BUILT_IN_FLOOR
case|:
case|case
name|BUILT_IN_FLOORF
case|:
case|case
name|BUILT_IN_FLOORL
case|:
return|return
name|fold_builtin_floor
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|BUILT_IN_CEIL
case|:
case|case
name|BUILT_IN_CEILF
case|:
case|case
name|BUILT_IN_CEILL
case|:
return|return
name|fold_builtin_ceil
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|BUILT_IN_TRUNC
case|:
case|case
name|BUILT_IN_TRUNCF
case|:
case|case
name|BUILT_IN_TRUNCL
case|:
return|return
name|fold_builtin_trunc
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|BUILT_IN_ROUND
case|:
case|case
name|BUILT_IN_ROUNDF
case|:
case|case
name|BUILT_IN_ROUNDL
case|:
case|case
name|BUILT_IN_NEARBYINT
case|:
case|case
name|BUILT_IN_NEARBYINTF
case|:
case|case
name|BUILT_IN_NEARBYINTL
case|:
return|return
name|fold_trunc_transparent_mathfn
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|BUILT_IN_FFS
case|:
case|case
name|BUILT_IN_FFSL
case|:
case|case
name|BUILT_IN_FFSLL
case|:
case|case
name|BUILT_IN_CLZ
case|:
case|case
name|BUILT_IN_CLZL
case|:
case|case
name|BUILT_IN_CLZLL
case|:
case|case
name|BUILT_IN_CTZ
case|:
case|case
name|BUILT_IN_CTZL
case|:
case|case
name|BUILT_IN_CTZLL
case|:
case|case
name|BUILT_IN_POPCOUNT
case|:
case|case
name|BUILT_IN_POPCOUNTL
case|:
case|case
name|BUILT_IN_POPCOUNTLL
case|:
case|case
name|BUILT_IN_PARITY
case|:
case|case
name|BUILT_IN_PARITYL
case|:
case|case
name|BUILT_IN_PARITYLL
case|:
return|return
name|fold_builtin_bitop
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|BUILT_IN_MEMCPY
case|:
return|return
name|fold_builtin_memcpy
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|BUILT_IN_MEMPCPY
case|:
return|return
name|fold_builtin_mempcpy
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|BUILT_IN_MEMMOVE
case|:
return|return
name|fold_builtin_memmove
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|BUILT_IN_STRCPY
case|:
return|return
name|fold_builtin_strcpy
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|BUILT_IN_STRNCPY
case|:
return|return
name|fold_builtin_strncpy
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|BUILT_IN_MEMCMP
case|:
return|return
name|fold_builtin_memcmp
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|BUILT_IN_STRCMP
case|:
return|return
name|fold_builtin_strcmp
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|BUILT_IN_STRNCMP
case|:
return|return
name|fold_builtin_strncmp
argument_list|(
name|exp
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Conveniently construct a function call expression.  */
end_comment

begin_function
name|tree
name|build_function_call_expr
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|call_expr
decl_stmt|;
name|call_expr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|call_expr
operator|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|call_expr
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|call_expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function validates the types of a function call argument list    represented as a tree chain of parameters against a specified list    of tree_codes.  If the last specifier is a 0, that represents an    ellipses, otherwise the last specifier must be a VOID_TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|validate_arglist
parameter_list|(
name|tree
name|arglist
parameter_list|,
modifier|...
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
do|do
block|{
name|code
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
expr|enum
name|tree_code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0
case|:
comment|/* This signifies an ellipses, any further arguments are all ok.  */
name|res
operator|=
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
case|case
name|VOID_TYPE
case|:
comment|/* This signifies an endlink, if no arguments remain, return 	     true, otherwise return false.  */
name|res
operator|=
name|arglist
operator|==
literal|0
expr_stmt|;
goto|goto
name|end
goto|;
default|default:
comment|/* If no parameters remain or the parameter's code does not 	     match the specified code, return false.  Otherwise continue 	     checking any remaining arguments.  */
if|if
condition|(
name|arglist
operator|==
literal|0
operator|||
name|code
operator|!=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
condition|)
goto|goto
name|end
goto|;
break|break;
block|}
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
comment|/* We need gotos here since we can only have one VA_CLOSE in a      function.  */
name|end
label|:
empty_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Default target-specific builtin expander that does nothing.  */
end_comment

begin_function
name|rtx
name|default_expand_builtin
parameter_list|(
name|tree
name|exp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|target
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Instantiate all remaining CONSTANT_P_RTX nodes.  */
end_comment

begin_function
name|void
name|purge_builtin_constant_p
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|set
decl_stmt|,
name|arg
decl_stmt|,
name|new
decl_stmt|,
name|note
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|arg
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
operator|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|arg
operator|=
name|SUBREG_REG
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|)
operator|)
operator|)
condition|)
block|{
name|arg
operator|=
name|XEXP
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|=
name|CONSTANT_P
argument_list|(
name|arg
argument_list|)
condition|?
name|const1_rtx
else|:
name|const0_rtx
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Remove the REG_EQUAL note from the insn.  */
if|if
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns true is EXP represents data that would potentially reside    in a readonly section.  */
end_comment

begin_function
specifier|static
name|bool
name|readonly_data_expr
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|STRIP_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
return|return
name|decl_readonly_section
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|false
return|;
block|}
end_function

end_unit

