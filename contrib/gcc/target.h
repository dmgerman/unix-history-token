begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Data structure definitions for a generic GCC target.    Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_comment
comment|/* This file contains a data structure that describes a GCC target.    At present it is incomplete, but in future it should grow to    contain most or all target machine and target O/S specific    information.     This structure has its initializer declared in target-def.h in the    form of large macro TARGET_INITIALIZER that expands to many smaller    macros.     The smaller macros each initialize one component of the structure,    and each has a default.  Each target should have a file that    includes target.h and target-def.h, and overrides any inappropriate    defaults by undefining the relevant macro and defining a suitable    replacement.  That file should then contain the definition of    "targetm" like so:     struct gcc_target targetm = TARGET_INITIALIZER;     Doing things this way allows us to bring together everything that    defines a GCC target.  By supplying a default that is appropriate    to most targets, we can easily add new items without needing to    edit dozens of target configuration files.  It should also allow us    to gradually reduce the amount of conditional compilation that is    scattered throughout GCC.  */
end_comment

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_struct
struct|struct
name|gcc_target
block|{
comment|/* Functions that output assembler for the target.  */
struct|struct
name|asm_out
block|{
comment|/* Opening and closing parentheses for asm expression grouping.  */
specifier|const
name|char
modifier|*
name|open_paren
decl_stmt|,
modifier|*
name|close_paren
decl_stmt|;
comment|/* Assembler instructions for creating various kinds of integer object.  */
specifier|const
name|char
modifier|*
name|byte_op
decl_stmt|;
struct|struct
name|asm_int_op
block|{
specifier|const
name|char
modifier|*
name|hi
decl_stmt|;
specifier|const
name|char
modifier|*
name|si
decl_stmt|;
specifier|const
name|char
modifier|*
name|di
decl_stmt|;
specifier|const
name|char
modifier|*
name|ti
decl_stmt|;
block|}
name|aligned_op
struct|,
name|unaligned_op
struct|;
comment|/* Try to output the assembler code for an integer object whose        value is given by X.  SIZE is the size of the object in bytes and        ALIGNED_P indicates whether it is aligned.  Return true if        successful.  Only handles cases for which BYTE_OP, ALIGNED_OP        and UNALIGNED_OP are NULL.  */
name|bool
function_decl|(
modifier|*
name|integer
function_decl|)
parameter_list|(
name|rtx
name|x
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|int
name|aligned_p
parameter_list|)
function_decl|;
comment|/* Output code that will globalize a label.  */
name|void
function_decl|(
modifier|*
name|globalize_label
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
comment|/* Output an internal label.  */
name|void
function_decl|(
modifier|*
name|internal_label
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
comment|/* Emit an assembler directive to set visibility for the symbol        associated with the tree decl.  */
name|void
function_decl|(
modifier|*
name|visibility
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* Output the assembler code for entry to a function.  */
name|void
function_decl|(
modifier|*
name|function_prologue
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
comment|/* Output the assembler code for end of prologue.  */
name|void
function_decl|(
modifier|*
name|function_end_prologue
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
comment|/* Output the assembler code for start of epilogue.  */
name|void
function_decl|(
modifier|*
name|function_begin_epilogue
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
comment|/* Output the assembler code for function exit.  */
name|void
function_decl|(
modifier|*
name|function_epilogue
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
comment|/* Switch to an arbitrary section NAME with attributes as        specified by FLAGS.  */
name|void
function_decl|(
modifier|*
name|named_section
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
comment|/* Switch to the section that holds the exception table.  */
name|void
function_decl|(
modifier|*
name|exception_section
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Switch to the section that holds the exception frames.  */
name|void
function_decl|(
modifier|*
name|eh_frame_section
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Select and switch to a section for EXP.  It may be a DECL or a        constant.  RELOC is nonzero if runtime relocations must be applied;        bit 1 will be set if the runtime relocations require non-local        name resolution.  ALIGN is the required alignment of the data.  */
name|void
function_decl|(
modifier|*
name|select_section
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
comment|/* Select and switch to a section for X with MODE.  ALIGN is        the desired alignment of the data.  */
name|void
function_decl|(
modifier|*
name|select_rtx_section
function_decl|)
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
comment|/* Select a unique section name for DECL.  RELOC is the same as        for SELECT_SECTION.  */
name|void
function_decl|(
modifier|*
name|unique_section
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* Output a constructor for a symbol with a given priority.  */
name|void
function_decl|(
modifier|*
name|constructor
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* Output a destructor for a symbol with a given priority.  */
name|void
function_decl|(
modifier|*
name|destructor
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* Output the assembler code for a thunk function.  THUNK_DECL is the        declaration for the thunk function itself, FUNCTION is the decl for        the target function.  DELTA is an immediate constant offset to be        added to THIS.  If VCALL_OFFSET is nonzero, the word at        *(*this + vcall_offset) should be added to THIS.  */
name|void
function_decl|(
modifier|*
name|output_mi_thunk
function_decl|)
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|thunk_decl
parameter_list|,
name|HOST_WIDE_INT
name|delta
parameter_list|,
name|HOST_WIDE_INT
name|vcall_offset
parameter_list|,
name|tree
name|function_decl
parameter_list|)
function_decl|;
comment|/* Determine whether output_mi_thunk would succeed.  */
comment|/* ??? Ideally, this hook would not exist, and success or failure        would be returned from output_mi_thunk directly.  But there's        too much undo-able setup involved in invoking output_mi_thunk.        Could be fixed by making output_mi_thunk emit rtl instead of        text to the output file.  */
name|bool
function_decl|(
modifier|*
name|can_output_mi_thunk
function_decl|)
parameter_list|(
name|tree
name|thunk_decl
parameter_list|,
name|HOST_WIDE_INT
name|delta
parameter_list|,
name|HOST_WIDE_INT
name|vcall_offset
parameter_list|,
name|tree
name|function_decl
parameter_list|)
function_decl|;
comment|/* Output any boilerplate text needed at the beginning of a        translation unit.  */
name|void
function_decl|(
modifier|*
name|file_start
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Output any boilerplate text needed at the end of a        translation unit.  */
name|void
function_decl|(
modifier|*
name|file_end
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Output an assembler pseudo-op to declare a library function name        external.  */
name|void
function_decl|(
modifier|*
name|external_libcall
function_decl|)
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
block|}
name|asm_out
struct|;
comment|/* Functions relating to instruction scheduling.  */
struct|struct
name|sched
block|{
comment|/* Given the current cost, COST, of an insn, INSN, calculate and        return a new cost based on its relationship to DEP_INSN through        the dependence LINK.  The default is to make no adjustment.  */
name|int
function_decl|(
modifier|*
name|adjust_cost
function_decl|)
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|link
parameter_list|,
name|rtx
name|def_insn
parameter_list|,
name|int
name|cost
parameter_list|)
function_decl|;
comment|/* Adjust the priority of an insn as you see fit.  Returns the new        priority.  */
name|int
function_decl|(
modifier|*
name|adjust_priority
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* Function which returns the maximum number of insns that can be        scheduled in the same machine cycle.  This must be constant        over an entire compilation.  The default is 1.  */
name|int
function_decl|(
modifier|*
name|issue_rate
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Calculate how much this insn affects how many more insns we        can emit this cycle.  Default is they all cost the same.  */
name|int
function_decl|(
modifier|*
name|variable_issue
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* Initialize machine-dependent scheduling code.  */
name|void
function_decl|(
modifier|*
name|md_init
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* Finalize machine-dependent scheduling code.  */
name|void
function_decl|(
modifier|*
name|md_finish
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* Reorder insns in a machine-dependent fashion, in two different        places.  Default does nothing.  */
name|int
function_decl|(
modifier|*
name|reorder
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|reorder2
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* The following member value is a pointer to a function called        after evaluation forward dependencies of insns in chain given        by two parameter values (head and tail correspondingly).  */
name|void
function_decl|(
modifier|*
name|dependencies_evaluation_hook
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
comment|/* The following member value is a pointer to a function returning        nonzero if we should use DFA based scheduling.  The default is        to use the old pipeline scheduler.  */
name|int
function_decl|(
modifier|*
name|use_dfa_pipeline_interface
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* The values of all the following members are used only for the        DFA based scheduler: */
comment|/* The values of the following four members are pointers to        functions used to simplify the automaton descriptions.        dfa_pre_cycle_insn and dfa_post_cycle_insn give functions        returning insns which are used to change the pipeline hazard        recognizer state when the new simulated processor cycle        correspondingly starts and finishes.  The function defined by        init_dfa_pre_cycle_insn and init_dfa_post_cycle_insn are used        to initialize the corresponding insns.  The default values of        the members result in not changing the automaton state when        the new simulated processor cycle correspondingly starts and        finishes.  */
name|void
function_decl|(
modifier|*
name|init_dfa_pre_cycle_insn
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|rtx
function_decl|(
modifier|*
name|dfa_pre_cycle_insn
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|init_dfa_post_cycle_insn
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|rtx
function_decl|(
modifier|*
name|dfa_post_cycle_insn
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* The following member value is a pointer to a function returning value        which defines how many insns in queue `ready' will we try for        multi-pass scheduling.  if the member value is nonzero and the        function returns positive value, the DFA based scheduler will make        multi-pass scheduling for the first cycle.  In other words, we will        try to choose ready insn which permits to start maximum number of        insns on the same cycle.  */
name|int
function_decl|(
modifier|*
name|first_cycle_multipass_dfa_lookahead
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* The following member value is pointer to a function controlling        what insns from the ready insn queue will be considered for the        multipass insn scheduling.  If the hook returns zero for insn        passed as the parameter, the insn will be not chosen to be        issued.  */
name|int
function_decl|(
modifier|*
name|first_cycle_multipass_dfa_lookahead_guard
function_decl|)
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
comment|/* The following member value is pointer to a function called by        the insn scheduler before issuing insn passed as the third        parameter on given cycle.  If the hook returns nonzero, the        insn is not issued on given processors cycle.  Instead of that,        the processor cycle is advanced.  If the value passed through        the last parameter is zero, the insn ready queue is not sorted        on the new cycle start as usually.  The first parameter passes        file for debugging output.  The second one passes the scheduler        verbose level of the debugging output.  The forth and the fifth        parameter values are correspondingly processor cycle on which        the previous insn has been issued and the current processor        cycle.  */
name|int
function_decl|(
modifier|*
name|dfa_new_cycle
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
comment|/* The values of the following members are pointers to functions        used to improve the first cycle multipass scheduling by        inserting nop insns.  dfa_scheduler_bubble gives a function        returning a nop insn with given index.  The indexes start with        zero.  The function should return NULL if there are no more nop        insns with indexes greater than given index.  To initialize the        nop insn the function given by member        init_dfa_scheduler_bubbles is used.  The default values of the        members result in not inserting nop insns during the multipass        scheduling.  */
name|void
function_decl|(
modifier|*
name|init_dfa_bubbles
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|rtx
function_decl|(
modifier|*
name|dfa_bubble
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
comment|/* The following member value is a pointer to a function called        by the insn scheduler.  It should return true if there exists a        dependence which is considered costly by the target, between         the insn passed as the first parameter, and the insn passed as         the second parameter.  The third parameter is the INSN_DEPEND         link that represents the dependence between the two insns.  The        fourth argument is the cost of the dependence as estimated by        the scheduler.  The last argument is the distance in cycles         between the already scheduled insn (first parameter) and the        the second insn (second parameter).  */
name|bool
function_decl|(
modifier|*
name|is_costly_dependence
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
block|}
name|sched
struct|;
comment|/* Given two decls, merge their attributes and return the result.  */
name|tree
function_decl|(
modifier|*
name|merge_decl_attributes
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
comment|/* Given two types, merge their attributes and return the result.  */
name|tree
function_decl|(
modifier|*
name|merge_type_attributes
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
comment|/* Table of machine attributes and functions to handle them.      Ignored if NULL.  */
specifier|const
name|struct
name|attribute_spec
modifier|*
name|attribute_table
decl_stmt|;
comment|/* Return zero if the attributes on TYPE1 and TYPE2 are incompatible,      one if they are compatible and two if they are nearly compatible      (which causes a warning to be generated).  */
name|int
function_decl|(
modifier|*
name|comp_type_attributes
function_decl|)
parameter_list|(
name|tree
name|type1
parameter_list|,
name|tree
name|type2
parameter_list|)
function_decl|;
comment|/* Assign default attributes to the newly defined TYPE.  */
name|void
function_decl|(
modifier|*
name|set_default_type_attributes
function_decl|)
parameter_list|(
name|tree
name|type
parameter_list|)
function_decl|;
comment|/* Insert attributes on the newly created DECL.  */
name|void
function_decl|(
modifier|*
name|insert_attributes
function_decl|)
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
modifier|*
name|attributes
parameter_list|)
function_decl|;
comment|/* Return true if FNDECL (which has at least one machine attribute)      can be inlined despite its machine attributes, false otherwise.  */
name|bool
function_decl|(
modifier|*
name|function_attribute_inlinable_p
function_decl|)
parameter_list|(
name|tree
name|fndecl
parameter_list|)
function_decl|;
comment|/* Return true if bitfields in RECORD_TYPE should follow the      Microsoft Visual C++ bitfield layout rules.  */
name|bool
function_decl|(
modifier|*
name|ms_bitfield_layout_p
function_decl|)
parameter_list|(
name|tree
name|record_type
parameter_list|)
function_decl|;
comment|/* Set up target-specific built-in functions.  */
name|void
function_decl|(
modifier|*
name|init_builtins
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Expand a target-specific builtin.  */
name|rtx
function_decl|(
modifier|*
name|expand_builtin
function_decl|)
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|ignore
parameter_list|)
function_decl|;
comment|/* For a vendor-specific fundamental TYPE, return a pointer to      a statically-allocated string containing the C++ mangling for      TYPE.  In all other cases, return NULL.  */
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|mangle_fundamental_type
function_decl|)
parameter_list|(
name|tree
name|type
parameter_list|)
function_decl|;
comment|/* Make any adjustments to libfunc names needed for this target.  */
name|void
function_decl|(
modifier|*
name|init_libfuncs
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Given a decl, a section name, and whether the decl initializer      has relocs, choose attributes for the section.  */
comment|/* ??? Should be merged with SELECT_SECTION and UNIQUE_SECTION.  */
name|unsigned
name|int
function_decl|(
modifier|*
name|section_type_flags
function_decl|)
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* True if new jumps cannot be created, to replace existing ones or      not, at the current point in the compilation.  */
name|bool
function_decl|(
modifier|*
name|cannot_modify_jumps_p
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Return a register class for which branch target register      optimizations should be applied.  */
name|int
function_decl|(
modifier|*
name|branch_target_register_class
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Return true if branch target register optimizations should include      callee-saved registers that are not already live during the current      function.  AFTER_PE_GEN is true if prologues and epilogues have      already been generated.  */
name|bool
function_decl|(
modifier|*
name|branch_target_register_callee_saved
function_decl|)
parameter_list|(
name|bool
name|after_pe_gen
parameter_list|)
function_decl|;
comment|/* True if the constant X cannot be placed in the constant pool.  */
name|bool
function_decl|(
modifier|*
name|cannot_force_const_mem
function_decl|)
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
comment|/* True if the insn X cannot be duplicated.  */
name|bool
function_decl|(
modifier|*
name|cannot_copy_insn_p
function_decl|)
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
comment|/* Given an address RTX, undo the effects of LEGITIMIZE_ADDRESS.  */
name|rtx
function_decl|(
modifier|*
name|delegitimize_address
function_decl|)
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
comment|/* True if it is OK to do sibling call optimization for the specified      call expression EXP.  DECL will be the called function, or NULL if      this is an indirect call.  */
name|bool
function_decl|(
modifier|*
name|function_ok_for_sibcall
function_decl|)
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|exp
parameter_list|)
function_decl|;
comment|/* True if EXP should be placed in a "small data" section.  */
name|bool
function_decl|(
modifier|*
name|in_small_data_p
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* True if EXP names an object for which name resolution must resolve      to the current module.  */
name|bool
function_decl|(
modifier|*
name|binds_local_p
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Do something target-specific to record properties of the DECL into      the associated SYMBOL_REF.  */
name|void
function_decl|(
modifier|*
name|encode_section_info
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* Undo the effects of encode_section_info on the symbol string.  */
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|strip_name_encoding
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
comment|/* True if MODE is valid for a pointer in __attribute__((mode("MODE"))).  */
name|bool
function_decl|(
modifier|*
name|valid_pointer_mode
function_decl|)
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
function_decl|;
comment|/* True if a vector is opaque.  */
name|bool
function_decl|(
modifier|*
name|vector_opaque_p
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
comment|/* Compute a (partial) cost for rtx X.  Return true if the complete      cost has been computed, and false if subexpressions should be      scanned.  In either case, *TOTAL contains the cost result.  */
comment|/* Note that CODE and OUTER_CODE ought to be RTX_CODE, but that's      not necessarily defined at this point.  */
name|bool
function_decl|(
modifier|*
name|rtx_costs
function_decl|)
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|outer_code
parameter_list|,
name|int
modifier|*
name|total
parameter_list|)
function_decl|;
comment|/* Compute the cost of X, used as an address.  Never called with      invalid addresses.  */
name|int
function_decl|(
modifier|*
name|address_cost
function_decl|)
parameter_list|(
name|rtx
name|x
parameter_list|)
function_decl|;
comment|/* Given a register, this hook should return a parallel of registers      to represent where to find the register pieces.  Define this hook      if the register and its mode are represented in Dwarf in      non-contiguous locations, or if the register should be      represented in more than one register in Dwarf.  Otherwise, this      hook should return NULL_RTX.  */
name|rtx
function_decl|(
modifier|*
name|dwarf_register_span
function_decl|)
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
comment|/* Fetch the fixed register(s) which hold condition codes, for      targets where it makes sense to look for duplicate assignments to      the condition codes.  This should return true if there is such a      register, false otherwise.  The arguments should be set to the      fixed register numbers.  Up to two condition code registers are      supported.  If there is only one for this target, the int pointed      at by the second argument should be set to -1.  */
name|bool
function_decl|(
modifier|*
name|fixed_condition_code_regs
function_decl|)
parameter_list|(
name|unsigned
name|int
modifier|*
parameter_list|,
name|unsigned
name|int
modifier|*
parameter_list|)
function_decl|;
comment|/* If two condition code modes are compatible, return a condition      code mode which is compatible with both, such that a comparison      done in the returned mode will work for both of the original      modes.  If the condition code modes are not compatible, return      VOIDmode.  */
name|enum
name|machine_mode
function_decl|(
modifier|*
name|cc_modes_compatible
function_decl|)
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
comment|/* Do machine-dependent code transformations.  Called just before      delayed-branch scheduling.  */
name|void
function_decl|(
modifier|*
name|machine_dependent_reorg
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Create the __builtin_va_list type.  */
name|tree
function_decl|(
modifier|*
name|build_builtin_va_list
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Validity-checking routines for PCH files, target-specific.      get_pch_validity returns a pointer to the data to be stored,      and stores the size in its argument.  pch_valid_p gets the same      information back and returns NULL if the PCH is valid,      or an error message if not.   */
name|void
modifier|*
function_decl|(
modifier|*
name|get_pch_validity
function_decl|)
parameter_list|(
name|size_t
modifier|*
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|pch_valid_p
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
comment|/* Functions relating to calls - argument passing, returns, etc.  */
struct|struct
name|calls
block|{
name|bool
function_decl|(
modifier|*
name|promote_function_args
function_decl|)
parameter_list|(
name|tree
name|fntype
parameter_list|)
function_decl|;
name|bool
function_decl|(
modifier|*
name|promote_function_return
function_decl|)
parameter_list|(
name|tree
name|fntype
parameter_list|)
function_decl|;
name|bool
function_decl|(
modifier|*
name|promote_prototypes
function_decl|)
parameter_list|(
name|tree
name|fntype
parameter_list|)
function_decl|;
name|rtx
function_decl|(
modifier|*
name|struct_value_rtx
function_decl|)
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|int
name|incoming
parameter_list|)
function_decl|;
name|bool
function_decl|(
modifier|*
name|return_in_memory
function_decl|)
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|fndecl
parameter_list|)
function_decl|;
name|bool
function_decl|(
modifier|*
name|return_in_msb
function_decl|)
parameter_list|(
name|tree
name|type
parameter_list|)
function_decl|;
name|rtx
function_decl|(
modifier|*
name|expand_builtin_saveregs
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Returns pretend_argument_size.  */
name|void
function_decl|(
modifier|*
name|setup_incoming_varargs
function_decl|)
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|ca
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
modifier|*
name|pretend_arg_size
parameter_list|,
name|int
name|second_time
parameter_list|)
function_decl|;
name|bool
function_decl|(
modifier|*
name|strict_argument_naming
function_decl|)
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|ca
parameter_list|)
function_decl|;
comment|/* Returns true if we should use SETUP_INCOMING_VARARGS and/or        targetm.calls.strict_argument_naming().  */
name|bool
function_decl|(
modifier|*
name|pretend_outgoing_varargs_named
function_decl|)
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|ca
parameter_list|)
function_decl|;
comment|/* Given a complex type T, return true if a parameter of type T        should be passed as two scalars.  */
name|bool
function_decl|(
modifier|*
name|split_complex_arg
function_decl|)
parameter_list|(
name|tree
name|type
parameter_list|)
function_decl|;
block|}
name|calls
struct|;
comment|/* Leave the boolean fields at the end.  */
comment|/* True if arbitrary sections are supported.  */
name|bool
name|have_named_sections
decl_stmt|;
comment|/* True if "native" constructors and destructors are supported,      false if we're using collect2 for the job.  */
name|bool
name|have_ctors_dtors
decl_stmt|;
comment|/* True if thread-local storage is supported.  */
name|bool
name|have_tls
decl_stmt|;
comment|/* True if a small readonly data section is supported.  */
name|bool
name|have_srodata_section
decl_stmt|;
comment|/* True if EH frame info sections should be zero-terminated.  */
name|bool
name|terminate_dw2_eh_frame_info
decl_stmt|;
comment|/* True if #NO_APP should be emitted at the beginning of      assembly output.  */
name|bool
name|file_start_app_off
decl_stmt|;
comment|/* True if output_file_directive should be called for main_input_filename      at the beginning of assembly output.  */
name|bool
name|file_start_file_directive
decl_stmt|;
comment|/* Leave the boolean fields at the end.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|gcc_target
name|targetm
decl_stmt|;
end_decl_stmt

end_unit

