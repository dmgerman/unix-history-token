begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic hooks for the RTL middle-end.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"rtlhooks-def.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* For speed, we will copy the RTX hooks struct member-by-member    instead of doing indirect calls.  For these reason, we initialize    *two* struct rtl_hooks globals: rtl_hooks is the one that is used    to actually call the hooks, while general_rtl_hooks is used    to restore the hooks by passes that modify them.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|rtl_hooks
name|general_rtl_hooks
init|=
name|RTL_HOOKS_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rtl_hooks
name|rtl_hooks
init|=
name|RTL_HOOKS_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_function
name|rtx
name|gen_lowpart_general
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|result
init|=
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
comment|/* If it's a REG, it must be a hard reg that's not valid in MODE.  */
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
comment|/* Or we could have a subreg of a floating point value.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|result
operator|=
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|copy_to_reg
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|result
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* The only additional case we can do is MEM.  */
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The following exposes the use of "x" to CSE.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
name|SCALAR_INT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|no_new_pseudos
condition|)
return|return
name|gen_lowpart_general
argument_list|(
name|mode
argument_list|,
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|-
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
comment|/* Adjust the address so that the address-after-the-data 	   is unchanged.  */
name|offset
operator|-=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
return|return
name|adjust_address
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Similar to gen_lowpart, but cannot emit any instruction via    copy_to_reg or force_reg.  Mainly used in simplify-rtx.c.  */
end_comment

begin_function
name|rtx
name|gen_lowpart_no_emit_general
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|result
init|=
name|gen_lowpart_if_possible
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
else|else
return|return
name|x
return|;
block|}
end_function

begin_function
name|rtx
name|reg_num_sign_bit_copies_general
parameter_list|(
name|rtx
name|x
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|known_x
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|known_mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|known_ret
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
modifier|*
name|result
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|rtx
name|reg_nonzero_bits_general
parameter_list|(
name|rtx
name|x
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|known_x
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|known_mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|known_ret
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|nonzero
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|bool
name|reg_truncated_to_mode_general
parameter_list|(
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Assuming that X is an rtx (e.g., MEM, REG or SUBREG) for a fixed-point    number, return an rtx (MEM, SUBREG, or CONST_INT) that refers to the    least-significant part of X.    MODE specifies how big a part of X to return.     If the requested operation cannot be done, 0 is returned.     This is similar to gen_lowpart_general.  */
end_comment

begin_function
name|rtx
name|gen_lowpart_if_possible
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|result
init|=
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* This is the only other case we handle.  */
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|new
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|-
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
comment|/* Adjust the address so that the address-after-the-data is 	   unchanged.  */
name|offset
operator|-=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|new
operator|=
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|new
return|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
return|return
name|gen_lowpart_SUBREG
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

end_unit

