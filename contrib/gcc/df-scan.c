begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* FIXME: We need to go back and add the warning messages about code    moved across setjmp.  */
end_comment

begin_comment
comment|/* Scanning of rtl for dataflow analysis.    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.    Originally contributed by Michael P. Hayes               (m.hayes@elec.canterbury.ac.nz, mhayes@redhat.com)    Major rewrite contributed by Danny Berlin (dberlin@dberlin.org)              and Kenneth Zadeck (zadeck@naturalbridge.com).  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"alloc-pool.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"sbitmap.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_include
include|#
directive|include
file|"df.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_epilogue
end_ifndef

begin_define
define|#
directive|define
name|HAVE_epilogue
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_prologue
end_ifndef

begin_define
define|#
directive|define
name|HAVE_prologue
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_sibcall_epilogue
end_ifndef

begin_define
define|#
directive|define
name|HAVE_sibcall_epilogue
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EPILOGUE_USES
end_ifndef

begin_define
define|#
directive|define
name|EPILOGUE_USES
parameter_list|(
name|REGNO
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The bitmap_obstack is used to hold some static variables that    should not be reset after each function is compiled.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap_obstack
name|persistent_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The set of hard registers in eliminables[i].from. */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|elim_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is a bitmap copy of regs_invalidated_by_call so that we can    easily add it into bitmaps, etc. */
end_comment

begin_decl_stmt
name|bitmap
name|df_invalidated_by_call
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize ur_in and ur_out as if all hard registers were partially    available.  */
end_comment

begin_function_decl
specifier|static
name|void
name|df_ref_record
parameter_list|(
name|struct
name|dataflow
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|basic_block
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|df_ref_type
parameter_list|,
name|enum
name|df_ref_flags
parameter_list|,
name|bool
name|record_live
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|df_def_record_1
parameter_list|(
name|struct
name|dataflow
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|basic_block
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|df_ref_flags
parameter_list|,
name|bool
name|record_live
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|df_defs_record
parameter_list|(
name|struct
name|dataflow
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|basic_block
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|df_uses_record
parameter_list|(
name|struct
name|dataflow
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|enum
name|df_ref_type
parameter_list|,
name|basic_block
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|df_ref_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|df_insn_refs_record
parameter_list|(
name|struct
name|dataflow
modifier|*
parameter_list|,
name|basic_block
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|df_bb_refs_record
parameter_list|(
name|struct
name|dataflow
modifier|*
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|df_refs_record
parameter_list|(
name|struct
name|dataflow
modifier|*
parameter_list|,
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|df_ref
modifier|*
name|df_ref_create_structure
parameter_list|(
name|struct
name|dataflow
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|basic_block
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|df_ref_type
parameter_list|,
name|enum
name|df_ref_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|df_record_entry_block_defs
parameter_list|(
name|struct
name|dataflow
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|df_record_exit_block_uses
parameter_list|(
name|struct
name|dataflow
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|df_grow_reg_info
parameter_list|(
name|struct
name|dataflow
modifier|*
parameter_list|,
name|struct
name|df_ref_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|df_grow_ref_info
parameter_list|(
name|struct
name|df_ref_info
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|df_grow_insn_info
parameter_list|(
name|struct
name|df
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------------    SCANNING DATAFLOW PROBLEM     There are several ways in which scanning looks just like the other    dataflow problems.  It shares the all the mechanisms for local info    as well as basic block info.  Where it differs is when and how often    it gets run.  It also has no need for the iterative solver. ----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Problem data for the scanning dataflow function.  */
end_comment

begin_struct
struct|struct
name|df_scan_problem_data
block|{
name|alloc_pool
name|ref_pool
decl_stmt|;
name|alloc_pool
name|insn_pool
decl_stmt|;
name|alloc_pool
name|reg_pool
decl_stmt|;
name|alloc_pool
name|mw_reg_pool
decl_stmt|;
name|alloc_pool
name|mw_link_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|df_scan_bb_info
modifier|*
name|df_scan_bb_info_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|df_scan_free_internal
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|struct
name|df_scan_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_scan_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
name|free
argument_list|(
name|df
operator|->
name|def_info
operator|.
name|regs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|df
operator|->
name|def_info
operator|.
name|refs
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|df
operator|->
name|def_info
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|df_ref_info
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|df
operator|->
name|use_info
operator|.
name|regs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|df
operator|->
name|use_info
operator|.
name|refs
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|df
operator|->
name|use_info
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|df_ref_info
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|df
operator|->
name|insns
argument_list|)
expr_stmt|;
name|df
operator|->
name|insns
operator|=
name|NULL
expr_stmt|;
name|df
operator|->
name|insns_size
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|dflow
operator|->
name|block_info
argument_list|)
expr_stmt|;
name|dflow
operator|->
name|block_info
operator|=
name|NULL
expr_stmt|;
name|dflow
operator|->
name|block_info_size
operator|=
literal|0
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|df
operator|->
name|hardware_regs_used
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|df
operator|->
name|entry_block_defs
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|df
operator|->
name|exit_block_uses
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|problem_data
operator|->
name|ref_pool
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|problem_data
operator|->
name|insn_pool
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|problem_data
operator|->
name|reg_pool
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|problem_data
operator|->
name|mw_reg_pool
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|problem_data
operator|->
name|mw_link_pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get basic block info.  */
end_comment

begin_function
name|struct
name|df_scan_bb_info
modifier|*
name|df_scan_get_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|index
operator|<
name|dflow
operator|->
name|block_info_size
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|df_scan_bb_info
operator|*
operator|)
name|dflow
operator|->
name|block_info
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Set basic block info.  */
end_comment

begin_function
specifier|static
name|void
name|df_scan_set_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|struct
name|df_scan_bb_info
modifier|*
name|bb_info
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|index
operator|<
name|dflow
operator|->
name|block_info_size
argument_list|)
expr_stmt|;
name|dflow
operator|->
name|block_info
index|[
name|index
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|bb_info
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free basic block info.  */
end_comment

begin_function
specifier|static
name|void
name|df_scan_free_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|void
modifier|*
name|vbb_info
parameter_list|)
block|{
name|struct
name|df_scan_bb_info
modifier|*
name|bb_info
init|=
operator|(
expr|struct
name|df_scan_bb_info
operator|*
operator|)
name|vbb_info
decl_stmt|;
if|if
condition|(
name|bb_info
condition|)
block|{
name|df_bb_refs_delete
argument_list|(
name|dflow
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|pool_free
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|,
name|bb_info
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate the problem data for the scanning problem.  This should be    called when the problem is created or when the entire function is to    be rescanned.  */
end_comment

begin_function
specifier|static
name|void
name|df_scan_alloc
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|blocks_to_rescan
parameter_list|,
name|bitmap
name|all_blocks
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|struct
name|df_scan_problem_data
modifier|*
name|problem_data
decl_stmt|;
name|unsigned
name|int
name|insn_num
init|=
name|get_max_uid
argument_list|()
operator|+
literal|1
decl_stmt|;
name|unsigned
name|int
name|block_size
init|=
literal|50
decl_stmt|;
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* Given the number of pools, this is really faster than tearing      everything apart.  */
if|if
condition|(
name|dflow
operator|->
name|problem_data
condition|)
name|df_scan_free_internal
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
name|dflow
operator|->
name|block_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"df_scan_block pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|df_scan_bb_info
argument_list|)
argument_list|,
name|block_size
argument_list|)
expr_stmt|;
name|problem_data
operator|=
name|XNEW
argument_list|(
expr|struct
name|df_scan_problem_data
argument_list|)
expr_stmt|;
name|dflow
operator|->
name|problem_data
operator|=
name|problem_data
expr_stmt|;
name|problem_data
operator|->
name|ref_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"df_scan_ref pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|df_ref
argument_list|)
argument_list|,
name|block_size
argument_list|)
expr_stmt|;
name|problem_data
operator|->
name|insn_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"df_scan_insn pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|df_insn_info
argument_list|)
argument_list|,
name|block_size
argument_list|)
expr_stmt|;
name|problem_data
operator|->
name|reg_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"df_scan_reg pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|df_reg_info
argument_list|)
argument_list|,
name|block_size
argument_list|)
expr_stmt|;
name|problem_data
operator|->
name|mw_reg_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"df_scan_mw_reg pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|df_mw_hardreg
argument_list|)
argument_list|,
name|block_size
argument_list|)
expr_stmt|;
name|problem_data
operator|->
name|mw_link_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"df_scan_mw_link pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|df_link
argument_list|)
argument_list|,
name|block_size
argument_list|)
expr_stmt|;
name|insn_num
operator|+=
name|insn_num
operator|/
literal|4
expr_stmt|;
name|df_grow_reg_info
argument_list|(
name|dflow
argument_list|,
operator|&
name|df
operator|->
name|def_info
argument_list|)
expr_stmt|;
name|df_grow_ref_info
argument_list|(
operator|&
name|df
operator|->
name|def_info
argument_list|,
name|insn_num
argument_list|)
expr_stmt|;
name|df_grow_reg_info
argument_list|(
name|dflow
argument_list|,
operator|&
name|df
operator|->
name|use_info
argument_list|)
expr_stmt|;
name|df_grow_ref_info
argument_list|(
operator|&
name|df
operator|->
name|use_info
argument_list|,
name|insn_num
operator|*
literal|2
argument_list|)
expr_stmt|;
name|df_grow_insn_info
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|df_grow_bb_info
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks_to_rescan
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|df_scan_bb_info
modifier|*
name|bb_info
init|=
name|df_scan_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bb_info
condition|)
block|{
name|bb_info
operator|=
operator|(
expr|struct
name|df_scan_bb_info
operator|*
operator|)
name|pool_alloc
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|)
expr_stmt|;
name|df_scan_set_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|,
name|bb_info
argument_list|)
expr_stmt|;
block|}
name|bb_info
operator|->
name|artificial_defs
operator|=
name|NULL
expr_stmt|;
name|bb_info
operator|->
name|artificial_uses
operator|=
name|NULL
expr_stmt|;
block|}
name|df
operator|->
name|hardware_regs_used
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|df
operator|->
name|entry_block_defs
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|df
operator|->
name|exit_block_uses
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all of the data associated with the scan problem.  */
end_comment

begin_function
specifier|static
name|void
name|df_scan_free
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
if|if
condition|(
name|dflow
operator|->
name|problem_data
condition|)
block|{
name|df_scan_free_internal
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dflow
operator|->
name|problem_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|df
operator|->
name|blocks_to_scan
condition|)
name|BITMAP_FREE
argument_list|(
name|df
operator|->
name|blocks_to_scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|blocks_to_analyze
condition|)
name|BITMAP_FREE
argument_list|(
name|df
operator|->
name|blocks_to_analyze
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|df_scan_dump
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
name|ATTRIBUTE_UNUSED
parameter_list|,
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  invalidated by call \t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|df_invalidated_by_call
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  hardware regs used \t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|df
operator|->
name|hardware_regs_used
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  entry block uses \t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|df
operator|->
name|entry_block_defs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  exit block uses \t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|df
operator|->
name|exit_block_uses
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  regs ever live \t"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|df_problem
name|problem_SCAN
init|=
block|{
name|DF_SCAN
block|,
comment|/* Problem id.  */
name|DF_NONE
block|,
comment|/* Direction.  */
name|df_scan_alloc
block|,
comment|/* Allocate the problem specific data.  */
name|NULL
block|,
comment|/* Reset global information.  */
name|df_scan_free_bb_info
block|,
comment|/* Free basic block info.  */
name|NULL
block|,
comment|/* Local compute function.  */
name|NULL
block|,
comment|/* Init the solution specific data.  */
name|NULL
block|,
comment|/* Iterative solver.  */
name|NULL
block|,
comment|/* Confluence operator 0.  */
name|NULL
block|,
comment|/* Confluence operator n.  */
name|NULL
block|,
comment|/* Transfer function.  */
name|NULL
block|,
comment|/* Finalize function.  */
name|df_scan_free
block|,
comment|/* Free all of the problem information.  */
name|df_scan_dump
block|,
comment|/* Debugging.  */
name|NULL
block|,
comment|/* Dependent problem.  */
literal|0
comment|/* Changeable flags.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a new DATAFLOW instance and add it to an existing instance    of DF.  The returned structure is what is used to get at the    solution.  */
end_comment

begin_function
name|struct
name|dataflow
modifier|*
name|df_scan_add_problem
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|df_add_problem
argument_list|(
name|df
argument_list|,
operator|&
name|problem_SCAN
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------    Storage Allocation Utilities ----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* First, grow the reg_info information.  If the current size is less than    the number of psuedos, grow to 25% more than the number of    pseudos.       Second, assure that all of the slots up to max_reg_num have been    filled with reg_info structures.  */
end_comment

begin_function
specifier|static
name|void
name|df_grow_reg_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|struct
name|df_ref_info
modifier|*
name|ref_info
parameter_list|)
block|{
name|unsigned
name|int
name|max_reg
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|new_size
init|=
name|max_reg
decl_stmt|;
name|struct
name|df_scan_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_scan_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ref_info
operator|->
name|regs_size
operator|<
name|new_size
condition|)
block|{
name|new_size
operator|+=
name|new_size
operator|/
literal|4
expr_stmt|;
name|ref_info
operator|->
name|regs
operator|=
name|xrealloc
argument_list|(
name|ref_info
operator|->
name|regs
argument_list|,
name|new_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|df_reg_info
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ref_info
operator|->
name|regs_size
operator|=
name|new_size
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|ref_info
operator|->
name|regs_inited
init|;
name|i
operator|<
name|max_reg
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|df_reg_info
modifier|*
name|reg_info
init|=
name|pool_alloc
argument_list|(
name|problem_data
operator|->
name|reg_pool
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|reg_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|df_reg_info
argument_list|)
argument_list|)
expr_stmt|;
name|ref_info
operator|->
name|regs
index|[
name|i
index|]
operator|=
name|reg_info
expr_stmt|;
block|}
name|ref_info
operator|->
name|regs_inited
operator|=
name|max_reg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Grow the ref information.  */
end_comment

begin_function
specifier|static
name|void
name|df_grow_ref_info
parameter_list|(
name|struct
name|df_ref_info
modifier|*
name|ref_info
parameter_list|,
name|unsigned
name|int
name|new_size
parameter_list|)
block|{
if|if
condition|(
name|ref_info
operator|->
name|refs_size
operator|<
name|new_size
condition|)
block|{
name|ref_info
operator|->
name|refs
operator|=
name|xrealloc
argument_list|(
name|ref_info
operator|->
name|refs
argument_list|,
name|new_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|df_ref
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ref_info
operator|->
name|refs
operator|+
name|ref_info
operator|->
name|refs_size
argument_list|,
literal|0
argument_list|,
operator|(
name|new_size
operator|-
name|ref_info
operator|->
name|refs_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|df_ref
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ref_info
operator|->
name|refs_size
operator|=
name|new_size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Grow the ref information.  If the current size is less than the    number of instructions, grow to 25% more than the number of    instructions.  */
end_comment

begin_function
specifier|static
name|void
name|df_grow_insn_info
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|)
block|{
name|unsigned
name|int
name|new_size
init|=
name|get_max_uid
argument_list|()
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|df
operator|->
name|insns_size
operator|<
name|new_size
condition|)
block|{
name|new_size
operator|+=
name|new_size
operator|/
literal|4
expr_stmt|;
name|df
operator|->
name|insns
operator|=
name|xrealloc
argument_list|(
name|df
operator|->
name|insns
argument_list|,
name|new_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|df_insn_info
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|df
operator|->
name|insns
operator|+
name|df
operator|->
name|insns_size
argument_list|,
literal|0
argument_list|,
operator|(
name|new_size
operator|-
name|df
operator|->
name|insns_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|df_insn_info
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|df
operator|->
name|insns_size
operator|=
name|new_size
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------------    PUBLIC INTERFACES FOR SMALL GRAIN CHANGES TO SCANNING. ----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Rescan some BLOCKS or all the blocks defined by the last call to    df_set_blocks if BLOCKS is NULL);  */
end_comment

begin_function
name|void
name|df_rescan_blocks
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|bitmap
name|blocks
parameter_list|)
block|{
name|bitmap
name|local_blocks_to_scan
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|struct
name|dataflow
modifier|*
name|dflow
init|=
name|df
operator|->
name|problems_by_index
index|[
name|DF_SCAN
index|]
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|df
operator|->
name|def_info
operator|.
name|refs_organized
operator|=
name|false
expr_stmt|;
name|df
operator|->
name|use_info
operator|.
name|refs_organized
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|blocks
condition|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|bool
name|cleared_bits
init|=
name|false
decl_stmt|;
comment|/* Need to assure that there are space in all of the tables.  */
name|unsigned
name|int
name|insn_num
init|=
name|get_max_uid
argument_list|()
operator|+
literal|1
decl_stmt|;
name|insn_num
operator|+=
name|insn_num
operator|/
literal|4
expr_stmt|;
name|df_grow_reg_info
argument_list|(
name|dflow
argument_list|,
operator|&
name|df
operator|->
name|def_info
argument_list|)
expr_stmt|;
name|df_grow_ref_info
argument_list|(
operator|&
name|df
operator|->
name|def_info
argument_list|,
name|insn_num
argument_list|)
expr_stmt|;
name|df_grow_reg_info
argument_list|(
name|dflow
argument_list|,
operator|&
name|df
operator|->
name|use_info
argument_list|)
expr_stmt|;
name|df_grow_ref_info
argument_list|(
operator|&
name|df
operator|->
name|use_info
argument_list|,
name|insn_num
operator|*
literal|2
argument_list|)
expr_stmt|;
name|df_grow_insn_info
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|df_grow_bb_info
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
name|bitmap_copy
argument_list|(
name|local_blocks_to_scan
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|bb_index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bb
condition|)
block|{
name|bitmap_clear_bit
argument_list|(
name|local_blocks_to_scan
argument_list|,
name|bb_index
argument_list|)
expr_stmt|;
name|cleared_bits
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cleared_bits
condition|)
name|bitmap_copy
argument_list|(
name|blocks
argument_list|,
name|local_blocks_to_scan
argument_list|)
expr_stmt|;
name|df
operator|->
name|def_info
operator|.
name|add_refs_inline
operator|=
name|true
expr_stmt|;
name|df
operator|->
name|use_info
operator|.
name|add_refs_inline
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
name|df
operator|->
name|num_problems_defined
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|bitmap
name|blocks_to_reset
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dflow
operator|->
name|problem
operator|->
name|reset_fun
condition|)
block|{
if|if
condition|(
operator|!
name|blocks_to_reset
condition|)
block|{
name|blocks_to_reset
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bitmap_copy
argument_list|(
name|blocks_to_reset
argument_list|,
name|local_blocks_to_scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|blocks_to_scan
condition|)
name|bitmap_ior_into
argument_list|(
name|blocks_to_reset
argument_list|,
name|df
operator|->
name|blocks_to_scan
argument_list|)
expr_stmt|;
block|}
name|dflow
operator|->
name|problem
operator|->
name|reset_fun
argument_list|(
name|dflow
argument_list|,
name|blocks_to_reset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|blocks_to_reset
condition|)
name|BITMAP_FREE
argument_list|(
name|blocks_to_reset
argument_list|)
expr_stmt|;
block|}
name|df_refs_delete
argument_list|(
name|dflow
argument_list|,
name|local_blocks_to_scan
argument_list|)
expr_stmt|;
comment|/* This may be a mistake, but if an explicit blocks is passed in          and the set of blocks to analyze has been explicitly set, add          the extra blocks to blocks_to_analyze.  The alternative is to          put an assert here.  We do not want this to just go by          silently or else we may get storage leaks.  */
if|if
condition|(
name|df
operator|->
name|blocks_to_analyze
condition|)
name|bitmap_ior_into
argument_list|(
name|df
operator|->
name|blocks_to_analyze
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we are going to do everything, just reallocate everything. 	 Most stuff is allocated in pools so this is faster than 	 walking it.  */
if|if
condition|(
name|df
operator|->
name|blocks_to_analyze
condition|)
name|bitmap_copy
argument_list|(
name|local_blocks_to_scan
argument_list|,
name|df
operator|->
name|blocks_to_analyze
argument_list|)
expr_stmt|;
else|else
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|bitmap_set_bit
argument_list|(
name|local_blocks_to_scan
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|df_scan_alloc
argument_list|(
name|dflow
argument_list|,
name|local_blocks_to_scan
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|df
operator|->
name|def_info
operator|.
name|add_refs_inline
operator|=
name|false
expr_stmt|;
name|df
operator|->
name|use_info
operator|.
name|add_refs_inline
operator|=
name|false
expr_stmt|;
block|}
name|df_refs_record
argument_list|(
name|dflow
argument_list|,
name|local_blocks_to_scan
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|bitmap_print (stderr, local_blocks_to_scan, "scanning: ", "\n");
endif|#
directive|endif
if|if
condition|(
operator|!
name|df
operator|->
name|blocks_to_scan
condition|)
name|df
operator|->
name|blocks_to_scan
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bitmap_ior_into
argument_list|(
name|df
operator|->
name|blocks_to_scan
argument_list|,
name|local_blocks_to_scan
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|local_blocks_to_scan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new ref of type DF_REF_TYPE for register REG at address    LOC within INSN of BB.  */
end_comment

begin_function
name|struct
name|df_ref
modifier|*
name|df_ref_create
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|rtx
modifier|*
name|loc
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|enum
name|df_ref_type
name|ref_type
parameter_list|,
name|enum
name|df_ref_flags
name|ref_flags
parameter_list|)
block|{
name|struct
name|dataflow
modifier|*
name|dflow
init|=
name|df
operator|->
name|problems_by_index
index|[
name|DF_SCAN
index|]
decl_stmt|;
name|struct
name|df_scan_bb_info
modifier|*
name|bb_info
decl_stmt|;
name|df_grow_reg_info
argument_list|(
name|dflow
argument_list|,
operator|&
name|df
operator|->
name|use_info
argument_list|)
expr_stmt|;
name|df_grow_reg_info
argument_list|(
name|dflow
argument_list|,
operator|&
name|df
operator|->
name|def_info
argument_list|)
expr_stmt|;
name|df_grow_bb_info
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
comment|/* Make sure there is the bb_info for this block.  */
name|bb_info
operator|=
name|df_scan_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bb_info
condition|)
block|{
name|bb_info
operator|=
operator|(
expr|struct
name|df_scan_bb_info
operator|*
operator|)
name|pool_alloc
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|)
expr_stmt|;
name|df_scan_set_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb_info
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|artificial_defs
operator|=
name|NULL
expr_stmt|;
name|bb_info
operator|->
name|artificial_uses
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ref_type
operator|==
name|DF_REF_REG_DEF
condition|)
name|df
operator|->
name|def_info
operator|.
name|add_refs_inline
operator|=
name|true
expr_stmt|;
else|else
name|df
operator|->
name|use_info
operator|.
name|add_refs_inline
operator|=
name|true
expr_stmt|;
return|return
name|df_ref_create_structure
argument_list|(
name|dflow
argument_list|,
name|reg
argument_list|,
name|loc
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|ref_type
argument_list|,
name|ref_flags
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------------    UTILITIES TO CREATE AND DESTROY REFS AND CHAINS. ----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Get the artificial uses for a basic block.  */
end_comment

begin_function
name|struct
name|df_ref
modifier|*
name|df_get_artificial_defs
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|unsigned
name|int
name|bb_index
parameter_list|)
block|{
name|struct
name|dataflow
modifier|*
name|dflow
init|=
name|df
operator|->
name|problems_by_index
index|[
name|DF_SCAN
index|]
decl_stmt|;
return|return
name|df_scan_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
operator|->
name|artificial_defs
return|;
block|}
end_function

begin_comment
comment|/* Get the artificial uses for a basic block.  */
end_comment

begin_function
name|struct
name|df_ref
modifier|*
name|df_get_artificial_uses
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|unsigned
name|int
name|bb_index
parameter_list|)
block|{
name|struct
name|dataflow
modifier|*
name|dflow
init|=
name|df
operator|->
name|problems_by_index
index|[
name|DF_SCAN
index|]
decl_stmt|;
return|return
name|df_scan_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
operator|->
name|artificial_uses
return|;
block|}
end_function

begin_comment
comment|/* Link REF at the front of reg_use or reg_def chain for REGNO.  */
end_comment

begin_function
name|void
name|df_reg_chain_create
parameter_list|(
name|struct
name|df_reg_info
modifier|*
name|reg_info
parameter_list|,
name|struct
name|df_ref
modifier|*
name|ref
parameter_list|)
block|{
name|struct
name|df_ref
modifier|*
name|head
init|=
name|reg_info
operator|->
name|reg_chain
decl_stmt|;
name|reg_info
operator|->
name|reg_chain
operator|=
name|ref
expr_stmt|;
name|DF_REF_NEXT_REG
argument_list|(
name|ref
argument_list|)
operator|=
name|head
expr_stmt|;
comment|/* We cannot actually link to the head of the chain.  */
name|DF_REF_PREV_REG
argument_list|(
name|ref
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|head
condition|)
name|DF_REF_PREV_REG
argument_list|(
name|head
argument_list|)
operator|=
name|ref
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove REF from the CHAIN.  Return the head of the chain.  This    will be CHAIN unless the REF was at the beginning of the chain.  */
end_comment

begin_function
specifier|static
name|struct
name|df_ref
modifier|*
name|df_ref_unlink
parameter_list|(
name|struct
name|df_ref
modifier|*
name|chain
parameter_list|,
name|struct
name|df_ref
modifier|*
name|ref
parameter_list|)
block|{
name|struct
name|df_ref
modifier|*
name|orig_chain
init|=
name|chain
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
if|if
condition|(
name|chain
operator|==
name|ref
condition|)
block|{
if|if
condition|(
name|prev
condition|)
block|{
name|prev
operator|->
name|next_ref
operator|=
name|ref
operator|->
name|next_ref
expr_stmt|;
name|ref
operator|->
name|next_ref
operator|=
name|NULL
expr_stmt|;
return|return
name|orig_chain
return|;
block|}
else|else
block|{
name|chain
operator|=
name|ref
operator|->
name|next_ref
expr_stmt|;
name|ref
operator|->
name|next_ref
operator|=
name|NULL
expr_stmt|;
return|return
name|chain
return|;
block|}
block|}
name|prev
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next_ref
expr_stmt|;
block|}
comment|/* Someone passed in a ref that was not in the chain.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Unlink and delete REF at the reg_use or reg_def chain.  Also delete    the def-use or use-def chain if it exists.  Returns the next ref in    uses or defs chain.  */
end_comment

begin_function
name|struct
name|df_ref
modifier|*
name|df_reg_chain_unlink
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|struct
name|df_ref
modifier|*
name|ref
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|next
init|=
name|DF_REF_NEXT_REG
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|prev
init|=
name|DF_REF_PREV_REG
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|struct
name|df_scan_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_scan_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
name|struct
name|df_reg_info
modifier|*
name|reg_info
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|next_ref
init|=
name|ref
operator|->
name|next_ref
decl_stmt|;
name|unsigned
name|int
name|id
init|=
name|DF_REF_ID
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|DF_REF_TYPE
argument_list|(
name|ref
argument_list|)
operator|==
name|DF_REF_REG_DEF
condition|)
block|{
name|reg_info
operator|=
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|df
operator|->
name|def_info
operator|.
name|bitmap_size
operator|--
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|def_info
operator|.
name|refs
operator|&&
operator|(
name|id
operator|<
name|df
operator|->
name|def_info
operator|.
name|refs_size
operator|)
condition|)
name|DF_DEFS_SET
argument_list|(
name|df
argument_list|,
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reg_info
operator|=
name|DF_REG_USE_GET
argument_list|(
name|df
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|df
operator|->
name|use_info
operator|.
name|bitmap_size
operator|--
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|use_info
operator|.
name|refs
operator|&&
operator|(
name|id
operator|<
name|df
operator|->
name|use_info
operator|.
name|refs_size
operator|)
condition|)
name|DF_USES_SET
argument_list|(
name|df
argument_list|,
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Delete any def-use or use-def chains that start here.  */
if|if
condition|(
name|DF_REF_CHAIN
argument_list|(
name|ref
argument_list|)
condition|)
name|df_chain_unlink
argument_list|(
name|df
operator|->
name|problems_by_index
index|[
name|DF_CHAIN
index|]
argument_list|,
name|ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|reg_info
operator|->
name|n_refs
operator|--
expr_stmt|;
comment|/* Unlink from the reg chain.  If there is no prev, this is the      first of the list.  If not, just join the next and prev.  */
if|if
condition|(
name|prev
condition|)
block|{
name|DF_REF_NEXT_REG
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|DF_REF_PREV_REG
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
else|else
block|{
name|reg_info
operator|->
name|reg_chain
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|DF_REF_PREV_REG
argument_list|(
name|next
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
name|pool_free
argument_list|(
name|problem_data
operator|->
name|ref_pool
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
name|next_ref
return|;
block|}
end_function

begin_comment
comment|/* Unlink REF from all def-use/use-def chains, etc.  */
end_comment

begin_function
name|void
name|df_ref_remove
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|struct
name|df_ref
modifier|*
name|ref
parameter_list|)
block|{
name|struct
name|dataflow
modifier|*
name|dflow
init|=
name|df
operator|->
name|problems_by_index
index|[
name|DF_SCAN
index|]
decl_stmt|;
if|if
condition|(
name|DF_REF_REG_DEF_P
argument_list|(
name|ref
argument_list|)
condition|)
block|{
if|if
condition|(
name|DF_REF_FLAGS
argument_list|(
name|ref
argument_list|)
operator|&
name|DF_REF_ARTIFICIAL
condition|)
block|{
name|struct
name|df_scan_bb_info
modifier|*
name|bb_info
init|=
name|df_scan_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|DF_REF_BB
argument_list|(
name|ref
argument_list|)
operator|->
name|index
argument_list|)
decl_stmt|;
name|bb_info
operator|->
name|artificial_defs
operator|=
name|df_ref_unlink
argument_list|(
name|bb_info
operator|->
name|artificial_defs
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
else|else
name|DF_INSN_UID_DEFS
argument_list|(
name|df
argument_list|,
name|DF_REF_INSN_UID
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|=
name|df_ref_unlink
argument_list|(
name|DF_INSN_UID_DEFS
argument_list|(
name|df
argument_list|,
name|DF_REF_INSN_UID
argument_list|(
name|ref
argument_list|)
argument_list|)
argument_list|,
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|def_info
operator|.
name|add_refs_inline
condition|)
name|DF_DEFS_SET
argument_list|(
name|df
argument_list|,
name|DF_REF_ID
argument_list|(
name|ref
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|DF_REF_FLAGS
argument_list|(
name|ref
argument_list|)
operator|&
name|DF_REF_ARTIFICIAL
condition|)
block|{
name|struct
name|df_scan_bb_info
modifier|*
name|bb_info
init|=
name|df_scan_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|DF_REF_BB
argument_list|(
name|ref
argument_list|)
operator|->
name|index
argument_list|)
decl_stmt|;
name|bb_info
operator|->
name|artificial_uses
operator|=
name|df_ref_unlink
argument_list|(
name|bb_info
operator|->
name|artificial_uses
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
else|else
name|DF_INSN_UID_USES
argument_list|(
name|df
argument_list|,
name|DF_REF_INSN_UID
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|=
name|df_ref_unlink
argument_list|(
name|DF_INSN_UID_USES
argument_list|(
name|df
argument_list|,
name|DF_REF_INSN_UID
argument_list|(
name|ref
argument_list|)
argument_list|)
argument_list|,
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|use_info
operator|.
name|add_refs_inline
condition|)
name|DF_USES_SET
argument_list|(
name|df
argument_list|,
name|DF_REF_ID
argument_list|(
name|ref
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|df_reg_chain_unlink
argument_list|(
name|dflow
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the insn record for INSN.  If there was one there, zero it out.  */
end_comment

begin_function
specifier|static
name|struct
name|df_insn_info
modifier|*
name|df_insn_create_insn_record
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|struct
name|df_scan_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_scan_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
name|struct
name|df_insn_info
modifier|*
name|insn_rec
init|=
name|DF_INSN_GET
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|insn_rec
condition|)
block|{
name|insn_rec
operator|=
name|pool_alloc
argument_list|(
name|problem_data
operator|->
name|insn_pool
argument_list|)
expr_stmt|;
name|DF_INSN_SET
argument_list|(
name|df
argument_list|,
name|insn
argument_list|,
name|insn_rec
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|insn_rec
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|df_insn_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|insn_rec
return|;
block|}
end_function

begin_comment
comment|/* Delete all of the refs information from INSN.  */
end_comment

begin_function
name|void
name|df_insn_refs_delete
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|unsigned
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|struct
name|df_insn_info
modifier|*
name|insn_info
init|=
name|NULL
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|ref
decl_stmt|;
name|struct
name|df_scan_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_scan_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
if|if
condition|(
name|uid
operator|<
name|df
operator|->
name|insns_size
condition|)
name|insn_info
operator|=
name|DF_INSN_UID_GET
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_info
condition|)
block|{
name|struct
name|df_mw_hardreg
modifier|*
name|hardregs
init|=
name|insn_info
operator|->
name|mw_hardregs
decl_stmt|;
while|while
condition|(
name|hardregs
condition|)
block|{
name|struct
name|df_mw_hardreg
modifier|*
name|next_hr
init|=
name|hardregs
operator|->
name|next
decl_stmt|;
name|struct
name|df_link
modifier|*
name|link
init|=
name|hardregs
operator|->
name|regs
decl_stmt|;
while|while
condition|(
name|link
condition|)
block|{
name|struct
name|df_link
modifier|*
name|next_l
init|=
name|link
operator|->
name|next
decl_stmt|;
name|pool_free
argument_list|(
name|problem_data
operator|->
name|mw_link_pool
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|link
operator|=
name|next_l
expr_stmt|;
block|}
name|pool_free
argument_list|(
name|problem_data
operator|->
name|mw_reg_pool
argument_list|,
name|hardregs
argument_list|)
expr_stmt|;
name|hardregs
operator|=
name|next_hr
expr_stmt|;
block|}
name|ref
operator|=
name|insn_info
operator|->
name|defs
expr_stmt|;
while|while
condition|(
name|ref
condition|)
name|ref
operator|=
name|df_reg_chain_unlink
argument_list|(
name|dflow
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|ref
operator|=
name|insn_info
operator|->
name|uses
expr_stmt|;
while|while
condition|(
name|ref
condition|)
name|ref
operator|=
name|df_reg_chain_unlink
argument_list|(
name|dflow
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|pool_free
argument_list|(
name|problem_data
operator|->
name|insn_pool
argument_list|,
name|insn_info
argument_list|)
expr_stmt|;
name|DF_INSN_SET
argument_list|(
name|df
argument_list|,
name|insn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete all of the refs information from basic_block with BB_INDEX.  */
end_comment

begin_function
name|void
name|df_bb_refs_delete
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|int
name|bb_index
parameter_list|)
block|{
name|struct
name|df_ref
modifier|*
name|def
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|use
decl_stmt|;
name|struct
name|df_scan_bb_info
modifier|*
name|bb_info
init|=
name|df_scan_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|bb_index
argument_list|)
decl_stmt|;
name|FOR_BB_INSNS
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* Record defs within INSN.  */
name|df_insn_refs_delete
argument_list|(
name|dflow
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get rid of any artificial uses or defs.  */
if|if
condition|(
name|bb_info
condition|)
block|{
name|def
operator|=
name|bb_info
operator|->
name|artificial_defs
expr_stmt|;
while|while
condition|(
name|def
condition|)
name|def
operator|=
name|df_reg_chain_unlink
argument_list|(
name|dflow
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|artificial_defs
operator|=
name|NULL
expr_stmt|;
name|use
operator|=
name|bb_info
operator|->
name|artificial_uses
expr_stmt|;
while|while
condition|(
name|use
condition|)
name|use
operator|=
name|df_reg_chain_unlink
argument_list|(
name|dflow
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|artificial_uses
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete all of the refs information from BLOCKS.  */
end_comment

begin_function
name|void
name|df_refs_delete
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|blocks
parameter_list|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|df_bb_refs_delete
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Take build ref table for either the uses or defs from the reg-use    or reg-def chains.  */
end_comment

begin_function
name|void
name|df_reorganize_refs
parameter_list|(
name|struct
name|df_ref_info
modifier|*
name|ref_info
parameter_list|)
block|{
name|unsigned
name|int
name|m
init|=
name|ref_info
operator|->
name|regs_inited
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|unsigned
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ref_info
operator|->
name|refs_organized
condition|)
return|return;
if|if
condition|(
name|ref_info
operator|->
name|refs_size
operator|<
name|ref_info
operator|->
name|bitmap_size
condition|)
block|{
name|int
name|new_size
init|=
name|ref_info
operator|->
name|bitmap_size
operator|+
name|ref_info
operator|->
name|bitmap_size
operator|/
literal|4
decl_stmt|;
name|df_grow_ref_info
argument_list|(
name|ref_info
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|m
condition|;
name|regno
operator|++
control|)
block|{
name|struct
name|df_reg_info
modifier|*
name|reg_info
init|=
name|ref_info
operator|->
name|regs
index|[
name|regno
index|]
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reg_info
condition|)
block|{
name|struct
name|df_ref
modifier|*
name|ref
init|=
name|reg_info
operator|->
name|reg_chain
decl_stmt|;
name|reg_info
operator|->
name|begin
operator|=
name|offset
expr_stmt|;
while|while
condition|(
name|ref
condition|)
block|{
name|ref_info
operator|->
name|refs
index|[
name|offset
index|]
operator|=
name|ref
expr_stmt|;
name|DF_REF_ID
argument_list|(
name|ref
argument_list|)
operator|=
name|offset
operator|++
expr_stmt|;
name|ref
operator|=
name|DF_REF_NEXT_REG
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
name|reg_info
operator|->
name|n_refs
operator|=
name|count
expr_stmt|;
block|}
block|}
comment|/* The bitmap size is not decremented when refs are deleted.  So      reset it now that we have squished out all of the empty      slots.  */
name|ref_info
operator|->
name|bitmap_size
operator|=
name|size
expr_stmt|;
name|ref_info
operator|->
name|refs_organized
operator|=
name|true
expr_stmt|;
name|ref_info
operator|->
name|add_refs_inline
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------------    Hard core instruction scanning code.  No external interfaces here,    just a lot of routines that look inside insns. ----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Create a ref and add it to the reg-def or reg-use chains.  */
end_comment

begin_function
specifier|static
name|struct
name|df_ref
modifier|*
name|df_ref_create_structure
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|rtx
modifier|*
name|loc
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|enum
name|df_ref_type
name|ref_type
parameter_list|,
name|enum
name|df_ref_flags
name|ref_flags
parameter_list|)
block|{
name|struct
name|df_ref
modifier|*
name|this_ref
decl_stmt|;
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|?
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
else|:
name|reg
argument_list|)
decl_stmt|;
name|struct
name|df_scan_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_scan_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
name|this_ref
operator|=
name|pool_alloc
argument_list|(
name|problem_data
operator|->
name|ref_pool
argument_list|)
expr_stmt|;
name|DF_REF_REG
argument_list|(
name|this_ref
argument_list|)
operator|=
name|reg
expr_stmt|;
name|DF_REF_REGNO
argument_list|(
name|this_ref
argument_list|)
operator|=
name|regno
expr_stmt|;
name|DF_REF_LOC
argument_list|(
name|this_ref
argument_list|)
operator|=
name|loc
expr_stmt|;
name|DF_REF_INSN
argument_list|(
name|this_ref
argument_list|)
operator|=
name|insn
expr_stmt|;
name|DF_REF_CHAIN
argument_list|(
name|this_ref
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DF_REF_TYPE
argument_list|(
name|this_ref
argument_list|)
operator|=
name|ref_type
expr_stmt|;
name|DF_REF_FLAGS
argument_list|(
name|this_ref
argument_list|)
operator|=
name|ref_flags
expr_stmt|;
name|DF_REF_DATA
argument_list|(
name|this_ref
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DF_REF_BB
argument_list|(
name|this_ref
argument_list|)
operator|=
name|bb
expr_stmt|;
comment|/* Link the ref into the reg_def and reg_use chains and keep a count      of the instances.  */
switch|switch
condition|(
name|ref_type
condition|)
block|{
case|case
name|DF_REF_REG_DEF
case|:
block|{
name|struct
name|df_reg_info
modifier|*
name|reg_info
init|=
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|reg_info
operator|->
name|n_refs
operator|++
expr_stmt|;
comment|/* Add the ref to the reg_def chain.  */
name|df_reg_chain_create
argument_list|(
name|reg_info
argument_list|,
name|this_ref
argument_list|)
expr_stmt|;
name|DF_REF_ID
argument_list|(
name|this_ref
argument_list|)
operator|=
name|df
operator|->
name|def_info
operator|.
name|bitmap_size
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|def_info
operator|.
name|add_refs_inline
condition|)
block|{
if|if
condition|(
name|DF_DEFS_SIZE
argument_list|(
name|df
argument_list|)
operator|>=
name|df
operator|->
name|def_info
operator|.
name|refs_size
condition|)
block|{
name|int
name|new_size
init|=
name|df
operator|->
name|def_info
operator|.
name|bitmap_size
operator|+
name|df
operator|->
name|def_info
operator|.
name|bitmap_size
operator|/
literal|4
decl_stmt|;
name|df_grow_ref_info
argument_list|(
operator|&
name|df
operator|->
name|def_info
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
block|}
comment|/* Add the ref to the big array of defs.  */
name|DF_DEFS_SET
argument_list|(
name|df
argument_list|,
name|df
operator|->
name|def_info
operator|.
name|bitmap_size
argument_list|,
name|this_ref
argument_list|)
expr_stmt|;
name|df
operator|->
name|def_info
operator|.
name|refs_organized
operator|=
name|false
expr_stmt|;
block|}
name|df
operator|->
name|def_info
operator|.
name|bitmap_size
operator|++
expr_stmt|;
if|if
condition|(
name|DF_REF_FLAGS
argument_list|(
name|this_ref
argument_list|)
operator|&
name|DF_REF_ARTIFICIAL
condition|)
block|{
name|struct
name|df_scan_bb_info
modifier|*
name|bb_info
init|=
name|df_scan_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb
operator|->
name|index
argument_list|)
decl_stmt|;
name|this_ref
operator|->
name|next_ref
operator|=
name|bb_info
operator|->
name|artificial_defs
expr_stmt|;
name|bb_info
operator|->
name|artificial_defs
operator|=
name|this_ref
expr_stmt|;
block|}
else|else
block|{
name|this_ref
operator|->
name|next_ref
operator|=
name|DF_INSN_GET
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
operator|->
name|defs
expr_stmt|;
name|DF_INSN_GET
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
operator|->
name|defs
operator|=
name|this_ref
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DF_REF_REG_MEM_LOAD
case|:
case|case
name|DF_REF_REG_MEM_STORE
case|:
case|case
name|DF_REF_REG_USE
case|:
block|{
name|struct
name|df_reg_info
modifier|*
name|reg_info
init|=
name|DF_REG_USE_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|reg_info
operator|->
name|n_refs
operator|++
expr_stmt|;
comment|/* Add the ref to the reg_use chain.  */
name|df_reg_chain_create
argument_list|(
name|reg_info
argument_list|,
name|this_ref
argument_list|)
expr_stmt|;
name|DF_REF_ID
argument_list|(
name|this_ref
argument_list|)
operator|=
name|df
operator|->
name|use_info
operator|.
name|bitmap_size
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|use_info
operator|.
name|add_refs_inline
condition|)
block|{
if|if
condition|(
name|DF_USES_SIZE
argument_list|(
name|df
argument_list|)
operator|>=
name|df
operator|->
name|use_info
operator|.
name|refs_size
condition|)
block|{
name|int
name|new_size
init|=
name|df
operator|->
name|use_info
operator|.
name|bitmap_size
operator|+
name|df
operator|->
name|use_info
operator|.
name|bitmap_size
operator|/
literal|4
decl_stmt|;
name|df_grow_ref_info
argument_list|(
operator|&
name|df
operator|->
name|use_info
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
block|}
comment|/* Add the ref to the big array of defs.  */
name|DF_USES_SET
argument_list|(
name|df
argument_list|,
name|df
operator|->
name|use_info
operator|.
name|bitmap_size
argument_list|,
name|this_ref
argument_list|)
expr_stmt|;
name|df
operator|->
name|use_info
operator|.
name|refs_organized
operator|=
name|false
expr_stmt|;
block|}
name|df
operator|->
name|use_info
operator|.
name|bitmap_size
operator|++
expr_stmt|;
if|if
condition|(
name|DF_REF_FLAGS
argument_list|(
name|this_ref
argument_list|)
operator|&
name|DF_REF_ARTIFICIAL
condition|)
block|{
name|struct
name|df_scan_bb_info
modifier|*
name|bb_info
init|=
name|df_scan_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb
operator|->
name|index
argument_list|)
decl_stmt|;
name|this_ref
operator|->
name|next_ref
operator|=
name|bb_info
operator|->
name|artificial_uses
expr_stmt|;
name|bb_info
operator|->
name|artificial_uses
operator|=
name|this_ref
expr_stmt|;
block|}
else|else
block|{
name|this_ref
operator|->
name|next_ref
operator|=
name|DF_INSN_GET
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
operator|->
name|uses
expr_stmt|;
name|DF_INSN_GET
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
operator|->
name|uses
operator|=
name|this_ref
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|this_ref
return|;
block|}
end_function

begin_comment
comment|/* Create new references of type DF_REF_TYPE for each part of register REG    at address LOC within INSN of BB.  */
end_comment

begin_function
specifier|static
name|void
name|df_ref_record
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|rtx
modifier|*
name|loc
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|enum
name|df_ref_type
name|ref_type
parameter_list|,
name|enum
name|df_ref_flags
name|ref_flags
parameter_list|,
name|bool
name|record_live
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|rtx
name|oldreg
init|=
name|reg
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|reg
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
argument_list|)
expr_stmt|;
comment|/* For the reg allocator we are interested in some SUBREG rtx's, but not      all.  Notably only those representing a word extraction from a multi-word      reg.  As written in the docu those should have the form      (subreg:SI (reg:M A) N), with size(SImode)> size(Mmode).      XXX Is that true?  We could also use the global word_mode variable.  */
if|if
condition|(
operator|(
name|dflow
operator|->
name|flags
operator|&
name|DF_SUBREGS
operator|)
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|word_mode
argument_list|)
operator|||
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|loc
operator|=
operator|&
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
operator|*
name|loc
expr_stmt|;
name|ref_flags
operator||=
name|DF_REF_STRIPPED
expr_stmt|;
block|}
name|regno
operator|=
name|REGNO
argument_list|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|?
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
else|:
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|endregno
decl_stmt|;
name|struct
name|df_mw_hardreg
modifier|*
name|hardreg
init|=
name|NULL
decl_stmt|;
name|struct
name|df_scan_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_scan_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dflow
operator|->
name|flags
operator|&
name|DF_HARD_REGS
operator|)
condition|)
return|return;
comment|/* GET_MODE (reg) is correct here.  We do not want to go into a SUBREG          for the mode, because we only want to add references to regs, which 	 are really referenced.  E.g., a (subreg:SI (reg:DI 0) 0) does _not_ 	 reference the whole reg 0 in DI mode (which would also include 	 reg 1, at least, if 0 and 1 are SImode registers).  */
name|endregno
operator|=
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|regno
operator|+=
name|subreg_regno_offset
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|endregno
operator|+=
name|regno
expr_stmt|;
comment|/*  If this is a multiword hardreg, we create some extra datastructures that  	  will enable us to easily build REG_DEAD and REG_UNUSED notes.  */
if|if
condition|(
operator|(
name|endregno
operator|!=
name|regno
operator|+
literal|1
operator|)
operator|&&
name|insn
condition|)
block|{
name|struct
name|df_insn_info
modifier|*
name|insn_info
init|=
name|DF_INSN_GET
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
decl_stmt|;
comment|/* Sets to a subreg of a multiword register are partial.  	     Sets to a non-subreg of a multiword register are not.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|oldreg
argument_list|)
operator|==
name|SUBREG
condition|)
name|ref_flags
operator||=
name|DF_REF_PARTIAL
expr_stmt|;
name|ref_flags
operator||=
name|DF_REF_MW_HARDREG
expr_stmt|;
name|hardreg
operator|=
name|pool_alloc
argument_list|(
name|problem_data
operator|->
name|mw_reg_pool
argument_list|)
expr_stmt|;
name|hardreg
operator|->
name|next
operator|=
name|insn_info
operator|->
name|mw_hardregs
expr_stmt|;
name|insn_info
operator|->
name|mw_hardregs
operator|=
name|hardreg
expr_stmt|;
name|hardreg
operator|->
name|type
operator|=
name|ref_type
expr_stmt|;
name|hardreg
operator|->
name|flags
operator|=
name|ref_flags
expr_stmt|;
name|hardreg
operator|->
name|mw_reg
operator|=
name|reg
expr_stmt|;
name|hardreg
operator|->
name|regs
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|df_ref
modifier|*
name|ref
decl_stmt|;
comment|/* Calls are handled at call site because regs_ever_live 	     doesn't include clobbered regs, only used ones.  */
if|if
condition|(
name|ref_type
operator|==
name|DF_REF_REG_DEF
operator|&&
name|record_live
condition|)
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ref_type
operator|==
name|DF_REF_REG_USE
operator|||
name|ref_type
operator|==
name|DF_REF_REG_MEM_STORE
operator|||
name|ref_type
operator|==
name|DF_REF_REG_MEM_LOAD
operator|)
operator|&&
operator|(
operator|(
name|ref_flags
operator|&
name|DF_REF_ARTIFICIAL
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Set regs_ever_live on uses of non-eliminable frame 		 pointers and arg pointers.  */
if|if
condition|(
operator|!
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|elim_reg_set
argument_list|,
name|regno
argument_list|)
operator|&&
operator|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|)
operator|)
condition|)
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|ref
operator|=
name|df_ref_create_structure
argument_list|(
name|dflow
argument_list|,
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
name|loc
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|ref_type
argument_list|,
name|ref_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|hardreg
condition|)
block|{
name|struct
name|df_link
modifier|*
name|link
init|=
name|pool_alloc
argument_list|(
name|problem_data
operator|->
name|mw_link_pool
argument_list|)
decl_stmt|;
name|link
operator|->
name|next
operator|=
name|hardreg
operator|->
name|regs
expr_stmt|;
name|link
operator|->
name|ref
operator|=
name|ref
expr_stmt|;
name|hardreg
operator|->
name|regs
operator|=
name|link
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|df_ref_create_structure
argument_list|(
name|dflow
argument_list|,
name|reg
argument_list|,
name|loc
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|ref_type
argument_list|,
name|ref_flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A set to a non-paradoxical SUBREG for which the number of word_mode units    covered by the outer mode is smaller than that covered by the inner mode,    is a read-modify-write operation.    This function returns true iff the SUBREG X is such a SUBREG.  */
end_comment

begin_function
name|bool
name|df_read_modify_subreg_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|isize
decl_stmt|,
name|osize
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SUBREG
condition|)
return|return
name|false
return|;
name|isize
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|osize
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|isize
operator|>
name|osize
operator|&&
name|isize
operator|>
name|UNITS_PER_WORD
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Process all the registers defined in the rtx, X.    Autoincrement/decrement definitions will be picked up by    df_uses_record.  */
end_comment

begin_function
specifier|static
name|void
name|df_def_record_1
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|rtx
name|x
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|enum
name|df_ref_flags
name|flags
parameter_list|,
name|bool
name|record_live
parameter_list|)
block|{
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|dst
decl_stmt|;
name|bool
name|dst_in_strict_lowpart
init|=
name|false
decl_stmt|;
comment|/* We may recursively call ourselves on EXPR_LIST when dealing with PARALLEL      construct.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|EXPR_LIST
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|loc
operator|=
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|*
name|loc
expr_stmt|;
comment|/* It is legal to have a set destination be a parallel. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|temp
init|=
name|XVECEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|EXPR_LIST
operator|||
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|SET
condition|)
name|df_def_record_1
argument_list|(
name|dflow
argument_list|,
name|temp
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CLOBBER
condition|?
name|flags
operator||
name|DF_REF_MUST_CLOBBER
else|:
name|flags
argument_list|,
name|record_live
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* Maybe, we should flag the use of STRICT_LOW_PART somehow.  It might      be handy for the reg allocator.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|df_read_modify_subreg_p
argument_list|(
name|dst
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Strict low part always contains SUBREG, but we do not want to make 	 it appear outside, as whole register is always considered.  */
block|if (GET_CODE (dst) == STRICT_LOW_PART) 	{ 	  loc =&XEXP (dst, 0); 	  dst = *loc; 	}
endif|#
directive|endif
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dst_in_strict_lowpart
operator|=
name|true
expr_stmt|;
name|dst
operator|=
operator|*
name|loc
expr_stmt|;
name|flags
operator||=
name|DF_REF_READ_WRITE
expr_stmt|;
block|}
comment|/* Sets to a subreg of a single word register are partial sets if      they are wrapped in a strict lowpart, and not partial otherwise.   */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|&&
name|dst_in_strict_lowpart
condition|)
name|flags
operator||=
name|DF_REF_PARTIAL
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|dst
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|)
condition|)
name|df_ref_record
argument_list|(
name|dflow
argument_list|,
name|dst
argument_list|,
name|loc
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|DF_REF_REG_DEF
argument_list|,
name|flags
argument_list|,
name|record_live
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process all the registers defined in the pattern rtx, X.  */
end_comment

begin_function
specifier|static
name|void
name|df_defs_record
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|rtx
name|x
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
block|{
comment|/* Mark the single def within the pattern.  */
name|df_def_record_1
argument_list|(
name|dflow
argument_list|,
name|x
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|code
operator|==
name|CLOBBER
condition|?
name|DF_REF_MUST_CLOBBER
else|:
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|COND_EXEC
condition|)
block|{
name|df_defs_record
argument_list|(
name|dflow
argument_list|,
name|COND_EXEC_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Mark the multiple defs within the pattern.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|df_defs_record
argument_list|(
name|dflow
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process all the registers used in the rtx at address LOC.  */
end_comment

begin_function
specifier|static
name|void
name|df_uses_record
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|rtx
modifier|*
name|loc
parameter_list|,
name|enum
name|df_ref_type
name|ref_type
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|enum
name|df_ref_flags
name|flags
parameter_list|)
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|retry
label|:
name|x
operator|=
operator|*
name|loc
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return;
case|case
name|CLOBBER
case|:
comment|/* If we are clobbering a MEM, mark any registers inside the address 	 as being used.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DF_REF_REG_MEM_STORE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* If we're clobbering a REG then we have a def so ignore.  */
return|return;
case|case
name|MEM
case|:
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DF_REF_REG_MEM_LOAD
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|flags
operator|&
name|DF_REF_IN_NOTE
argument_list|)
expr_stmt|;
return|return;
case|case
name|SUBREG
case|:
comment|/* While we're here, optimize this case.  */
name|flags
operator||=
name|DF_REF_PARTIAL
expr_stmt|;
comment|/* In case the SUBREG is not of a REG, do not optimize.  */
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|loc
operator|=
operator|&
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
name|loc
argument_list|,
name|ref_type
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ... Fall through ...  */
case|case
name|REG
case|:
name|df_ref_record
argument_list|(
name|dflow
argument_list|,
name|x
argument_list|,
name|loc
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|ref_type
argument_list|,
name|flags
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return;
case|case
name|SET
case|:
block|{
name|rtx
name|dst
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|DF_REF_IN_NOTE
operator|)
argument_list|)
expr_stmt|;
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
if|if
condition|(
name|df_read_modify_subreg_p
argument_list|(
name|dst
argument_list|)
condition|)
block|{
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|&
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|flags
operator||
name|DF_REF_READ_WRITE
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|REG
case|:
case|case
name|PARALLEL
case|:
case|case
name|SCRATCH
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
break|break;
case|case
name|MEM
case|:
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|&
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DF_REF_REG_MEM_STORE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRICT_LOW_PART
case|:
block|{
name|rtx
modifier|*
name|temp
init|=
operator|&
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* A strict_low_part uses the whole REG and not just the 		 SUBREG.  */
name|dst
operator|=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|SUBREG
operator|)
condition|?
operator|&
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
else|:
name|temp
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|DF_REF_READ_WRITE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZERO_EXTRACT
case|:
case|case
name|SIGN_EXTRACT
case|:
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|&
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|DF_REF_READ_WRITE
argument_list|)
expr_stmt|;
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|&
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|&
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|2
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|dst
operator|=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
case|case
name|RETURN
case|:
break|break;
case|case
name|ASM_OPERANDS
case|:
case|case
name|UNSPEC_VOLATILE
case|:
case|case
name|TRAP_IF
case|:
case|case
name|ASM_INPUT
case|:
block|{
comment|/* Traditional and volatile asm instructions must be 	   considered to use and clobber all hard registers, all 	   pseudo-registers and all of memory.  So must TRAP_IF and 	   UNSPEC_VOLATILE operations.  	   Consider for instance a volatile asm that changes the fpu 	   rounding mode.  An insn should not be moved across this 	   even if it only uses pseudo-regs because it might give an 	   incorrectly rounded result.  	   However, flow.c's liveness computation did *not* do this, 	   giving the reasoning as " ?!? Unfortunately, marking all 	   hard registers as live causes massive problems for the 	   register allocator and marking all pseudos as live creates 	   mountains of uninitialized variable warnings."  	   In order to maintain the status quo with regard to liveness 	   and uses, we do what flow.c did and just mark any regs we 	   can find in ASM_OPERANDS as used.  Later on, when liveness 	   is computed, asm insns are scanned and regs_asm_clobbered 	   is filled out.    	   For all ASM_OPERANDS, we must traverse the vector of input 	   operands.  We can not just fall through here since then we 	   would be confused by the ASM_INPUT rtx inside ASM_OPERANDS, 	   which do not indicate traditional asms unlike their normal 	   usage.  */
if|if
condition|(
name|code
operator|==
name|ASM_OPERANDS
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|;
name|j
operator|++
control|)
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|j
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
case|case
name|PRE_DEC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_INC
case|:
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
comment|/* Catch the def of the register being modified.  */
name|flags
operator||=
name|DF_REF_READ_WRITE
expr_stmt|;
name|df_ref_record
argument_list|(
name|dflow
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|DF_REF_REG_DEF
argument_list|,
name|flags
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* ... Fall through to handle uses ...  */
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* Tail recursive case: save a function call level.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|ref_type
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|ref_type
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return true if *LOC contains an asm.  */
end_comment

begin_function
specifier|static
name|int
name|df_insn_contains_asm_1
parameter_list|(
name|rtx
modifier|*
name|loc
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|*
name|loc
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|loc
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if INSN contains an ASM.  */
end_comment

begin_function
specifier|static
name|int
name|df_insn_contains_asm
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
return|return
name|for_each_rtx
argument_list|(
operator|&
name|insn
argument_list|,
name|df_insn_contains_asm_1
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Record all the refs for DF within INSN of basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|df_insn_refs_record
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|df_insn_contains_asm
argument_list|(
name|insn
argument_list|)
condition|)
name|DF_INSN_CONTAINS_ASM
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
operator|=
name|true
expr_stmt|;
comment|/* Record register defs.  */
name|df_defs_record
argument_list|(
name|dflow
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_EQUIV_NOTES
condition|)
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
switch|switch
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
condition|)
block|{
case|case
name|REG_EQUIV
case|:
case|case
name|REG_EQUAL
case|:
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|DF_REF_IN_NOTE
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|note
decl_stmt|;
comment|/* Record the registers used to pass arguments, and explicitly 	     noted as clobbered.  */
for|for
control|(
name|note
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|df_defs_record
argument_list|(
name|dflow
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|regno_last
decl_stmt|;
name|int
name|regno_first
decl_stmt|;
name|int
name|i
decl_stmt|;
name|regno_last
operator|=
name|regno_first
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno_first
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno_last
operator|+=
name|hard_regno_nregs
index|[
name|regno_first
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regno_first
init|;
name|i
operator|<=
name|regno_last
condition|;
name|i
operator|++
control|)
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* The stack ptr is used (honorarily) by a CALL insn.  */
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|&
name|regno_reg_rtx
index|[
name|STACK_POINTER_REGNUM
index|]
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_HARD_REGS
condition|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|ui
decl_stmt|;
comment|/* Calls may also reference any of the global registers, 		 so they are recorded as used.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|&
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|df_invalidated_by_call
argument_list|,
literal|0
argument_list|,
argument|ui
argument_list|,
argument|bi
argument_list|)
name|df_ref_record
argument_list|(
name|dflow
argument_list|,
name|regno_reg_rtx
index|[
name|ui
index|]
argument_list|,
operator|&
name|regno_reg_rtx
index|[
name|ui
index|]
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|DF_REF_REG_DEF
argument_list|,
name|DF_REF_MAY_CLOBBER
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Record the register uses.  */
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|df_has_eh_preds
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Record all the refs within the basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|df_bb_refs_record
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|luid
init|=
literal|0
decl_stmt|;
name|struct
name|df_scan_bb_info
modifier|*
name|bb_info
init|=
name|df_scan_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb
operator|->
name|index
argument_list|)
decl_stmt|;
name|bitmap
name|artificial_uses_at_bottom
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_HARD_REGS
condition|)
name|artificial_uses_at_bottom
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Need to make sure that there is a record in the basic block info. */
if|if
condition|(
operator|!
name|bb_info
condition|)
block|{
name|bb_info
operator|=
operator|(
expr|struct
name|df_scan_bb_info
operator|*
operator|)
name|pool_alloc
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|)
expr_stmt|;
name|df_scan_set_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb_info
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|artificial_defs
operator|=
name|NULL
expr_stmt|;
name|bb_info
operator|->
name|artificial_uses
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Scan the block an insn at a time from beginning to end.  */
name|FOR_BB_INSNS
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
name|df_insn_create_insn_record
argument_list|(
name|dflow
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* Record defs within INSN.  */
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
operator|=
name|luid
operator|++
expr_stmt|;
name|df_insn_refs_record
argument_list|(
name|dflow
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
operator|=
name|luid
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EH_RETURN_DATA_REGNO
if|if
condition|(
operator|(
name|dflow
operator|->
name|flags
operator|&
name|DF_HARD_REGS
operator|)
operator|&&
name|df_has_eh_preds
argument_list|(
name|bb
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Mark the registers that will contain data for the handler.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|regno
init|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|==
name|INVALID_REGNUM
condition|)
break|break;
name|df_ref_record
argument_list|(
name|dflow
argument_list|,
name|regno_reg_rtx
index|[
name|regno
index|]
argument_list|,
operator|&
name|regno_reg_rtx
index|[
name|regno
index|]
argument_list|,
name|bb
argument_list|,
name|NULL
argument_list|,
name|DF_REF_REG_DEF
argument_list|,
name|DF_REF_ARTIFICIAL
operator||
name|DF_REF_AT_TOP
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|dflow
operator|->
name|flags
operator|&
name|DF_HARD_REGS
operator|)
operator|&&
name|df_has_eh_preds
argument_list|(
name|bb
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|EH_USES
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* This code is putting in a artificial ref for the use at the 	 TOP of the block that receives the exception.  It is too 	 cumbersome to actually put the ref on the edge.  We could 	 either model this at the top of the receiver block or the 	 bottom of the sender block.           The bottom of the sender block is problematic because not all          out-edges of the a block are eh-edges.  However, it is true          that all edges into a block are either eh-edges or none of          them are eh-edges.  Thus, we can model this at the top of the          eh-receiver for all of the edges at once. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|EH_USES
argument_list|(
name|i
argument_list|)
condition|)
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|&
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|NULL
argument_list|,
name|DF_REF_ARTIFICIAL
operator||
name|DF_REF_AT_TOP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The following code (down thru the arg_pointer setting APPEARS 	 to be necessary because there is nothing that actually 	 describes what the exception handling code may actually need 	 to keep alive.  */
if|if
condition|(
name|reload_completed
condition|)
block|{
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|artificial_uses_at_bottom
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
name|bitmap_set_bit
argument_list|(
name|artificial_uses_at_bottom
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
if|if
condition|(
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
condition|)
name|bitmap_set_bit
argument_list|(
name|artificial_uses_at_bottom
argument_list|,
name|ARG_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
operator|(
name|dflow
operator|->
name|flags
operator|&
name|DF_HARD_REGS
operator|)
operator|&&
name|bb
operator|->
name|index
operator|>=
name|NUM_FIXED_BLOCKS
condition|)
block|{
comment|/* Before reload, there are a few registers that must be forced 	 live everywhere -- which might not already be the case for 	 blocks within infinite loops.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
block|{
comment|/* Any reference to any pseudo before reload is a potential 	     reference of the frame pointer.  */
name|bitmap_set_bit
argument_list|(
name|artificial_uses_at_bottom
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
comment|/* Pseudos with argument area equivalences may require 	     reloading via the argument pointer.  */
if|if
condition|(
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
condition|)
name|bitmap_set_bit
argument_list|(
name|artificial_uses_at_bottom
argument_list|,
name|ARG_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Any constant, or pseudo with constant equivalences, may 	     require reloading from memory using the pic register.  */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|PIC_OFFSET_TABLE_REGNUM
operator|!=
name|INVALID_REGNUM
operator|&&
name|fixed_regs
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
name|bitmap_set_bit
argument_list|(
name|artificial_uses_at_bottom
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
block|}
comment|/* The all-important stack pointer must always be live.  */
name|bitmap_set_bit
argument_list|(
name|artificial_uses_at_bottom
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_HARD_REGS
condition|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|artificial_uses_at_bottom
argument_list|,
literal|0
argument_list|,
argument|regno
argument_list|,
argument|bi
argument_list|)
block|{
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|&
name|regno_reg_rtx
index|[
name|regno
index|]
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|NULL
argument_list|,
name|DF_REF_ARTIFICIAL
argument_list|)
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|artificial_uses_at_bottom
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record all the refs in the basic blocks specified by BLOCKS.  */
end_comment

begin_function
specifier|static
name|void
name|df_refs_record
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|blocks
parameter_list|)
block|{
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|bb_index
argument_list|)
decl_stmt|;
name|df_bb_refs_record
argument_list|(
name|dflow
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|blocks
argument_list|,
name|EXIT_BLOCK
argument_list|)
condition|)
name|df_record_exit_block_uses
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|blocks
argument_list|,
name|ENTRY_BLOCK
argument_list|)
condition|)
name|df_record_entry_block_defs
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------    Specialized hard register scanning functions. ----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Mark a register in SET.  Hard registers in large modes get all    of their component registers set as well.  */
end_comment

begin_function
specifier|static
name|void
name|df_mark_reg
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|void
modifier|*
name|vset
parameter_list|)
block|{
name|bitmap
name|set
init|=
operator|(
name|bitmap
operator|)
name|vset
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|BLKmode
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|set
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
init|=
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
name|bitmap_set_bit
argument_list|(
name|set
argument_list|,
name|regno
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record the (conservative) set of hard registers that are defined on    entry to the function.  */
end_comment

begin_function
specifier|static
name|void
name|df_record_entry_block_defs
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|rtx
name|r
decl_stmt|;
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|bitmap_clear
argument_list|(
name|df
operator|->
name|entry_block_defs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dflow
operator|->
name|flags
operator|&
name|DF_HARD_REGS
operator|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|i
argument_list|)
condition|)
ifdef|#
directive|ifdef
name|INCOMING_REGNO
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|entry_block_defs
argument_list|,
name|INCOMING_REGNO
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|entry_block_defs
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Once the prologue has been generated, all of these registers      should just show up in the first regular block.  */
if|if
condition|(
name|HAVE_prologue
operator|&&
name|epilogue_completed
condition|)
block|{
comment|/* Defs for the callee saved registers are inserted so that the 	 pushes have some defining location.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|call_used_regs
index|[
name|i
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|regs_ever_live
index|[
name|i
index|]
operator|)
condition|)
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|entry_block_defs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The always important stack pointer.  */
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|entry_block_defs
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INCOMING_RETURN_ADDR_RTX
if|if
condition|(
name|REG_P
argument_list|(
name|INCOMING_RETURN_ADDR_RTX
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|entry_block_defs
argument_list|,
name|REGNO
argument_list|(
name|INCOMING_RETURN_ADDR_RTX
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If STATIC_CHAIN_INCOMING_REGNUM == STATIC_CHAIN_REGNUM 	 only STATIC_CHAIN_REGNUM is defined.  If they are different, 	 we only care about the STATIC_CHAIN_INCOMING_REGNUM.  */
ifdef|#
directive|ifdef
name|STATIC_CHAIN_INCOMING_REGNUM
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|entry_block_defs
argument_list|,
name|STATIC_CHAIN_INCOMING_REGNUM
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|STATIC_CHAIN_REGNUM
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|entry_block_defs
argument_list|,
name|STATIC_CHAIN_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|r
operator|=
name|TARGET_STRUCT_VALUE_RTX
argument_list|(
name|current_function_decl
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&&
name|REG_P
argument_list|(
name|r
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|entry_block_defs
argument_list|,
name|REGNO
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|reload_completed
operator|)
operator|||
name|frame_pointer_needed
condition|)
block|{
comment|/* Any reference to any pseudo before reload is a potential 	 reference of the frame pointer.  */
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|entry_block_defs
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
comment|/* If they are different, also mark the hard frame pointer as live.  */
if|if
condition|(
operator|!
name|LOCAL_REGNO
argument_list|(
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|entry_block_defs
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* These registers are live everywhere.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
block|{
ifdef|#
directive|ifdef
name|EH_USES
comment|/* The ia-64, the only machine that uses this, does not define these  	 until after reload.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|EH_USES
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|entry_block_defs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
comment|/* Pseudos with argument area equivalences may require 	 reloading via the argument pointer.  */
if|if
condition|(
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
condition|)
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|entry_block_defs
argument_list|,
name|ARG_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PIC_OFFSET_TABLE_REGNUM
comment|/* Any constant, or pseudo with constant equivalences, may 	 require reloading from memory using the pic register.  */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|PIC_OFFSET_TABLE_REGNUM
operator|!=
name|INVALID_REGNUM
operator|&&
name|fixed_regs
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|entry_block_defs
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|targetm
operator|.
name|live_on_entry
argument_list|(
name|df
operator|->
name|entry_block_defs
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|df->entry_block_defs
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|df_ref_record
argument_list|(
name|dflow
argument_list|,
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
operator|&
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|,
name|NULL
argument_list|,
name|DF_REF_REG_DEF
argument_list|,
name|DF_REF_ARTIFICIAL
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record the set of hard registers that are used in the exit block.  */
end_comment

begin_function
specifier|static
name|void
name|df_record_exit_block_uses
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|bitmap_clear
argument_list|(
name|df
operator|->
name|exit_block_uses
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dflow
operator|->
name|flags
operator|&
name|DF_HARD_REGS
operator|)
condition|)
return|return;
comment|/* If exiting needs the right stack value, consider the stack      pointer live at the end of the function.  */
if|if
condition|(
operator|(
name|HAVE_epilogue
operator|&&
name|epilogue_completed
operator|)
operator|||
operator|!
name|EXIT_IGNORE_STACK
operator|||
operator|(
operator|!
name|FRAME_POINTER_REQUIRED
operator|&&
operator|!
name|current_function_calls_alloca
operator|&&
name|flag_omit_frame_pointer
operator|)
operator|||
name|current_function_sp_is_unchanging
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|exit_block_uses
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the frame pointer if needed at the end of the function.      If we end up eliminating it, it will be removed from the live      list of each basic block by reload.  */
if|if
condition|(
operator|(
operator|!
name|reload_completed
operator|)
operator|||
name|frame_pointer_needed
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|exit_block_uses
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
comment|/* If they are different, also mark the hard frame pointer as live.  */
if|if
condition|(
operator|!
name|LOCAL_REGNO
argument_list|(
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|exit_block_uses
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
comment|/* Many architectures have a GP register even without flag_pic.      Assume the pic register is not in use, or will be handled by      other means, if it is not fixed.  */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|PIC_OFFSET_TABLE_REGNUM
operator|!=
name|INVALID_REGNUM
operator|&&
name|fixed_regs
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|exit_block_uses
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Mark all global registers, and all registers used by the      epilogue as being live at the end of the function since they      may be referenced by our caller.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
operator|||
name|EPILOGUE_USES
argument_list|(
name|i
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|exit_block_uses
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_epilogue
operator|&&
name|epilogue_completed
condition|)
block|{
comment|/* Mark all call-saved registers that we actually used.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|LOCAL_REGNO
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|i
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|exit_block_uses
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EH_RETURN_DATA_REGNO
comment|/* Mark the registers that will contain data for the handler.  */
if|if
condition|(
name|reload_completed
operator|&&
name|current_function_calls_eh_return
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|regno
init|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|==
name|INVALID_REGNUM
condition|)
break|break;
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|exit_block_uses
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EH_RETURN_STACKADJ_RTX
if|if
condition|(
operator|(
operator|!
name|HAVE_epilogue
operator|||
operator|!
name|epilogue_completed
operator|)
operator|&&
name|current_function_calls_eh_return
condition|)
block|{
name|rtx
name|tmp
init|=
name|EH_RETURN_STACKADJ_RTX
decl_stmt|;
if|if
condition|(
name|tmp
operator|&&
name|REG_P
argument_list|(
name|tmp
argument_list|)
condition|)
name|df_mark_reg
argument_list|(
name|tmp
argument_list|,
name|df
operator|->
name|exit_block_uses
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EH_RETURN_HANDLER_RTX
if|if
condition|(
operator|(
operator|!
name|HAVE_epilogue
operator|||
operator|!
name|epilogue_completed
operator|)
operator|&&
name|current_function_calls_eh_return
condition|)
block|{
name|rtx
name|tmp
init|=
name|EH_RETURN_HANDLER_RTX
decl_stmt|;
if|if
condition|(
name|tmp
operator|&&
name|REG_P
argument_list|(
name|tmp
argument_list|)
condition|)
name|df_mark_reg
argument_list|(
name|tmp
argument_list|,
name|df
operator|->
name|exit_block_uses
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Mark function return value.  */
name|diddle_return_value
argument_list|(
name|df_mark_reg
argument_list|,
operator|(
name|void
operator|*
operator|)
name|df
operator|->
name|exit_block_uses
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_HARD_REGS
condition|)
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|df->exit_block_uses
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
name|df_uses_record
argument_list|(
name|dflow
argument_list|,
operator|&
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
name|NULL
argument_list|,
name|DF_REF_ARTIFICIAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|bool
name|initialized
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize some platform specific structures.  */
end_comment

begin_function
name|void
name|df_hard_reg_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|eliminables
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
endif|#
directive|endif
comment|/* After reload, some ports add certain bits to regs_ever_live so      this cannot be reset.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
name|memset
argument_list|(
name|regs_ever_live
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|regs_ever_live
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialized
condition|)
return|return;
name|bitmap_obstack_initialize
argument_list|(
operator|&
name|persistent_obstack
argument_list|)
expr_stmt|;
comment|/* Record which registers will be eliminated.  We use this in      mark_used_regs.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|elim_reg_set
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ARRAY_SIZE
argument_list|(
name|eliminables
argument_list|)
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|elim_reg_set
argument_list|,
name|eliminables
index|[
name|i
index|]
operator|.
name|from
argument_list|)
expr_stmt|;
else|#
directive|else
name|SET_HARD_REG_BIT
argument_list|(
name|elim_reg_set
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|df_invalidated_by_call
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|persistent_obstack
argument_list|)
expr_stmt|;
comment|/* Inconveniently, this is only readily available in hard reg set      form.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|i
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|df_invalidated_by_call
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|initialized
operator|=
name|true
expr_stmt|;
block|}
end_function

end_unit

