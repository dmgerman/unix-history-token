begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Routines for discovering and unpropagating edge equivalences.    Copyright (C) 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"domwalk.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"tree-ssa-propagate.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* The basic structure describing an equivalency created by traversing    an edge.  Traversing the edge effectively means that we can assume    that we've seen an assignment LHS = RHS.  */
end_comment

begin_struct
struct|struct
name|edge_equivalency
block|{
name|tree
name|rhs
decl_stmt|;
name|tree
name|lhs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This routine finds and records edge equivalences for every edge    in the CFG.     When complete, each edge that creates an equivalency will have an    EDGE_EQUIVALENCY structure hanging off the edge's AUX field.     The caller is responsible for freeing the AUX fields.  */
end_comment

begin_function
specifier|static
name|void
name|associate_equivalences_with_edges
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
comment|/* Walk over each block.  If the block ends with a control statement,      then it might create a useful equivalence.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
init|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
comment|/* If the block does not end with a COND_EXPR or SWITCH_EXPR 	 then there is nothing to do.  */
if|if
condition|(
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
continue|continue;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stmt
condition|)
continue|continue;
comment|/* A COND_EXPR may create an equivalency in a variety of different 	 ways.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|tree
name|cond
init|=
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|edge
name|true_edge
decl_stmt|;
name|edge
name|false_edge
decl_stmt|;
name|struct
name|edge_equivalency
modifier|*
name|equivalency
decl_stmt|;
name|extract_true_false_edges_from_block
argument_list|(
name|bb
argument_list|,
operator|&
name|true_edge
argument_list|,
operator|&
name|false_edge
argument_list|)
expr_stmt|;
comment|/* If the conditional is a single variable 'X', record 'X = 1' 	     for the true edge and 'X = 0' on the false edge.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|cond
argument_list|)
condition|)
block|{
name|equivalency
operator|=
name|XNEW
argument_list|(
expr|struct
name|edge_equivalency
argument_list|)
expr_stmt|;
name|equivalency
operator|->
name|rhs
operator|=
name|constant_boolean_node
argument_list|(
literal|1
argument_list|,
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|)
expr_stmt|;
name|equivalency
operator|->
name|lhs
operator|=
name|cond
expr_stmt|;
name|true_edge
operator|->
name|aux
operator|=
name|equivalency
expr_stmt|;
name|equivalency
operator|=
name|XNEW
argument_list|(
expr|struct
name|edge_equivalency
argument_list|)
expr_stmt|;
name|equivalency
operator|->
name|rhs
operator|=
name|constant_boolean_node
argument_list|(
literal|0
argument_list|,
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|)
expr_stmt|;
name|equivalency
operator|->
name|lhs
operator|=
name|cond
expr_stmt|;
name|false_edge
operator|->
name|aux
operator|=
name|equivalency
expr_stmt|;
block|}
comment|/* Equality tests may create one or two equivalences.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|NE_EXPR
condition|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Special case comparing booleans against a constant as we 		 know the value of OP0 on both arms of the branch.  i.e., we 		 can record an equivalence for OP0 rather than COND.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|op0
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|op1
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ_EXPR
condition|)
block|{
name|equivalency
operator|=
name|XNEW
argument_list|(
expr|struct
name|edge_equivalency
argument_list|)
expr_stmt|;
name|equivalency
operator|->
name|lhs
operator|=
name|op0
expr_stmt|;
name|equivalency
operator|->
name|rhs
operator|=
operator|(
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|?
name|boolean_false_node
else|:
name|boolean_true_node
operator|)
expr_stmt|;
name|true_edge
operator|->
name|aux
operator|=
name|equivalency
expr_stmt|;
name|equivalency
operator|=
name|XNEW
argument_list|(
expr|struct
name|edge_equivalency
argument_list|)
expr_stmt|;
name|equivalency
operator|->
name|lhs
operator|=
name|op0
expr_stmt|;
name|equivalency
operator|->
name|rhs
operator|=
operator|(
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|?
name|boolean_true_node
else|:
name|boolean_false_node
operator|)
expr_stmt|;
name|false_edge
operator|->
name|aux
operator|=
name|equivalency
expr_stmt|;
block|}
else|else
block|{
name|equivalency
operator|=
name|XNEW
argument_list|(
expr|struct
name|edge_equivalency
argument_list|)
expr_stmt|;
name|equivalency
operator|->
name|lhs
operator|=
name|op0
expr_stmt|;
name|equivalency
operator|->
name|rhs
operator|=
operator|(
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|?
name|boolean_true_node
else|:
name|boolean_false_node
operator|)
expr_stmt|;
name|true_edge
operator|->
name|aux
operator|=
name|equivalency
expr_stmt|;
name|equivalency
operator|=
name|XNEW
argument_list|(
expr|struct
name|edge_equivalency
argument_list|)
expr_stmt|;
name|equivalency
operator|->
name|lhs
operator|=
name|op0
expr_stmt|;
name|equivalency
operator|->
name|rhs
operator|=
operator|(
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|?
name|boolean_false_node
else|:
name|boolean_true_node
operator|)
expr_stmt|;
name|false_edge
operator|->
name|aux
operator|=
name|equivalency
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
name|is_gimple_min_invariant
argument_list|(
name|op1
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|op1
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* For IEEE, -0.0 == 0.0, so we don't necessarily know 		     the sign of a variable compared against zero.  If 		     we're honoring signed zeros, then we cannot record 		     this value unless we know that the value is nonzero.  */
if|if
condition|(
name|HONOR_SIGNED_ZEROS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|REAL_CST
operator|||
name|REAL_VALUES_EQUAL
argument_list|(
name|dconst0
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
name|equivalency
operator|=
name|XNEW
argument_list|(
expr|struct
name|edge_equivalency
argument_list|)
expr_stmt|;
name|equivalency
operator|->
name|lhs
operator|=
name|op0
expr_stmt|;
name|equivalency
operator|->
name|rhs
operator|=
name|op1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ_EXPR
condition|)
name|true_edge
operator|->
name|aux
operator|=
name|equivalency
expr_stmt|;
else|else
name|false_edge
operator|->
name|aux
operator|=
name|equivalency
expr_stmt|;
block|}
block|}
comment|/* ??? TRUTH_NOT_EXPR can create an equivalence too.  */
block|}
comment|/* For a SWITCH_EXPR, a case label which represents a single 	 value and which is the only case label which reaches the 	 target block creates an equivalence.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|SWITCH_EXPR
condition|)
block|{
name|tree
name|cond
init|=
name|SWITCH_COND
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|cond
argument_list|)
condition|)
block|{
name|tree
name|labels
init|=
name|SWITCH_LABELS
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_labels
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|labels
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|info
init|=
name|XCNEWVEC
argument_list|(
name|tree
argument_list|,
name|n_basic_blocks
argument_list|)
decl_stmt|;
comment|/* Walk over the case label vector.  Record blocks 		 which are reached by a single case label which represents 		 a single value.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_labels
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|label
init|=
name|TREE_VEC_ELT
argument_list|(
name|labels
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|basic_block
name|bb
init|=
name|label_to_block
argument_list|(
name|CASE_LABEL
argument_list|(
name|label
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|CASE_HIGH
argument_list|(
name|label
argument_list|)
operator|||
operator|!
name|CASE_LOW
argument_list|(
name|label
argument_list|)
operator|||
name|info
index|[
name|bb
operator|->
name|index
index|]
condition|)
name|info
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|error_mark_node
expr_stmt|;
else|else
name|info
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|label
expr_stmt|;
block|}
comment|/* Now walk over the blocks to determine which ones were 		 marked as being reached by a useful case label.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|node
init|=
name|info
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
operator|&&
name|node
operator|!=
name|error_mark_node
condition|)
block|{
name|tree
name|x
init|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|CASE_LOW
argument_list|(
name|node
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|edge_equivalency
modifier|*
name|equivalency
decl_stmt|;
comment|/* Record an equivalency on the edge from BB to basic 			 block I.  */
name|equivalency
operator|=
name|XNEW
argument_list|(
expr|struct
name|edge_equivalency
argument_list|)
expr_stmt|;
name|equivalency
operator|->
name|rhs
operator|=
name|x
expr_stmt|;
name|equivalency
operator|->
name|lhs
operator|=
name|cond
expr_stmt|;
name|find_edge
argument_list|(
name|bb
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|->
name|aux
operator|=
name|equivalency
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Translating out of SSA sometimes requires inserting copies and    constant initializations on edges to eliminate PHI nodes.     In some cases those copies and constant initializations are    redundant because the target already has the value on the    RHS of the assignment.     We previously tried to catch these cases after translating    out of SSA form.  However, that code often missed cases.  Worse    yet, the cases it missed were also often missed by the RTL    optimizers.  Thus the resulting code had redundant instructions.     This pass attempts to detect these situations before translating    out of SSA form.     The key concept that this pass is built upon is that these    redundant copies and constant initializations often occur    due to constant/copy propagating equivalences resulting from    COND_EXPRs and SWITCH_EXPRs.     We want to do those propagations as they can sometimes allow    the SSA optimizers to do a better job.  However, in the cases    where such propagations do not result in further optimization,    we would like to "undo" the propagation to avoid the redundant    copies and constant initializations.     This pass works by first associating equivalences with edges in    the CFG.  For example, the edge leading from a SWITCH_EXPR to    its associated CASE_LABEL will have an equivalency between    SWITCH_COND and the value in the case label.     Once we have found the edge equivalences, we proceed to walk    the CFG in dominator order.  As we traverse edges we record    equivalences associated with those edges we traverse.     When we encounter a PHI node, we walk its arguments to see if we    have an equivalence for the PHI argument.  If so, then we replace    the argument.     Equivalences are looked up based on their value (think of it as    the RHS of an assignment).   A value may be an SSA_NAME or an    invariant.  We may have several SSA_NAMEs with the same value,    so with each value we have a list of SSA_NAMEs that have the    same value.  */
end_comment

begin_comment
comment|/* As we enter each block we record the value for any edge equivalency    leading to this block.  If no such edge equivalency exists, then we    record NULL.  These equivalences are live until we leave the dominator    subtree rooted at the block where we record the equivalency.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|equiv_stack
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Global hash table implementing a mapping from invariant values    to a list of SSA_NAMEs which have the same value.  We might be    able to reuse tree-vn for this code.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|equiv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Main structure for recording equivalences into our hash table.  */
end_comment

begin_struct
struct|struct
name|equiv_hash_elt
block|{
comment|/* The value/key of this entry.  */
name|tree
name|value
decl_stmt|;
comment|/* List of SSA_NAMEs which have the same value/key.  */
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|equivalences
expr_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|uncprop_initialize_block
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uncprop_finalize_block
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uncprop_into_successor_phis
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Hashing and equality routines for the hash table.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|equiv_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|tree
name|value
init|=
operator|(
operator|(
expr|struct
name|equiv_hash_elt
operator|*
operator|)
name|p
operator|)
operator|->
name|value
decl_stmt|;
return|return
name|iterative_hash_expr
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|equiv_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
name|tree
name|value1
init|=
operator|(
operator|(
expr|struct
name|equiv_hash_elt
operator|*
operator|)
name|p1
operator|)
operator|->
name|value
decl_stmt|;
name|tree
name|value2
init|=
operator|(
operator|(
expr|struct
name|equiv_hash_elt
operator|*
operator|)
name|p2
operator|)
operator|->
name|value
decl_stmt|;
return|return
name|operand_equal_p
argument_list|(
name|value1
argument_list|,
name|value2
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Free an instance of equiv_hash_elt.  */
end_comment

begin_function
specifier|static
name|void
name|equiv_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|equiv_hash_elt
modifier|*
name|elt
init|=
operator|(
expr|struct
name|equiv_hash_elt
operator|*
operator|)
name|p
decl_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|elt
operator|->
name|equivalences
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the most recently recorded equivalency for VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|remove_equivalence
parameter_list|(
name|tree
name|value
parameter_list|)
block|{
name|struct
name|equiv_hash_elt
name|equiv_hash_elt
decl_stmt|,
modifier|*
name|equiv_hash_elt_p
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|equiv_hash_elt
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|equiv_hash_elt
operator|.
name|equivalences
operator|=
name|NULL
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|equiv
argument_list|,
operator|&
name|equiv_hash_elt
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
name|equiv_hash_elt_p
operator|=
operator|(
expr|struct
name|equiv_hash_elt
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|equiv_hash_elt_p
operator|->
name|equivalences
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record EQUIVALENCE = VALUE into our hash table.  */
end_comment

begin_function
specifier|static
name|void
name|record_equiv
parameter_list|(
name|tree
name|value
parameter_list|,
name|tree
name|equivalence
parameter_list|)
block|{
name|struct
name|equiv_hash_elt
modifier|*
name|equiv_hash_elt
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|equiv_hash_elt
operator|=
name|XNEW
argument_list|(
expr|struct
name|equiv_hash_elt
argument_list|)
expr_stmt|;
name|equiv_hash_elt
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|equiv_hash_elt
operator|->
name|equivalences
operator|=
name|NULL
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|equiv
argument_list|,
name|equiv_hash_elt
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|NULL
condition|)
operator|*
name|slot
operator|=
operator|(
name|void
operator|*
operator|)
name|equiv_hash_elt
expr_stmt|;
else|else
name|free
argument_list|(
name|equiv_hash_elt
argument_list|)
expr_stmt|;
name|equiv_hash_elt
operator|=
operator|(
expr|struct
name|equiv_hash_elt
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|equiv_hash_elt
operator|->
name|equivalences
argument_list|,
name|equivalence
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Main driver for un-cprop.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|tree_ssa_uncprop
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dom_walk_data
name|walk_data
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|associate_equivalences_with_edges
argument_list|()
expr_stmt|;
comment|/* Create our global data structures.  */
name|equiv
operator|=
name|htab_create
argument_list|(
literal|1024
argument_list|,
name|equiv_hash
argument_list|,
name|equiv_eq
argument_list|,
name|equiv_free
argument_list|)
expr_stmt|;
name|equiv_stack
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* We're going to do a dominator walk, so ensure that we have      dominance information.  */
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* Setup callbacks for the generic dominator tree walker.  */
name|walk_data
operator|.
name|walk_stmts_backward
operator|=
name|false
expr_stmt|;
name|walk_data
operator|.
name|dom_direction
operator|=
name|CDI_DOMINATORS
expr_stmt|;
name|walk_data
operator|.
name|initialize_block_local_data
operator|=
name|NULL
expr_stmt|;
name|walk_data
operator|.
name|before_dom_children_before_stmts
operator|=
name|uncprop_initialize_block
expr_stmt|;
name|walk_data
operator|.
name|before_dom_children_walk_stmts
operator|=
name|NULL
expr_stmt|;
name|walk_data
operator|.
name|before_dom_children_after_stmts
operator|=
name|uncprop_into_successor_phis
expr_stmt|;
name|walk_data
operator|.
name|after_dom_children_before_stmts
operator|=
name|NULL
expr_stmt|;
name|walk_data
operator|.
name|after_dom_children_walk_stmts
operator|=
name|NULL
expr_stmt|;
name|walk_data
operator|.
name|after_dom_children_after_stmts
operator|=
name|uncprop_finalize_block
expr_stmt|;
name|walk_data
operator|.
name|global_data
operator|=
name|NULL
expr_stmt|;
name|walk_data
operator|.
name|block_local_data_size
operator|=
literal|0
expr_stmt|;
name|walk_data
operator|.
name|interesting_blocks
operator|=
name|NULL
expr_stmt|;
comment|/* Now initialize the dominator walker.  */
name|init_walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|)
expr_stmt|;
comment|/* Recursively walk the dominator tree undoing unprofitable      constant/copy propagations.  */
name|walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
comment|/* Finalize and clean up.  */
name|fini_walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|)
expr_stmt|;
comment|/* EQUIV_STACK should already be empty at this point, so we just      need to empty elements out of the hash table, free EQUIV_STACK,      and cleanup the AUX field on the edges.  */
name|htab_delete
argument_list|(
name|equiv
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|equiv_stack
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|aux
condition|)
block|{
name|free
argument_list|(
name|e
operator|->
name|aux
argument_list|)
expr_stmt|;
name|e
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* We have finished processing the dominator children of BB, perform    any finalization actions in preparation for leaving this node in    the dominator tree.  */
end_comment

begin_function
specifier|static
name|void
name|uncprop_finalize_block
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Pop the topmost value off the equiv stack.  */
name|tree
name|value
init|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|equiv_stack
argument_list|)
decl_stmt|;
comment|/* If that value was non-null, then pop the topmost equivalency off      its equivalency stack.  */
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|remove_equivalence
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unpropagate values from PHI nodes in successor blocks of BB.  */
end_comment

begin_function
specifier|static
name|void
name|uncprop_into_successor_phis
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
comment|/* For each successor edge, first temporarily record any equivalence      on that edge.  Then unpropagate values in any PHI nodes at the      destination of the edge.  Then remove the temporary equivalence.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
name|tree
name|phi
init|=
name|phi_nodes
argument_list|(
name|e
operator|->
name|dest
argument_list|)
decl_stmt|;
comment|/* If there are no PHI nodes in this destination, then there is 	 no sense in recording any equivalences.  */
if|if
condition|(
operator|!
name|phi
condition|)
continue|continue;
comment|/* Record any equivalency associated with E.  */
if|if
condition|(
name|e
operator|->
name|aux
condition|)
block|{
name|struct
name|edge_equivalency
modifier|*
name|equiv
init|=
operator|(
expr|struct
name|edge_equivalency
operator|*
operator|)
name|e
operator|->
name|aux
decl_stmt|;
name|record_equiv
argument_list|(
name|equiv
operator|->
name|rhs
argument_list|,
name|equiv
operator|->
name|lhs
argument_list|)
expr_stmt|;
block|}
comment|/* Walk over the PHI nodes, unpropagating values.  */
for|for
control|(
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
comment|/* Sigh.  We'll have more efficient access to this one day.  */
name|tree
name|arg
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|e
operator|->
name|dest_idx
argument_list|)
decl_stmt|;
name|struct
name|equiv_hash_elt
name|equiv_hash_elt
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
comment|/* If the argument is not an invariant, or refers to the same 	     underlying variable as the PHI result, then there's no 	     point in un-propagating the argument.  */
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
name|arg
argument_list|)
operator|&&
name|SSA_NAME_VAR
argument_list|(
name|arg
argument_list|)
operator|!=
name|SSA_NAME_VAR
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Lookup this argument's value in the hash table.  */
name|equiv_hash_elt
operator|.
name|value
operator|=
name|arg
expr_stmt|;
name|equiv_hash_elt
operator|.
name|equivalences
operator|=
name|NULL
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|equiv
argument_list|,
operator|&
name|equiv_hash_elt
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
condition|)
block|{
name|struct
name|equiv_hash_elt
modifier|*
name|elt
init|=
operator|(
expr|struct
name|equiv_hash_elt
operator|*
operator|)
operator|*
name|slot
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Walk every equivalence with the same value.  If we find 		 one with the same underlying variable as the PHI result, 		 then replace the value in the argument with its equivalent 		 SSA_NAME.  Use the most recent equivalence as hopefully 		 that results in shortest lifetimes.  */
for|for
control|(
name|j
operator|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|elt
operator|->
name|equivalences
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|tree
name|equiv
init|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|elt
operator|->
name|equivalences
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|SSA_NAME_VAR
argument_list|(
name|equiv
argument_list|)
operator|==
name|SSA_NAME_VAR
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
condition|)
block|{
name|SET_PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|e
operator|->
name|dest_idx
argument_list|,
name|equiv
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* If we had an equivalence associated with this edge, remove it.  */
if|if
condition|(
name|e
operator|->
name|aux
condition|)
block|{
name|struct
name|edge_equivalency
modifier|*
name|equiv
init|=
operator|(
expr|struct
name|edge_equivalency
operator|*
operator|)
name|e
operator|->
name|aux
decl_stmt|;
name|remove_equivalence
argument_list|(
name|equiv
operator|->
name|rhs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Ignoring loop backedges, if BB has precisely one incoming edge then    return that edge.  Otherwise return NULL.  */
end_comment

begin_function
specifier|static
name|edge
name|single_incoming_edge_ignoring_loop_edges
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|retval
init|=
name|NULL
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
comment|/* A loop back edge can be identified by the destination of 	 the edge dominating the source of the edge.  */
if|if
condition|(
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|e
operator|->
name|src
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
continue|continue;
comment|/* If we have already seen a non-loop edge, then we must have 	 multiple incoming non-loop edges and thus we return NULL.  */
if|if
condition|(
name|retval
condition|)
return|return
name|NULL
return|;
comment|/* This is the first non-loop incoming edge we have found.  Record 	 it.  */
name|retval
operator|=
name|e
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uncprop_initialize_block
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|basic_block
name|parent
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|bool
name|recorded
init|=
name|false
decl_stmt|;
comment|/* If this block is dominated by a single incoming edge and that edge      has an equivalency, then record the equivalency and push the      VALUE onto EQUIV_STACK.  Else push a NULL entry on EQUIV_STACK.  */
name|parent
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
name|e
operator|=
name|single_incoming_edge_ignoring_loop_edges
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|&&
name|e
operator|->
name|src
operator|==
name|parent
operator|&&
name|e
operator|->
name|aux
condition|)
block|{
name|struct
name|edge_equivalency
modifier|*
name|equiv
init|=
operator|(
expr|struct
name|edge_equivalency
operator|*
operator|)
name|e
operator|->
name|aux
decl_stmt|;
name|record_equiv
argument_list|(
name|equiv
operator|->
name|rhs
argument_list|,
name|equiv
operator|->
name|lhs
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|equiv_stack
argument_list|,
name|equiv
operator|->
name|rhs
argument_list|)
expr_stmt|;
name|recorded
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|recorded
condition|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|equiv_stack
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_uncprop
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_tree_dom
operator|!=
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_uncprop
init|=
block|{
literal|"uncprop"
block|,
comment|/* name */
name|gate_uncprop
block|,
comment|/* gate */
name|tree_ssa_uncprop
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_SSA_UNCPROP
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_verify_ssa
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

