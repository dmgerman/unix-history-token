begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Exception handling and frame unwind runtime interface routines.    Copyright (C) 2001, 2002 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* @@@ Really this should be out of line, but this also causes link    compatibility problems with the base ABI.  This is slightly better    than duplicating code, however.  */
end_comment

begin_comment
comment|/* If using C++, references to abort have to be qualified with std::.  */
end_comment

begin_if
if|#
directive|if
name|__cplusplus
end_if

begin_define
define|#
directive|define
name|__gxx_abort
value|std::abort
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__gxx_abort
value|abort
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Pointer encodings, from dwarf2.h.  */
end_comment

begin_define
define|#
directive|define
name|DW_EH_PE_absptr
value|0x00
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_omit
value|0xff
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_uleb128
value|0x01
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_udata2
value|0x02
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_udata4
value|0x03
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_udata8
value|0x04
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_sleb128
value|0x09
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_sdata2
value|0x0A
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_sdata4
value|0x0B
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_sdata8
value|0x0C
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_signed
value|0x08
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_pcrel
value|0x10
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_textrel
value|0x20
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_datarel
value|0x30
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_funcrel
value|0x40
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_aligned
value|0x50
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_indirect
value|0x80
end_define

begin_escape
end_escape

begin_comment
comment|/* Given an encoding, return the number of bytes the format occupies.    This is only defined for fixed-size encodings, and so does not    include leb128.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|size_of_encoded_value
parameter_list|(
name|unsigned
name|char
name|encoding
parameter_list|)
block|{
if|if
condition|(
name|encoding
operator|==
name|DW_EH_PE_omit
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|encoding
operator|&
literal|0x07
condition|)
block|{
case|case
name|DW_EH_PE_absptr
case|:
return|return
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
return|;
case|case
name|DW_EH_PE_udata2
case|:
return|return
literal|2
return|;
case|case
name|DW_EH_PE_udata4
case|:
return|return
literal|4
return|;
case|case
name|DW_EH_PE_udata8
case|:
return|return
literal|8
return|;
block|}
name|__gxx_abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_BASE_OF_ENCODED_VALUE
end_ifndef

begin_comment
comment|/* Given an encoding and an _Unwind_Context, return the base to which    the encoding is relative.  This base may then be passed to    read_encoded_value_with_base for use when the _Unwind_Context is    not available.  */
end_comment

begin_function
specifier|static
name|_Unwind_Ptr
name|base_of_encoded_value
parameter_list|(
name|unsigned
name|char
name|encoding
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
if|if
condition|(
name|encoding
operator|==
name|DW_EH_PE_omit
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|encoding
operator|&
literal|0x70
condition|)
block|{
case|case
name|DW_EH_PE_absptr
case|:
case|case
name|DW_EH_PE_pcrel
case|:
case|case
name|DW_EH_PE_aligned
case|:
return|return
literal|0
return|;
case|case
name|DW_EH_PE_textrel
case|:
return|return
name|_Unwind_GetTextRelBase
argument_list|(
name|context
argument_list|)
return|;
case|case
name|DW_EH_PE_datarel
case|:
return|return
name|_Unwind_GetDataRelBase
argument_list|(
name|context
argument_list|)
return|;
case|case
name|DW_EH_PE_funcrel
case|:
return|return
name|_Unwind_GetRegionStart
argument_list|(
name|context
argument_list|)
return|;
block|}
name|__gxx_abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Read an unsigned leb128 value from P, store the value in VAL, return    P incremented past the value.  We assume that a word is large enough to    hold any value so encoded; if it is smaller than a pointer on some target,    pointers should not be leb128 encoded on that target.  */
end_comment

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|read_uleb128
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|_Unwind_Word
modifier|*
name|val
parameter_list|)
block|{
name|unsigned
name|int
name|shift
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
name|_Unwind_Word
name|result
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|byte
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|result
operator||=
operator|(
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
name|byte
operator|&
literal|0x80
condition|)
do|;
operator|*
name|val
operator|=
name|result
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Similar, but read a signed leb128 value.  */
end_comment

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|read_sleb128
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|_Unwind_Sword
modifier|*
name|val
parameter_list|)
block|{
name|unsigned
name|int
name|shift
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
name|_Unwind_Word
name|result
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|byte
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|result
operator||=
operator|(
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
name|byte
operator|&
literal|0x80
condition|)
do|;
comment|/* Sign-extend a negative value.  */
if|if
condition|(
name|shift
operator|<
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|result
argument_list|)
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|!=
literal|0
condition|)
name|result
operator||=
operator|-
operator|(
literal|1L
operator|<<
name|shift
operator|)
expr_stmt|;
operator|*
name|val
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|result
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Load an encoded value from memory at P.  The value is returned in VAL;    The function returns P incremented past the value.  BASE is as given    by base_of_encoded_value for this encoding in the appropriate context.  */
end_comment

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|read_encoded_value_with_base
parameter_list|(
name|unsigned
name|char
name|encoding
parameter_list|,
name|_Unwind_Ptr
name|base
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|_Unwind_Ptr
modifier|*
name|val
parameter_list|)
block|{
union|union
name|unaligned
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|u2
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|HI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|u4
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|SI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|u8
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|DI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|signed
name|s2
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|HI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|signed
name|s4
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|SI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|signed
name|s8
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|DI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|__packed__
operator|)
argument_list|)
union|;
name|union
name|unaligned
modifier|*
name|u
init|=
operator|(
expr|union
name|unaligned
operator|*
operator|)
name|p
decl_stmt|;
name|_Unwind_Ptr
name|result
decl_stmt|;
if|if
condition|(
name|encoding
operator|==
name|DW_EH_PE_aligned
condition|)
block|{
name|_Unwind_Ptr
name|a
init|=
operator|(
name|_Unwind_Ptr
operator|)
name|p
decl_stmt|;
name|a
operator|=
operator|(
name|a
operator|+
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
name|result
operator|=
operator|*
operator|(
name|_Unwind_Ptr
operator|*
operator|)
name|a
expr_stmt|;
name|p
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|a
operator|+
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|encoding
operator|&
literal|0x0f
condition|)
block|{
case|case
name|DW_EH_PE_absptr
case|:
name|result
operator|=
operator|(
name|_Unwind_Ptr
operator|)
name|u
operator|->
name|ptr
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_uleb128
case|:
block|{
name|_Unwind_Word
name|tmp
decl_stmt|;
name|p
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|_Unwind_Ptr
operator|)
name|tmp
expr_stmt|;
block|}
break|break;
case|case
name|DW_EH_PE_sleb128
case|:
block|{
name|_Unwind_Sword
name|tmp
decl_stmt|;
name|p
operator|=
name|read_sleb128
argument_list|(
name|p
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|_Unwind_Ptr
operator|)
name|tmp
expr_stmt|;
block|}
break|break;
case|case
name|DW_EH_PE_udata2
case|:
name|result
operator|=
name|u
operator|->
name|u2
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_udata4
case|:
name|result
operator|=
name|u
operator|->
name|u4
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_udata8
case|:
name|result
operator|=
name|u
operator|->
name|u8
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_sdata2
case|:
name|result
operator|=
name|u
operator|->
name|s2
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_sdata4
case|:
name|result
operator|=
name|u
operator|->
name|s4
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_sdata8
case|:
name|result
operator|=
name|u
operator|->
name|s8
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
break|break;
default|default:
name|__gxx_abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|result
operator|+=
operator|(
operator|(
name|encoding
operator|&
literal|0x70
operator|)
operator|==
name|DW_EH_PE_pcrel
condition|?
operator|(
name|_Unwind_Ptr
operator|)
name|u
else|:
name|base
operator|)
expr_stmt|;
if|if
condition|(
name|encoding
operator|&
name|DW_EH_PE_indirect
condition|)
name|result
operator|=
operator|*
operator|(
name|_Unwind_Ptr
operator|*
operator|)
name|result
expr_stmt|;
block|}
block|}
operator|*
name|val
operator|=
name|result
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_BASE_OF_ENCODED_VALUE
end_ifndef

begin_comment
comment|/* Like read_encoded_value_with_base, but get the base from the context    rather than providing it directly.  */
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|unsigned
name|char
modifier|*
name|read_encoded_value
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|unsigned
name|char
name|encoding
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|_Unwind_Ptr
modifier|*
name|val
parameter_list|)
block|{
return|return
name|read_encoded_value_with_base
argument_list|(
name|encoding
argument_list|,
name|base_of_encoded_value
argument_list|(
name|encoding
argument_list|,
name|context
argument_list|)
argument_list|,
name|p
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

