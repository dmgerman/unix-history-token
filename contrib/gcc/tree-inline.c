begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Control and data flow functions for trees.    Copyright 2001, 2002 Free Software Foundation, Inc.    Contributed by Alexandre Oliva<aoliva@redhat.com>  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* This should be eventually be generalized to other languages, but    this would require a shared function-as-trees infrastructure.  */
end_comment

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_comment
comment|/* 0 if we should not perform inlining.    1 if we should expand functions calls inline at the tree level.      2 if we should consider *all* functions to be inline     candidates.  */
end_comment

begin_decl_stmt
name|int
name|flag_inline_trees
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* To Do:     o In order to make inlining-on-trees work, we pessimized      function-local static constants.  In particular, they are now      always output, even when not addressed.  Fix this by treating      function-local static constants just like global static      constants; the back-end already knows not to output them if they      are not needed.     o Provide heuristics to clamp inlining of recursive template      calls?  */
end_comment

begin_comment
comment|/* Data required for function inlining.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|inline_data
block|{
comment|/* A stack of the functions we are inlining.  For example, if we are      compiling `f', which calls `g', which calls `h', and we are      inlining the body of `h', the stack will contain, `h', followed      by `g', followed by `f'.  The first few elements of the stack may      contain other functions that we know we should not recurse into,      even though they are not directly being inlined.  */
name|varray_type
name|fns
decl_stmt|;
comment|/* The index of the first element of FNS that really represents an      inlined function.  */
name|unsigned
name|first_inlined_fn
decl_stmt|;
comment|/* The label to jump to when a return statement is encountered.  If      this value is NULL, then return statements will simply be      remapped as return statements, rather than as jumps.  */
name|tree
name|ret_label
decl_stmt|;
comment|/* The map from local declarations in the inlined function to      equivalents in the function into which it is being inlined.  */
name|splay_tree
name|decl_map
decl_stmt|;
comment|/* Nonzero if we are currently within the cleanup for a      TARGET_EXPR.  */
name|int
name|in_target_cleanup_p
decl_stmt|;
comment|/* A stack of the TARGET_EXPRs that we are currently processing.  */
name|varray_type
name|target_exprs
decl_stmt|;
comment|/* A list of the functions current function has inlined.  */
name|varray_type
name|inlined_fns
decl_stmt|;
comment|/* The approximate number of statements we have inlined in the      current call stack.  */
name|int
name|inlined_stmts
decl_stmt|;
comment|/* We use the same mechanism to build clones that we do to perform      inlining.  However, there are a few places where we need to      distinguish between those two situations.  This flag is true if      we are cloning, rather than inlining.  */
name|bool
name|cloning_p
decl_stmt|;
comment|/* Hash table used to prevent walk_tree from visiting the same node      umpteen million times.  */
name|htab_t
name|tree_pruner
decl_stmt|;
block|}
name|inline_data
typedef|;
end_typedef

begin_comment
comment|/* Prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|initialize_inlined_parameters
name|PARAMS
argument_list|(
operator|(
name|inline_data
operator|*
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|declare_return_variable
name|PARAMS
argument_list|(
operator|(
name|inline_data
operator|*
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|copy_body_r
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|copy_body
name|PARAMS
argument_list|(
operator|(
name|inline_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|expand_call_inline
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_calls_inline
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|inline_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inlinable_function_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|inline_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|remap_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|inline_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remap_block
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|inline_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_scope_stmt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|inline_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The approximate number of instructions per statement.  This number    need not be particularly accurate; it is used only to make    decisions about when a function is too big to inline.  */
end_comment

begin_define
define|#
directive|define
name|INSNS_PER_STMT
value|(10)
end_define

begin_comment
comment|/* Remap DECL during the copying of the BLOCK tree for the function.  */
end_comment

begin_function
specifier|static
name|tree
name|remap_decl
parameter_list|(
name|decl
parameter_list|,
name|id
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|inline_data
modifier|*
name|id
decl_stmt|;
block|{
name|splay_tree_node
name|n
decl_stmt|;
name|tree
name|fn
decl_stmt|;
comment|/* We only remap local variables in the current function.  */
name|fn
operator|=
name|VARRAY_TOP_TREE
argument_list|(
name|id
operator|->
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|auto_var_in_fn_p
call|)
argument_list|(
name|decl
argument_list|,
name|fn
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* See if we have remapped this declaration.  */
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|id
operator|->
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|decl
argument_list|)
expr_stmt|;
comment|/* If we didn't already have an equivalent for this declaration,      create one now.  */
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* Make a copy of the variable or label.  */
name|t
operator|=
name|copy_decl_for_inlining
argument_list|(
name|decl
argument_list|,
name|fn
argument_list|,
name|VARRAY_TREE
argument_list|(
name|id
operator|->
name|fns
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The decl T could be a dynamic array or other variable size type, 	 in which case some fields need to be remapped because they may 	 contain SAVE_EXPRs.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|copy_node
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|copy_node
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|copy_body_r
argument_list|,
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|anon_aggr_type_p
call|)
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
comment|/* For a VAR_DECL of anonymous type, we must also copy the 	     member VAR_DECLS here and rechain the 	     DECL_ANON_UNION_ELEMS.  */
name|tree
name|members
init|=
name|NULL
decl_stmt|;
name|tree
name|src
decl_stmt|;
for|for
control|(
name|src
operator|=
name|DECL_ANON_UNION_ELEMS
argument_list|(
name|t
argument_list|)
init|;
name|src
condition|;
name|src
operator|=
name|TREE_CHAIN
argument_list|(
name|src
argument_list|)
control|)
block|{
name|tree
name|member
init|=
name|remap_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|src
argument_list|)
argument_list|,
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|src
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|members
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|member
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
name|DECL_ANON_UNION_ELEMS
argument_list|(
name|t
argument_list|)
operator|=
name|nreverse
argument_list|(
name|members
argument_list|)
expr_stmt|;
block|}
comment|/* Remember it, so that if we encounter this local entity 	 again we can reuse this copy.  */
name|n
operator|=
name|splay_tree_insert
argument_list|(
name|id
operator|->
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|decl
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|t
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tree
operator|)
name|n
operator|->
name|value
return|;
block|}
end_function

begin_comment
comment|/* Copy the SCOPE_STMT_BLOCK associated with SCOPE_STMT to contain    remapped versions of the variables therein.  And hook the new block    into the block-tree.  If non-NULL, the DECLS are declarations to    add to use instead of the BLOCK_VARS in the old block.  */
end_comment

begin_function
specifier|static
name|void
name|remap_block
parameter_list|(
name|scope_stmt
parameter_list|,
name|decls
parameter_list|,
name|id
parameter_list|)
name|tree
name|scope_stmt
decl_stmt|;
name|tree
name|decls
decl_stmt|;
name|inline_data
modifier|*
name|id
decl_stmt|;
block|{
comment|/* We cannot do this in the cleanup for a TARGET_EXPR since we do      not know whether or not expand_expr will actually write out the      code we put there.  If it does not, then we'll have more BLOCKs      than block-notes, and things will go awry.  At some point, we      should make the back-end handle BLOCK notes in a tidier way,      without requiring a strict correspondence to the block-tree; then      this check can go.  */
if|if
condition|(
name|id
operator|->
name|in_target_cleanup_p
condition|)
block|{
name|SCOPE_STMT_BLOCK
argument_list|(
name|scope_stmt
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return;
block|}
comment|/* If this is the beginning of a scope, remap the associated BLOCK.  */
if|if
condition|(
name|SCOPE_BEGIN_P
argument_list|(
name|scope_stmt
argument_list|)
operator|&&
name|SCOPE_STMT_BLOCK
argument_list|(
name|scope_stmt
argument_list|)
condition|)
block|{
name|tree
name|old_block
decl_stmt|;
name|tree
name|new_block
decl_stmt|;
name|tree
name|old_var
decl_stmt|;
name|tree
name|fn
decl_stmt|;
comment|/* Make the new block.  */
name|old_block
operator|=
name|SCOPE_STMT_BLOCK
argument_list|(
name|scope_stmt
argument_list|)
expr_stmt|;
name|new_block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|new_block
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|old_block
argument_list|)
expr_stmt|;
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|new_block
argument_list|)
operator|=
name|old_block
expr_stmt|;
name|SCOPE_STMT_BLOCK
argument_list|(
name|scope_stmt
argument_list|)
operator|=
name|new_block
expr_stmt|;
comment|/* Remap its variables.  */
for|for
control|(
name|old_var
operator|=
name|decls
condition|?
name|decls
else|:
name|BLOCK_VARS
argument_list|(
name|old_block
argument_list|)
init|;
name|old_var
condition|;
name|old_var
operator|=
name|TREE_CHAIN
argument_list|(
name|old_var
argument_list|)
control|)
block|{
name|tree
name|new_var
decl_stmt|;
comment|/* Remap the variable.  */
name|new_var
operator|=
name|remap_decl
argument_list|(
name|old_var
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* If we didn't remap this variable, so we can't mess with 	     its TREE_CHAIN.  If we remapped this variable to 	     something other than a declaration (say, if we mapped it 	     to a constant), then we must similarly omit any mention 	     of it here.  */
if|if
condition|(
operator|!
name|new_var
operator|||
operator|!
name|DECL_P
argument_list|(
name|new_var
argument_list|)
condition|)
empty_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|new_var
argument_list|)
operator|=
name|BLOCK_VARS
argument_list|(
name|new_block
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|new_block
argument_list|)
operator|=
name|new_var
expr_stmt|;
block|}
block|}
comment|/* We put the BLOCK_VARS in reverse order; fix that now.  */
name|BLOCK_VARS
argument_list|(
name|new_block
argument_list|)
operator|=
name|nreverse
argument_list|(
name|BLOCK_VARS
argument_list|(
name|new_block
argument_list|)
argument_list|)
expr_stmt|;
name|fn
operator|=
name|VARRAY_TREE
argument_list|(
name|id
operator|->
name|fns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|cloning_p
condition|)
comment|/* We're building a clone; DECL_INITIAL is still 	   error_mark_node, and current_binding_level is the parm 	   binding level.  */
name|insert_block
argument_list|(
name|new_block
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Attach this new block after the DECL_INITIAL block for the 	     function into which this block is being inlined.  In 	     rest_of_compilation we will straighten out the BLOCK tree.  */
name|tree
modifier|*
name|first_block
decl_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
condition|)
name|first_block
operator|=
operator|&
name|BLOCK_CHAIN
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|first_block
operator|=
operator|&
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|BLOCK_CHAIN
argument_list|(
name|new_block
argument_list|)
operator|=
operator|*
name|first_block
expr_stmt|;
operator|*
name|first_block
operator|=
name|new_block
expr_stmt|;
block|}
comment|/* Remember the remapped block.  */
name|splay_tree_insert
argument_list|(
name|id
operator|->
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|old_block
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|new_block
argument_list|)
expr_stmt|;
block|}
comment|/* If this is the end of a scope, set the SCOPE_STMT_BLOCK to be the      remapped block.  */
elseif|else
if|if
condition|(
name|SCOPE_END_P
argument_list|(
name|scope_stmt
argument_list|)
operator|&&
name|SCOPE_STMT_BLOCK
argument_list|(
name|scope_stmt
argument_list|)
condition|)
block|{
name|splay_tree_node
name|n
decl_stmt|;
comment|/* Find this block in the table of remapped things.  */
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|id
operator|->
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|SCOPE_STMT_BLOCK
argument_list|(
name|scope_stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
name|abort
argument_list|()
expr_stmt|;
name|SCOPE_STMT_BLOCK
argument_list|(
name|scope_stmt
argument_list|)
operator|=
operator|(
name|tree
operator|)
name|n
operator|->
name|value
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copy the SCOPE_STMT pointed to by TP.  */
end_comment

begin_function
specifier|static
name|void
name|copy_scope_stmt
parameter_list|(
name|tp
parameter_list|,
name|walk_subtrees
parameter_list|,
name|id
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
decl_stmt|;
name|inline_data
modifier|*
name|id
decl_stmt|;
block|{
name|tree
name|block
decl_stmt|;
comment|/* Remember whether or not this statement was nullified.  When      making a copy, copy_tree_r always sets SCOPE_NULLIFIED_P (and      doesn't copy the SCOPE_STMT_BLOCK) to free callers from having to      deal with copying BLOCKs if they do not wish to do so.  */
name|block
operator|=
name|SCOPE_STMT_BLOCK
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
comment|/* Copy (and replace) the statement.  */
name|copy_tree_r
argument_list|(
name|tp
argument_list|,
name|walk_subtrees
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Restore the SCOPE_STMT_BLOCK.  */
name|SCOPE_STMT_BLOCK
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
name|block
expr_stmt|;
comment|/* Remap the associated block.  */
name|remap_block
argument_list|(
operator|*
name|tp
argument_list|,
name|NULL_TREE
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from copy_body via walk_tree.  DATA is really an    `inline_data *'.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_body_r
parameter_list|(
name|tp
parameter_list|,
name|walk_subtrees
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|inline_data
modifier|*
name|id
decl_stmt|;
name|tree
name|fn
decl_stmt|;
comment|/* Set up.  */
name|id
operator|=
operator|(
name|inline_data
operator|*
operator|)
name|data
expr_stmt|;
name|fn
operator|=
name|VARRAY_TOP_TREE
argument_list|(
name|id
operator|->
name|fns
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* All automatic variables should have a DECL_CONTEXT indicating      what function they come from.  */
block|if ((TREE_CODE (*tp) == VAR_DECL || TREE_CODE (*tp) == LABEL_DECL)&& DECL_NAMESPACE_SCOPE_P (*tp))     if (! DECL_EXTERNAL (*tp)&& ! TREE_STATIC (*tp))       abort ();
endif|#
directive|endif
comment|/* If this is a RETURN_STMT, change it into an EXPR_STMT and a      GOTO_STMT with the RET_LABEL as its target.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|RETURN_STMT
operator|&&
name|id
operator|->
name|ret_label
condition|)
block|{
name|tree
name|return_stmt
init|=
operator|*
name|tp
decl_stmt|;
name|tree
name|goto_stmt
decl_stmt|;
comment|/* Build the GOTO_STMT.  */
name|goto_stmt
operator|=
name|build_stmt
argument_list|(
name|GOTO_STMT
argument_list|,
name|id
operator|->
name|ret_label
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|goto_stmt
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|return_stmt
argument_list|)
expr_stmt|;
name|GOTO_FAKE_P
argument_list|(
name|goto_stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If we're returning something, just turn that into an 	 assignment into the equivalent of the original 	 RESULT_DECL.  */
if|if
condition|(
name|RETURN_EXPR
argument_list|(
name|return_stmt
argument_list|)
condition|)
block|{
operator|*
name|tp
operator|=
name|build_stmt
argument_list|(
name|EXPR_STMT
argument_list|,
name|RETURN_EXPR
argument_list|(
name|return_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|STMT_IS_FULL_EXPR_P
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* And then jump to the end of the function.  */
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
name|goto_stmt
expr_stmt|;
block|}
comment|/* If we're not returning anything just do the jump.  */
else|else
operator|*
name|tp
operator|=
name|goto_stmt
expr_stmt|;
block|}
comment|/* Local variables and labels need to be replaced by equivalent      variables.  We don't want to copy static variables; there's only      one of those, no matter how many times we inline the containing      function.  */
elseif|else
if|if
condition|(
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|auto_var_in_fn_p
call|)
argument_list|(
operator|*
name|tp
argument_list|,
name|fn
argument_list|)
condition|)
block|{
name|tree
name|new_decl
decl_stmt|;
comment|/* Remap the declaration.  */
name|new_decl
operator|=
name|remap_decl
argument_list|(
operator|*
name|tp
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_decl
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Replace this variable with the copy.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|new_decl
expr_stmt|;
block|}
if|#
directive|if
literal|0
if|else if (nonstatic_local_decl_p (*tp)&& DECL_CONTEXT (*tp) != VARRAY_TREE (id->fns, 0))     abort ();
endif|#
directive|endif
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|remap_save_expr
argument_list|(
name|tp
argument_list|,
name|id
operator|->
name|decl_map
argument_list|,
name|VARRAY_TREE
argument_list|(
name|id
operator|->
name|fns
argument_list|,
literal|0
argument_list|)
argument_list|,
name|walk_subtrees
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|UNSAVE_EXPR
condition|)
comment|/* UNSAVE_EXPRs should not be generated until expansion time.  */
name|abort
argument_list|()
expr_stmt|;
comment|/* For a SCOPE_STMT, we must copy the associated block so that we      can write out debugging information for the inlined variables.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|SCOPE_STMT
operator|&&
operator|!
name|id
operator|->
name|in_target_cleanup_p
condition|)
name|copy_scope_stmt
argument_list|(
name|tp
argument_list|,
name|walk_subtrees
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* Otherwise, just copy the node.  Note that copy_tree_r already      knows not to copy VAR_DECLs, etc., so this is safe.  */
else|else
block|{
name|copy_tree_r
argument_list|(
name|tp
argument_list|,
name|walk_subtrees
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* The copied TARGET_EXPR has never been expanded, even if the 	 original node was expanded already.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|TARGET_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|3
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|auto_var_in_fn_p
call|)
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fn
argument_list|)
operator|)
condition|)
block|{
comment|/* Some assignments VAR = VAR; don't generate any rtl code 	     and thus don't count as variable modification.  Avoid 	     keeping bogosities like 0 = 0.  */
name|tree
name|decl
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|value
decl_stmt|;
name|splay_tree_node
name|n
decl_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|id
operator|->
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|value
operator|=
operator|(
name|tree
operator|)
name|n
operator|->
name|value
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
operator|||
name|TREE_READONLY_DECL_P
argument_list|(
name|value
argument_list|)
condition|)
operator|*
name|tp
operator|=
name|value
expr_stmt|;
block|}
block|}
block|}
comment|/* Keep iterating.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Make a copy of the body of FN so that it can be inserted inline in    another function.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_body
parameter_list|(
name|id
parameter_list|)
name|inline_data
modifier|*
name|id
decl_stmt|;
block|{
name|tree
name|body
decl_stmt|;
name|body
operator|=
name|DECL_SAVED_TREE
argument_list|(
name|VARRAY_TOP_TREE
argument_list|(
name|id
operator|->
name|fns
argument_list|)
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|body
argument_list|,
name|copy_body_r
argument_list|,
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|body
return|;
block|}
end_function

begin_comment
comment|/* Generate code to initialize the parameters of the function at the    top of the stack in ID from the ARGS (presented as a TREE_LIST).  */
end_comment

begin_function
specifier|static
name|tree
name|initialize_inlined_parameters
parameter_list|(
name|id
parameter_list|,
name|args
parameter_list|,
name|fn
parameter_list|)
name|inline_data
modifier|*
name|id
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|tree
name|fn
decl_stmt|;
block|{
name|tree
name|init_stmts
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|tree
name|a
decl_stmt|;
name|tree
name|p
decl_stmt|;
comment|/* Figure out what the parameters are.  */
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Start with no initializations whatsoever.  */
name|init_stmts
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Loop through the parameter declarations, replacing each with an      equivalent VAR_DECL, appropriately initialized.  */
for|for
control|(
name|p
operator|=
name|parms
operator|,
name|a
operator|=
name|args
init|;
name|p
condition|;
name|a
operator|=
name|a
condition|?
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
else|:
name|a
operator|,
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|init_stmt
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|tree
name|value
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
comment|/* Find the initializer.  */
name|value
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|convert_parm_for_inlining
call|)
argument_list|(
name|p
argument_list|,
name|a
condition|?
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
else|:
name|NULL_TREE
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* If the parameter is never assigned to, we may not need to 	 create a new variable here at all.  Instead, we may be able 	 to just use the argument value.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|p
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|p
argument_list|)
operator|&&
name|value
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|value
argument_list|)
condition|)
block|{
comment|/* Simplify the value, if possible.  */
name|value
operator|=
name|fold
argument_list|(
name|DECL_P
argument_list|(
name|value
argument_list|)
condition|?
name|decl_constant_value
argument_list|(
name|value
argument_list|)
else|:
name|value
argument_list|)
expr_stmt|;
comment|/* We can't risk substituting complex expressions.  They 	     might contain variables that will be assigned to later. 	     Theoretically, we could check the expression to see if 	     all of the variables that determine its value are 	     read-only, but we don't bother.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
operator|||
name|TREE_READONLY_DECL_P
argument_list|(
name|value
argument_list|)
condition|)
block|{
comment|/* If this is a declaration, wrap it a NOP_EXPR so that 		 we don't try to put the VALUE on the list of 		 BLOCK_VARS.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|value
argument_list|)
condition|)
name|value
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|id
operator|->
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|p
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|value
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Make an equivalent VAR_DECL.  */
name|var
operator|=
name|copy_decl_for_inlining
argument_list|(
name|p
argument_list|,
name|fn
argument_list|,
name|VARRAY_TREE
argument_list|(
name|id
operator|->
name|fns
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Register the VAR_DECL as the equivalent for the PARM_DECL; 	 that way, when the PARM_DECL is encountered, it will be 	 automatically replaced by the VAR_DECL.  */
name|splay_tree_insert
argument_list|(
name|id
operator|->
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|p
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|var
argument_list|)
expr_stmt|;
comment|/* Declare this new variable.  */
name|init_stmt
operator|=
name|build_stmt
argument_list|(
name|DECL_STMT
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|init_stmt
argument_list|)
operator|=
name|init_stmts
expr_stmt|;
name|init_stmts
operator|=
name|init_stmt
expr_stmt|;
comment|/* Initialize this VAR_DECL from the equivalent argument.  If 	 the argument is an object, created via a constructor or copy, 	 this will not result in an extra copy: the TARGET_EXPR 	 representing the argument will be bound to VAR, and the 	 object will be constructed in VAR.  */
if|if
condition|(
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|var
argument_list|)
operator|=
name|value
expr_stmt|;
else|else
block|{
comment|/* Even if P was TREE_READONLY, the new VAR should not be. 	     In the original code, we would have constructed a 	     temporary, and then the function body would have never 	     changed the value of P.  However, now, we will be 	     constructing VAR directly.  The constructor body may 	     change its value multiple times as it is being 	     constructed.  Therefore, it must not be TREE_READONLY; 	     the back-end assumes that TREE_READONLY variable is 	     assigned to only once.  */
name|TREE_READONLY
argument_list|(
name|var
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Build a run-time initialization.  */
name|init_stmt
operator|=
name|build_stmt
argument_list|(
name|EXPR_STMT
argument_list|,
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add this initialization to the list.  Note that we want the 	     declaration *after* the initialization because we are going 	     to reverse all the initialization statements below.  */
name|TREE_CHAIN
argument_list|(
name|init_stmt
argument_list|)
operator|=
name|init_stmts
expr_stmt|;
name|init_stmts
operator|=
name|init_stmt
expr_stmt|;
block|}
comment|/* See if we need to clean up the declaration.  */
name|cleanup
operator|=
name|maybe_build_cleanup
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup
condition|)
block|{
name|tree
name|cleanup_stmt
decl_stmt|;
comment|/* Build the cleanup statement.  */
name|cleanup_stmt
operator|=
name|build_stmt
argument_list|(
name|CLEANUP_STMT
argument_list|,
name|var
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
comment|/* Add it to the *front* of the list; the list will be 	     reversed below.  */
name|TREE_CHAIN
argument_list|(
name|cleanup_stmt
argument_list|)
operator|=
name|init_stmts
expr_stmt|;
name|init_stmts
operator|=
name|cleanup_stmt
expr_stmt|;
block|}
block|}
comment|/* Evaluate trailing arguments.  */
for|for
control|(
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
block|{
name|tree
name|init_stmt
decl_stmt|;
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|value
operator|||
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|value
argument_list|)
condition|)
continue|continue;
name|init_stmt
operator|=
name|build_stmt
argument_list|(
name|EXPR_STMT
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|init_stmt
argument_list|)
operator|=
name|init_stmts
expr_stmt|;
name|init_stmts
operator|=
name|init_stmt
expr_stmt|;
block|}
comment|/* The initialization statements have been built up in reverse      order.  Straighten them out now.  */
return|return
name|nreverse
argument_list|(
name|init_stmts
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Declare a return variable to replace the RESULT_DECL for the    function we are calling.  An appropriate DECL_STMT is returned.    The USE_STMT is filled in to contain a use of the declaration to    indicate the return value of the function.  */
end_comment

begin_function
specifier|static
name|tree
name|declare_return_variable
parameter_list|(
name|id
parameter_list|,
name|use_stmt
parameter_list|)
name|struct
name|inline_data
modifier|*
name|id
decl_stmt|;
name|tree
modifier|*
name|use_stmt
decl_stmt|;
block|{
name|tree
name|fn
init|=
name|VARRAY_TOP_TREE
argument_list|(
name|id
operator|->
name|fns
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|DECL_RESULT
argument_list|(
name|fn
argument_list|)
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|int
name|need_return_decl
init|=
literal|1
decl_stmt|;
comment|/* We don't need to do anything for functions that don't return      anything.  */
if|if
condition|(
operator|!
name|result
operator|||
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|use_stmt
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|var
operator|=
operator|(
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|copy_res_decl_for_inlining
call|)
argument_list|(
name|result
argument_list|,
name|fn
argument_list|,
name|VARRAY_TREE
argument_list|(
name|id
operator|->
name|fns
argument_list|,
literal|0
argument_list|)
argument_list|,
name|id
operator|->
name|decl_map
argument_list|,
operator|&
name|need_return_decl
argument_list|,
operator|&
name|id
operator|->
name|target_exprs
argument_list|)
operator|)
expr_stmt|;
comment|/* Register the VAR_DECL as the equivalent for the RESULT_DECL; that      way, when the RESULT_DECL is encountered, it will be      automatically replaced by the VAR_DECL.  */
name|splay_tree_insert
argument_list|(
name|id
operator|->
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|result
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|var
argument_list|)
expr_stmt|;
comment|/* Build the USE_STMT.  If the return type of the function was      promoted, convert it back to the expected type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
operator|*
name|use_stmt
operator|=
name|build_stmt
argument_list|(
name|EXPR_STMT
argument_list|,
name|var
argument_list|)
expr_stmt|;
else|else
operator|*
name|use_stmt
operator|=
name|build_stmt
argument_list|(
name|EXPR_STMT
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
operator|*
name|use_stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Build the declaration statement if FN does not return an      aggregate.  */
if|if
condition|(
name|need_return_decl
condition|)
return|return
name|build_stmt
argument_list|(
name|DECL_STMT
argument_list|,
name|var
argument_list|)
return|;
comment|/* If FN does return an aggregate, there's no need to declare the      return variable; we're using a variable in our caller's frame.  */
else|else
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if a function can be inlined as a tree.  */
end_comment

begin_function
name|int
name|tree_inlinable_function_p
parameter_list|(
name|fn
parameter_list|)
name|tree
name|fn
decl_stmt|;
block|{
return|return
name|inlinable_function_p
argument_list|(
name|fn
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if FN is a function that can be inlined into the    inlining context ID_.  If ID_ is NULL, check whether the function    can be inlined at all.  */
end_comment

begin_function
specifier|static
name|int
name|inlinable_function_p
parameter_list|(
name|fn
parameter_list|,
name|id
parameter_list|)
name|tree
name|fn
decl_stmt|;
name|inline_data
modifier|*
name|id
decl_stmt|;
block|{
name|int
name|inlinable
decl_stmt|;
comment|/* If we've already decided this function shouldn't be inlined,      there's no need to check again.  */
if|if
condition|(
name|DECL_UNINLINABLE
argument_list|(
name|fn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Assume it is not inlinable.  */
name|inlinable
operator|=
literal|0
expr_stmt|;
comment|/* If we're not inlining things, then nothing is inlinable.  */
if|if
condition|(
operator|!
name|flag_inline_trees
condition|)
empty_stmt|;
comment|/* If we're not inlining all functions and the function was not      declared `inline', we don't inline it.  Don't think of      disregarding DECL_INLINE when flag_inline_trees == 2; it's the      front-end that must set DECL_INLINE in this case, because      dwarf2out loses if a function is inlined that doesn't have      DECL_INLINE set.  */
elseif|else
if|if
condition|(
operator|!
name|DECL_INLINE
argument_list|(
name|fn
argument_list|)
condition|)
empty_stmt|;
comment|/* We can't inline functions that are too big.  Only allow a single      function to eat up half of our budget.  Make special allowance      for extern inline functions, though.  */
elseif|else
if|if
condition|(
operator|!
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|disregard_inline_limits
call|)
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_NUM_STMTS
argument_list|(
name|fn
argument_list|)
operator|*
name|INSNS_PER_STMT
operator|>
name|MAX_INLINE_INSNS
operator|/
literal|2
condition|)
empty_stmt|;
comment|/* All is well.  We can inline this function.  Traditionally, GCC      has refused to inline functions using alloca, or functions whose      values are returned in a PARALLEL, and a few other such obscure      conditions.  We are not equally constrained at the tree level.  */
else|else
name|inlinable
operator|=
literal|1
expr_stmt|;
comment|/* Squirrel away the result so that we don't have to check again.  */
name|DECL_UNINLINABLE
argument_list|(
name|fn
argument_list|)
operator|=
operator|!
name|inlinable
expr_stmt|;
comment|/* Even if this function is not itself too big to inline, it might      be that we've done so much inlining already that we don't want to      risk too much inlining any more and thus halve the acceptable      size.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|disregard_inline_limits
call|)
argument_list|(
name|fn
argument_list|)
operator|&&
operator|(
operator|(
name|DECL_NUM_STMTS
argument_list|(
name|fn
argument_list|)
operator|+
operator|(
name|id
condition|?
name|id
operator|->
name|inlined_stmts
else|:
literal|0
operator|)
operator|)
operator|*
name|INSNS_PER_STMT
operator|>
name|MAX_INLINE_INSNS
operator|)
operator|&&
name|DECL_NUM_STMTS
argument_list|(
name|fn
argument_list|)
operator|*
name|INSNS_PER_STMT
operator|>
name|MAX_INLINE_INSNS
operator|/
literal|4
condition|)
name|inlinable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inlinable
operator|&&
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|cannot_inline_tree_fn
call|)
argument_list|(
operator|&
name|fn
argument_list|)
condition|)
name|inlinable
operator|=
literal|0
expr_stmt|;
comment|/* If we don't have the function body available, we can't inline      it.  */
if|if
condition|(
operator|!
name|DECL_SAVED_TREE
argument_list|(
name|fn
argument_list|)
condition|)
name|inlinable
operator|=
literal|0
expr_stmt|;
comment|/* Check again, language hooks may have modified it.  */
if|if
condition|(
operator|!
name|inlinable
operator|||
name|DECL_UNINLINABLE
argument_list|(
name|fn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Don't do recursive inlining, either.  We don't record this in      DECL_UNINLINABLE; we may be able to inline this function later.  */
if|if
condition|(
name|id
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|id
operator|->
name|fns
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|VARRAY_TREE
argument_list|(
name|id
operator|->
name|fns
argument_list|,
name|i
argument_list|)
operator|==
name|fn
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|DECL_INLINED_FNS
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|tree
name|inlined_fns
init|=
name|DECL_INLINED_FNS
argument_list|(
name|fn
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|inlined_fns
argument_list|)
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|inlined_fns
argument_list|,
name|j
argument_list|)
operator|==
name|VARRAY_TREE
argument_list|(
name|id
operator|->
name|fns
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
comment|/* Return the result.  */
return|return
name|inlinable
return|;
block|}
end_function

begin_comment
comment|/* If *TP is a CALL_EXPR, replace it with its inline expansion.  */
end_comment

begin_function
specifier|static
name|tree
name|expand_call_inline
parameter_list|(
name|tp
parameter_list|,
name|walk_subtrees
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|inline_data
modifier|*
name|id
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|tree
name|chain
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|tree
name|scope_stmt
decl_stmt|;
name|tree
name|use_stmt
decl_stmt|;
name|tree
name|arg_inits
decl_stmt|;
name|tree
modifier|*
name|inlined_body
decl_stmt|;
name|splay_tree
name|st
decl_stmt|;
comment|/* See what we've got.  */
name|id
operator|=
operator|(
name|inline_data
operator|*
operator|)
name|data
expr_stmt|;
name|t
operator|=
operator|*
name|tp
expr_stmt|;
comment|/* Recurse, but letting recursive invocations know that we are      inside the body of a TARGET_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
block|{
name|int
name|i
decl_stmt|,
name|len
init|=
name|first_rtl_op
argument_list|(
name|TARGET_EXPR
argument_list|)
decl_stmt|;
comment|/* We're walking our own subtrees.  */
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
comment|/* Push *TP on the stack of pending TARGET_EXPRs.  */
name|VARRAY_PUSH_TREE
argument_list|(
name|id
operator|->
name|target_exprs
argument_list|,
operator|*
name|tp
argument_list|)
expr_stmt|;
comment|/* Actually walk over them.  This loop is the body of 	 walk_trees, omitting the case where the TARGET_EXPR 	 itself is handled.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|2
condition|)
operator|++
name|id
operator|->
name|in_target_cleanup_p
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
name|i
argument_list|)
argument_list|,
name|expand_call_inline
argument_list|,
name|data
argument_list|,
name|id
operator|->
name|tree_pruner
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|2
condition|)
operator|--
name|id
operator|->
name|in_target_cleanup_p
expr_stmt|;
block|}
comment|/* We're done with this TARGET_EXPR now.  */
name|VARRAY_POP
argument_list|(
name|id
operator|->
name|target_exprs
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
comment|/* Because types were not copied in copy_body, CALL_EXPRs beneath        them should not be expanded.  This can happen if the type is a        dynamic array type, for example.  */
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
comment|/* From here on, we're only interested in CALL_EXPRs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|CALL_EXPR
condition|)
return|return
name|NULL_TREE
return|;
comment|/* First, see if we can figure out what function is being called.      If we cannot, then there is no hope of inlining the function.  */
name|fn
operator|=
name|get_callee_fndecl
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If fn is a declaration of a function in a nested scope that was      globally declared inline, we don't set its DECL_INITIAL.      However, we can't blindly follow DECL_ABSTRACT_ORIGIN because the      C++ front-end uses it for cdtors to refer to their internal      declarations, that are not real functions.  Fortunately those      don't have trees to be saved, so we can tell by checking their      DECL_SAVED_TREE.  */
if|if
condition|(
operator|!
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|fn
operator|=
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Don't try to inline functions that are not well-suited to      inlining.  */
if|if
condition|(
operator|!
name|inlinable_function_p
argument_list|(
name|fn
argument_list|,
name|id
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
operator|!
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|start_inlining
call|)
argument_list|(
name|fn
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Set the current filename and line number to the function we are      inlining so that when we create new _STMT nodes here they get      line numbers corresponding to the function we are calling.  We      wrap the whole inlined body in an EXPR_WITH_FILE_AND_LINE as well      because individual statements don't record the filename.  */
name|push_srcloc
argument_list|(
name|fn
operator|->
name|decl
operator|.
name|filename
argument_list|,
name|fn
operator|->
name|decl
operator|.
name|linenum
argument_list|)
expr_stmt|;
comment|/* Build a statement-expression containing code to initialize the      arguments, the actual inline expansion of the body, and a label      for the return statements within the function to jump to.  The      type of the statement expression is the return type of the      function call.  */
name|expr
operator|=
name|build1
argument_list|(
name|STMT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|make_node
argument_list|(
name|COMPOUND_STMT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There is no scope associated with the statement-expression.  */
name|STMT_EXPR_NO_SCOPE
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|stmt
operator|=
name|STMT_EXPR_STMT
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Local declarations will be replaced by their equivalents in this      map.  */
name|st
operator|=
name|id
operator|->
name|decl_map
expr_stmt|;
name|id
operator|->
name|decl_map
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Initialize the parameters.  */
name|arg_inits
operator|=
name|initialize_inlined_parameters
argument_list|(
name|id
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* Expand any inlined calls in the initializers.  Do this before we      push FN on the stack of functions we are inlining; we want to      inline calls to FN that appear in the initializers for the      parameters.  */
name|expand_calls_inline
argument_list|(
operator|&
name|arg_inits
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* And add them to the tree.  */
name|COMPOUND_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|chainon
argument_list|(
name|COMPOUND_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|arg_inits
argument_list|)
expr_stmt|;
comment|/* Record the function we are about to inline so that we can avoid      recursing into it.  */
name|VARRAY_PUSH_TREE
argument_list|(
name|id
operator|->
name|fns
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* Record the function we are about to inline if optimize_function      has not been called on it yet and we don't have it in the list.  */
if|if
condition|(
operator|!
name|DECL_INLINED_FNS
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|id
operator|->
name|inlined_fns
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|VARRAY_TREE
argument_list|(
name|id
operator|->
name|inlined_fns
argument_list|,
name|i
argument_list|)
operator|==
name|fn
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|VARRAY_PUSH_TREE
argument_list|(
name|id
operator|->
name|inlined_fns
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
comment|/* Return statements in the function body will be replaced by jumps      to the RET_LABEL.  */
name|id
operator|->
name|ret_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|id
operator|->
name|ret_label
argument_list|)
operator|=
name|VARRAY_TREE
argument_list|(
name|id
operator|->
name|fns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|!=
name|BLOCK
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Create a block to put the parameters in.  We have to do this      after the parameters have been remapped because remapping      parameters is different from remapping ordinary variables.  */
name|scope_stmt
operator|=
name|build_stmt
argument_list|(
name|SCOPE_STMT
argument_list|,
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|SCOPE_BEGIN_P
argument_list|(
name|scope_stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SCOPE_NO_CLEANUPS_P
argument_list|(
name|scope_stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
name|remap_block
argument_list|(
name|scope_stmt
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|scope_stmt
argument_list|)
operator|=
name|COMPOUND_BODY
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|COMPOUND_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|scope_stmt
expr_stmt|;
comment|/* Tell the debugging backends that this block represents the      outermost scope of the inlined function.  */
if|if
condition|(
name|SCOPE_STMT_BLOCK
argument_list|(
name|scope_stmt
argument_list|)
condition|)
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|SCOPE_STMT_BLOCK
argument_list|(
name|scope_stmt
argument_list|)
argument_list|)
operator|=
name|DECL_ORIGIN
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Declare the return variable for the function.  */
name|COMPOUND_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|chainon
argument_list|(
name|COMPOUND_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|declare_return_variable
argument_list|(
name|id
argument_list|,
operator|&
name|use_stmt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* After we've initialized the parameters, we insert the body of the      function itself.  */
name|inlined_body
operator|=
operator|&
name|COMPOUND_BODY
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|inlined_body
condition|)
name|inlined_body
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|inlined_body
argument_list|)
expr_stmt|;
operator|*
name|inlined_body
operator|=
name|copy_body
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|/* After the body of the function comes the RET_LABEL.  This must come      before we evaluate the returned value below, because that evalulation      may cause RTL to be generated.  */
name|COMPOUND_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|chainon
argument_list|(
name|COMPOUND_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|build_stmt
argument_list|(
name|LABEL_STMT
argument_list|,
name|id
operator|->
name|ret_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finally, mention the returned value so that the value of the      statement-expression is the returned value of the function.  */
name|COMPOUND_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|chainon
argument_list|(
name|COMPOUND_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|use_stmt
argument_list|)
expr_stmt|;
comment|/* Close the block for the parameters.  */
name|scope_stmt
operator|=
name|build_stmt
argument_list|(
name|SCOPE_STMT
argument_list|,
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|SCOPE_NO_CLEANUPS_P
argument_list|(
name|scope_stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
name|remap_block
argument_list|(
name|scope_stmt
argument_list|,
name|NULL_TREE
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|COMPOUND_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|chainon
argument_list|(
name|COMPOUND_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|scope_stmt
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
name|splay_tree_delete
argument_list|(
name|id
operator|->
name|decl_map
argument_list|)
expr_stmt|;
name|id
operator|->
name|decl_map
operator|=
name|st
expr_stmt|;
comment|/* The new expression has side-effects if the old one did.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Replace the call by the inlined body.  Wrap it in an      EXPR_WITH_FILE_LOCATION so that we'll get debugging line notes      pointing to the right place.  */
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|build_expr_wfl
argument_list|(
name|expr
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|fn
argument_list|)
argument_list|,
comment|/*col=*/
literal|0
argument_list|)
expr_stmt|;
name|EXPR_WFL_EMIT_LINE_NOTE
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
name|chain
expr_stmt|;
name|pop_srcloc
argument_list|()
expr_stmt|;
comment|/* If the value of the new expression is ignored, that's OK.  We      don't warn about this for CALL_EXPRs, so we shouldn't warn about      the equivalent inlined version either.  */
name|TREE_USED
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Our function now has more statements than it did before.  */
name|DECL_NUM_STMTS
argument_list|(
name|VARRAY_TREE
argument_list|(
name|id
operator|->
name|fns
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|+=
name|DECL_NUM_STMTS
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|id
operator|->
name|inlined_stmts
operator|+=
name|DECL_NUM_STMTS
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Recurse into the body of the just inlined function.  */
name|expand_calls_inline
argument_list|(
name|inlined_body
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|VARRAY_POP
argument_list|(
name|id
operator|->
name|fns
argument_list|)
expr_stmt|;
comment|/* If we've returned to the top level, clear out the record of how      much inlining has been done.  */
if|if
condition|(
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|id
operator|->
name|fns
argument_list|)
operator|==
name|id
operator|->
name|first_inlined_fn
condition|)
name|id
operator|->
name|inlined_stmts
operator|=
literal|0
expr_stmt|;
comment|/* Don't walk into subtrees.  We've already handled them above.  */
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|end_inlining
call|)
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Keep iterating.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Walk over the entire tree *TP, replacing CALL_EXPRs with inline    expansions as appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|expand_calls_inline
parameter_list|(
name|tp
parameter_list|,
name|id
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|inline_data
modifier|*
name|id
decl_stmt|;
block|{
comment|/* Search through *TP, replacing all calls to inline functions by      appropriate equivalents.  Use walk_tree in no-duplicates mode      to avoid exponential time complexity.  (We can't just use      walk_tree_without_duplicates, because of the special TARGET_EXPR      handling in expand_calls.  The hash table is set up in      optimize_function.  */
name|walk_tree
argument_list|(
name|tp
argument_list|,
name|expand_call_inline
argument_list|,
name|id
argument_list|,
name|id
operator|->
name|tree_pruner
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand calls to inline functions in the body of FN.  */
end_comment

begin_function
name|void
name|optimize_inline_calls
parameter_list|(
name|fn
parameter_list|)
name|tree
name|fn
decl_stmt|;
block|{
name|inline_data
name|id
decl_stmt|;
name|tree
name|prev_fn
decl_stmt|;
comment|/* Clear out ID.  */
name|memset
argument_list|(
operator|&
name|id
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't allow recursion into FN.  */
name|VARRAY_TREE_INIT
argument_list|(
name|id
operator|.
name|fns
argument_list|,
literal|32
argument_list|,
literal|"fns"
argument_list|)
expr_stmt|;
name|VARRAY_PUSH_TREE
argument_list|(
name|id
operator|.
name|fns
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* Or any functions that aren't finished yet.  */
name|prev_fn
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|current_function_decl
condition|)
block|{
name|VARRAY_PUSH_TREE
argument_list|(
name|id
operator|.
name|fns
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
name|prev_fn
operator|=
name|current_function_decl
expr_stmt|;
block|}
name|prev_fn
operator|=
operator|(
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|add_pending_fn_decls
call|)
argument_list|(
operator|&
name|id
operator|.
name|fns
argument_list|,
name|prev_fn
argument_list|)
operator|)
expr_stmt|;
comment|/* Create the stack of TARGET_EXPRs.  */
name|VARRAY_TREE_INIT
argument_list|(
name|id
operator|.
name|target_exprs
argument_list|,
literal|32
argument_list|,
literal|"target_exprs"
argument_list|)
expr_stmt|;
comment|/* Create the list of functions this call will inline.  */
name|VARRAY_TREE_INIT
argument_list|(
name|id
operator|.
name|inlined_fns
argument_list|,
literal|32
argument_list|,
literal|"inlined_fns"
argument_list|)
expr_stmt|;
comment|/* Keep track of the low-water mark, i.e., the point where the first      real inlining is represented in ID.FNS.  */
name|id
operator|.
name|first_inlined_fn
operator|=
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|id
operator|.
name|fns
argument_list|)
expr_stmt|;
comment|/* Replace all calls to inline functions with the bodies of those      functions.  */
name|id
operator|.
name|tree_pruner
operator|=
name|htab_create
argument_list|(
literal|37
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|expand_calls_inline
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fn
argument_list|)
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
name|htab_delete
argument_list|(
name|id
operator|.
name|tree_pruner
argument_list|)
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|id
operator|.
name|fns
argument_list|)
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|id
operator|.
name|target_exprs
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|tree
name|ifn
init|=
name|make_tree_vec
argument_list|(
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|id
operator|.
name|inlined_fns
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|TREE_VEC_ELT
argument_list|(
name|ifn
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|VARRAY_TREE
argument_list|(
name|id
operator|.
name|inlined_fns
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|id
operator|.
name|inlined_fns
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INLINED_FNS
argument_list|(
name|fn
argument_list|)
operator|=
name|ifn
expr_stmt|;
block|}
name|VARRAY_FREE
argument_list|(
name|id
operator|.
name|inlined_fns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FN is a function that has a complete body, and CLONE is a function    whose body is to be set to a copy of FN, mapping argument    declarations according to the ARG_MAP splay_tree.  */
end_comment

begin_function
name|void
name|clone_body
parameter_list|(
name|clone
parameter_list|,
name|fn
parameter_list|,
name|arg_map
parameter_list|)
name|tree
name|clone
decl_stmt|,
name|fn
decl_stmt|;
name|void
modifier|*
name|arg_map
decl_stmt|;
block|{
name|inline_data
name|id
decl_stmt|;
comment|/* Clone the body, as if we were making an inline call.  But, remap      the parameters in the callee to the parameters of caller.  If      there's an in-charge parameter, map it to an appropriate      constant.  */
name|memset
argument_list|(
operator|&
name|id
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|VARRAY_TREE_INIT
argument_list|(
name|id
operator|.
name|fns
argument_list|,
literal|2
argument_list|,
literal|"fns"
argument_list|)
expr_stmt|;
name|VARRAY_PUSH_TREE
argument_list|(
name|id
operator|.
name|fns
argument_list|,
name|clone
argument_list|)
expr_stmt|;
name|VARRAY_PUSH_TREE
argument_list|(
name|id
operator|.
name|fns
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|id
operator|.
name|decl_map
operator|=
operator|(
name|splay_tree
operator|)
name|arg_map
expr_stmt|;
comment|/* Cloning is treated slightly differently from inlining.  Set      CLONING_P so that it's clear which operation we're performing.  */
name|id
operator|.
name|cloning_p
operator|=
name|true
expr_stmt|;
comment|/* Actually copy the body.  */
name|TREE_CHAIN
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|clone
argument_list|)
argument_list|)
operator|=
name|copy_body
argument_list|(
operator|&
name|id
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
name|VARRAY_FREE
argument_list|(
name|id
operator|.
name|fns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Apply FUNC to all the sub-trees of TP in a pre-order traversal.    FUNC is called with the DATA and the address of each sub-tree.  If    FUNC returns a non-NULL value, the traversal is aborted, and the    value returned by FUNC is returned.  If HTAB is non-NULL it is used    to record the nodes visited, and to avoid visiting a node more than    once.  */
end_comment

begin_function
name|tree
name|walk_tree
parameter_list|(
name|tp
parameter_list|,
name|func
parameter_list|,
name|data
parameter_list|,
name|htab_
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|walk_tree_fn
name|func
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|void
modifier|*
name|htab_
decl_stmt|;
block|{
name|htab_t
name|htab
init|=
operator|(
name|htab_t
operator|)
name|htab_
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|walk_subtrees
decl_stmt|;
name|tree
name|result
decl_stmt|;
define|#
directive|define
name|WALK_SUBTREE
parameter_list|(
name|NODE
parameter_list|)
define|\
value|do							\     {							\       result = walk_tree (&(NODE), func, data, htab);	\       if (result)					\ 	return result;					\     }							\   while (0)
define|#
directive|define
name|WALK_SUBTREE_TAIL
parameter_list|(
name|NODE
parameter_list|)
define|\
value|do							\     {							\        tp =& (NODE);					\        goto tail_recurse;				\     }							\   while (0)
name|tail_recurse
label|:
comment|/* Skip empty subtrees.  */
if|if
condition|(
operator|!
operator|*
name|tp
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|htab
condition|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
comment|/* Don't walk the same tree twice, if the user has requested          that we avoid doing so.  */
if|if
condition|(
name|htab_find
argument_list|(
name|htab
argument_list|,
operator|*
name|tp
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If we haven't already seen this node, add it to the table.  */
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|htab
argument_list|,
operator|*
name|tp
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
operator|*
name|tp
expr_stmt|;
block|}
comment|/* Call the function.  */
name|walk_subtrees
operator|=
literal|1
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|tp
argument_list|,
operator|&
name|walk_subtrees
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* If we found something, return it.  */
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
comment|/* Even if we didn't, FUNC may have decided that there was nothing      interesting below this point in the tree.  */
if|if
condition|(
operator|!
name|walk_subtrees
condition|)
block|{
if|if
condition|(
name|statement_code_p
argument_list|(
name|code
argument_list|)
operator|||
name|code
operator|==
name|TREE_LIST
operator|||
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|tree_chain_matters_p
call|)
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
comment|/* But we still need to check our siblings.  */
name|WALK_SUBTREE_TAIL
argument_list|(
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL_TREE
return|;
block|}
comment|/* Handle common cases up front.  */
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
argument_list|)
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'r'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'s'
condition|)
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
comment|/* Set lineno here so we get the right instantiation context 	 if we call instantiate_decl from inlinable_function_p.  */
if|if
condition|(
name|statement_code_p
argument_list|(
name|code
argument_list|)
operator|&&
operator|!
name|STMT_LINENO_FOR_FN_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
name|lineno
operator|=
name|STMT_LINENO
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
comment|/* Walk over all the sub-trees of this operand.  */
name|len
operator|=
name|first_rtl_op
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* TARGET_EXPRs are peculiar: operands 1 and 3 can be the same. 	 But, we only want to walk once.  */
if|if
condition|(
name|code
operator|==
name|TARGET_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|3
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|1
argument_list|)
condition|)
operator|--
name|len
expr_stmt|;
comment|/* Go through the subtrees.  We need to do this in forward order so          that the scope of a FOR_EXPR is handled properly.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|WALK_SUBTREE
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For statements, we also walk the chain so that we cover the 	 entire statement tree.  */
if|if
condition|(
name|statement_code_p
argument_list|(
name|code
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|DECL_STMT
operator|&&
name|DECL_STMT_DECL
argument_list|(
operator|*
name|tp
argument_list|)
operator|&&
name|DECL_P
argument_list|(
name|DECL_STMT_DECL
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Walk the DECL_INITIAL and DECL_SIZE.  We don't want to walk 		 into declarations that are just mentioned, rather than 		 declared; they don't really belong to this part of the tree. 		 And, we can see cycles: the initializer for a declaration can 		 refer to the declaration itself.  */
name|WALK_SUBTREE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|DECL_STMT_DECL
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE
argument_list|(
name|DECL_SIZE
argument_list|(
name|DECL_STMT_DECL
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|DECL_STMT_DECL
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* This can be tail-recursion optimized if we write it this way.  */
name|WALK_SUBTREE_TAIL
argument_list|(
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We didn't find what we were looking for.  */
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'d'
condition|)
block|{
name|WALK_SUBTREE_TAIL
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|walk_subtrees
call|)
argument_list|(
name|tp
argument_list|,
operator|&
name|walk_subtrees
argument_list|,
name|func
argument_list|,
name|data
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|||
operator|!
name|walk_subtrees
condition|)
return|return
name|result
return|;
comment|/* Not one of the easy cases.  We must explicitly go through the      children.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ERROR_MARK
case|:
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|VECTOR_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BLOCK
case|:
case|case
name|RECORD_TYPE
case|:
comment|/* None of thse have subtrees other than those already walked          above.  */
break|break;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
name|WALK_SUBTREE_TAIL
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TREE_LIST
case|:
name|WALK_SUBTREE
argument_list|(
name|TREE_VALUE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE_TAIL
argument_list|(
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TREE_VEC
case|:
block|{
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
operator|*
name|tp
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
comment|/* Walk all elements but the first.  */
while|while
condition|(
operator|--
name|len
condition|)
name|WALK_SUBTREE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
operator|*
name|tp
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now walk the first one as a tail call.  */
name|WALK_SUBTREE_TAIL
argument_list|(
name|TREE_VEC_ELT
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
case|case
name|COMPLEX_CST
case|:
name|WALK_SUBTREE
argument_list|(
name|TREE_REALPART
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE_TAIL
argument_list|(
name|TREE_IMAGPART
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|CONSTRUCTOR
case|:
name|WALK_SUBTREE_TAIL
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|METHOD_TYPE
case|:
name|WALK_SUBTREE
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FUNCTION_TYPE
case|:
name|WALK_SUBTREE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|tree
name|arg
init|=
name|TYPE_ARG_TYPES
argument_list|(
operator|*
name|tp
argument_list|)
decl_stmt|;
comment|/* We never want to walk into default arguments.  */
for|for
control|(
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
name|WALK_SUBTREE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARRAY_TYPE
case|:
name|WALK_SUBTREE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE_TAIL
argument_list|(
name|TYPE_DOMAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|INTEGER_TYPE
case|:
name|WALK_SUBTREE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE_TAIL
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OFFSET_TYPE
case|:
name|WALK_SUBTREE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE_TAIL
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* We didn't find what we were looking for.  */
return|return
name|NULL_TREE
return|;
undef|#
directive|undef
name|WALK_SUBTREE
block|}
end_function

begin_comment
comment|/* Like walk_tree, but does not walk duplicate nodes more than     once.  */
end_comment

begin_function
name|tree
name|walk_tree_without_duplicates
parameter_list|(
name|tp
parameter_list|,
name|func
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|walk_tree_fn
name|func
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|;
name|htab_t
name|htab
decl_stmt|;
name|htab
operator|=
name|htab_create
argument_list|(
literal|37
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|walk_tree
argument_list|(
name|tp
argument_list|,
name|func
argument_list|,
name|data
argument_list|,
name|htab
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|htab
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Passed to walk_tree.  Copies the node pointed to, if appropriate.  */
end_comment

begin_function
name|tree
name|copy_tree_r
parameter_list|(
name|tp
parameter_list|,
name|walk_subtrees
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
decl_stmt|;
comment|/* We make copies of most nodes.  */
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
argument_list|)
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'r'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'s'
operator|||
name|code
operator|==
name|TREE_LIST
operator|||
name|code
operator|==
name|TREE_VEC
operator|||
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|tree_chain_matters_p
call|)
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
comment|/* Because the chain gets clobbered when we make a copy, we save it 	 here.  */
name|tree
name|chain
init|=
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
decl_stmt|;
comment|/* Copy the node.  */
operator|*
name|tp
operator|=
name|copy_node
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
comment|/* Now, restore the chain, if appropriate.  That will cause 	 walk_tree to walk into the chain as well.  */
if|if
condition|(
name|code
operator|==
name|PARM_DECL
operator|||
name|code
operator|==
name|TREE_LIST
operator|||
call|(
modifier|*
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|tree_chain_matters_p
call|)
argument_list|(
operator|*
name|tp
argument_list|)
operator|||
name|statement_code_p
argument_list|(
name|code
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
name|chain
expr_stmt|;
comment|/* For now, we don't update BLOCKs when we make copies.  So, we 	 have to nullify all scope-statements.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|SCOPE_STMT
condition|)
name|SCOPE_STMT_BLOCK
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'t'
condition|)
comment|/* There's no need to copy types, or anything beneath them.  */
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* The SAVE_EXPR pointed to by TP is being copied.  If ST contains    information indicating to what new SAVE_EXPR this one should be    mapped, use that one.  Otherwise, create a new node and enter it in    ST.  FN is the function into which the copy will be placed.  */
end_comment

begin_function
name|void
name|remap_save_expr
parameter_list|(
name|tp
parameter_list|,
name|st_
parameter_list|,
name|fn
parameter_list|,
name|walk_subtrees
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|void
modifier|*
name|st_
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
decl_stmt|;
block|{
name|splay_tree
name|st
init|=
operator|(
name|splay_tree
operator|)
name|st_
decl_stmt|;
name|splay_tree_node
name|n
decl_stmt|;
comment|/* See if we already encountered this SAVE_EXPR.  */
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|st
argument_list|,
operator|(
name|splay_tree_key
operator|)
operator|*
name|tp
argument_list|)
expr_stmt|;
comment|/* If we didn't already remap this SAVE_EXPR, do so now.  */
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|tree
name|t
init|=
name|copy_node
argument_list|(
operator|*
name|tp
argument_list|)
decl_stmt|;
comment|/* The SAVE_EXPR is now part of the function into which we 	 are inlining this body.  */
name|SAVE_EXPR_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|fn
expr_stmt|;
comment|/* And we haven't evaluated it yet.  */
name|SAVE_EXPR_RTL
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Remember this SAVE_EXPR.  */
name|n
operator|=
name|splay_tree_insert
argument_list|(
name|st
argument_list|,
operator|(
name|splay_tree_key
operator|)
operator|*
name|tp
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|t
argument_list|)
expr_stmt|;
comment|/* Make sure we don't remap an already-remapped SAVE_EXPR.  */
name|splay_tree_insert
argument_list|(
name|st
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|t
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We've already walked into this SAVE_EXPR, so we needn't do it        again.  */
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
comment|/* Replace this SAVE_EXPR with the copy.  */
operator|*
name|tp
operator|=
operator|(
name|tree
operator|)
name|n
operator|->
name|value
expr_stmt|;
block|}
end_function

end_unit

