begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Tree inlining.    Copyright 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.    Contributed by Alexandre Oliva<aoliva@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"tree-mudflap.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"pointer-set.h"
end_include

begin_include
include|#
directive|include
file|"ipa-prop.h"
end_include

begin_comment
comment|/* I'm not real happy about this, but we need to handle gimple and    non-gimple trees.  */
end_comment

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_comment
comment|/* Inlining, Cloning, Versioning, Parallelization     Inlining: a function body is duplicated, but the PARM_DECLs are    remapped into VAR_DECLs, and non-void RETURN_EXPRs become    MODIFY_EXPRs that store to a dedicated returned-value variable.    The duplicated eh_region info of the copy will later be appended    to the info for the caller; the eh_region info in copied throwing    statements and RESX_EXPRs is adjusted accordingly.     Cloning: (only in C++) We have one body for a con/de/structor, and    multiple function decls, each with a unique parameter list.    Duplicate the body, using the given splay tree; some parameters    will become constants (like 0 or 1).     Versioning: a function body is duplicated and the result is a new    function rather than into blocks of an existing function as with    inlining.  Some parameters will become constants.     Parallelization: a region of a function is duplicated resulting in    a new function.  Variables may be replaced with complex expressions    to enable shared variable semantics.     All of these will simultaneously lookup any callgraph edges.  If    we're going to inline the duplicated function body, and the given    function has some cloned callgraph nodes (one for each place this    function will be inlined) those callgraph edges will be duplicated.    If we're cloning the body, those callgraph edges will be    updated to point into the new body.  (Note that the original    callgraph node and edge list will not be altered.)     See the CALL_EXPR handling case in copy_body_r ().  */
end_comment

begin_comment
comment|/* 0 if we should not perform inlining.    1 if we should expand functions calls inline at the tree level.    2 if we should consider *all* functions to be inline    candidates.  */
end_comment

begin_decl_stmt
name|int
name|flag_inline_trees
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* To Do:     o In order to make inlining-on-trees work, we pessimized      function-local static constants.  In particular, they are now      always output, even when not addressed.  Fix this by treating      function-local static constants just like global static      constants; the back-end already knows not to output them if they      are not needed.     o Provide heuristics to clamp inlining of recursive template      calls?  */
end_comment

begin_comment
comment|/* Prototypes.  */
end_comment

begin_function_decl
specifier|static
name|tree
name|declare_return_variable
parameter_list|(
name|copy_body_data
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|copy_generic_body
parameter_list|(
name|copy_body_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|inlinable_function_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remap_block
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|copy_body_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|remap_decls
parameter_list|(
name|tree
parameter_list|,
name|copy_body_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_bind_expr
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|copy_body_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|mark_local_for_remap_r
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unsave_expr_1
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|unsave_r
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|declare_inline_vars
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remap_save_expr
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_lexical_block
parameter_list|(
name|tree
name|current_block
parameter_list|,
name|tree
name|new_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|copy_decl_to_var
parameter_list|(
name|tree
parameter_list|,
name|copy_body_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|copy_result_decl_to_var
parameter_list|(
name|tree
parameter_list|,
name|copy_body_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|copy_decl_no_change
parameter_list|(
name|tree
parameter_list|,
name|copy_body_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|copy_decl_maybe_to_var
parameter_list|(
name|tree
parameter_list|,
name|copy_body_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Insert a tree->tree mapping for ID.  Despite the name suggests    that the trees should be variables, it is used for more than that.  */
end_comment

begin_function
name|void
name|insert_decl_map
parameter_list|(
name|copy_body_data
modifier|*
name|id
parameter_list|,
name|tree
name|key
parameter_list|,
name|tree
name|value
parameter_list|)
block|{
name|splay_tree_insert
argument_list|(
name|id
operator|->
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|key
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|value
argument_list|)
expr_stmt|;
comment|/* Always insert an identity map as well.  If we see this same new      node again, we won't want to duplicate it a second time.  */
if|if
condition|(
name|key
operator|!=
name|value
condition|)
name|splay_tree_insert
argument_list|(
name|id
operator|->
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|value
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remap DECL during the copying of the BLOCK tree for the function.  */
end_comment

begin_function
name|tree
name|remap_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|copy_body_data
modifier|*
name|id
parameter_list|)
block|{
name|splay_tree_node
name|n
decl_stmt|;
name|tree
name|fn
decl_stmt|;
comment|/* We only remap local variables in the current function.  */
name|fn
operator|=
name|id
operator|->
name|src_fn
expr_stmt|;
comment|/* See if we have remapped this declaration.  */
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|id
operator|->
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|decl
argument_list|)
expr_stmt|;
comment|/* If we didn't already have an equivalent for this declaration,      create one now.  */
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/* Make a copy of the variable or label.  */
name|tree
name|t
init|=
name|id
operator|->
name|copy_decl
argument_list|(
name|decl
argument_list|,
name|id
argument_list|)
decl_stmt|;
comment|/* Remember it, so that if we encounter this local entity again 	 we can reuse this copy.  Do this early because remap_type may 	 need this decl for TYPE_STUB_DECL.  */
name|insert_decl_map
argument_list|(
name|id
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* Remap types, if necessary.  */
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|remap_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|DECL_ORIGINAL_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|remap_type
argument_list|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* Remap sizes as necessary.  */
name|walk_tree
argument_list|(
operator|&
name|DECL_SIZE
argument_list|(
name|t
argument_list|)
argument_list|,
name|copy_body_r
argument_list|,
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|DECL_SIZE_UNIT
argument_list|(
name|t
argument_list|)
argument_list|,
name|copy_body_r
argument_list|,
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If fields, do likewise for offset and qualifier.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|walk_tree
argument_list|(
operator|&
name|DECL_FIELD_OFFSET
argument_list|(
name|t
argument_list|)
argument_list|,
name|copy_body_r
argument_list|,
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
name|walk_tree
argument_list|(
operator|&
name|DECL_QUALIFIER
argument_list|(
name|t
argument_list|)
argument_list|,
name|copy_body_r
argument_list|,
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
return|return
name|unshare_expr
argument_list|(
operator|(
name|tree
operator|)
name|n
operator|->
name|value
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|remap_type_1
parameter_list|(
name|tree
name|type
parameter_list|,
name|copy_body_data
modifier|*
name|id
parameter_list|)
block|{
name|splay_tree_node
name|node
decl_stmt|;
name|tree
name|new
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|type
return|;
comment|/* See if we have remapped this type.  */
name|node
operator|=
name|splay_tree_lookup
argument_list|(
name|id
operator|->
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
return|return
operator|(
name|tree
operator|)
name|node
operator|->
name|value
return|;
comment|/* The type only needs remapping if it's variably modified.  */
if|if
condition|(
operator|!
name|variably_modified_type_p
argument_list|(
name|type
argument_list|,
name|id
operator|->
name|src_fn
argument_list|)
condition|)
block|{
name|insert_decl_map
argument_list|(
name|id
argument_list|,
name|type
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
comment|/* We do need a copy.  build and register it now.  If this is a pointer or      reference type, remap the designated type and make a new pointer or      reference type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|new
operator|=
name|build_pointer_type_for_mode
argument_list|(
name|remap_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|id
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|insert_decl_map
argument_list|(
name|id
argument_list|,
name|type
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|new
operator|=
name|build_reference_type_for_mode
argument_list|(
name|remap_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|id
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|insert_decl_map
argument_list|(
name|id
argument_list|,
name|type
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
else|else
name|new
operator|=
name|copy_node
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|insert_decl_map
argument_list|(
name|id
argument_list|,
name|type
argument_list|,
name|new
argument_list|)
expr_stmt|;
comment|/* This is a new type, not a copy of an old type.  Need to reassociate      variants.  We can handle everything except the main variant lazily.  */
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|t
condition|)
block|{
name|t
operator|=
name|remap_type
argument_list|(
name|t
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|new
argument_list|)
operator|=
name|t
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|new
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|TYPE_MAIN_VARIANT
argument_list|(
name|new
argument_list|)
operator|=
name|new
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|new
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
condition|)
name|TYPE_STUB_DECL
argument_list|(
name|new
argument_list|)
operator|=
name|remap_decl
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* Lazily create pointer and reference types.  */
name|TYPE_POINTER_TO
argument_list|(
name|new
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|new
argument_list|)
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|new
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
name|t
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|walk_tree
argument_list|(
operator|&
name|TYPE_MIN_VALUE
argument_list|(
name|new
argument_list|)
argument_list|,
name|copy_body_r
argument_list|,
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|walk_tree
argument_list|(
operator|&
name|TYPE_MAX_VALUE
argument_list|(
name|new
argument_list|)
argument_list|,
name|copy_body_r
argument_list|,
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|new
return|;
case|case
name|FUNCTION_TYPE
case|:
name|TREE_TYPE
argument_list|(
name|new
argument_list|)
operator|=
name|remap_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|new
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|TYPE_ARG_TYPES
argument_list|(
name|new
argument_list|)
argument_list|,
name|copy_body_r
argument_list|,
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|new
return|;
case|case
name|ARRAY_TYPE
case|:
name|TREE_TYPE
argument_list|(
name|new
argument_list|)
operator|=
name|remap_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|new
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|TYPE_DOMAIN
argument_list|(
name|new
argument_list|)
operator|=
name|remap_type
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|new
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
block|{
name|tree
name|f
decl_stmt|,
name|nf
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|f
operator|=
name|TYPE_FIELDS
argument_list|(
name|new
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
block|{
name|t
operator|=
name|remap_decl
argument_list|(
name|f
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|new
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|nf
expr_stmt|;
name|nf
operator|=
name|t
expr_stmt|;
block|}
name|TYPE_FIELDS
argument_list|(
name|new
argument_list|)
operator|=
name|nreverse
argument_list|(
name|nf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OFFSET_TYPE
case|:
default|default:
comment|/* Shouldn't have been thought variable sized.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|walk_tree
argument_list|(
operator|&
name|TYPE_SIZE
argument_list|(
name|new
argument_list|)
argument_list|,
name|copy_body_r
argument_list|,
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|TYPE_SIZE_UNIT
argument_list|(
name|new
argument_list|)
argument_list|,
name|copy_body_r
argument_list|,
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|tree
name|remap_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|copy_body_data
modifier|*
name|id
parameter_list|)
block|{
name|splay_tree_node
name|node
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|type
return|;
comment|/* See if we have remapped this type.  */
name|node
operator|=
name|splay_tree_lookup
argument_list|(
name|id
operator|->
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
return|return
operator|(
name|tree
operator|)
name|node
operator|->
name|value
return|;
comment|/* The type only needs remapping if it's variably modified.  */
if|if
condition|(
operator|!
name|variably_modified_type_p
argument_list|(
name|type
argument_list|,
name|id
operator|->
name|src_fn
argument_list|)
condition|)
block|{
name|insert_decl_map
argument_list|(
name|id
argument_list|,
name|type
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
return|return
name|remap_type_1
argument_list|(
name|type
argument_list|,
name|id
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|remap_decls
parameter_list|(
name|tree
name|decls
parameter_list|,
name|copy_body_data
modifier|*
name|id
parameter_list|)
block|{
name|tree
name|old_var
decl_stmt|;
name|tree
name|new_decls
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Remap its variables.  */
for|for
control|(
name|old_var
operator|=
name|decls
init|;
name|old_var
condition|;
name|old_var
operator|=
name|TREE_CHAIN
argument_list|(
name|old_var
argument_list|)
control|)
block|{
name|tree
name|new_var
decl_stmt|;
comment|/* We can not chain the local static declarations into the unexpanded_var_list          as we can't duplicate them or break one decl rule.  Go ahead and link          them into unexpanded_var_list.  */
if|if
condition|(
operator|!
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|auto_var_in_fn_p
argument_list|(
name|old_var
argument_list|,
name|id
operator|->
name|src_fn
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|old_var
argument_list|)
condition|)
block|{
name|cfun
operator|->
name|unexpanded_var_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|old_var
argument_list|,
name|cfun
operator|->
name|unexpanded_var_list
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Remap the variable.  */
name|new_var
operator|=
name|remap_decl
argument_list|(
name|old_var
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* If we didn't remap this variable, so we can't mess with its 	 TREE_CHAIN.  If we remapped this variable to the return slot, it's 	 already declared somewhere else, so don't declare it here.  */
if|if
condition|(
operator|!
name|new_var
operator|||
name|new_var
operator|==
name|id
operator|->
name|retvar
condition|)
empty_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|new_var
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|new_var
argument_list|)
operator|=
name|new_decls
expr_stmt|;
name|new_decls
operator|=
name|new_var
expr_stmt|;
block|}
block|}
return|return
name|nreverse
argument_list|(
name|new_decls
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copy the BLOCK to contain remapped versions of the variables    therein.  And hook the new block into the block-tree.  */
end_comment

begin_function
specifier|static
name|void
name|remap_block
parameter_list|(
name|tree
modifier|*
name|block
parameter_list|,
name|copy_body_data
modifier|*
name|id
parameter_list|)
block|{
name|tree
name|old_block
decl_stmt|;
name|tree
name|new_block
decl_stmt|;
name|tree
name|fn
decl_stmt|;
comment|/* Make the new block.  */
name|old_block
operator|=
operator|*
name|block
expr_stmt|;
name|new_block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|new_block
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|old_block
argument_list|)
expr_stmt|;
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|new_block
argument_list|)
operator|=
name|old_block
expr_stmt|;
name|BLOCK_SOURCE_LOCATION
argument_list|(
name|new_block
argument_list|)
operator|=
name|BLOCK_SOURCE_LOCATION
argument_list|(
name|old_block
argument_list|)
expr_stmt|;
operator|*
name|block
operator|=
name|new_block
expr_stmt|;
comment|/* Remap its variables.  */
name|BLOCK_VARS
argument_list|(
name|new_block
argument_list|)
operator|=
name|remap_decls
argument_list|(
name|BLOCK_VARS
argument_list|(
name|old_block
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|fn
operator|=
name|id
operator|->
name|dst_fn
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|transform_lang_insert_block
condition|)
name|lang_hooks
operator|.
name|decls
operator|.
name|insert_block
argument_list|(
name|new_block
argument_list|)
expr_stmt|;
comment|/* Remember the remapped block.  */
name|insert_decl_map
argument_list|(
name|id
argument_list|,
name|old_block
argument_list|,
name|new_block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the whole block tree and root it in id->block.  */
end_comment

begin_function
specifier|static
name|tree
name|remap_blocks
parameter_list|(
name|tree
name|block
parameter_list|,
name|copy_body_data
modifier|*
name|id
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|new
init|=
name|block
decl_stmt|;
if|if
condition|(
operator|!
name|block
condition|)
return|return
name|NULL
return|;
name|remap_block
argument_list|(
operator|&
name|new
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|new
operator|!=
name|block
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|BLOCK_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|add_lexical_block
argument_list|(
name|new
argument_list|,
name|remap_blocks
argument_list|(
name|t
argument_list|,
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_statement_list
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|)
block|{
name|tree_stmt_iterator
name|oi
decl_stmt|,
name|ni
decl_stmt|;
name|tree
name|new
decl_stmt|;
name|new
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|ni
operator|=
name|tsi_start
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|oi
operator|=
name|tsi_start
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|new
expr_stmt|;
for|for
control|(
init|;
operator|!
name|tsi_end_p
argument_list|(
name|oi
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|oi
argument_list|)
control|)
name|tsi_link_after
argument_list|(
operator|&
name|ni
argument_list|,
name|tsi_stmt
argument_list|(
name|oi
argument_list|)
argument_list|,
name|TSI_NEW_STMT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_bind_expr
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|copy_body_data
modifier|*
name|id
parameter_list|)
block|{
name|tree
name|block
init|=
name|BIND_EXPR_BLOCK
argument_list|(
operator|*
name|tp
argument_list|)
decl_stmt|;
comment|/* Copy (and replace) the statement.  */
name|copy_tree_r
argument_list|(
name|tp
argument_list|,
name|walk_subtrees
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
condition|)
block|{
name|remap_block
argument_list|(
operator|&
name|block
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|BIND_EXPR_BLOCK
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
name|block
expr_stmt|;
block|}
if|if
condition|(
name|BIND_EXPR_VARS
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
comment|/* This will remap a lot of the same decls again, but this should be        harmless.  */
name|BIND_EXPR_VARS
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
name|remap_decls
argument_list|(
name|BIND_EXPR_VARS
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from copy_body_id via walk_tree.  DATA is really an    `copy_body_data *'.  */
end_comment

begin_function
name|tree
name|copy_body_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|copy_body_data
modifier|*
name|id
init|=
operator|(
name|copy_body_data
operator|*
operator|)
name|data
decl_stmt|;
name|tree
name|fn
init|=
name|id
operator|->
name|src_fn
decl_stmt|;
name|tree
name|new_block
decl_stmt|;
comment|/* Begin by recognizing trees that we'll completely rewrite for the      inlining context.  Our output for these trees is completely      different from out input (e.g. RETURN_EXPR is deleted, and morphs      into an edge).  Further down, we'll handle trees that get      duplicated and/or tweaked.  */
comment|/* When requested, RETURN_EXPRs should be transformed to just the      contained MODIFY_EXPR.  The branch semantics of the return will      be handled elsewhere by manipulating the CFG rather than a statement.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|RETURN_EXPR
operator|&&
name|id
operator|->
name|transform_return_to_modify
condition|)
block|{
name|tree
name|assignment
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If we're returning something, just turn that into an 	 assignment into the equivalent of the original RESULT_DECL. 	 If the "assignment" is just the result decl, the result 	 decl has already been set (e.g. a recent "foo (&result_decl, 	 ...)"); just toss the entire RETURN_EXPR.  */
if|if
condition|(
name|assignment
operator|&&
name|TREE_CODE
argument_list|(
name|assignment
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
comment|/* Replace the RETURN_EXPR with (a copy of) the 	     MODIFY_EXPR hanging underneath.  */
operator|*
name|tp
operator|=
name|copy_node
argument_list|(
name|assignment
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Else the RETURN_EXPR returns no value.  */
block|{
operator|*
name|tp
operator|=
name|NULL
expr_stmt|;
return|return
call|(
name|tree
call|)
argument_list|(
name|void
operator|*
argument_list|)
literal|1
return|;
block|}
block|}
comment|/* Local variables and labels need to be replaced by equivalent      variables.  We don't want to copy static variables; there's only      one of those, no matter how many times we inline the containing      function.  Similarly for globals from an outer function.  */
elseif|else
if|if
condition|(
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|auto_var_in_fn_p
argument_list|(
operator|*
name|tp
argument_list|,
name|fn
argument_list|)
condition|)
block|{
name|tree
name|new_decl
decl_stmt|;
comment|/* Remap the declaration.  */
name|new_decl
operator|=
name|remap_decl
argument_list|(
operator|*
name|tp
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
comment|/* Replace this variable with the copy.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|new_decl
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|STATEMENT_LIST
condition|)
name|copy_statement_list
argument_list|(
name|tp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|remap_save_expr
argument_list|(
name|tp
argument_list|,
name|id
operator|->
name|decl_map
argument_list|,
name|walk_subtrees
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|LABEL_DECL
operator|&&
operator|(
operator|!
name|DECL_CONTEXT
argument_list|(
operator|*
name|tp
argument_list|)
operator|||
name|decl_function_context
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|id
operator|->
name|src_fn
operator|)
condition|)
comment|/* These may need to be remapped for EH handling.  */
operator|*
name|tp
operator|=
name|remap_decl
argument_list|(
operator|*
name|tp
argument_list|,
name|id
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|BIND_EXPR
condition|)
name|copy_bind_expr
argument_list|(
name|tp
argument_list|,
name|walk_subtrees
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* Types may need remapping as well.  */
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
operator|*
name|tp
operator|=
name|remap_type
argument_list|(
operator|*
name|tp
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* If this is a constant, we have to copy the node iff the type will be      remapped.  copy_tree_r will not copy a constant.  */
elseif|else
if|if
condition|(
name|CONSTANT_CLASS_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
name|tree
name|new_type
init|=
name|remap_type
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|,
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_type
operator|==
name|TREE_TYPE
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|INTEGER_CST
condition|)
operator|*
name|tp
operator|=
name|build_int_cst_wide
argument_list|(
name|new_type
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|tp
operator|=
name|copy_node
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
name|new_type
expr_stmt|;
block|}
block|}
comment|/* Otherwise, just copy the node.  Note that copy_tree_r already      knows not to copy VAR_DECLs, etc., so this is safe.  */
else|else
block|{
comment|/* Here we handle trees that are not completely rewritten. 	 First we detect some inlining-induced bogosities for 	 discarding.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|auto_var_in_fn_p
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fn
argument_list|)
operator|)
condition|)
block|{
comment|/* Some assignments VAR = VAR; don't generate any rtl code 	     and thus don't count as variable modification.  Avoid 	     keeping bogosities like 0 = 0.  */
name|tree
name|decl
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|value
decl_stmt|;
name|splay_tree_node
name|n
decl_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|id
operator|->
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|value
operator|=
operator|(
name|tree
operator|)
name|n
operator|->
name|value
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
operator|||
name|TREE_READONLY_DECL_P
argument_list|(
name|value
argument_list|)
condition|)
block|{
operator|*
name|tp
operator|=
name|build_empty_stmt
argument_list|()
expr_stmt|;
return|return
name|copy_body_r
argument_list|(
name|tp
argument_list|,
name|walk_subtrees
argument_list|,
name|data
argument_list|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* Get rid of *& from inline substitutions that can happen when a 	     pointer argument is an ADDR_EXPR.  */
name|tree
name|decl
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|splay_tree_node
name|n
decl_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|id
operator|->
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|tree
name|new
decl_stmt|;
name|tree
name|old
decl_stmt|;
comment|/* If we happen to get an ADDR_EXPR in n->value, strip 	         it manually here as we'll eventually get ADDR_EXPRs 		 which lie about their types pointed to.  In this case 		 build_fold_indirect_ref wouldn't strip the INDIRECT_REF, 		 but we absolutely rely on that.  As fold_indirect_ref 	         does other useful transformations, try that first, though.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|(
name|tree
operator|)
name|n
operator|->
name|value
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|=
name|unshare_expr
argument_list|(
operator|(
name|tree
operator|)
name|n
operator|->
name|value
argument_list|)
expr_stmt|;
name|old
operator|=
operator|*
name|tp
expr_stmt|;
operator|*
name|tp
operator|=
name|fold_indirect_ref_1
argument_list|(
name|type
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|tp
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
operator|*
name|tp
operator|=
name|TREE_OPERAND
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|tp
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* Here is the "usual case".  Copy this tree node, and then 	 tweak some special cases.  */
name|copy_tree_r
argument_list|(
name|tp
argument_list|,
name|walk_subtrees
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If EXPR has block defined, map it to newly constructed block.          When inlining we want EXPRs without block appear in the block 	 of function call.  */
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|new_block
operator|=
name|id
operator|->
name|block
expr_stmt|;
if|if
condition|(
name|TREE_BLOCK
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
name|splay_tree_node
name|n
decl_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|id
operator|->
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|TREE_BLOCK
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|new_block
operator|=
operator|(
name|tree
operator|)
name|n
operator|->
name|value
expr_stmt|;
block|}
name|TREE_BLOCK
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
name|new_block
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|RESX_EXPR
operator|&&
name|id
operator|->
name|eh_region_offset
condition|)
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|id
operator|->
name|eh_region_offset
operator|+
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|!=
name|OMP_CLAUSE
condition|)
name|TREE_TYPE
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
name|remap_type
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* The copied TARGET_EXPR has never been expanded, even if the 	 original node was expanded already.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|TARGET_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|3
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Variable substitution need not be simple.  In particular, the 	 INDIRECT_REF substitution above.  Make sure that TREE_CONSTANT 	 and friends are up-to-date.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|copy_body_r
argument_list|,
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Handle the case where we substituted an INDIRECT_REF 	     into the operand of the ADDR_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
operator|*
name|tp
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|recompute_tree_invariant_for_addr_expr
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Keep iterating.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Copy basic block, scale profile accordingly.  Edges will be taken care of    later  */
end_comment

begin_function
specifier|static
name|basic_block
name|copy_bb
parameter_list|(
name|copy_body_data
modifier|*
name|id
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|int
name|frequency_scale
parameter_list|,
name|int
name|count_scale
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|,
name|copy_bsi
decl_stmt|;
name|basic_block
name|copy_basic_block
decl_stmt|;
comment|/* create_basic_block() will append every new block to      basic_block_info automatically.  */
name|copy_basic_block
operator|=
name|create_basic_block
argument_list|(
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|basic_block
operator|)
name|bb
operator|->
name|prev_bb
operator|->
name|aux
argument_list|)
expr_stmt|;
name|copy_basic_block
operator|->
name|count
operator|=
name|bb
operator|->
name|count
operator|*
name|count_scale
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
name|copy_basic_block
operator|->
name|frequency
operator|=
operator|(
name|bb
operator|->
name|frequency
operator|*
name|frequency_scale
operator|/
name|REG_BR_PROB_BASE
operator|)
expr_stmt|;
name|copy_bsi
operator|=
name|bsi_start
argument_list|(
name|copy_basic_block
argument_list|)
expr_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
name|tree
name|orig_stmt
init|=
name|stmt
decl_stmt|;
name|walk_tree
argument_list|(
operator|&
name|stmt
argument_list|,
name|copy_body_r
argument_list|,
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* RETURN_EXPR might be removed,          this is signalled by making stmt pointer NULL.  */
if|if
condition|(
name|stmt
condition|)
block|{
name|tree
name|call
decl_stmt|,
name|decl
decl_stmt|;
comment|/* With return slot optimization we can end up with 	     non-gimple (foo *)&this->m, fix that here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
operator|!
name|is_gimple_val
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|gimplify_stmt
argument_list|(
operator|&
name|stmt
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|copy_bsi
argument_list|,
name|stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|call
operator|=
name|get_call_expr_in
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* We're duplicating a CALL_EXPR.  Find any corresponding 	     callgraph edges and update or duplicate them.  */
if|if
condition|(
name|call
operator|&&
operator|(
name|decl
operator|=
name|get_callee_fndecl
argument_list|(
name|call
argument_list|)
operator|)
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|edge
decl_stmt|;
switch|switch
condition|(
name|id
operator|->
name|transform_call_graph_edges
condition|)
block|{
case|case
name|CB_CGE_DUPLICATE
case|:
name|edge
operator|=
name|cgraph_edge
argument_list|(
name|id
operator|->
name|src_node
argument_list|,
name|orig_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|edge
condition|)
name|cgraph_clone_edge
argument_list|(
name|edge
argument_list|,
name|id
operator|->
name|dst_node
argument_list|,
name|stmt
argument_list|,
name|REG_BR_PROB_BASE
argument_list|,
literal|1
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|CB_CGE_MOVE_CLONES
case|:
for|for
control|(
name|node
operator|=
name|id
operator|->
name|dst_node
operator|->
name|next_clone
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next_clone
control|)
block|{
name|edge
operator|=
name|cgraph_edge
argument_list|(
name|node
argument_list|,
name|orig_stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|edge
argument_list|)
expr_stmt|;
name|cgraph_set_call_stmt
argument_list|(
name|edge
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
comment|/* FALLTHRU */
case|case
name|CB_CGE_MOVE
case|:
name|edge
operator|=
name|cgraph_edge
argument_list|(
name|id
operator|->
name|dst_node
argument_list|,
name|orig_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|edge
condition|)
name|cgraph_set_call_stmt
argument_list|(
name|edge
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If you think we can abort here, you are wrong. 	     There is no region 0 in tree land.  */
name|gcc_assert
argument_list|(
name|lookup_stmt_eh_region_fn
argument_list|(
name|id
operator|->
name|src_cfun
argument_list|,
name|orig_stmt
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_could_throw_p
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|int
name|region
init|=
name|lookup_stmt_eh_region_fn
argument_list|(
name|id
operator|->
name|src_cfun
argument_list|,
name|orig_stmt
argument_list|)
decl_stmt|;
comment|/* Add an entry for the copied tree in the EH hashtable. 		 When cloning or versioning, use the hashtable in 		 cfun, and just copy the EH number.  When inlining, use the 		 hashtable in the caller, and adjust the region number.  */
if|if
condition|(
name|region
operator|>
literal|0
condition|)
name|add_stmt_to_eh_region
argument_list|(
name|stmt
argument_list|,
name|region
operator|+
name|id
operator|->
name|eh_region_offset
argument_list|)
expr_stmt|;
comment|/* If this tree doesn't have a region associated with it, 		 and there is a "current region," 		 then associate this tree with the current region 		 and add edges associated with this region.  */
if|if
condition|(
operator|(
name|lookup_stmt_eh_region_fn
argument_list|(
name|id
operator|->
name|src_cfun
argument_list|,
name|orig_stmt
argument_list|)
operator|<=
literal|0
operator|&&
name|id
operator|->
name|eh_region
operator|>
literal|0
operator|)
operator|&&
name|tree_could_throw_p
argument_list|(
name|stmt
argument_list|)
condition|)
name|add_stmt_to_eh_region
argument_list|(
name|stmt
argument_list|,
name|id
operator|->
name|eh_region
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|copy_basic_block
return|;
block|}
end_function

begin_comment
comment|/* Copy edges from BB into its copy constructed earlier, scale profile    accordingly.  Edges will be taken care of later.  Assume aux    pointers to point to the copies of each BB.  */
end_comment

begin_function
specifier|static
name|void
name|copy_edges_for_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
name|count_scale
parameter_list|)
block|{
name|basic_block
name|new_bb
init|=
operator|(
name|basic_block
operator|)
name|bb
operator|->
name|aux
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|old_edge
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* Use the indices from the original blocks to create edges for the      new ones.  */
name|FOR_EACH_EDGE
argument_list|(
argument|old_edge
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|!
operator|(
name|old_edge
operator|->
name|flags
operator|&
name|EDGE_EH
operator|)
condition|)
block|{
name|edge
name|new
decl_stmt|;
name|flags
operator|=
name|old_edge
operator|->
name|flags
expr_stmt|;
comment|/* Return edges do get a FALLTHRU flag when the get inlined.  */
if|if
condition|(
name|old_edge
operator|->
name|dest
operator|->
name|index
operator|==
name|EXIT_BLOCK
operator|&&
operator|!
name|old_edge
operator|->
name|flags
operator|&&
name|old_edge
operator|->
name|dest
operator|->
name|aux
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
name|new
operator|=
name|make_edge
argument_list|(
name|new_bb
argument_list|,
operator|(
name|basic_block
operator|)
name|old_edge
operator|->
name|dest
operator|->
name|aux
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|new
operator|->
name|count
operator|=
name|old_edge
operator|->
name|count
operator|*
name|count_scale
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
name|new
operator|->
name|probability
operator|=
name|old_edge
operator|->
name|probability
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|->
name|index
operator|==
name|ENTRY_BLOCK
operator|||
name|bb
operator|->
name|index
operator|==
name|EXIT_BLOCK
condition|)
return|return;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|new_bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
control|)
block|{
name|tree
name|copy_stmt
decl_stmt|;
name|copy_stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|copy_stmt
argument_list|)
expr_stmt|;
comment|/* Do this before the possible split_block.  */
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
comment|/* If this tree could throw an exception, there are two          cases where we need to add abnormal edge(s): the          tree wasn't in a region and there is a "current          region" in the caller; or the original tree had          EH edges.  In both cases split the block after the tree,          and add abnormal edge(s) as needed; we need both          those from the callee and the caller.          We check whether the copy can throw, because the const          propagation can change an INDIRECT_REF which throws          into a COMPONENT_REF which doesn't.  If the copy          can throw, the original could also throw.  */
if|if
condition|(
name|tree_can_throw_internal
argument_list|(
name|copy_stmt
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
comment|/* Note that bb's predecessor edges aren't necessarily 	       right at this point; split_block doesn't care.  */
block|{
name|edge
name|e
init|=
name|split_block
argument_list|(
name|new_bb
argument_list|,
name|copy_stmt
argument_list|)
decl_stmt|;
name|new_bb
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|bsi
operator|=
name|bsi_start
argument_list|(
name|new_bb
argument_list|)
expr_stmt|;
block|}
name|make_eh_edges
argument_list|(
name|copy_stmt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Wrapper for remap_decl so it can be used as a callback.  */
end_comment

begin_function
specifier|static
name|tree
name|remap_decl_1
parameter_list|(
name|tree
name|decl
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
name|remap_decl
argument_list|(
name|decl
argument_list|,
operator|(
name|copy_body_data
operator|*
operator|)
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make a copy of the body of FN so that it can be inserted inline in    another function.  Walks FN via CFG, returns new fndecl.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_cfg_body
parameter_list|(
name|copy_body_data
modifier|*
name|id
parameter_list|,
name|gcov_type
name|count
parameter_list|,
name|int
name|frequency
parameter_list|,
name|basic_block
name|entry_block_map
parameter_list|,
name|basic_block
name|exit_block_map
parameter_list|)
block|{
name|tree
name|callee_fndecl
init|=
name|id
operator|->
name|src_fn
decl_stmt|;
comment|/* Original cfun for the callee, doesn't change.  */
name|struct
name|function
modifier|*
name|src_cfun
init|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|callee_fndecl
argument_list|)
decl_stmt|;
comment|/* Copy, built by this function.  */
name|struct
name|function
modifier|*
name|new_cfun
decl_stmt|;
comment|/* Place to copy from; when a copy of the function was saved off earlier,      use that instead of the main copy.  */
name|struct
name|function
modifier|*
name|cfun_to_copy
init|=
operator|(
expr|struct
name|function
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|tree
name|new_fndecl
init|=
name|NULL
decl_stmt|;
name|int
name|count_scale
decl_stmt|,
name|frequency_scale
decl_stmt|;
if|if
condition|(
name|ENTRY_BLOCK_PTR_FOR_FUNCTION
argument_list|(
name|src_cfun
argument_list|)
operator|->
name|count
condition|)
name|count_scale
operator|=
operator|(
name|REG_BR_PROB_BASE
operator|*
name|count
operator|/
name|ENTRY_BLOCK_PTR_FOR_FUNCTION
argument_list|(
name|src_cfun
argument_list|)
operator|->
name|count
operator|)
expr_stmt|;
else|else
name|count_scale
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ENTRY_BLOCK_PTR_FOR_FUNCTION
argument_list|(
name|src_cfun
argument_list|)
operator|->
name|frequency
condition|)
name|frequency_scale
operator|=
operator|(
name|REG_BR_PROB_BASE
operator|*
name|frequency
operator|/
name|ENTRY_BLOCK_PTR_FOR_FUNCTION
argument_list|(
name|src_cfun
argument_list|)
operator|->
name|frequency
operator|)
expr_stmt|;
else|else
name|frequency_scale
operator|=
name|count_scale
expr_stmt|;
comment|/* Register specific tree functions.  */
name|tree_register_cfg_hooks
argument_list|()
expr_stmt|;
comment|/* Must have a CFG here at this point.  */
name|gcc_assert
argument_list|(
name|ENTRY_BLOCK_PTR_FOR_FUNCTION
argument_list|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|callee_fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|cfun_to_copy
operator|=
operator|*
name|DECL_STRUCT_FUNCTION
argument_list|(
name|callee_fndecl
argument_list|)
expr_stmt|;
name|id
operator|->
name|src_cfun
operator|=
name|cfun_to_copy
expr_stmt|;
comment|/* If requested, create new basic_block_info and label_to_block_maps.      Otherwise, insert our new blocks and labels into the existing cfg.  */
if|if
condition|(
name|id
operator|->
name|transform_new_cfg
condition|)
block|{
name|new_cfun
operator|=
operator|(
expr|struct
name|function
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|function
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|new_cfun
operator|=
operator|*
name|DECL_STRUCT_FUNCTION
argument_list|(
name|callee_fndecl
argument_list|)
expr_stmt|;
name|new_cfun
operator|->
name|cfg
operator|=
name|NULL
expr_stmt|;
name|new_cfun
operator|->
name|decl
operator|=
name|new_fndecl
operator|=
name|copy_node
argument_list|(
name|callee_fndecl
argument_list|)
expr_stmt|;
name|new_cfun
operator|->
name|ib_boundaries_block
operator|=
name|NULL
expr_stmt|;
name|DECL_STRUCT_FUNCTION
argument_list|(
name|new_fndecl
argument_list|)
operator|=
name|new_cfun
expr_stmt|;
name|push_cfun
argument_list|(
name|new_cfun
argument_list|)
expr_stmt|;
name|init_empty_tree_cfg
argument_list|()
expr_stmt|;
name|ENTRY_BLOCK_PTR
operator|->
name|count
operator|=
operator|(
name|ENTRY_BLOCK_PTR_FOR_FUNCTION
argument_list|(
name|src_cfun
argument_list|)
operator|->
name|count
operator|*
name|count_scale
operator|/
name|REG_BR_PROB_BASE
operator|)
expr_stmt|;
name|ENTRY_BLOCK_PTR
operator|->
name|frequency
operator|=
operator|(
name|ENTRY_BLOCK_PTR_FOR_FUNCTION
argument_list|(
name|src_cfun
argument_list|)
operator|->
name|frequency
operator|*
name|frequency_scale
operator|/
name|REG_BR_PROB_BASE
operator|)
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|count
operator|=
operator|(
name|EXIT_BLOCK_PTR_FOR_FUNCTION
argument_list|(
name|src_cfun
argument_list|)
operator|->
name|count
operator|*
name|count_scale
operator|/
name|REG_BR_PROB_BASE
operator|)
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|frequency
operator|=
operator|(
name|EXIT_BLOCK_PTR_FOR_FUNCTION
argument_list|(
name|src_cfun
argument_list|)
operator|->
name|frequency
operator|*
name|frequency_scale
operator|/
name|REG_BR_PROB_BASE
operator|)
expr_stmt|;
name|entry_block_map
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
name|exit_block_map
operator|=
name|EXIT_BLOCK_PTR
expr_stmt|;
block|}
name|ENTRY_BLOCK_PTR_FOR_FUNCTION
argument_list|(
name|cfun_to_copy
argument_list|)
operator|->
name|aux
operator|=
name|entry_block_map
expr_stmt|;
name|EXIT_BLOCK_PTR_FOR_FUNCTION
argument_list|(
name|cfun_to_copy
argument_list|)
operator|->
name|aux
operator|=
name|exit_block_map
expr_stmt|;
comment|/* Duplicate any exception-handling regions.  */
if|if
condition|(
name|cfun
operator|->
name|eh
condition|)
block|{
if|if
condition|(
name|id
operator|->
name|transform_new_cfg
condition|)
name|init_eh_for_function
argument_list|()
expr_stmt|;
name|id
operator|->
name|eh_region_offset
operator|=
name|duplicate_eh_regions
argument_list|(
name|cfun_to_copy
argument_list|,
name|remap_decl_1
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
name|id
operator|->
name|eh_region
argument_list|)
expr_stmt|;
block|}
comment|/* Use aux pointers to map the original blocks to copy.  */
name|FOR_EACH_BB_FN
argument_list|(
argument|bb
argument_list|,
argument|cfun_to_copy
argument_list|)
name|bb
operator|->
name|aux
operator|=
name|copy_bb
argument_list|(
name|id
argument_list|,
name|bb
argument_list|,
name|frequency_scale
argument_list|,
name|count_scale
argument_list|)
expr_stmt|;
comment|/* Now that we've duplicated the blocks, duplicate their edges.  */
name|FOR_ALL_BB_FN
argument_list|(
argument|bb
argument_list|,
argument|cfun_to_copy
argument_list|)
name|copy_edges_for_bb
argument_list|(
name|bb
argument_list|,
name|count_scale
argument_list|)
expr_stmt|;
name|FOR_ALL_BB_FN
argument_list|(
argument|bb
argument_list|,
argument|cfun_to_copy
argument_list|)
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|transform_new_cfg
condition|)
name|pop_cfun
argument_list|()
expr_stmt|;
return|return
name|new_fndecl
return|;
block|}
end_function

begin_comment
comment|/* Make a copy of the body of FN so that it can be inserted inline in    another function.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_generic_body
parameter_list|(
name|copy_body_data
modifier|*
name|id
parameter_list|)
block|{
name|tree
name|body
decl_stmt|;
name|tree
name|fndecl
init|=
name|id
operator|->
name|src_fn
decl_stmt|;
name|body
operator|=
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|body
argument_list|,
name|copy_body_r
argument_list|,
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|body
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|copy_body
parameter_list|(
name|copy_body_data
modifier|*
name|id
parameter_list|,
name|gcov_type
name|count
parameter_list|,
name|int
name|frequency
parameter_list|,
name|basic_block
name|entry_block_map
parameter_list|,
name|basic_block
name|exit_block_map
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|id
operator|->
name|src_fn
decl_stmt|;
name|tree
name|body
decl_stmt|;
comment|/* If this body has a CFG, walk CFG and copy.  */
name|gcc_assert
argument_list|(
name|ENTRY_BLOCK_PTR_FOR_FUNCTION
argument_list|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|body
operator|=
name|copy_cfg_body
argument_list|(
name|id
argument_list|,
name|count
argument_list|,
name|frequency
argument_list|,
name|entry_block_map
argument_list|,
name|exit_block_map
argument_list|)
expr_stmt|;
return|return
name|body
return|;
block|}
end_function

begin_comment
comment|/* Return true if VALUE is an ADDR_EXPR of an automatic variable    defined in function FN, or of a data member thereof.  */
end_comment

begin_function
specifier|static
name|bool
name|self_inlining_addr_expr
parameter_list|(
name|tree
name|value
parameter_list|,
name|tree
name|fn
parameter_list|)
block|{
name|tree
name|var
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
return|return
name|false
return|;
name|var
operator|=
name|get_base_address
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|var
operator|&&
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|auto_var_in_fn_p
argument_list|(
name|var
argument_list|,
name|fn
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_one_parameter
parameter_list|(
name|copy_body_data
modifier|*
name|id
parameter_list|,
name|tree
name|p
parameter_list|,
name|tree
name|value
parameter_list|,
name|tree
name|fn
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|tree
modifier|*
name|vars
parameter_list|)
block|{
name|tree
name|init_stmt
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|tree
name|var_sub
decl_stmt|;
comment|/* If the parameter is never assigned to, we may not need to      create a new variable here at all.  Instead, we may be able      to just use the argument value.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|p
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|p
argument_list|)
operator|&&
name|value
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|value
argument_list|)
condition|)
block|{
comment|/* We may produce non-gimple trees by adding NOPs or introduce 	 invalid sharing when operand is not really constant. 	 It is not big deal to prohibit constant propagation here as 	 we will constant propagate in DOM1 pass anyway.  */
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|value
argument_list|)
operator|&&
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
argument_list|)
comment|/* We have to be very careful about ADDR_EXPR.  Make sure 	     the base variable isn't a local variable of the inlined 	     function, e.g., when doing recursive inlining, direct or 	     mutually-recursive or whatever, which is why we don't 	     just test whether fn == current_function_decl.  */
operator|&&
operator|!
name|self_inlining_addr_expr
argument_list|(
name|value
argument_list|,
name|fn
argument_list|)
condition|)
block|{
name|insert_decl_map
argument_list|(
name|id
argument_list|,
name|p
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Make an equivalent VAR_DECL.  Note that we must NOT remap the type      here since the type of this decl must be visible to the calling      function.  */
name|var
operator|=
name|copy_decl_to_var
argument_list|(
name|p
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* See if the frontend wants to pass this by invisible reference.  If      so, our new VAR_DECL will have REFERENCE_TYPE, and we need to      replace uses of the PARM_DECL with dereferences.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|insert_decl_map
argument_list|(
name|id
argument_list|,
name|var
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|var_sub
operator|=
name|build_fold_indirect_ref
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
else|else
name|var_sub
operator|=
name|var
expr_stmt|;
comment|/* Register the VAR_DECL as the equivalent for the PARM_DECL;      that way, when the PARM_DECL is encountered, it will be      automatically replaced by the VAR_DECL.  */
name|insert_decl_map
argument_list|(
name|id
argument_list|,
name|p
argument_list|,
name|var_sub
argument_list|)
expr_stmt|;
comment|/* Declare this new variable.  */
name|TREE_CHAIN
argument_list|(
name|var
argument_list|)
operator|=
operator|*
name|vars
expr_stmt|;
operator|*
name|vars
operator|=
name|var
expr_stmt|;
comment|/* Make gimplifier happy about this variable.  */
name|DECL_SEEN_IN_BIND_EXPR_P
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Even if P was TREE_READONLY, the new VAR should not be.      In the original code, we would have constructed a      temporary, and then the function body would have never      changed the value of P.  However, now, we will be      constructing VAR directly.  The constructor body may      change its value multiple times as it is being      constructed.  Therefore, it must not be TREE_READONLY;      the back-end assumes that TREE_READONLY variable is      assigned to only once.  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|var
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Initialize this VAR_DECL from the equivalent argument.  Convert      the argument to the proper type in case it was promoted.  */
if|if
condition|(
name|value
condition|)
block|{
name|tree
name|rhs
init|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|block_stmt_iterator
name|bsi
init|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
condition|)
return|return;
name|STRIP_USELESS_TYPE_CONVERSION
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* We want to use MODIFY_EXPR, not INIT_EXPR here so that we 	 keep our trees in gimple form.  */
name|init_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|,
name|var
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
comment|/* If we did not create a gimple value and we did not create a gimple 	 cast of a gimple value, then we will need to gimplify INIT_STMTS 	 at the end.  Note that is_gimple_cast only checks the outer 	 tree code, not its operand.  Thus the explicit check that its 	 operand is a gimple value.  */
if|if
condition|(
operator|!
name|is_gimple_val
argument_list|(
name|rhs
argument_list|)
operator|&&
operator|(
operator|!
name|is_gimple_cast
argument_list|(
name|rhs
argument_list|)
operator|||
operator|!
name|is_gimple_val
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|gimplify_stmt
argument_list|(
operator|&
name|init_stmt
argument_list|)
expr_stmt|;
comment|/* If VAR represents a zero-sized variable, it's possible that the 	 assignment statment may result in no gimple statements.  */
if|if
condition|(
name|init_stmt
condition|)
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|init_stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate code to initialize the parameters of the function at the    top of the stack in ID from the ARGS (presented as a TREE_LIST).  */
end_comment

begin_function
specifier|static
name|void
name|initialize_inlined_parameters
parameter_list|(
name|copy_body_data
modifier|*
name|id
parameter_list|,
name|tree
name|args
parameter_list|,
name|tree
name|static_chain
parameter_list|,
name|tree
name|fn
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|tree
name|parms
decl_stmt|;
name|tree
name|a
decl_stmt|;
name|tree
name|p
decl_stmt|;
name|tree
name|vars
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|argnum
init|=
literal|0
decl_stmt|;
comment|/* Figure out what the parameters are.  */
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Loop through the parameter declarations, replacing each with an      equivalent VAR_DECL, appropriately initialized.  */
for|for
control|(
name|p
operator|=
name|parms
operator|,
name|a
operator|=
name|args
init|;
name|p
condition|;
name|a
operator|=
name|a
condition|?
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
else|:
name|a
operator|,
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|value
decl_stmt|;
operator|++
name|argnum
expr_stmt|;
comment|/* Find the initializer.  */
name|value
operator|=
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|convert_parm_for_inlining
argument_list|(
name|p
argument_list|,
name|a
condition|?
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
else|:
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|argnum
argument_list|)
expr_stmt|;
name|setup_one_parameter
argument_list|(
name|id
argument_list|,
name|p
argument_list|,
name|value
argument_list|,
name|fn
argument_list|,
name|bb
argument_list|,
operator|&
name|vars
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the static chain.  */
name|p
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|fn
argument_list|)
operator|->
name|static_chain_decl
expr_stmt|;
name|gcc_assert
argument_list|(
name|fn
operator|!=
name|current_function_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
comment|/* No static chain?  Seems like a bug in tree-nested.c.  */
name|gcc_assert
argument_list|(
name|static_chain
argument_list|)
expr_stmt|;
name|setup_one_parameter
argument_list|(
name|id
argument_list|,
name|p
argument_list|,
name|static_chain
argument_list|,
name|fn
argument_list|,
name|bb
argument_list|,
operator|&
name|vars
argument_list|)
expr_stmt|;
block|}
name|declare_inline_vars
argument_list|(
name|id
operator|->
name|block
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Declare a return variable to replace the RESULT_DECL for the    function we are calling.  An appropriate DECL_STMT is returned.    The USE_STMT is filled to contain a use of the declaration to    indicate the return value of the function.     RETURN_SLOT_ADDR, if non-null, was a fake parameter that    took the address of the result.  MODIFY_DEST, if non-null, was the LHS of    the MODIFY_EXPR to which this call is the RHS.     The return value is a (possibly null) value that is the result of the    function as seen by the callee.  *USE_P is a (possibly null) value that    holds the result as seen by the caller.  */
end_comment

begin_function
specifier|static
name|tree
name|declare_return_variable
parameter_list|(
name|copy_body_data
modifier|*
name|id
parameter_list|,
name|tree
name|return_slot_addr
parameter_list|,
name|tree
name|modify_dest
parameter_list|,
name|tree
modifier|*
name|use_p
parameter_list|)
block|{
name|tree
name|callee
init|=
name|id
operator|->
name|src_fn
decl_stmt|;
name|tree
name|caller
init|=
name|id
operator|->
name|dst_fn
decl_stmt|;
name|tree
name|result
init|=
name|DECL_RESULT
argument_list|(
name|callee
argument_list|)
decl_stmt|;
name|tree
name|callee_type
init|=
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
decl_stmt|;
name|tree
name|caller_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|callee
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|var
decl_stmt|,
name|use
decl_stmt|;
comment|/* We don't need to do anything for functions that don't return      anything.  */
if|if
condition|(
operator|!
name|result
operator|||
name|VOID_TYPE_P
argument_list|(
name|callee_type
argument_list|)
condition|)
block|{
operator|*
name|use_p
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* If there was a return slot, then the return value is the      dereferenced address of that object.  */
if|if
condition|(
name|return_slot_addr
condition|)
block|{
comment|/* The front end shouldn't have used both return_slot_addr and 	 a modify expression.  */
name|gcc_assert
argument_list|(
operator|!
name|modify_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_BY_REFERENCE
argument_list|(
name|result
argument_list|)
condition|)
name|var
operator|=
name|return_slot_addr
expr_stmt|;
else|else
name|var
operator|=
name|build_fold_indirect_ref
argument_list|(
name|return_slot_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
operator|!
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|result
argument_list|)
operator|&&
name|DECL_P
argument_list|(
name|var
argument_list|)
condition|)
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|var
argument_list|)
operator|=
literal|0
expr_stmt|;
name|use
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* All types requiring non-trivial constructors should have been handled.  */
name|gcc_assert
argument_list|(
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|callee_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Attempt to avoid creating a new temporary variable.  */
if|if
condition|(
name|modify_dest
condition|)
block|{
name|bool
name|use_it
init|=
name|false
decl_stmt|;
comment|/* We can't use MODIFY_DEST if there's type promotion involved.  */
if|if
condition|(
operator|!
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|caller_type
argument_list|,
name|callee_type
argument_list|)
condition|)
name|use_it
operator|=
name|false
expr_stmt|;
comment|/* ??? If we're assigning to a variable sized type, then we must 	 reuse the destination variable, because we've no good way to 	 create variable sized temporaries at this point.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|caller_type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|use_it
operator|=
name|true
expr_stmt|;
comment|/* If the callee cannot possibly modify MODIFY_DEST, then we can 	 reuse it as the result of the call directly.  Don't do this if 	 it would promote MODIFY_DEST to addressable.  */
elseif|else
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|result
argument_list|)
condition|)
name|use_it
operator|=
name|false
expr_stmt|;
else|else
block|{
name|tree
name|base_m
init|=
name|get_base_address
argument_list|(
name|modify_dest
argument_list|)
decl_stmt|;
comment|/* If the base isn't a decl, then it's a pointer, and we don't 	     know where that's going to go.  */
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|base_m
argument_list|)
condition|)
name|use_it
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|is_global_var
argument_list|(
name|base_m
argument_list|)
condition|)
name|use_it
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
operator|!
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|result
argument_list|)
operator|&&
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|base_m
argument_list|)
condition|)
name|use_it
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|base_m
argument_list|)
condition|)
name|use_it
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|use_it
condition|)
block|{
name|var
operator|=
name|modify_dest
expr_stmt|;
name|use
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|callee_type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
name|var
operator|=
name|copy_result_decl_to_var
argument_list|(
name|result
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|DECL_SEEN_IN_BIND_EXPR_P
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_STRUCT_FUNCTION
argument_list|(
name|caller
argument_list|)
operator|->
name|unexpanded_var_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|var
argument_list|,
name|DECL_STRUCT_FUNCTION
argument_list|(
name|caller
argument_list|)
operator|->
name|unexpanded_var_list
argument_list|)
expr_stmt|;
comment|/* Do not have the rest of GCC warn about this variable as it should      not be visible to the user.  */
name|TREE_NO_WARNING
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|declare_inline_vars
argument_list|(
name|id
operator|->
name|block
argument_list|,
name|var
argument_list|)
expr_stmt|;
comment|/* Build the use expr.  If the return type of the function was      promoted, convert it back to the expected type.  */
name|use
operator|=
name|var
expr_stmt|;
if|if
condition|(
operator|!
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|,
name|caller_type
argument_list|)
condition|)
name|use
operator|=
name|fold_convert
argument_list|(
name|caller_type
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|STRIP_USELESS_TYPE_CONVERSION
argument_list|(
name|use
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_BY_REFERENCE
argument_list|(
name|result
argument_list|)
condition|)
name|var
operator|=
name|build_fold_addr_expr
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* Register the VAR_DECL as the equivalent for the RESULT_DECL; that      way, when the RESULT_DECL is encountered, it will be      automatically replaced by the VAR_DECL.  */
name|insert_decl_map
argument_list|(
name|id
argument_list|,
name|result
argument_list|,
name|var
argument_list|)
expr_stmt|;
comment|/* Remember this so we can ignore it in remap_decls.  */
name|id
operator|->
name|retvar
operator|=
name|var
expr_stmt|;
operator|*
name|use_p
operator|=
name|use
expr_stmt|;
return|return
name|var
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if a function can be inlined as a tree.  */
end_comment

begin_function
name|bool
name|tree_inlinable_function_p
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
return|return
name|inlinable_function_p
argument_list|(
name|fn
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|inline_forbidden_reason
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|tree
name|inline_forbidden_p_1
parameter_list|(
name|tree
modifier|*
name|nodep
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|fnp
parameter_list|)
block|{
name|tree
name|node
init|=
operator|*
name|nodep
decl_stmt|;
name|tree
name|fn
init|=
operator|(
name|tree
operator|)
name|fnp
decl_stmt|;
name|tree
name|t
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
condition|)
block|{
case|case
name|CALL_EXPR
case|:
comment|/* Refuse to inline alloca call unless user explicitly forced so as 	 this may change program's memory overhead drastically when the 	 function using alloca is called in loop.  In GCC present in 	 SPEC2000 inlining into schedule_block cause it to require 2GB of 	 RAM instead of 256MB.  */
if|if
condition|(
name|alloca_call_p
argument_list|(
name|node
argument_list|)
operator|&&
operator|!
name|lookup_attribute
argument_list|(
literal|"always_inline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
block|{
name|inline_forbidden_reason
operator|=
name|G_
argument_list|(
literal|"function %q+F can never be inlined because it uses "
literal|"alloca (override using the always_inline attribute)"
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
name|t
operator|=
name|get_callee_fndecl
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
break|break;
comment|/* We cannot inline functions that call setjmp.  */
if|if
condition|(
name|setjmp_call_p
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|inline_forbidden_reason
operator|=
name|G_
argument_list|(
literal|"function %q+F can never be inlined because it uses setjmp"
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|t
argument_list|)
operator|==
name|BUILT_IN_NORMAL
condition|)
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* We cannot inline functions that take a variable number of 	       arguments.  */
case|case
name|BUILT_IN_VA_START
case|:
case|case
name|BUILT_IN_STDARG_START
case|:
case|case
name|BUILT_IN_NEXT_ARG
case|:
case|case
name|BUILT_IN_VA_END
case|:
name|inline_forbidden_reason
operator|=
name|G_
argument_list|(
literal|"function %q+F can never be inlined because it "
literal|"uses variable argument lists"
argument_list|)
expr_stmt|;
return|return
name|node
return|;
case|case
name|BUILT_IN_LONGJMP
case|:
comment|/* We can't inline functions that call __builtin_longjmp at 	       all.  The non-local goto machinery really requires the 	       destination be in a different function.  If we allow the 	       function calling __builtin_longjmp to be inlined into the 	       function calling __builtin_setjmp, Things will Go Awry.  */
name|inline_forbidden_reason
operator|=
name|G_
argument_list|(
literal|"function %q+F can never be inlined because "
literal|"it uses setjmp-longjmp exception handling"
argument_list|)
expr_stmt|;
return|return
name|node
return|;
case|case
name|BUILT_IN_NONLOCAL_GOTO
case|:
comment|/* Similarly.  */
name|inline_forbidden_reason
operator|=
name|G_
argument_list|(
literal|"function %q+F can never be inlined because "
literal|"it uses non-local goto"
argument_list|)
expr_stmt|;
return|return
name|node
return|;
case|case
name|BUILT_IN_RETURN
case|:
case|case
name|BUILT_IN_APPLY_ARGS
case|:
comment|/* If a __builtin_apply_args caller would be inlined, 	       it would be saving arguments of the function it has 	       been inlined into.  Similarly __builtin_return would 	       return from the function the inline has been inlined into.  */
name|inline_forbidden_reason
operator|=
name|G_
argument_list|(
literal|"function %q+F can never be inlined because "
literal|"it uses __builtin_return or __builtin_apply_args"
argument_list|)
expr_stmt|;
return|return
name|node
return|;
default|default:
break|break;
block|}
break|break;
case|case
name|GOTO_EXPR
case|:
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We will not inline a function which uses computed goto.  The 	 addresses of its local labels, which may be tucked into 	 global storage, are of course not constant across 	 instantiations, which causes unexpected behavior.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|LABEL_DECL
condition|)
block|{
name|inline_forbidden_reason
operator|=
name|G_
argument_list|(
literal|"function %q+F can never be inlined "
literal|"because it contains a computed goto"
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
break|break;
case|case
name|LABEL_EXPR
case|:
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NONLOCAL
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* We cannot inline a function that receives a non-local goto 	     because we cannot remap the destination label used in the 	     function that is performing the non-local goto.  */
name|inline_forbidden_reason
operator|=
name|G_
argument_list|(
literal|"function %q+F can never be inlined "
literal|"because it receives a non-local goto"
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
comment|/* We cannot inline a function of the form  	   void F (int i) { struct S { int ar[i]; } s; }  	 Attempting to do so produces a catch-22. 	 If walk_tree examines the TYPE_FIELDS chain of RECORD_TYPE/ 	 UNION_TYPE nodes, then it goes into infinite recursion on a 	 structure containing a pointer to its own type.  If it doesn't, 	 then the type node for S doesn't get adjusted properly when 	 F is inlined.   	 ??? This is likely no longer true, but it's too late in the 4.0 	 cycle to try to find out.  This should be checked for 4.1.  */
for|for
control|(
name|t
operator|=
name|TYPE_FIELDS
argument_list|(
name|node
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|variably_modified_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|inline_forbidden_reason
operator|=
name|G_
argument_list|(
literal|"function %q+F can never be inlined "
literal|"because it uses variable sized variables"
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return subexpression representing possible alloca call, if any.  */
end_comment

begin_function
specifier|static
name|tree
name|inline_forbidden_p
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|location_t
name|saved_loc
init|=
name|input_location
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|tree
name|ret
init|=
name|NULL_TREE
decl_stmt|;
name|FOR_EACH_BB_FN
argument_list|(
argument|bb
argument_list|,
argument|DECL_STRUCT_FUNCTION (fndecl)
argument_list|)
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|ret
operator|=
name|walk_tree_without_duplicates
argument_list|(
name|bsi_stmt_ptr
argument_list|(
name|bsi
argument_list|)
argument_list|,
name|inline_forbidden_p_1
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|egress
goto|;
block|}
name|egress
label|:
name|input_location
operator|=
name|saved_loc
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if FN is a function that does not have any    fundamental inline blocking properties.  */
end_comment

begin_function
specifier|static
name|bool
name|inlinable_function_p
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|bool
name|inlinable
init|=
name|true
decl_stmt|;
comment|/* If we've already decided this function shouldn't be inlined,      there's no need to check again.  */
if|if
condition|(
name|DECL_UNINLINABLE
argument_list|(
name|fn
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* See if there is any language-specific reason it cannot be      inlined.  (It is important that this hook be called early because      in C++ it may result in template instantiation.)      If the function is not inlinable for language-specific reasons,      it is left up to the langhook to explain why.  */
name|inlinable
operator|=
operator|!
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|cannot_inline_tree_fn
argument_list|(
operator|&
name|fn
argument_list|)
expr_stmt|;
comment|/* If we don't have the function body available, we can't inline it.      However, this should not be recorded since we also get here for      forward declared inline functions.  Therefore, return at once.  */
if|if
condition|(
operator|!
name|DECL_SAVED_TREE
argument_list|(
name|fn
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If we're not inlining at all, then we cannot inline this function.  */
elseif|else
if|if
condition|(
operator|!
name|flag_inline_trees
condition|)
name|inlinable
operator|=
name|false
expr_stmt|;
comment|/* Only try to inline functions if DECL_INLINE is set.  This should be      true for all functions declared `inline', and for all other functions      as well with -finline-functions.       Don't think of disregarding DECL_INLINE when flag_inline_trees == 2;      it's the front-end that must set DECL_INLINE in this case, because      dwarf2out loses if a function that does not have DECL_INLINE set is      inlined anyway.  That is why we have both DECL_INLINE and      DECL_DECLARED_INLINE_P.  */
comment|/* FIXME: When flag_inline_trees dies, the check for flag_unit_at_a_time 	    here should be redundant.  */
elseif|else
if|if
condition|(
operator|!
name|DECL_INLINE
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|flag_unit_at_a_time
condition|)
name|inlinable
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|inline_forbidden_p
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* See if we should warn about uninlinable functions.  Previously, 	 some of these warnings would be issued while trying to expand 	 the function inline, but that would cause multiple warnings 	 about functions that would for example call alloca.  But since 	 this a property of the function, just one warning is enough. 	 As a bonus we can now give more details about the reason why a 	 function is not inlinable. 	 We only warn for functions declared `inline' by the user.  */
name|bool
name|do_warning
init|=
operator|(
name|warn_inline
operator|&&
name|DECL_INLINE
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|fn
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"always_inline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|sorry
argument_list|(
name|inline_forbidden_reason
argument_list|,
name|fn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|do_warning
condition|)
name|warning
argument_list|(
name|OPT_Winline
argument_list|,
name|inline_forbidden_reason
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|inlinable
operator|=
name|false
expr_stmt|;
block|}
comment|/* Squirrel away the result so that we don't have to check again.  */
name|DECL_UNINLINABLE
argument_list|(
name|fn
argument_list|)
operator|=
operator|!
name|inlinable
expr_stmt|;
return|return
name|inlinable
return|;
block|}
end_function

begin_comment
comment|/* Estimate the cost of a memory move.  Use machine dependent    word size and take possible memcpy call into account.  */
end_comment

begin_function
name|int
name|estimate_move_cost
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|HOST_WIDE_INT
name|size
decl_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
operator|||
name|size
operator|>
name|MOVE_MAX_PIECES
operator|*
name|MOVE_RATIO
condition|)
comment|/* Cost of a memcpy call, 3 arguments and the call.  */
return|return
literal|4
return|;
else|else
return|return
operator|(
operator|(
name|size
operator|+
name|MOVE_MAX_PIECES
operator|-
literal|1
operator|)
operator|/
name|MOVE_MAX_PIECES
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Used by estimate_num_insns.  Estimate number of instructions seen    by given statement.  */
end_comment

begin_function
specifier|static
name|tree
name|estimate_num_insns_1
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
modifier|*
name|count
init|=
operator|(
name|int
operator|*
operator|)
name|data
decl_stmt|;
name|tree
name|x
init|=
operator|*
name|tp
decl_stmt|;
if|if
condition|(
name|IS_TYPE_OR_DECL_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Assume that constants and references counts nothing.  These should      be majorized by amount of operations among them we count later      and are common target of CSE and similar optimizations.  */
elseif|else
if|if
condition|(
name|CONSTANT_CLASS_P
argument_list|(
name|x
argument_list|)
operator|||
name|REFERENCE_CLASS_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* Containers have no cost.  */
case|case
name|TREE_LIST
case|:
case|case
name|TREE_VEC
case|:
case|case
name|BLOCK
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|BIT_FIELD_REF
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|ALIGN_INDIRECT_REF
case|:
case|case
name|MISALIGNED_INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
case|case
name|OBJ_TYPE_REF
case|:
case|case
name|EXC_PTR_EXPR
case|:
comment|/* ??? */
case|case
name|FILTER_EXPR
case|:
comment|/* ??? */
case|case
name|COMPOUND_EXPR
case|:
case|case
name|BIND_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|COMPLEX_EXPR
case|:
case|case
name|RANGE_EXPR
case|:
case|case
name|CASE_LABEL_EXPR
case|:
case|case
name|SSA_NAME
case|:
case|case
name|CATCH_EXPR
case|:
case|case
name|EH_FILTER_EXPR
case|:
case|case
name|STATEMENT_LIST
case|:
case|case
name|ERROR_MARK
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|FDESC_EXPR
case|:
case|case
name|VA_ARG_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
case|case
name|TRY_FINALLY_EXPR
case|:
case|case
name|LABEL_EXPR
case|:
case|case
name|GOTO_EXPR
case|:
case|case
name|RETURN_EXPR
case|:
case|case
name|EXIT_EXPR
case|:
case|case
name|LOOP_EXPR
case|:
case|case
name|PHI_NODE
case|:
case|case
name|WITH_SIZE_EXPR
case|:
case|case
name|OMP_CLAUSE
case|:
case|case
name|OMP_RETURN
case|:
case|case
name|OMP_CONTINUE
case|:
break|break;
comment|/* We don't account constants for now.  Assume that the cost is amortized        by operations that do use them.  We may re-consider this decision once        we are able to optimize the tree before estimating its size and break        out static initializers.  */
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|COMPLEX_CST
case|:
case|case
name|VECTOR_CST
case|:
case|case
name|STRING_CST
case|:
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
comment|/* Try to estimate the cost of assignments.  We have three cases to        deal with: 	1) Simple assignments to registers; 	2) Stores to things that must live in memory.  This includes 	   "normal" stores to scalars, but also assignments of large 	   structures, or constructors of big arrays; 	3) TARGET_EXPRs.         Let us look at the first two cases, assuming we have "a = b + C":<modify_expr<var_decl "a"><plus_expr<var_decl "b"><constant C>>        If "a" is a GIMPLE register, the assignment to it is free on almost        any target, because "a" usually ends up in a real register.  Hence        the only cost of this expression comes from the PLUS_EXPR, and we        can ignore the MODIFY_EXPR.        If "a" is not a GIMPLE register, the assignment to "a" will most        likely be a real store, so the cost of the MODIFY_EXPR is the cost        of moving something into "a", which we compute using the function        estimate_move_cost.         The third case deals with TARGET_EXPRs, for which the semantics are        that a temporary is assigned, unless the TARGET_EXPR itself is being        assigned to something else.  In the latter case we do not need the        temporary.  E.g. in<modify_expr<var_decl "a"><target_expr>>, the        MODIFY_EXPR is free.  */
case|case
name|INIT_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
comment|/* Is the right and side a TARGET_EXPR?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
break|break;
comment|/* ... fall through ...  */
case|case
name|TARGET_EXPR
case|:
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Is this an assignments to a register?  */
if|if
condition|(
name|is_gimple_reg
argument_list|(
name|x
argument_list|)
condition|)
break|break;
comment|/* Otherwise it's a store, so fall through to compute the move cost.  */
case|case
name|CONSTRUCTOR
case|:
operator|*
name|count
operator|+=
name|estimate_move_cost
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Assign cost of 1 to usual operations.        ??? We may consider mapping RTL costs to this.  */
case|case
name|COND_EXPR
case|:
case|case
name|VEC_COND_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
case|case
name|VEC_LSHIFT_EXPR
case|:
case|case
name|VEC_RSHIFT_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|ORDERED_EXPR
case|:
case|case
name|UNORDERED_EXPR
case|:
case|case
name|UNLT_EXPR
case|:
case|case
name|UNLE_EXPR
case|:
case|case
name|UNGT_EXPR
case|:
case|case
name|UNGE_EXPR
case|:
case|case
name|UNEQ_EXPR
case|:
case|case
name|LTGT_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|CONJ_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|SWITCH_EXPR
case|:
case|case
name|ASM_EXPR
case|:
case|case
name|REALIGN_LOAD_EXPR
case|:
case|case
name|REDUC_MAX_EXPR
case|:
case|case
name|REDUC_MIN_EXPR
case|:
case|case
name|REDUC_PLUS_EXPR
case|:
case|case
name|WIDEN_SUM_EXPR
case|:
case|case
name|DOT_PROD_EXPR
case|:
case|case
name|WIDEN_MULT_EXPR
case|:
case|case
name|RESX_EXPR
case|:
operator|*
name|count
operator|+=
literal|1
expr_stmt|;
break|break;
comment|/* Few special cases of expensive operations.  This is useful        to avoid inlining on functions having too many of these.  */
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
operator|*
name|count
operator|+=
literal|10
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|decl
init|=
name|get_callee_fndecl
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|tree
name|arg
decl_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_BUILT_IN_CLASS
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_NORMAL
condition|)
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_CONSTANT_P
case|:
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
case|case
name|BUILT_IN_EXPECT
case|:
return|return
name|NULL_TREE
return|;
default|default:
break|break;
block|}
comment|/* Our cost must be kept in sync with cgraph_estimate_size_after_inlining 	   that does use function declaration to figure out the arguments.  */
if|if
condition|(
operator|!
name|decl
condition|)
block|{
for|for
control|(
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
operator|*
name|count
operator|+=
name|estimate_move_cost
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
operator|*
name|count
operator|+=
name|estimate_move_cost
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|count
operator|+=
name|PARAM_VALUE
argument_list|(
name|PARAM_INLINE_CALL_COST
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OMP_PARALLEL
case|:
case|case
name|OMP_FOR
case|:
case|case
name|OMP_SECTIONS
case|:
case|case
name|OMP_SINGLE
case|:
case|case
name|OMP_SECTION
case|:
case|case
name|OMP_MASTER
case|:
case|case
name|OMP_ORDERED
case|:
case|case
name|OMP_CRITICAL
case|:
case|case
name|OMP_ATOMIC
case|:
comment|/* OpenMP directives are generally very expensive.  */
operator|*
name|count
operator|+=
literal|40
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Estimate number of instructions that will be created by expanding EXPR.  */
end_comment

begin_function
name|int
name|estimate_num_insns
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|int
name|num
init|=
literal|0
decl_stmt|;
name|struct
name|pointer_set_t
modifier|*
name|visited_nodes
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|struct
name|function
modifier|*
name|my_function
decl_stmt|;
comment|/* If we're given an entire function, walk the CFG.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|my_function
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|my_function
operator|&&
name|my_function
operator|->
name|cfg
argument_list|)
expr_stmt|;
name|visited_nodes
operator|=
name|pointer_set_create
argument_list|()
expr_stmt|;
name|FOR_EACH_BB_FN
argument_list|(
argument|bb
argument_list|,
argument|my_function
argument_list|)
block|{
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|walk_tree
argument_list|(
name|bsi_stmt_ptr
argument_list|(
name|bsi
argument_list|)
argument_list|,
name|estimate_num_insns_1
argument_list|,
operator|&
name|num
argument_list|,
name|visited_nodes
argument_list|)
expr_stmt|;
block|}
block|}
name|pointer_set_destroy
argument_list|(
name|visited_nodes
argument_list|)
expr_stmt|;
block|}
else|else
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|expr
argument_list|,
name|estimate_num_insns_1
argument_list|,
operator|&
name|num
argument_list|)
expr_stmt|;
return|return
name|num
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|struct
name|function
modifier|*
name|function_p
typedef|;
end_typedef

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|function_p
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|function_p
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Initialized with NOGC, making this poisonous to the garbage collector.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|function_p
argument_list|,
name|heap
argument_list|)
operator|*
name|cfun_stack
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|push_cfun
parameter_list|(
name|struct
name|function
modifier|*
name|new_cfun
parameter_list|)
block|{
name|VEC_safe_push
argument_list|(
name|function_p
argument_list|,
name|heap
argument_list|,
name|cfun_stack
argument_list|,
name|cfun
argument_list|)
expr_stmt|;
name|cfun
operator|=
name|new_cfun
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_cfun
parameter_list|(
name|void
parameter_list|)
block|{
name|cfun
operator|=
name|VEC_pop
argument_list|(
name|function_p
argument_list|,
name|cfun_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Install new lexical TREE_BLOCK underneath 'current_block'.  */
end_comment

begin_function
specifier|static
name|void
name|add_lexical_block
parameter_list|(
name|tree
name|current_block
parameter_list|,
name|tree
name|new_block
parameter_list|)
block|{
name|tree
modifier|*
name|blk_p
decl_stmt|;
comment|/* Walk to the last sub-block.  */
for|for
control|(
name|blk_p
operator|=
operator|&
name|BLOCK_SUBBLOCKS
argument_list|(
name|current_block
argument_list|)
init|;
operator|*
name|blk_p
condition|;
name|blk_p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|blk_p
argument_list|)
control|)
empty_stmt|;
operator|*
name|blk_p
operator|=
name|new_block
expr_stmt|;
name|BLOCK_SUPERCONTEXT
argument_list|(
name|new_block
argument_list|)
operator|=
name|current_block
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If *TP is a CALL_EXPR, replace it with its inline expansion.  */
end_comment

begin_function
specifier|static
name|bool
name|expand_call_inline
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|tree
modifier|*
name|tp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|copy_body_data
modifier|*
name|id
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|use_retvar
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|splay_tree
name|st
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|tree
name|return_slot_addr
decl_stmt|;
name|tree
name|modify_dest
decl_stmt|;
name|location_t
name|saved_location
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|cg_edge
decl_stmt|;
specifier|const
name|char
modifier|*
name|reason
decl_stmt|;
name|basic_block
name|return_block
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|,
name|stmt_bsi
decl_stmt|;
name|bool
name|successfully_inlined
init|=
name|FALSE
decl_stmt|;
name|bool
name|purge_dead_abnormal_edges
decl_stmt|;
name|tree
name|t_step
decl_stmt|;
name|tree
name|var
decl_stmt|;
comment|/* See what we've got.  */
name|id
operator|=
operator|(
name|copy_body_data
operator|*
operator|)
name|data
expr_stmt|;
name|t
operator|=
operator|*
name|tp
expr_stmt|;
comment|/* Set input_location here so we get the right instantiation context      if we call instantiate_decl from inlinable_function_p.  */
name|saved_location
operator|=
name|input_location
expr_stmt|;
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|t
argument_list|)
condition|)
name|input_location
operator|=
name|EXPR_LOCATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* From here on, we're only interested in CALL_EXPRs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|CALL_EXPR
condition|)
goto|goto
name|egress
goto|;
comment|/* First, see if we can figure out what function is being called.      If we cannot, then there is no hope of inlining the function.  */
name|fn
operator|=
name|get_callee_fndecl
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
goto|goto
name|egress
goto|;
comment|/* Turn forward declarations into real ones.  */
name|fn
operator|=
name|cgraph_node
argument_list|(
name|fn
argument_list|)
operator|->
name|decl
expr_stmt|;
comment|/* If fn is a declaration of a function in a nested scope that was      globally declared inline, we don't set its DECL_INITIAL.      However, we can't blindly follow DECL_ABSTRACT_ORIGIN because the      C++ front-end uses it for cdtors to refer to their internal      declarations, that are not real functions.  Fortunately those      don't have trees to be saved, so we can tell by checking their      DECL_SAVED_TREE.  */
if|if
condition|(
operator|!
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|fn
operator|=
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Objective C and fortran still calls tree_rest_of_compilation directly.      Kill this check once this is fixed.  */
if|if
condition|(
operator|!
name|id
operator|->
name|dst_node
operator|->
name|analyzed
condition|)
goto|goto
name|egress
goto|;
name|cg_edge
operator|=
name|cgraph_edge
argument_list|(
name|id
operator|->
name|dst_node
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
comment|/* Constant propagation on argument done during previous inlining      may create new direct call.  Produce an edge for it.  */
if|if
condition|(
operator|!
name|cg_edge
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|dest
init|=
name|cgraph_node
argument_list|(
name|fn
argument_list|)
decl_stmt|;
comment|/* We have missing edge in the callgraph.  This can happen in one case          where previous inlining turned indirect call into direct call by          constant propagating arguments.  In all other cases we hit a bug          (incorrect node sharing is most common reason for missing edges.  */
name|gcc_assert
argument_list|(
name|dest
operator|->
name|needed
operator|||
operator|!
name|flag_unit_at_a_time
argument_list|)
expr_stmt|;
name|cgraph_create_edge
argument_list|(
name|id
operator|->
name|dst_node
argument_list|,
name|dest
argument_list|,
name|stmt
argument_list|,
name|bb
operator|->
name|count
argument_list|,
name|bb
operator|->
name|loop_depth
argument_list|)
operator|->
name|inline_failed
operator|=
name|N_
argument_list|(
literal|"originally indirect function call not considered for inlining"
argument_list|)
expr_stmt|;
goto|goto
name|egress
goto|;
block|}
comment|/* Don't try to inline functions that are not well-suited to      inlining.  */
if|if
condition|(
operator|!
name|cgraph_inline_p
argument_list|(
name|cg_edge
argument_list|,
operator|&
name|reason
argument_list|)
condition|)
block|{
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"always_inline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|fn
argument_list|)
argument_list|)
comment|/* Avoid warnings during early inline pass. */
operator|&&
operator|(
operator|!
name|flag_unit_at_a_time
operator|||
name|cgraph_global_info_ready
operator|)
condition|)
block|{
name|sorry
argument_list|(
literal|"inlining failed in call to %q+F: %s"
argument_list|,
name|fn
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|sorry
argument_list|(
literal|"called from here"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn_inline
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|fn
argument_list|)
operator|&&
name|strlen
argument_list|(
name|reason
argument_list|)
operator|&&
operator|!
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|fn
argument_list|)
argument_list|)
comment|/* Avoid warnings during early inline pass. */
operator|&&
operator|(
operator|!
name|flag_unit_at_a_time
operator|||
name|cgraph_global_info_ready
operator|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Winline
argument_list|,
literal|"inlining failed in call to %q+F: %s"
argument_list|,
name|fn
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Winline
argument_list|,
literal|"called from here"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|egress
goto|;
block|}
name|fn
operator|=
name|cg_edge
operator|->
name|callee
operator|->
name|decl
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|cg_edge
operator|->
name|callee
operator|->
name|decl
operator|!=
name|id
operator|->
name|dst_node
operator|->
name|decl
condition|)
name|verify_cgraph_node
argument_list|(
name|cg_edge
operator|->
name|callee
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We will be inlining this callee.  */
name|id
operator|->
name|eh_region
operator|=
name|lookup_stmt_eh_region
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* Split the block holding the CALL_EXPR.  */
name|e
operator|=
name|split_block
argument_list|(
name|bb
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|bb
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|return_block
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* split_block splits after the statement; work around this by      moving the call into the second block manually.  Not pretty,      but seems easier than doing the CFG manipulation by hand      when the CALL_EXPR is in the last statement of BB.  */
name|stmt_bsi
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|stmt_bsi
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* If the CALL_EXPR was in the last statement of BB, it may have      been the source of abnormal edges.  In this case, schedule      the removal of dead abnormal edges.  */
name|bsi
operator|=
name|bsi_start
argument_list|(
name|return_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
block|{
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|purge_dead_abnormal_edges
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|purge_dead_abnormal_edges
operator|=
name|false
expr_stmt|;
block|}
name|stmt_bsi
operator|=
name|bsi_start
argument_list|(
name|return_block
argument_list|)
expr_stmt|;
comment|/* Build a block containing code to initialize the arguments, the      actual inline expansion of the body, and a label for the return      statements within the function to jump to.  The type of the      statement expression is the return type of the function call.  */
name|id
operator|->
name|block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|id
operator|->
name|block
argument_list|)
operator|=
name|fn
expr_stmt|;
name|BLOCK_SOURCE_LOCATION
argument_list|(
name|id
operator|->
name|block
argument_list|)
operator|=
name|input_location
expr_stmt|;
name|add_lexical_block
argument_list|(
name|TREE_BLOCK
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|id
operator|->
name|block
argument_list|)
expr_stmt|;
comment|/* Local declarations will be replaced by their equivalents in this      map.  */
name|st
operator|=
name|id
operator|->
name|decl_map
expr_stmt|;
name|id
operator|->
name|decl_map
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Initialize the parameters.  */
name|args
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Record the function we are about to inline.  */
name|id
operator|->
name|src_fn
operator|=
name|fn
expr_stmt|;
name|id
operator|->
name|src_node
operator|=
name|cg_edge
operator|->
name|callee
expr_stmt|;
name|initialize_inlined_parameters
argument_list|(
name|id
argument_list|,
name|args
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|fn
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
condition|)
name|add_lexical_block
argument_list|(
name|id
operator|->
name|block
argument_list|,
name|remap_blocks
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
argument_list|,
name|id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return statements in the function body will be replaced by jumps      to the RET_LABEL.  */
name|gcc_assert
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|BLOCK
argument_list|)
expr_stmt|;
comment|/* Find the lhs to which the result of this call is assigned.  */
name|return_slot_addr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|modify_dest
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The function which we are inlining might not return a value, 	 in which case we should issue a warning that the function 	 does not return a value.  In that case the optimizers will 	 see that the variable to which the value is assigned was not 	 initialized.  We do not want to issue a warning about that 	 uninitialized variable.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|modify_dest
argument_list|)
condition|)
name|TREE_NO_WARNING
argument_list|(
name|modify_dest
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CALL_EXPR_RETURN_SLOT_OPT
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|return_slot_addr
operator|=
name|build_fold_addr_expr
argument_list|(
name|modify_dest
argument_list|)
expr_stmt|;
name|STRIP_USELESS_TYPE_CONVERSION
argument_list|(
name|return_slot_addr
argument_list|)
expr_stmt|;
name|modify_dest
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
name|modify_dest
operator|=
name|NULL
expr_stmt|;
comment|/* Declare the return variable for the function.  */
name|declare_return_variable
argument_list|(
name|id
argument_list|,
name|return_slot_addr
argument_list|,
name|modify_dest
argument_list|,
operator|&
name|use_retvar
argument_list|)
expr_stmt|;
comment|/* This is it.  Duplicate the callee body.  Assume callee is      pre-gimplified.  Note that we must not alter the caller      function in any way before this point, as this CALL_EXPR may be      a self-referential call; if we're calling ourselves, we need to      duplicate our body before altering anything.  */
name|copy_body
argument_list|(
name|id
argument_list|,
name|bb
operator|->
name|count
argument_list|,
name|bb
operator|->
name|frequency
argument_list|,
name|bb
argument_list|,
name|return_block
argument_list|)
expr_stmt|;
comment|/* Add local vars in this inlined callee to caller.  */
name|t_step
operator|=
name|id
operator|->
name|src_cfun
operator|->
name|unexpanded_var_list
expr_stmt|;
for|for
control|(
init|;
name|t_step
condition|;
name|t_step
operator|=
name|TREE_CHAIN
argument_list|(
name|t_step
argument_list|)
control|)
block|{
name|var
operator|=
name|TREE_VALUE
argument_list|(
name|t_step
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|var
argument_list|)
condition|)
name|cfun
operator|->
name|unexpanded_var_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|var
argument_list|,
name|cfun
operator|->
name|unexpanded_var_list
argument_list|)
expr_stmt|;
else|else
name|cfun
operator|->
name|unexpanded_var_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|remap_decl
argument_list|(
name|var
argument_list|,
name|id
argument_list|)
argument_list|,
name|cfun
operator|->
name|unexpanded_var_list
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up.  */
name|splay_tree_delete
argument_list|(
name|id
operator|->
name|decl_map
argument_list|)
expr_stmt|;
name|id
operator|->
name|decl_map
operator|=
name|st
expr_stmt|;
comment|/* If the inlined function returns a result that we care about,      clobber the CALL_EXPR with a reference to the return variable.  */
if|if
condition|(
name|use_retvar
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|stmt_bsi
argument_list|)
argument_list|)
operator|!=
name|CALL_EXPR
operator|)
condition|)
block|{
operator|*
name|tp
operator|=
name|use_retvar
expr_stmt|;
name|maybe_clean_or_replace_eh_stmt
argument_list|(
name|stmt
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We're modifying a TSI owned by gimple_expand_calls_inline();        tsi_delink() will leave the iterator in a sane state.  */
name|bsi_remove
argument_list|(
operator|&
name|stmt_bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|purge_dead_abnormal_edges
condition|)
name|tree_purge_dead_abnormal_call_edges
argument_list|(
name|return_block
argument_list|)
expr_stmt|;
comment|/* If the value of the new expression is ignored, that's OK.  We      don't warn about this for CALL_EXPRs, so we shouldn't warn about      the equivalent inlined version either.  */
name|TREE_USED
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Output the inlining info for this abstract function, since it has been      inlined.  If we don't do this now, we can lose the information about the      variables in the function when the blocks get blown away as soon as we      remove the cgraph node.  */
call|(
modifier|*
name|debug_hooks
operator|->
name|outlining_inline_function
call|)
argument_list|(
name|cg_edge
operator|->
name|callee
operator|->
name|decl
argument_list|)
expr_stmt|;
comment|/* Update callgraph if needed.  */
name|cgraph_remove_node
argument_list|(
name|cg_edge
operator|->
name|callee
argument_list|)
expr_stmt|;
name|id
operator|->
name|block
operator|=
name|NULL_TREE
expr_stmt|;
name|successfully_inlined
operator|=
name|TRUE
expr_stmt|;
name|egress
label|:
name|input_location
operator|=
name|saved_location
expr_stmt|;
return|return
name|successfully_inlined
return|;
block|}
end_function

begin_comment
comment|/* Expand call statements reachable from STMT_P.    We can only have CALL_EXPRs as the "toplevel" tree code or nested    in a MODIFY_EXPR.  See tree-gimple.c:get_call_expr_in().  We can    unfortunately not use that function here because we need a pointer    to the CALL_EXPR, not the tree itself.  */
end_comment

begin_function
specifier|static
name|bool
name|gimple_expand_calls_inline
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|copy_body_data
modifier|*
name|id
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
comment|/* Register specific tree functions.  */
name|tree_register_cfg_hooks
argument_list|()
expr_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
modifier|*
name|expr_p
init|=
name|bsi_stmt_ptr
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
name|tree
name|stmt
init|=
operator|*
name|expr_p
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|expr_p
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|WITH_SIZE_EXPR
condition|)
name|expr_p
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|CALL_EXPR
condition|)
if|if
condition|(
name|expand_call_inline
argument_list|(
name|bb
argument_list|,
name|stmt
argument_list|,
name|expr_p
argument_list|,
name|id
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Expand calls to inline functions in the body of FN.  */
end_comment

begin_function
name|void
name|optimize_inline_calls
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|copy_body_data
name|id
decl_stmt|;
name|tree
name|prev_fn
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* There is no point in performing inlining if errors have already      occurred -- and we might crash if we try to inline invalid      code.  */
if|if
condition|(
name|errorcount
operator|||
name|sorrycount
condition|)
return|return;
comment|/* Clear out ID.  */
name|memset
argument_list|(
operator|&
name|id
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|.
name|src_node
operator|=
name|id
operator|.
name|dst_node
operator|=
name|cgraph_node
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|id
operator|.
name|dst_fn
operator|=
name|fn
expr_stmt|;
comment|/* Or any functions that aren't finished yet.  */
name|prev_fn
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|current_function_decl
condition|)
block|{
name|id
operator|.
name|dst_fn
operator|=
name|current_function_decl
expr_stmt|;
name|prev_fn
operator|=
name|current_function_decl
expr_stmt|;
block|}
name|id
operator|.
name|copy_decl
operator|=
name|copy_decl_maybe_to_var
expr_stmt|;
name|id
operator|.
name|transform_call_graph_edges
operator|=
name|CB_CGE_DUPLICATE
expr_stmt|;
name|id
operator|.
name|transform_new_cfg
operator|=
name|false
expr_stmt|;
name|id
operator|.
name|transform_return_to_modify
operator|=
name|true
expr_stmt|;
name|id
operator|.
name|transform_lang_insert_block
operator|=
name|false
expr_stmt|;
name|push_gimplify_context
argument_list|()
expr_stmt|;
comment|/* Reach the trees by walking over the CFG, and note the      enclosing basic-blocks in the call edges.  */
comment|/* We walk the blocks going forward, because inlined function bodies      will split id->current_basic_block, and the new blocks will      follow it; we'll trudge through them, processing their CALL_EXPRs      along the way.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|gimple_expand_calls_inline
argument_list|(
name|bb
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
name|pop_gimplify_context
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Renumber the (code) basic_blocks consecutively.  */
name|compact_blocks
argument_list|()
expr_stmt|;
comment|/* Renumber the lexical scoping (non-code) blocks consecutively.  */
name|number_blocks
argument_list|(
name|fn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
name|verify_cgraph_node
argument_list|(
name|id
operator|.
name|dst_node
argument_list|)
expr_stmt|;
comment|/* Double check that we inlined everything we are supposed to inline.  */
for|for
control|(
name|e
operator|=
name|id
operator|.
name|dst_node
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
name|gcc_assert
argument_list|(
name|e
operator|->
name|inline_failed
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* We need to rescale frequencies again to peak at REG_BR_PROB_BASE      as inlining loops might increase the maximum.  */
if|if
condition|(
name|ENTRY_BLOCK_PTR
operator|->
name|count
condition|)
name|counts_to_freqs
argument_list|()
expr_stmt|;
name|fold_cond_expr_cond
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FN is a function that has a complete body, and CLONE is a function whose    body is to be set to a copy of FN, mapping argument declarations according    to the ARG_MAP splay_tree.  */
end_comment

begin_function
name|void
name|clone_body
parameter_list|(
name|tree
name|clone
parameter_list|,
name|tree
name|fn
parameter_list|,
name|void
modifier|*
name|arg_map
parameter_list|)
block|{
name|copy_body_data
name|id
decl_stmt|;
comment|/* Clone the body, as if we were making an inline call.  But, remap the      parameters in the callee to the parameters of caller.  */
name|memset
argument_list|(
operator|&
name|id
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|.
name|src_fn
operator|=
name|fn
expr_stmt|;
name|id
operator|.
name|dst_fn
operator|=
name|clone
expr_stmt|;
name|id
operator|.
name|src_cfun
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|id
operator|.
name|decl_map
operator|=
operator|(
name|splay_tree
operator|)
name|arg_map
expr_stmt|;
name|id
operator|.
name|copy_decl
operator|=
name|copy_decl_no_change
expr_stmt|;
name|id
operator|.
name|transform_call_graph_edges
operator|=
name|CB_CGE_DUPLICATE
expr_stmt|;
name|id
operator|.
name|transform_new_cfg
operator|=
name|true
expr_stmt|;
name|id
operator|.
name|transform_return_to_modify
operator|=
name|false
expr_stmt|;
name|id
operator|.
name|transform_lang_insert_block
operator|=
name|true
expr_stmt|;
comment|/* We're not inside any EH region.  */
name|id
operator|.
name|eh_region
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Actually copy the body.  */
name|append_to_statement_list_force
argument_list|(
name|copy_generic_body
argument_list|(
operator|&
name|id
argument_list|)
argument_list|,
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|clone
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Passed to walk_tree.  Copies the node pointed to, if appropriate.  */
end_comment

begin_function
name|tree
name|copy_tree_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
decl_stmt|;
comment|/* We make copies of most nodes.  */
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
argument_list|)
operator|||
name|code
operator|==
name|TREE_LIST
operator|||
name|code
operator|==
name|TREE_VEC
operator|||
name|code
operator|==
name|TYPE_DECL
operator|||
name|code
operator|==
name|OMP_CLAUSE
condition|)
block|{
comment|/* Because the chain gets clobbered when we make a copy, we save it 	 here.  */
name|tree
name|chain
init|=
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
decl_stmt|;
name|tree
name|new
decl_stmt|;
comment|/* Copy the node.  */
name|new
operator|=
name|copy_node
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
comment|/* Propagate mudflap marked-ness.  */
if|if
condition|(
name|flag_mudflap
operator|&&
name|mf_marked_p
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
name|mf_mark
argument_list|(
name|new
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|new
expr_stmt|;
comment|/* Now, restore the chain, if appropriate.  That will cause 	 walk_tree to walk into the chain as well.  */
if|if
condition|(
name|code
operator|==
name|PARM_DECL
operator|||
name|code
operator|==
name|TREE_LIST
operator|||
name|code
operator|==
name|OMP_CLAUSE
condition|)
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
name|chain
expr_stmt|;
comment|/* For now, we don't update BLOCKs when we make copies.  So, we 	 have to nullify all BIND_EXPRs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|BIND_EXPR
condition|)
name|BIND_EXPR_BLOCK
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CONSTRUCTOR
condition|)
block|{
comment|/* CONSTRUCTOR nodes need special handling because          we need to duplicate the vector of elements.  */
name|tree
name|new
decl_stmt|;
name|new
operator|=
name|copy_node
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
comment|/* Propagate mudflap marked-ness.  */
if|if
condition|(
name|flag_mudflap
operator|&&
name|mf_marked_p
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
name|mf_mark
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|CONSTRUCTOR_ELTS
argument_list|(
name|new
argument_list|)
operator|=
name|VEC_copy
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|new
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_type
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_declaration
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_constant
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
name|code
operator|!=
name|STATEMENT_LIST
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* The SAVE_EXPR pointed to by TP is being copied.  If ST contains    information indicating to what new SAVE_EXPR this one should be mapped,    use that one.  Otherwise, create a new node and enter it in ST.  FN is    the function into which the copy will be placed.  */
end_comment

begin_function
specifier|static
name|void
name|remap_save_expr
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|void
modifier|*
name|st_
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|)
block|{
name|splay_tree
name|st
init|=
operator|(
name|splay_tree
operator|)
name|st_
decl_stmt|;
name|splay_tree_node
name|n
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* See if we already encountered this SAVE_EXPR.  */
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|st
argument_list|,
operator|(
name|splay_tree_key
operator|)
operator|*
name|tp
argument_list|)
expr_stmt|;
comment|/* If we didn't already remap this SAVE_EXPR, do so now.  */
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|t
operator|=
name|copy_node
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
comment|/* Remember this SAVE_EXPR.  */
name|splay_tree_insert
argument_list|(
name|st
argument_list|,
operator|(
name|splay_tree_key
operator|)
operator|*
name|tp
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|t
argument_list|)
expr_stmt|;
comment|/* Make sure we don't remap an already-remapped SAVE_EXPR.  */
name|splay_tree_insert
argument_list|(
name|st
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|t
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We've already walked into this SAVE_EXPR; don't do it again.  */
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
name|t
operator|=
operator|(
name|tree
operator|)
name|n
operator|->
name|value
expr_stmt|;
block|}
comment|/* Replace this SAVE_EXPR with the copy.  */
operator|*
name|tp
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called via walk_tree.  If *TP points to a DECL_STMT for a local label,    copies the declaration and enters it in the splay_tree in DATA (which is    really an `copy_body_data *').  */
end_comment

begin_function
specifier|static
name|tree
name|mark_local_for_remap_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|copy_body_data
modifier|*
name|id
init|=
operator|(
name|copy_body_data
operator|*
operator|)
name|data
decl_stmt|;
comment|/* Don't walk into types.  */
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
block|{
name|tree
name|decl
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Copy the decl and remember the copy.  */
name|insert_decl_map
argument_list|(
name|id
argument_list|,
name|decl
argument_list|,
name|id
operator|->
name|copy_decl
argument_list|(
name|decl
argument_list|,
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Perform any modifications to EXPR required when it is unsaved.  Does    not recurse into EXPR's subtrees.  */
end_comment

begin_function
specifier|static
name|void
name|unsave_expr_1
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|TARGET_EXPR
case|:
comment|/* Don't mess with a TARGET_EXPR that hasn't been expanded.          It's OK for this to happen if it was part of a subtree that          isn't immediately expanded, such as operand 2 of another          TARGET_EXPR.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|3
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Called via walk_tree when an expression is unsaved.  Using the    splay_tree pointed to by ST (which is really a `splay_tree'),    remaps all local declarations to appropriate replacements.  */
end_comment

begin_function
specifier|static
name|tree
name|unsave_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|copy_body_data
modifier|*
name|id
init|=
operator|(
name|copy_body_data
operator|*
operator|)
name|data
decl_stmt|;
name|splay_tree
name|st
init|=
name|id
operator|->
name|decl_map
decl_stmt|;
name|splay_tree_node
name|n
decl_stmt|;
comment|/* Only a local declaration (variable or label).  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
operator|*
name|tp
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|LABEL_DECL
condition|)
block|{
comment|/* Lookup the declaration.  */
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|st
argument_list|,
operator|(
name|splay_tree_key
operator|)
operator|*
name|tp
argument_list|)
expr_stmt|;
comment|/* If it's there, remap it.  */
if|if
condition|(
name|n
condition|)
operator|*
name|tp
operator|=
operator|(
name|tree
operator|)
name|n
operator|->
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|STATEMENT_LIST
condition|)
name|copy_statement_list
argument_list|(
name|tp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|BIND_EXPR
condition|)
name|copy_bind_expr
argument_list|(
name|tp
argument_list|,
name|walk_subtrees
argument_list|,
name|id
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|remap_save_expr
argument_list|(
name|tp
argument_list|,
name|st
argument_list|,
name|walk_subtrees
argument_list|)
expr_stmt|;
else|else
block|{
name|copy_tree_r
argument_list|(
name|tp
argument_list|,
name|walk_subtrees
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Do whatever unsaving is required.  */
name|unsave_expr_1
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
block|}
comment|/* Keep iterating.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Copies everything in EXPR and replaces variables, labels    and SAVE_EXPRs local to EXPR.  */
end_comment

begin_function
name|tree
name|unsave_expr_now
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|copy_body_data
name|id
decl_stmt|;
comment|/* There's nothing to do for NULL_TREE.  */
if|if
condition|(
name|expr
operator|==
literal|0
condition|)
return|return
name|expr
return|;
comment|/* Set up ID.  */
name|memset
argument_list|(
operator|&
name|id
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|.
name|src_fn
operator|=
name|current_function_decl
expr_stmt|;
name|id
operator|.
name|dst_fn
operator|=
name|current_function_decl
expr_stmt|;
name|id
operator|.
name|decl_map
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|id
operator|.
name|copy_decl
operator|=
name|copy_decl_no_change
expr_stmt|;
name|id
operator|.
name|transform_call_graph_edges
operator|=
name|CB_CGE_DUPLICATE
expr_stmt|;
name|id
operator|.
name|transform_new_cfg
operator|=
name|false
expr_stmt|;
name|id
operator|.
name|transform_return_to_modify
operator|=
name|false
expr_stmt|;
name|id
operator|.
name|transform_lang_insert_block
operator|=
name|false
expr_stmt|;
comment|/* Walk the tree once to find local labels.  */
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|expr
argument_list|,
name|mark_local_for_remap_r
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
comment|/* Walk the tree again, copying, remapping, and unsaving.  */
name|walk_tree
argument_list|(
operator|&
name|expr
argument_list|,
name|unsave_r
argument_list|,
operator|&
name|id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
name|splay_tree_delete
argument_list|(
name|id
operator|.
name|decl_map
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Allow someone to determine if SEARCH is a child of TOP from gdb.  */
end_comment

begin_function
specifier|static
name|tree
name|debug_find_tree_1
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
operator|*
name|tp
operator|==
name|data
condition|)
return|return
operator|(
name|tree
operator|)
name|data
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|bool
name|debug_find_tree
parameter_list|(
name|tree
name|top
parameter_list|,
name|tree
name|search
parameter_list|)
block|{
return|return
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|top
argument_list|,
name|debug_find_tree_1
argument_list|,
name|search
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Declare the variables created by the inliner.  Add all the variables in    VARS to BIND_EXPR.  */
end_comment

begin_function
specifier|static
name|void
name|declare_inline_vars
parameter_list|(
name|tree
name|block
parameter_list|,
name|tree
name|vars
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|vars
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|DECL_SEEN_IN_BIND_EXPR_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|unexpanded_var_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|cfun
operator|->
name|unexpanded_var_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|block
condition|)
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|chainon
argument_list|(
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy NODE (which must be a DECL).  The DECL originally was in the FROM_FN,    but now it will be in the TO_FN.  PARM_TO_VAR means enable PARM_DECL to    VAR_DECL translation.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_decl_for_dup_finish
parameter_list|(
name|copy_body_data
modifier|*
name|id
parameter_list|,
name|tree
name|decl
parameter_list|,
name|tree
name|copy
parameter_list|)
block|{
comment|/* Don't generate debug information for the copy if we wouldn't have      generated it for the copy either.  */
name|DECL_ARTIFICIAL
argument_list|(
name|copy
argument_list|)
operator|=
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|copy
argument_list|)
operator|=
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Set the DECL_ABSTRACT_ORIGIN so the debugging routines know what      declaration inspired this copy.  */
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|copy
argument_list|)
operator|=
name|DECL_ORIGIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* The new variable/label has no RTL, yet.  */
if|if
condition|(
name|CODE_CONTAINS_STRUCT
argument_list|(
name|TREE_CODE
argument_list|(
name|copy
argument_list|)
argument_list|,
name|TS_DECL_WRTL
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|copy
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|copy
argument_list|)
condition|)
name|SET_DECL_RTL
argument_list|(
name|copy
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* These args would always appear unused, if not for this.  */
name|TREE_USED
argument_list|(
name|copy
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Set the context for the new declaration.  */
if|if
condition|(
operator|!
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Globals stay global.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|id
operator|->
name|src_fn
condition|)
comment|/* Things that weren't in the scope of the function we're inlining        from aren't in the scope we're inlining to, either.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Function-scoped static variables should stay in the original        function.  */
empty_stmt|;
else|else
comment|/* Ordinary automatic local variables are now in the scope of the        new function.  */
name|DECL_CONTEXT
argument_list|(
name|copy
argument_list|)
operator|=
name|id
operator|->
name|dst_fn
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|copy_decl_to_var
parameter_list|(
name|tree
name|decl
parameter_list|,
name|copy_body_data
modifier|*
name|id
parameter_list|)
block|{
name|tree
name|copy
decl_stmt|,
name|type
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|copy
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|copy
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|copy
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|copy
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|copy
argument_list|)
operator|=
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|copy_decl_for_dup_finish
argument_list|(
name|id
argument_list|,
name|decl
argument_list|,
name|copy
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like copy_decl_to_var, but create a return slot object instead of a    pointer variable for return by invisible reference.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_result_decl_to_var
parameter_list|(
name|tree
name|decl
parameter_list|,
name|copy_body_data
modifier|*
name|id
parameter_list|)
block|{
name|tree
name|copy
decl_stmt|,
name|type
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_BY_REFERENCE
argument_list|(
name|decl
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|copy
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|copy
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|copy
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_BY_REFERENCE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|TREE_ADDRESSABLE
argument_list|(
name|copy
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|copy
argument_list|)
operator|=
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
return|return
name|copy_decl_for_dup_finish
argument_list|(
name|id
argument_list|,
name|decl
argument_list|,
name|copy
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|copy_decl_no_change
parameter_list|(
name|tree
name|decl
parameter_list|,
name|copy_body_data
modifier|*
name|id
parameter_list|)
block|{
name|tree
name|copy
decl_stmt|;
name|copy
operator|=
name|copy_node
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* The COPY is not abstract; it will be generated in DST_FN.  */
name|DECL_ABSTRACT
argument_list|(
name|copy
argument_list|)
operator|=
literal|0
expr_stmt|;
name|lang_hooks
operator|.
name|dup_lang_specific_decl
argument_list|(
name|copy
argument_list|)
expr_stmt|;
comment|/* TREE_ADDRESSABLE isn't used to indicate that a label's address has      been taken; it's for internal bookkeeping in expand_goto_internal.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|LABEL_DECL
condition|)
block|{
name|TREE_ADDRESSABLE
argument_list|(
name|copy
argument_list|)
operator|=
literal|0
expr_stmt|;
name|LABEL_DECL_UID
argument_list|(
name|copy
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|copy_decl_for_dup_finish
argument_list|(
name|id
argument_list|,
name|decl
argument_list|,
name|copy
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|copy_decl_maybe_to_var
parameter_list|(
name|tree
name|decl
parameter_list|,
name|copy_body_data
modifier|*
name|id
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
condition|)
return|return
name|copy_decl_to_var
argument_list|(
name|decl
argument_list|,
name|id
argument_list|)
return|;
else|else
return|return
name|copy_decl_no_change
argument_list|(
name|decl
argument_list|,
name|id
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a copy of the function's argument tree.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_arguments_for_versioning
parameter_list|(
name|tree
name|orig_parm
parameter_list|,
name|copy_body_data
modifier|*
name|id
parameter_list|)
block|{
name|tree
modifier|*
name|arg_copy
decl_stmt|,
modifier|*
name|parg
decl_stmt|;
name|arg_copy
operator|=
operator|&
name|orig_parm
expr_stmt|;
for|for
control|(
name|parg
operator|=
name|arg_copy
init|;
operator|*
name|parg
condition|;
name|parg
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|parg
argument_list|)
control|)
block|{
name|tree
name|new
init|=
name|remap_decl
argument_list|(
operator|*
name|parg
argument_list|,
name|id
argument_list|)
decl_stmt|;
name|lang_hooks
operator|.
name|dup_lang_specific_decl
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|new
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|parg
argument_list|)
expr_stmt|;
operator|*
name|parg
operator|=
name|new
expr_stmt|;
block|}
return|return
name|orig_parm
return|;
block|}
end_function

begin_comment
comment|/* Return a copy of the function's static chain.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_static_chain
parameter_list|(
name|tree
name|static_chain
parameter_list|,
name|copy_body_data
modifier|*
name|id
parameter_list|)
block|{
name|tree
modifier|*
name|chain_copy
decl_stmt|,
modifier|*
name|pvar
decl_stmt|;
name|chain_copy
operator|=
operator|&
name|static_chain
expr_stmt|;
for|for
control|(
name|pvar
operator|=
name|chain_copy
init|;
operator|*
name|pvar
condition|;
name|pvar
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|pvar
argument_list|)
control|)
block|{
name|tree
name|new
init|=
name|remap_decl
argument_list|(
operator|*
name|pvar
argument_list|,
name|id
argument_list|)
decl_stmt|;
name|lang_hooks
operator|.
name|dup_lang_specific_decl
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|new
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|pvar
argument_list|)
expr_stmt|;
operator|*
name|pvar
operator|=
name|new
expr_stmt|;
block|}
return|return
name|static_chain
return|;
block|}
end_function

begin_comment
comment|/* Return true if the function is allowed to be versioned.    This is a guard for the versioning functionality.  */
end_comment

begin_function
name|bool
name|tree_versionable_function_p
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
if|if
condition|(
name|fndecl
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
comment|/* ??? There are cases where a function is      uninlinable but can be versioned.  */
if|if
condition|(
operator|!
name|tree_inlinable_function_p
argument_list|(
name|fndecl
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create a copy of a function's tree.    OLD_DECL and NEW_DECL are FUNCTION_DECL tree nodes    of the original function and the new copied function    respectively.  In case we want to replace a DECL     tree with another tree while duplicating the function's     body, TREE_MAP represents the mapping between these     trees. If UPDATE_CLONES is set, the call_stmt fields    of edges of clones of the function will be updated.  */
end_comment

begin_function
name|void
name|tree_function_versioning
parameter_list|(
name|tree
name|old_decl
parameter_list|,
name|tree
name|new_decl
parameter_list|,
name|varray_type
name|tree_map
parameter_list|,
name|bool
name|update_clones
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|old_version_node
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|new_version_node
decl_stmt|;
name|copy_body_data
name|id
decl_stmt|;
name|tree
name|p
decl_stmt|,
name|new_fndecl
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|struct
name|ipa_replace_map
modifier|*
name|replace_info
decl_stmt|;
name|basic_block
name|old_entry_block
decl_stmt|;
name|tree
name|t_step
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|old_decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|new_decl
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
name|DECL_POSSIBLY_INLINED
argument_list|(
name|old_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|old_version_node
operator|=
name|cgraph_node
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
name|new_version_node
operator|=
name|cgraph_node
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
name|allocate_struct_function
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
comment|/* Cfun points to the new allocated function struct at this point.  */
name|cfun
operator|->
name|function_end_locus
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|new_decl
argument_list|)
operator|=
name|DECL_ORIGIN
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
comment|/* Generate a new name for the new version. */
if|if
condition|(
operator|!
name|update_clones
condition|)
name|DECL_NAME
argument_list|(
name|new_decl
argument_list|)
operator|=
name|create_tmp_var_name
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Create a new SYMBOL_REF rtx for the new name. */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|old_decl
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|SET_DECL_RTL
argument_list|(
name|new_decl
argument_list|,
name|copy_rtx
argument_list|(
name|DECL_RTL
argument_list|(
name|old_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|new_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|old_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|new_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Prepare the data structures for the tree copy.  */
name|memset
argument_list|(
operator|&
name|id
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|.
name|decl_map
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|id
operator|.
name|src_fn
operator|=
name|old_decl
expr_stmt|;
name|id
operator|.
name|dst_fn
operator|=
name|new_decl
expr_stmt|;
name|id
operator|.
name|src_node
operator|=
name|old_version_node
expr_stmt|;
name|id
operator|.
name|dst_node
operator|=
name|new_version_node
expr_stmt|;
name|id
operator|.
name|src_cfun
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
name|id
operator|.
name|copy_decl
operator|=
name|copy_decl_no_change
expr_stmt|;
name|id
operator|.
name|transform_call_graph_edges
operator|=
name|update_clones
condition|?
name|CB_CGE_MOVE_CLONES
else|:
name|CB_CGE_MOVE
expr_stmt|;
name|id
operator|.
name|transform_new_cfg
operator|=
name|true
expr_stmt|;
name|id
operator|.
name|transform_return_to_modify
operator|=
name|false
expr_stmt|;
name|id
operator|.
name|transform_lang_insert_block
operator|=
name|false
expr_stmt|;
name|current_function_decl
operator|=
name|new_decl
expr_stmt|;
comment|/* Copy the function's static chain.  */
name|p
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|old_decl
argument_list|)
operator|->
name|static_chain_decl
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|DECL_STRUCT_FUNCTION
argument_list|(
name|new_decl
argument_list|)
operator|->
name|static_chain_decl
operator|=
name|copy_static_chain
argument_list|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|old_decl
argument_list|)
operator|->
name|static_chain_decl
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
comment|/* Copy the function's arguments.  */
if|if
condition|(
name|DECL_ARGUMENTS
argument_list|(
name|old_decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|DECL_ARGUMENTS
argument_list|(
name|new_decl
argument_list|)
operator|=
name|copy_arguments_for_versioning
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|old_decl
argument_list|)
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
comment|/* If there's a tree_map, prepare for substitution.  */
if|if
condition|(
name|tree_map
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|tree_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|replace_info
operator|=
name|VARRAY_GENERIC_PTR
argument_list|(
name|tree_map
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|replace_info
operator|->
name|replace_p
condition|)
name|insert_decl_map
argument_list|(
operator|&
name|id
argument_list|,
name|replace_info
operator|->
name|old_tree
argument_list|,
name|replace_info
operator|->
name|new_tree
argument_list|)
expr_stmt|;
block|}
name|DECL_INITIAL
argument_list|(
name|new_decl
argument_list|)
operator|=
name|remap_blocks
argument_list|(
name|DECL_INITIAL
argument_list|(
name|id
operator|.
name|src_fn
argument_list|)
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
comment|/* Renumber the lexical scoping (non-code) blocks consecutively.  */
name|number_blocks
argument_list|(
name|id
operator|.
name|dst_fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|old_decl
argument_list|)
operator|->
name|unexpanded_var_list
operator|!=
name|NULL_TREE
condition|)
comment|/* Add local vars.  */
for|for
control|(
name|t_step
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|old_decl
argument_list|)
operator|->
name|unexpanded_var_list
init|;
name|t_step
condition|;
name|t_step
operator|=
name|TREE_CHAIN
argument_list|(
name|t_step
argument_list|)
control|)
block|{
name|tree
name|var
init|=
name|TREE_VALUE
argument_list|(
name|t_step
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|var
argument_list|)
condition|)
name|cfun
operator|->
name|unexpanded_var_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|var
argument_list|,
name|cfun
operator|->
name|unexpanded_var_list
argument_list|)
expr_stmt|;
else|else
name|cfun
operator|->
name|unexpanded_var_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|remap_decl
argument_list|(
name|var
argument_list|,
operator|&
name|id
argument_list|)
argument_list|,
name|cfun
operator|->
name|unexpanded_var_list
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the Function's body.  */
name|old_entry_block
operator|=
name|ENTRY_BLOCK_PTR_FOR_FUNCTION
argument_list|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|old_decl
argument_list|)
argument_list|)
expr_stmt|;
name|new_fndecl
operator|=
name|copy_body
argument_list|(
operator|&
name|id
argument_list|,
name|old_entry_block
operator|->
name|count
argument_list|,
name|old_entry_block
operator|->
name|frequency
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DECL_SAVED_TREE
argument_list|(
name|new_decl
argument_list|)
operator|=
name|DECL_SAVED_TREE
argument_list|(
name|new_fndecl
argument_list|)
expr_stmt|;
name|DECL_STRUCT_FUNCTION
argument_list|(
name|new_decl
argument_list|)
operator|->
name|cfg
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|new_fndecl
argument_list|)
operator|->
name|cfg
expr_stmt|;
name|DECL_STRUCT_FUNCTION
argument_list|(
name|new_decl
argument_list|)
operator|->
name|eh
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|new_fndecl
argument_list|)
operator|->
name|eh
expr_stmt|;
name|DECL_STRUCT_FUNCTION
argument_list|(
name|new_decl
argument_list|)
operator|->
name|ib_boundaries_block
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|new_fndecl
argument_list|)
operator|->
name|ib_boundaries_block
expr_stmt|;
name|DECL_STRUCT_FUNCTION
argument_list|(
name|new_decl
argument_list|)
operator|->
name|last_label_uid
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|new_fndecl
argument_list|)
operator|->
name|last_label_uid
expr_stmt|;
if|if
condition|(
name|DECL_RESULT
argument_list|(
name|old_decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
modifier|*
name|res_decl
init|=
operator|&
name|DECL_RESULT
argument_list|(
name|old_decl
argument_list|)
decl_stmt|;
name|DECL_RESULT
argument_list|(
name|new_decl
argument_list|)
operator|=
name|remap_decl
argument_list|(
operator|*
name|res_decl
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|dup_lang_specific_decl
argument_list|(
name|DECL_RESULT
argument_list|(
name|new_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
comment|/* Renumber the lexical scoping (non-code) blocks consecutively.  */
name|number_blocks
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
name|splay_tree_delete
argument_list|(
name|id
operator|.
name|decl_map
argument_list|)
expr_stmt|;
name|fold_cond_expr_cond
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Duplicate a type, fields and all.  */
end_comment

begin_function
name|tree
name|build_duplicate_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|struct
name|copy_body_data
name|id
decl_stmt|;
name|memset
argument_list|(
operator|&
name|id
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|.
name|src_fn
operator|=
name|current_function_decl
expr_stmt|;
name|id
operator|.
name|dst_fn
operator|=
name|current_function_decl
expr_stmt|;
name|id
operator|.
name|src_cfun
operator|=
name|cfun
expr_stmt|;
name|id
operator|.
name|decl_map
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|type
operator|=
name|remap_type_1
argument_list|(
name|type
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
name|splay_tree_delete
argument_list|(
name|id
operator|.
name|decl_map
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

end_unit

