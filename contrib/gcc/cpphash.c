begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Hash tables for the CPP library.    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Written by Per Bothner, 1994.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"cpphash.h"
end_include

begin_decl_stmt
specifier|static
name|cpp_hashnode
modifier|*
name|alloc_node
name|PARAMS
argument_list|(
operator|(
name|hash_table
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return an identifier node for hashtable.c.  Used by cpplib except    when integrated with the C front ends.  */
end_comment

begin_function
specifier|static
name|cpp_hashnode
modifier|*
name|alloc_node
parameter_list|(
name|table
parameter_list|)
name|hash_table
modifier|*
name|table
decl_stmt|;
block|{
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
name|node
operator|=
operator|(
name|cpp_hashnode
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|table
operator|->
name|pfile
operator|->
name|hash_ob
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_hashnode
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_hashnode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Set up the identifier hash table.  Use TABLE if non-null, otherwise    create our own.  */
end_comment

begin_function
name|void
name|_cpp_init_hashtable
parameter_list|(
name|pfile
parameter_list|,
name|table
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|hash_table
modifier|*
name|table
decl_stmt|;
block|{
name|struct
name|spec_nodes
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|table
operator|==
name|NULL
condition|)
block|{
name|pfile
operator|->
name|our_hashtable
operator|=
literal|1
expr_stmt|;
name|table
operator|=
name|ht_create
argument_list|(
literal|13
argument_list|)
expr_stmt|;
comment|/* 8K (=2^13) entries.  */
name|table
operator|->
name|alloc_node
operator|=
operator|(
name|hashnode
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|hash_table
operator|*
operator|)
argument_list|)
operator|)
name|alloc_node
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|pfile
operator|->
name|hash_ob
argument_list|)
expr_stmt|;
block|}
name|table
operator|->
name|pfile
operator|=
name|pfile
expr_stmt|;
name|pfile
operator|->
name|hash_table
operator|=
name|table
expr_stmt|;
comment|/* Now we can initialize things that use the hash table.  */
name|_cpp_init_directives
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_init_internal_pragmas
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|s
operator|=
operator|&
name|pfile
operator|->
name|spec_nodes
expr_stmt|;
name|s
operator|->
name|n_defined
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|DSC
argument_list|(
literal|"defined"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|n_true
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|DSC
argument_list|(
literal|"true"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|n_false
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|DSC
argument_list|(
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|n__STRICT_ANSI__
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|DSC
argument_list|(
literal|"__STRICT_ANSI__"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|n__CHAR_UNSIGNED__
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|DSC
argument_list|(
literal|"__CHAR_UNSIGNED__"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|n__VA_ARGS__
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|DSC
argument_list|(
literal|"__VA_ARGS__"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|n__VA_ARGS__
operator|->
name|flags
operator||=
name|NODE_DIAGNOSTIC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tear down the identifier hash table.  */
end_comment

begin_function
name|void
name|_cpp_destroy_hashtable
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
if|if
condition|(
name|pfile
operator|->
name|our_hashtable
condition|)
block|{
name|ht_destroy
argument_list|(
name|pfile
operator|->
name|hash_table
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|pfile
operator|->
name|hash_ob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the hash entry for the STR of length LEN, creating one    if necessary.  */
end_comment

begin_function
name|cpp_hashnode
modifier|*
name|cpp_lookup
parameter_list|(
name|pfile
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
block|{
comment|/* ht_lookup cannot return NULL.  */
return|return
name|CPP_HASHNODE
argument_list|(
name|ht_lookup
argument_list|(
name|pfile
operator|->
name|hash_table
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|HT_ALLOC
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine whether the str STR, of length LEN, is a defined macro.  */
end_comment

begin_function
name|int
name|cpp_defined
parameter_list|(
name|pfile
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|CPP_HASHNODE
argument_list|(
name|ht_lookup
argument_list|(
name|pfile
operator|->
name|hash_table
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|HT_NO_INSERT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If it's of type NT_MACRO, it cannot be poisoned.  */
return|return
name|node
operator|&&
name|node
operator|->
name|type
operator|==
name|NT_MACRO
return|;
block|}
end_function

begin_comment
comment|/* For all nodes in the hashtable, callback CB with parameters PFILE,    the node, and V.  */
end_comment

begin_function
name|void
name|cpp_forall_identifiers
parameter_list|(
name|pfile
parameter_list|,
name|cb
parameter_list|,
name|v
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_cb
name|cb
decl_stmt|;
name|PTR
name|v
decl_stmt|;
block|{
comment|/* We don't need a proxy since the hash table's identifier comes      first in cpp_hashnode.  */
name|ht_forall
argument_list|(
name|pfile
operator|->
name|hash_table
argument_list|,
operator|(
name|ht_cb
operator|)
name|cb
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

