begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Part of CPP library.  (Macro handling.)    Copyright (C) 1986, 87, 89, 92-95, 1996, 1998 Free Software Foundation, Inc.    Written by Per Bothner, 1994.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"cpphash.h"
end_include

begin_undef
undef|#
directive|undef
name|abort
end_undef

begin_decl_stmt
specifier|static
name|int
name|comp_def_part
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|change_newlines
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_macro_expansion
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|HASHNODE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unsafe_chars
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SKIP_WHITE_SPACE
parameter_list|(
name|p
parameter_list|)
value|do { while (is_hor_space[*p]) p++; } while (0)
end_define

begin_define
define|#
directive|define
name|CPP_IS_MACRO_BUFFER
parameter_list|(
name|PBUF
parameter_list|)
value|((PBUF)->data != NULL)
end_define

begin_define
define|#
directive|define
name|FORWARD
parameter_list|(
name|N
parameter_list|)
value|CPP_FORWARD (CPP_BUFFER (pfile), (N))
end_define

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The arglist structure is built by create_definition to tell    collect_expansion where the argument names begin.  That    is, for a define like "#define f(x,y,z) foo+x-bar*y", the arglist    would contain pointers to the strings x, y, and z.    collect_expansion would then build a DEFINITION node,    with reflist nodes pointing to the places x, y, and z had    appeared.  So the arglist is just convenience data passed    between these two routines.  It is not kept around after    the current #define has been processed and entered into the    hash table.  */
end_comment

begin_struct
struct|struct
name|arglist
block|{
name|struct
name|arglist
modifier|*
name|next
decl_stmt|;
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|argno
decl_stmt|;
name|char
name|rest_args
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure represents one parsed argument in a macro call.    `raw' points to the argument text as written (`raw_length' is its length).    `expanded' points to the argument's macro-expansion    (its length is `expand_length').    `stringified_length' is the length the argument would have    if stringified.    `use_count' is the number of times this macro arg is substituted    into the macro.  If the actual use count exceeds 10,     the value stored is 10.  */
end_comment

begin_comment
comment|/* raw and expanded are relative to ARG_BASE */
end_comment

begin_define
define|#
directive|define
name|ARG_BASE
value|((pfile)->token_buffer)
end_define

begin_struct
struct|struct
name|argdata
block|{
comment|/* Strings relative to pfile->token_buffer */
name|long
name|raw
decl_stmt|,
name|expanded
decl_stmt|,
name|stringified
decl_stmt|;
name|int
name|raw_length
decl_stmt|,
name|expand_length
decl_stmt|;
name|int
name|stringified_length
decl_stmt|;
name|char
name|newlines
decl_stmt|;
name|char
name|use_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Return hash function on name.  must be compatible with the one    computed a step at a time, elsewhere  */
end_comment

begin_function
name|int
name|hashf
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|hashsize
parameter_list|)
specifier|register
specifier|const
name|U_CHAR
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|hashsize
decl_stmt|;
block|{
specifier|register
name|int
name|r
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|r
operator|=
name|HASHSTEP
argument_list|(
name|r
argument_list|,
operator|*
name|name
operator|++
argument_list|)
expr_stmt|;
return|return
name|MAKE_POS
argument_list|(
name|r
argument_list|)
operator|%
name|hashsize
return|;
block|}
end_function

begin_comment
comment|/* Find the most recent hash node for name "name" (ending with first    non-identifier char) installed by cpp_install     If LEN is>= 0, it is the length of the name.    Otherwise, compute the length by scanning the entire name.     If HASH is>= 0, it is the precomputed hash code.    Otherwise, compute the hash code.  */
end_comment

begin_function
name|HASHNODE
modifier|*
name|cpp_lookup
parameter_list|(
name|pfile
parameter_list|,
name|name
parameter_list|,
name|len
parameter_list|,
name|hash
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
specifier|register
specifier|const
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
specifier|register
name|HASHNODE
modifier|*
name|bucket
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|bp
operator|=
name|name
init|;
name|is_idchar
index|[
operator|*
name|bp
index|]
condition|;
name|bp
operator|++
control|)
empty_stmt|;
name|len
operator|=
name|bp
operator|-
name|name
expr_stmt|;
block|}
if|if
condition|(
name|hash
operator|<
literal|0
condition|)
name|hash
operator|=
name|hashf
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|pfile
operator|->
name|hashtab
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|bucket
condition|)
block|{
if|if
condition|(
name|bucket
operator|->
name|length
operator|==
name|len
operator|&&
name|strncmp
argument_list|(
name|bucket
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bucket
return|;
name|bucket
operator|=
name|bucket
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|HASHNODE
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Delete a hash node.  Some weirdness to free junk from macros.  * More such weirdness will have to be added if you define more hash  * types that need it.  */
end_comment

begin_comment
comment|/* Note that the DEFINITION of a macro is removed from the hash table    but its storage is not freed.  This would be a storage leak    except that it is not reasonable to keep undefining and redefining    large numbers of macros many times.    In any case, this is necessary, because a macro can be #undef'd    in the middle of reading the arguments to a call to it.    If #undef freed the DEFINITION, that would crash.  */
end_comment

begin_function
name|void
name|delete_macro
parameter_list|(
name|hp
parameter_list|)
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
block|{
if|if
condition|(
name|hp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|prev
operator|->
name|next
operator|=
name|hp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
operator|->
name|prev
expr_stmt|;
comment|/* make sure that the bucket chain header that      the deleted guy was on points to the right thing afterwards.  */
if|if
condition|(
name|hp
operator|==
operator|*
name|hp
operator|->
name|bucket_hdr
condition|)
operator|*
name|hp
operator|->
name|bucket_hdr
operator|=
name|hp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
condition|)
block|{
name|DEFINITION
modifier|*
name|d
init|=
name|hp
operator|->
name|value
operator|.
name|defn
decl_stmt|;
name|struct
name|reflist
modifier|*
name|ap
decl_stmt|,
modifier|*
name|nextap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|d
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|nextap
control|)
block|{
name|nextap
operator|=
name|ap
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|nargs
operator|>=
literal|0
condition|)
name|free
argument_list|(
name|d
operator|->
name|args
operator|.
name|argnames
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Install a name in the main hash table, even if it is already there.    Name stops with first non alphanumeric, except leading '#'.    Caller must check against redefinition if that is desired.    delete_macro () removes things installed by cpp_install () in fifo order.    this is important because of the `defined' special symbol used    in #if, and also if pushdef/popdef directives are ever implemented.     If LEN is>= 0, it is the length of the name.    Otherwise, compute the length by scanning the entire name.     If HASH is>= 0, it is the precomputed hash code.    Otherwise, compute the hash code.  */
end_comment

begin_function
name|HASHNODE
modifier|*
name|cpp_install
parameter_list|(
name|pfile
parameter_list|,
name|name
parameter_list|,
name|len
parameter_list|,
name|type
parameter_list|,
name|value
parameter_list|,
name|hash
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|enum
name|node_type
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
specifier|register
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|bucket
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|p
operator|=
name|name
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|name
expr_stmt|;
block|}
if|if
condition|(
name|hash
operator|<
literal|0
condition|)
name|hash
operator|=
name|hashf
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
name|i
operator|=
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
operator|+
name|len
operator|+
literal|1
expr_stmt|;
name|hp
operator|=
operator|(
name|HASHNODE
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|hash
expr_stmt|;
name|hp
operator|->
name|bucket_hdr
operator|=
operator|&
name|pfile
operator|->
name|hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|hp
operator|->
name|next
operator|=
name|pfile
operator|->
name|hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|pfile
operator|->
name|hashtab
index|[
name|bucket
index|]
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|hp
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|hp
operator|->
name|value
operator|.
name|cpval
operator|=
name|value
expr_stmt|;
name|hp
operator|->
name|name
operator|=
operator|(
operator|(
name|U_CHAR
operator|*
operator|)
name|hp
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|hp
operator|->
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|hp
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|hp
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|macro_cleanup
parameter_list|(
name|pbuf
parameter_list|,
name|pfile
parameter_list|)
name|cpp_buffer
modifier|*
name|pbuf
decl_stmt|;
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|HASHNODE
modifier|*
name|macro
init|=
operator|(
name|HASHNODE
operator|*
operator|)
name|pbuf
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|macro
operator|->
name|type
operator|==
name|T_DISABLED
condition|)
name|macro
operator|->
name|type
operator|=
name|T_MACRO
expr_stmt|;
if|if
condition|(
name|macro
operator|->
name|type
operator|!=
name|T_MACRO
operator|||
name|pbuf
operator|->
name|buf
operator|!=
name|macro
operator|->
name|value
operator|.
name|defn
operator|->
name|expansion
condition|)
name|free
argument_list|(
name|pbuf
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read a replacement list for a macro with parameters.    Build the DEFINITION structure.    Reads characters of text starting at BUF until END.    ARGLIST specifies the formal parameters to look for    in the text of the definition; NARGS is the number of args    in that list, or -1 for a macro name that wants no argument list.    MACRONAME is the macro name itself (so we can avoid recursive expansion)    and NAMELEN is its length in characters.        Note that comments, backslash-newlines, and leading white space    have already been deleted from the argument.  */
end_comment

begin_function
specifier|static
name|DEFINITION
modifier|*
name|collect_expansion
parameter_list|(
name|pfile
parameter_list|,
name|buf
parameter_list|,
name|limit
parameter_list|,
name|nargs
parameter_list|,
name|arglist
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|nargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|arglist
modifier|*
name|arglist
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|,
modifier|*
name|lastp
decl_stmt|,
modifier|*
name|exp_p
decl_stmt|;
name|struct
name|reflist
modifier|*
name|endpat
init|=
name|NULL
decl_stmt|;
comment|/* Pointer to first nonspace after last ## seen.  */
name|U_CHAR
modifier|*
name|concat
init|=
literal|0
decl_stmt|;
comment|/* Pointer to first nonspace after last single-# seen.  */
name|U_CHAR
modifier|*
name|stringify
init|=
literal|0
decl_stmt|;
name|int
name|maxsize
decl_stmt|;
name|int
name|expected_delimiter
init|=
literal|'\0'
decl_stmt|;
comment|/* Scan thru the replacement list, ignoring comments and quoted      strings, picking up on the macro calls.  It does a linear search      thru the arg list on every potential symbol.  Profiling might say      that something smarter should happen.  */
if|if
condition|(
name|limit
operator|<
name|buf
condition|)
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"internal error: limit< buf in collect_expansion"
argument_list|)
expr_stmt|;
name|limit
operator|=
name|buf
expr_stmt|;
comment|/* treat it like a null defn */
block|}
comment|/* Find the beginning of the trailing whitespace.  */
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
name|is_space
index|[
name|limit
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|limit
operator|--
expr_stmt|;
comment|/* Allocate space for the text in the macro definition.      Leading and trailing whitespace chars need 2 bytes each.      Each other input char may or may not need 1 byte,      so this is an upper bound.  The extra 5 are for invented      leading and trailing newline-marker and final null.  */
name|maxsize
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|DEFINITION
argument_list|)
operator|+
operator|(
name|limit
operator|-
name|p
operator|)
operator|+
literal|5
operator|)
expr_stmt|;
name|defn
operator|=
operator|(
name|DEFINITION
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|maxsize
argument_list|)
expr_stmt|;
name|defn
operator|->
name|nargs
operator|=
name|nargs
expr_stmt|;
name|exp_p
operator|=
name|defn
operator|->
name|expansion
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|defn
operator|+
sizeof|sizeof
argument_list|(
name|DEFINITION
argument_list|)
expr_stmt|;
name|lastp
operator|=
name|exp_p
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
comment|/* Add one initial space escape-marker to prevent accidental      token-pasting (often removed by macroexpand).  */
operator|*
name|exp_p
operator|++
operator|=
literal|'\r'
expr_stmt|;
operator|*
name|exp_p
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|limit
operator|-
name|p
operator|>=
literal|2
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'#'
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`##' at start of macro definition"
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Process the main body of the definition.  */
while|while
condition|(
name|p
operator|<
name|limit
condition|)
block|{
name|int
name|skipped_arg
init|=
literal|0
decl_stmt|;
specifier|register
name|U_CHAR
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
operator|*
name|exp_p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
if|if
condition|(
name|expected_delimiter
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|expected_delimiter
condition|)
name|expected_delimiter
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|expected_delimiter
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|p
operator|<
name|limit
operator|&&
name|expected_delimiter
condition|)
block|{
comment|/* In a string, backslash goes through 		     and makes next char ordinary.  */
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'#'
case|:
comment|/* # is ordinary inside a string.  */
if|if
condition|(
name|expected_delimiter
condition|)
break|break;
if|if
condition|(
name|p
operator|<
name|limit
operator|&&
operator|*
name|p
operator|==
literal|'#'
condition|)
block|{
comment|/* ##: concatenate preceding and following tokens.  */
comment|/* Take out the first #, discard preceding whitespace.  */
name|exp_p
operator|--
expr_stmt|;
while|while
condition|(
name|exp_p
operator|>
name|lastp
operator|&&
name|is_hor_space
index|[
name|exp_p
index|[
operator|-
literal|1
index|]
index|]
condition|)
operator|--
name|exp_p
expr_stmt|;
comment|/* Skip the second #.  */
name|p
operator|++
expr_stmt|;
comment|/* Discard following whitespace.  */
name|SKIP_WHITE_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|concat
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|limit
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`##' at end of macro definition"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nargs
operator|>=
literal|0
condition|)
block|{
comment|/* Single #: stringify following argument ref. 		     Don't leave the # in the expansion.  */
name|exp_p
operator|--
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|limit
operator|||
operator|!
name|is_idstart
index|[
operator|*
name|p
index|]
operator|||
operator|(
operator|*
name|p
operator|==
literal|'L'
operator|&&
name|p
operator|+
literal|1
operator|<
name|limit
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\''
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'"'
operator|)
operator|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`#' operator is not followed by a macro argument name"
argument_list|)
expr_stmt|;
else|else
name|stringify
operator|=
name|p
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
comment|/* In -traditional mode, recognize arguments inside strings and 	     character constants, and ignore special properties of #. 	     Arguments inside strings are considered "stringified", but no 	     extra quote marks are supplied.  */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
if|if
condition|(
name|expected_delimiter
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|expected_delimiter
condition|)
name|expected_delimiter
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|expected_delimiter
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Backslash quotes delimiters and itself, 		 but not macro args.  */
if|if
condition|(
name|expected_delimiter
operator|!=
literal|0
operator|&&
name|p
operator|<
name|limit
operator|&&
operator|(
operator|*
name|p
operator|==
name|expected_delimiter
operator|||
operator|*
name|p
operator|==
literal|'\\'
operator|)
condition|)
block|{
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|expected_delimiter
operator|!=
literal|'\0'
condition|)
comment|/* No comments inside strings.  */
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
comment|/* If we find a comment that wasn't removed by 		     handle_directive, this must be -traditional. 		     So replace the comment with nothing at all.  */
name|exp_p
operator|--
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
operator|!
operator|(
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'*'
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Mark this as a concatenation-point, 		     as if it had been ##.  */
block|concat = p;
endif|#
directive|endif
block|}
break|break;
block|}
block|}
comment|/* Handle the start of a symbol.  */
if|if
condition|(
name|is_idchar
index|[
name|c
index|]
operator|&&
name|nargs
operator|>
literal|0
condition|)
block|{
name|U_CHAR
modifier|*
name|id_beg
init|=
name|p
operator|-
literal|1
decl_stmt|;
name|int
name|id_len
decl_stmt|;
operator|--
name|exp_p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|limit
operator|&&
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
name|id_len
operator|=
name|p
operator|-
name|id_beg
expr_stmt|;
if|if
condition|(
name|is_idstart
index|[
name|c
index|]
operator|&&
operator|!
operator|(
name|id_len
operator|==
literal|1
operator|&&
name|c
operator|==
literal|'L'
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'\''
operator|||
operator|*
name|p
operator|==
literal|'"'
operator|)
operator|)
condition|)
block|{
specifier|register
name|struct
name|arglist
modifier|*
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|arglist
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|next
control|)
block|{
name|struct
name|reflist
modifier|*
name|tpat
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|c
operator|&&
name|arg
operator|->
name|length
operator|==
name|id_len
operator|&&
name|strncmp
argument_list|(
name|arg
operator|->
name|name
argument_list|,
name|id_beg
argument_list|,
name|id_len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|expected_delimiter
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|warn_stringify
condition|)
block|{
if|if
condition|(
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"macro argument `%.*s' is stringified."
argument_list|,
name|id_len
argument_list|,
name|arg
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"macro arg `%.*s' would be stringified with -traditional."
argument_list|,
name|id_len
argument_list|,
name|arg
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If ANSI, don't actually substitute 			 inside a string.  */
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|&&
name|expected_delimiter
condition|)
break|break;
comment|/* make a pat node for this arg and append it 			 to the end of the pat list */
name|tpat
operator|=
operator|(
expr|struct
name|reflist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|reflist
argument_list|)
argument_list|)
expr_stmt|;
name|tpat
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|tpat
operator|->
name|raw_before
operator|=
name|concat
operator|==
name|id_beg
expr_stmt|;
name|tpat
operator|->
name|raw_after
operator|=
literal|0
expr_stmt|;
name|tpat
operator|->
name|rest_args
operator|=
name|arg
operator|->
name|rest_args
expr_stmt|;
name|tpat
operator|->
name|stringify
operator|=
operator|(
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|?
name|expected_delimiter
operator|!=
literal|'\0'
else|:
name|stringify
operator|==
name|id_beg
operator|)
expr_stmt|;
if|if
condition|(
name|endpat
operator|==
name|NULL
condition|)
name|defn
operator|->
name|pattern
operator|=
name|tpat
expr_stmt|;
else|else
name|endpat
operator|->
name|next
operator|=
name|tpat
expr_stmt|;
name|endpat
operator|=
name|tpat
expr_stmt|;
name|tpat
operator|->
name|argno
operator|=
name|arg
operator|->
name|argno
expr_stmt|;
name|tpat
operator|->
name|nchars
operator|=
name|exp_p
operator|-
name|lastp
expr_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|p1
init|=
name|p
decl_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|+
literal|2
operator|<=
name|limit
operator|&&
name|p1
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|p1
index|[
literal|1
index|]
operator|==
literal|'#'
condition|)
name|tpat
operator|->
name|raw_after
operator|=
literal|1
expr_stmt|;
block|}
name|lastp
operator|=
name|exp_p
expr_stmt|;
name|skipped_arg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If this was not a macro arg, copy it into the expansion.  */
if|if
condition|(
operator|!
name|skipped_arg
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|lim1
init|=
name|p
decl_stmt|;
name|p
operator|=
name|id_beg
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|lim1
condition|)
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|stringify
operator|==
name|id_beg
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`#' operator should be followed by a macro argument name"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|&&
name|expected_delimiter
operator|==
literal|0
condition|)
block|{
comment|/* If ANSI, put in a "\r " marker to prevent token pasting.          But not if "inside a string" (which in ANSI mode          happens only for -D option).  */
operator|*
name|exp_p
operator|++
operator|=
literal|'\r'
expr_stmt|;
operator|*
name|exp_p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|exp_p
operator|=
literal|'\0'
expr_stmt|;
name|defn
operator|->
name|length
operator|=
name|exp_p
operator|-
name|defn
operator|->
name|expansion
expr_stmt|;
comment|/* Crash now if we overrun the allocated size.  */
if|if
condition|(
name|defn
operator|->
name|length
operator|+
literal|1
operator|>
name|maxsize
condition|)
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This isn't worth the time it takes.  */
comment|/* give back excess storage */
block|defn->expansion = (U_CHAR *) xrealloc (defn->expansion, defn->length + 1);
endif|#
directive|endif
return|return
name|defn
return|;
block|}
end_block

begin_comment
comment|/*  * special extension string that can be added to the last macro argument to   * allow it to absorb the "rest" of the arguments when expanded.  Ex:  * 		#define wow(a, b...)		process (b, a, b)  *		{ wow (1, 2, 3); }	->	{ process (2, 3, 1, 2, 3); }  *		{ wow (one, two); }	->	{ process (two, one, two); }  * if this "rest_arg" is used with the concat token '##' and if it is not  * supplied then the token attached to with ## will not be outputted.  Ex:  * 		#define wow (a, b...)		process (b ## , a, ## b)  *		{ wow (1, 2); }		->	{ process (2, 1, 2); }  *		{ wow (one); }		->	{ process (one); {  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rest_extension
index|[]
init|=
literal|"..."
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REST_EXTENSION_LENGTH
value|(sizeof (rest_extension) - 1)
end_define

begin_comment
comment|/* Create a DEFINITION node from a #define directive.  Arguments are     as for do_define.  */
end_comment

begin_function
name|MACRODEF
name|create_definition
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|pfile
parameter_list|,
name|predefinition
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|predefinition
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
comment|/* temp ptr into input buffer */
name|U_CHAR
modifier|*
name|symname
decl_stmt|;
comment|/* remember where symbol name starts */
name|int
name|sym_length
decl_stmt|;
comment|/* and how long it is */
name|int
name|rest_args
init|=
literal|0
decl_stmt|;
name|long
name|line
decl_stmt|,
name|col
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|?
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|nominal_fname
else|:
literal|""
decl_stmt|;
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
name|int
name|arglengths
init|=
literal|0
decl_stmt|;
comment|/* Accumulate lengths of arg names 				   plus number of args.  */
name|MACRODEF
name|mdef
decl_stmt|;
name|cpp_buf_line_and_col
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
name|symname
operator|=
name|bp
expr_stmt|;
comment|/* remember where it starts */
name|sym_length
operator|=
name|check_macro_name
argument_list|(
name|pfile
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|sym_length
expr_stmt|;
comment|/* Lossage will occur if identifiers or control keywords are broken      across lines using backslash.  This is not the right place to take      care of that.  */
if|if
condition|(
operator|*
name|bp
operator|==
literal|'('
condition|)
block|{
name|struct
name|arglist
modifier|*
name|arg_ptrs
init|=
name|NULL
decl_stmt|;
name|int
name|argno
init|=
literal|0
decl_stmt|;
name|bp
operator|++
expr_stmt|;
comment|/* skip '(' */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Loop over macro argument names.  */
while|while
condition|(
operator|*
name|bp
operator|!=
literal|')'
condition|)
block|{
name|struct
name|arglist
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
expr|struct
name|arglist
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|bp
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|arg_ptrs
expr_stmt|;
name|temp
operator|->
name|argno
operator|=
name|argno
operator|++
expr_stmt|;
name|temp
operator|->
name|rest_args
operator|=
literal|0
expr_stmt|;
name|arg_ptrs
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|rest_args
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"another parameter follows `%s'"
argument_list|,
name|rest_extension
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|bp
index|]
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"invalid character in macro parameter name"
argument_list|)
expr_stmt|;
comment|/* Find the end of the arg name.  */
while|while
condition|(
name|is_idchar
index|[
operator|*
name|bp
index|]
condition|)
block|{
name|bp
operator|++
expr_stmt|;
comment|/* do we have a "special" rest-args extension here? */
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|limit
operator|-
name|bp
argument_list|)
operator|>
name|REST_EXTENSION_LENGTH
operator|&&
operator|!
name|strncmp
argument_list|(
name|rest_extension
argument_list|,
name|bp
argument_list|,
name|REST_EXTENSION_LENGTH
argument_list|)
condition|)
block|{
name|rest_args
operator|=
literal|1
expr_stmt|;
name|temp
operator|->
name|rest_args
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|temp
operator|->
name|length
operator|=
name|bp
operator|-
name|temp
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|rest_args
operator|==
literal|1
condition|)
name|bp
operator|+=
name|REST_EXTENSION_LENGTH
expr_stmt|;
name|arglengths
operator|+=
name|temp
operator|->
name|length
operator|+
literal|2
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|length
operator|==
literal|0
operator|||
operator|(
operator|*
name|bp
operator|!=
literal|','
operator|&&
operator|*
name|bp
operator|!=
literal|')'
operator|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"badly punctuated parameter list in `#define'"
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|','
condition|)
block|{
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|>=
name|limit
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"unterminated parameter list in `#define'"
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
block|{
name|struct
name|arglist
modifier|*
name|otemp
decl_stmt|;
for|for
control|(
name|otemp
operator|=
name|temp
operator|->
name|next
init|;
name|otemp
operator|!=
name|NULL
condition|;
name|otemp
operator|=
name|otemp
operator|->
name|next
control|)
if|if
condition|(
name|temp
operator|->
name|length
operator|==
name|otemp
operator|->
name|length
operator|&&
name|strncmp
argument_list|(
name|temp
operator|->
name|name
argument_list|,
name|otemp
operator|->
name|name
argument_list|,
name|temp
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|temp
operator|->
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|name
argument_list|,
name|temp
operator|->
name|name
argument_list|,
name|temp
operator|->
name|length
argument_list|)
expr_stmt|;
name|name
index|[
name|temp
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"duplicate argument name `%s' in `#define'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
block|}
block|}
operator|++
name|bp
expr_stmt|;
comment|/* skip paren */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* now everything from bp before limit is the definition.  */
name|defn
operator|=
name|collect_expansion
argument_list|(
name|pfile
argument_list|,
name|bp
argument_list|,
name|limit
argument_list|,
name|argno
argument_list|,
name|arg_ptrs
argument_list|)
expr_stmt|;
name|defn
operator|->
name|rest_args
operator|=
name|rest_args
expr_stmt|;
comment|/* Now set defn->args.argnames to the result of concatenating          the argument names in reverse order          with comma-space between them.  */
name|defn
operator|->
name|args
operator|.
name|argnames
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|arglengths
operator|+
literal|1
argument_list|)
expr_stmt|;
block|{
name|struct
name|arglist
modifier|*
name|temp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|arg_ptrs
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
block|{
name|bcopy
argument_list|(
name|temp
operator|->
name|name
argument_list|,
operator|&
name|defn
operator|->
name|args
operator|.
name|argnames
index|[
name|i
index|]
argument_list|,
name|temp
operator|->
name|length
argument_list|)
expr_stmt|;
name|i
operator|+=
name|temp
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|next
operator|!=
literal|0
condition|)
block|{
name|defn
operator|->
name|args
operator|.
name|argnames
index|[
name|i
operator|++
index|]
operator|=
literal|','
expr_stmt|;
name|defn
operator|->
name|args
operator|.
name|argnames
index|[
name|i
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
name|defn
operator|->
name|args
operator|.
name|argnames
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Simple expansion or empty definition.  */
if|if
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
block|{
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Per C9x, missing white space after the name in a #define 	       of an object-like macro is always a constraint violation. */
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"missing white space after `#define %.*s'"
argument_list|,
name|sym_length
argument_list|,
name|symname
argument_list|)
expr_stmt|;
block|}
comment|/* now everything from bp before limit is the definition.  */
name|defn
operator|=
name|collect_expansion
argument_list|(
name|pfile
argument_list|,
name|bp
argument_list|,
name|limit
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|defn
operator|->
name|args
operator|.
name|argnames
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
literal|""
expr_stmt|;
block|}
name|defn
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|defn
operator|->
name|file
operator|=
name|file
expr_stmt|;
comment|/* OP is null if this is a predefinition */
name|defn
operator|->
name|predefined
operator|=
name|predefinition
expr_stmt|;
name|mdef
operator|.
name|defn
operator|=
name|defn
expr_stmt|;
name|mdef
operator|.
name|symnam
operator|=
name|symname
expr_stmt|;
name|mdef
operator|.
name|symlen
operator|=
name|sym_length
expr_stmt|;
return|return
name|mdef
return|;
name|nope
label|:
name|mdef
operator|.
name|defn
operator|=
literal|0
expr_stmt|;
return|return
name|mdef
return|;
block|}
end_block

begin_comment
comment|/*  * Parse a macro argument and append the info on PFILE's token_buffer.  * REST_ARGS means to absorb the rest of the args.  * Return nonzero to indicate a syntax error.  */
end_comment

begin_function
specifier|static
name|enum
name|cpp_token
name|macarg
parameter_list|(
name|pfile
parameter_list|,
name|rest_args
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|rest_args
decl_stmt|;
block|{
name|int
name|paren
init|=
literal|0
decl_stmt|;
name|enum
name|cpp_token
name|token
decl_stmt|;
name|char
name|save_put_out_comments
init|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|put_out_comments
decl_stmt|;
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|put_out_comments
operator|=
literal|0
expr_stmt|;
comment|/* Try to parse as much of the argument as exists at this      input stack level.  */
name|pfile
operator|->
name|no_macro_expand
operator|++
expr_stmt|;
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|no_line_commands
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|CPP_EOF
case|:
goto|goto
name|done
goto|;
case|case
name|CPP_POP
case|:
comment|/* If we've hit end of file, it's an error (reported by caller). 	     Ditto if it's the end of cpp_expand_to_buffer text. 	     If we've hit end of macro, just continue.  */
if|if
condition|(
operator|!
name|CPP_IS_MACRO_BUFFER
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|)
condition|)
goto|goto
name|done
goto|;
break|break;
case|case
name|CPP_LPAREN
case|:
name|paren
operator|++
expr_stmt|;
break|break;
case|case
name|CPP_RPAREN
case|:
if|if
condition|(
operator|--
name|paren
operator|<
literal|0
condition|)
goto|goto
name|found
goto|;
break|break;
case|case
name|CPP_COMMA
case|:
comment|/* if we've returned to lowest level and 	     we aren't absorbing all args */
if|if
condition|(
name|paren
operator|==
literal|0
operator|&&
name|rest_args
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
break|break;
name|found
label|:
comment|/* Remove ',' or ')' from argument buffer.  */
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
default|default:
empty_stmt|;
block|}
block|}
name|done
label|:
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|put_out_comments
operator|=
name|save_put_out_comments
expr_stmt|;
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|no_line_commands
operator|--
expr_stmt|;
name|pfile
operator|->
name|no_macro_expand
operator|--
expr_stmt|;
return|return
name|token
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Turn newlines to spaces in the string of length LENGTH at START,    except inside of string constants.    The string is copied into itself with its beginning staying fixed.  */
end_comment

begin_function
specifier|static
name|int
name|change_newlines
parameter_list|(
name|start
parameter_list|,
name|length
parameter_list|)
name|U_CHAR
modifier|*
name|start
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|ibp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|obp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|ibp
operator|=
name|start
expr_stmt|;
name|limit
operator|=
name|start
operator|+
name|length
expr_stmt|;
name|obp
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
comment|/* Notice and skip strings, so that we don't 	     delete newlines in them.  */
block|{
name|int
name|quotec
init|=
name|c
decl_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quotec
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|quotec
operator|==
literal|'\''
condition|)
break|break;
block|}
block|}
break|break;
block|}
block|}
return|return
name|obp
operator|-
name|start
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|tm
modifier|*
name|timestamp
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|pfile
operator|->
name|timebuf
condition|)
block|{
name|time_t
name|t
init|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
name|pfile
operator|->
name|timebuf
operator|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|pfile
operator|->
name|timebuf
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|monthnames
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * expand things like __FILE__.  Place the expansion into the output  * buffer *without* rescanning.  */
end_comment

begin_function
specifier|static
name|void
name|special_symbol
parameter_list|(
name|hp
parameter_list|,
name|pfile
parameter_list|)
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|cpp_buffer
modifier|*
name|ip
decl_stmt|;
switch|switch
condition|(
name|hp
operator|->
name|type
condition|)
block|{
case|case
name|T_FILE
case|:
case|case
name|T_BASE_FILE
case|:
block|{
name|ip
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_BASE_FILE
condition|)
block|{
while|while
condition|(
name|CPP_PREV_BUFFER
argument_list|(
name|ip
argument_list|)
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
name|ip
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ip
operator|->
name|nominal_fname
operator|&&
name|ip
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
name|ip
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
name|ip
operator|->
name|nominal_fname
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|buf
operator|=
literal|""
expr_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|3
operator|+
literal|4
operator|*
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|quote_string
argument_list|(
name|pfile
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|T_INCLUDE_LEVEL
case|:
block|{
name|int
name|true_indepth
init|=
literal|0
decl_stmt|;
name|ip
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ip
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|;
name|ip
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|ip
argument_list|)
control|)
if|if
condition|(
name|ip
operator|->
name|fname
operator|!=
name|NULL
condition|)
name|true_indepth
operator|++
expr_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|true_indepth
argument_list|)
expr_stmt|;
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|strlen
argument_list|(
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|T_VERSION
case|:
name|len
operator|=
name|strlen
argument_list|(
name|version_string
argument_list|)
expr_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|3
operator|+
name|len
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
name|version_string
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|CPP_NUL_TERMINATE_Q
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_CONST
case|:
name|buf
operator|=
name|hp
operator|->
name|value
operator|.
name|cpval
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\0'
condition|)
name|buf
operator|=
literal|"\r "
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|CPP_NUL_TERMINATE_Q
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_STDC
case|:
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STDC_0_IN_SYSTEM_HEADERS
name|ip
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ip
operator|->
name|nominal_fname
operator|&&
name|ip
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
name|ip
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|system_header_p
operator|&&
operator|!
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__STRICT_ANSI__"
argument_list|,
literal|15
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'1'
argument_list|)
expr_stmt|;
name|CPP_NUL_TERMINATE_Q
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_SPECLINE
case|:
block|{
name|long
name|line
decl_stmt|;
name|cpp_buf_line_and_col
argument_list|(
name|cpp_file_buffer
argument_list|(
name|pfile
argument_list|)
argument_list|,
operator|&
name|line
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
argument_list|,
literal|"%ld"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|strlen
argument_list|(
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|T_DATE
case|:
case|case
name|T_TIME
case|:
block|{
name|struct
name|tm
modifier|*
name|timebuf
decl_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|timebuf
operator|=
name|timestamp
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_DATE
condition|)
name|sprintf
argument_list|(
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
argument_list|,
literal|"\"%s %2d %4d\""
argument_list|,
name|monthnames
index|[
name|timebuf
operator|->
name|tm_mon
index|]
argument_list|,
name|timebuf
operator|->
name|tm_mday
argument_list|,
name|timebuf
operator|->
name|tm_year
operator|+
literal|1900
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
argument_list|,
literal|"\"%02d:%02d:%02d\""
argument_list|,
name|timebuf
operator|->
name|tm_hour
argument_list|,
name|timebuf
operator|->
name|tm_min
argument_list|,
name|timebuf
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|strlen
argument_list|(
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"cpplib internal error: invalid special hash type"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Expand a macro call.    HP points to the symbol that is the macro being called.    Put the result of expansion onto the input stack    so that subsequent input by our caller will use it.     If macro wants arguments, caller has already verified that    an argument list follows; arguments come from the input stack.  */
end_comment

begin_function
name|void
name|macroexpand
parameter_list|(
name|pfile
parameter_list|,
name|hp
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
block|{
name|int
name|nargs
decl_stmt|;
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|xbuf
decl_stmt|;
name|long
name|start_line
decl_stmt|,
name|start_column
decl_stmt|;
name|int
name|xbuf_len
decl_stmt|;
name|struct
name|argdata
modifier|*
name|args
decl_stmt|;
name|long
name|old_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
block|int start_line = instack[indepth].lineno;
endif|#
directive|endif
name|int
name|rest_args
decl_stmt|,
name|rest_zero
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|#
directive|if
literal|0
comment|/* This macro is being used inside a #if, which means it must be */
comment|/* recorded as a precondition.  */
block|if (pcp_inside_if&& pcp_outfile&& defn->predefined)     dump_single_macro (hp, pcp_outfile);
endif|#
directive|endif
name|cpp_buf_line_and_col
argument_list|(
name|cpp_file_buffer
argument_list|(
name|pfile
argument_list|)
argument_list|,
operator|&
name|start_line
argument_list|,
operator|&
name|start_column
argument_list|)
expr_stmt|;
comment|/* Check for and handle special symbols. */
if|if
condition|(
name|hp
operator|->
name|type
operator|!=
name|T_MACRO
condition|)
block|{
name|special_symbol
argument_list|(
name|hp
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
name|xbuf_len
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
name|old_written
expr_stmt|;
name|xbuf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|xbuf_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
argument_list|,
name|xbuf
argument_list|,
name|xbuf_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|push_macro_expansion
argument_list|(
name|pfile
argument_list|,
name|xbuf
argument_list|,
name|xbuf_len
argument_list|,
name|hp
argument_list|)
expr_stmt|;
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|has_escapes
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|defn
operator|=
name|hp
operator|->
name|value
operator|.
name|defn
expr_stmt|;
name|nargs
operator|=
name|defn
operator|->
name|nargs
expr_stmt|;
name|pfile
operator|->
name|output_escapes
operator|++
expr_stmt|;
if|if
condition|(
name|nargs
operator|>=
literal|0
condition|)
block|{
name|enum
name|cpp_token
name|token
init|=
name|CPP_EOF
decl_stmt|;
name|args
operator|=
operator|(
expr|struct
name|argdata
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|nargs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|argdata
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|args
index|[
name|i
index|]
operator|.
name|raw
operator|=
name|args
index|[
name|i
index|]
operator|.
name|expanded
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|raw_length
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|expand_length
operator|=
name|args
index|[
name|i
index|]
operator|.
name|stringified_length
operator|=
operator|-
literal|1
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|use_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Parse all the macro args that are supplied.  I counts them.          The first NARGS args are stored in ARGS.          The rest are discarded.  If rest_args is set then we assume          macarg absorbed the rest of the args.  */
name|i
operator|=
literal|0
expr_stmt|;
name|rest_args
operator|=
literal|0
expr_stmt|;
name|rest_args
operator|=
literal|0
expr_stmt|;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Discard open-parenthesis before first arg.  */
do|do
block|{
if|if
condition|(
name|rest_args
condition|)
continue|continue;
if|if
condition|(
name|i
operator|<
name|nargs
operator|||
operator|(
name|nargs
operator|==
literal|0
operator|&&
name|i
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* if we are working on last arg which absorbs rest of args... */
if|if
condition|(
name|i
operator|==
name|nargs
operator|-
literal|1
operator|&&
name|defn
operator|->
name|rest_args
condition|)
name|rest_args
operator|=
literal|1
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|raw
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|macarg
argument_list|(
name|pfile
argument_list|,
name|rest_args
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|raw_length
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
name|args
index|[
name|i
index|]
operator|.
name|raw
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|newlines
operator|=
literal|0
expr_stmt|;
comment|/* FIXME */
block|}
else|else
name|token
operator|=
name|macarg
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_EOF
operator|||
name|token
operator|==
name|CPP_POP
condition|)
block|{
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|start_line
argument_list|,
name|start_column
argument_list|,
literal|"unterminated macro call"
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
name|CPP_COMMA
condition|)
do|;
comment|/* If we got one arg but it was just whitespace, call that 0 args.  */
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
init|=
name|ARG_BASE
operator|+
name|args
index|[
literal|0
index|]
operator|.
name|raw
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|lim
init|=
name|bp
operator|+
name|args
index|[
literal|0
index|]
operator|.
name|raw_length
decl_stmt|;
comment|/* cpp.texi says for foo ( ) we provide one argument. 	     However, if foo wants just 0 arguments, treat this as 0.  */
if|if
condition|(
name|nargs
operator|==
literal|0
condition|)
while|while
condition|(
name|bp
operator|!=
name|lim
operator|&&
name|is_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|lim
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Don't output an error message if we have already output one for          a parse error above.  */
name|rest_zero
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nargs
operator|==
literal|0
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"arguments given to macro `%s'"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
name|nargs
condition|)
block|{
comment|/* traditional C allows foo() if foo wants one argument.  */
if|if
condition|(
name|nargs
operator|==
literal|1
operator|&&
name|i
operator|==
literal|0
operator|&&
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
empty_stmt|;
comment|/* the rest args token is allowed to absorb 0 tokens */
elseif|else
if|if
condition|(
name|i
operator|==
name|nargs
operator|-
literal|1
operator|&&
name|defn
operator|->
name|rest_args
condition|)
name|rest_zero
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"macro `%s' used without args"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"macro `%s' used with just one arg"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"macro `%s' used with only %d args"
argument_list|,
name|hp
operator|->
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
name|nargs
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"macro `%s' used with too many (%d) args"
argument_list|,
name|hp
operator|->
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If macro wants zero args, we parsed the arglist for checking only.      Read directly from the macro definition.  */
if|if
condition|(
name|nargs
operator|<=
literal|0
condition|)
block|{
name|xbuf
operator|=
name|defn
operator|->
name|expansion
expr_stmt|;
name|xbuf_len
operator|=
name|defn
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|U_CHAR
modifier|*
name|exp
init|=
name|defn
operator|->
name|expansion
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|;
comment|/* offset in expansion, 				   copied a piece at a time */
specifier|register
name|int
name|totlen
decl_stmt|;
comment|/* total amount of exp buffer filled so far */
specifier|register
name|struct
name|reflist
modifier|*
name|ap
decl_stmt|,
modifier|*
name|last_ap
decl_stmt|;
comment|/* Macro really takes args.  Compute the expansion of this call.  */
comment|/* Compute length in characters of the macro's expansion.          Also count number of times each arg is used.  */
name|xbuf_len
operator|=
name|defn
operator|->
name|length
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|defn
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|stringify
condition|)
block|{
specifier|register
name|struct
name|argdata
modifier|*
name|arg
init|=
operator|&
name|args
index|[
name|ap
operator|->
name|argno
index|]
decl_stmt|;
comment|/* Stringify if it hasn't already been */
if|if
condition|(
name|arg
operator|->
name|stringified_length
operator|<
literal|0
condition|)
block|{
name|int
name|arglen
init|=
name|arg
operator|->
name|raw_length
decl_stmt|;
name|int
name|escaped
init|=
literal|0
decl_stmt|;
name|int
name|in_string
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* Initially need_space is -1.  Otherwise, 1 means the 		     previous character was a space, but we suppressed it; 		     0 means the previous character was a non-space.  */
name|int
name|need_space
init|=
operator|-
literal|1
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|arg
operator|->
name|stringified
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
comment|/* insert beginning quote */
for|for
control|(
init|;
name|i
operator|<
name|arglen
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|(
name|ARG_BASE
operator|+
name|arg
operator|->
name|raw
operator|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|in_string
condition|)
block|{
comment|/* Internal sequences of whitespace are 			     replaced by one space except within 			     a string or char token. */
if|if
condition|(
name|is_space
index|[
name|c
index|]
condition|)
block|{
if|if
condition|(
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
operator|>
operator|(
name|unsigned
operator|)
name|arg
operator|->
name|stringified
operator|&&
operator|(
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
operator|)
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
block|{
comment|/* "\r " escape markers are removed */
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|need_space
operator|==
literal|0
condition|)
name|need_space
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|need_space
operator|>
literal|0
condition|)
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|need_space
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|escaped
condition|)
name|escaped
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|escaped
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|in_string
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|in_string
condition|)
name|in_string
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\''
condition|)
name|in_string
operator|=
name|c
expr_stmt|;
block|}
comment|/* Escape these chars */
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
operator|(
name|in_string
operator|&&
name|c
operator|==
literal|'\\'
operator|)
condition|)
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
comment|/* insert ending quote */
name|arg
operator|->
name|stringified_length
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
name|arg
operator|->
name|stringified
expr_stmt|;
block|}
name|xbuf_len
operator|+=
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|stringified_length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|raw_before
operator|||
name|ap
operator|->
name|raw_after
operator|||
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
comment|/* Add 4 for two newline-space markers to prevent 	       token concatenation.  */
name|xbuf_len
operator|+=
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|raw_length
operator|+
literal|4
expr_stmt|;
else|else
block|{
comment|/* We have an ordinary (expanded) occurrence of the arg. 	         So compute its expansion, if we have not already.  */
if|if
condition|(
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|expand_length
operator|<
literal|0
condition|)
block|{
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|expanded
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|cpp_expand_to_buffer
argument_list|(
name|pfile
argument_list|,
name|ARG_BASE
operator|+
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|raw
argument_list|,
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|raw_length
argument_list|)
expr_stmt|;
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|expand_length
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|expanded
expr_stmt|;
block|}
comment|/* Add 4 for two newline-space markers to prevent 	         token concatenation.  */
name|xbuf_len
operator|+=
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|expand_length
operator|+
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|use_count
operator|<
literal|10
condition|)
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|use_count
operator|++
expr_stmt|;
block|}
name|xbuf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|xbuf_len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Generate in XBUF the complete expansion          with arguments substituted in.          TOTLEN is the total size generated so far.          OFFSET is the index in the definition          of where we are copying from.  */
name|offset
operator|=
name|totlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|last_ap
operator|=
name|NULL
operator|,
name|ap
operator|=
name|defn
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|last_ap
operator|=
name|ap
operator|,
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
specifier|register
name|struct
name|argdata
modifier|*
name|arg
init|=
operator|&
name|args
index|[
name|ap
operator|->
name|argno
index|]
decl_stmt|;
name|int
name|count_before
init|=
name|totlen
decl_stmt|;
comment|/* Add chars to XBUF.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ap
operator|->
name|nchars
condition|;
name|i
operator|++
operator|,
name|offset
operator|++
control|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
name|exp
index|[
name|offset
index|]
expr_stmt|;
comment|/* If followed by an empty rest arg with concatenation, 	     delete the last run of nonwhite chars.  */
if|if
condition|(
name|rest_zero
operator|&&
name|totlen
operator|>
name|count_before
operator|&&
operator|(
operator|(
name|ap
operator|->
name|rest_args
operator|&&
name|ap
operator|->
name|raw_before
operator|)
operator|||
operator|(
name|last_ap
operator|!=
name|NULL
operator|&&
name|last_ap
operator|->
name|rest_args
operator|&&
name|last_ap
operator|->
name|raw_after
operator|)
operator|)
condition|)
block|{
comment|/* Delete final whitespace.  */
while|while
condition|(
name|totlen
operator|>
name|count_before
operator|&&
name|is_space
index|[
name|xbuf
index|[
name|totlen
operator|-
literal|1
index|]
index|]
condition|)
name|totlen
operator|--
expr_stmt|;
comment|/* Delete the nonwhites before them.  */
while|while
condition|(
name|totlen
operator|>
name|count_before
operator|&&
operator|!
name|is_space
index|[
name|xbuf
index|[
name|totlen
operator|-
literal|1
index|]
index|]
condition|)
name|totlen
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|stringify
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|ARG_BASE
operator|+
name|arg
operator|->
name|stringified
argument_list|,
name|xbuf
operator|+
name|totlen
argument_list|,
name|arg
operator|->
name|stringified_length
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|arg
operator|->
name|stringified_length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|raw_before
operator|||
name|ap
operator|->
name|raw_after
operator|||
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|U_CHAR
modifier|*
name|p1
init|=
name|ARG_BASE
operator|+
name|arg
operator|->
name|raw
decl_stmt|;
name|U_CHAR
modifier|*
name|l1
init|=
name|p1
operator|+
name|arg
operator|->
name|raw_length
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|raw_before
condition|)
block|{
while|while
condition|(
name|p1
operator|!=
name|l1
operator|&&
name|is_space
index|[
operator|*
name|p1
index|]
condition|)
name|p1
operator|++
expr_stmt|;
while|while
condition|(
name|p1
operator|!=
name|l1
operator|&&
name|is_idchar
index|[
operator|*
name|p1
index|]
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|raw_after
condition|)
block|{
comment|/* Arg is concatenated after: delete trailing whitespace, 		     whitespace markers, and no-reexpansion markers.  */
while|while
condition|(
name|p1
operator|!=
name|l1
condition|)
block|{
if|if
condition|(
name|is_space
index|[
name|l1
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|l1
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|l1
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|l1
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|l1
index|[
operator|-
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|l1
operator|!=
name|p1
operator|+
literal|1
operator|&&
name|l1
index|[
operator|-
literal|2
index|]
operator|==
literal|'\r'
condition|)
name|l1
operator|-=
literal|2
expr_stmt|;
else|else
break|break;
block|}
else|else
break|break;
block|}
block|}
comment|/* Delete any no-reexpansion marker that precedes 	         an identifier at the beginning of the argument. */
if|if
condition|(
name|p1
index|[
literal|0
index|]
operator|==
literal|'\r'
operator|&&
name|p1
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
name|p1
operator|+=
literal|2
expr_stmt|;
name|bcopy
argument_list|(
name|p1
argument_list|,
name|xbuf
operator|+
name|totlen
argument_list|,
name|l1
operator|-
name|p1
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|l1
operator|-
name|p1
expr_stmt|;
block|}
else|else
block|{
name|U_CHAR
modifier|*
name|expanded
init|=
name|ARG_BASE
operator|+
name|arg
operator|->
name|expanded
decl_stmt|;
if|if
condition|(
operator|!
name|ap
operator|->
name|raw_before
operator|&&
name|totlen
operator|>
literal|0
operator|&&
name|arg
operator|->
name|expand_length
operator|&&
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|&&
name|unsafe_chars
argument_list|(
name|xbuf
index|[
name|totlen
operator|-
literal|1
index|]
argument_list|,
name|expanded
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|expanded
argument_list|,
name|xbuf
operator|+
name|totlen
argument_list|,
name|arg
operator|->
name|expand_length
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|arg
operator|->
name|expand_length
expr_stmt|;
if|if
condition|(
operator|!
name|ap
operator|->
name|raw_after
operator|&&
name|totlen
operator|>
literal|0
operator|&&
name|offset
operator|<
name|defn
operator|->
name|length
operator|&&
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|&&
name|unsafe_chars
argument_list|(
name|xbuf
index|[
name|totlen
operator|-
literal|1
index|]
argument_list|,
name|exp
index|[
name|offset
index|]
argument_list|)
condition|)
block|{
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
comment|/* If a macro argument with newlines is used multiple times, 	         then only expand the newlines once.  This avoids creating 	         output lines which don't correspond to any input line, 	         which confuses gdb and gcov.  */
if|if
condition|(
name|arg
operator|->
name|use_count
operator|>
literal|1
operator|&&
name|arg
operator|->
name|newlines
operator|>
literal|0
condition|)
block|{
comment|/* Don't bother doing change_newlines for subsequent 		     uses of arg.  */
name|arg
operator|->
name|use_count
operator|=
literal|1
expr_stmt|;
name|arg
operator|->
name|expand_length
operator|=
name|change_newlines
argument_list|(
name|expanded
argument_list|,
name|arg
operator|->
name|expand_length
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|totlen
operator|>
name|xbuf_len
condition|)
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"internal_error: buffer overrun in macroexpand"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* if there is anything left of the definition          after handling the arg list, copy that in too.  */
for|for
control|(
name|i
operator|=
name|offset
init|;
name|i
operator|<
name|defn
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|/* if we've reached the end of the macro */
if|if
condition|(
name|exp
index|[
name|i
index|]
operator|==
literal|')'
condition|)
name|rest_zero
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rest_zero
operator|&&
name|last_ap
operator|!=
name|NULL
operator|&&
name|last_ap
operator|->
name|rest_args
operator|&&
name|last_ap
operator|->
name|raw_after
operator|)
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
name|exp
index|[
name|i
index|]
expr_stmt|;
block|}
name|xbuf
index|[
name|totlen
index|]
operator|=
literal|0
expr_stmt|;
name|xbuf_len
operator|=
name|totlen
expr_stmt|;
block|}
name|pfile
operator|->
name|output_escapes
operator|--
expr_stmt|;
comment|/* Now put the expansion on the input stack      so our caller will commence reading from it.  */
name|push_macro_expansion
argument_list|(
name|pfile
argument_list|,
name|xbuf
argument_list|,
name|xbuf_len
argument_list|,
name|hp
argument_list|)
expr_stmt|;
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|has_escapes
operator|=
literal|1
expr_stmt|;
comment|/* Pop the space we've used in the token_buffer for argument expansion.  */
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
comment|/* Recursive macro use sometimes works traditionally.      #define foo(x,y) bar (x (y,0), y)      foo (foo, baz)  */
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|hp
operator|->
name|type
operator|=
name|T_DISABLED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 iff a token ending in C1 followed directly by a token C2    could cause mis-tokenization.  */
end_comment

begin_function
specifier|static
name|int
name|unsafe_chars
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
block|{
switch|switch
condition|(
name|c1
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
if|if
condition|(
name|c2
operator|==
name|c1
operator|||
name|c2
operator|==
literal|'='
condition|)
return|return
literal|1
return|;
goto|goto
name|letter
goto|;
case|case
literal|'.'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
if|if
condition|(
name|c2
operator|==
literal|'-'
operator|||
name|c2
operator|==
literal|'+'
condition|)
return|return
literal|1
return|;
comment|/* could extend a pre-processing number */
goto|goto
name|letter
goto|;
case|case
literal|'L'
case|:
if|if
condition|(
name|c2
operator|==
literal|'\''
operator|||
name|c2
operator|==
literal|'\"'
condition|)
return|return
literal|1
return|;
comment|/* Could turn into L"xxx" or L'xxx'.  */
goto|goto
name|letter
goto|;
case|case
literal|'_'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
name|letter
label|:
comment|/* We're in the middle of either a name or a pre-processing number.  */
return|return
operator|(
name|is_idchar
index|[
name|c2
index|]
operator|||
name|c2
operator|==
literal|'.'
operator|)
return|;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'!'
case|:
case|case
literal|'%'
case|:
case|case
literal|'#'
case|:
case|case
literal|':'
case|:
case|case
literal|'^'
case|:
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
case|case
literal|'='
case|:
return|return
operator|(
name|c2
operator|==
name|c1
operator|||
name|c2
operator|==
literal|'='
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|push_macro_expansion
parameter_list|(
name|pfile
parameter_list|,
name|xbuf
parameter_list|,
name|xbuf_len
parameter_list|,
name|hp
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|xbuf
decl_stmt|;
name|int
name|xbuf_len
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
block|{
specifier|register
name|cpp_buffer
modifier|*
name|mbuf
init|=
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|xbuf
argument_list|,
name|xbuf_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|mbuf
operator|==
name|NULL
condition|)
return|return;
name|mbuf
operator|->
name|cleanup
operator|=
name|macro_cleanup
expr_stmt|;
name|mbuf
operator|->
name|data
operator|=
name|hp
expr_stmt|;
comment|/* The first chars of the expansion should be a "\r " added by      collect_expansion.  This is to prevent accidental token-pasting      between the text preceding the macro invocation, and the macro      expansion text.       We would like to avoid adding unneeded spaces (for the sake of      tools that use cpp, such as imake).  In some common cases we can      tell that it is safe to omit the space.       The character before the macro invocation cannot have been an      idchar (or else it would have been pasted with the idchars of      the macro name).  Therefore, if the first non-space character      of the expansion is an idchar, we do not need the extra space      to prevent token pasting.       Also, we don't need the extra space if the first char is '(',      or some other (less common) characters.  */
if|if
condition|(
name|xbuf
index|[
literal|0
index|]
operator|==
literal|'\r'
operator|&&
name|xbuf
index|[
literal|1
index|]
operator|==
literal|' '
operator|&&
operator|(
name|is_idchar
index|[
name|xbuf
index|[
literal|2
index|]
index|]
operator|||
name|xbuf
index|[
literal|2
index|]
operator|==
literal|'('
operator|||
name|xbuf
index|[
literal|2
index|]
operator|==
literal|'\''
operator|||
name|xbuf
index|[
literal|2
index|]
operator|==
literal|'\"'
operator|)
condition|)
name|mbuf
operator|->
name|cur
operator|+=
literal|2
expr_stmt|;
comment|/* Likewise, avoid the extra space at the end of the macro expansion      if this is safe.  We can do a better job here since we can know      what the next char will be.  */
if|if
condition|(
name|xbuf_len
operator|>=
literal|3
operator|&&
name|mbuf
operator|->
name|rlimit
index|[
operator|-
literal|2
index|]
operator|==
literal|'\r'
operator|&&
name|mbuf
operator|->
name|rlimit
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
block|{
name|int
name|c1
init|=
name|mbuf
operator|->
name|rlimit
index|[
operator|-
literal|3
index|]
decl_stmt|;
name|int
name|c2
init|=
name|CPP_BUF_PEEK
argument_list|(
name|CPP_PREV_BUFFER
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|c2
operator|==
name|EOF
operator|||
operator|!
name|unsafe_chars
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|)
condition|)
name|mbuf
operator|->
name|rlimit
operator|-=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return zero if two DEFINITIONs are isomorphic.  */
end_comment

begin_function
name|int
name|compare_defs
parameter_list|(
name|pfile
parameter_list|,
name|d1
parameter_list|,
name|d2
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|DEFINITION
modifier|*
name|d1
decl_stmt|,
decl|*
name|d2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|reflist
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p1
init|=
name|d1
operator|->
name|expansion
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p2
init|=
name|d2
operator|->
name|expansion
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|d1
operator|->
name|nargs
operator|!=
name|d2
operator|->
name|nargs
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|d1
operator|->
name|args
operator|.
name|argnames
argument_list|,
operator|(
name|char
operator|*
operator|)
name|d2
operator|->
name|args
operator|.
name|argnames
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|a1
operator|=
name|d1
operator|->
name|pattern
operator|,
name|a2
operator|=
name|d2
operator|->
name|pattern
init|;
name|a1
operator|&&
name|a2
condition|;
name|a1
operator|=
name|a1
operator|->
name|next
operator|,
name|a2
operator|=
name|a2
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|a1
operator|->
name|nchars
operator|==
name|a2
operator|->
name|nchars
operator|&&
operator|!
name|strncmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|a1
operator|->
name|nchars
argument_list|)
operator|)
operator|||
operator|!
name|comp_def_part
argument_list|(
name|first
argument_list|,
name|p1
argument_list|,
name|a1
operator|->
name|nchars
argument_list|,
name|p2
argument_list|,
name|a2
operator|->
name|nchars
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
name|a1
operator|->
name|argno
operator|!=
name|a2
operator|->
name|argno
operator|||
name|a1
operator|->
name|stringify
operator|!=
name|a2
operator|->
name|stringify
operator|||
name|a1
operator|->
name|raw_before
operator|!=
name|a2
operator|->
name|raw_before
operator|||
name|a1
operator|->
name|raw_after
operator|!=
name|a2
operator|->
name|raw_after
condition|)
return|return
literal|1
return|;
name|first
operator|=
literal|0
expr_stmt|;
name|p1
operator|+=
name|a1
operator|->
name|nchars
expr_stmt|;
name|p2
operator|+=
name|a2
operator|->
name|nchars
expr_stmt|;
block|}
if|if
condition|(
name|a1
operator|!=
name|a2
condition|)
return|return
literal|1
return|;
return|return
name|comp_def_part
argument_list|(
name|first
argument_list|,
name|p1
argument_list|,
name|d1
operator|->
name|length
operator|-
operator|(
name|p1
operator|-
name|d1
operator|->
name|expansion
operator|)
argument_list|,
name|p2
argument_list|,
name|d2
operator|->
name|length
operator|-
operator|(
name|p2
operator|-
name|d2
operator|->
name|expansion
operator|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Return 1 if two parts of two macro definitions are effectively different.    One of the parts starts at BEG1 and has LEN1 chars;    the other has LEN2 chars at BEG2.    Any sequence of whitespace matches any other sequence of whitespace.    FIRST means these parts are the first of a macro definition;     so ignore leading whitespace entirely.    LAST means these parts are the last of a macro definition;     so ignore trailing whitespace entirely.  */
end_comment

begin_function
specifier|static
name|int
name|comp_def_part
parameter_list|(
name|first
parameter_list|,
name|beg1
parameter_list|,
name|len1
parameter_list|,
name|beg2
parameter_list|,
name|len2
parameter_list|,
name|last
parameter_list|)
name|int
name|first
decl_stmt|;
name|U_CHAR
modifier|*
name|beg1
decl_stmt|,
decl|*
name|beg2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|last
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|end1
init|=
name|beg1
operator|+
name|len1
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|end2
init|=
name|beg2
operator|+
name|len2
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|is_space
index|[
operator|*
name|beg1
index|]
condition|)
name|beg1
operator|++
expr_stmt|;
while|while
condition|(
name|beg2
operator|!=
name|end2
operator|&&
name|is_space
index|[
operator|*
name|beg2
index|]
condition|)
name|beg2
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|last
condition|)
block|{
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|is_space
index|[
name|end1
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|end1
operator|--
expr_stmt|;
while|while
condition|(
name|beg2
operator|!=
name|end2
operator|&&
name|is_space
index|[
name|end2
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|end2
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|beg2
operator|!=
name|end2
condition|)
block|{
if|if
condition|(
name|is_space
index|[
operator|*
name|beg1
index|]
operator|&&
name|is_space
index|[
operator|*
name|beg2
index|]
condition|)
block|{
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|is_space
index|[
operator|*
name|beg1
index|]
condition|)
name|beg1
operator|++
expr_stmt|;
while|while
condition|(
name|beg2
operator|!=
name|end2
operator|&&
name|is_space
index|[
operator|*
name|beg2
index|]
condition|)
name|beg2
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|beg1
operator|==
operator|*
name|beg2
condition|)
block|{
name|beg1
operator|++
expr_stmt|;
name|beg2
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
operator|(
name|beg1
operator|!=
name|end1
operator|)
operator|||
operator|(
name|beg2
operator|!=
name|end2
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Dump the definition of macro MACRO on stdout.  The format is suitable    to be read back in again. */
end_comment

begin_function
name|void
name|dump_definition
parameter_list|(
name|pfile
parameter_list|,
name|macro
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|MACRODEF
name|macro
decl_stmt|;
block|{
name|DEFINITION
modifier|*
name|defn
init|=
name|macro
operator|.
name|defn
decl_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
name|macro
operator|.
name|symlen
operator|+
sizeof|sizeof
expr|"#define "
argument_list|)
expr_stmt|;
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
literal|"#define "
argument_list|,
sizeof|sizeof
expr|"#define "
operator|-
literal|1
argument_list|)
expr_stmt|;
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
name|macro
operator|.
name|symnam
argument_list|,
name|macro
operator|.
name|symlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|defn
operator|->
name|nargs
operator|==
operator|-
literal|1
condition|)
block|{
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
comment|/* The first and last two characters of a macro expansion are 	 always "\r "; this needs to be trimmed out. 	 So we need length-4 chars of space, plus one for the NUL.  */
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
name|defn
operator|->
name|length
operator|-
literal|4
operator|+
literal|1
argument_list|)
expr_stmt|;
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
name|defn
operator|->
name|expansion
operator|+
literal|2
argument_list|,
name|defn
operator|->
name|length
operator|-
literal|4
argument_list|)
expr_stmt|;
name|CPP_NUL_TERMINATE_Q
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|reflist
modifier|*
name|r
decl_stmt|;
name|unsigned
name|char
modifier|*
name|argnames
init|=
name|xstrdup
argument_list|(
name|defn
operator|->
name|args
operator|.
name|argnames
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|argv
init|=
name|alloca
argument_list|(
name|defn
operator|->
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
modifier|*
name|argl
init|=
name|alloca
argument_list|(
name|defn
operator|->
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|x
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* First extract the argument list. */
name|x
operator|=
name|argnames
expr_stmt|;
name|i
operator|=
name|defn
operator|->
name|nargs
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|argv
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
while|while
condition|(
operator|*
name|x
operator|!=
literal|','
operator|&&
operator|*
name|x
operator|!=
literal|'\0'
condition|)
name|x
operator|++
expr_stmt|;
name|argl
index|[
name|i
index|]
operator|=
name|x
operator|-
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|x
operator|==
literal|','
condition|)
block|{
operator|*
name|x
operator|=
literal|'\0'
expr_stmt|;
name|x
operator|+=
literal|2
expr_stmt|;
comment|/* skip the space after the comma */
block|}
block|}
comment|/* Now print out the argument list. */
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defn
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
name|argl
index|[
name|i
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|argl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|defn
operator|->
name|nargs
operator|-
literal|1
condition|)
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
literal|", "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|defn
operator|->
name|rest_args
condition|)
name|CPP_PUTS
argument_list|(
name|pfile
argument_list|,
literal|"...) "
argument_list|,
literal|5
argument_list|)
expr_stmt|;
else|else
name|CPP_PUTS
argument_list|(
name|pfile
argument_list|,
literal|") "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Now the definition. */
name|x
operator|=
name|defn
operator|->
name|expansion
expr_stmt|;
for|for
control|(
name|r
operator|=
name|defn
operator|->
name|pattern
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
name|i
operator|=
name|r
operator|->
name|nchars
expr_stmt|;
if|if
condition|(
operator|*
name|x
operator|==
literal|'\r'
condition|)
name|x
operator|+=
literal|2
operator|,
name|i
operator|-=
literal|2
expr_stmt|;
comment|/* i chars for macro text, plus the length of the macro 	   argument name, plus one for a stringify marker, plus two for 	   each concatenation marker. */
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
name|i
operator|+
name|argl
index|[
name|r
operator|->
name|argno
index|]
operator|+
name|r
operator|->
name|stringify
operator|+
operator|(
name|r
operator|->
name|raw_before
operator|+
name|r
operator|->
name|raw_after
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|raw_before
condition|)
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
literal|"##"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|stringify
condition|)
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
name|argv
index|[
name|r
operator|->
name|argno
index|]
argument_list|,
name|argl
index|[
name|r
operator|->
name|argno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|raw_after
operator|&&
operator|!
operator|(
name|r
operator|->
name|next
operator|&&
name|r
operator|->
name|next
operator|->
name|nchars
operator|==
literal|0
operator|&&
name|r
operator|->
name|next
operator|->
name|raw_before
operator|)
condition|)
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
literal|"##"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|x
operator|+=
name|i
expr_stmt|;
block|}
name|i
operator|=
name|defn
operator|->
name|length
operator|-
operator|(
name|x
operator|-
name|defn
operator|->
name|expansion
operator|)
operator|-
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|x
operator|==
literal|'\r'
condition|)
name|x
operator|+=
literal|2
operator|,
name|i
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|CPP_PUTS
argument_list|(
name|pfile
argument_list|,
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CPP_NUL_TERMINATE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

