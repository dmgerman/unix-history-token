begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Part of CPP library.  (Macro hash table support.)    Copyright (C) 1986, 87, 89, 92-95, 1996 Free Software Foundation, Inc.    Written by Per Bothner, 1994.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"gansidecl.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"cpphash.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xmalloc
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return hash function on name.  must be compatible with the one    computed a step at a time, elsewhere  */
end_comment

begin_function
name|int
name|hashf
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|hashsize
parameter_list|)
specifier|register
specifier|const
name|U_CHAR
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|hashsize
decl_stmt|;
block|{
specifier|register
name|int
name|r
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|r
operator|=
name|HASHSTEP
argument_list|(
name|r
argument_list|,
operator|*
name|name
operator|++
argument_list|)
expr_stmt|;
return|return
name|MAKE_POS
argument_list|(
name|r
argument_list|)
operator|%
name|hashsize
return|;
block|}
end_function

begin_comment
comment|/* Find the most recent hash node for name "name" (ending with first    non-identifier char) installed by install     If LEN is>= 0, it is the length of the name.    Otherwise, compute the length by scanning the entire name.     If HASH is>= 0, it is the precomputed hash code.    Otherwise, compute the hash code.  */
end_comment

begin_function
name|HASHNODE
modifier|*
name|cpp_lookup
parameter_list|(
name|pfile
parameter_list|,
name|name
parameter_list|,
name|len
parameter_list|,
name|hash
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
specifier|register
specifier|const
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
specifier|register
name|HASHNODE
modifier|*
name|bucket
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|bp
operator|=
name|name
init|;
name|is_idchar
index|[
operator|*
name|bp
index|]
condition|;
name|bp
operator|++
control|)
empty_stmt|;
name|len
operator|=
name|bp
operator|-
name|name
expr_stmt|;
block|}
if|if
condition|(
name|hash
operator|<
literal|0
condition|)
name|hash
operator|=
name|hashf
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|hashtab
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|bucket
condition|)
block|{
if|if
condition|(
name|bucket
operator|->
name|length
operator|==
name|len
operator|&&
name|strncmp
argument_list|(
name|bucket
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bucket
return|;
name|bucket
operator|=
name|bucket
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|HASHNODE
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Delete a hash node.  Some weirdness to free junk from macros.  * More such weirdness will have to be added if you define more hash  * types that need it.  */
end_comment

begin_comment
comment|/* Note that the DEFINITION of a macro is removed from the hash table    but its storage is not freed.  This would be a storage leak    except that it is not reasonable to keep undefining and redefining    large numbers of macros many times.    In any case, this is necessary, because a macro can be #undef'd    in the middle of reading the arguments to a call to it.    If #undef freed the DEFINITION, that would crash.  */
end_comment

begin_function
name|void
name|delete_macro
parameter_list|(
name|hp
parameter_list|)
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
block|{
if|if
condition|(
name|hp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|prev
operator|->
name|next
operator|=
name|hp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
operator|->
name|prev
expr_stmt|;
comment|/* make sure that the bucket chain header that      the deleted guy was on points to the right thing afterwards.  */
if|if
condition|(
name|hp
operator|==
operator|*
name|hp
operator|->
name|bucket_hdr
condition|)
operator|*
name|hp
operator|->
name|bucket_hdr
operator|=
name|hp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
condition|)
block|{
name|DEFINITION
modifier|*
name|d
init|=
name|hp
operator|->
name|value
operator|.
name|defn
decl_stmt|;
name|struct
name|reflist
modifier|*
name|ap
decl_stmt|,
modifier|*
name|nextap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|d
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|nextap
control|)
block|{
name|nextap
operator|=
name|ap
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|nargs
operator|>=
literal|0
condition|)
name|free
argument_list|(
name|d
operator|->
name|args
operator|.
name|argnames
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Install a name in the main hash table, even if it is already there.      name stops with first non alphanumeric, except leading '#'.    caller must check against redefinition if that is desired.    delete_macro () removes things installed by install () in fifo order.    this is important because of the `defined' special symbol used    in #if, and also if pushdef/popdef directives are ever implemented.     If LEN is>= 0, it is the length of the name.    Otherwise, compute the length by scanning the entire name.     If HASH is>= 0, it is the precomputed hash code.    Otherwise, compute the hash code.  */
end_comment

begin_function
name|HASHNODE
modifier|*
name|install
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|type
parameter_list|,
name|ivalue
parameter_list|,
name|value
parameter_list|,
name|hash
parameter_list|)
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|enum
name|node_type
name|type
decl_stmt|;
name|int
name|ivalue
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
specifier|register
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|bucket
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|p
operator|=
name|name
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|name
expr_stmt|;
block|}
if|if
condition|(
name|hash
operator|<
literal|0
condition|)
name|hash
operator|=
name|hashf
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
name|i
operator|=
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
operator|+
name|len
operator|+
literal|1
expr_stmt|;
name|hp
operator|=
operator|(
name|HASHNODE
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|hash
expr_stmt|;
name|hp
operator|->
name|bucket_hdr
operator|=
operator|&
name|hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|hp
operator|->
name|next
operator|=
name|hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|hashtab
index|[
name|bucket
index|]
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|hp
operator|->
name|length
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_CONST
condition|)
name|hp
operator|->
name|value
operator|.
name|ival
operator|=
name|ivalue
expr_stmt|;
else|else
name|hp
operator|->
name|value
operator|.
name|cpval
operator|=
name|value
expr_stmt|;
name|hp
operator|->
name|name
operator|=
operator|(
operator|(
name|U_CHAR
operator|*
operator|)
name|hp
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
expr_stmt|;
name|p
operator|=
name|hp
operator|->
name|name
expr_stmt|;
name|q
operator|=
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
name|hp
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|hp
return|;
block|}
end_function

begin_function
name|void
name|cpp_hash_cleanup
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|HASHSIZE
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
while|while
condition|(
name|hashtab
index|[
name|i
index|]
condition|)
name|delete_macro
argument_list|(
name|hashtab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

