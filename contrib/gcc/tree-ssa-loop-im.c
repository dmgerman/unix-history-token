begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Loop invariant motion.    Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"domwalk.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_comment
comment|/* TODO:  Support for predicated code motion.  I.e.     while (1)      {        if (cond) 	 { 	   a = inv; 	   something; 	 }      }     Where COND and INV are is invariants, but evaluating INV may trap or be    invalid from some other reason if !COND.  This may be transformed to     if (cond)      a = inv;    while (1)      {        if (cond) 	 something;      }  */
end_comment

begin_comment
comment|/* A type for the list of statements that have to be moved in order to be able    to hoist an invariant computation.  */
end_comment

begin_struct
struct|struct
name|depend
block|{
name|tree
name|stmt
decl_stmt|;
name|struct
name|depend
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The auxiliary data kept for each statement.  */
end_comment

begin_struct
struct|struct
name|lim_aux_data
block|{
name|struct
name|loop
modifier|*
name|max_loop
decl_stmt|;
comment|/* The outermost loop in that the statement 				   is invariant.  */
name|struct
name|loop
modifier|*
name|tgt_loop
decl_stmt|;
comment|/* The loop out of that we want to move the 				   invariant.  */
name|struct
name|loop
modifier|*
name|always_executed_in
decl_stmt|;
comment|/* The outermost loop for that we are sure 				   the statement is executed if the loop 				   is entered.  */
name|bool
name|sm_done
decl_stmt|;
comment|/* True iff the store motion for a memory 				   reference in the statement has already 				   been executed.  */
name|unsigned
name|cost
decl_stmt|;
comment|/* Cost of the computation performed by the 				   statement.  */
name|struct
name|depend
modifier|*
name|depends
decl_stmt|;
comment|/* List of statements that must be also hoisted 				   out of the loop when this statement is 				   hoisted; i.e. those that define the operands 				   of the statement and are inside of the 				   MAX_LOOP loop.  */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LIM_DATA
parameter_list|(
name|STMT
parameter_list|)
value|(TREE_CODE (STMT) == PHI_NODE \ 			? NULL \ 			: (struct lim_aux_data *) (stmt_ann (STMT)->common.aux))
end_define

begin_comment
comment|/* Description of a memory reference location for store motion.  */
end_comment

begin_struct
struct|struct
name|mem_ref_loc
block|{
name|tree
modifier|*
name|ref
decl_stmt|;
comment|/* The reference itself.  */
name|tree
name|stmt
decl_stmt|;
comment|/* The statement in that it occurs.  */
name|struct
name|mem_ref_loc
modifier|*
name|next
decl_stmt|;
comment|/* Next use in the chain.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Description of a memory reference for store motion.  */
end_comment

begin_struct
struct|struct
name|mem_ref
block|{
name|tree
name|mem
decl_stmt|;
comment|/* The memory itself.  */
name|hashval_t
name|hash
decl_stmt|;
comment|/* Its hash value.  */
name|bool
name|is_stored
decl_stmt|;
comment|/* True if there is a store to the location 				   in the loop.  */
name|struct
name|mem_ref_loc
modifier|*
name|locs
decl_stmt|;
comment|/* The locations where it is found.  */
name|bitmap
name|vops
decl_stmt|;
comment|/* Vops corresponding to this memory 				   location.  */
name|struct
name|mem_ref
modifier|*
name|next
decl_stmt|;
comment|/* Next memory reference in the list. 				   Memory references are stored in a hash 				   table, but the hash function depends 				   on values of pointers. Thus we cannot use 				   htab_traverse, since then we would get 				   miscompares during bootstrap (although the 				   produced code would be correct).  */
block|}
struct|;
end_struct

begin_comment
comment|/* Minimum cost of an expensive expression.  */
end_comment

begin_define
define|#
directive|define
name|LIM_EXPENSIVE
value|((unsigned) PARAM_VALUE (PARAM_LIM_EXPENSIVE))
end_define

begin_comment
comment|/* The outermost loop for that execution of the header guarantees that the    block will be executed.  */
end_comment

begin_define
define|#
directive|define
name|ALWAYS_EXECUTED_IN
parameter_list|(
name|BB
parameter_list|)
value|((struct loop *) (BB)->aux)
end_define

begin_comment
comment|/* Calls CBCK for each index in memory reference ADDR_P.  There are two    kinds situations handled; in each of these cases, the memory reference    and DATA are passed to the callback:        Access to an array: ARRAY_{RANGE_}REF (base, index).  In this case we also    pass the pointer to the index to the callback.     Pointer dereference: INDIRECT_REF (addr).  In this case we also pass the    pointer to addr to the callback.        If the callback returns false, the whole search stops and false is returned.    Otherwise the function returns true after traversing through the whole    reference *ADDR_P.  */
end_comment

begin_function
name|bool
name|for_each_index
parameter_list|(
name|tree
modifier|*
name|addr_p
parameter_list|,
name|bool
function_decl|(
modifier|*
name|cbck
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
modifier|*
name|nxt
decl_stmt|,
modifier|*
name|idx
decl_stmt|;
for|for
control|(
init|;
condition|;
name|addr_p
operator|=
name|nxt
control|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|addr_p
argument_list|)
condition|)
block|{
case|case
name|SSA_NAME
case|:
return|return
name|cbck
argument_list|(
operator|*
name|addr_p
argument_list|,
name|addr_p
argument_list|,
name|data
argument_list|)
return|;
case|case
name|MISALIGNED_INDIRECT_REF
case|:
case|case
name|ALIGN_INDIRECT_REF
case|:
case|case
name|INDIRECT_REF
case|:
name|nxt
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|addr_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|cbck
argument_list|(
operator|*
name|addr_p
argument_list|,
name|nxt
argument_list|,
name|data
argument_list|)
return|;
case|case
name|BIT_FIELD_REF
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
name|nxt
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|addr_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
comment|/* If the component has varying offset, it behaves like index 	     as well.  */
name|idx
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|addr_p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|idx
operator|&&
operator|!
name|cbck
argument_list|(
operator|*
name|addr_p
argument_list|,
name|idx
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|false
return|;
name|nxt
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|addr_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
name|nxt
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|addr_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cbck
argument_list|(
operator|*
name|addr_p
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|addr_p
argument_list|,
literal|1
argument_list|)
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|STRING_CST
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|VECTOR_CST
case|:
case|case
name|COMPLEX_CST
case|:
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
return|return
name|true
return|;
case|case
name|TARGET_MEM_REF
case|:
name|idx
operator|=
operator|&
name|TMR_BASE
argument_list|(
operator|*
name|addr_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|idx
operator|&&
operator|!
name|cbck
argument_list|(
operator|*
name|addr_p
argument_list|,
name|idx
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|false
return|;
name|idx
operator|=
operator|&
name|TMR_INDEX
argument_list|(
operator|*
name|addr_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|idx
operator|&&
operator|!
name|cbck
argument_list|(
operator|*
name|addr_p
argument_list|,
name|idx
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* If it is possible to hoist the statement STMT unconditionally,    returns MOVE_POSSIBLE.    If it is possible to hoist the statement STMT, but we must avoid making    it executed if it would not be executed in the original program (e.g.    because it may trap), return MOVE_PRESERVE_EXECUTION.    Otherwise return MOVE_IMPOSSIBLE.  */
end_comment

begin_function
name|enum
name|move_pos
name|movement_possibility
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
if|if
condition|(
name|flag_unswitch_loops
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
comment|/* If we perform unswitching, force the operands of the invariant 	 condition to be moved out of the loop.  */
return|return
name|MOVE_POSSIBLE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|MOVE_IMPOSSIBLE
return|;
if|if
condition|(
name|stmt_ends_bb_p
argument_list|(
name|stmt
argument_list|)
condition|)
return|return
name|MOVE_IMPOSSIBLE
return|;
if|if
condition|(
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
operator|->
name|has_volatile_ops
condition|)
return|return
name|MOVE_IMPOSSIBLE
return|;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|lhs
argument_list|)
condition|)
return|return
name|MOVE_IMPOSSIBLE
return|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|rhs
argument_list|)
condition|)
return|return
name|MOVE_IMPOSSIBLE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|SSA_NAME
operator|||
name|tree_could_trap_p
argument_list|(
name|rhs
argument_list|)
condition|)
return|return
name|MOVE_PRESERVE_EXECUTION
return|;
if|if
condition|(
name|get_call_expr_in
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
comment|/* While pure or const call is guaranteed to have no side effects, we 	 cannot move it arbitrarily.  Consider code like  	 char *s = something ();  	 while (1) 	   { 	     if (s) 	       t = strlen (s); 	     else 	       t = 0; 	   }  	 Here the strlen call cannot be moved out of the loop, even though 	 s is invariant.  In addition to possibly creating a call with 	 invalid arguments, moving out a function call that is not executed 	 may cause performance regressions in case the call is costly and 	 not executed at all.  */
return|return
name|MOVE_PRESERVE_EXECUTION
return|;
block|}
return|return
name|MOVE_POSSIBLE
return|;
block|}
end_function

begin_comment
comment|/* Suppose that operand DEF is used inside the LOOP.  Returns the outermost    loop to that we could move the expression using DEF if it did not have    other operands, i.e. the outermost loop enclosing LOOP in that the value    of DEF is invariant.  */
end_comment

begin_function
specifier|static
name|struct
name|loop
modifier|*
name|outermost_invariant_loop
parameter_list|(
name|tree
name|def
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|tree
name|def_stmt
decl_stmt|;
name|basic_block
name|def_bb
decl_stmt|;
name|struct
name|loop
modifier|*
name|max_loop
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|superloop_at_depth
argument_list|(
name|loop
argument_list|,
literal|1
argument_list|)
return|;
name|def_stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|def
argument_list|)
expr_stmt|;
name|def_bb
operator|=
name|bb_for_stmt
argument_list|(
name|def_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|def_bb
condition|)
return|return
name|superloop_at_depth
argument_list|(
name|loop
argument_list|,
literal|1
argument_list|)
return|;
name|max_loop
operator|=
name|find_common_loop
argument_list|(
name|loop
argument_list|,
name|def_bb
operator|->
name|loop_father
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIM_DATA
argument_list|(
name|def_stmt
argument_list|)
operator|&&
name|LIM_DATA
argument_list|(
name|def_stmt
argument_list|)
operator|->
name|max_loop
condition|)
name|max_loop
operator|=
name|find_common_loop
argument_list|(
name|max_loop
argument_list|,
name|LIM_DATA
argument_list|(
name|def_stmt
argument_list|)
operator|->
name|max_loop
operator|->
name|outer
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_loop
operator|==
name|loop
condition|)
return|return
name|NULL
return|;
name|max_loop
operator|=
name|superloop_at_depth
argument_list|(
name|loop
argument_list|,
name|max_loop
operator|->
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|max_loop
return|;
block|}
end_function

begin_comment
comment|/* Returns the outermost superloop of LOOP in that the expression EXPR is    invariant.  */
end_comment

begin_function
specifier|static
name|struct
name|loop
modifier|*
name|outermost_invariant_loop_expr
parameter_list|(
name|tree
name|expr
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|enum
name|tree_code_class
name|class
init|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|nops
decl_stmt|;
name|struct
name|loop
modifier|*
name|max_loop
init|=
name|superloop_at_depth
argument_list|(
name|loop
argument_list|,
literal|1
argument_list|)
decl_stmt|,
modifier|*
name|aloop
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SSA_NAME
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|is_gimple_min_invariant
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|outermost_invariant_loop
argument_list|(
name|expr
argument_list|,
name|loop
argument_list|)
return|;
if|if
condition|(
name|class
operator|!=
name|tcc_unary
operator|&&
name|class
operator|!=
name|tcc_binary
operator|&&
name|class
operator|!=
name|tcc_expression
operator|&&
name|class
operator|!=
name|tcc_comparison
condition|)
return|return
name|NULL
return|;
name|nops
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
block|{
name|aloop
operator|=
name|outermost_invariant_loop_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
name|i
argument_list|)
argument_list|,
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aloop
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|flow_loop_nested_p
argument_list|(
name|max_loop
argument_list|,
name|aloop
argument_list|)
condition|)
name|max_loop
operator|=
name|aloop
expr_stmt|;
block|}
return|return
name|max_loop
return|;
block|}
end_function

begin_comment
comment|/* DATA is a structure containing information associated with a statement    inside LOOP.  DEF is one of the operands of this statement.        Find the outermost loop enclosing LOOP in that value of DEF is invariant    and record this in DATA->max_loop field.  If DEF itself is defined inside    this loop as well (i.e. we need to hoist it out of the loop if we want    to hoist the statement represented by DATA), record the statement in that    DEF is defined to the DATA->depends list.  Additionally if ADD_COST is true,    add the cost of the computation of DEF to the DATA->cost.        If DEF is not invariant in LOOP, return false.  Otherwise return TRUE.  */
end_comment

begin_function
specifier|static
name|bool
name|add_dependency
parameter_list|(
name|tree
name|def
parameter_list|,
name|struct
name|lim_aux_data
modifier|*
name|data
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|bool
name|add_cost
parameter_list|)
block|{
name|tree
name|def_stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|basic_block
name|def_bb
init|=
name|bb_for_stmt
argument_list|(
name|def_stmt
argument_list|)
decl_stmt|;
name|struct
name|loop
modifier|*
name|max_loop
decl_stmt|;
name|struct
name|depend
modifier|*
name|dep
decl_stmt|;
if|if
condition|(
operator|!
name|def_bb
condition|)
return|return
name|true
return|;
name|max_loop
operator|=
name|outermost_invariant_loop
argument_list|(
name|def
argument_list|,
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|max_loop
condition|)
return|return
name|false
return|;
if|if
condition|(
name|flow_loop_nested_p
argument_list|(
name|data
operator|->
name|max_loop
argument_list|,
name|max_loop
argument_list|)
condition|)
name|data
operator|->
name|max_loop
operator|=
name|max_loop
expr_stmt|;
if|if
condition|(
operator|!
name|LIM_DATA
argument_list|(
name|def_stmt
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|add_cost
comment|/* Only add the cost if the statement defining DEF is inside LOOP, 	 i.e. if it is likely that by moving the invariants dependent 	 on it, we will be able to avoid creating a new register for 	 it (since it will be only used in these dependent invariants).  */
operator|&&
name|def_bb
operator|->
name|loop_father
operator|==
name|loop
condition|)
name|data
operator|->
name|cost
operator|+=
name|LIM_DATA
argument_list|(
name|def_stmt
argument_list|)
operator|->
name|cost
expr_stmt|;
name|dep
operator|=
name|XNEW
argument_list|(
expr|struct
name|depend
argument_list|)
expr_stmt|;
name|dep
operator|->
name|stmt
operator|=
name|def_stmt
expr_stmt|;
name|dep
operator|->
name|next
operator|=
name|data
operator|->
name|depends
expr_stmt|;
name|data
operator|->
name|depends
operator|=
name|dep
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Returns an estimate for a cost of statement STMT.  TODO -- the values here    are just ad-hoc constants.  The estimates should be based on target-specific    values.  */
end_comment

begin_function
specifier|static
name|unsigned
name|stmt_cost
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|rhs
decl_stmt|;
name|unsigned
name|cost
init|=
literal|1
decl_stmt|;
comment|/* Always try to create possibilities for unswitching.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
return|return
name|LIM_EXPENSIVE
return|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Hoisting memory references out should almost surely be a win.  */
if|if
condition|(
name|stmt_references_memory_p
argument_list|(
name|stmt
argument_list|)
condition|)
name|cost
operator|+=
literal|20
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
case|case
name|CALL_EXPR
case|:
comment|/* We should be hoisting calls if possible.  */
comment|/* Unless the call is a builtin_constant_p; this always folds to a 	 constant, so moving it is useless.  */
name|rhs
operator|=
name|get_callee_fndecl
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|rhs
argument_list|)
operator|==
name|BUILT_IN_NORMAL
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BUILT_IN_CONSTANT_P
condition|)
return|return
literal|0
return|;
name|cost
operator|+=
literal|20
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
comment|/* Division and multiplication are usually expensive.  */
name|cost
operator|+=
literal|20
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Determine the outermost loop to that it is possible to hoist a statement    STMT and store it to LIM_DATA (STMT)->max_loop.  To do this we determine    the outermost loop in that the value computed by STMT is invariant.    If MUST_PRESERVE_EXEC is true, additionally choose such a loop that    we preserve the fact whether STMT is executed.  It also fills other related    information to LIM_DATA (STMT).        The function returns false if STMT cannot be hoisted outside of the loop it    is defined in, and true otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|determine_max_movement
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|bool
name|must_preserve_exec
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|bb
operator|->
name|loop_father
decl_stmt|;
name|struct
name|loop
modifier|*
name|level
decl_stmt|;
name|struct
name|lim_aux_data
modifier|*
name|lim_data
init|=
name|LIM_DATA
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
if|if
condition|(
name|must_preserve_exec
condition|)
name|level
operator|=
name|ALWAYS_EXECUTED_IN
argument_list|(
name|bb
argument_list|)
expr_stmt|;
else|else
name|level
operator|=
name|superloop_at_depth
argument_list|(
name|loop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lim_data
operator|->
name|max_loop
operator|=
name|level
expr_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|val
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
if|if
condition|(
operator|!
name|add_dependency
argument_list|(
name|val
argument_list|,
name|lim_data
argument_list|,
name|loop
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|false
return|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|val
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_KILLS
argument_list|)
if|if
condition|(
operator|!
name|add_dependency
argument_list|(
name|val
argument_list|,
name|lim_data
argument_list|,
name|loop
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|false
return|;
name|lim_data
operator|->
name|cost
operator|+=
name|stmt_cost
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Suppose that some statement in ORIG_LOOP is hoisted to the loop LEVEL,    and that one of the operands of this statement is computed by STMT.    Ensure that STMT (together with all the statements that define its    operands) is hoisted at least out of the loop LEVEL.  */
end_comment

begin_function
specifier|static
name|void
name|set_level
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|struct
name|loop
modifier|*
name|orig_loop
parameter_list|,
name|struct
name|loop
modifier|*
name|level
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|stmt_loop
init|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
operator|->
name|loop_father
decl_stmt|;
name|struct
name|depend
modifier|*
name|dep
decl_stmt|;
name|stmt_loop
operator|=
name|find_common_loop
argument_list|(
name|orig_loop
argument_list|,
name|stmt_loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIM_DATA
argument_list|(
name|stmt
argument_list|)
operator|&&
name|LIM_DATA
argument_list|(
name|stmt
argument_list|)
operator|->
name|tgt_loop
condition|)
name|stmt_loop
operator|=
name|find_common_loop
argument_list|(
name|stmt_loop
argument_list|,
name|LIM_DATA
argument_list|(
name|stmt
argument_list|)
operator|->
name|tgt_loop
operator|->
name|outer
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow_loop_nested_p
argument_list|(
name|stmt_loop
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|gcc_assert
argument_list|(
name|LIM_DATA
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|level
operator|==
name|LIM_DATA
argument_list|(
name|stmt
argument_list|)
operator|->
name|max_loop
operator|||
name|flow_loop_nested_p
argument_list|(
name|LIM_DATA
argument_list|(
name|stmt
argument_list|)
operator|->
name|max_loop
argument_list|,
name|level
argument_list|)
argument_list|)
expr_stmt|;
name|LIM_DATA
argument_list|(
name|stmt
argument_list|)
operator|->
name|tgt_loop
operator|=
name|level
expr_stmt|;
for|for
control|(
name|dep
operator|=
name|LIM_DATA
argument_list|(
name|stmt
argument_list|)
operator|->
name|depends
init|;
name|dep
condition|;
name|dep
operator|=
name|dep
operator|->
name|next
control|)
name|set_level
argument_list|(
name|dep
operator|->
name|stmt
argument_list|,
name|orig_loop
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determines an outermost loop from that we want to hoist the statement STMT.    For now we chose the outermost possible loop.  TODO -- use profiling    information to set it more sanely.  */
end_comment

begin_function
specifier|static
name|void
name|set_profitable_level
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|set_level
argument_list|(
name|stmt
argument_list|,
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
operator|->
name|loop_father
argument_list|,
name|LIM_DATA
argument_list|(
name|stmt
argument_list|)
operator|->
name|max_loop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns true if STMT is not a pure call.  */
end_comment

begin_function
specifier|static
name|bool
name|nonpure_call_p
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|call
init|=
name|get_call_expr_in
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|call
condition|)
return|return
name|false
return|;
return|return
name|TREE_SIDE_EFFECTS
argument_list|(
name|call
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Releases the memory occupied by DATA.  */
end_comment

begin_function
specifier|static
name|void
name|free_lim_aux_data
parameter_list|(
name|struct
name|lim_aux_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|depend
modifier|*
name|dep
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|dep
operator|=
name|data
operator|->
name|depends
init|;
name|dep
condition|;
name|dep
operator|=
name|next
control|)
block|{
name|next
operator|=
name|dep
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|dep
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine the outermost loops in that statements in basic block BB are    invariant, and record them to the LIM_DATA associated with the statements.    Callback for walk_dominator_tree.  */
end_comment

begin_function
specifier|static
name|void
name|determine_invariantness_stmt
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|dw_data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|enum
name|move_pos
name|pos
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|stmt
decl_stmt|,
name|rhs
decl_stmt|;
name|bool
name|maybe_never
init|=
name|ALWAYS_EXECUTED_IN
argument_list|(
name|bb
argument_list|)
operator|==
name|NULL
decl_stmt|;
name|struct
name|loop
modifier|*
name|outermost
init|=
name|ALWAYS_EXECUTED_IN
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bb
operator|->
name|loop_father
operator|->
name|outer
condition|)
return|return;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Basic block %d (loop %d -- depth %d):\n\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|loop_father
operator|->
name|num
argument_list|,
name|bb
operator|->
name|loop_father
operator|->
name|depth
argument_list|)
expr_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
name|pos
operator|=
name|movement_possibility
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|MOVE_IMPOSSIBLE
condition|)
block|{
if|if
condition|(
name|nonpure_call_p
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|maybe_never
operator|=
name|true
expr_stmt|;
name|outermost
operator|=
name|NULL
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* If divisor is invariant, convert a/b to a*(1/b), allowing reciprocal 	 to be hoisted out of loop, saving expensive divide.  */
if|if
condition|(
name|pos
operator|==
name|MOVE_POSSIBLE
operator|&&
operator|(
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|RDIV_EXPR
operator|&&
name|flag_unsafe_math_optimizations
operator|&&
operator|!
name|flag_trapping_math
operator|&&
name|outermost_invariant_loop_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|loop_containing_stmt
argument_list|(
name|stmt
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|&&
name|outermost_invariant_loop_expr
argument_list|(
name|rhs
argument_list|,
name|loop_containing_stmt
argument_list|(
name|stmt
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|tree
name|lhs
decl_stmt|,
name|stmt1
decl_stmt|,
name|stmt2
decl_stmt|,
name|var
decl_stmt|,
name|name
decl_stmt|;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* stmt must be MODIFY_EXPR.  */
name|var
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
literal|"reciptmp"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|stmt1
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|var
argument_list|,
name|build2
argument_list|(
name|RDIV_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|dconst1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|make_ssa_name
argument_list|(
name|var
argument_list|,
name|stmt1
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt1
argument_list|,
literal|0
argument_list|)
operator|=
name|name
expr_stmt|;
name|stmt2
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lhs
argument_list|,
name|build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|name
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Replace division stmt with reciprocal and multiply stmts. 	     The multiply stmt is not invariant, so update iterator 	     and avoid rescanning.  */
name|bsi_replace
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt1
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt2
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|lhs
argument_list|)
operator|=
name|stmt2
expr_stmt|;
comment|/* Continue processing with invariant reciprocal statement.  */
name|stmt
operator|=
name|stmt1
expr_stmt|;
block|}
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
operator|->
name|common
operator|.
name|aux
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lim_aux_data
argument_list|)
argument_list|)
expr_stmt|;
name|LIM_DATA
argument_list|(
name|stmt
argument_list|)
operator|->
name|always_executed_in
operator|=
name|outermost
expr_stmt|;
if|if
condition|(
name|maybe_never
operator|&&
name|pos
operator|==
name|MOVE_PRESERVE_EXECUTION
condition|)
continue|continue;
if|if
condition|(
operator|!
name|determine_max_movement
argument_list|(
name|stmt
argument_list|,
name|pos
operator|==
name|MOVE_PRESERVE_EXECUTION
argument_list|)
condition|)
block|{
name|LIM_DATA
argument_list|(
name|stmt
argument_list|)
operator|->
name|max_loop
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|print_generic_stmt_indented
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  invariant up to level %d, cost %d.\n\n"
argument_list|,
name|LIM_DATA
argument_list|(
name|stmt
argument_list|)
operator|->
name|max_loop
operator|->
name|depth
argument_list|,
name|LIM_DATA
argument_list|(
name|stmt
argument_list|)
operator|->
name|cost
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LIM_DATA
argument_list|(
name|stmt
argument_list|)
operator|->
name|cost
operator|>=
name|LIM_EXPENSIVE
condition|)
name|set_profitable_level
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For each statement determines the outermost loop in that it is invariant,    statements on whose motion it depends and the cost of the computation.    This information is stored to the LIM_DATA structure associated with    each statement.  */
end_comment

begin_function
specifier|static
name|void
name|determine_invariantness
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dom_walk_data
name|walk_data
decl_stmt|;
name|memset
argument_list|(
operator|&
name|walk_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dom_walk_data
argument_list|)
argument_list|)
expr_stmt|;
name|walk_data
operator|.
name|before_dom_children_before_stmts
operator|=
name|determine_invariantness_stmt
expr_stmt|;
name|init_walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|)
expr_stmt|;
name|walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
name|fini_walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Commits edge insertions and updates loop structures.  */
end_comment

begin_function
name|void
name|loop_commit_inserts
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|old_last_basic_block
decl_stmt|,
name|i
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|old_last_basic_block
operator|=
name|last_basic_block
expr_stmt|;
name|bsi_commit_edge_inserts
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|old_last_basic_block
init|;
name|i
operator|<
operator|(
name|unsigned
operator|)
name|last_basic_block
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|bb
argument_list|,
name|find_common_loop
argument_list|(
name|single_pred
argument_list|(
name|bb
argument_list|)
operator|->
name|loop_father
argument_list|,
name|single_succ
argument_list|(
name|bb
argument_list|)
operator|->
name|loop_father
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Hoist the statements in basic block BB out of the loops prescribed by    data stored in LIM_DATA structures associated with each statement.  Callback    for walk_dominator_tree.  */
end_comment

begin_function
specifier|static
name|void
name|move_computations_stmt
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|dw_data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|level
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|unsigned
name|cost
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|bb
operator|->
name|loop_father
operator|->
name|outer
condition|)
return|return;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
control|)
block|{
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LIM_DATA
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cost
operator|=
name|LIM_DATA
argument_list|(
name|stmt
argument_list|)
operator|->
name|cost
expr_stmt|;
name|level
operator|=
name|LIM_DATA
argument_list|(
name|stmt
argument_list|)
operator|->
name|tgt_loop
expr_stmt|;
name|free_lim_aux_data
argument_list|(
name|LIM_DATA
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
operator|->
name|common
operator|.
name|aux
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|level
condition|)
block|{
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* We do not really want to move conditionals out of the loop; we just 	 placed it here to force its operands to be moved if necessary.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
continue|continue;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Moving statement\n"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(cost %u) out of loop %d.\n\n"
argument_list|,
name|cost
argument_list|,
name|level
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
name|bsi_insert_on_edge
argument_list|(
name|loop_preheader_edge
argument_list|(
name|level
argument_list|)
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|bsi
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Hoist the statements out of the loops prescribed by data stored in    LIM_DATA structures associated with each statement.*/
end_comment

begin_function
specifier|static
name|void
name|move_computations
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dom_walk_data
name|walk_data
decl_stmt|;
name|memset
argument_list|(
operator|&
name|walk_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dom_walk_data
argument_list|)
argument_list|)
expr_stmt|;
name|walk_data
operator|.
name|before_dom_children_before_stmts
operator|=
name|move_computations_stmt
expr_stmt|;
name|init_walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|)
expr_stmt|;
name|walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
name|fini_walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|)
expr_stmt|;
name|loop_commit_inserts
argument_list|()
expr_stmt|;
if|if
condition|(
name|need_ssa_update_p
argument_list|()
condition|)
name|rewrite_into_loop_closed_ssa
argument_list|(
name|NULL
argument_list|,
name|TODO_update_ssa
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Checks whether the statement defining variable *INDEX can be hoisted    out of the loop passed in DATA.  Callback for for_each_index.  */
end_comment

begin_function
specifier|static
name|bool
name|may_move_till
parameter_list|(
name|tree
name|ref
parameter_list|,
name|tree
modifier|*
name|index
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|data
decl_stmt|,
modifier|*
name|max_loop
decl_stmt|;
comment|/* If REF is an array reference, check also that the step and the lower      bound is invariant in LOOP.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|tree
name|step
init|=
name|array_ref_element_size
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|tree
name|lbound
init|=
name|array_ref_low_bound
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|max_loop
operator|=
name|outermost_invariant_loop_expr
argument_list|(
name|step
argument_list|,
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|max_loop
condition|)
return|return
name|false
return|;
name|max_loop
operator|=
name|outermost_invariant_loop_expr
argument_list|(
name|lbound
argument_list|,
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|max_loop
condition|)
return|return
name|false
return|;
block|}
name|max_loop
operator|=
name|outermost_invariant_loop
argument_list|(
operator|*
name|index
argument_list|,
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|max_loop
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Forces statements defining (invariant) SSA names in expression EXPR to be    moved out of the LOOP.  ORIG_LOOP is the loop in that EXPR is used.  */
end_comment

begin_function
specifier|static
name|void
name|force_move_till_expr
parameter_list|(
name|tree
name|expr
parameter_list|,
name|struct
name|loop
modifier|*
name|orig_loop
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|enum
name|tree_code_class
name|class
init|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|nops
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_EMPTY_STMT
argument_list|(
name|stmt
argument_list|)
condition|)
return|return;
name|set_level
argument_list|(
name|stmt
argument_list|,
name|orig_loop
argument_list|,
name|loop
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|class
operator|!=
name|tcc_unary
operator|&&
name|class
operator|!=
name|tcc_binary
operator|&&
name|class
operator|!=
name|tcc_expression
operator|&&
name|class
operator|!=
name|tcc_comparison
condition|)
return|return;
name|nops
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
name|force_move_till_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
name|i
argument_list|)
argument_list|,
name|orig_loop
argument_list|,
name|loop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Forces statement defining invariants in REF (and *INDEX) to be moved out of    the LOOP.  The reference REF is used in the loop ORIG_LOOP.  Callback for    for_each_index.  */
end_comment

begin_struct
struct|struct
name|fmt_data
block|{
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|struct
name|loop
modifier|*
name|orig_loop
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|bool
name|force_move_till
parameter_list|(
name|tree
name|ref
parameter_list|,
name|tree
modifier|*
name|index
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|;
name|struct
name|fmt_data
modifier|*
name|fmt_data
init|=
name|data
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|tree
name|step
init|=
name|array_ref_element_size
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|tree
name|lbound
init|=
name|array_ref_low_bound
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|force_move_till_expr
argument_list|(
name|step
argument_list|,
name|fmt_data
operator|->
name|orig_loop
argument_list|,
name|fmt_data
operator|->
name|loop
argument_list|)
expr_stmt|;
name|force_move_till_expr
argument_list|(
name|lbound
argument_list|,
name|fmt_data
operator|->
name|orig_loop
argument_list|,
name|fmt_data
operator|->
name|loop
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|index
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|true
return|;
name|stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
operator|*
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_EMPTY_STMT
argument_list|(
name|stmt
argument_list|)
condition|)
return|return
name|true
return|;
name|set_level
argument_list|(
name|stmt
argument_list|,
name|fmt_data
operator|->
name|orig_loop
argument_list|,
name|fmt_data
operator|->
name|loop
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Records memory reference location *REF to the list MEM_REFS.  The reference    occurs in statement STMT.  */
end_comment

begin_function
specifier|static
name|void
name|record_mem_ref_loc
parameter_list|(
name|struct
name|mem_ref_loc
modifier|*
modifier|*
name|mem_refs
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|tree
modifier|*
name|ref
parameter_list|)
block|{
name|struct
name|mem_ref_loc
modifier|*
name|aref
init|=
name|XNEW
argument_list|(
expr|struct
name|mem_ref_loc
argument_list|)
decl_stmt|;
name|aref
operator|->
name|stmt
operator|=
name|stmt
expr_stmt|;
name|aref
operator|->
name|ref
operator|=
name|ref
expr_stmt|;
name|aref
operator|->
name|next
operator|=
operator|*
name|mem_refs
expr_stmt|;
operator|*
name|mem_refs
operator|=
name|aref
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Releases list of memory reference locations MEM_REFS.  */
end_comment

begin_function
specifier|static
name|void
name|free_mem_ref_locs
parameter_list|(
name|struct
name|mem_ref_loc
modifier|*
name|mem_refs
parameter_list|)
block|{
name|struct
name|mem_ref_loc
modifier|*
name|act
decl_stmt|;
while|while
condition|(
name|mem_refs
condition|)
block|{
name|act
operator|=
name|mem_refs
expr_stmt|;
name|mem_refs
operator|=
name|mem_refs
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|act
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Rewrites memory references in list MEM_REFS by variable TMP_VAR.  */
end_comment

begin_function
specifier|static
name|void
name|rewrite_mem_refs
parameter_list|(
name|tree
name|tmp_var
parameter_list|,
name|struct
name|mem_ref_loc
modifier|*
name|mem_refs
parameter_list|)
block|{
name|tree
name|var
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
for|for
control|(
init|;
name|mem_refs
condition|;
name|mem_refs
operator|=
name|mem_refs
operator|->
name|next
control|)
block|{
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|var
argument_list|,
argument|mem_refs->stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_VIRTUALS
argument_list|)
name|mark_sym_for_renaming
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|mem_refs
operator|->
name|ref
operator|=
name|tmp_var
expr_stmt|;
name|update_stmt
argument_list|(
name|mem_refs
operator|->
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The name and the length of the currently generated variable    for lsm.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LSM_NAME_LENGTH
value|40
end_define

begin_decl_stmt
specifier|static
name|char
name|lsm_tmp_name
index|[
name|MAX_LSM_NAME_LENGTH
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lsm_tmp_name_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Adds S to lsm_tmp_name.  */
end_comment

begin_function
specifier|static
name|void
name|lsm_tmp_name_add
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|l
init|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
name|lsm_tmp_name_length
decl_stmt|;
if|if
condition|(
name|l
operator|>
name|MAX_LSM_NAME_LENGTH
condition|)
return|return;
name|strcpy
argument_list|(
name|lsm_tmp_name
operator|+
name|lsm_tmp_name_length
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|lsm_tmp_name_length
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stores the name for temporary variable that replaces REF to    lsm_tmp_name.  */
end_comment

begin_function
specifier|static
name|void
name|gen_lsm_tmp_name
parameter_list|(
name|tree
name|ref
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
condition|)
block|{
case|case
name|MISALIGNED_INDIRECT_REF
case|:
case|case
name|ALIGN_INDIRECT_REF
case|:
case|case
name|INDIRECT_REF
case|:
name|gen_lsm_tmp_name
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|lsm_tmp_name_add
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_FIELD_REF
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
case|case
name|ARRAY_RANGE_REF
case|:
name|gen_lsm_tmp_name
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REALPART_EXPR
case|:
name|gen_lsm_tmp_name
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|lsm_tmp_name_add
argument_list|(
literal|"_RE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMAGPART_EXPR
case|:
name|gen_lsm_tmp_name
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|lsm_tmp_name_add
argument_list|(
literal|"_IM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
name|gen_lsm_tmp_name
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|lsm_tmp_name_add
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
name|name
operator|=
name|get_name
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
name|name
operator|=
literal|"F"
expr_stmt|;
name|lsm_tmp_name_add
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
name|lsm_tmp_name_add
argument_list|(
name|name
argument_list|)
expr_stmt|;
case|case
name|ARRAY_REF
case|:
name|gen_lsm_tmp_name
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|lsm_tmp_name_add
argument_list|(
literal|"_I"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSA_NAME
case|:
name|ref
operator|=
name|SSA_NAME_VAR
argument_list|(
name|ref
argument_list|)
expr_stmt|;
comment|/* Fallthru.  */
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
name|name
operator|=
name|get_name
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
name|name
operator|=
literal|"D"
expr_stmt|;
name|lsm_tmp_name_add
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
name|lsm_tmp_name_add
argument_list|(
literal|"S"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESULT_DECL
case|:
name|lsm_tmp_name_add
argument_list|(
literal|"R"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determines name for temporary variable that replaces REF.    The name is accumulated into the lsm_tmp_name variable.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_lsm_tmp_name
parameter_list|(
name|tree
name|ref
parameter_list|)
block|{
name|lsm_tmp_name_length
operator|=
literal|0
expr_stmt|;
name|gen_lsm_tmp_name
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|lsm_tmp_name_add
argument_list|(
literal|"_lsm"
argument_list|)
expr_stmt|;
return|return
name|lsm_tmp_name
return|;
block|}
end_function

begin_comment
comment|/* Records request for store motion of memory reference REF from LOOP.    MEM_REFS is the list of occurrences of the reference REF inside LOOP;    these references are rewritten by a new temporary variable.    Exits from the LOOP are stored in EXITS, there are N_EXITS of them.    The initialization of the temporary variable is put to the preheader    of the loop, and assignments to the reference from the temporary variable    are emitted to exits.  */
end_comment

begin_function
specifier|static
name|void
name|schedule_sm
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|edge
modifier|*
name|exits
parameter_list|,
name|unsigned
name|n_exits
parameter_list|,
name|tree
name|ref
parameter_list|,
name|struct
name|mem_ref_loc
modifier|*
name|mem_refs
parameter_list|)
block|{
name|struct
name|mem_ref_loc
modifier|*
name|aref
decl_stmt|;
name|tree
name|tmp_var
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|tree
name|load
decl_stmt|,
name|store
decl_stmt|;
name|struct
name|fmt_data
name|fmt_data
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Executing store motion of "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" from loop %d\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
name|tmp_var
operator|=
name|make_rename_temp
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|get_lsm_tmp_name
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|fmt_data
operator|.
name|loop
operator|=
name|loop
expr_stmt|;
name|fmt_data
operator|.
name|orig_loop
operator|=
name|loop
expr_stmt|;
name|for_each_index
argument_list|(
operator|&
name|ref
argument_list|,
name|force_move_till
argument_list|,
operator|&
name|fmt_data
argument_list|)
expr_stmt|;
name|rewrite_mem_refs
argument_list|(
name|tmp_var
argument_list|,
name|mem_refs
argument_list|)
expr_stmt|;
for|for
control|(
name|aref
operator|=
name|mem_refs
init|;
name|aref
condition|;
name|aref
operator|=
name|aref
operator|->
name|next
control|)
if|if
condition|(
name|LIM_DATA
argument_list|(
name|aref
operator|->
name|stmt
argument_list|)
condition|)
name|LIM_DATA
argument_list|(
name|aref
operator|->
name|stmt
argument_list|)
operator|->
name|sm_done
operator|=
name|true
expr_stmt|;
comment|/* Emit the load& stores.  */
name|load
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tmp_var
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|get_stmt_ann
argument_list|(
name|load
argument_list|)
operator|->
name|common
operator|.
name|aux
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lim_aux_data
argument_list|)
argument_list|)
expr_stmt|;
name|LIM_DATA
argument_list|(
name|load
argument_list|)
operator|->
name|max_loop
operator|=
name|loop
expr_stmt|;
name|LIM_DATA
argument_list|(
name|load
argument_list|)
operator|->
name|tgt_loop
operator|=
name|loop
expr_stmt|;
comment|/* Put this into the latch, so that we are sure it will be processed after      all dependencies.  */
name|bsi_insert_on_edge
argument_list|(
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|load
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_exits
condition|;
name|i
operator|++
control|)
block|{
name|store
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|unshare_expr
argument_list|(
name|ref
argument_list|)
argument_list|,
name|tmp_var
argument_list|)
expr_stmt|;
name|bsi_insert_on_edge
argument_list|(
name|exits
index|[
name|i
index|]
argument_list|,
name|store
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check whether memory reference REF can be hoisted out of the LOOP.  If this    is true, prepare the statements that load the value of the memory reference    to a temporary variable in the loop preheader, store it back on the loop    exits, and replace all the references inside LOOP by this temporary variable.    LOOP has N_EXITS stored in EXITS.  CLOBBERED_VOPS is the bitmap of virtual    operands that are clobbered by a call or accessed through multiple references    in loop.  */
end_comment

begin_function
specifier|static
name|void
name|determine_lsm_ref
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|edge
modifier|*
name|exits
parameter_list|,
name|unsigned
name|n_exits
parameter_list|,
name|bitmap
name|clobbered_vops
parameter_list|,
name|struct
name|mem_ref
modifier|*
name|ref
parameter_list|)
block|{
name|struct
name|mem_ref_loc
modifier|*
name|aref
decl_stmt|;
name|struct
name|loop
modifier|*
name|must_exec
decl_stmt|;
comment|/* In case the memory is not stored to, there is nothing for SM to do.  */
if|if
condition|(
operator|!
name|ref
operator|->
name|is_stored
condition|)
return|return;
comment|/* If the reference is aliased with any different ref, or killed by call      in function, then fail.  */
if|if
condition|(
name|bitmap_intersect_p
argument_list|(
name|ref
operator|->
name|vops
argument_list|,
name|clobbered_vops
argument_list|)
condition|)
return|return;
if|if
condition|(
name|tree_could_trap_p
argument_list|(
name|ref
operator|->
name|mem
argument_list|)
condition|)
block|{
comment|/* If the memory access is unsafe (i.e. it might trap), ensure that some 	 of the statements in that it occurs is always executed when the loop 	 is entered.  This way we know that by moving the load from the 	 reference out of the loop we will not cause the error that would not 	 occur otherwise.  	 TODO -- in fact we would like to check for anticipability of the 	 reference, i.e. that on each path from loop entry to loop exit at 	 least one of the statements containing the memory reference is 	 executed.  */
for|for
control|(
name|aref
operator|=
name|ref
operator|->
name|locs
init|;
name|aref
condition|;
name|aref
operator|=
name|aref
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|LIM_DATA
argument_list|(
name|aref
operator|->
name|stmt
argument_list|)
condition|)
continue|continue;
name|must_exec
operator|=
name|LIM_DATA
argument_list|(
name|aref
operator|->
name|stmt
argument_list|)
operator|->
name|always_executed_in
expr_stmt|;
if|if
condition|(
operator|!
name|must_exec
condition|)
continue|continue;
if|if
condition|(
name|must_exec
operator|==
name|loop
operator|||
name|flow_loop_nested_p
argument_list|(
name|must_exec
argument_list|,
name|loop
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|aref
condition|)
return|return;
block|}
name|schedule_sm
argument_list|(
name|loop
argument_list|,
name|exits
argument_list|,
name|n_exits
argument_list|,
name|ref
operator|->
name|mem
argument_list|,
name|ref
operator|->
name|locs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hoists memory references MEM_REFS out of LOOP.  CLOBBERED_VOPS is the list    of vops clobbered by call in loop or accessed by multiple memory references.    EXITS is the list of N_EXITS exit edges of the LOOP.  */
end_comment

begin_function
specifier|static
name|void
name|hoist_memory_references
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|mem_ref
modifier|*
name|mem_refs
parameter_list|,
name|bitmap
name|clobbered_vops
parameter_list|,
name|edge
modifier|*
name|exits
parameter_list|,
name|unsigned
name|n_exits
parameter_list|)
block|{
name|struct
name|mem_ref
modifier|*
name|ref
decl_stmt|;
for|for
control|(
name|ref
operator|=
name|mem_refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
name|determine_lsm_ref
argument_list|(
name|loop
argument_list|,
name|exits
argument_list|,
name|n_exits
argument_list|,
name|clobbered_vops
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Checks whether LOOP (with N_EXITS exits stored in EXITS array) is suitable    for a store motion optimization (i.e. whether we can insert statement    on its exits).  */
end_comment

begin_function
specifier|static
name|bool
name|loop_suitable_for_sm
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
name|ATTRIBUTE_UNUSED
parameter_list|,
name|edge
modifier|*
name|exits
parameter_list|,
name|unsigned
name|n_exits
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_exits
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|exits
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* A hash function for struct mem_ref object OBJ.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|memref_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|obj
parameter_list|)
block|{
specifier|const
name|struct
name|mem_ref
modifier|*
name|mem
init|=
name|obj
decl_stmt|;
return|return
name|mem
operator|->
name|hash
return|;
block|}
end_function

begin_comment
comment|/* An equality function for struct mem_ref object OBJ1 with    memory reference OBJ2.  */
end_comment

begin_function
specifier|static
name|int
name|memref_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|obj1
parameter_list|,
specifier|const
name|void
modifier|*
name|obj2
parameter_list|)
block|{
specifier|const
name|struct
name|mem_ref
modifier|*
name|mem1
init|=
name|obj1
decl_stmt|;
return|return
name|operand_equal_p
argument_list|(
name|mem1
operator|->
name|mem
argument_list|,
operator|(
name|tree
operator|)
name|obj2
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Gathers memory references in statement STMT in LOOP, storing the    information about them in MEM_REFS hash table.  Note vops accessed through    unrecognized statements in CLOBBERED_VOPS.  The newly created references    are also stored to MEM_REF_LIST.  */
end_comment

begin_function
specifier|static
name|void
name|gather_mem_refs_stmt
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|htab_t
name|mem_refs
parameter_list|,
name|bitmap
name|clobbered_vops
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|struct
name|mem_ref
modifier|*
modifier|*
name|mem_ref_list
parameter_list|)
block|{
name|tree
modifier|*
name|lhs
decl_stmt|,
modifier|*
name|rhs
decl_stmt|,
modifier|*
name|mem
init|=
name|NULL
decl_stmt|;
name|hashval_t
name|hash
decl_stmt|;
name|PTR
modifier|*
name|slot
decl_stmt|;
name|struct
name|mem_ref
modifier|*
name|ref
init|=
name|NULL
decl_stmt|;
name|ssa_op_iter
name|oi
decl_stmt|;
name|tree
name|vname
decl_stmt|;
name|bool
name|is_stored
decl_stmt|;
if|if
condition|(
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_ALL_VIRTUALS
argument_list|)
condition|)
return|return;
comment|/* Recognize MEM = (SSA_NAME | invariant) and SSA_NAME = MEM patterns.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
goto|goto
name|fail
goto|;
name|lhs
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|lhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
if|if
condition|(
operator|!
name|is_gimple_addressable
argument_list|(
operator|*
name|rhs
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|mem
operator|=
name|rhs
expr_stmt|;
name|is_stored
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|rhs
argument_list|)
operator|==
name|SSA_NAME
operator|||
name|is_gimple_min_invariant
argument_list|(
operator|*
name|rhs
argument_list|)
condition|)
block|{
name|mem
operator|=
name|lhs
expr_stmt|;
name|is_stored
operator|=
name|true
expr_stmt|;
block|}
else|else
goto|goto
name|fail
goto|;
comment|/* If we cannot create an SSA name for the result, give up.  */
if|if
condition|(
operator|!
name|is_gimple_reg_type
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|mem
argument_list|)
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
operator|*
name|mem
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* If we cannot move the reference out of the loop, fail.  */
if|if
condition|(
operator|!
name|for_each_index
argument_list|(
name|mem
argument_list|,
name|may_move_till
argument_list|,
name|loop
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|hash
operator|=
name|iterative_hash_expr
argument_list|(
operator|*
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|mem_refs
argument_list|,
operator|*
name|mem
argument_list|,
name|hash
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
name|ref
operator|=
operator|*
name|slot
expr_stmt|;
else|else
block|{
name|ref
operator|=
name|XNEW
argument_list|(
expr|struct
name|mem_ref
argument_list|)
expr_stmt|;
name|ref
operator|->
name|mem
operator|=
operator|*
name|mem
expr_stmt|;
name|ref
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
name|ref
operator|->
name|locs
operator|=
name|NULL
expr_stmt|;
name|ref
operator|->
name|is_stored
operator|=
name|false
expr_stmt|;
name|ref
operator|->
name|vops
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ref
operator|->
name|next
operator|=
operator|*
name|mem_ref_list
expr_stmt|;
operator|*
name|mem_ref_list
operator|=
name|ref
expr_stmt|;
operator|*
name|slot
operator|=
name|ref
expr_stmt|;
block|}
name|ref
operator|->
name|is_stored
operator||=
name|is_stored
expr_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|vname
argument_list|,
argument|stmt
argument_list|,
argument|oi
argument_list|,
argument|SSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_KILLS
argument_list|)
name|bitmap_set_bit
argument_list|(
name|ref
operator|->
name|vops
argument_list|,
name|DECL_UID
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|vname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|record_mem_ref_loc
argument_list|(
operator|&
name|ref
operator|->
name|locs
argument_list|,
name|stmt
argument_list|,
name|mem
argument_list|)
expr_stmt|;
return|return;
name|fail
label|:
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|vname
argument_list|,
argument|stmt
argument_list|,
argument|oi
argument_list|,
argument|SSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_KILLS
argument_list|)
name|bitmap_set_bit
argument_list|(
name|clobbered_vops
argument_list|,
name|DECL_UID
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|vname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gathers memory references in LOOP.  Notes vops accessed through unrecognized    statements in CLOBBERED_VOPS.  The list of the references found by    the function is returned.  */
end_comment

begin_function
specifier|static
name|struct
name|mem_ref
modifier|*
name|gather_mem_refs
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|bitmap
name|clobbered_vops
parameter_list|)
block|{
name|basic_block
modifier|*
name|body
init|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|struct
name|mem_ref
modifier|*
name|mem_ref_list
init|=
name|NULL
decl_stmt|;
name|htab_t
name|mem_refs
init|=
name|htab_create
argument_list|(
literal|100
argument_list|,
name|memref_hash
argument_list|,
name|memref_eq
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|body
index|[
name|i
index|]
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
name|gather_mem_refs_stmt
argument_list|(
name|loop
argument_list|,
name|mem_refs
argument_list|,
name|clobbered_vops
argument_list|,
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|,
operator|&
name|mem_ref_list
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|mem_refs
argument_list|)
expr_stmt|;
return|return
name|mem_ref_list
return|;
block|}
end_function

begin_comment
comment|/* Finds the vops accessed by more than one of the memory references described    in MEM_REFS and marks them in CLOBBERED_VOPS.  */
end_comment

begin_function
specifier|static
name|void
name|find_more_ref_vops
parameter_list|(
name|struct
name|mem_ref
modifier|*
name|mem_refs
parameter_list|,
name|bitmap
name|clobbered_vops
parameter_list|)
block|{
name|bitmap_head
name|tmp
decl_stmt|,
name|all_vops
decl_stmt|;
name|struct
name|mem_ref
modifier|*
name|ref
decl_stmt|;
name|bitmap_initialize
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|bitmap_default_obstack
argument_list|)
expr_stmt|;
name|bitmap_initialize
argument_list|(
operator|&
name|all_vops
argument_list|,
operator|&
name|bitmap_default_obstack
argument_list|)
expr_stmt|;
for|for
control|(
name|ref
operator|=
name|mem_refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
comment|/* The vops that are already in all_vops are accessed by more than 	 one memory reference.  */
name|bitmap_and
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|all_vops
argument_list|,
name|ref
operator|->
name|vops
argument_list|)
expr_stmt|;
name|bitmap_ior_into
argument_list|(
name|clobbered_vops
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|bitmap_ior_into
argument_list|(
operator|&
name|all_vops
argument_list|,
name|ref
operator|->
name|vops
argument_list|)
expr_stmt|;
block|}
name|bitmap_clear
argument_list|(
operator|&
name|all_vops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Releases the memory occupied by REF.  */
end_comment

begin_function
specifier|static
name|void
name|free_mem_ref
parameter_list|(
name|struct
name|mem_ref
modifier|*
name|ref
parameter_list|)
block|{
name|free_mem_ref_locs
argument_list|(
name|ref
operator|->
name|locs
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|ref
operator|->
name|vops
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Releases the memory occupied by REFS.  */
end_comment

begin_function
specifier|static
name|void
name|free_mem_refs
parameter_list|(
name|struct
name|mem_ref
modifier|*
name|refs
parameter_list|)
block|{
name|struct
name|mem_ref
modifier|*
name|ref
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|ref
operator|=
name|refs
init|;
name|ref
condition|;
name|ref
operator|=
name|next
control|)
block|{
name|next
operator|=
name|ref
operator|->
name|next
expr_stmt|;
name|free_mem_ref
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Try to perform store motion for all memory references modified inside    LOOP.  */
end_comment

begin_function
specifier|static
name|void
name|determine_lsm_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|unsigned
name|n_exits
decl_stmt|;
name|edge
modifier|*
name|exits
init|=
name|get_loop_exit_edges
argument_list|(
name|loop
argument_list|,
operator|&
name|n_exits
argument_list|)
decl_stmt|;
name|bitmap
name|clobbered_vops
decl_stmt|;
name|struct
name|mem_ref
modifier|*
name|mem_refs
decl_stmt|;
if|if
condition|(
operator|!
name|loop_suitable_for_sm
argument_list|(
name|loop
argument_list|,
name|exits
argument_list|,
name|n_exits
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|exits
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find the memory references in LOOP.  */
name|clobbered_vops
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mem_refs
operator|=
name|gather_mem_refs
argument_list|(
name|loop
argument_list|,
name|clobbered_vops
argument_list|)
expr_stmt|;
comment|/* Find the vops that are used for more than one reference.  */
name|find_more_ref_vops
argument_list|(
name|mem_refs
argument_list|,
name|clobbered_vops
argument_list|)
expr_stmt|;
comment|/* Hoist all suitable memory references.  */
name|hoist_memory_references
argument_list|(
name|loop
argument_list|,
name|mem_refs
argument_list|,
name|clobbered_vops
argument_list|,
name|exits
argument_list|,
name|n_exits
argument_list|)
expr_stmt|;
name|free_mem_refs
argument_list|(
name|mem_refs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|exits
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|clobbered_vops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to perform store motion for all memory references modified inside    any of LOOPS.  */
end_comment

begin_function
specifier|static
name|void
name|determine_lsm
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
if|if
condition|(
operator|!
name|loops
operator|->
name|tree_root
operator|->
name|inner
condition|)
return|return;
comment|/* Pass the loops from the outermost and perform the store motion as      suitable.  */
name|loop
operator|=
name|loops
operator|->
name|tree_root
operator|->
name|inner
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|determine_lsm_loop
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
block|{
name|loop
operator|=
name|loop
operator|->
name|inner
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
operator|!
name|loop
operator|->
name|next
condition|)
block|{
name|loop
operator|=
name|loop
operator|->
name|outer
expr_stmt|;
if|if
condition|(
name|loop
operator|==
name|loops
operator|->
name|tree_root
condition|)
block|{
name|loop_commit_inserts
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|loop
operator|=
name|loop
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fills ALWAYS_EXECUTED_IN information for basic blocks of LOOP, i.e.    for each such basic block bb records the outermost loop for that execution    of its header implies execution of bb.  CONTAINS_CALL is the bitmap of    blocks that contain a nonpure call.  */
end_comment

begin_function
specifier|static
name|void
name|fill_always_executed_in
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|sbitmap
name|contains_call
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|NULL
decl_stmt|,
modifier|*
name|bbs
decl_stmt|,
name|last
init|=
name|NULL
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|struct
name|loop
modifier|*
name|inn_loop
init|=
name|loop
decl_stmt|;
if|if
condition|(
operator|!
name|loop
operator|->
name|header
operator|->
name|aux
condition|)
block|{
name|bbs
operator|=
name|get_loop_body_in_dom_order
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|bb
operator|=
name|bbs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loop
operator|->
name|latch
argument_list|,
name|bb
argument_list|)
condition|)
name|last
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|contains_call
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
break|break;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
break|break;
if|if
condition|(
name|e
condition|)
break|break;
comment|/* A loop might be infinite (TODO use simple loop analysis 	     to disprove this if possible).  */
if|if
condition|(
name|bb
operator|->
name|flags
operator|&
name|BB_IRREDUCIBLE_LOOP
condition|)
break|break;
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|inn_loop
argument_list|,
name|bb
argument_list|)
condition|)
break|break;
if|if
condition|(
name|bb
operator|->
name|loop_father
operator|->
name|header
operator|==
name|bb
condition|)
block|{
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loop
operator|->
name|latch
argument_list|,
name|bb
argument_list|)
condition|)
break|break;
comment|/* In a loop that is always entered we may proceed anyway. 		 But record that we entered it and stop once we leave it.  */
name|inn_loop
operator|=
name|bb
operator|->
name|loop_father
expr_stmt|;
block|}
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|last
operator|->
name|aux
operator|=
name|loop
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|loop
operator|->
name|header
condition|)
break|break;
name|last
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|loop
operator|=
name|loop
operator|->
name|inner
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|next
control|)
name|fill_always_executed_in
argument_list|(
name|loop
argument_list|,
name|contains_call
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the global information needed by the loop invariant motion pass.    LOOPS is the loop tree.  */
end_comment

begin_function
specifier|static
name|void
name|tree_ssa_lim_initialize
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|sbitmap
name|contains_call
init|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|sbitmap_zero
argument_list|(
name|contains_call
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
if|if
condition|(
name|nonpure_call_p
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|contains_call
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|loop
operator|=
name|loops
operator|->
name|tree_root
operator|->
name|inner
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|next
control|)
name|fill_always_executed_in
argument_list|(
name|loop
argument_list|,
name|contains_call
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|contains_call
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cleans up after the invariant motion pass.  */
end_comment

begin_function
specifier|static
name|void
name|tree_ssa_lim_finalize
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Moves invariants from LOOPS.  Only "expensive" invariants are moved out --    i.e. those that are likely to be win regardless of the register pressure.  */
end_comment

begin_function
name|void
name|tree_ssa_lim
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|tree_ssa_lim_initialize
argument_list|(
name|loops
argument_list|)
expr_stmt|;
comment|/* For each statement determine the outermost loop in that it is      invariant and cost for computing the invariant.  */
name|determine_invariantness
argument_list|()
expr_stmt|;
comment|/* For each memory reference determine whether it is possible to hoist it      out of the loop.  Force the necessary invariants to be moved out of the      loops as well.  */
name|determine_lsm
argument_list|(
name|loops
argument_list|)
expr_stmt|;
comment|/* Move the expressions that are expensive enough.  */
name|move_computations
argument_list|()
expr_stmt|;
name|tree_ssa_lim_finalize
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

