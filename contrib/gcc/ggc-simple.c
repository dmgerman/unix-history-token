begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Simple garbage collection for the GNU compiler.    Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_comment
comment|/* Debugging flags.  */
end_comment

begin_comment
comment|/* Zap memory before freeing to catch dangling pointers.  */
end_comment

begin_define
define|#
directive|define
name|GGC_POISON
end_define

begin_comment
comment|/* Collect statistics on how bushy the search tree is.  */
end_comment

begin_undef
undef|#
directive|undef
name|GGC_BALANCE
end_undef

begin_comment
comment|/* Perform collection every time ggc_collect is invoked.  Otherwise,    collection is performed only when a significant amount of memory    has been allocated since the last collection.  */
end_comment

begin_undef
undef|#
directive|undef
name|GGC_ALWAYS_COLLECT
end_undef

begin_comment
comment|/* Always verify that the to-be-marked memory is collectable.  */
end_comment

begin_undef
undef|#
directive|undef
name|GGC_ALWAYS_VERIFY
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_GC_CHECKING
end_ifdef

begin_define
define|#
directive|define
name|GGC_POISON
end_define

begin_define
define|#
directive|define
name|GGC_ALWAYS_VERIFY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_GC_ALWAYS_COLLECT
end_ifdef

begin_define
define|#
directive|define
name|GGC_ALWAYS_COLLECT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_BITS_PER_PTR
end_ifndef

begin_define
define|#
directive|define
name|HOST_BITS_PER_PTR
value|HOST_BITS_PER_LONG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We'd like a balanced tree, but we don't really want to pay for the    cost of keeping the tree balanced.  We'll settle for the next best    thing -- nearly balanced.     In this context, the most natural key is the node pointer itself,    but due to the way memory managers work, we'd be virtually certain    to wind up with a completely degenerate straight line.  What's needed    is to make something more variable, and yet predictable, be more    significant in the comparison.     The handiest source of variability is the low bits of the pointer    value itself.  Any sort of bit/byte swap would do, but such machine    specific operations are not handy, and we don't want to put that much    effort into it.  */
end_comment

begin_define
define|#
directive|define
name|PTR_KEY
parameter_list|(
name|p
parameter_list|)
value|((size_t)p<< (HOST_BITS_PER_PTR - 8)		    \ 			 | ((size_t)p& 0xff00)<< (HOST_BITS_PER_PTR - 24) \ 			 | (size_t)p>> 16)
end_define

begin_comment
comment|/* GC'able memory; a node in a binary search tree.  */
end_comment

begin_struct
struct|struct
name|ggc_mem
block|{
comment|/* A combination of the standard left/right nodes, indexable by `<'.  */
name|struct
name|ggc_mem
modifier|*
name|sub
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|int
name|mark
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|context
range|:
literal|7
decl_stmt|;
name|unsigned
name|int
name|size
range|:
literal|24
decl_stmt|;
comment|/* Make sure the data is reasonably aligned.  */
union|union
block|{
name|HOST_WIDEST_INT
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LONG_DOUBLE
name|long
name|double
name|d
decl_stmt|;
else|#
directive|else
name|double
name|d
decl_stmt|;
endif|#
directive|endif
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|globals
block|{
comment|/* Root of the object tree.  */
name|struct
name|ggc_mem
modifier|*
name|root
decl_stmt|;
comment|/* Data bytes currently allocated.  */
name|size_t
name|allocated
decl_stmt|;
comment|/* Data objects currently allocated.  */
name|size_t
name|objects
decl_stmt|;
comment|/* Data bytes allocated at time of last GC.  */
name|size_t
name|allocated_last_gc
decl_stmt|;
comment|/* Current context level.  */
name|int
name|context
decl_stmt|;
block|}
name|G
struct|;
end_struct

begin_comment
comment|/* Skip garbage collection if the current allocation is not at least    this factor times the allocation at the end of the last collection.    In other words, total allocation must expand by (this factor minus    one) before collection is performed.  */
end_comment

begin_define
define|#
directive|define
name|GGC_MIN_EXPAND_FOR_GC
value|(1.3)
end_define

begin_comment
comment|/* Bound `allocated_last_gc' to 4MB, to prevent the memory expansion    test from triggering too often when the heap is small.  */
end_comment

begin_define
define|#
directive|define
name|GGC_MIN_LAST_ALLOCATED
value|(4 * 1024 * 1024)
end_define

begin_comment
comment|/* Local function prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|tree_insert
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ggc_mem
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tree_lookup
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ggc_mem
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_marks
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ggc_mem
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sweep_objs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ggc_mem
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ggc_pop_context_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ggc_mem
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For use from debugger.  */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|debug_ggc_tree
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ggc_mem
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GGC_BALANCE
end_ifdef

begin_decl_stmt
specifier|extern
name|void
name|debug_ggc_balance
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|tally_leaves
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ggc_mem
operator|*
operator|,
name|int
operator|,
name|size_t
operator|*
operator|,
name|size_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insert V into the search tree.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|tree_insert
parameter_list|(
name|v
parameter_list|)
name|struct
name|ggc_mem
modifier|*
name|v
decl_stmt|;
block|{
name|size_t
name|v_key
init|=
name|PTR_KEY
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|struct
name|ggc_mem
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|G
operator|.
name|root
operator|,
name|p
operator|=
operator|*
name|pp
init|;
name|p
condition|;
name|p
operator|=
operator|*
name|pp
control|)
block|{
name|size_t
name|p_key
init|=
name|PTR_KEY
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|pp
operator|=
operator|&
name|p
operator|->
name|sub
index|[
name|v_key
operator|<
name|p_key
index|]
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|v
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if V is in the tree.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|tree_lookup
parameter_list|(
name|v
parameter_list|)
name|struct
name|ggc_mem
modifier|*
name|v
decl_stmt|;
block|{
name|size_t
name|v_key
init|=
name|PTR_KEY
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|struct
name|ggc_mem
modifier|*
name|p
init|=
name|G
operator|.
name|root
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|size_t
name|p_key
init|=
name|PTR_KEY
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|v
condition|)
return|return
literal|1
return|;
name|p
operator|=
name|p
operator|->
name|sub
index|[
name|v_key
operator|<
name|p_key
index|]
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Alloc SIZE bytes of GC'able memory.  If ZERO, clear the memory.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_alloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
name|struct
name|ggc_mem
modifier|*
name|x
decl_stmt|;
name|x
operator|=
operator|(
expr|struct
name|ggc_mem
operator|*
operator|)
name|xmalloc
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|ggc_mem
argument_list|,
name|u
argument_list|)
operator|+
name|size
argument_list|)
expr_stmt|;
name|x
operator|->
name|sub
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|x
operator|->
name|sub
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|x
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|context
operator|=
name|G
operator|.
name|context
expr_stmt|;
name|x
operator|->
name|size
operator|=
name|size
expr_stmt|;
ifdef|#
directive|ifdef
name|GGC_POISON
name|memset
argument_list|(
operator|&
name|x
operator|->
name|u
argument_list|,
literal|0xaf
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tree_insert
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|G
operator|.
name|allocated
operator|+=
name|size
expr_stmt|;
name|G
operator|.
name|objects
operator|+=
literal|1
expr_stmt|;
return|return
operator|&
name|x
operator|->
name|u
return|;
block|}
end_function

begin_comment
comment|/* Mark a node.  */
end_comment

begin_function
name|int
name|ggc_set_mark
parameter_list|(
name|p
parameter_list|)
specifier|const
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|ggc_mem
modifier|*
name|x
decl_stmt|;
name|x
operator|=
operator|(
expr|struct
name|ggc_mem
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
operator|-
name|offsetof
argument_list|(
expr|struct
name|ggc_mem
argument_list|,
name|u
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GGC_ALWAYS_VERIFY
if|if
condition|(
operator|!
name|tree_lookup
argument_list|(
name|x
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|x
operator|->
name|mark
condition|)
return|return
literal|1
return|;
name|x
operator|->
name|mark
operator|=
literal|1
expr_stmt|;
name|G
operator|.
name|allocated
operator|+=
name|x
operator|->
name|size
expr_stmt|;
name|G
operator|.
name|objects
operator|+=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if P has been marked, zero otherwise.  */
end_comment

begin_function
name|int
name|ggc_marked_p
parameter_list|(
name|p
parameter_list|)
specifier|const
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|ggc_mem
modifier|*
name|x
decl_stmt|;
name|x
operator|=
operator|(
expr|struct
name|ggc_mem
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
operator|-
name|offsetof
argument_list|(
expr|struct
name|ggc_mem
argument_list|,
name|u
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GGC_ALWAYS_VERIFY
if|if
condition|(
operator|!
name|tree_lookup
argument_list|(
name|x
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|x
operator|->
name|mark
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the gc-able object P.  */
end_comment

begin_function
name|size_t
name|ggc_get_size
parameter_list|(
name|p
parameter_list|)
specifier|const
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|ggc_mem
modifier|*
name|x
init|=
operator|(
expr|struct
name|ggc_mem
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
operator|-
name|offsetof
argument_list|(
expr|struct
name|ggc_mem
argument_list|,
name|u
argument_list|)
operator|)
decl_stmt|;
return|return
name|x
operator|->
name|size
return|;
block|}
end_function

begin_comment
comment|/* Unmark all objects.  */
end_comment

begin_function
specifier|static
name|void
name|clear_marks
parameter_list|(
name|x
parameter_list|)
name|struct
name|ggc_mem
modifier|*
name|x
decl_stmt|;
block|{
name|x
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|sub
index|[
literal|0
index|]
condition|)
name|clear_marks
argument_list|(
name|x
operator|->
name|sub
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|sub
index|[
literal|1
index|]
condition|)
name|clear_marks
argument_list|(
name|x
operator|->
name|sub
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all objects in the current context that are not marked.  */
end_comment

begin_function
specifier|static
name|void
name|sweep_objs
parameter_list|(
name|root
parameter_list|)
name|struct
name|ggc_mem
modifier|*
modifier|*
name|root
decl_stmt|;
block|{
name|struct
name|ggc_mem
modifier|*
name|x
init|=
operator|*
name|root
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return;
name|sweep_objs
argument_list|(
operator|&
name|x
operator|->
name|sub
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sweep_objs
argument_list|(
operator|&
name|x
operator|->
name|sub
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
operator|->
name|mark
operator|&&
name|x
operator|->
name|context
operator|>=
name|G
operator|.
name|context
condition|)
block|{
name|struct
name|ggc_mem
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|l
operator|=
name|x
operator|->
name|sub
index|[
literal|0
index|]
expr_stmt|;
name|r
operator|=
name|x
operator|->
name|sub
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
operator|*
name|root
operator|=
name|r
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|r
condition|)
operator|*
name|root
operator|=
name|l
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|l
operator|->
name|sub
index|[
literal|1
index|]
condition|)
block|{
operator|*
name|root
operator|=
name|l
expr_stmt|;
name|l
operator|->
name|sub
index|[
literal|1
index|]
operator|=
name|r
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|r
operator|->
name|sub
index|[
literal|0
index|]
condition|)
block|{
operator|*
name|root
operator|=
name|r
expr_stmt|;
name|r
operator|->
name|sub
index|[
literal|0
index|]
operator|=
name|l
expr_stmt|;
block|}
else|else
block|{
operator|*
name|root
operator|=
name|l
expr_stmt|;
do|do
block|{
name|root
operator|=
operator|&
name|l
operator|->
name|sub
index|[
literal|1
index|]
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|l
operator|=
operator|*
name|root
operator|)
operator|!=
name|NULL
condition|)
do|;
operator|*
name|root
operator|=
name|r
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GGC_POISON
name|memset
argument_list|(
operator|&
name|x
operator|->
name|u
argument_list|,
literal|0xA5
argument_list|,
name|x
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The top level mark-and-sweep routine.  */
end_comment

begin_function
name|void
name|ggc_collect
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|GGC_ALWAYS_COLLECT
if|if
condition|(
name|G
operator|.
name|allocated
operator|<
name|GGC_MIN_EXPAND_FOR_GC
operator|*
name|G
operator|.
name|allocated_last_gc
condition|)
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GGC_BALANCE
name|debug_ggc_balance
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|timevar_push
argument_list|(
name|TV_GC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" {GC %luk -> "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|G
operator|.
name|allocated
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|G
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
name|G
operator|.
name|objects
operator|=
literal|0
expr_stmt|;
name|clear_marks
argument_list|(
name|G
operator|.
name|root
argument_list|)
expr_stmt|;
name|ggc_mark_roots
argument_list|()
expr_stmt|;
name|sweep_objs
argument_list|(
operator|&
name|G
operator|.
name|root
argument_list|)
expr_stmt|;
name|G
operator|.
name|allocated_last_gc
operator|=
name|G
operator|.
name|allocated
expr_stmt|;
if|if
condition|(
name|G
operator|.
name|allocated_last_gc
operator|<
name|GGC_MIN_LAST_ALLOCATED
condition|)
name|G
operator|.
name|allocated_last_gc
operator|=
name|GGC_MIN_LAST_ALLOCATED
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_GC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%luk}"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|G
operator|.
name|allocated
operator|/
literal|1024
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GGC_BALANCE
name|debug_ggc_balance
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Called once to initialize the garbage collector.  */
end_comment

begin_function
name|void
name|init_ggc
parameter_list|()
block|{
name|G
operator|.
name|allocated_last_gc
operator|=
name|GGC_MIN_LAST_ALLOCATED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start a new GGC context.  Memory allocated in previous contexts    will not be collected while the new context is active.  */
end_comment

begin_function
name|void
name|ggc_push_context
parameter_list|()
block|{
name|G
operator|.
name|context
operator|++
expr_stmt|;
comment|/* We only allocated 7 bits in the node for the context.  This      should be more than enough.  */
if|if
condition|(
name|G
operator|.
name|context
operator|>=
literal|128
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a GC context.  Any uncollected memory in the new context    will be merged with the old context.  */
end_comment

begin_function
name|void
name|ggc_pop_context
parameter_list|()
block|{
name|G
operator|.
name|context
operator|--
expr_stmt|;
if|if
condition|(
name|G
operator|.
name|root
condition|)
name|ggc_pop_context_1
argument_list|(
name|G
operator|.
name|root
argument_list|,
name|G
operator|.
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ggc_pop_context_1
parameter_list|(
name|x
parameter_list|,
name|c
parameter_list|)
name|struct
name|ggc_mem
modifier|*
name|x
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|->
name|context
operator|>
name|c
condition|)
name|x
operator|->
name|context
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|sub
index|[
literal|0
index|]
condition|)
name|ggc_pop_context_1
argument_list|(
name|x
operator|->
name|sub
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|sub
index|[
literal|1
index|]
condition|)
name|ggc_pop_context_1
argument_list|(
name|x
operator|->
name|sub
index|[
literal|1
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump a tree.  */
end_comment

begin_function
name|void
name|debug_ggc_tree
parameter_list|(
name|p
parameter_list|,
name|indent
parameter_list|)
name|struct
name|ggc_mem
modifier|*
name|p
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|fputs
argument_list|(
literal|"(nil)\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|sub
index|[
literal|0
index|]
condition|)
name|debug_ggc_tree
argument_list|(
name|p
operator|->
name|sub
index|[
literal|0
index|]
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indent
condition|;
operator|++
name|i
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lx %p\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|PTR_KEY
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|sub
index|[
literal|1
index|]
condition|)
name|debug_ggc_tree
argument_list|(
name|p
operator|->
name|sub
index|[
literal|1
index|]
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GGC_BALANCE
end_ifdef

begin_comment
comment|/* Collect tree balance metrics  */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_function
name|void
name|debug_ggc_balance
parameter_list|()
block|{
name|size_t
name|nleaf
decl_stmt|,
name|sumdepth
decl_stmt|;
name|nleaf
operator|=
name|sumdepth
operator|=
literal|0
expr_stmt|;
name|tally_leaves
argument_list|(
name|G
operator|.
name|root
argument_list|,
literal|0
argument_list|,
operator|&
name|nleaf
argument_list|,
operator|&
name|sumdepth
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" {B %.2f,%.1f,%.1f}"
argument_list|,
comment|/* In a balanced tree, leaf/node should approach 1/2.  */
operator|(
name|float
operator|)
name|nleaf
operator|/
operator|(
name|float
operator|)
name|G
operator|.
name|objects
argument_list|,
comment|/* In a balanced tree, average leaf depth should approach lg(n).  */
operator|(
name|float
operator|)
name|sumdepth
operator|/
operator|(
name|float
operator|)
name|nleaf
argument_list|,
name|log
argument_list|(
operator|(
name|double
operator|)
name|G
operator|.
name|objects
argument_list|)
operator|/
name|M_LN2
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Used by debug_ggc_balance, and also by ggc_print_statistics.  */
end_comment

begin_function
specifier|static
name|void
name|tally_leaves
parameter_list|(
name|x
parameter_list|,
name|depth
parameter_list|,
name|nleaf
parameter_list|,
name|sumdepth
parameter_list|)
name|struct
name|ggc_mem
modifier|*
name|x
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|size_t
modifier|*
name|nleaf
decl_stmt|;
name|size_t
modifier|*
name|sumdepth
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|x
operator|->
name|sub
index|[
literal|0
index|]
operator|&&
operator|!
name|x
operator|->
name|sub
index|[
literal|1
index|]
condition|)
block|{
operator|*
name|nleaf
operator|+=
literal|1
expr_stmt|;
operator|*
name|sumdepth
operator|+=
name|depth
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|x
operator|->
name|sub
index|[
literal|0
index|]
condition|)
name|tally_leaves
argument_list|(
name|x
operator|->
name|sub
index|[
literal|0
index|]
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|nleaf
argument_list|,
name|sumdepth
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|sub
index|[
literal|1
index|]
condition|)
name|tally_leaves
argument_list|(
name|x
operator|->
name|sub
index|[
literal|1
index|]
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|nleaf
argument_list|,
name|sumdepth
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|SCALE
parameter_list|(
name|x
parameter_list|)
value|((unsigned long) ((x)< 1024*10 \ 		  ? (x) \ 		  : ((x)< 1024*1024*10 \ 		     ? (x) / 1024 \ 		     : (x) / (1024*1024))))
end_define

begin_define
define|#
directive|define
name|LABEL
parameter_list|(
name|x
parameter_list|)
value|((x)< 1024*10 ? ' ' : ((x)< 1024*1024*10 ? 'k' : 'M'))
end_define

begin_comment
comment|/* Report on GC memory usage.  */
end_comment

begin_function
name|void
name|ggc_print_statistics
parameter_list|()
block|{
name|struct
name|ggc_statistics
name|stats
decl_stmt|;
name|size_t
name|nleaf
init|=
literal|0
decl_stmt|,
name|sumdepth
init|=
literal|0
decl_stmt|;
comment|/* Clear the statistics.  */
name|memset
argument_list|(
operator|&
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure collection will really occur.  */
name|G
operator|.
name|allocated_last_gc
operator|=
literal|0
expr_stmt|;
comment|/* Collect and print the statistics common across collectors.  */
name|ggc_print_common_statistics
argument_list|(
name|stderr
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
comment|/* Report on tree balancing.  */
name|tally_leaves
argument_list|(
name|G
operator|.
name|root
argument_list|,
literal|0
argument_list|,
operator|&
name|nleaf
argument_list|,
operator|&
name|sumdepth
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\ Total internal data (bytes)\t%ld%c\n\ Number of leaves in tree\t%d\n\ Average leaf depth\t\t%.1f\n"
argument_list|,
name|SCALE
argument_list|(
name|G
operator|.
name|objects
operator|*
name|offsetof
argument_list|(
expr|struct
name|ggc_mem
argument_list|,
name|u
argument_list|)
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|G
operator|.
name|objects
operator|*
name|offsetof
argument_list|(
expr|struct
name|ggc_mem
argument_list|,
name|u
argument_list|)
argument_list|)
argument_list|,
name|nleaf
argument_list|,
operator|(
name|double
operator|)
name|sumdepth
operator|/
operator|(
name|double
operator|)
name|nleaf
argument_list|)
expr_stmt|;
comment|/* Report overall memory usage.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\ Total objects allocated\t\t%d\n\ Total memory in GC arena\t%ld%c\n"
argument_list|,
name|G
operator|.
name|objects
argument_list|,
name|SCALE
argument_list|(
name|G
operator|.
name|allocated
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|G
operator|.
name|allocated
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

