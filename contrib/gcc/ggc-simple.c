begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Simple garbage collection for the GNU compiler.    Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003    Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_comment
comment|/* Debugging flags.  */
end_comment

begin_comment
comment|/* Zap memory before freeing to catch dangling pointers.  */
end_comment

begin_undef
undef|#
directive|undef
name|GGC_POISON
end_undef

begin_comment
comment|/* Collect statistics on how bushy the search tree is.  */
end_comment

begin_undef
undef|#
directive|undef
name|GGC_BALANCE
end_undef

begin_comment
comment|/* Always verify that the to-be-marked memory is collectable.  */
end_comment

begin_undef
undef|#
directive|undef
name|GGC_ALWAYS_VERIFY
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_GC_CHECKING
end_ifdef

begin_define
define|#
directive|define
name|GGC_POISON
end_define

begin_define
define|#
directive|define
name|GGC_ALWAYS_VERIFY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_BITS_PER_PTR
end_ifndef

begin_define
define|#
directive|define
name|HOST_BITS_PER_PTR
value|HOST_BITS_PER_LONG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We'd like a balanced tree, but we don't really want to pay for the    cost of keeping the tree balanced.  We'll settle for the next best    thing -- nearly balanced.     In this context, the most natural key is the node pointer itself,    but due to the way memory managers work, we'd be virtually certain    to wind up with a completely degenerate straight line.  What's needed    is to make something more variable, and yet predictable, be more    significant in the comparison.     The handiest source of variability is the low bits of the pointer    value itself.  Any sort of bit/byte swap would do, but such machine    specific operations are not handy, and we don't want to put that much    effort into it.  */
end_comment

begin_define
define|#
directive|define
name|PTR_KEY
parameter_list|(
name|p
parameter_list|)
value|((size_t)p<< (HOST_BITS_PER_PTR - 8)		    \ 			 | ((size_t)p& 0xff00)<< (HOST_BITS_PER_PTR - 24) \ 			 | (size_t)p>> 16)
end_define

begin_comment
comment|/* GC'able memory; a node in a binary search tree.  */
end_comment

begin_struct
struct|struct
name|ggc_mem
block|{
comment|/* A combination of the standard left/right nodes, indexable by `<'.  */
name|struct
name|ggc_mem
modifier|*
name|sub
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|int
name|mark
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|context
range|:
literal|7
decl_stmt|;
name|unsigned
name|int
name|size
range|:
literal|24
decl_stmt|;
comment|/* Make sure the data is reasonably aligned.  */
union|union
block|{
name|HOST_WIDEST_INT
name|i
decl_stmt|;
name|long
name|double
name|d
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|globals
block|{
comment|/* Root of the object tree.  */
name|struct
name|ggc_mem
modifier|*
name|root
decl_stmt|;
comment|/* Data bytes currently allocated.  */
name|size_t
name|allocated
decl_stmt|;
comment|/* Data objects currently allocated.  */
name|size_t
name|objects
decl_stmt|;
comment|/* Data bytes allocated at time of last GC.  */
name|size_t
name|allocated_last_gc
decl_stmt|;
comment|/* Current context level.  */
name|int
name|context
decl_stmt|;
block|}
name|G
struct|;
end_struct

begin_comment
comment|/* Local function prototypes.  */
end_comment

begin_function_decl
specifier|static
name|void
name|tree_insert
parameter_list|(
name|struct
name|ggc_mem
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tree_lookup
parameter_list|(
name|struct
name|ggc_mem
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_marks
parameter_list|(
name|struct
name|ggc_mem
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sweep_objs
parameter_list|(
name|struct
name|ggc_mem
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ggc_pop_context_1
parameter_list|(
name|struct
name|ggc_mem
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* For use from debugger.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|debug_ggc_tree
parameter_list|(
name|struct
name|ggc_mem
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|GGC_BALANCE
end_ifdef

begin_function_decl
specifier|extern
name|void
name|debug_ggc_balance
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|tally_leaves
parameter_list|(
name|struct
name|ggc_mem
modifier|*
parameter_list|,
name|int
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|alloc_zone
modifier|*
name|rtl_zone
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|alloc_zone
modifier|*
name|tree_zone
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|alloc_zone
modifier|*
name|garbage_zone
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insert V into the search tree.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|tree_insert
parameter_list|(
name|struct
name|ggc_mem
modifier|*
name|v
parameter_list|)
block|{
name|size_t
name|v_key
init|=
name|PTR_KEY
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|struct
name|ggc_mem
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|G
operator|.
name|root
operator|,
name|p
operator|=
operator|*
name|pp
init|;
name|p
condition|;
name|p
operator|=
operator|*
name|pp
control|)
block|{
name|size_t
name|p_key
init|=
name|PTR_KEY
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|pp
operator|=
operator|&
name|p
operator|->
name|sub
index|[
name|v_key
operator|<
name|p_key
index|]
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|v
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if V is in the tree.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|tree_lookup
parameter_list|(
name|struct
name|ggc_mem
modifier|*
name|v
parameter_list|)
block|{
name|size_t
name|v_key
init|=
name|PTR_KEY
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|struct
name|ggc_mem
modifier|*
name|p
init|=
name|G
operator|.
name|root
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|size_t
name|p_key
init|=
name|PTR_KEY
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|v
condition|)
return|return
literal|1
return|;
name|p
operator|=
name|p
operator|->
name|sub
index|[
name|v_key
operator|<
name|p_key
index|]
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Typed allocation function.  Does nothing special in this collector.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_alloc_typed
parameter_list|(
name|enum
name|gt_types_enum
name|type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
name|ggc_alloc
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Zone allocation function.  Does nothing special in this collector.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_alloc_zone
parameter_list|(
name|size_t
name|size
parameter_list|,
name|struct
name|alloc_zone
modifier|*
name|zone
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|ggc_alloc
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Alloc SIZE bytes of GC'able memory.  If ZERO, clear the memory.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|ggc_mem
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|xmalloc
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|ggc_mem
argument_list|,
name|u
argument_list|)
operator|+
name|size
argument_list|)
expr_stmt|;
name|x
operator|->
name|sub
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|x
operator|->
name|sub
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|x
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|context
operator|=
name|G
operator|.
name|context
expr_stmt|;
name|x
operator|->
name|size
operator|=
name|size
expr_stmt|;
ifdef|#
directive|ifdef
name|GGC_POISON
name|memset
argument_list|(
operator|&
name|x
operator|->
name|u
argument_list|,
literal|0xaf
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tree_insert
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|G
operator|.
name|allocated
operator|+=
name|size
expr_stmt|;
name|G
operator|.
name|objects
operator|+=
literal|1
expr_stmt|;
return|return
operator|&
name|x
operator|->
name|u
return|;
block|}
end_function

begin_comment
comment|/* Mark a node.  */
end_comment

begin_function
name|int
name|ggc_set_mark
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ggc_mem
modifier|*
name|x
decl_stmt|;
name|x
operator|=
operator|(
expr|struct
name|ggc_mem
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
operator|-
name|offsetof
argument_list|(
expr|struct
name|ggc_mem
argument_list|,
name|u
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GGC_ALWAYS_VERIFY
if|if
condition|(
operator|!
name|tree_lookup
argument_list|(
name|x
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|x
operator|->
name|mark
condition|)
return|return
literal|1
return|;
name|x
operator|->
name|mark
operator|=
literal|1
expr_stmt|;
name|G
operator|.
name|allocated
operator|+=
name|x
operator|->
name|size
expr_stmt|;
name|G
operator|.
name|objects
operator|+=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if P has been marked, zero otherwise.  */
end_comment

begin_function
name|int
name|ggc_marked_p
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ggc_mem
modifier|*
name|x
decl_stmt|;
name|x
operator|=
operator|(
expr|struct
name|ggc_mem
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
operator|-
name|offsetof
argument_list|(
expr|struct
name|ggc_mem
argument_list|,
name|u
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GGC_ALWAYS_VERIFY
if|if
condition|(
operator|!
name|tree_lookup
argument_list|(
name|x
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|x
operator|->
name|mark
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the gc-able object P.  */
end_comment

begin_function
name|size_t
name|ggc_get_size
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ggc_mem
modifier|*
name|x
init|=
operator|(
expr|struct
name|ggc_mem
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
operator|-
name|offsetof
argument_list|(
expr|struct
name|ggc_mem
argument_list|,
name|u
argument_list|)
operator|)
decl_stmt|;
return|return
name|x
operator|->
name|size
return|;
block|}
end_function

begin_comment
comment|/* Unmark all objects.  */
end_comment

begin_function
specifier|static
name|void
name|clear_marks
parameter_list|(
name|struct
name|ggc_mem
modifier|*
name|x
parameter_list|)
block|{
name|x
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|sub
index|[
literal|0
index|]
condition|)
name|clear_marks
argument_list|(
name|x
operator|->
name|sub
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|sub
index|[
literal|1
index|]
condition|)
name|clear_marks
argument_list|(
name|x
operator|->
name|sub
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all objects in the current context that are not marked.  */
end_comment

begin_function
specifier|static
name|void
name|sweep_objs
parameter_list|(
name|struct
name|ggc_mem
modifier|*
modifier|*
name|root
parameter_list|)
block|{
name|struct
name|ggc_mem
modifier|*
name|x
init|=
operator|*
name|root
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return;
name|sweep_objs
argument_list|(
operator|&
name|x
operator|->
name|sub
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sweep_objs
argument_list|(
operator|&
name|x
operator|->
name|sub
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
operator|->
name|mark
operator|&&
name|x
operator|->
name|context
operator|>=
name|G
operator|.
name|context
condition|)
block|{
name|struct
name|ggc_mem
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|l
operator|=
name|x
operator|->
name|sub
index|[
literal|0
index|]
expr_stmt|;
name|r
operator|=
name|x
operator|->
name|sub
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
operator|*
name|root
operator|=
name|r
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|r
condition|)
operator|*
name|root
operator|=
name|l
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|l
operator|->
name|sub
index|[
literal|1
index|]
condition|)
block|{
operator|*
name|root
operator|=
name|l
expr_stmt|;
name|l
operator|->
name|sub
index|[
literal|1
index|]
operator|=
name|r
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|r
operator|->
name|sub
index|[
literal|0
index|]
condition|)
block|{
operator|*
name|root
operator|=
name|r
expr_stmt|;
name|r
operator|->
name|sub
index|[
literal|0
index|]
operator|=
name|l
expr_stmt|;
block|}
else|else
block|{
operator|*
name|root
operator|=
name|l
expr_stmt|;
do|do
block|{
name|root
operator|=
operator|&
name|l
operator|->
name|sub
index|[
literal|1
index|]
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|l
operator|=
operator|*
name|root
operator|)
operator|!=
name|NULL
condition|)
do|;
operator|*
name|root
operator|=
name|r
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GGC_POISON
name|memset
argument_list|(
operator|&
name|x
operator|->
name|u
argument_list|,
literal|0xA5
argument_list|,
name|x
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The top level mark-and-sweep routine.  */
end_comment

begin_function
name|void
name|ggc_collect
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Avoid frequent unnecessary work by skipping collection if the      total allocations haven't expanded much since the last      collection.  */
name|size_t
name|allocated_last_gc
init|=
name|MAX
argument_list|(
name|G
operator|.
name|allocated_last_gc
argument_list|,
operator|(
name|size_t
operator|)
name|PARAM_VALUE
argument_list|(
name|GGC_MIN_HEAPSIZE
argument_list|)
operator|*
literal|1024
argument_list|)
decl_stmt|;
name|size_t
name|min_expand
init|=
name|allocated_last_gc
operator|*
name|PARAM_VALUE
argument_list|(
name|GGC_MIN_EXPAND
argument_list|)
operator|/
literal|100
decl_stmt|;
if|if
condition|(
name|G
operator|.
name|allocated
operator|<
name|allocated_last_gc
operator|+
name|min_expand
condition|)
return|return;
ifdef|#
directive|ifdef
name|GGC_BALANCE
name|debug_ggc_balance
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|timevar_push
argument_list|(
name|TV_GC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" {GC %luk -> "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|G
operator|.
name|allocated
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|G
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
name|G
operator|.
name|objects
operator|=
literal|0
expr_stmt|;
name|clear_marks
argument_list|(
name|G
operator|.
name|root
argument_list|)
expr_stmt|;
name|ggc_mark_roots
argument_list|()
expr_stmt|;
name|sweep_objs
argument_list|(
operator|&
name|G
operator|.
name|root
argument_list|)
expr_stmt|;
name|G
operator|.
name|allocated_last_gc
operator|=
name|G
operator|.
name|allocated
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_GC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%luk}"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|G
operator|.
name|allocated
operator|/
literal|1024
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GGC_BALANCE
name|debug_ggc_balance
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Called once to initialize the garbage collector.  */
end_comment

begin_function
name|void
name|init_ggc
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Start a new GGC zone.  */
end_comment

begin_function
name|struct
name|alloc_zone
modifier|*
name|new_ggc_zone
parameter_list|(
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Destroy a GGC zone.  */
end_comment

begin_function
name|void
name|destroy_ggc_zone
parameter_list|(
name|struct
name|alloc_zone
modifier|*
name|zone
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Start a new GGC context.  Memory allocated in previous contexts    will not be collected while the new context is active.  */
end_comment

begin_function
name|void
name|ggc_push_context
parameter_list|(
name|void
parameter_list|)
block|{
name|G
operator|.
name|context
operator|++
expr_stmt|;
comment|/* We only allocated 7 bits in the node for the context.  This      should be more than enough.  */
if|if
condition|(
name|G
operator|.
name|context
operator|>=
literal|128
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a GC context.  Any uncollected memory in the new context    will be merged with the old context.  */
end_comment

begin_function
name|void
name|ggc_pop_context
parameter_list|(
name|void
parameter_list|)
block|{
name|G
operator|.
name|context
operator|--
expr_stmt|;
if|if
condition|(
name|G
operator|.
name|root
condition|)
name|ggc_pop_context_1
argument_list|(
name|G
operator|.
name|root
argument_list|,
name|G
operator|.
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ggc_pop_context_1
parameter_list|(
name|struct
name|ggc_mem
modifier|*
name|x
parameter_list|,
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|x
operator|->
name|context
operator|>
name|c
condition|)
name|x
operator|->
name|context
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|sub
index|[
literal|0
index|]
condition|)
name|ggc_pop_context_1
argument_list|(
name|x
operator|->
name|sub
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|sub
index|[
literal|1
index|]
condition|)
name|ggc_pop_context_1
argument_list|(
name|x
operator|->
name|sub
index|[
literal|1
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump a tree.  */
end_comment

begin_function
name|void
name|debug_ggc_tree
parameter_list|(
name|struct
name|ggc_mem
modifier|*
name|p
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|fputs
argument_list|(
literal|"(nil)\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|sub
index|[
literal|0
index|]
condition|)
name|debug_ggc_tree
argument_list|(
name|p
operator|->
name|sub
index|[
literal|0
index|]
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indent
condition|;
operator|++
name|i
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lx %p\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|PTR_KEY
argument_list|(
name|p
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|sub
index|[
literal|1
index|]
condition|)
name|debug_ggc_tree
argument_list|(
name|p
operator|->
name|sub
index|[
literal|1
index|]
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GGC_BALANCE
end_ifdef

begin_comment
comment|/* Collect tree balance metrics  */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_function
name|void
name|debug_ggc_balance
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|nleaf
decl_stmt|,
name|sumdepth
decl_stmt|;
name|nleaf
operator|=
name|sumdepth
operator|=
literal|0
expr_stmt|;
name|tally_leaves
argument_list|(
name|G
operator|.
name|root
argument_list|,
literal|0
argument_list|,
operator|&
name|nleaf
argument_list|,
operator|&
name|sumdepth
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" {B %.2f,%.1f,%.1f}"
argument_list|,
comment|/* In a balanced tree, leaf/node should approach 1/2.  */
operator|(
name|float
operator|)
name|nleaf
operator|/
operator|(
name|float
operator|)
name|G
operator|.
name|objects
argument_list|,
comment|/* In a balanced tree, average leaf depth should approach lg(n).  */
operator|(
name|float
operator|)
name|sumdepth
operator|/
operator|(
name|float
operator|)
name|nleaf
argument_list|,
name|log
argument_list|(
operator|(
name|double
operator|)
name|G
operator|.
name|objects
argument_list|)
operator|/
name|M_LN2
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Used by debug_ggc_balance, and also by ggc_print_statistics.  */
end_comment

begin_function
specifier|static
name|void
name|tally_leaves
parameter_list|(
name|struct
name|ggc_mem
modifier|*
name|x
parameter_list|,
name|int
name|depth
parameter_list|,
name|size_t
modifier|*
name|nleaf
parameter_list|,
name|size_t
modifier|*
name|sumdepth
parameter_list|)
block|{
if|if
condition|(
operator|!
name|x
operator|->
name|sub
index|[
literal|0
index|]
operator|&&
operator|!
name|x
operator|->
name|sub
index|[
literal|1
index|]
condition|)
block|{
operator|*
name|nleaf
operator|+=
literal|1
expr_stmt|;
operator|*
name|sumdepth
operator|+=
name|depth
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|x
operator|->
name|sub
index|[
literal|0
index|]
condition|)
name|tally_leaves
argument_list|(
name|x
operator|->
name|sub
index|[
literal|0
index|]
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|nleaf
argument_list|,
name|sumdepth
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|sub
index|[
literal|1
index|]
condition|)
name|tally_leaves
argument_list|(
name|x
operator|->
name|sub
index|[
literal|1
index|]
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|nleaf
argument_list|,
name|sumdepth
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|SCALE
parameter_list|(
name|x
parameter_list|)
value|((unsigned long) ((x)< 1024*10 \ 		  ? (x) \ 		  : ((x)< 1024*1024*10 \ 		     ? (x) / 1024 \ 		     : (x) / (1024*1024))))
end_define

begin_define
define|#
directive|define
name|LABEL
parameter_list|(
name|x
parameter_list|)
value|((x)< 1024*10 ? ' ' : ((x)< 1024*1024*10 ? 'k' : 'M'))
end_define

begin_comment
comment|/* Report on GC memory usage.  */
end_comment

begin_function
name|void
name|ggc_print_statistics
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ggc_statistics
name|stats
decl_stmt|;
name|size_t
name|nleaf
init|=
literal|0
decl_stmt|,
name|sumdepth
init|=
literal|0
decl_stmt|;
comment|/* Clear the statistics.  */
name|memset
argument_list|(
operator|&
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure collection will really occur.  */
name|G
operator|.
name|allocated_last_gc
operator|=
literal|0
expr_stmt|;
comment|/* Collect and print the statistics common across collectors.  */
name|ggc_print_common_statistics
argument_list|(
name|stderr
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
comment|/* Report on tree balancing.  */
name|tally_leaves
argument_list|(
name|G
operator|.
name|root
argument_list|,
literal|0
argument_list|,
operator|&
name|nleaf
argument_list|,
operator|&
name|sumdepth
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\ Total internal data (bytes)\t%ld%c\n\ Number of leaves in tree\t%lu\n\ Average leaf depth\t\t%.1f\n"
argument_list|,
name|SCALE
argument_list|(
name|G
operator|.
name|objects
operator|*
name|offsetof
argument_list|(
expr|struct
name|ggc_mem
argument_list|,
name|u
argument_list|)
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|G
operator|.
name|objects
operator|*
name|offsetof
argument_list|(
expr|struct
name|ggc_mem
argument_list|,
name|u
argument_list|)
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|nleaf
argument_list|,
operator|(
name|double
operator|)
name|sumdepth
operator|/
operator|(
name|double
operator|)
name|nleaf
argument_list|)
expr_stmt|;
comment|/* Report overall memory usage.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\ Total objects allocated\t\t%ld\n\ Total memory in GC arena\t%ld%c\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|G
operator|.
name|objects
argument_list|,
name|SCALE
argument_list|(
name|G
operator|.
name|allocated
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|G
operator|.
name|allocated
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|struct
name|ggc_pch_data
modifier|*
name|init_ggc_pch
parameter_list|(
name|void
parameter_list|)
block|{
name|sorry
argument_list|(
literal|"Generating PCH files is not supported when using ggc-simple.c"
argument_list|)
expr_stmt|;
comment|/* It could be supported, but the code is not yet written.  */
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|ggc_pch_count_object
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|x
name|ATTRIBUTE_UNUSED
parameter_list|,
name|size_t
name|size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
name|is_string
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_function
name|size_t
name|ggc_pch_total_size
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ggc_pch_this_base
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|base
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_function
name|char
modifier|*
name|ggc_pch_alloc_object
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|x
name|ATTRIBUTE_UNUSED
parameter_list|,
name|size_t
name|size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
name|is_string
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|ggc_pch_prepare_write
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
name|ATTRIBUTE_UNUSED
parameter_list|,
name|FILE
modifier|*
name|f
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ggc_pch_write_object
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
name|ATTRIBUTE_UNUSED
parameter_list|,
name|FILE
modifier|*
name|f
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|x
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|newx
name|ATTRIBUTE_UNUSED
parameter_list|,
name|size_t
name|size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
name|is_string
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ggc_pch_finish
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
name|ATTRIBUTE_UNUSED
parameter_list|,
name|FILE
modifier|*
name|f
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ggc_pch_read
parameter_list|(
name|FILE
modifier|*
name|f
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|addr
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* This should be impossible, since we won't generate any valid PCH      files for this configuration.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

