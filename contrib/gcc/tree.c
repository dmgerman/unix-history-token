begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Language-independent node constructors for parse phase of GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file contains the low level primitives for operating on tree nodes,    including allocation, list operations, interning of identifiers,    construction of data type nodes and statement nodes,    and construction of type conversion nodes.  It also contains    tables index by tree code that describe how to take apart    nodes of that code.     It is intended to be language-independent, but occasionally    calls language-dependent routines defined (for C) in typecheck.c.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"pointer-set.h"
end_include

begin_comment
comment|/* Each tree code class has an associated string representation.    These must correspond to the tree_code_class entries.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|tree_code_class_strings
index|[]
init|=
block|{
literal|"exceptional"
block|,
literal|"constant"
block|,
literal|"type"
block|,
literal|"declaration"
block|,
literal|"reference"
block|,
literal|"comparison"
block|,
literal|"unary"
block|,
literal|"binary"
block|,
literal|"statement"
block|,
literal|"expression"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* obstack.[ch] explicitly declined to prototype this.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|_obstack_allocated_p
parameter_list|(
name|struct
name|obstack
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_comment
comment|/* Statistics-gathering stuff.  */
end_comment

begin_decl_stmt
name|int
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|all_kinds
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|all_kinds
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep in sync with tree.h:enum tree_node_kind.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tree_node_kind_names
index|[]
init|=
block|{
literal|"decls"
block|,
literal|"types"
block|,
literal|"blocks"
block|,
literal|"stmts"
block|,
literal|"refs"
block|,
literal|"exprs"
block|,
literal|"constants"
block|,
literal|"identifiers"
block|,
literal|"perm_tree_lists"
block|,
literal|"temp_tree_lists"
block|,
literal|"vecs"
block|,
literal|"binfos"
block|,
literal|"phi_nodes"
block|,
literal|"ssa names"
block|,
literal|"constructors"
block|,
literal|"random kinds"
block|,
literal|"lang_decl kinds"
block|,
literal|"lang_type kinds"
block|,
literal|"omp clauses"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GATHER_STATISTICS */
end_comment

begin_comment
comment|/* Unique id for next decl created.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|next_decl_uid
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Unique id for next type created.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|next_type_uid
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Since we cannot rehash a type after it is in the table, we have to    keep the hash code.  */
end_comment

begin_decl_stmt
name|struct
name|type_hash
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|unsigned
name|long
name|hash
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Initial size of the hash table (rounded to next prime).  */
end_comment

begin_define
define|#
directive|define
name|TYPE_HASH_INITIAL_SIZE
value|1000
end_define

begin_comment
comment|/* Now here is the hash table.  When recording a type, it is added to    the slot whose index is the hash code.  Note that the hash table is    used for several kinds of types (function types, array types and    array index range types, for now).  While all these live in the    same table, they are completely independent, and the hash code is    computed differently for each of these.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(if_marked (
literal|"type_hash_marked_p"
argument|), param_is (struct type_hash))
argument_list|)
name|htab_t
name|type_hash_table
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Hash table and temporary node for larger integer const values.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|int_cst_node
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(if_marked (
literal|"ggc_marked_p"
argument|), param_is (union tree_node))
argument_list|)
name|htab_t
name|int_cst_hash_table
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* General tree->tree mapping  structure for use in hash tables.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(if_marked (
literal|"tree_map_marked_p"
argument|), param_is (struct tree_map))
argument_list|)
name|htab_t
name|debug_expr_for_decl
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(if_marked (
literal|"tree_map_marked_p"
argument|), param_is (struct tree_map))
argument_list|)
name|htab_t
name|value_expr_for_decl
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(if_marked (
literal|"tree_int_map_marked_p"
argument|), param_is (struct tree_int_map))
argument_list|)
name|htab_t
name|init_priority_for_decl
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(if_marked (
literal|"tree_map_marked_p"
argument|), param_is (struct tree_map))
argument_list|)
name|htab_t
name|restrict_base_for_decl
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|tree_int_map
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|tree
name|from
decl_stmt|;
name|unsigned
name|short
name|to
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|unsigned
name|int
name|tree_int_map_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tree_int_map_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tree_int_map_marked_p
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_type_quals
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|type_hash_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|type_hash_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|int_cst_hash_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|int_cst_hash_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_type_hash_statistics
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_debug_expr_statistics
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_value_expr_statistics
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|type_hash_marked_p
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|type_hash_list
parameter_list|(
name|tree
parameter_list|,
name|hashval_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|attribute_hash_list
parameter_list|(
name|tree
parameter_list|,
name|hashval_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|tree
name|global_trees
index|[
name|TI_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|integer_types
index|[
name|itk_none
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|tree_contains_struct
index|[
literal|256
index|]
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of operands for each OpenMP clause.  */
end_comment

begin_decl_stmt
name|unsigned
specifier|const
name|char
name|omp_clause_num_ops
index|[]
init|=
block|{
literal|0
block|,
comment|/* OMP_CLAUSE_ERROR  */
literal|1
block|,
comment|/* OMP_CLAUSE_PRIVATE  */
literal|1
block|,
comment|/* OMP_CLAUSE_SHARED  */
literal|1
block|,
comment|/* OMP_CLAUSE_FIRSTPRIVATE  */
literal|1
block|,
comment|/* OMP_CLAUSE_LASTPRIVATE  */
literal|4
block|,
comment|/* OMP_CLAUSE_REDUCTION  */
literal|1
block|,
comment|/* OMP_CLAUSE_COPYIN  */
literal|1
block|,
comment|/* OMP_CLAUSE_COPYPRIVATE  */
literal|1
block|,
comment|/* OMP_CLAUSE_IF  */
literal|1
block|,
comment|/* OMP_CLAUSE_NUM_THREADS  */
literal|1
block|,
comment|/* OMP_CLAUSE_SCHEDULE  */
literal|0
block|,
comment|/* OMP_CLAUSE_NOWAIT  */
literal|0
block|,
comment|/* OMP_CLAUSE_ORDERED  */
literal|0
comment|/* OMP_CLAUSE_DEFAULT  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|omp_clause_code_name
index|[]
init|=
block|{
literal|"error_clause"
block|,
literal|"private"
block|,
literal|"shared"
block|,
literal|"firstprivate"
block|,
literal|"lastprivate"
block|,
literal|"reduction"
block|,
literal|"copyin"
block|,
literal|"copyprivate"
block|,
literal|"if"
block|,
literal|"num_threads"
block|,
literal|"schedule"
block|,
literal|"nowait"
block|,
literal|"ordered"
block|,
literal|"default"
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Init tree.c.  */
end_comment

begin_function
name|void
name|init_ttree
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Initialize the hash table of types.  */
name|type_hash_table
operator|=
name|htab_create_ggc
argument_list|(
name|TYPE_HASH_INITIAL_SIZE
argument_list|,
name|type_hash_hash
argument_list|,
name|type_hash_eq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug_expr_for_decl
operator|=
name|htab_create_ggc
argument_list|(
literal|512
argument_list|,
name|tree_map_hash
argument_list|,
name|tree_map_eq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value_expr_for_decl
operator|=
name|htab_create_ggc
argument_list|(
literal|512
argument_list|,
name|tree_map_hash
argument_list|,
name|tree_map_eq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_priority_for_decl
operator|=
name|htab_create_ggc
argument_list|(
literal|512
argument_list|,
name|tree_int_map_hash
argument_list|,
name|tree_int_map_eq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|restrict_base_for_decl
operator|=
name|htab_create_ggc
argument_list|(
literal|256
argument_list|,
name|tree_map_hash
argument_list|,
name|tree_map_eq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|int_cst_hash_table
operator|=
name|htab_create_ggc
argument_list|(
literal|1024
argument_list|,
name|int_cst_hash_hash
argument_list|,
name|int_cst_hash_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|int_cst_node
operator|=
name|make_node
argument_list|(
name|INTEGER_CST
argument_list|)
expr_stmt|;
name|tree_contains_struct
index|[
name|FUNCTION_DECL
index|]
index|[
name|TS_DECL_NON_COMMON
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|TRANSLATION_UNIT_DECL
index|]
index|[
name|TS_DECL_NON_COMMON
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|TYPE_DECL
index|]
index|[
name|TS_DECL_NON_COMMON
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|CONST_DECL
index|]
index|[
name|TS_DECL_COMMON
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|VAR_DECL
index|]
index|[
name|TS_DECL_COMMON
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|PARM_DECL
index|]
index|[
name|TS_DECL_COMMON
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|RESULT_DECL
index|]
index|[
name|TS_DECL_COMMON
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|FUNCTION_DECL
index|]
index|[
name|TS_DECL_COMMON
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|TYPE_DECL
index|]
index|[
name|TS_DECL_COMMON
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|TRANSLATION_UNIT_DECL
index|]
index|[
name|TS_DECL_COMMON
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|LABEL_DECL
index|]
index|[
name|TS_DECL_COMMON
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|FIELD_DECL
index|]
index|[
name|TS_DECL_COMMON
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|CONST_DECL
index|]
index|[
name|TS_DECL_WRTL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|VAR_DECL
index|]
index|[
name|TS_DECL_WRTL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|PARM_DECL
index|]
index|[
name|TS_DECL_WRTL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|RESULT_DECL
index|]
index|[
name|TS_DECL_WRTL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|FUNCTION_DECL
index|]
index|[
name|TS_DECL_WRTL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|LABEL_DECL
index|]
index|[
name|TS_DECL_WRTL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|CONST_DECL
index|]
index|[
name|TS_DECL_MINIMAL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|VAR_DECL
index|]
index|[
name|TS_DECL_MINIMAL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|PARM_DECL
index|]
index|[
name|TS_DECL_MINIMAL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|RESULT_DECL
index|]
index|[
name|TS_DECL_MINIMAL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|FUNCTION_DECL
index|]
index|[
name|TS_DECL_MINIMAL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|TYPE_DECL
index|]
index|[
name|TS_DECL_MINIMAL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|TRANSLATION_UNIT_DECL
index|]
index|[
name|TS_DECL_MINIMAL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|LABEL_DECL
index|]
index|[
name|TS_DECL_MINIMAL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|FIELD_DECL
index|]
index|[
name|TS_DECL_MINIMAL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|STRUCT_FIELD_TAG
index|]
index|[
name|TS_DECL_MINIMAL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|NAME_MEMORY_TAG
index|]
index|[
name|TS_DECL_MINIMAL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|SYMBOL_MEMORY_TAG
index|]
index|[
name|TS_DECL_MINIMAL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|STRUCT_FIELD_TAG
index|]
index|[
name|TS_MEMORY_TAG
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|NAME_MEMORY_TAG
index|]
index|[
name|TS_MEMORY_TAG
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|SYMBOL_MEMORY_TAG
index|]
index|[
name|TS_MEMORY_TAG
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|STRUCT_FIELD_TAG
index|]
index|[
name|TS_STRUCT_FIELD_TAG
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|VAR_DECL
index|]
index|[
name|TS_DECL_WITH_VIS
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|FUNCTION_DECL
index|]
index|[
name|TS_DECL_WITH_VIS
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|TYPE_DECL
index|]
index|[
name|TS_DECL_WITH_VIS
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|TRANSLATION_UNIT_DECL
index|]
index|[
name|TS_DECL_WITH_VIS
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|VAR_DECL
index|]
index|[
name|TS_VAR_DECL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|FIELD_DECL
index|]
index|[
name|TS_FIELD_DECL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|PARM_DECL
index|]
index|[
name|TS_PARM_DECL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|LABEL_DECL
index|]
index|[
name|TS_LABEL_DECL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|RESULT_DECL
index|]
index|[
name|TS_RESULT_DECL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|CONST_DECL
index|]
index|[
name|TS_CONST_DECL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|TYPE_DECL
index|]
index|[
name|TS_TYPE_DECL
index|]
operator|=
literal|1
expr_stmt|;
name|tree_contains_struct
index|[
name|FUNCTION_DECL
index|]
index|[
name|TS_FUNCTION_DECL
index|]
operator|=
literal|1
expr_stmt|;
name|lang_hooks
operator|.
name|init_ts
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The name of the object as the assembler will see it (but before any    translations made by ASM_OUTPUT_LABELREF).  Often this is the same    as DECL_NAME.  It is an IDENTIFIER_NODE.  */
end_comment

begin_function
name|tree
name|decl_assembler_name
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
name|lang_hooks
operator|.
name|set_decl_assembler_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|DECL_WITH_VIS_CHECK
argument_list|(
name|decl
argument_list|)
operator|->
name|decl_with_vis
operator|.
name|assembler_name
return|;
block|}
end_function

begin_comment
comment|/* Compute the number of bytes occupied by a tree with code CODE.    This function cannot be used for TREE_VEC, PHI_NODE, or STRING_CST    codes, which are of variable length.  */
end_comment

begin_function
name|size_t
name|tree_code_size
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|tcc_declaration
case|:
comment|/* A decl node */
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|FIELD_DECL
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_field_decl
argument_list|)
return|;
case|case
name|PARM_DECL
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_parm_decl
argument_list|)
return|;
case|case
name|VAR_DECL
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_var_decl
argument_list|)
return|;
case|case
name|LABEL_DECL
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_label_decl
argument_list|)
return|;
case|case
name|RESULT_DECL
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_result_decl
argument_list|)
return|;
case|case
name|CONST_DECL
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_const_decl
argument_list|)
return|;
case|case
name|TYPE_DECL
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_type_decl
argument_list|)
return|;
case|case
name|FUNCTION_DECL
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_function_decl
argument_list|)
return|;
case|case
name|NAME_MEMORY_TAG
case|:
case|case
name|SYMBOL_MEMORY_TAG
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_memory_tag
argument_list|)
return|;
case|case
name|STRUCT_FIELD_TAG
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_struct_field_tag
argument_list|)
return|;
default|default:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_non_common
argument_list|)
return|;
block|}
block|}
case|case
name|tcc_type
case|:
comment|/* a type node */
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_type
argument_list|)
return|;
case|case
name|tcc_reference
case|:
comment|/* a reference */
case|case
name|tcc_expression
case|:
comment|/* an expression */
case|case
name|tcc_statement
case|:
comment|/* an expression with side effects */
case|case
name|tcc_comparison
case|:
comment|/* a comparison expression */
case|case
name|tcc_unary
case|:
comment|/* a unary arithmetic expression */
case|case
name|tcc_binary
case|:
comment|/* a binary arithmetic expression */
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_exp
argument_list|)
operator|+
operator|(
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
return|;
case|case
name|tcc_constant
case|:
comment|/* a constant */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_int_cst
argument_list|)
return|;
case|case
name|REAL_CST
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_real_cst
argument_list|)
return|;
case|case
name|COMPLEX_CST
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_complex
argument_list|)
return|;
case|case
name|VECTOR_CST
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_vector
argument_list|)
return|;
case|case
name|STRING_CST
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
default|default:
return|return
name|lang_hooks
operator|.
name|tree_size
argument_list|(
name|code
argument_list|)
return|;
block|}
case|case
name|tcc_exceptional
case|:
comment|/* something random, like an identifier.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|IDENTIFIER_NODE
case|:
return|return
name|lang_hooks
operator|.
name|identifier_size
return|;
case|case
name|TREE_LIST
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_list
argument_list|)
return|;
case|case
name|ERROR_MARK
case|:
case|case
name|PLACEHOLDER_EXPR
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
return|;
case|case
name|TREE_VEC
case|:
case|case
name|OMP_CLAUSE
case|:
case|case
name|PHI_NODE
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|SSA_NAME
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_ssa_name
argument_list|)
return|;
case|case
name|STATEMENT_LIST
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_statement_list
argument_list|)
return|;
case|case
name|BLOCK
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_block
argument_list|)
return|;
case|case
name|VALUE_HANDLE
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_value_handle
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_constructor
argument_list|)
return|;
default|default:
return|return
name|lang_hooks
operator|.
name|tree_size
argument_list|(
name|code
argument_list|)
return|;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute the number of bytes occupied by NODE.  This routine only    looks at TREE_CODE, except for PHI_NODE and TREE_VEC nodes.  */
end_comment

begin_function
name|size_t
name|tree_size
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|node
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PHI_NODE
case|:
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_phi_node
argument_list|)
operator|+
operator|(
name|PHI_ARG_CAPACITY
argument_list|(
name|node
argument_list|)
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|phi_arg_d
argument_list|)
operator|)
return|;
case|case
name|TREE_BINFO
case|:
return|return
operator|(
name|offsetof
argument_list|(
expr|struct
name|tree_binfo
argument_list|,
name|base_binfos
argument_list|)
operator|+
name|VEC_embedded_size
argument_list|(
name|tree
argument_list|,
name|BINFO_N_BASE_BINFOS
argument_list|(
name|node
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|TREE_VEC
case|:
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_vec
argument_list|)
operator|+
operator|(
name|TREE_VEC_LENGTH
argument_list|(
name|node
argument_list|)
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
return|;
case|case
name|STRING_CST
case|:
return|return
name|TREE_STRING_LENGTH
argument_list|(
name|node
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|tree_string
argument_list|,
name|str
argument_list|)
operator|+
literal|1
return|;
case|case
name|OMP_CLAUSE
case|:
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_omp_clause
argument_list|)
operator|+
operator|(
name|omp_clause_num_ops
index|[
name|OMP_CLAUSE_CODE
argument_list|(
name|node
argument_list|)
index|]
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|)
return|;
default|default:
return|return
name|tree_code_size
argument_list|(
name|code
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a newly allocated node of code CODE.  For decl and type    nodes, some other fields are initialized.  The rest of the node is    initialized to zero.  This function cannot be used for PHI_NODE,    TREE_VEC or OMP_CLAUSE nodes, which is enforced by asserts in    tree_code_size.     Achoo!  I got a code in the node.  */
end_comment

begin_function
name|tree
name|make_node_stat
parameter_list|(
name|enum
name|tree_code
name|code
name|MEM_STAT_DECL
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|enum
name|tree_code_class
name|type
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|size_t
name|length
init|=
name|tree_code_size
argument_list|(
name|code
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_kind
name|kind
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|tcc_declaration
case|:
comment|/* A decl node */
name|kind
operator|=
name|d_kind
expr_stmt|;
break|break;
case|case
name|tcc_type
case|:
comment|/* a type node */
name|kind
operator|=
name|t_kind
expr_stmt|;
break|break;
case|case
name|tcc_statement
case|:
comment|/* an expression with side effects */
name|kind
operator|=
name|s_kind
expr_stmt|;
break|break;
case|case
name|tcc_reference
case|:
comment|/* a reference */
name|kind
operator|=
name|r_kind
expr_stmt|;
break|break;
case|case
name|tcc_expression
case|:
comment|/* an expression */
case|case
name|tcc_comparison
case|:
comment|/* a comparison expression */
case|case
name|tcc_unary
case|:
comment|/* a unary arithmetic expression */
case|case
name|tcc_binary
case|:
comment|/* a binary arithmetic expression */
name|kind
operator|=
name|e_kind
expr_stmt|;
break|break;
case|case
name|tcc_constant
case|:
comment|/* a constant */
name|kind
operator|=
name|c_kind
expr_stmt|;
break|break;
case|case
name|tcc_exceptional
case|:
comment|/* something random, like an identifier.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|IDENTIFIER_NODE
case|:
name|kind
operator|=
name|id_kind
expr_stmt|;
break|break;
case|case
name|TREE_VEC
case|:
name|kind
operator|=
name|vec_kind
expr_stmt|;
break|break;
case|case
name|TREE_BINFO
case|:
name|kind
operator|=
name|binfo_kind
expr_stmt|;
break|break;
case|case
name|PHI_NODE
case|:
name|kind
operator|=
name|phi_kind
expr_stmt|;
break|break;
case|case
name|SSA_NAME
case|:
name|kind
operator|=
name|ssa_name_kind
expr_stmt|;
break|break;
case|case
name|BLOCK
case|:
name|kind
operator|=
name|b_kind
expr_stmt|;
break|break;
case|case
name|CONSTRUCTOR
case|:
name|kind
operator|=
name|constr_kind
expr_stmt|;
break|break;
default|default:
name|kind
operator|=
name|x_kind
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|kind
index|]
operator|++
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|kind
index|]
operator|+=
name|length
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|code
operator|==
name|IDENTIFIER_NODE
condition|)
name|t
operator|=
name|ggc_alloc_zone_pass_stat
argument_list|(
name|length
argument_list|,
operator|&
name|tree_id_zone
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|ggc_alloc_zone_pass_stat
argument_list|(
name|length
argument_list|,
operator|&
name|tree_zone
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|tcc_statement
case|:
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|tcc_declaration
case|:
if|if
condition|(
name|CODE_CONTAINS_STRUCT
argument_list|(
name|code
argument_list|,
name|TS_DECL_WITH_VIS
argument_list|)
condition|)
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|t
argument_list|)
operator|=
name|in_system_header
expr_stmt|;
if|if
condition|(
name|CODE_CONTAINS_STRUCT
argument_list|(
name|code
argument_list|,
name|TS_DECL_COMMON
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|DECL_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|FUNCTION_BOUNDARY
expr_stmt|;
name|DECL_MODE
argument_list|(
name|t
argument_list|)
operator|=
name|FUNCTION_MODE
expr_stmt|;
block|}
else|else
name|DECL_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We have not yet computed the alias set for this declaration.  */
name|DECL_POINTER_ALIAS_SET
argument_list|(
name|t
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|DECL_SOURCE_LOCATION
argument_list|(
name|t
argument_list|)
operator|=
name|input_location
expr_stmt|;
name|DECL_UID
argument_list|(
name|t
argument_list|)
operator|=
name|next_decl_uid
operator|++
expr_stmt|;
break|break;
case|case
name|tcc_type
case|:
name|TYPE_UID
argument_list|(
name|t
argument_list|)
operator|=
name|next_type_uid
operator|++
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|BITS_PER_UNIT
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Default to no attributes for type, but let target change that.  */
name|TYPE_ATTRIBUTES
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|targetm
operator|.
name|set_default_type_attributes
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* We have not yet computed the alias set for this type.  */
name|TYPE_ALIAS_SET
argument_list|(
name|t
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|tcc_constant
case|:
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|tcc_expression
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INIT_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|VA_ARG_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
comment|/* All of these have side-effects, no matter what their 	     operands are.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
comment|/* Other classes need no special treatment.  */
break|break;
block|}
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a new node with the same contents as NODE except that its    TREE_CHAIN is zero and it has a fresh uid.  */
end_comment

begin_function
name|tree
name|copy_node_stat
parameter_list|(
name|tree
name|node
name|MEM_STAT_DECL
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|gcc_assert
argument_list|(
name|code
operator|!=
name|STATEMENT_LIST
argument_list|)
expr_stmt|;
name|length
operator|=
name|tree_size
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|t
operator|=
name|ggc_alloc_zone_pass_stat
argument_list|(
name|length
argument_list|,
operator|&
name|tree_zone
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|t
argument_list|,
name|node
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_VISITED
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|common
operator|.
name|ann
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_declaration
condition|)
block|{
name|DECL_UID
argument_list|(
name|t
argument_list|)
operator|=
name|next_decl_uid
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|SET_DECL_VALUE_EXPR
argument_list|(
name|t
argument_list|,
name|DECL_VALUE_EXPR
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_HAS_INIT_PRIORITY_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|SET_DECL_INIT_PRIORITY
argument_list|(
name|t
argument_list|,
name|DECL_INIT_PRIORITY
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_HAS_INIT_PRIORITY_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_BASED_ON_RESTRICT_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|SET_DECL_RESTRICT_BASE
argument_list|(
name|t
argument_list|,
name|DECL_GET_RESTRICT_BASE
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_BASED_ON_RESTRICT_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_type
condition|)
block|{
name|TYPE_UID
argument_list|(
name|t
argument_list|)
operator|=
name|next_type_uid
operator|++
expr_stmt|;
comment|/* The following is so that the debug code for 	 the copy is different from the original type. 	 The two statements usually duplicate each other 	 (because they clear fields of the same union), 	 but the optimizer should catch that.  */
name|TYPE_SYMTAB_POINTER
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Do not copy the values cache.  */
if|if
condition|(
name|TYPE_CACHED_VALUES_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|TYPE_CACHED_VALUES_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_CACHED_VALUES
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return a copy of a chain of nodes, chained through the TREE_CHAIN field.    For example, this can copy a list made of TREE_LIST nodes.  */
end_comment

begin_function
name|tree
name|copy_list
parameter_list|(
name|tree
name|list
parameter_list|)
block|{
name|tree
name|head
decl_stmt|;
name|tree
name|prev
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|head
operator|=
name|prev
operator|=
name|copy_node
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|copy_node
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|prev
operator|=
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
return|return
name|head
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create an INT_CST node with a LOW value sign extended.  */
end_comment

begin_function
name|tree
name|build_int_cst
parameter_list|(
name|tree
name|type
parameter_list|,
name|HOST_WIDE_INT
name|low
parameter_list|)
block|{
return|return
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
name|low
argument_list|,
name|low
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create an INT_CST node with a LOW value zero extended.  */
end_comment

begin_function
name|tree
name|build_int_cstu
parameter_list|(
name|tree
name|type
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|low
parameter_list|)
block|{
return|return
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
name|low
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create an INT_CST node with a LOW value in TYPE.  The value is sign extended    if it is negative.  This function is similar to build_int_cst, but    the extra bits outside of the type precision are cleared.  Constants    with these extra bits may confuse the fold so that it detects overflows    even in cases when they do not occur, and in general should be avoided.    We cannot however make this a default behavior of build_int_cst without    more intrusive changes, since there are parts of gcc that rely on the extra    precision of the integer constants.  */
end_comment

begin_function
name|tree
name|build_int_cst_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|HOST_WIDE_INT
name|low
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|val
init|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|low
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|hi
decl_stmt|,
name|mask
decl_stmt|;
name|unsigned
name|bits
decl_stmt|;
name|bool
name|signed_p
decl_stmt|;
name|bool
name|negative
decl_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
name|bits
operator|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|signed_p
operator|=
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|negative
operator|=
operator|(
name|low
operator|<
literal|0
operator|)
expr_stmt|;
else|else
block|{
comment|/* If the sign bit is inside precision of LOW, use it to determine 	 the sign of the constant.  */
name|negative
operator|=
operator|(
operator|(
name|val
operator|>>
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* Mask out the bits outside of the precision of the constant.  */
name|mask
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|2
operator|)
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|signed_p
operator|&&
name|negative
condition|)
name|val
operator||=
operator|~
name|mask
expr_stmt|;
else|else
name|val
operator|&=
name|mask
expr_stmt|;
block|}
comment|/* Determine the high bits.  */
name|hi
operator|=
operator|(
name|negative
condition|?
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
else|:
literal|0
operator|)
expr_stmt|;
comment|/* For unsigned type we need to mask out the bits outside of the type      precision.  */
if|if
condition|(
operator|!
name|signed_p
condition|)
block|{
if|if
condition|(
name|bits
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|hi
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|bits
operator|-=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|2
operator|)
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|hi
operator|&=
name|mask
expr_stmt|;
block|}
block|}
return|return
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
name|val
argument_list|,
name|hi
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* These are the hash table functions for the hash table of INTEGER_CST    nodes of a sizetype.  */
end_comment

begin_comment
comment|/* Return the hash code code X, an INTEGER_CST.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|int_cst_hash_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|)
block|{
name|tree
name|t
init|=
operator|(
name|tree
operator|)
name|x
decl_stmt|;
return|return
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|^
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|^
name|htab_hash_pointer
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the value represented by *X (an INTEGER_CST tree node)    is the same as that given by *Y, which is the same.  */
end_comment

begin_function
specifier|static
name|int
name|int_cst_hash_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
name|tree
name|xt
init|=
operator|(
name|tree
operator|)
name|x
decl_stmt|;
name|tree
name|yt
init|=
operator|(
name|tree
operator|)
name|y
decl_stmt|;
return|return
operator|(
name|TREE_TYPE
argument_list|(
name|xt
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|yt
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|xt
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|yt
argument_list|)
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|xt
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|yt
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create an INT_CST node of TYPE and value HI:LOW.  If TYPE is NULL,    integer_type_node is used.  The returned node is always shared.    For small integers we use a per-type vector cache, for larger ones    we use a single hash table.  */
end_comment

begin_function
name|tree
name|build_int_cst_wide
parameter_list|(
name|tree
name|type
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|low
parameter_list|,
name|HOST_WIDE_INT
name|hi
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|int
name|ix
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|limit
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* Cache NULL pointer.  */
if|if
condition|(
operator|!
name|hi
operator|&&
operator|!
name|low
condition|)
block|{
name|limit
operator|=
literal|1
expr_stmt|;
name|ix
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|BOOLEAN_TYPE
case|:
comment|/* Cache false or true.  */
name|limit
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|hi
operator|&&
name|low
operator|<
literal|2
condition|)
name|ix
operator|=
name|low
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Cache 0..N */
name|limit
operator|=
name|INTEGER_SHARE_LIMIT
expr_stmt|;
if|if
condition|(
operator|!
name|hi
operator|&&
name|low
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTEGER_SHARE_LIMIT
condition|)
name|ix
operator|=
name|low
expr_stmt|;
block|}
else|else
block|{
comment|/* Cache -1..N */
name|limit
operator|=
name|INTEGER_SHARE_LIMIT
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|hi
operator|&&
name|low
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTEGER_SHARE_LIMIT
condition|)
name|ix
operator|=
name|low
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|hi
operator|==
operator|-
literal|1
operator|&&
name|low
operator|==
operator|-
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
condition|)
name|ix
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|ix
operator|>=
literal|0
condition|)
block|{
comment|/* Look for it in the type's vector of small shared ints.  */
if|if
condition|(
operator|!
name|TYPE_CACHED_VALUES_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|TYPE_CACHED_VALUES_P
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_CACHED_VALUES
argument_list|(
name|type
argument_list|)
operator|=
name|make_tree_vec
argument_list|(
name|limit
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|TREE_VEC_ELT
argument_list|(
name|TYPE_CACHED_VALUES
argument_list|(
name|type
argument_list|)
argument_list|,
name|ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
comment|/* Make sure no one is clobbering the shared constant.  */
name|gcc_assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|type
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|==
name|low
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|==
name|hi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Create a new shared int.  */
name|t
operator|=
name|make_node
argument_list|(
name|INTEGER_CST
argument_list|)
expr_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|=
name|low
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|=
name|hi
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|TYPE_CACHED_VALUES
argument_list|(
name|type
argument_list|)
argument_list|,
name|ix
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Use the cache of larger shared ints.  */
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|int_cst_node
argument_list|)
operator|=
name|low
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|int_cst_node
argument_list|)
operator|=
name|hi
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|int_cst_node
argument_list|)
operator|=
name|type
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|int_cst_hash_table
argument_list|,
name|int_cst_node
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|t
operator|=
operator|*
name|slot
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
comment|/* Insert this one into the hash table.  */
name|t
operator|=
name|int_cst_node
expr_stmt|;
operator|*
name|slot
operator|=
name|t
expr_stmt|;
comment|/* Make a new node for next time round.  */
name|int_cst_node
operator|=
name|make_node
argument_list|(
name|INTEGER_CST
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Builds an integer constant in TYPE such that lowest BITS bits are ones    and the rest are zeros.  */
end_comment

begin_function
name|tree
name|build_low_bits_mask
parameter_list|(
name|tree
name|type
parameter_list|,
name|unsigned
name|bits
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|all_ones
init|=
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
decl_stmt|;
name|gcc_assert
argument_list|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Sign extended all-ones mask.  */
name|low
operator|=
name|all_ones
expr_stmt|;
name|high
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bits
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|low
operator|=
name|all_ones
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|bits
operator|)
expr_stmt|;
name|high
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bits
operator|-=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
name|low
operator|=
name|all_ones
expr_stmt|;
name|high
operator|=
name|all_ones
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|bits
operator|)
expr_stmt|;
block|}
return|return
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Checks that X is integer constant that can be expressed in (unsigned)    HOST_WIDE_INT without loss of precision.  */
end_comment

begin_function
name|bool
name|cst_and_fits_in_hwi
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
name|false
return|;
return|return
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a new VECTOR_CST node whose type is TYPE and whose values    are in a list pointed to by VALS.  */
end_comment

begin_function
name|tree
name|build_vector
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|vals
parameter_list|)
block|{
name|tree
name|v
init|=
name|make_node
argument_list|(
name|VECTOR_CST
argument_list|)
decl_stmt|;
name|int
name|over1
init|=
literal|0
decl_stmt|,
name|over2
init|=
literal|0
decl_stmt|;
name|tree
name|link
decl_stmt|;
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|v
argument_list|)
operator|=
name|vals
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|v
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Iterate through elements and check for overflow.  */
for|for
control|(
name|link
operator|=
name|vals
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
comment|/* Don't crash if we get an address constant.  */
if|if
condition|(
operator|!
name|CONSTANT_CLASS_P
argument_list|(
name|value
argument_list|)
condition|)
continue|continue;
name|over1
operator||=
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|over2
operator||=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|TREE_OVERFLOW
argument_list|(
name|v
argument_list|)
operator|=
name|over1
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|v
argument_list|)
operator|=
name|over2
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Return a new VECTOR_CST node whose type is TYPE and whose values    are extracted from V, a vector of CONSTRUCTOR_ELT.  */
end_comment

begin_decl_stmt
name|tree
name|build_vector_from_ctor
argument_list|(
name|tree
name|type
argument_list|,
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v
argument_list|)
block|{
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|tree
name|value
decl_stmt|;
name|FOR_EACH_CONSTRUCTOR_VALUE
argument_list|(
argument|v
argument_list|,
argument|idx
argument_list|,
argument|value
argument_list|)
name|list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|build_vector
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|list
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Return a new CONSTRUCTOR node whose type is TYPE and whose values    are in the VEC pointed to by VALS.  */
end_comment

begin_decl_stmt
name|tree
name|build_constructor
argument_list|(
name|tree
name|type
argument_list|,
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|vals
argument_list|)
block|{
name|tree
name|c
init|=
name|make_node
argument_list|(
name|CONSTRUCTOR
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|c
argument_list|)
operator|=
name|type
expr_stmt|;
name|CONSTRUCTOR_ELTS
argument_list|(
name|c
argument_list|)
operator|=
name|vals
expr_stmt|;
return|return
name|c
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Build a CONSTRUCTOR node made of a single initializer, with the specified    INDEX and VALUE.  */
end_comment

begin_function
name|tree
name|build_constructor_single
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|index
parameter_list|,
name|tree
name|value
parameter_list|)
block|{
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v
expr_stmt|;
name|constructor_elt
modifier|*
name|elt
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|v
operator|=
name|VEC_alloc
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|elt
operator|=
name|VEC_quick_push
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|elt
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|elt
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|t
operator|=
name|build_constructor
argument_list|(
name|type
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return a new CONSTRUCTOR node whose type is TYPE and whose values    are in a list pointed to by VALS.  */
end_comment

begin_function
name|tree
name|build_constructor_from_list
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|vals
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|val
decl_stmt|;
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v
operator|=
name|NULL
expr_stmt|;
name|bool
name|constant_p
init|=
name|true
decl_stmt|;
if|if
condition|(
name|vals
condition|)
block|{
name|v
operator|=
name|VEC_alloc
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|,
name|list_length
argument_list|(
name|vals
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|vals
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|constructor_elt
modifier|*
name|elt
init|=
name|VEC_quick_push
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|val
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|elt
operator|->
name|index
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|elt
operator|->
name|value
operator|=
name|val
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|val
argument_list|)
condition|)
name|constant_p
operator|=
name|false
expr_stmt|;
block|}
block|}
name|t
operator|=
name|build_constructor
argument_list|(
name|type
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
name|constant_p
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return a new REAL_CST node whose type is TYPE and value is D.  */
end_comment

begin_function
name|tree
name|build_real
parameter_list|(
name|tree
name|type
parameter_list|,
name|REAL_VALUE_TYPE
name|d
parameter_list|)
block|{
name|tree
name|v
decl_stmt|;
name|REAL_VALUE_TYPE
modifier|*
name|dp
decl_stmt|;
name|int
name|overflow
init|=
literal|0
decl_stmt|;
comment|/* ??? Used to check for overflow here via CHECK_FLOAT_TYPE.      Consider doing it via real_convert now.  */
name|v
operator|=
name|make_node
argument_list|(
name|REAL_CST
argument_list|)
expr_stmt|;
name|dp
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|REAL_VALUE_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dp
argument_list|,
operator|&
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|REAL_VALUE_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|v
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_REAL_CST_PTR
argument_list|(
name|v
argument_list|)
operator|=
name|dp
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|v
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|v
argument_list|)
operator|=
name|overflow
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Return a new REAL_CST node whose type is TYPE    and whose value is the integer value of the INTEGER_CST node I.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|real_value_from_int_cst
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|i
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
comment|/* Clear all bits of the real value type so that we can later do      bitwise comparisons to see if two values are the same.  */
name|memset
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|d
argument_list|)
expr_stmt|;
name|real_from_integer
argument_list|(
operator|&
name|d
argument_list|,
name|type
condition|?
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
else|:
name|VOIDmode
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/* Given a tree representing an integer constant I, return a tree    representing the same value as a floating-point constant of type TYPE.  */
end_comment

begin_function
name|tree
name|build_real_from_int_cst
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|i
parameter_list|)
block|{
name|tree
name|v
decl_stmt|;
name|int
name|overflow
init|=
name|TREE_OVERFLOW
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|v
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|real_value_from_int_cst
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|v
argument_list|)
operator||=
name|overflow
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|v
argument_list|)
operator||=
name|overflow
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Return a newly constructed STRING_CST node whose value is    the LEN characters at STR.    The TREE_TYPE is not initialized.  */
end_comment

begin_function
name|tree
name|build_string
parameter_list|(
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|tree
name|s
decl_stmt|;
name|size_t
name|length
decl_stmt|;
comment|/* Do not waste bytes provided by padding of struct tree_string.  */
name|length
operator|=
name|len
operator|+
name|offsetof
argument_list|(
expr|struct
name|tree_string
argument_list|,
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|c_kind
index|]
operator|++
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|c_kind
index|]
operator|+=
name|length
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|ggc_alloc_tree
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|s
argument_list|,
name|STRING_CST
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|s
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|s
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STRING_LENGTH
argument_list|(
name|s
argument_list|)
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|TREE_STRING_POINTER
argument_list|(
name|s
argument_list|)
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
operator|(
name|char
operator|*
operator|)
name|TREE_STRING_POINTER
argument_list|(
name|s
argument_list|)
operator|)
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Return a newly constructed COMPLEX_CST node whose value is    specified by the real and imaginary parts REAL and IMAG.    Both REAL and IMAG should be constant nodes.  TYPE, if specified,    will be the type of the COMPLEX_CST; otherwise a new type will be made.  */
end_comment

begin_function
name|tree
name|build_complex
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|real
parameter_list|,
name|tree
name|imag
parameter_list|)
block|{
name|tree
name|t
init|=
name|make_node
argument_list|(
name|COMPLEX_CST
argument_list|)
decl_stmt|;
name|TREE_REALPART
argument_list|(
name|t
argument_list|)
operator|=
name|real
expr_stmt|;
name|TREE_IMAGPART
argument_list|(
name|t
argument_list|)
operator|=
name|imag
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
condition|?
name|type
else|:
name|build_complex_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|real
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|real
argument_list|)
operator||
name|TREE_OVERFLOW
argument_list|(
name|imag
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|real
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|imag
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return a constant of arithmetic type TYPE which is the    multiplicative identity of the set TYPE.  */
end_comment

begin_function
name|tree
name|build_one_cst
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
return|return
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|REAL_TYPE
case|:
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
return|;
case|case
name|VECTOR_TYPE
case|:
block|{
name|tree
name|scalar
decl_stmt|,
name|cst
decl_stmt|;
name|int
name|i
decl_stmt|;
name|scalar
operator|=
name|build_one_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create 'vect_cst_ = {cst,cst,...,cst}'  */
name|cst
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|type
argument_list|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|cst
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|scalar
argument_list|,
name|cst
argument_list|)
expr_stmt|;
return|return
name|build_vector
argument_list|(
name|type
argument_list|,
name|cst
argument_list|)
return|;
block|}
case|case
name|COMPLEX_TYPE
case|:
return|return
name|build_complex
argument_list|(
name|type
argument_list|,
name|build_one_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build a BINFO with LEN language slots.  */
end_comment

begin_function
name|tree
name|make_tree_binfo_stat
parameter_list|(
name|unsigned
name|base_binfos
name|MEM_STAT_DECL
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|size_t
name|length
init|=
operator|(
name|offsetof
argument_list|(
expr|struct
name|tree_binfo
argument_list|,
name|base_binfos
argument_list|)
operator|+
name|VEC_embedded_size
argument_list|(
name|tree
argument_list|,
name|base_binfos
argument_list|)
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|binfo_kind
index|]
operator|++
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|binfo_kind
index|]
operator|+=
name|length
expr_stmt|;
endif|#
directive|endif
name|t
operator|=
name|ggc_alloc_zone_pass_stat
argument_list|(
name|length
argument_list|,
operator|&
name|tree_zone
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|tree_binfo
argument_list|,
name|base_binfos
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|TREE_BINFO
argument_list|)
expr_stmt|;
name|VEC_embedded_init
argument_list|(
name|tree
argument_list|,
name|BINFO_BASE_BINFOS
argument_list|(
name|t
argument_list|)
argument_list|,
name|base_binfos
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Build a newly constructed TREE_VEC node of length LEN.  */
end_comment

begin_function
name|tree
name|make_tree_vec_stat
parameter_list|(
name|int
name|len
name|MEM_STAT_DECL
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|int
name|length
init|=
operator|(
name|len
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_vec
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|vec_kind
index|]
operator|++
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|vec_kind
index|]
operator|+=
name|length
expr_stmt|;
endif|#
directive|endif
name|t
operator|=
name|ggc_alloc_zone_pass_stat
argument_list|(
name|length
argument_list|,
operator|&
name|tree_zone
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|TREE_VEC
argument_list|)
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
operator|=
name|len
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if EXPR is the integer constant zero or a complex constant    of zero.  */
end_comment

begin_function
name|int
name|integer_zerop
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|integer_zerop
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is the integer constant one or the corresponding    complex constant.  */
end_comment

begin_function
name|int
name|integer_onep
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
operator|==
literal|1
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|integer_onep
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is an integer containing all 1's in as much precision as    it contains.  Likewise for the corresponding complex constant.  */
end_comment

begin_function
name|int
name|integer_all_onesp
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|int
name|uns
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|integer_all_onesp
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
name|uns
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
operator|==
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|uns
condition|)
return|return
literal|0
return|;
comment|/* Note that using TYPE_PRECISION here is wrong.  We care about the      actual bits, not the (arbitrary) range of the type.  */
name|prec
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prec
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|HOST_WIDE_INT
name|high_value
decl_stmt|;
name|int
name|shift_amount
decl_stmt|;
name|shift_amount
operator|=
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
comment|/* Can not handle precisions greater than twice the host int size.  */
name|gcc_assert
argument_list|(
name|shift_amount
operator|<=
name|HOST_BITS_PER_WIDE_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift_amount
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
comment|/* Shifting by the host word size is undefined according to the ANSI 	   standard, so we must handle this as a special case.  */
name|high_value
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|high_value
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|shift_amount
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
operator|==
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
operator|==
name|high_value
operator|)
return|;
block|}
else|else
return|return
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
operator|==
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|prec
operator|)
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is an integer constant that is a power of 2 (i.e., has only    one bit on).  */
end_comment

begin_function
name|int
name|integer_pow2p
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|low
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
name|prec
operator|=
operator|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|?
name|POINTER_SIZE
else|:
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|high
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|low
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* First clear all bits that are beyond the type's precision in case      we've been sign extended.  */
if|if
condition|(
name|prec
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|high
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
else|else
block|{
name|high
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|low
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|prec
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|high
operator|==
literal|0
operator|&&
name|low
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|high
operator|==
literal|0
operator|&&
operator|(
name|low
operator|&
operator|(
name|low
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|low
operator|==
literal|0
operator|&&
operator|(
name|high
operator|&
operator|(
name|high
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is an integer constant other than zero or a    complex constant other than zero.  */
end_comment

begin_function
name|int
name|integer_nonzerop
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
operator|!=
literal|0
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
operator|(
name|integer_nonzerop
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|||
name|integer_nonzerop
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the power of two represented by a tree node known to be a    power of two.  */
end_comment

begin_function
name|int
name|tree_log2
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|low
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|tree_log2
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
name|prec
operator|=
operator|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|?
name|POINTER_SIZE
else|:
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|high
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|low
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* First clear all bits that are beyond the type's precision in case      we've been sign extended.  */
if|if
condition|(
name|prec
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|high
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
else|else
block|{
name|high
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|low
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|prec
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|high
operator|!=
literal|0
condition|?
name|HOST_BITS_PER_WIDE_INT
operator|+
name|exact_log2
argument_list|(
name|high
argument_list|)
else|:
name|exact_log2
argument_list|(
name|low
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but return the largest integer Y such that 2 ** Y is less    than or equal to EXPR.  */
end_comment

begin_function
name|int
name|tree_floor_log2
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|low
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|tree_log2
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
name|prec
operator|=
operator|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|?
name|POINTER_SIZE
else|:
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|high
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|low
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* First clear all bits that are beyond the type's precision in case      we've been sign extended.  Ignore if type's precision hasn't been set      since what we are doing is setting it.  */
if|if
condition|(
name|prec
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|||
name|prec
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|high
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
else|else
block|{
name|high
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|low
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|prec
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|high
operator|!=
literal|0
condition|?
name|HOST_BITS_PER_WIDE_INT
operator|+
name|floor_log2
argument_list|(
name|high
argument_list|)
else|:
name|floor_log2
argument_list|(
name|low
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is the real constant zero.  */
end_comment

begin_function
name|int
name|real_zerop
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|expr
argument_list|)
argument_list|,
name|dconst0
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|real_zerop
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|real_zerop
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is the real constant one in real or complex form.  */
end_comment

begin_function
name|int
name|real_onep
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|expr
argument_list|)
argument_list|,
name|dconst1
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|real_onep
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|real_zerop
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is the real constant two.  */
end_comment

begin_function
name|int
name|real_twop
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|expr
argument_list|)
argument_list|,
name|dconst2
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|real_twop
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|real_zerop
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is the real constant minus one.  */
end_comment

begin_function
name|int
name|real_minus_onep
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|expr
argument_list|)
argument_list|,
name|dconstm1
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|real_minus_onep
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|real_zerop
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if EXP is a constant or a cast of a constant.  */
end_comment

begin_function
name|int
name|really_constant_p
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
comment|/* This is not quite the same as STRIP_NOPS.  It does more.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TREE_CONSTANT
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return first list element whose TREE_VALUE is ELEM.    Return 0 if ELEM is not in LIST.  */
end_comment

begin_function
name|tree
name|value_member
parameter_list|(
name|tree
name|elem
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|elem
operator|==
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
condition|)
return|return
name|list
return|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return first list element whose TREE_PURPOSE is ELEM.    Return 0 if ELEM is not in LIST.  */
end_comment

begin_function
name|tree
name|purpose_member
parameter_list|(
name|tree
name|elem
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|elem
operator|==
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
condition|)
return|return
name|list
return|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if ELEM is part of the chain CHAIN.  */
end_comment

begin_function
name|int
name|chain_member
parameter_list|(
name|tree
name|elem
parameter_list|,
name|tree
name|chain
parameter_list|)
block|{
while|while
condition|(
name|chain
condition|)
block|{
if|if
condition|(
name|elem
operator|==
name|chain
condition|)
return|return
literal|1
return|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the length of a chain of nodes chained through TREE_CHAIN.    We expect a null pointer to mark the end of the chain.    This is the Lisp primitive `length'.  */
end_comment

begin_function
name|int
name|list_length
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|p
init|=
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_TREE_CHECKING
name|tree
name|q
init|=
name|t
decl_stmt|;
endif|#
directive|endif
name|int
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_TREE_CHECKING
if|if
condition|(
name|len
operator|%
literal|2
condition|)
name|q
operator|=
name|TREE_CHAIN
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|p
operator|!=
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|++
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Returns the number of FIELD_DECLs in TYPE.  */
end_comment

begin_function
name|int
name|fields_length
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|t
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
condition|)
operator|++
name|count
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Concatenate two chains of nodes (chained through TREE_CHAIN)    by modifying the last node in chain 1 to point to chain 2.    This is the Lisp primitive `nconc'.  */
end_comment

begin_function
name|tree
name|chainon
parameter_list|(
name|tree
name|op1
parameter_list|,
name|tree
name|op2
parameter_list|)
block|{
name|tree
name|t1
decl_stmt|;
if|if
condition|(
operator|!
name|op1
condition|)
return|return
name|op2
return|;
if|if
condition|(
operator|!
name|op2
condition|)
return|return
name|op1
return|;
for|for
control|(
name|t1
operator|=
name|op1
init|;
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
control|)
continue|continue;
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|=
name|op2
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_TREE_CHECKING
block|{
name|tree
name|t2
decl_stmt|;
for|for
control|(
name|t2
operator|=
name|op2
init|;
name|t2
condition|;
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
control|)
name|gcc_assert
argument_list|(
name|t2
operator|!=
name|t1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|op1
return|;
block|}
end_function

begin_comment
comment|/* Return the last node in a chain of nodes (chained through TREE_CHAIN).  */
end_comment

begin_function
name|tree
name|tree_last
parameter_list|(
name|tree
name|chain
parameter_list|)
block|{
name|tree
name|next
decl_stmt|;
if|if
condition|(
name|chain
condition|)
while|while
condition|(
operator|(
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
operator|)
condition|)
name|chain
operator|=
name|next
expr_stmt|;
return|return
name|chain
return|;
block|}
end_function

begin_comment
comment|/* Reverse the order of elements in the chain T,    and return the new head of the chain (old last element).  */
end_comment

begin_function
name|tree
name|nreverse
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|prev
init|=
literal|0
decl_stmt|,
name|decl
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|t
init|;
name|decl
condition|;
name|decl
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|decl
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a newly created TREE_LIST node whose    purpose and value fields are PARM and VALUE.  */
end_comment

begin_function
name|tree
name|build_tree_list_stat
parameter_list|(
name|tree
name|parm
parameter_list|,
name|tree
name|value
name|MEM_STAT_DECL
parameter_list|)
block|{
name|tree
name|t
init|=
name|make_node_stat
argument_list|(
argument|TREE_LIST PASS_MEM_STAT
argument_list|)
decl_stmt|;
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|=
name|parm
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|value
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return a newly created TREE_LIST node whose    purpose and value fields are PURPOSE and VALUE    and whose TREE_CHAIN is CHAIN.  */
end_comment

begin_function
name|tree
name|tree_cons_stat
parameter_list|(
name|tree
name|purpose
parameter_list|,
name|tree
name|value
parameter_list|,
name|tree
name|chain
name|MEM_STAT_DECL
parameter_list|)
block|{
name|tree
name|node
decl_stmt|;
name|node
operator|=
name|ggc_alloc_zone_pass_stat
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_list
argument_list|)
argument_list|,
operator|&
name|tree_zone
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|x_kind
index|]
operator|++
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|x_kind
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_list
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TREE_SET_CODE
argument_list|(
name|node
argument_list|,
name|TREE_LIST
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|node
argument_list|)
operator|=
name|chain
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|node
argument_list|)
operator|=
name|purpose
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|node
argument_list|)
operator|=
name|value
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the size nominally occupied by an object of type TYPE    when it resides in memory.  The value is measured in units of bytes,    and its data type is that normally used for type sizes    (which is the first type created by make_signed_type or    make_unsigned_type).  */
end_comment

begin_function
name|tree
name|size_in_bytes
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|integer_zero_node
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|t
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|lang_hooks
operator|.
name|types
operator|.
name|incomplete_type_error
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|size_zero_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|t
operator|=
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return the size of TYPE (in bytes) as a wide integer    or return -1 if the size can vary or is larger than an integer.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|int_size_in_bytes
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|t
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
comment|/* If the result would appear negative, it's too big to represent.  */
operator|||
operator|(
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the maximum size of TYPE (in bytes) as a wide integer    or return -1 if the size can vary or is larger than an integer.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|max_int_size_in_bytes
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|HOST_WIDE_INT
name|size
init|=
operator|-
literal|1
decl_stmt|;
name|tree
name|size_tree
decl_stmt|;
comment|/* If this is an array type, check for a possible MAX_SIZE attached.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|size_tree
operator|=
name|TYPE_ARRAY_MAX_SIZE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_tree
operator|&&
name|host_integerp
argument_list|(
name|size_tree
argument_list|,
literal|1
argument_list|)
condition|)
name|size
operator|=
name|tree_low_cst
argument_list|(
name|size_tree
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If we still haven't been able to get a size, see if the language      can compute a maximum size.  */
if|if
condition|(
name|size
operator|==
operator|-
literal|1
condition|)
block|{
name|size_tree
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|max_size
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_tree
operator|&&
name|host_integerp
argument_list|(
name|size_tree
argument_list|,
literal|1
argument_list|)
condition|)
name|size
operator|=
name|tree_low_cst
argument_list|(
name|size_tree
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the bit position of FIELD, in bits from the start of the record.    This is a tree of type bitsizetype.  */
end_comment

begin_function
name|tree
name|bit_position
parameter_list|(
name|tree
name|field
parameter_list|)
block|{
return|return
name|bit_from_pos
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Likewise, but return as an integer.  It must be representable in    that way (since it could be a signed value, we don't have the    option of returning -1 like int_size_in_byte can.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|int_bit_position
parameter_list|(
name|tree
name|field
parameter_list|)
block|{
return|return
name|tree_low_cst
argument_list|(
name|bit_position
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the byte position of FIELD, in bytes from the start of the record.    This is a tree of type sizetype.  */
end_comment

begin_function
name|tree
name|byte_position
parameter_list|(
name|tree
name|field
parameter_list|)
block|{
return|return
name|byte_from_pos
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Likewise, but return as an integer.  It must be representable in    that way (since it could be a signed value, we don't have the    option of returning -1 like int_size_in_byte can.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|int_byte_position
parameter_list|(
name|tree
name|field
parameter_list|)
block|{
return|return
name|tree_low_cst
argument_list|(
name|byte_position
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the strictest alignment, in bits, that T is known to have.  */
end_comment

begin_function
name|unsigned
name|int
name|expr_align
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|unsigned
name|int
name|align0
decl_stmt|,
name|align1
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
comment|/* If we have conversions, we know that the alignment of the 	 object must meet each of the alignments of the types.  */
name|align0
operator|=
name|expr_align
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|align1
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MAX
argument_list|(
name|align0
argument_list|,
name|align1
argument_list|)
return|;
case|case
name|SAVE_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|INIT_EXPR
case|:
case|case
name|TARGET_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|CLEANUP_POINT_EXPR
case|:
comment|/* These don't change the alignment of an object.  */
return|return
name|expr_align
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
comment|/* The best we can do is say that the alignment is the least aligned 	 of the two arms.  */
name|align0
operator|=
name|expr_align
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|align1
operator|=
name|expr_align
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MIN
argument_list|(
name|align0
argument_list|,
name|align1
argument_list|)
return|;
comment|/* FIXME: LABEL_DECL and CONST_DECL never have DECL_ALIGN set 	 meaningfully, it's always 1.  */
case|case
name|LABEL_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
name|gcc_assert
argument_list|(
name|DECL_ALIGN
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|DECL_ALIGN
argument_list|(
name|t
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* Otherwise take the alignment from that of the type.  */
return|return
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return, as a tree node, the number of elements for TYPE (which is an    ARRAY_TYPE) minus one. This counts only elements of the top array.  */
end_comment

begin_function
name|tree
name|array_type_nelts
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|index_type
decl_stmt|,
name|min
decl_stmt|,
name|max
decl_stmt|;
comment|/* If they did it with unspecified bounds, then we should have already      given an error about it before we got here.  */
if|if
condition|(
operator|!
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|index_type
operator|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|min
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
name|max
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|integer_zerop
argument_list|(
name|min
argument_list|)
condition|?
name|max
else|:
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|max
argument_list|)
argument_list|,
name|max
argument_list|,
name|min
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If arg is static -- a reference to an object in static storage -- then    return the object.  This is not the same as the C meaning of `static'.    If arg isn't static, return NULL.  */
end_comment

begin_function
name|tree
name|staticp
parameter_list|(
name|tree
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|FUNCTION_DECL
case|:
comment|/* Nested functions are static, even though taking their address will 	 involve a trampoline as we unnest the nested function and create 	 the trampoline on the tree level.  */
return|return
name|arg
return|;
case|case
name|VAR_DECL
case|:
return|return
operator|(
operator|(
name|TREE_STATIC
argument_list|(
name|arg
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|arg
argument_list|)
operator|)
operator|&&
operator|!
name|DECL_THREAD_LOCAL_P
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
name|DECL_DLLIMPORT_P
argument_list|(
name|arg
argument_list|)
condition|?
name|arg
else|:
name|NULL
operator|)
return|;
case|case
name|CONST_DECL
case|:
return|return
operator|(
operator|(
name|TREE_STATIC
argument_list|(
name|arg
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|arg
argument_list|)
operator|)
condition|?
name|arg
else|:
name|NULL
operator|)
return|;
case|case
name|CONSTRUCTOR
case|:
return|return
name|TREE_STATIC
argument_list|(
name|arg
argument_list|)
condition|?
name|arg
else|:
name|NULL
return|;
case|case
name|LABEL_DECL
case|:
case|case
name|STRING_CST
case|:
return|return
name|arg
return|;
case|case
name|COMPONENT_REF
case|:
comment|/* If the thing being referenced is not a field, then it is 	 something language specific.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
return|return
call|(
modifier|*
name|lang_hooks
operator|.
name|staticp
call|)
argument_list|(
name|arg
argument_list|)
return|;
comment|/* If we are referencing a bitfield, we can't evaluate an 	 ADDR_EXPR at compile time and so it isn't a constant.  */
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|staticp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|BIT_FIELD_REF
case|:
return|return
name|NULL
return|;
case|case
name|MISALIGNED_INDIRECT_REF
case|:
case|case
name|ALIGN_INDIRECT_REF
case|:
case|case
name|INDIRECT_REF
case|:
return|return
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
name|arg
else|:
name|NULL
return|;
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|staticp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
else|else
return|return
name|false
return|;
default|default:
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
condition|)
return|return
name|lang_hooks
operator|.
name|staticp
argument_list|(
name|arg
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wrap a SAVE_EXPR around EXPR, if appropriate.    Do this to any expression which may be used in more than one place,    but must be evaluated only once.     Normally, expand_expr would reevaluate the expression each time.    Calling save_expr produces something that is evaluated and recorded    the first time expand_expr is called on it.  Subsequent calls to    expand_expr just reuse the recorded value.     The call to expand_expr that generates code that actually computes    the value is the first call *at compile time*.  Subsequent calls    *at compile time* generate code to use the saved value.    This produces correct result provided that *at run time* control    always flows through the insns made by the first expand_expr    before reaching the other places where the save_expr was evaluated.    You, the caller of save_expr, must make sure this is so.     Constants, and certain read-only nodes, are returned with no    SAVE_EXPR because that is safe.  Expressions containing placeholders    are not touched; see tree.def for an explanation of what these    are used for.  */
end_comment

begin_function
name|tree
name|save_expr
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|t
init|=
name|fold
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|inner
decl_stmt|;
comment|/* If the tree evaluates to a constant, then we don't want to hide that      fact (i.e. this allows further folding, and direct checks for constants).      However, a read-only object that has side effects cannot be bypassed.      Since it is no problem to reevaluate literals, we just return the      literal node.  */
name|inner
operator|=
name|skip_simple_arithmetic
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_INVARIANT
argument_list|(
name|inner
argument_list|)
operator|||
operator|(
name|TREE_READONLY
argument_list|(
name|inner
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|inner
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|SAVE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|t
return|;
comment|/* If INNER contains a PLACEHOLDER_EXPR, we must evaluate it each time, since      it means that the size or offset of some field of an object depends on      the value within another field.       Note that it must not be the case that T contains both a PLACEHOLDER_EXPR      and some variable since it would then need to be both evaluated once and      evaluated more than once.  Front-ends must assure this case cannot      happen by surrounding any such subexpressions in their own SAVE_EXPR      and forcing evaluation at the proper time.  */
if|if
condition|(
name|contains_placeholder_p
argument_list|(
name|inner
argument_list|)
condition|)
return|return
name|t
return|;
name|t
operator|=
name|build1
argument_list|(
name|SAVE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* This expression might be placed ahead of a jump to ensure that the      value was computed on both sides of the jump.  So make sure it isn't      eliminated as dead.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Look inside EXPR and into any simple arithmetic operations.  Return    the innermost non-arithmetic node.  */
end_comment

begin_function
name|tree
name|skip_simple_arithmetic
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|inner
decl_stmt|;
comment|/* We don't care about whether this can be used as an lvalue in this      context.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we have simple operations applied to a SAVE_EXPR or to a SAVE_EXPR and      a constant, it will be more efficient to not make another SAVE_EXPR since      it will allow better simplification and GCSE will be able to merge the      computations if they actually occur.  */
name|inner
operator|=
name|expr
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|UNARY_CLASS_P
argument_list|(
name|inner
argument_list|)
condition|)
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|BINARY_CLASS_P
argument_list|(
name|inner
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_INVARIANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_INVARIANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
else|else
break|break;
block|}
return|return
name|inner
return|;
block|}
end_function

begin_comment
comment|/* Return which tree structure is used by T.  */
end_comment

begin_function
name|enum
name|tree_node_structure_enum
name|tree_node_structure
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|tcc_declaration
case|:
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|FIELD_DECL
case|:
return|return
name|TS_FIELD_DECL
return|;
case|case
name|PARM_DECL
case|:
return|return
name|TS_PARM_DECL
return|;
case|case
name|VAR_DECL
case|:
return|return
name|TS_VAR_DECL
return|;
case|case
name|LABEL_DECL
case|:
return|return
name|TS_LABEL_DECL
return|;
case|case
name|RESULT_DECL
case|:
return|return
name|TS_RESULT_DECL
return|;
case|case
name|CONST_DECL
case|:
return|return
name|TS_CONST_DECL
return|;
case|case
name|TYPE_DECL
case|:
return|return
name|TS_TYPE_DECL
return|;
case|case
name|FUNCTION_DECL
case|:
return|return
name|TS_FUNCTION_DECL
return|;
case|case
name|SYMBOL_MEMORY_TAG
case|:
case|case
name|NAME_MEMORY_TAG
case|:
case|case
name|STRUCT_FIELD_TAG
case|:
return|return
name|TS_MEMORY_TAG
return|;
default|default:
return|return
name|TS_DECL_NON_COMMON
return|;
block|}
block|}
case|case
name|tcc_type
case|:
return|return
name|TS_TYPE
return|;
case|case
name|tcc_reference
case|:
case|case
name|tcc_comparison
case|:
case|case
name|tcc_unary
case|:
case|case
name|tcc_binary
case|:
case|case
name|tcc_expression
case|:
case|case
name|tcc_statement
case|:
return|return
name|TS_EXP
return|;
default|default:
comment|/* tcc_constant and tcc_exceptional */
break|break;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* tcc_constant cases.  */
case|case
name|INTEGER_CST
case|:
return|return
name|TS_INT_CST
return|;
case|case
name|REAL_CST
case|:
return|return
name|TS_REAL_CST
return|;
case|case
name|COMPLEX_CST
case|:
return|return
name|TS_COMPLEX
return|;
case|case
name|VECTOR_CST
case|:
return|return
name|TS_VECTOR
return|;
case|case
name|STRING_CST
case|:
return|return
name|TS_STRING
return|;
comment|/* tcc_exceptional cases.  */
case|case
name|ERROR_MARK
case|:
return|return
name|TS_COMMON
return|;
case|case
name|IDENTIFIER_NODE
case|:
return|return
name|TS_IDENTIFIER
return|;
case|case
name|TREE_LIST
case|:
return|return
name|TS_LIST
return|;
case|case
name|TREE_VEC
case|:
return|return
name|TS_VEC
return|;
case|case
name|PHI_NODE
case|:
return|return
name|TS_PHI_NODE
return|;
case|case
name|SSA_NAME
case|:
return|return
name|TS_SSA_NAME
return|;
case|case
name|PLACEHOLDER_EXPR
case|:
return|return
name|TS_COMMON
return|;
case|case
name|STATEMENT_LIST
case|:
return|return
name|TS_STATEMENT_LIST
return|;
case|case
name|BLOCK
case|:
return|return
name|TS_BLOCK
return|;
case|case
name|CONSTRUCTOR
case|:
return|return
name|TS_CONSTRUCTOR
return|;
case|case
name|TREE_BINFO
case|:
return|return
name|TS_BINFO
return|;
case|case
name|VALUE_HANDLE
case|:
return|return
name|TS_VALUE_HANDLE
return|;
case|case
name|OMP_CLAUSE
case|:
return|return
name|TS_OMP_CLAUSE
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size    or offset that depends on a field within a record.  */
end_comment

begin_function
name|bool
name|contains_placeholder_p
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
if|if
condition|(
operator|!
name|exp
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PLACEHOLDER_EXPR
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|tcc_reference
case|:
comment|/* Don't look at any PLACEHOLDER_EXPRs that might be in index or bit 	 position computations since they will be converted into a 	 WITH_RECORD_EXPR involving the reference, which will assume 	 here will be valid.  */
return|return
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|tcc_exceptional
case|:
if|if
condition|(
name|code
operator|==
name|TREE_LIST
condition|)
return|return
operator|(
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|||
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
return|;
break|break;
case|case
name|tcc_unary
case|:
case|case
name|tcc_binary
case|:
case|case
name|tcc_comparison
case|:
case|case
name|tcc_expression
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|COMPOUND_EXPR
case|:
comment|/* Ignoring the first operand isn't quite right, but works best.  */
return|return
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
return|return
operator|(
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|CALL_EXPR
case|:
return|return
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
return|return
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
literal|2
case|:
return|return
operator|(
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if any part of the computation of TYPE involves a    PLACEHOLDER_EXPR.  This includes size, bounds, qualifiers    (for QUAL_UNION_TYPE) and field positions.  */
end_comment

begin_function
specifier|static
name|bool
name|type_contains_placeholder_1
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
comment|/* If the size contains a placeholder or the parent type (component type in      the case of arrays) type involves a placeholder, this type does.  */
if|if
condition|(
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|||
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|type_contains_placeholder_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
comment|/* Now do type-specific checks.  Note that the last part of the check above      greatly limits what we have to do below.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|VOID_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
return|return
name|false
return|;
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
comment|/* Here we just check the bounds.  */
return|return
operator|(
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|||
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|ARRAY_TYPE
case|:
comment|/* We're already checked the component type (TREE_TYPE), so just check 	 the index type.  */
return|return
name|type_contains_placeholder_p
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
block|{
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|(
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|&&
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|DECL_QUALIFIER
argument_list|(
name|field
argument_list|)
argument_list|)
operator|)
operator|||
name|type_contains_placeholder_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bool
name|type_contains_placeholder_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|bool
name|result
decl_stmt|;
comment|/* If the contains_placeholder_bits field has been initialized,      then we know the answer.  */
if|if
condition|(
name|TYPE_CONTAINS_PLACEHOLDER_INTERNAL
argument_list|(
name|type
argument_list|)
operator|>
literal|0
condition|)
return|return
name|TYPE_CONTAINS_PLACEHOLDER_INTERNAL
argument_list|(
name|type
argument_list|)
operator|-
literal|1
return|;
comment|/* Indicate that we've seen this type node, and the answer is false.      This is what we want to return if we run into recursion via fields.  */
name|TYPE_CONTAINS_PLACEHOLDER_INTERNAL
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Compute the real value.  */
name|result
operator|=
name|type_contains_placeholder_1
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Store the real value.  */
name|TYPE_CONTAINS_PLACEHOLDER_INTERNAL
argument_list|(
name|type
argument_list|)
operator|=
name|result
operator|+
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a tree EXP, a FIELD_DECL F, and a replacement value R,    return a tree with all occurrences of references to F in a    PLACEHOLDER_EXPR replaced by R.   Note that we assume here that EXP    contains only arithmetic expressions or a CALL_EXPR with a    PLACEHOLDER_EXPR occurring only in its arglist.  */
end_comment

begin_function
name|tree
name|substitute_in_expr
parameter_list|(
name|tree
name|exp
parameter_list|,
name|tree
name|f
parameter_list|,
name|tree
name|r
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|op3
decl_stmt|;
name|tree
name|new
decl_stmt|;
name|tree
name|inner
decl_stmt|;
comment|/* We handle TREE_LIST and COMPONENT_REF separately.  */
if|if
condition|(
name|code
operator|==
name|TREE_LIST
condition|)
block|{
name|op0
operator|=
name|SUBSTITUTE_IN_EXPR
argument_list|(
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|op1
operator|=
name|SUBSTITUTE_IN_EXPR
argument_list|(
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
operator|&&
name|op1
operator|==
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|exp
return|;
return|return
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|COMPONENT_REF
condition|)
block|{
comment|/* If this expression is getting a value from a PLACEHOLDER_EXPR 	and it is the right field, replace it with R.  */
for|for
control|(
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
init|;
name|REFERENCE_CLASS_P
argument_list|(
name|inner
argument_list|)
condition|;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|==
name|f
condition|)
return|return
name|r
return|;
comment|/* If this expression hasn't been completed let, leave it alone.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
operator|==
literal|0
condition|)
return|return
name|exp
return|;
name|op0
operator|=
name|SUBSTITUTE_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|exp
return|;
name|new
operator|=
name|fold_build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|tcc_constant
case|:
case|case
name|tcc_declaration
case|:
return|return
name|exp
return|;
case|case
name|tcc_exceptional
case|:
case|case
name|tcc_unary
case|:
case|case
name|tcc_binary
case|:
case|case
name|tcc_comparison
case|:
case|case
name|tcc_expression
case|:
case|case
name|tcc_reference
case|:
switch|switch
condition|(
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
name|exp
return|;
case|case
literal|1
case|:
name|op0
operator|=
name|SUBSTITUTE_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|exp
return|;
name|new
operator|=
name|fold_build1
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|op0
operator|=
name|SUBSTITUTE_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|op1
operator|=
name|SUBSTITUTE_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|exp
return|;
name|new
operator|=
name|fold_build2
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|op0
operator|=
name|SUBSTITUTE_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|op1
operator|=
name|SUBSTITUTE_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|op2
operator|=
name|SUBSTITUTE_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|&&
name|op2
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|exp
return|;
name|new
operator|=
name|fold_build3
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|op0
operator|=
name|SUBSTITUTE_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|op1
operator|=
name|SUBSTITUTE_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|op2
operator|=
name|SUBSTITUTE_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|op3
operator|=
name|SUBSTITUTE_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|3
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|&&
name|op2
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|&&
name|op3
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|exp
return|;
name|new
operator|=
name|fold
argument_list|(
name|build4
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|op3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|TREE_READONLY
argument_list|(
name|new
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Similar, but look for a PLACEHOLDER_EXPR in EXP and find a replacement    for it within OBJ, a tree that is an object or a chain of references.  */
end_comment

begin_function
name|tree
name|substitute_placeholder_in_expr
parameter_list|(
name|tree
name|exp
parameter_list|,
name|tree
name|obj
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|op3
decl_stmt|;
comment|/* If this is a PLACEHOLDER_EXPR, see if we find a corresponding type      in the chain of OBJ.  */
if|if
condition|(
name|code
operator|==
name|PLACEHOLDER_EXPR
condition|)
block|{
name|tree
name|need_type
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|elt
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|obj
init|;
name|elt
operator|!=
literal|0
condition|;
name|elt
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|COND_EXPR
operator|)
condition|?
name|TREE_OPERAND
argument_list|(
name|elt
argument_list|,
literal|1
argument_list|)
else|:
operator|(
name|REFERENCE_CLASS_P
argument_list|(
name|elt
argument_list|)
operator|||
name|UNARY_CLASS_P
argument_list|(
name|elt
argument_list|)
operator|||
name|BINARY_CLASS_P
argument_list|(
name|elt
argument_list|)
operator|||
name|EXPRESSION_CLASS_P
argument_list|(
name|elt
argument_list|)
operator|)
condition|?
name|TREE_OPERAND
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|)
else|:
literal|0
operator|)
control|)
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
name|need_type
condition|)
return|return
name|elt
return|;
for|for
control|(
name|elt
operator|=
name|obj
init|;
name|elt
operator|!=
literal|0
condition|;
name|elt
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|COND_EXPR
operator|)
condition|?
name|TREE_OPERAND
argument_list|(
name|elt
argument_list|,
literal|1
argument_list|)
else|:
operator|(
name|REFERENCE_CLASS_P
argument_list|(
name|elt
argument_list|)
operator|||
name|UNARY_CLASS_P
argument_list|(
name|elt
argument_list|)
operator|||
name|BINARY_CLASS_P
argument_list|(
name|elt
argument_list|)
operator|||
name|EXPRESSION_CLASS_P
argument_list|(
name|elt
argument_list|)
operator|)
condition|?
name|TREE_OPERAND
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|)
else|:
literal|0
operator|)
control|)
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
operator|==
name|need_type
operator|)
condition|)
return|return
name|fold_build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|need_type
argument_list|,
name|elt
argument_list|)
return|;
comment|/* If we didn't find it, return the original PLACEHOLDER_EXPR.  If it 	 survives until RTL generation, there will be an error.  */
return|return
name|exp
return|;
block|}
comment|/* TREE_LIST is special because we need to look at TREE_VALUE      and TREE_CHAIN, not TREE_OPERANDS.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|TREE_LIST
condition|)
block|{
name|op0
operator|=
name|SUBSTITUTE_PLACEHOLDER_IN_EXPR
argument_list|(
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|op1
operator|=
name|SUBSTITUTE_PLACEHOLDER_IN_EXPR
argument_list|(
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
operator|&&
name|op1
operator|==
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|exp
return|;
return|return
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
block|}
else|else
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|tcc_constant
case|:
case|case
name|tcc_declaration
case|:
return|return
name|exp
return|;
case|case
name|tcc_exceptional
case|:
case|case
name|tcc_unary
case|:
case|case
name|tcc_binary
case|:
case|case
name|tcc_comparison
case|:
case|case
name|tcc_expression
case|:
case|case
name|tcc_reference
case|:
case|case
name|tcc_statement
case|:
switch|switch
condition|(
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
name|exp
return|;
case|case
literal|1
case|:
name|op0
operator|=
name|SUBSTITUTE_PLACEHOLDER_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|exp
return|;
else|else
return|return
name|fold_build1
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op0
argument_list|)
return|;
case|case
literal|2
case|:
name|op0
operator|=
name|SUBSTITUTE_PLACEHOLDER_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|op1
operator|=
name|SUBSTITUTE_PLACEHOLDER_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|exp
return|;
else|else
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
case|case
literal|3
case|:
name|op0
operator|=
name|SUBSTITUTE_PLACEHOLDER_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|op1
operator|=
name|SUBSTITUTE_PLACEHOLDER_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|op2
operator|=
name|SUBSTITUTE_PLACEHOLDER_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|&&
name|op2
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|exp
return|;
else|else
return|return
name|fold_build3
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
case|case
literal|4
case|:
name|op0
operator|=
name|SUBSTITUTE_PLACEHOLDER_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|op1
operator|=
name|SUBSTITUTE_PLACEHOLDER_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|op2
operator|=
name|SUBSTITUTE_PLACEHOLDER_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|op3
operator|=
name|SUBSTITUTE_PLACEHOLDER_IN_EXPR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|3
argument_list|)
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|&&
name|op2
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|&&
name|op3
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|exp
return|;
else|else
return|return
name|fold
argument_list|(
name|build4
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|op3
argument_list|)
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stabilize a reference so that we can use it any number of times    without causing its operands to be evaluated more than once.    Returns the stabilized reference.  This works by means of save_expr,    so see the caveats in the comments about save_expr.     Also allows conversion expressions whose operands are references.    Any other kind of expression is returned unchanged.  */
end_comment

begin_function
name|tree
name|stabilize_reference
parameter_list|(
name|tree
name|ref
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
comment|/* No action is needed in this case.  */
return|return
name|ref
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDIRECT_REF
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|INDIRECT_REF
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|COMPONENT_REF
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_FIELD_REF
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|BIT_FIELD_REF
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_RANGE_REF
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|ARRAY_RANGE_REF
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPOUND_EXPR
case|:
comment|/* We cannot wrap the first expression in a SAVE_EXPR, as then 	 it wouldn't be ignored.  This matters when dealing with 	 volatiles.  */
return|return
name|stabilize_reference_1
argument_list|(
name|ref
argument_list|)
return|;
comment|/* If arg isn't a kind of lvalue we recognize, make no change. 	 Caller should recognize the error for an invalid lvalue.  */
default|default:
return|return
name|ref
return|;
case|case
name|ERROR_MARK
case|:
return|return
name|error_mark_node
return|;
block|}
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of stabilize_reference; this is called for subtrees of    references.  Any expression with side-effects must be put in a SAVE_EXPR    to ensure that it is only evaluated once.     We don't put SAVE_EXPR nodes around everything, because assigning very    simple expressions to temporaries causes us to miss good opportunities    for optimizations.  Among other things, the opportunity to fold in the    addition of a constant into an addressing mode often gets lost, e.g.    "y[i+1] += x;".  In general, we take the approach that we should not make    an assignment unless we are forced into it - i.e., that any non-side effect    operator should be allowed, and that cse should take care of coalescing    multiple utterances of the same expression should that prove fruitful.  */
end_comment

begin_function
name|tree
name|stabilize_reference_1
parameter_list|(
name|tree
name|e
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
comment|/* We cannot ignore const expressions because it might be a reference      to a const array but whose index contains side-effects.  But we can      ignore things that are actual constant or that already have been      handled by this function.  */
if|if
condition|(
name|TREE_INVARIANT
argument_list|(
name|e
argument_list|)
condition|)
return|return
name|e
return|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|tcc_exceptional
case|:
case|case
name|tcc_type
case|:
case|case
name|tcc_declaration
case|:
case|case
name|tcc_comparison
case|:
case|case
name|tcc_statement
case|:
case|case
name|tcc_expression
case|:
case|case
name|tcc_reference
case|:
comment|/* If the expression has side-effects, then encase it in a SAVE_EXPR 	 so that it will only be evaluated once.  */
comment|/* The reference (r) and comparison (<) classes could be handled as 	 below, but it is generally faster to only evaluate them once.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|e
argument_list|)
condition|)
return|return
name|save_expr
argument_list|(
name|e
argument_list|)
return|;
return|return
name|e
return|;
case|case
name|tcc_constant
case|:
comment|/* Constants need no processing.  In fact, we should never reach 	 here.  */
return|return
name|e
return|;
case|case
name|tcc_binary
case|:
comment|/* Division is slow and tends to be compiled with jumps, 	 especially the division by powers of 2 that is often 	 found inside of an array reference.  So do it just once.  */
if|if
condition|(
name|code
operator|==
name|TRUNC_DIV_EXPR
operator|||
name|code
operator|==
name|TRUNC_MOD_EXPR
operator|||
name|code
operator|==
name|FLOOR_DIV_EXPR
operator|||
name|code
operator|==
name|FLOOR_MOD_EXPR
operator|||
name|code
operator|==
name|CEIL_DIV_EXPR
operator|||
name|code
operator|==
name|CEIL_MOD_EXPR
operator|||
name|code
operator|==
name|ROUND_DIV_EXPR
operator|||
name|code
operator|==
name|ROUND_MOD_EXPR
condition|)
return|return
name|save_expr
argument_list|(
name|e
argument_list|)
return|;
comment|/* Recursively stabilize each operand.  */
name|result
operator|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|tcc_unary
case|:
comment|/* Recursively stabilize each operand.  */
name|result
operator|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Low-level constructors for expressions.  */
end_comment

begin_comment
comment|/* A helper function for build1 and constant folders.  Set TREE_CONSTANT,    TREE_INVARIANT, and TREE_SIDE_EFFECTS for an ADDR_EXPR.  */
end_comment

begin_function
name|void
name|recompute_tree_invariant_for_addr_expr
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|node
decl_stmt|;
name|bool
name|tc
init|=
name|true
decl_stmt|,
name|ti
init|=
name|true
decl_stmt|,
name|se
init|=
name|false
decl_stmt|;
comment|/* We started out assuming this address is both invariant and constant, but      does not have side effects.  Now go down any handled components and see if      any of them involve offsets that are either non-constant or non-invariant.      Also check for side-effects.       ??? Note that this code makes no attempt to deal with the case where      taking the address of something causes a copy due to misalignment.  */
define|#
directive|define
name|UPDATE_TITCSE
parameter_list|(
name|NODE
parameter_list|)
define|\
value|do { tree _node = (NODE); \      if (_node&& !TREE_INVARIANT (_node)) ti = false; \      if (_node&& !TREE_CONSTANT (_node)) tc = false; \      if (_node&& TREE_SIDE_EFFECTS (_node)) se = true; } while (0)
for|for
control|(
name|node
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
init|;
name|handled_component_p
argument_list|(
name|node
argument_list|)
condition|;
name|node
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
control|)
block|{
comment|/* If the first operand doesn't have an ARRAY_TYPE, this is a bogus 	 array reference (probably made temporarily by the G++ front end), 	 so ignore all the operands.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|ARRAY_RANGE_REF
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|UPDATE_TITCSE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|2
argument_list|)
condition|)
name|UPDATE_TITCSE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|3
argument_list|)
condition|)
name|UPDATE_TITCSE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Likewise, just because this is a COMPONENT_REF doesn't mean we have a 	 FIELD_DECL, apparently.  The G++ front end can put something else 	 there, at least temporarily.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|2
argument_list|)
condition|)
name|UPDATE_TITCSE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
name|UPDATE_TITCSE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
name|lang_hooks
operator|.
name|expr_to_decl
argument_list|(
name|node
argument_list|,
operator|&
name|tc
argument_list|,
operator|&
name|ti
argument_list|,
operator|&
name|se
argument_list|)
expr_stmt|;
comment|/* Now see what's inside.  If it's an INDIRECT_REF, copy our properties from      the address, since&(*a)->b is a form of addition.  If it's a decl, it's      invariant and constant if the decl is static.  It's also invariant if it's      a decl in the current function.  Taking the address of a volatile variable      is not volatile.  If it's a constant, the address is both invariant and      constant.  Otherwise it's neither.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|UPDATE_TITCSE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|staticp
argument_list|(
name|node
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|decl_function_context
argument_list|(
name|node
argument_list|)
operator|==
name|current_function_decl
comment|/* Addresses of thread-local variables are invariant.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_THREAD_LOCAL_P
argument_list|(
name|node
argument_list|)
operator|)
condition|)
name|tc
operator|=
name|false
expr_stmt|;
else|else
name|ti
operator|=
name|tc
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_CLASS_P
argument_list|(
name|node
argument_list|)
condition|)
empty_stmt|;
else|else
block|{
name|ti
operator|=
name|tc
operator|=
name|false
expr_stmt|;
name|se
operator||=
name|TREE_SIDE_EFFECTS
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
name|tc
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|ti
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
name|se
expr_stmt|;
undef|#
directive|undef
name|UPDATE_TITCSE
block|}
end_function

begin_comment
comment|/* Build an expression of code CODE, data type TYPE, and operands as    specified.  Expressions and reference nodes can be created this way.    Constants, decls, types and misc nodes cannot be.     We define 5 non-variadic functions, from 0 to 4 arguments.  This is    enough for all extant tree codes.  */
end_comment

begin_function
name|tree
name|build0_stat
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|tt
name|MEM_STAT_DECL
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node_stat
argument_list|(
argument|code PASS_MEM_STAT
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|tt
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|build1_stat
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|node
name|MEM_STAT_DECL
parameter_list|)
block|{
name|int
name|length
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_exp
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_kind
name|kind
decl_stmt|;
endif|#
directive|endif
name|tree
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|tcc_statement
case|:
comment|/* an expression with side effects */
name|kind
operator|=
name|s_kind
expr_stmt|;
break|break;
case|case
name|tcc_reference
case|:
comment|/* a reference */
name|kind
operator|=
name|r_kind
expr_stmt|;
break|break;
default|default:
name|kind
operator|=
name|e_kind
expr_stmt|;
break|break;
block|}
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|kind
index|]
operator|++
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|kind
index|]
operator|+=
name|length
expr_stmt|;
endif|#
directive|endif
name|gcc_assert
argument_list|(
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|ggc_alloc_zone_pass_stat
argument_list|(
name|length
argument_list|,
operator|&
name|tree_zone
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|SET_EXPR_LOCATION
argument_list|(
name|t
argument_list|,
name|UNKNOWN_LOCATION
argument_list|)
expr_stmt|;
else|#
directive|else
name|SET_EXPR_LOCUS
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|node
expr_stmt|;
name|TREE_BLOCK
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|node
operator|&&
operator|!
name|TYPE_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_statement
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|VA_ARG_EXPR
case|:
comment|/* All of these have side-effects, no matter what their 	 operands are.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MISALIGNED_INDIRECT_REF
case|:
case|case
name|ALIGN_INDIRECT_REF
case|:
case|case
name|INDIRECT_REF
case|:
comment|/* Whether a dereference is readonly has nothing to do with whether 	 its operand is readonly.  */
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|node
condition|)
name|recompute_tree_invariant_for_addr_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_unary
operator|||
name|code
operator|==
name|VIEW_CONVERT_EXPR
operator|)
operator|&&
name|node
operator|&&
operator|!
name|TYPE_P
argument_list|(
name|node
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|node
argument_list|)
condition|)
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_unary
operator|||
name|code
operator|==
name|VIEW_CONVERT_EXPR
operator|)
operator|&&
name|node
operator|&&
name|TREE_INVARIANT
argument_list|(
name|node
argument_list|)
condition|)
name|TREE_INVARIANT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_reference
operator|&&
name|node
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|node
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|t
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PROCESS_ARG
parameter_list|(
name|N
parameter_list|)
define|\
value|do {					\     TREE_OPERAND (t, N) = arg##N;	\     if (arg##N&&!TYPE_P (arg##N))	\       {					\         if (TREE_SIDE_EFFECTS (arg##N))	\ 	  side_effects = 1;		\         if (!TREE_READONLY (arg##N))	\ 	  read_only = 0;		\         if (!TREE_CONSTANT (arg##N))	\ 	  constant = 0;			\ 	if (!TREE_INVARIANT (arg##N))	\ 	  invariant = 0;		\       }					\   } while (0)
end_define

begin_function
name|tree
name|build2_stat
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|tt
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
name|MEM_STAT_DECL
parameter_list|)
block|{
name|bool
name|constant
decl_stmt|,
name|read_only
decl_stmt|,
name|side_effects
decl_stmt|,
name|invariant
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|==
literal|2
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node_stat
argument_list|(
argument|code PASS_MEM_STAT
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|tt
expr_stmt|;
comment|/* Below, we automatically set TREE_SIDE_EFFECTS and TREE_READONLY for the      result based on those same flags for the arguments.  But if the      arguments aren't really even `tree' expressions, we shouldn't be trying      to do this.  */
comment|/* Expressions without side effects may be constant if their      arguments are as well.  */
name|constant
operator|=
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_comparison
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_binary
operator|)
expr_stmt|;
name|read_only
operator|=
literal|1
expr_stmt|;
name|side_effects
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|invariant
operator|=
name|constant
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|=
name|read_only
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
name|constant
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|invariant
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
name|side_effects
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_reference
operator|&&
name|arg0
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|arg0
argument_list|)
operator|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|build3_stat
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|tt
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|tree
name|arg2
name|MEM_STAT_DECL
parameter_list|)
block|{
name|bool
name|constant
decl_stmt|,
name|read_only
decl_stmt|,
name|side_effects
decl_stmt|,
name|invariant
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|==
literal|3
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node_stat
argument_list|(
argument|code PASS_MEM_STAT
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|tt
expr_stmt|;
name|side_effects
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CALL_EXPR
operator|&&
operator|!
name|side_effects
condition|)
block|{
name|tree
name|node
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Calls have side-effects, except those to const or 	 pure functions.  */
name|i
operator|=
name|call_expr_flags
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|&
operator|(
name|ECF_CONST
operator||
name|ECF_PURE
operator|)
operator|)
condition|)
name|side_effects
operator|=
literal|1
expr_stmt|;
comment|/* And even those have side-effects if their arguments do.  */
else|else
for|for
control|(
name|node
operator|=
name|arg1
init|;
name|node
condition|;
name|node
operator|=
name|TREE_CHAIN
argument_list|(
name|node
argument_list|)
control|)
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_VALUE
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
block|{
name|side_effects
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
name|side_effects
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_reference
operator|&&
name|arg0
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|arg0
argument_list|)
operator|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|build4_stat
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|tt
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|tree
name|arg2
parameter_list|,
name|tree
name|arg3
name|MEM_STAT_DECL
parameter_list|)
block|{
name|bool
name|constant
decl_stmt|,
name|read_only
decl_stmt|,
name|side_effects
decl_stmt|,
name|invariant
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|==
literal|4
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node_stat
argument_list|(
argument|code PASS_MEM_STAT
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|tt
expr_stmt|;
name|side_effects
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
name|side_effects
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_reference
operator|&&
name|arg0
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|arg0
argument_list|)
operator|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|build5_stat
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|tt
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|tree
name|arg2
parameter_list|,
name|tree
name|arg3
parameter_list|,
name|tree
name|arg4
name|MEM_STAT_DECL
parameter_list|)
block|{
name|bool
name|constant
decl_stmt|,
name|read_only
decl_stmt|,
name|side_effects
decl_stmt|,
name|invariant
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|==
literal|5
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node_stat
argument_list|(
argument|code PASS_MEM_STAT
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|tt
expr_stmt|;
name|side_effects
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
name|side_effects
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_reference
operator|&&
name|arg0
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|arg0
argument_list|)
operator|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|build7_stat
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|tt
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|tree
name|arg2
parameter_list|,
name|tree
name|arg3
parameter_list|,
name|tree
name|arg4
parameter_list|,
name|tree
name|arg5
parameter_list|,
name|tree
name|arg6
name|MEM_STAT_DECL
parameter_list|)
block|{
name|bool
name|constant
decl_stmt|,
name|read_only
decl_stmt|,
name|side_effects
decl_stmt|,
name|invariant
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|gcc_assert
argument_list|(
name|code
operator|==
name|TARGET_MEM_REF
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node_stat
argument_list|(
argument|code PASS_MEM_STAT
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|tt
expr_stmt|;
name|side_effects
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|PROCESS_ARG
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
name|side_effects
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Similar except don't specify the TREE_TYPE    and leave the TREE_SIDE_EFFECTS as 0.    It is permissible for arguments to be null,    or even garbage if their values do not matter.  */
end_comment

begin_function
name|tree
name|build_nt
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
modifier|...
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|va_list
name|p
decl_stmt|;
name|va_start
argument_list|(
name|p
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|length
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a DECL_... node of code CODE, name NAME and data type TYPE.    We do NOT enter this node in any sort of symbol table.     layout_decl is used to set up the decl's storage layout.    Other slots are initialized to 0 or null pointers.  */
end_comment

begin_function
name|tree
name|build_decl_stat
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|type
name|MEM_STAT_DECL
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|make_node_stat
argument_list|(
argument|code PASS_MEM_STAT
argument_list|)
expr_stmt|;
comment|/*  if (type == error_mark_node)     type = integer_type_node; */
comment|/* That is not done, deliberately, so that having error_mark_node    as the type can suppress useless errors in the use of this variable.  */
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|name
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|VAR_DECL
operator|||
name|code
operator|==
name|PARM_DECL
operator|||
name|code
operator|==
name|RESULT_DECL
condition|)
name|layout_decl
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Builds and returns function declaration with NAME and TYPE.  */
end_comment

begin_function
name|tree
name|build_fn_decl
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|id
init|=
name|get_identifier
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|id
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* BLOCK nodes are used to represent the structure of binding contours    and declarations, once those contours have been exited and their contents    compiled.  This information is used for outputting debugging info.  */
end_comment

begin_function
name|tree
name|build_block
parameter_list|(
name|tree
name|vars
parameter_list|,
name|tree
name|subblocks
parameter_list|,
name|tree
name|supercontext
parameter_list|,
name|tree
name|chain
parameter_list|)
block|{
name|tree
name|block
init|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
decl_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|vars
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
name|subblocks
expr_stmt|;
name|BLOCK_SUPERCONTEXT
argument_list|(
name|block
argument_list|)
operator|=
name|supercontext
expr_stmt|;
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
operator|=
name|chain
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/* ! defined(USE_MAPPED_LOCATION) */
end_comment

begin_comment
comment|/* ??? gengtype doesn't handle conditionals */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|source_locus
name|last_annotated_node
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
end_ifdef

begin_function
name|expanded_location
name|expand_location
parameter_list|(
name|source_location
name|loc
parameter_list|)
block|{
name|expanded_location
name|xloc
decl_stmt|;
if|if
condition|(
name|loc
operator|==
literal|0
condition|)
block|{
name|xloc
operator|.
name|file
operator|=
name|NULL
expr_stmt|;
name|xloc
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|xloc
operator|.
name|column
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|struct
name|line_map
modifier|*
name|map
init|=
name|linemap_lookup
argument_list|(
operator|&
name|line_table
argument_list|,
name|loc
argument_list|)
decl_stmt|;
name|xloc
operator|.
name|file
operator|=
name|map
operator|->
name|to_file
expr_stmt|;
name|xloc
operator|.
name|line
operator|=
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|xloc
operator|.
name|column
operator|=
name|SOURCE_COLUMN
argument_list|(
name|map
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return
name|xloc
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Record the exact location where an expression or an identifier were    encountered.  */
end_comment

begin_function
name|void
name|annotate_with_file_line
parameter_list|(
name|tree
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
comment|/* Roughly one percent of the calls to this function are to annotate      a node with the same information already attached to that node!      Just return instead of wasting memory.  */
if|if
condition|(
name|EXPR_LOCUS
argument_list|(
name|node
argument_list|)
operator|&&
name|EXPR_LINENO
argument_list|(
name|node
argument_list|)
operator|==
name|line
operator|&&
operator|(
name|EXPR_FILENAME
argument_list|(
name|node
argument_list|)
operator|==
name|file
operator|||
operator|!
name|strcmp
argument_list|(
name|EXPR_FILENAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|file
argument_list|)
operator|)
condition|)
block|{
name|last_annotated_node
operator|=
name|EXPR_LOCUS
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* In heavily macroized code (such as GCC itself) this single      entry cache can reduce the number of allocations by more      than half.  */
if|if
condition|(
name|last_annotated_node
operator|&&
name|last_annotated_node
operator|->
name|line
operator|==
name|line
operator|&&
operator|(
name|last_annotated_node
operator|->
name|file
operator|==
name|file
operator|||
operator|!
name|strcmp
argument_list|(
name|last_annotated_node
operator|->
name|file
argument_list|,
name|file
argument_list|)
operator|)
condition|)
block|{
name|SET_EXPR_LOCUS
argument_list|(
name|node
argument_list|,
name|last_annotated_node
argument_list|)
expr_stmt|;
return|return;
block|}
name|SET_EXPR_LOCUS
argument_list|(
name|node
argument_list|,
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|location_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|EXPR_LINENO
argument_list|(
name|node
argument_list|)
operator|=
name|line
expr_stmt|;
name|EXPR_FILENAME
argument_list|(
name|node
argument_list|)
operator|=
name|file
expr_stmt|;
name|last_annotated_node
operator|=
name|EXPR_LOCUS
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|annotate_with_locus
parameter_list|(
name|tree
name|node
parameter_list|,
name|location_t
name|locus
parameter_list|)
block|{
name|annotate_with_file_line
argument_list|(
name|node
argument_list|,
name|locus
operator|.
name|file
argument_list|,
name|locus
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Return a declaration like DDECL except that its DECL_ATTRIBUTES    is ATTRIBUTE.  */
end_comment

begin_function
name|tree
name|build_decl_attribute_variant
parameter_list|(
name|tree
name|ddecl
parameter_list|,
name|tree
name|attribute
parameter_list|)
block|{
name|DECL_ATTRIBUTES
argument_list|(
name|ddecl
argument_list|)
operator|=
name|attribute
expr_stmt|;
return|return
name|ddecl
return|;
block|}
end_function

begin_comment
comment|/* Borrowed from hashtab.c iterative_hash implementation.  */
end_comment

begin_define
define|#
directive|define
name|mix
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|{ \   a -= b; a -= c; a ^= (c>>13); \   b -= c; b -= a; b ^= (a<< 8); \   c -= a; c -= b; c ^= ((b&0xffffffff)>>13); \   a -= b; a -= c; a ^= ((c&0xffffffff)>>12); \   b -= c; b -= a; b = (b ^ (a<<16))& 0xffffffff; \   c -= a; c -= b; c = (c ^ (b>> 5))& 0xffffffff; \   a -= b; a -= c; a = (a ^ (c>> 3))& 0xffffffff; \   b -= c; b -= a; b = (b ^ (a<<10))& 0xffffffff; \   c -= a; c -= b; c = (c ^ (b>>15))& 0xffffffff; \ }
end_define

begin_comment
comment|/* Produce good hash value combining VAL and VAL2.  */
end_comment

begin_function
specifier|static
specifier|inline
name|hashval_t
name|iterative_hash_hashval_t
parameter_list|(
name|hashval_t
name|val
parameter_list|,
name|hashval_t
name|val2
parameter_list|)
block|{
comment|/* the golden ratio; an arbitrary value.  */
name|hashval_t
name|a
init|=
literal|0x9e3779b9
decl_stmt|;
name|mix
argument_list|(
name|a
argument_list|,
name|val
argument_list|,
name|val2
argument_list|)
expr_stmt|;
return|return
name|val2
return|;
block|}
end_function

begin_comment
comment|/* Produce good hash value combining PTR and VAL2.  */
end_comment

begin_function
specifier|static
specifier|inline
name|hashval_t
name|iterative_hash_pointer
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|hashval_t
name|val2
parameter_list|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|ptr
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|hashval_t
argument_list|)
condition|)
return|return
name|iterative_hash_hashval_t
argument_list|(
operator|(
name|size_t
operator|)
name|ptr
argument_list|,
name|val2
argument_list|)
return|;
else|else
block|{
name|hashval_t
name|a
init|=
operator|(
name|hashval_t
operator|)
operator|(
name|size_t
operator|)
name|ptr
decl_stmt|;
comment|/* Avoid warnings about shifting of more than the width of the type on          hosts that won't execute this path.  */
name|int
name|zero
init|=
literal|0
decl_stmt|;
name|hashval_t
name|b
init|=
call|(
name|hashval_t
call|)
argument_list|(
operator|(
name|size_t
operator|)
name|ptr
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|hashval_t
argument_list|)
operator|*
literal|8
operator|+
name|zero
operator|)
argument_list|)
decl_stmt|;
name|mix
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|val2
argument_list|)
expr_stmt|;
return|return
name|val2
return|;
block|}
block|}
end_function

begin_comment
comment|/* Produce good hash value combining VAL and VAL2.  */
end_comment

begin_function
specifier|static
specifier|inline
name|hashval_t
name|iterative_hash_host_wide_int
parameter_list|(
name|HOST_WIDE_INT
name|val
parameter_list|,
name|hashval_t
name|val2
parameter_list|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|hashval_t
argument_list|)
condition|)
return|return
name|iterative_hash_hashval_t
argument_list|(
name|val
argument_list|,
name|val2
argument_list|)
return|;
else|else
block|{
name|hashval_t
name|a
init|=
operator|(
name|hashval_t
operator|)
name|val
decl_stmt|;
comment|/* Avoid warnings about shifting of more than the width of the type on          hosts that won't execute this path.  */
name|int
name|zero
init|=
literal|0
decl_stmt|;
name|hashval_t
name|b
init|=
call|(
name|hashval_t
call|)
argument_list|(
name|val
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|hashval_t
argument_list|)
operator|*
literal|8
operator|+
name|zero
operator|)
argument_list|)
decl_stmt|;
name|mix
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|val2
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
operator|>
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|hashval_t
argument_list|)
condition|)
block|{
name|hashval_t
name|a
init|=
call|(
name|hashval_t
call|)
argument_list|(
name|val
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|hashval_t
argument_list|)
operator|*
literal|16
operator|+
name|zero
operator|)
argument_list|)
decl_stmt|;
name|hashval_t
name|b
init|=
call|(
name|hashval_t
call|)
argument_list|(
name|val
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|hashval_t
argument_list|)
operator|*
literal|24
operator|+
name|zero
operator|)
argument_list|)
decl_stmt|;
name|mix
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|val2
argument_list|)
expr_stmt|;
block|}
return|return
name|val2
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a type like TTYPE except that its TYPE_ATTRIBUTE    is ATTRIBUTE and its qualifiers are QUALS.     Record such modified types already made so we don't make duplicates.  */
end_comment

begin_function
specifier|static
name|tree
name|build_type_attribute_qual_variant
parameter_list|(
name|tree
name|ttype
parameter_list|,
name|tree
name|attribute
parameter_list|,
name|int
name|quals
parameter_list|)
block|{
if|if
condition|(
operator|!
name|attribute_list_equal
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|ttype
argument_list|)
argument_list|,
name|attribute
argument_list|)
condition|)
block|{
name|hashval_t
name|hashcode
init|=
literal|0
decl_stmt|;
name|tree
name|ntype
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|ttype
argument_list|)
decl_stmt|;
name|ntype
operator|=
name|copy_node
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
name|TYPE_POINTER_TO
argument_list|(
name|ntype
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|ntype
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_ATTRIBUTES
argument_list|(
name|ntype
argument_list|)
operator|=
name|attribute
expr_stmt|;
comment|/* Create a new main variant of TYPE.  */
name|TYPE_MAIN_VARIANT
argument_list|(
name|ntype
argument_list|)
operator|=
name|ntype
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|ntype
argument_list|)
operator|=
literal|0
expr_stmt|;
name|set_type_quals
argument_list|(
name|ntype
argument_list|,
name|TYPE_UNQUALIFIED
argument_list|)
expr_stmt|;
name|hashcode
operator|=
name|iterative_hash_object
argument_list|(
name|code
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|ntype
argument_list|)
condition|)
name|hashcode
operator|=
name|iterative_hash_object
argument_list|(
name|TYPE_HASH
argument_list|(
name|TREE_TYPE
argument_list|(
name|ntype
argument_list|)
argument_list|)
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
name|hashcode
operator|=
name|attribute_hash_list
argument_list|(
name|attribute
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|ntype
argument_list|)
condition|)
block|{
case|case
name|FUNCTION_TYPE
case|:
name|hashcode
operator|=
name|type_hash_list
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|ntype
argument_list|)
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
name|hashcode
operator|=
name|iterative_hash_object
argument_list|(
name|TYPE_HASH
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|ntype
argument_list|)
argument_list|)
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
name|hashcode
operator|=
name|iterative_hash_object
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|ntype
argument_list|)
argument_list|)
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
name|hashcode
operator|=
name|iterative_hash_object
argument_list|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|ntype
argument_list|)
argument_list|)
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
block|{
name|unsigned
name|int
name|precision
init|=
name|TYPE_PRECISION
argument_list|(
name|ntype
argument_list|)
decl_stmt|;
name|hashcode
operator|=
name|iterative_hash_object
argument_list|(
name|precision
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|ntype
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|ntype
argument_list|)
expr_stmt|;
name|ttype
operator|=
name|build_qualified_type
argument_list|(
name|ntype
argument_list|,
name|quals
argument_list|)
expr_stmt|;
block|}
return|return
name|ttype
return|;
block|}
end_function

begin_comment
comment|/* Return a type like TTYPE except that its TYPE_ATTRIBUTE    is ATTRIBUTE.     Record such modified types already made so we don't make duplicates.  */
end_comment

begin_function
name|tree
name|build_type_attribute_variant
parameter_list|(
name|tree
name|ttype
parameter_list|,
name|tree
name|attribute
parameter_list|)
block|{
return|return
name|build_type_attribute_qual_variant
argument_list|(
name|ttype
argument_list|,
name|attribute
argument_list|,
name|TYPE_QUALS
argument_list|(
name|ttype
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if IDENT is a valid name for attribute ATTR,    or zero if not.     We try both `text' and `__text__', ATTR may be either one.  */
end_comment

begin_comment
comment|/* ??? It might be a reasonable simplification to require ATTR to be only    `text'.  One might then also require attribute lists to be stored in    their canonicalized form.  */
end_comment

begin_function
specifier|static
name|int
name|is_attribute_with_length_p
parameter_list|(
specifier|const
name|char
modifier|*
name|attr
parameter_list|,
name|int
name|attr_len
parameter_list|,
name|tree
name|ident
parameter_list|)
block|{
name|int
name|ident_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ident
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|ident_len
operator|=
name|IDENTIFIER_LENGTH
argument_list|(
name|ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|ident_len
operator|==
name|attr_len
operator|&&
name|strcmp
argument_list|(
name|attr
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* If ATTR is `__text__', IDENT must be `text'; and vice versa.  */
if|if
condition|(
name|attr
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
name|gcc_assert
argument_list|(
name|attr
index|[
literal|1
index|]
operator|==
literal|'_'
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|attr
index|[
name|attr_len
operator|-
literal|2
index|]
operator|==
literal|'_'
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|attr
index|[
name|attr_len
operator|-
literal|1
index|]
operator|==
literal|'_'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ident_len
operator|==
name|attr_len
operator|-
literal|4
operator|&&
name|strncmp
argument_list|(
name|attr
operator|+
literal|2
argument_list|,
name|p
argument_list|,
name|attr_len
operator|-
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|ident_len
operator|==
name|attr_len
operator|+
literal|4
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
name|ident_len
operator|-
literal|2
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
name|ident_len
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|strncmp
argument_list|(
name|attr
argument_list|,
name|p
operator|+
literal|2
argument_list|,
name|attr_len
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if IDENT is a valid name for attribute ATTR,    or zero if not.     We try both `text' and `__text__', ATTR may be either one.  */
end_comment

begin_function
name|int
name|is_attribute_p
parameter_list|(
specifier|const
name|char
modifier|*
name|attr
parameter_list|,
name|tree
name|ident
parameter_list|)
block|{
return|return
name|is_attribute_with_length_p
argument_list|(
name|attr
argument_list|,
name|strlen
argument_list|(
name|attr
argument_list|)
argument_list|,
name|ident
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given an attribute name and a list of attributes, return a pointer to the    attribute's list element if the attribute is part of the list, or NULL_TREE    if not found.  If the attribute appears more than once, this only    returns the first occurrence; the TREE_CHAIN of the return value should    be passed back in if further occurrences are wanted.  */
end_comment

begin_function
name|tree
name|lookup_attribute
parameter_list|(
specifier|const
name|char
modifier|*
name|attr_name
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|tree
name|l
decl_stmt|;
name|size_t
name|attr_len
init|=
name|strlen
argument_list|(
name|attr_name
argument_list|)
decl_stmt|;
for|for
control|(
name|l
operator|=
name|list
init|;
name|l
condition|;
name|l
operator|=
name|TREE_CHAIN
argument_list|(
name|l
argument_list|)
control|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|l
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_attribute_with_length_p
argument_list|(
name|attr_name
argument_list|,
name|attr_len
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
return|return
name|l
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Remove any instances of attribute ATTR_NAME in LIST and return the    modified list.  */
end_comment

begin_function
name|tree
name|remove_attribute
parameter_list|(
specifier|const
name|char
modifier|*
name|attr_name
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|tree
modifier|*
name|p
decl_stmt|;
name|size_t
name|attr_len
init|=
name|strlen
argument_list|(
name|attr_name
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|list
init|;
operator|*
name|p
condition|;
control|)
block|{
name|tree
name|l
init|=
operator|*
name|p
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|l
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_attribute_with_length_p
argument_list|(
name|attr_name
argument_list|,
name|attr_len
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
operator|*
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|l
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Return an attribute list that is the union of a1 and a2.  */
end_comment

begin_function
name|tree
name|merge_attributes
parameter_list|(
name|tree
name|a1
parameter_list|,
name|tree
name|a2
parameter_list|)
block|{
name|tree
name|attributes
decl_stmt|;
comment|/* Either one unset?  Take the set one.  */
if|if
condition|(
operator|(
name|attributes
operator|=
name|a1
operator|)
operator|==
literal|0
condition|)
name|attributes
operator|=
name|a2
expr_stmt|;
comment|/* One that completely contains the other?  Take it.  */
elseif|else
if|if
condition|(
name|a2
operator|!=
literal|0
operator|&&
operator|!
name|attribute_list_contained
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
condition|)
block|{
if|if
condition|(
name|attribute_list_contained
argument_list|(
name|a2
argument_list|,
name|a1
argument_list|)
condition|)
name|attributes
operator|=
name|a2
expr_stmt|;
else|else
block|{
comment|/* Pick the longest list, and hang on the other list.  */
if|if
condition|(
name|list_length
argument_list|(
name|a1
argument_list|)
operator|<
name|list_length
argument_list|(
name|a2
argument_list|)
condition|)
name|attributes
operator|=
name|a2
operator|,
name|a2
operator|=
name|a1
expr_stmt|;
for|for
control|(
init|;
name|a2
operator|!=
literal|0
condition|;
name|a2
operator|=
name|TREE_CHAIN
argument_list|(
name|a2
argument_list|)
control|)
block|{
name|tree
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
name|lookup_attribute
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|a2
argument_list|)
argument_list|)
argument_list|,
name|attributes
argument_list|)
init|;
name|a
operator|!=
name|NULL_TREE
condition|;
name|a
operator|=
name|lookup_attribute
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|a2
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
operator|!=
name|NULL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|a2
argument_list|)
operator|!=
name|NULL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|a2
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|simple_cst_list_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|a2
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|a2
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|a
operator|==
name|NULL_TREE
condition|)
block|{
name|a1
operator|=
name|copy_node
argument_list|(
name|a2
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|a1
argument_list|)
operator|=
name|attributes
expr_stmt|;
name|attributes
operator|=
name|a1
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|attributes
return|;
block|}
end_function

begin_comment
comment|/* Given types T1 and T2, merge their attributes and return   the result.  */
end_comment

begin_function
name|tree
name|merge_type_attributes
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
return|return
name|merge_attributes
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given decls OLDDECL and NEWDECL, merge their attributes and return    the result.  */
end_comment

begin_function
name|tree
name|merge_decl_attributes
parameter_list|(
name|tree
name|olddecl
parameter_list|,
name|tree
name|newdecl
parameter_list|)
block|{
return|return
name|merge_attributes
argument_list|(
name|DECL_ATTRIBUTES
argument_list|(
name|olddecl
argument_list|)
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|TARGET_DLLIMPORT_DECL_ATTRIBUTES
end_if

begin_comment
comment|/* Specialization of merge_decl_attributes for various Windows targets.     This handles the following situation:       __declspec (dllimport) int foo;      int foo;     The second instance of `foo' nullifies the dllimport.  */
end_comment

begin_function
name|tree
name|merge_dllimport_decl_attributes
parameter_list|(
name|tree
name|old
parameter_list|,
name|tree
name|new
parameter_list|)
block|{
name|tree
name|a
decl_stmt|;
name|int
name|delete_dllimport_p
init|=
literal|1
decl_stmt|;
comment|/* What we need to do here is remove from `old' dllimport if it doesn't      appear in `new'.  dllimport behaves like extern: if a declaration is      marked dllimport and a definition appears later, then the object      is not dllimport'd.  We also remove a `new' dllimport if the old list      contains dllexport:  dllexport always overrides dllimport, regardless      of the order of declaration.  */
if|if
condition|(
operator|!
name|VAR_OR_FUNCTION_DECL_P
argument_list|(
name|new
argument_list|)
condition|)
name|delete_dllimport_p
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_DLLIMPORT_P
argument_list|(
name|new
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"dllexport"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|old
argument_list|)
argument_list|)
condition|)
block|{
name|DECL_DLLIMPORT_P
argument_list|(
name|new
argument_list|)
operator|=
literal|0
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%q+D already declared with dllexport attribute: "
literal|"dllimport ignored"
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_DLLIMPORT_P
argument_list|(
name|old
argument_list|)
operator|&&
operator|!
name|DECL_DLLIMPORT_P
argument_list|(
name|new
argument_list|)
condition|)
block|{
comment|/* Warn about overriding a symbol that has already been used. eg:            extern int __attribute__ ((dllimport)) foo; 	   int* bar () {return&foo;} 	   int foo;       */
if|if
condition|(
name|TREE_USED
argument_list|(
name|old
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%q+D redeclared without dllimport attribute "
literal|"after being referenced with dll linkage"
argument_list|,
name|new
argument_list|)
expr_stmt|;
comment|/* If we have used a variable's address with dllimport linkage, 	      keep the old DECL_DLLIMPORT_P flag: the ADDR_EXPR using the 	      decl may already have had TREE_INVARIANT and TREE_CONSTANT 	      computed. 	      We still remove the attribute so that assembler code refers 	      to '&foo rather than '_imp__foo'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|old
argument_list|)
condition|)
name|DECL_DLLIMPORT_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Let an inline definition silently override the external reference, 	 but otherwise warn about attribute inconsistency.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|VAR_DECL
operator|||
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|new
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%q+D redeclared without dllimport attribute: "
literal|"previous dllimport ignored"
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
else|else
name|delete_dllimport_p
operator|=
literal|0
expr_stmt|;
name|a
operator|=
name|merge_attributes
argument_list|(
name|DECL_ATTRIBUTES
argument_list|(
name|old
argument_list|)
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_dllimport_p
condition|)
block|{
name|tree
name|prev
decl_stmt|,
name|t
decl_stmt|;
specifier|const
name|size_t
name|attr_len
init|=
name|strlen
argument_list|(
literal|"dllimport"
argument_list|)
decl_stmt|;
comment|/* Scan the list for dllimport and delete it.  */
for|for
control|(
name|prev
operator|=
name|NULL_TREE
operator|,
name|t
operator|=
name|a
init|;
name|t
condition|;
name|prev
operator|=
name|t
operator|,
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|is_attribute_with_length_p
argument_list|(
literal|"dllimport"
argument_list|,
name|attr_len
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev
operator|==
name|NULL_TREE
condition|)
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|a
return|;
block|}
end_function

begin_comment
comment|/* Handle a "dllimport" or "dllexport" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
name|tree
name|handle_dll_attribute
parameter_list|(
name|tree
modifier|*
name|pnode
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|flags
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|node
init|=
operator|*
name|pnode
decl_stmt|;
comment|/* These attributes may apply to structure and union types being created,      but otherwise should pass to the declaration involved.  */
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
operator|(
operator|(
name|int
operator|)
name|ATTR_FLAG_DECL_NEXT
operator||
operator|(
name|int
operator|)
name|ATTR_FLAG_FUNCTION_NEXT
operator||
operator|(
name|int
operator|)
name|ATTR_FLAG_ARRAY_NEXT
operator|)
condition|)
block|{
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|tree_cons
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qs attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|!=
name|VAR_DECL
condition|)
block|{
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qs attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Report error on dllimport ambiguities seen now before they cause      any damage.  */
elseif|else
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"dllimport"
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|/* Honor any target-specific overrides. */
if|if
condition|(
operator|!
name|targetm
operator|.
name|valid_dllimport_attribute_p
argument_list|(
name|node
argument_list|)
condition|)
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"inline function %q+D declared as "
literal|" dllimport: attribute ignored"
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
comment|/* Like MS, treat definition of dllimported variables and 	 non-inlined functions on declaration as syntax errors. */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"function %q+D definition is marked dllimport"
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"variable %q+D definition is marked dllimport"
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
comment|/* `extern' needn't be specified with dllimport. 	     Specify `extern' now and hope for the best.  Sigh.  */
name|DECL_EXTERNAL
argument_list|(
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Also, implicitly give dllimport'd variables declared within 	     a function global scope, unless declared static.  */
if|if
condition|(
name|current_function_decl
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|node
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|no_add_attrs
operator|==
name|false
condition|)
name|DECL_DLLIMPORT_P
argument_list|(
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/*  Report error if symbol is not accessible at global scope.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|node
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"external linkage required for symbol %q+D because of "
literal|"%qs attribute"
argument_list|,
name|node
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_DLLIMPORT_DECL_ATTRIBUTES  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Set the type qualifiers for TYPE to TYPE_QUALS, which is a bitmask    of the various TYPE_QUAL values.  */
end_comment

begin_function
specifier|static
name|void
name|set_type_quals
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|type_quals
parameter_list|)
block|{
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_CONST
operator|)
operator|!=
literal|0
expr_stmt|;
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_VOLATILE
operator|)
operator|!=
literal|0
expr_stmt|;
name|TYPE_RESTRICT
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_RESTRICT
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns true iff cand is equivalent to base with type_quals.  */
end_comment

begin_function
name|bool
name|check_qualified_type
parameter_list|(
name|tree
name|cand
parameter_list|,
name|tree
name|base
parameter_list|,
name|int
name|type_quals
parameter_list|)
block|{
return|return
operator|(
name|TYPE_QUALS
argument_list|(
name|cand
argument_list|)
operator|==
name|type_quals
operator|&&
name|TYPE_NAME
argument_list|(
name|cand
argument_list|)
operator|==
name|TYPE_NAME
argument_list|(
name|base
argument_list|)
comment|/* Apparently this is needed for Objective-C.  */
operator|&&
name|TYPE_CONTEXT
argument_list|(
name|cand
argument_list|)
operator|==
name|TYPE_CONTEXT
argument_list|(
name|base
argument_list|)
operator|&&
name|attribute_list_equal
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|cand
argument_list|)
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|base
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a version of the TYPE, qualified as indicated by the    TYPE_QUALS, if one exists.  If no qualified version exists yet,    return NULL_TREE.  */
end_comment

begin_function
name|tree
name|get_qualified_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|type_quals
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator|==
name|type_quals
condition|)
return|return
name|type
return|;
comment|/* Search the chain of variants to see if there is already one there just      like the one we need to have.  If so, use that existing one.  We must      preserve the TYPE_NAME, since there is code that depends on this.  */
for|for
control|(
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|check_qualified_type
argument_list|(
name|t
argument_list|,
name|type
argument_list|,
name|type_quals
argument_list|)
condition|)
return|return
name|t
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Like get_qualified_type, but creates the type if it does not    exist.  This function never returns NULL_TREE.  */
end_comment

begin_function
name|tree
name|build_qualified_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|type_quals
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* See if we already have the appropriate qualified variant.  */
name|t
operator|=
name|get_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
comment|/* If not, build it.  */
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|t
operator|=
name|build_variant_type_copy
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|set_type_quals
argument_list|(
name|t
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Create a new distinct copy of TYPE.  The new type is made its own    MAIN_VARIANT.  */
end_comment

begin_function
name|tree
name|build_distinct_type_copy
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|t
init|=
name|copy_node
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|TYPE_POINTER_TO
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Make it its own variant.  */
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|t
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Note that it is now possible for TYPE_MIN_VALUE to be a value      whose TREE_TYPE is not t.  This can also happen in the Ada      frontend when using subtypes.  */
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Create a new variant of TYPE, equivalent but distinct.    This is so the caller can modify it.  */
end_comment

begin_function
name|tree
name|build_variant_type_copy
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|m
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|t
operator|=
name|build_distinct_type_copy
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Add the new type to the chain of variants of TYPE.  */
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
operator|=
name|t
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|m
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if the from tree in both tree maps are equal.  */
end_comment

begin_function
name|int
name|tree_map_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
block|{
specifier|const
name|struct
name|tree_map
modifier|*
name|a
init|=
name|va
decl_stmt|,
modifier|*
name|b
init|=
name|vb
decl_stmt|;
return|return
operator|(
name|a
operator|->
name|from
operator|==
name|b
operator|->
name|from
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Hash a from tree in a tree_map.  */
end_comment

begin_function
name|unsigned
name|int
name|tree_map_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|item
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
specifier|const
expr|struct
name|tree_map
operator|*
operator|)
name|item
operator|)
operator|->
name|hash
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if this tree map structure is marked for garbage collection    purposes.  We simply return true if the from tree is marked, so that this    structure goes away when the from tree goes away.  */
end_comment

begin_function
name|int
name|tree_map_marked_p
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|tree
name|from
init|=
operator|(
operator|(
expr|struct
name|tree_map
operator|*
operator|)
name|p
operator|)
operator|->
name|from
decl_stmt|;
return|return
name|ggc_marked_p
argument_list|(
name|from
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the trees in the tree_int_map *'s VA and VB are equal.  */
end_comment

begin_function
specifier|static
name|int
name|tree_int_map_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
block|{
specifier|const
name|struct
name|tree_int_map
modifier|*
name|a
init|=
name|va
decl_stmt|,
modifier|*
name|b
init|=
name|vb
decl_stmt|;
return|return
operator|(
name|a
operator|->
name|from
operator|==
name|b
operator|->
name|from
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Hash a from tree in the tree_int_map * ITEM.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|tree_int_map_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|item
parameter_list|)
block|{
return|return
name|htab_hash_pointer
argument_list|(
operator|(
operator|(
specifier|const
expr|struct
name|tree_int_map
operator|*
operator|)
name|item
operator|)
operator|->
name|from
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if this tree int map structure is marked for garbage collection    purposes.  We simply return true if the from tree_int_map *P's from tree is marked, so that this    structure goes away when the from tree goes away.  */
end_comment

begin_function
specifier|static
name|int
name|tree_int_map_marked_p
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|tree
name|from
init|=
operator|(
operator|(
expr|struct
name|tree_int_map
operator|*
operator|)
name|p
operator|)
operator|->
name|from
decl_stmt|;
return|return
name|ggc_marked_p
argument_list|(
name|from
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Lookup an init priority for FROM, and return it if we find one.  */
end_comment

begin_function
name|unsigned
name|short
name|decl_init_priority_lookup
parameter_list|(
name|tree
name|from
parameter_list|)
block|{
name|struct
name|tree_int_map
modifier|*
name|h
decl_stmt|,
name|in
decl_stmt|;
name|in
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|h
operator|=
name|htab_find_with_hash
argument_list|(
name|init_priority_for_decl
argument_list|,
operator|&
name|in
argument_list|,
name|htab_hash_pointer
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
return|return
name|h
operator|->
name|to
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Insert a mapping FROM->TO in the init priority hashtable.  */
end_comment

begin_function
name|void
name|decl_init_priority_insert
parameter_list|(
name|tree
name|from
parameter_list|,
name|unsigned
name|short
name|to
parameter_list|)
block|{
name|struct
name|tree_int_map
modifier|*
name|h
decl_stmt|;
name|void
modifier|*
modifier|*
name|loc
decl_stmt|;
name|h
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_int_map
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|from
operator|=
name|from
expr_stmt|;
name|h
operator|->
name|to
operator|=
name|to
expr_stmt|;
name|loc
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|init_priority_for_decl
argument_list|,
name|h
argument_list|,
name|htab_hash_pointer
argument_list|(
name|from
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|tree_int_map
operator|*
operator|*
operator|)
name|loc
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up a restrict qualified base decl for FROM.  */
end_comment

begin_function
name|tree
name|decl_restrict_base_lookup
parameter_list|(
name|tree
name|from
parameter_list|)
block|{
name|struct
name|tree_map
modifier|*
name|h
decl_stmt|;
name|struct
name|tree_map
name|in
decl_stmt|;
name|in
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|h
operator|=
name|htab_find_with_hash
argument_list|(
name|restrict_base_for_decl
argument_list|,
operator|&
name|in
argument_list|,
name|htab_hash_pointer
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|h
condition|?
name|h
operator|->
name|to
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Record the restrict qualified base TO for FROM.  */
end_comment

begin_function
name|void
name|decl_restrict_base_insert
parameter_list|(
name|tree
name|from
parameter_list|,
name|tree
name|to
parameter_list|)
block|{
name|struct
name|tree_map
modifier|*
name|h
decl_stmt|;
name|void
modifier|*
modifier|*
name|loc
decl_stmt|;
name|h
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_map
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|hash
operator|=
name|htab_hash_pointer
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|h
operator|->
name|from
operator|=
name|from
expr_stmt|;
name|h
operator|->
name|to
operator|=
name|to
expr_stmt|;
name|loc
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|restrict_base_for_decl
argument_list|,
name|h
argument_list|,
name|h
operator|->
name|hash
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|tree_map
operator|*
operator|*
operator|)
name|loc
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out the statistics for the DECL_DEBUG_EXPR hash table.  */
end_comment

begin_function
specifier|static
name|void
name|print_debug_expr_statistics
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DECL_DEBUG_EXPR  hash: size %ld, %ld elements, %f collisions\n"
argument_list|,
operator|(
name|long
operator|)
name|htab_size
argument_list|(
name|debug_expr_for_decl
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|htab_elements
argument_list|(
name|debug_expr_for_decl
argument_list|)
argument_list|,
name|htab_collisions
argument_list|(
name|debug_expr_for_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out the statistics for the DECL_VALUE_EXPR hash table.  */
end_comment

begin_function
specifier|static
name|void
name|print_value_expr_statistics
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DECL_VALUE_EXPR  hash: size %ld, %ld elements, %f collisions\n"
argument_list|,
operator|(
name|long
operator|)
name|htab_size
argument_list|(
name|value_expr_for_decl
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|htab_elements
argument_list|(
name|value_expr_for_decl
argument_list|)
argument_list|,
name|htab_collisions
argument_list|(
name|value_expr_for_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out statistics for the RESTRICT_BASE_FOR_DECL hash table, but    don't print anything if the table is empty.  */
end_comment

begin_function
specifier|static
name|void
name|print_restrict_base_statistics
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|htab_elements
argument_list|(
name|restrict_base_for_decl
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RESTRICT_BASE    hash: size %ld, %ld elements, %f collisions\n"
argument_list|,
operator|(
name|long
operator|)
name|htab_size
argument_list|(
name|restrict_base_for_decl
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|htab_elements
argument_list|(
name|restrict_base_for_decl
argument_list|)
argument_list|,
name|htab_collisions
argument_list|(
name|restrict_base_for_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lookup a debug expression for FROM, and return it if we find one.  */
end_comment

begin_function
name|tree
name|decl_debug_expr_lookup
parameter_list|(
name|tree
name|from
parameter_list|)
block|{
name|struct
name|tree_map
modifier|*
name|h
decl_stmt|,
name|in
decl_stmt|;
name|in
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|h
operator|=
name|htab_find_with_hash
argument_list|(
name|debug_expr_for_decl
argument_list|,
operator|&
name|in
argument_list|,
name|htab_hash_pointer
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
return|return
name|h
operator|->
name|to
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Insert a mapping FROM->TO in the debug expression hashtable.  */
end_comment

begin_function
name|void
name|decl_debug_expr_insert
parameter_list|(
name|tree
name|from
parameter_list|,
name|tree
name|to
parameter_list|)
block|{
name|struct
name|tree_map
modifier|*
name|h
decl_stmt|;
name|void
modifier|*
modifier|*
name|loc
decl_stmt|;
name|h
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_map
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|hash
operator|=
name|htab_hash_pointer
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|h
operator|->
name|from
operator|=
name|from
expr_stmt|;
name|h
operator|->
name|to
operator|=
name|to
expr_stmt|;
name|loc
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|debug_expr_for_decl
argument_list|,
name|h
argument_list|,
name|h
operator|->
name|hash
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|tree_map
operator|*
operator|*
operator|)
name|loc
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lookup a value expression for FROM, and return it if we find one.  */
end_comment

begin_function
name|tree
name|decl_value_expr_lookup
parameter_list|(
name|tree
name|from
parameter_list|)
block|{
name|struct
name|tree_map
modifier|*
name|h
decl_stmt|,
name|in
decl_stmt|;
name|in
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|h
operator|=
name|htab_find_with_hash
argument_list|(
name|value_expr_for_decl
argument_list|,
operator|&
name|in
argument_list|,
name|htab_hash_pointer
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
return|return
name|h
operator|->
name|to
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Insert a mapping FROM->TO in the value expression hashtable.  */
end_comment

begin_function
name|void
name|decl_value_expr_insert
parameter_list|(
name|tree
name|from
parameter_list|,
name|tree
name|to
parameter_list|)
block|{
name|struct
name|tree_map
modifier|*
name|h
decl_stmt|;
name|void
modifier|*
modifier|*
name|loc
decl_stmt|;
name|h
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_map
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|hash
operator|=
name|htab_hash_pointer
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|h
operator|->
name|from
operator|=
name|from
expr_stmt|;
name|h
operator|->
name|to
operator|=
name|to
expr_stmt|;
name|loc
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|value_expr_for_decl
argument_list|,
name|h
argument_list|,
name|h
operator|->
name|hash
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|tree_map
operator|*
operator|*
operator|)
name|loc
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hashing of types so that we don't make duplicates.    The entry point is `type_hash_canon'.  */
end_comment

begin_comment
comment|/* Compute a hash code for a list of types (chain of TREE_LIST nodes    with types in the TREE_VALUE slots), by adding the hash codes    of the individual types.  */
end_comment

begin_function
name|unsigned
name|int
name|type_hash_list
parameter_list|(
name|tree
name|list
parameter_list|,
name|hashval_t
name|hashcode
parameter_list|)
block|{
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|hashcode
operator|=
name|iterative_hash_object
argument_list|(
name|TYPE_HASH
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
return|return
name|hashcode
return|;
block|}
end_function

begin_comment
comment|/* These are the Hashtable callback functions.  */
end_comment

begin_comment
comment|/* Returns true iff the types are equivalent.  */
end_comment

begin_function
specifier|static
name|int
name|type_hash_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
block|{
specifier|const
name|struct
name|type_hash
modifier|*
name|a
init|=
name|va
decl_stmt|,
modifier|*
name|b
init|=
name|vb
decl_stmt|;
comment|/* First test the things that are the same for all types.  */
if|if
condition|(
name|a
operator|->
name|hash
operator|!=
name|b
operator|->
name|hash
operator|||
name|TREE_CODE
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|||
name|TREE_TYPE
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|||
operator|!
name|attribute_list_equal
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|a
operator|->
name|type
argument_list|)
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|b
operator|->
name|type
argument_list|)
argument_list|)
operator|||
name|TYPE_ALIGN
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|!=
name|TYPE_ALIGN
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|||
name|TYPE_MODE
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|b
operator|->
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|a
operator|->
name|type
argument_list|)
condition|)
block|{
case|case
name|VOID_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
return|return
literal|1
return|;
case|case
name|VECTOR_TYPE
case|:
return|return
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|==
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|b
operator|->
name|type
argument_list|)
return|;
case|case
name|ENUMERAL_TYPE
case|:
if|if
condition|(
name|TYPE_VALUES
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|!=
name|TYPE_VALUES
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|&&
operator|!
operator|(
name|TYPE_VALUES
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_VALUES
argument_list|(
name|a
operator|->
name|type
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TYPE_VALUES
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_VALUES
argument_list|(
name|b
operator|->
name|type
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|type_list_equal
argument_list|(
name|TYPE_VALUES
argument_list|(
name|a
operator|->
name|type
argument_list|)
argument_list|,
name|TYPE_VALUES
argument_list|(
name|b
operator|->
name|type
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* ... fall through ... */
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
return|return
operator|(
operator|(
name|TYPE_MAX_VALUE
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|==
name|TYPE_MAX_VALUE
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|||
name|tree_int_cst_equal
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|a
operator|->
name|type
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|b
operator|->
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_MIN_VALUE
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|==
name|TYPE_MIN_VALUE
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|||
name|tree_int_cst_equal
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|a
operator|->
name|type
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|b
operator|->
name|type
argument_list|)
argument_list|)
operator|)
operator|)
return|;
case|case
name|OFFSET_TYPE
case|:
return|return
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|==
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|b
operator|->
name|type
argument_list|)
return|;
case|case
name|METHOD_TYPE
case|:
return|return
operator|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|==
name|TYPE_METHOD_BASETYPE
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|&&
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|==
name|TYPE_ARG_TYPES
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|||
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|a
operator|->
name|type
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|b
operator|->
name|type
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|type_list_equal
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|a
operator|->
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|b
operator|->
name|type
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
return|;
case|case
name|ARRAY_TYPE
case|:
return|return
name|TYPE_DOMAIN
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|==
name|TYPE_DOMAIN
argument_list|(
name|b
operator|->
name|type
argument_list|)
return|;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
return|return
operator|(
name|TYPE_FIELDS
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|==
name|TYPE_FIELDS
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|||
operator|(
name|TYPE_FIELDS
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|a
operator|->
name|type
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TYPE_FIELDS
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|b
operator|->
name|type
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|type_list_equal
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|a
operator|->
name|type
argument_list|)
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|b
operator|->
name|type
argument_list|)
argument_list|)
operator|)
operator|)
return|;
case|case
name|FUNCTION_TYPE
case|:
return|return
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|==
name|TYPE_ARG_TYPES
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|||
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|a
operator|->
name|type
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|b
operator|->
name|type
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|type_list_equal
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|a
operator|->
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|b
operator|->
name|type
argument_list|)
argument_list|)
operator|)
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the cached hash value.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|type_hash_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|item
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
expr|struct
name|type_hash
operator|*
operator|)
name|item
operator|)
operator|->
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Look in the type hash table for a type isomorphic to TYPE.    If one is found, return it.  Otherwise return 0.  */
end_comment

begin_function
name|tree
name|type_hash_lookup
parameter_list|(
name|hashval_t
name|hashcode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|struct
name|type_hash
modifier|*
name|h
decl_stmt|,
name|in
decl_stmt|;
comment|/* The TYPE_ALIGN field of a type is set by layout_type(), so we      must call that routine before comparing TYPE_ALIGNs.  */
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|in
operator|.
name|hash
operator|=
name|hashcode
expr_stmt|;
name|in
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|h
operator|=
name|htab_find_with_hash
argument_list|(
name|type_hash_table
argument_list|,
operator|&
name|in
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
return|return
name|h
operator|->
name|type
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Add an entry to the type-hash-table    for a type TYPE whose hash code is HASHCODE.  */
end_comment

begin_function
name|void
name|type_hash_add
parameter_list|(
name|hashval_t
name|hashcode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|struct
name|type_hash
modifier|*
name|h
decl_stmt|;
name|void
modifier|*
modifier|*
name|loc
decl_stmt|;
name|h
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type_hash
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|hash
operator|=
name|hashcode
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|loc
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|type_hash_table
argument_list|,
name|h
argument_list|,
name|hashcode
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|type_hash
operator|*
operator|*
operator|)
name|loc
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given TYPE, and HASHCODE its hash code, return the canonical    object for an identical type if one already exists.    Otherwise, return TYPE, and record it as the canonical object.     To use this function, first create a type of the sort you want.    Then compute its hash code from the fields of the type that    make it different from other similar types.    Then call this function and use the value.  */
end_comment

begin_function
name|tree
name|type_hash_canon
parameter_list|(
name|unsigned
name|int
name|hashcode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|t1
decl_stmt|;
comment|/* The hash table only contains main variants, so ensure that's what we're      being passed.  */
name|gcc_assert
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lang_hooks
operator|.
name|types
operator|.
name|hash_types
condition|)
return|return
name|type
return|;
comment|/* See if the type is in the hash table already.  If so, return it.      Otherwise, add the type.  */
name|t1
operator|=
name|type_hash_lookup
argument_list|(
name|hashcode
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|t_kind
index|]
operator|--
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|t_kind
index|]
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|t1
return|;
block|}
else|else
block|{
name|type_hash_add
argument_list|(
name|hashcode
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
block|}
end_function

begin_comment
comment|/* See if the data pointed to by the type hash table is marked.  We consider    it marked if the type is marked or if a debug type number or symbol    table entry has been made for the type.  This reduces the amount of    debugging output and eliminates that dependency of the debug output on    the number of garbage collections.  */
end_comment

begin_function
specifier|static
name|int
name|type_hash_marked_p
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|tree
name|type
init|=
operator|(
operator|(
expr|struct
name|type_hash
operator|*
operator|)
name|p
operator|)
operator|->
name|type
decl_stmt|;
return|return
name|ggc_marked_p
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_SYMTAB_POINTER
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_type_hash_statistics
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Type hash: size %ld, %ld elements, %f collisions\n"
argument_list|,
operator|(
name|long
operator|)
name|htab_size
argument_list|(
name|type_hash_table
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|htab_elements
argument_list|(
name|type_hash_table
argument_list|)
argument_list|,
name|htab_collisions
argument_list|(
name|type_hash_table
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute a hash code for a list of attributes (chain of TREE_LIST nodes    with names in the TREE_PURPOSE slots and args in the TREE_VALUE slots),    by adding the hash codes of the individual attributes.  */
end_comment

begin_function
name|unsigned
name|int
name|attribute_hash_list
parameter_list|(
name|tree
name|list
parameter_list|,
name|hashval_t
name|hashcode
parameter_list|)
block|{
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
comment|/* ??? Do we want to add in TREE_VALUE too? */
name|hashcode
operator|=
name|iterative_hash_object
argument_list|(
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
return|return
name|hashcode
return|;
block|}
end_function

begin_comment
comment|/* Given two lists of attributes, return true if list l2 is    equivalent to l1.  */
end_comment

begin_function
name|int
name|attribute_list_equal
parameter_list|(
name|tree
name|l1
parameter_list|,
name|tree
name|l2
parameter_list|)
block|{
return|return
name|attribute_list_contained
argument_list|(
name|l1
argument_list|,
name|l2
argument_list|)
operator|&&
name|attribute_list_contained
argument_list|(
name|l2
argument_list|,
name|l1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given two lists of attributes, return true if list L2 is    completely contained within L1.  */
end_comment

begin_comment
comment|/* ??? This would be faster if attribute names were stored in a canonicalized    form.  Otherwise, if L1 uses `foo' and L2 uses `__foo__', the long method    must be used to show these elements are equivalent (which they are).  */
end_comment

begin_comment
comment|/* ??? It's not clear that attributes with arguments will always be handled    correctly.  */
end_comment

begin_function
name|int
name|attribute_list_contained
parameter_list|(
name|tree
name|l1
parameter_list|,
name|tree
name|l2
parameter_list|)
block|{
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
comment|/* First check the obvious, maybe the lists are identical.  */
if|if
condition|(
name|l1
operator|==
name|l2
condition|)
return|return
literal|1
return|;
comment|/* Maybe the lists are similar.  */
for|for
control|(
name|t1
operator|=
name|l1
operator|,
name|t2
operator|=
name|l2
init|;
name|t1
operator|!=
literal|0
operator|&&
name|t2
operator|!=
literal|0
operator|&&
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
operator|&&
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|,
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
control|)
empty_stmt|;
comment|/* Maybe the lists are equal.  */
if|if
condition|(
name|t1
operator|==
literal|0
operator|&&
name|t2
operator|==
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
init|;
name|t2
operator|!=
literal|0
condition|;
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
control|)
block|{
name|tree
name|attr
decl_stmt|;
for|for
control|(
name|attr
operator|=
name|lookup_attribute
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|,
name|l1
argument_list|)
init|;
name|attr
operator|!=
name|NULL_TREE
condition|;
name|attr
operator|=
name|lookup_attribute
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|attr
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
operator|!=
name|NULL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|attr
argument_list|)
operator|!=
name|NULL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|attr
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|simple_cst_list_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|attr
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|attr
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|attr
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given two lists of types    (chains of TREE_LIST nodes with types in the TREE_VALUE slots)    return 1 if the lists contain the same types in the same order.    Also, the TREE_PURPOSEs must match.  */
end_comment

begin_function
name|int
name|type_list_equal
parameter_list|(
name|tree
name|l1
parameter_list|,
name|tree
name|l2
parameter_list|)
block|{
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
for|for
control|(
name|t1
operator|=
name|l1
operator|,
name|t2
operator|=
name|l2
init|;
name|t1
operator|&&
name|t2
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|,
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
operator|||
operator|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
operator|(
literal|1
operator|==
name|simple_cst_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|t1
operator|==
name|t2
return|;
block|}
end_function

begin_comment
comment|/* Returns the number of arguments to the FUNCTION_TYPE or METHOD_TYPE    given by TYPE.  If the argument list accepts variable arguments,    then this function counts only the ordinary arguments.  */
end_comment

begin_function
name|int
name|type_num_arguments
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
comment|/* If the function does not take a variable number of arguments,        the last element in the list will have type `void'.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
break|break;
else|else
operator|++
name|i
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if integer constants T1 and T2    represent the same constant value.  */
end_comment

begin_function
name|int
name|tree_int_cst_equal
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|t1
operator|==
literal|0
operator|||
name|t2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|t2
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if integer constants T1 and T2 represent values that satisfy<.    The precise way of comparison depends on their data type.  */
end_comment

begin_function
name|int
name|tree_int_cst_lt
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|!=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|t1_sgn
init|=
name|tree_int_cst_sgn
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|int
name|t2_sgn
init|=
name|tree_int_cst_sgn
argument_list|(
name|t2
argument_list|)
decl_stmt|;
if|if
condition|(
name|t1_sgn
operator|<
name|t2_sgn
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|t1_sgn
operator|>
name|t2_sgn
condition|)
return|return
literal|0
return|;
comment|/* Otherwise, both are non-negative, so we compare them as 	 unsigned just in case one of them would overflow a signed 	 type.  */
block|}
elseif|else
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
condition|)
return|return
name|INT_CST_LT
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
return|;
return|return
name|INT_CST_LT_UNSIGNED
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns -1 if T1< T2, 0 if T1 == T2, and 1 if T1> T2.  */
end_comment

begin_function
name|int
name|tree_int_cst_compare
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if T is an INTEGER_CST that can be manipulated efficiently on    the host.  If POS is zero, the value can be represented in a single    HOST_WIDE_INT.  If POS is nonzero, the value must be non-negative and can    be represented in a single unsigned HOST_WIDE_INT.  */
end_comment

begin_function
name|int
name|host_integerp
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|>=
literal|0
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|<
literal|0
operator|&&
operator|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|TYPE_IS_SIZETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|pos
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the HOST_WIDE_INT least significant bits of T if it is an    INTEGER_CST and there is no overflow.  POS is nonzero if the result must    be non-negative.  We must be able to satisfy the above conditions.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|tree_low_cst
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|host_integerp
argument_list|(
name|t
argument_list|,
name|pos
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the most significant bit of the integer constant T.  */
end_comment

begin_function
name|int
name|tree_int_cst_msb
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|HOST_WIDE_INT
name|h
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|l
decl_stmt|;
comment|/* Note that using TYPE_PRECISION here is wrong.  We care about the      actual bits, not the (arbitrary) range of the type.  */
name|prec
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|rshift_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
argument_list|,
name|prec
argument_list|,
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|l
operator|&
literal|1
operator|)
operator|==
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return an indication of the sign of the integer constant T.    The return value is -1 if T< 0, 0 if T == 0, and 1 if T> 0.    Note that -1 will never be returned if T's type is unsigned.  */
end_comment

begin_function
name|int
name|tree_int_cst_sgn
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Compare two constructor-element-type constants.  Return 1 if the lists    are known to be equal; otherwise return 0.  */
end_comment

begin_function
name|int
name|simple_cst_list_equal
parameter_list|(
name|tree
name|l1
parameter_list|,
name|tree
name|l2
parameter_list|)
block|{
while|while
condition|(
name|l1
operator|!=
name|NULL_TREE
operator|&&
name|l2
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|l1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|l2
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
name|l1
operator|=
name|TREE_CHAIN
argument_list|(
name|l1
argument_list|)
expr_stmt|;
name|l2
operator|=
name|TREE_CHAIN
argument_list|(
name|l2
argument_list|)
expr_stmt|;
block|}
return|return
name|l1
operator|==
name|l2
return|;
block|}
end_function

begin_comment
comment|/* Return truthvalue of whether T1 is the same tree structure as T2.    Return 1 if they are the same.    Return 0 if they are understandably different.    Return -1 if either contains tree structure not understood by    this function.  */
end_comment

begin_function
name|int
name|simple_cst_equal
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
name|enum
name|tree_code
name|code1
decl_stmt|,
name|code2
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|t1
operator|==
literal|0
operator|||
name|t2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|NOP_EXPR
operator|||
name|code1
operator|==
name|CONVERT_EXPR
operator|||
name|code1
operator|==
name|NON_LVALUE_EXPR
condition|)
block|{
if|if
condition|(
name|code2
operator|==
name|NOP_EXPR
operator|||
name|code2
operator|==
name|CONVERT_EXPR
operator|||
name|code2
operator|==
name|NON_LVALUE_EXPR
condition|)
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
else|else
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|t2
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code2
operator|==
name|NOP_EXPR
operator|||
name|code2
operator|==
name|CONVERT_EXPR
operator|||
name|code2
operator|==
name|NON_LVALUE_EXPR
condition|)
return|return
name|simple_cst_equal
argument_list|(
name|t1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code1
operator|!=
name|code2
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code1
condition|)
block|{
case|case
name|INTEGER_CST
case|:
return|return
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|t2
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|t2
argument_list|)
operator|)
return|;
case|case
name|REAL_CST
case|:
return|return
name|REAL_VALUES_IDENTICAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
case|case
name|STRING_CST
case|:
return|return
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_STRING_LENGTH
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|CONSTRUCTOR
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v1
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v2
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|v1
argument_list|)
operator|!=
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|v2
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|v1
argument_list|)
condition|;
operator|++
name|idx
control|)
comment|/* ??? Should we handle also fields here? */
if|if
condition|(
operator|!
name|simple_cst_equal
argument_list|(
name|VEC_index
argument_list|(
name|constructor_elt
argument_list|,
name|v1
argument_list|,
name|idx
argument_list|)
operator|->
name|value
argument_list|,
name|VEC_index
argument_list|(
name|constructor_elt
argument_list|,
name|v2
argument_list|,
name|idx
argument_list|)
operator|->
name|value
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
case|case
name|SAVE_EXPR
case|:
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
name|cmp
operator|=
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|simple_cst_list_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|TARGET_EXPR
case|:
comment|/* Special case: if either target is an unallocated VAR_DECL, 	 it means that it's going to be unified with whatever the 	 TARGET_EXPR is really supposed to initialize, so treat it 	 as being equivalent to anything.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|cmp
operator|=
literal|1
expr_stmt|;
else|else
name|cmp
operator|=
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|WITH_CLEANUP_EXPR
case|:
name|cmp
operator|=
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
comment|/* This general rule works for most tree codes.  All exceptions should be      handled above.  If this is a language-specific tree code, we can't      trust what might be in the operand, so say we don't know      the situation.  */
if|if
condition|(
operator|(
name|int
operator|)
name|code1
operator|>=
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code1
argument_list|)
condition|)
block|{
case|case
name|tcc_unary
case|:
case|case
name|tcc_binary
case|:
case|case
name|tcc_comparison
case|:
case|case
name|tcc_expression
case|:
case|case
name|tcc_reference
case|:
case|case
name|tcc_statement
case|:
name|cmp
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_CODE_LENGTH
argument_list|(
name|code1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|cmp
operator|=
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
name|i
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
block|}
return|return
name|cmp
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Compare the value of T, an INTEGER_CST, with U, an unsigned integer value.    Return -1, 0, or 1 if the value of T is less than, equal to, or greater    than U, respectively.  */
end_comment

begin_function
name|int
name|compare_tree_int
parameter_list|(
name|tree
name|t
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|u
parameter_list|)
block|{
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|t
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|==
name|u
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|<
name|u
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if CODE represents an associative tree code.  Otherwise    return false.  */
end_comment

begin_function
name|bool
name|associative_tree_code
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
return|return
name|true
return|;
default|default:
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if CODE represents a commutative tree code.  Otherwise    return false.  */
end_comment

begin_function
name|bool
name|commutative_tree_code
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|UNORDERED_EXPR
case|:
case|case
name|ORDERED_EXPR
case|:
case|case
name|UNEQ_EXPR
case|:
case|case
name|LTGT_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
return|return
name|true
return|;
default|default:
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Generate a hash value for an expression.  This can be used iteratively    by passing a previous result as the "val" argument.     This function is intended to produce the same hash for expressions which    would compare equal using operand_equal_p.  */
end_comment

begin_function
name|hashval_t
name|iterative_hash_expr
parameter_list|(
name|tree
name|t
parameter_list|,
name|hashval_t
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|char
name|class
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return
name|iterative_hash_pointer
argument_list|(
name|t
argument_list|,
name|val
argument_list|)
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Alas, constants aren't shared, so we can't rely on pointer        identity.  */
case|case
name|INTEGER_CST
case|:
name|val
operator|=
name|iterative_hash_host_wide_int
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|iterative_hash_host_wide_int
argument_list|(
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
argument_list|,
name|val
argument_list|)
return|;
case|case
name|REAL_CST
case|:
block|{
name|unsigned
name|int
name|val2
init|=
name|real_hash
argument_list|(
name|TREE_REAL_CST_PTR
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|iterative_hash_hashval_t
argument_list|(
name|val2
argument_list|,
name|val
argument_list|)
return|;
block|}
case|case
name|STRING_CST
case|:
return|return
name|iterative_hash
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
argument_list|,
name|val
argument_list|)
return|;
case|case
name|COMPLEX_CST
case|:
name|val
operator|=
name|iterative_hash_expr
argument_list|(
name|TREE_REALPART
argument_list|(
name|t
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|iterative_hash_expr
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|t
argument_list|)
argument_list|,
name|val
argument_list|)
return|;
case|case
name|VECTOR_CST
case|:
return|return
name|iterative_hash_expr
argument_list|(
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|val
argument_list|)
return|;
case|case
name|SSA_NAME
case|:
case|case
name|VALUE_HANDLE
case|:
comment|/* we can just compare by pointer.  */
return|return
name|iterative_hash_pointer
argument_list|(
name|t
argument_list|,
name|val
argument_list|)
return|;
case|case
name|TREE_LIST
case|:
comment|/* A list of expressions, for a CALL_EXPR or as the elements of a 	 VECTOR_CST.  */
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|val
operator|=
name|iterative_hash_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
case|case
name|CONSTRUCTOR
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|tree
name|field
decl_stmt|,
name|value
decl_stmt|;
name|FOR_EACH_CONSTRUCTOR_ELT
argument_list|(
argument|CONSTRUCTOR_ELTS (t)
argument_list|,
argument|idx
argument_list|,
argument|field
argument_list|,
argument|value
argument_list|)
block|{
name|val
operator|=
name|iterative_hash_expr
argument_list|(
name|field
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|iterative_hash_expr
argument_list|(
name|value
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
case|case
name|FUNCTION_DECL
case|:
comment|/* When referring to a built-in FUNCTION_DECL, use the 	 __builtin__ form.  Otherwise nodes that compare equal 	 according to operand_equal_p might get different 	 hash codes.  */
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|val
operator|=
name|iterative_hash_pointer
argument_list|(
name|built_in_decls
index|[
name|DECL_FUNCTION_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/* else FALL THROUGH */
default|default:
name|class
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|tcc_declaration
condition|)
block|{
comment|/* DECL's have a unique ID */
name|val
operator|=
name|iterative_hash_host_wide_int
argument_list|(
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|iterative_hash_object
argument_list|(
name|code
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Don't hash the type, that can lead to having nodes which 	     compare equal according to operand_equal_p, but which 	     have different hash codes.  */
if|if
condition|(
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
operator|||
name|code
operator|==
name|NON_LVALUE_EXPR
condition|)
block|{
comment|/* Make sure to include signness in the hash computation.  */
name|val
operator|+=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|iterative_hash_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|commutative_tree_code
argument_list|(
name|code
argument_list|)
condition|)
block|{
comment|/* It's a commutative expression.  We want to hash it the same 		 however it appears.  We do this by first hashing both operands 		 and then rehashing based on the order of their independent 		 hashes.  */
name|hashval_t
name|one
init|=
name|iterative_hash_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|hashval_t
name|two
init|=
name|iterative_hash_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|hashval_t
name|t
decl_stmt|;
if|if
condition|(
name|one
operator|>
name|two
condition|)
name|t
operator|=
name|one
operator|,
name|one
operator|=
name|two
operator|,
name|two
operator|=
name|t
expr_stmt|;
name|val
operator|=
name|iterative_hash_hashval_t
argument_list|(
name|one
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|iterative_hash_hashval_t
argument_list|(
name|two
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|val
operator|=
name|iterative_hash_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Constructors for pointer, array and function types.    (RECORD_TYPE, UNION_TYPE and ENUMERAL_TYPE nodes are    constructed by language-dependent code, not here.)  */
end_comment

begin_comment
comment|/* Construct, lay out and return the type of pointers to TO_TYPE with    mode MODE.  If CAN_ALIAS_ALL is TRUE, indicate this type can    reference all of memory. If such a type has already been    constructed, reuse it.  */
end_comment

begin_function
name|tree
name|build_pointer_type_for_mode
parameter_list|(
name|tree
name|to_type
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|bool
name|can_alias_all
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|to_type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* In some cases, languages will have things that aren't a POINTER_TYPE      (such as a RECORD_TYPE for fat pointers in Ada) as TYPE_POINTER_TO.      In that case, return that type without regard to the rest of our      operands.       ??? This is a kludge, but consistent with the way this function has      always operated and there doesn't seem to be a good way to avoid this      at the moment.  */
if|if
condition|(
name|TYPE_POINTER_TO
argument_list|(
name|to_type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|to_type
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
name|TYPE_POINTER_TO
argument_list|(
name|to_type
argument_list|)
return|;
comment|/* First, if we already have a type for pointers to TO_TYPE and it's      the proper mode, use it.  */
for|for
control|(
name|t
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|to_type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TYPE_NEXT_PTR_TO
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|==
name|mode
operator|&&
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|t
argument_list|)
operator|==
name|can_alias_all
condition|)
return|return
name|t
return|;
name|t
operator|=
name|make_node
argument_list|(
name|POINTER_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|to_type
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|=
name|mode
expr_stmt|;
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|t
argument_list|)
operator|=
name|can_alias_all
expr_stmt|;
name|TYPE_NEXT_PTR_TO
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|to_type
argument_list|)
expr_stmt|;
name|TYPE_POINTER_TO
argument_list|(
name|to_type
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Lay out the type.  This function has many callers that are concerned      with expression-construction, and this simplifies them all.  */
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* By default build pointers in ptr_mode.  */
end_comment

begin_function
name|tree
name|build_pointer_type
parameter_list|(
name|tree
name|to_type
parameter_list|)
block|{
return|return
name|build_pointer_type_for_mode
argument_list|(
name|to_type
argument_list|,
name|ptr_mode
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Same as build_pointer_type_for_mode, but for REFERENCE_TYPE.  */
end_comment

begin_function
name|tree
name|build_reference_type_for_mode
parameter_list|(
name|tree
name|to_type
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|bool
name|can_alias_all
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* In some cases, languages will have things that aren't a REFERENCE_TYPE      (such as a RECORD_TYPE for fat pointers in Ada) as TYPE_REFERENCE_TO.      In that case, return that type without regard to the rest of our      operands.       ??? This is a kludge, but consistent with the way this function has      always operated and there doesn't seem to be a good way to avoid this      at the moment.  */
if|if
condition|(
name|TYPE_REFERENCE_TO
argument_list|(
name|to_type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_REFERENCE_TO
argument_list|(
name|to_type
argument_list|)
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
return|return
name|TYPE_REFERENCE_TO
argument_list|(
name|to_type
argument_list|)
return|;
comment|/* First, if we already have a type for pointers to TO_TYPE and it's      the proper mode, use it.  */
for|for
control|(
name|t
operator|=
name|TYPE_REFERENCE_TO
argument_list|(
name|to_type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TYPE_NEXT_REF_TO
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|==
name|mode
operator|&&
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|t
argument_list|)
operator|==
name|can_alias_all
condition|)
return|return
name|t
return|;
name|t
operator|=
name|make_node
argument_list|(
name|REFERENCE_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|to_type
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|=
name|mode
expr_stmt|;
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|t
argument_list|)
operator|=
name|can_alias_all
expr_stmt|;
name|TYPE_NEXT_REF_TO
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_REFERENCE_TO
argument_list|(
name|to_type
argument_list|)
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|to_type
argument_list|)
operator|=
name|t
expr_stmt|;
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Build the node for the type of references-to-TO_TYPE by default    in ptr_mode.  */
end_comment

begin_function
name|tree
name|build_reference_type
parameter_list|(
name|tree
name|to_type
parameter_list|)
block|{
return|return
name|build_reference_type_for_mode
argument_list|(
name|to_type
argument_list|,
name|ptr_mode
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a type that is compatible with t but has no cv quals anywhere    in its type, thus     const char *const *const *  ->  char ***.  */
end_comment

begin_function
name|tree
name|build_type_no_quals
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
return|return
name|build_pointer_type_for_mode
argument_list|(
name|build_type_no_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|REFERENCE_TYPE
case|:
return|return
name|build_reference_type_for_mode
argument_list|(
name|build_type_no_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Create a type of integers to be the TYPE_DOMAIN of an ARRAY_TYPE.    MAXVAL should be the maximum value in the domain    (one less than the length of the array).     The maximum value that MAXVAL can have is INT_MAX for a HOST_WIDE_INT.    We don't enforce this limit, that is up to caller (e.g. language front end).    The limit exists because the result is a signed type and we don't handle    sizes that use more than one HOST_WIDE_INT.  */
end_comment

begin_function
name|tree
name|build_index_type
parameter_list|(
name|tree
name|maxval
parameter_list|)
block|{
name|tree
name|itype
init|=
name|make_node
argument_list|(
name|INTEGER_TYPE
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|itype
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|itype
argument_list|)
operator|=
name|size_zero_node
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|itype
argument_list|)
operator|=
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|maxval
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|type_hash_canon
argument_list|(
name|tree_low_cst
argument_list|(
name|maxval
argument_list|,
literal|1
argument_list|)
argument_list|,
name|itype
argument_list|)
return|;
else|else
return|return
name|itype
return|;
block|}
end_function

begin_comment
comment|/* Builds a signed or unsigned integer type of precision PRECISION.    Used for C bitfields whose precision does not match that of    built-in target types.  */
end_comment

begin_function
name|tree
name|build_nonstandard_integer_type
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|precision
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|tree
name|itype
init|=
name|make_node
argument_list|(
name|INTEGER_TYPE
argument_list|)
decl_stmt|;
name|TYPE_PRECISION
argument_list|(
name|itype
argument_list|)
operator|=
name|precision
expr_stmt|;
if|if
condition|(
name|unsignedp
condition|)
name|fixup_unsigned_type
argument_list|(
name|itype
argument_list|)
expr_stmt|;
else|else
name|fixup_signed_type
argument_list|(
name|itype
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|itype
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|type_hash_canon
argument_list|(
name|tree_low_cst
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|itype
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|itype
argument_list|)
return|;
return|return
name|itype
return|;
block|}
end_function

begin_comment
comment|/* Create a range of some discrete type TYPE (an INTEGER_TYPE,    ENUMERAL_TYPE or BOOLEAN_TYPE), with low bound LOWVAL and    high bound HIGHVAL.  If TYPE is NULL, sizetype is used.  */
end_comment

begin_function
name|tree
name|build_range_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|lowval
parameter_list|,
name|tree
name|highval
parameter_list|)
block|{
name|tree
name|itype
init|=
name|make_node
argument_list|(
name|INTEGER_TYPE
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|itype
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
name|type
operator|=
name|sizetype
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|itype
argument_list|)
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|lowval
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|itype
argument_list|)
operator|=
name|highval
condition|?
name|fold_convert
argument_list|(
name|type
argument_list|,
name|highval
argument_list|)
else|:
name|NULL
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|lowval
argument_list|,
literal|0
argument_list|)
operator|&&
name|highval
operator|!=
literal|0
operator|&&
name|host_integerp
argument_list|(
name|highval
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|type_hash_canon
argument_list|(
name|tree_low_cst
argument_list|(
name|highval
argument_list|,
literal|0
argument_list|)
operator|-
name|tree_low_cst
argument_list|(
name|lowval
argument_list|,
literal|0
argument_list|)
argument_list|,
name|itype
argument_list|)
return|;
else|else
return|return
name|itype
return|;
block|}
end_function

begin_comment
comment|/* Just like build_index_type, but takes lowval and highval instead    of just highval (maxval).  */
end_comment

begin_function
name|tree
name|build_index_2_type
parameter_list|(
name|tree
name|lowval
parameter_list|,
name|tree
name|highval
parameter_list|)
block|{
return|return
name|build_range_type
argument_list|(
name|sizetype
argument_list|,
name|lowval
argument_list|,
name|highval
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Construct, lay out and return the type of arrays of elements with ELT_TYPE    and number of elements specified by the range of values of INDEX_TYPE.    If such a type has already been constructed, reuse it.  */
end_comment

begin_function
name|tree
name|build_array_type
parameter_list|(
name|tree
name|elt_type
parameter_list|,
name|tree
name|index_type
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|hashval_t
name|hashcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elt_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"arrays of functions are not meaningful"
argument_list|)
expr_stmt|;
name|elt_type
operator|=
name|integer_type_node
expr_stmt|;
block|}
name|t
operator|=
name|make_node
argument_list|(
name|ARRAY_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|elt_type
expr_stmt|;
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
operator|=
name|index_type
expr_stmt|;
if|if
condition|(
name|index_type
operator|==
literal|0
condition|)
block|{
name|tree
name|save
init|=
name|t
decl_stmt|;
name|hashcode
operator|=
name|iterative_hash_object
argument_list|(
name|TYPE_HASH
argument_list|(
name|elt_type
argument_list|)
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|save
operator|==
name|t
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
name|hashcode
operator|=
name|iterative_hash_object
argument_list|(
name|TYPE_HASH
argument_list|(
name|elt_type
argument_list|)
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
name|hashcode
operator|=
name|iterative_hash_object
argument_list|(
name|TYPE_HASH
argument_list|(
name|index_type
argument_list|)
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return the TYPE of the elements comprising    the innermost dimension of ARRAY.  */
end_comment

begin_function
name|tree
name|get_inner_array_type
parameter_list|(
name|tree
name|array
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Construct, lay out and return    the type of functions returning type VALUE_TYPE    given arguments of types ARG_TYPES.    ARG_TYPES is a chain of TREE_LIST nodes whose TREE_VALUEs    are data type nodes for the arguments of the function.    If such a type has already been constructed, reuse it.  */
end_comment

begin_function
name|tree
name|build_function_type
parameter_list|(
name|tree
name|value_type
parameter_list|,
name|tree
name|arg_types
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|hashval_t
name|hashcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"function return type cannot be function"
argument_list|)
expr_stmt|;
name|value_type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Make a node of the sort we want.  */
name|t
operator|=
name|make_node
argument_list|(
name|FUNCTION_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|value_type
expr_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
operator|=
name|arg_types
expr_stmt|;
comment|/* If we already have such a type, use the old one.  */
name|hashcode
operator|=
name|iterative_hash_object
argument_list|(
name|TYPE_HASH
argument_list|(
name|value_type
argument_list|)
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
name|hashcode
operator|=
name|type_hash_list
argument_list|(
name|arg_types
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Build a function type.  The RETURN_TYPE is the type returned by the    function.  If additional arguments are provided, they are    additional argument types.  The list of argument types must always    be terminated by NULL_TREE.  */
end_comment

begin_function
name|tree
name|build_function_type_list
parameter_list|(
name|tree
name|return_type
parameter_list|,
modifier|...
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|args
decl_stmt|,
name|last
decl_stmt|;
name|va_list
name|p
decl_stmt|;
name|va_start
argument_list|(
name|p
argument_list|,
name|return_type
argument_list|)
expr_stmt|;
name|t
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
expr_stmt|;
for|for
control|(
name|args
operator|=
name|NULL_TREE
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
control|)
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL_TREE
condition|)
name|args
operator|=
name|void_list_node
expr_stmt|;
else|else
block|{
name|last
operator|=
name|args
expr_stmt|;
name|args
operator|=
name|nreverse
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|void_list_node
expr_stmt|;
block|}
name|args
operator|=
name|build_function_type
argument_list|(
name|return_type
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/* Build a METHOD_TYPE for a member of BASETYPE.  The RETTYPE (a TYPE)    and ARGTYPES (a TREE_LIST) are the return type and arguments types    for the method.  An implicit additional parameter (of type    pointer-to-BASETYPE) is added to the ARGTYPES.  */
end_comment

begin_function
name|tree
name|build_method_type_directly
parameter_list|(
name|tree
name|basetype
parameter_list|,
name|tree
name|rettype
parameter_list|,
name|tree
name|argtypes
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|ptype
decl_stmt|;
name|int
name|hashcode
init|=
literal|0
decl_stmt|;
comment|/* Make a node of the sort we want.  */
name|t
operator|=
name|make_node
argument_list|(
name|METHOD_TYPE
argument_list|)
expr_stmt|;
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|rettype
expr_stmt|;
name|ptype
operator|=
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
comment|/* The actual arglist for this function includes a "hidden" argument      which is "this".  Put it into the list of argument types.  */
name|argtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptype
argument_list|,
name|argtypes
argument_list|)
expr_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
operator|=
name|argtypes
expr_stmt|;
comment|/* If we already have such a type, use the old one.  */
name|hashcode
operator|=
name|iterative_hash_object
argument_list|(
name|TYPE_HASH
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
name|hashcode
operator|=
name|iterative_hash_object
argument_list|(
name|TYPE_HASH
argument_list|(
name|rettype
argument_list|)
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
name|hashcode
operator|=
name|type_hash_list
argument_list|(
name|argtypes
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Construct, lay out and return the type of methods belonging to class    BASETYPE and whose arguments and values are described by TYPE.    If that type exists already, reuse it.    TYPE must be a FUNCTION_TYPE node.  */
end_comment

begin_function
name|tree
name|build_method_type
parameter_list|(
name|tree
name|basetype
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
argument_list|)
expr_stmt|;
return|return
name|build_method_type_directly
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Construct, lay out and return the type of offsets to a value    of type TYPE, within an object of type BASETYPE.    If a suitable offset type exists already, reuse it.  */
end_comment

begin_function
name|tree
name|build_offset_type
parameter_list|(
name|tree
name|basetype
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|hashval_t
name|hashcode
init|=
literal|0
decl_stmt|;
comment|/* Make a node of the sort we want.  */
name|t
operator|=
name|make_node
argument_list|(
name|OFFSET_TYPE
argument_list|)
expr_stmt|;
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* If we already have such a type, use the old one.  */
name|hashcode
operator|=
name|iterative_hash_object
argument_list|(
name|TYPE_HASH
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
name|hashcode
operator|=
name|iterative_hash_object
argument_list|(
name|TYPE_HASH
argument_list|(
name|type
argument_list|)
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Create a complex type whose components are COMPONENT_TYPE.  */
end_comment

begin_function
name|tree
name|build_complex_type
parameter_list|(
name|tree
name|component_type
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|hashval_t
name|hashcode
decl_stmt|;
comment|/* Make a node of the sort we want.  */
name|t
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|component_type
argument_list|)
expr_stmt|;
comment|/* If we already have such a type, use the old one.  */
name|hashcode
operator|=
name|iterative_hash_object
argument_list|(
name|TYPE_HASH
argument_list|(
name|component_type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* If we are writing Dwarf2 output we need to create a name,      since complex is a fundamental type.  */
if|if
condition|(
operator|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
operator|||
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
operator|)
operator|&&
operator|!
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|component_type
operator|==
name|char_type_node
condition|)
name|name
operator|=
literal|"complex char"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|signed_char_type_node
condition|)
name|name
operator|=
literal|"complex signed char"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|unsigned_char_type_node
condition|)
name|name
operator|=
literal|"complex unsigned char"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|short_integer_type_node
condition|)
name|name
operator|=
literal|"complex short int"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|short_unsigned_type_node
condition|)
name|name
operator|=
literal|"complex short unsigned int"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|integer_type_node
condition|)
name|name
operator|=
literal|"complex int"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|unsigned_type_node
condition|)
name|name
operator|=
literal|"complex unsigned int"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|long_integer_type_node
condition|)
name|name
operator|=
literal|"complex long int"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|long_unsigned_type_node
condition|)
name|name
operator|=
literal|"complex long unsigned int"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|long_long_integer_type_node
condition|)
name|name
operator|=
literal|"complex long long int"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|long_long_unsigned_type_node
condition|)
name|name
operator|=
literal|"complex long long unsigned int"
expr_stmt|;
else|else
name|name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
operator|!=
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|build_qualified_type
argument_list|(
name|t
argument_list|,
name|TYPE_QUALS
argument_list|(
name|component_type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return OP, stripped of any conversions to wider types as much as is safe.    Converting the value back to OP's type makes a value equivalent to OP.     If FOR_TYPE is nonzero, we return a value which, if converted to    type FOR_TYPE, would be equivalent to converting OP to type FOR_TYPE.     If FOR_TYPE is nonzero, unaligned bit-field references may be changed to the    narrowest type that can hold the value, even if they don't exactly fit.    Otherwise, bit-field references are changed to a narrower type    only if they can be fetched directly from memory in that type.     OP must have integer, real or enumeral type.  Pointers are not allowed!     There are some cases where the obvious value we could return    would regenerate to OP if converted to OP's type,    but would not extend like OP to wider types.    If FOR_TYPE indicates such extension is contemplated, we eschew such values.    For example, if OP is (unsigned short)(signed char)-1,    we avoid returning (signed char)-1 if FOR_TYPE is int,    even though extending that to an unsigned short would regenerate OP,    since the result of extending (signed char)-1 to (int)    is different from (int) OP.  */
end_comment

begin_function
name|tree
name|get_unwidened
parameter_list|(
name|tree
name|op
parameter_list|,
name|tree
name|for_type
parameter_list|)
block|{
comment|/* Set UNS initially if converting OP to FOR_TYPE is a zero-extension.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|unsigned
name|final_prec
init|=
name|TYPE_PRECISION
argument_list|(
name|for_type
operator|!=
literal|0
condition|?
name|for_type
else|:
name|type
argument_list|)
decl_stmt|;
name|int
name|uns
init|=
operator|(
name|for_type
operator|!=
literal|0
operator|&&
name|for_type
operator|!=
name|type
operator|&&
name|final_prec
operator|>
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
decl_stmt|;
name|tree
name|win
init|=
name|op
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
block|{
name|int
name|bitschange
decl_stmt|;
comment|/* TYPE_PRECISION on vector types has different meaning 	 (TYPE_VECTOR_SUBPARTS) and casts from vectors are view conversions, 	 so avoid them here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
break|break;
name|bitschange
operator|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Truncations are many-one so cannot be removed. 	 Unless we are later going to truncate down even farther.  */
if|if
condition|(
name|bitschange
operator|<
literal|0
operator|&&
name|final_prec
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* See what's inside this conversion.  If we decide to strip it, 	 we will set WIN.  */
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we have not stripped any zero-extensions (uns is 0), 	 we can strip any kind of extension. 	 If we have previously stripped a zero-extension, 	 only zero-extensions can safely be stripped. 	 Any extension can be stripped if the bits it would produce 	 are all going to be discarded later by truncating to FOR_TYPE.  */
if|if
condition|(
name|bitschange
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|uns
operator|||
name|final_prec
operator|<=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
name|win
operator|=
name|op
expr_stmt|;
comment|/* TYPE_UNSIGNED says whether this is a zero-extension. 	     Let's avoid computing it if it does not affect WIN 	     and if UNS will not be needed again.  */
if|if
condition|(
operator|(
name|uns
operator|||
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
block|{
name|uns
operator|=
literal|1
expr_stmt|;
name|win
operator|=
name|op
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|COMPONENT_REF
comment|/* Since type_for_size always gives an integer type.  */
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
comment|/* Don't crash if field not laid out yet.  */
operator|&&
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|innerprec
init|=
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
operator|(
name|DECL_UNSIGNED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
argument_list|(
name|innerprec
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* We can get this structure field in the narrowest type it fits in. 	 If FOR_TYPE is 0, do this only for a field that matches the 	 narrower type exactly and is aligned for it 	 The resulting extension to its nominal type (a fullword type) 	 must fit the same conditions as for other extensions.  */
if|if
condition|(
name|type
operator|!=
literal|0
operator|&&
name|INT_CST_LT_UNSIGNED
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|for_type
operator|||
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|uns
operator|||
name|final_prec
operator|<=
name|innerprec
operator|||
name|unsignedp
operator|)
condition|)
block|{
name|win
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|win
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|win
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|win
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return OP or a simpler expression for a narrower value    which can be sign-extended or zero-extended to give back OP.    Store in *UNSIGNEDP_PTR either 1 if the value should be zero-extended    or 0 if the value should be sign-extended.  */
end_comment

begin_function
name|tree
name|get_narrower
parameter_list|(
name|tree
name|op
parameter_list|,
name|int
modifier|*
name|unsignedp_ptr
parameter_list|)
block|{
name|int
name|uns
init|=
literal|0
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|tree
name|win
init|=
name|op
decl_stmt|;
name|bool
name|integral_p
init|=
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
name|int
name|bitschange
init|=
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
decl_stmt|;
comment|/* Truncations are many-one so cannot be removed.  */
if|if
condition|(
name|bitschange
operator|<
literal|0
condition|)
break|break;
comment|/* See what's inside this conversion.  If we decide to strip it, 	 we will set WIN.  */
if|if
condition|(
name|bitschange
operator|>
literal|0
condition|)
block|{
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* An extension: the outermost one can be stripped, 	     but remember whether it is zero or sign extension.  */
if|if
condition|(
name|first
condition|)
name|uns
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Otherwise, if a sign extension has been stripped, 	     only sign extensions can now be stripped; 	     if a zero extension has been stripped, only zero-extensions.  */
elseif|else
if|if
condition|(
name|uns
operator|!=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
break|break;
name|first
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* bitschange == 0 */
block|{
comment|/* A change in nominal type can always be stripped, but we must 	     preserve the unsignedness.  */
if|if
condition|(
name|first
condition|)
name|uns
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Keep trying to narrow, but don't assign op to win if it 	     would turn an integral type into something else.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|integral_p
condition|)
continue|continue;
block|}
name|win
operator|=
name|op
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|COMPONENT_REF
comment|/* Since type_for_size always gives an integer type.  */
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REAL_TYPE
comment|/* Ensure field is laid out already.  */
operator|&&
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|innerprec
init|=
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
operator|(
name|DECL_UNSIGNED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|tree
name|type
init|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
argument_list|(
name|innerprec
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
comment|/* We can get this structure field in a narrower type that fits it, 	 but the resulting extension to its nominal type (a fullword type) 	 must satisfy the same conditions as for other extensions.  	 Do this only for fields that are aligned (not bit-fields), 	 because when bit-field insns will be used there is no 	 advantage in doing this.  */
if|if
condition|(
name|innerprec
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
name|first
operator|||
name|uns
operator|==
name|DECL_UNSIGNED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
name|type
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|first
condition|)
name|uns
operator|=
name|DECL_UNSIGNED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|win
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|unsignedp_ptr
operator|=
name|uns
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if integer constant C has a value that is permissible    for type TYPE (an INTEGER_TYPE).  */
end_comment

begin_function
name|int
name|int_fits_type_p
parameter_list|(
name|tree
name|c
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|type_low_bound
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|type_high_bound
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|bool
name|ok_for_low_bound
decl_stmt|,
name|ok_for_high_bound
decl_stmt|;
name|tree
name|tmp
decl_stmt|;
comment|/* If at least one bound of the type is a constant integer, we can check      ourselves and maybe make a decision. If no such decision is possible, but      this type is a subtype, try checking against that.  Otherwise, use      force_fit_type, which checks against the precision.       Compute the status for each possibly constant bound, and return if we see      one does not match. Use ok_for_xxx_bound for this purpose, assigning -1      for "unknown if constant fits", 0 for "constant known *not* to fit" and 1      for "constant known to fit".  */
comment|/* Check if C>= type_low_bound.  */
if|if
condition|(
name|type_low_bound
operator|&&
name|TREE_CODE
argument_list|(
name|type_low_bound
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|c
argument_list|,
name|type_low_bound
argument_list|)
condition|)
return|return
literal|0
return|;
name|ok_for_low_bound
operator|=
name|true
expr_stmt|;
block|}
else|else
name|ok_for_low_bound
operator|=
name|false
expr_stmt|;
comment|/* Check if c<= type_high_bound.  */
if|if
condition|(
name|type_high_bound
operator|&&
name|TREE_CODE
argument_list|(
name|type_high_bound
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|type_high_bound
argument_list|,
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
name|ok_for_high_bound
operator|=
name|true
expr_stmt|;
block|}
else|else
name|ok_for_high_bound
operator|=
name|false
expr_stmt|;
comment|/* If the constant fits both bounds, the result is known.  */
if|if
condition|(
name|ok_for_low_bound
operator|&&
name|ok_for_high_bound
condition|)
return|return
literal|1
return|;
comment|/* Perform some generic filtering which may allow making a decision      even if the bounds are not constant.  First, negative integers      never fit in unsigned types, */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|c
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Second, narrower types always fit in wider ones.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Third, unsigned integers with top bit set never fit signed types.  */
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|c
argument_list|)
argument_list|)
operator|&&
name|tree_int_cst_msb
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If we haven't been able to decide at this point, there nothing more we      can check ourselves here.  Look at the base type if we have one and it      has the same precision.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|int_fits_type_p
argument_list|(
name|c
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
comment|/* Or to force_fit_type, if nothing else.  */
name|tmp
operator|=
name|copy_node
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
operator|=
name|type
expr_stmt|;
name|tmp
operator|=
name|force_fit_type
argument_list|(
name|tmp
argument_list|,
operator|-
literal|1
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|TREE_INT_CST_HIGH
argument_list|(
name|tmp
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|c
argument_list|)
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|tmp
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subprogram of following function.  Called by walk_tree.     Return *TP if it is an automatic variable or parameter of the    function passed in as DATA.  */
end_comment

begin_function
specifier|static
name|tree
name|find_var_from_fn
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|fn
init|=
operator|(
name|tree
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|tp
argument_list|)
operator|&&
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|auto_var_in_fn_p
argument_list|(
operator|*
name|tp
argument_list|,
name|fn
argument_list|)
condition|)
return|return
operator|*
name|tp
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns true if T is, contains, or refers to a type with variable    size.  For METHOD_TYPEs and FUNCTION_TYPEs we exclude the    arguments, but not the return type.  If FN is nonzero, only return    true if a modifier of the type or position of FN is a variable or    parameter inside FN.     This concept is more general than that of C99 'variably modified types':    in C99, a struct type is never variably modified because a VLA may not    appear as a structure member.  However, in GNU C code like:       struct S { int i[f()]; };     is valid, and other languages may define similar constructs.  */
end_comment

begin_function
name|bool
name|variably_modified_type_p
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|fn
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* Test if T is either variable (if FN is zero) or an expression containing    a variable in FN.  */
define|#
directive|define
name|RETURN_TRUE_IF_VAR
parameter_list|(
name|T
parameter_list|)
define|\
value|do { tree _t = (T);							\     if (_t&& _t != error_mark_node&& TREE_CODE (_t) != INTEGER_CST	\&& (!fn || walk_tree (&_t, find_var_from_fn, fn, NULL)))	\       return true;  } while (0)
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|false
return|;
comment|/* If TYPE itself has variable size, it is variably modified.  */
name|RETURN_TRUE_IF_VAR
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_TRUE_IF_VAR
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
if|if
condition|(
name|variably_modified_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|fn
argument_list|)
condition|)
return|return
name|true
return|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
comment|/* If TYPE is a function type, it is variably modified if the 	 return type is variably modified.  */
if|if
condition|(
name|variably_modified_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|fn
argument_list|)
condition|)
return|return
name|true
return|;
break|break;
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
comment|/* Scalar types are variably modified if their end points 	 aren't constant.  */
name|RETURN_TRUE_IF_VAR
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_TRUE_IF_VAR
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
comment|/* We can't see if any of the fields are variably-modified by the 	 definition we normally use, since that would produce infinite 	 recursion via pointers.  */
comment|/* This is variably modified if some field's type is.  */
for|for
control|(
name|t
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|RETURN_TRUE_IF_VAR
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_TRUE_IF_VAR
argument_list|(
name|DECL_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_TRUE_IF_VAR
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
name|RETURN_TRUE_IF_VAR
argument_list|(
name|DECL_QUALIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARRAY_TYPE
case|:
comment|/* Do not call ourselves to avoid infinite recursion.  This is 	 variably modified if the element type is.  */
name|RETURN_TRUE_IF_VAR
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_TRUE_IF_VAR
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* The current language may have other cases to check, but in general,      all other types are not variably modified.  */
return|return
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|var_mod_type_p
argument_list|(
name|type
argument_list|,
name|fn
argument_list|)
return|;
undef|#
directive|undef
name|RETURN_TRUE_IF_VAR
block|}
end_function

begin_comment
comment|/* Given a DECL or TYPE, return the scope in which it was declared, or    NULL_TREE if there is no containing scope.  */
end_comment

begin_function
name|tree
name|get_containing_scope
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
operator|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|?
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
else|:
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost context enclosing DECL that is    a FUNCTION_DECL, or zero if none.  */
end_comment

begin_function
name|tree
name|decl_function_context
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|context
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|0
return|;
comment|/* C++ virtual functions use DECL_CONTEXT for the class of the vtable      where we look up the function at runtime.  Such functions always take      a first argument of type 'pointer to real context'.       C++ should really be fixed to use DECL_CONTEXT for the real context,      and use something else for the "virtual context".  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
condition|)
name|context
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
while|while
condition|(
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|BLOCK
condition|)
name|context
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
else|else
name|context
operator|=
name|get_containing_scope
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
return|return
name|context
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost context enclosing DECL that is    a RECORD_TYPE, UNION_TYPE or QUAL_UNION_TYPE, or zero if none.    TYPE_DECLs and FUNCTION_DECLs are transparent to this function.  */
end_comment

begin_function
name|tree
name|decl_type_context
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
while|while
condition|(
name|context
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
condition|)
block|{
case|case
name|NAMESPACE_DECL
case|:
case|case
name|TRANSLATION_UNIT_DECL
case|:
return|return
name|NULL_TREE
return|;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
return|return
name|context
return|;
case|case
name|TYPE_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
break|break;
case|case
name|BLOCK
case|:
name|context
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* CALL is a CALL_EXPR.  Return the declaration for the function    called, or NULL_TREE if the called function cannot be    determined.  */
end_comment

begin_function
name|tree
name|get_callee_fndecl
parameter_list|(
name|tree
name|call
parameter_list|)
block|{
name|tree
name|addr
decl_stmt|;
if|if
condition|(
name|call
operator|==
name|error_mark_node
condition|)
return|return
name|call
return|;
comment|/* It's invalid to call this function with anything but a      CALL_EXPR.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|call
argument_list|)
operator|==
name|CALL_EXPR
argument_list|)
expr_stmt|;
comment|/* The first operand to the CALL is the address of the function      called.  */
name|addr
operator|=
name|TREE_OPERAND
argument_list|(
name|call
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* If this is a readonly function pointer, extract its initial value.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|addr
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_READONLY
argument_list|(
name|addr
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|addr
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|DECL_INITIAL
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* If the address is just `&f' for some function `f', then we know      that `f' is being called.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
return|;
comment|/* We couldn't figure out what was being called.  Maybe the front      end has some idea.  */
return|return
name|lang_hooks
operator|.
name|lang_get_callee_fndecl
argument_list|(
name|call
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print debugging information about tree nodes generated during the compile,    and any language-specific information.  */
end_comment

begin_function
name|void
name|dump_tree_statistics
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|int
name|i
decl_stmt|;
name|int
name|total_nodes
decl_stmt|,
name|total_bytes
decl_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n??? tree nodes created\n\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Kind                   Nodes      Bytes\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"---------------------------------------\n"
argument_list|)
expr_stmt|;
name|total_nodes
operator|=
name|total_bytes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|all_kinds
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-20s %7d %10d\n"
argument_list|,
name|tree_node_kind_names
index|[
name|i
index|]
argument_list|,
name|tree_node_counts
index|[
name|i
index|]
argument_list|,
name|tree_node_sizes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|total_nodes
operator|+=
name|tree_node_counts
index|[
name|i
index|]
expr_stmt|;
name|total_bytes
operator|+=
name|tree_node_sizes
index|[
name|i
index|]
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"---------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-20s %7d %10d\n"
argument_list|,
literal|"Total"
argument_list|,
name|total_nodes
argument_list|,
name|total_bytes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"---------------------------------------\n"
argument_list|)
expr_stmt|;
name|ssanames_print_statistics
argument_list|()
expr_stmt|;
name|phinodes_print_statistics
argument_list|()
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(No per-node statistics)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|print_type_hash_statistics
argument_list|()
expr_stmt|;
name|print_debug_expr_statistics
argument_list|()
expr_stmt|;
name|print_value_expr_statistics
argument_list|()
expr_stmt|;
name|print_restrict_base_statistics
argument_list|()
expr_stmt|;
name|lang_hooks
operator|.
name|print_statistics
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|FILE_FUNCTION_FORMAT
value|"_GLOBAL__%s_%s"
end_define

begin_comment
comment|/* Generate a crc32 of a string.  */
end_comment

begin_function
name|unsigned
name|crc32_string
parameter_list|(
name|unsigned
name|chksum
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
do|do
block|{
name|unsigned
name|value
init|=
operator|*
name|string
operator|<<
literal|24
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|8
init|;
name|ix
operator|--
condition|;
name|value
operator|<<=
literal|1
control|)
block|{
name|unsigned
name|feedback
decl_stmt|;
name|feedback
operator|=
operator|(
name|value
operator|^
name|chksum
operator|)
operator|&
literal|0x80000000
condition|?
literal|0x04c11db7
else|:
literal|0
expr_stmt|;
name|chksum
operator|<<=
literal|1
expr_stmt|;
name|chksum
operator|^=
name|feedback
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|string
operator|++
condition|)
do|;
return|return
name|chksum
return|;
block|}
end_function

begin_comment
comment|/* P is a string that will be used in a symbol.  Mask out any characters    that are not valid in that context.  */
end_comment

begin_function
name|void
name|clean_symbol_name
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|ISALNUM
argument_list|(
operator|*
name|p
argument_list|)
ifndef|#
directive|ifndef
name|NO_DOLLAR_IN_LABEL
comment|/* this for `$'; unlikely, but... -- kr */
operator|||
operator|*
name|p
operator|==
literal|'$'
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_DOT_IN_LABEL
comment|/* this for `.'; unlikely, but...  */
operator|||
operator|*
name|p
operator|==
literal|'.'
endif|#
directive|endif
operator|)
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a name for a function unique to this translation unit.    TYPE is some string to identify the purpose of this function to the    linker or collect2.  */
end_comment

begin_function
name|tree
name|get_file_function_name_long
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|first_global_object_name
condition|)
block|{
name|p
operator|=
name|first_global_object_name
expr_stmt|;
comment|/* For type 'F', the generated name must be unique not only to this 	 translation unit but also to any given link.  Since global names 	 can be overloaded, we concatenate the first global object name 	 with a string derived from the file name of this object.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"F"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|file
init|=
name|main_input_filename
decl_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
name|file
operator|=
name|input_filename
expr_stmt|;
name|q
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|q
argument_list|,
literal|"%s_%08X"
argument_list|,
name|p
argument_list|,
name|crc32_string
argument_list|(
literal|0
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We don't have anything that we know to be unique to this translation 	 unit, so use what we do have and throw in some randomness.  */
name|unsigned
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|weak_global_object_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
init|=
name|main_input_filename
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
name|name
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
name|file
operator|=
name|input_filename
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|q
operator|=
name|alloca
argument_list|(
literal|9
operator|*
literal|2
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|q
argument_list|,
name|file
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|clean_symbol_name
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|q
operator|+
name|len
argument_list|,
literal|"_%08X_%08X"
argument_list|,
name|crc32_string
argument_list|(
literal|0
argument_list|,
name|name
argument_list|)
argument_list|,
name|crc32_string
argument_list|(
literal|0
argument_list|,
name|flag_random_seed
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|buf
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|FILE_FUNCTION_FORMAT
argument_list|)
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
name|strlen
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the name of the file-level functions we may need.      Use a global object (which is already required to be unique over      the program) rather than the file name (which imposes extra      constraints).  */
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILE_FUNCTION_FORMAT
argument_list|,
name|type
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If KIND=='I', return a suitable global initializer (constructor) name.    If KIND=='D', return a suitable global clean-up (destructor) name.  */
end_comment

begin_function
name|tree
name|get_file_function_name
parameter_list|(
name|int
name|kind
parameter_list|)
block|{
name|char
name|p
index|[
literal|2
index|]
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|kind
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|get_file_function_name_long
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
name|ENABLE_TREE_CHECKING
operator|&&
operator|(
name|GCC_VERSION
operator|>=
literal|2007
operator|)
end_if

begin_comment
comment|/* Complain that the tree code of NODE does not match the expected 0    terminated list of trailing codes. The trailing code list can be    empty, for a more vague error message.  FILE, LINE, and FUNCTION    are of the caller.  */
end_comment

begin_function
name|void
name|tree_check_failed
parameter_list|(
specifier|const
name|tree
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|function
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|length
init|=
literal|0
decl_stmt|;
name|int
name|code
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|function
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|code
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|)
condition|)
name|length
operator|+=
literal|4
operator|+
name|strlen
argument_list|(
name|tree_code_name
index|[
name|code
index|]
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
name|va_start
argument_list|(
name|args
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|length
operator|+=
name|strlen
argument_list|(
literal|"expected "
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|alloca
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|code
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|prefix
init|=
name|length
condition|?
literal|" or "
else|:
literal|"expected "
decl_stmt|;
name|strcpy
argument_list|(
name|buffer
operator|+
name|length
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|length
operator|+=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
operator|+
name|length
argument_list|,
name|tree_code_name
index|[
name|code
index|]
argument_list|)
expr_stmt|;
name|length
operator|+=
name|strlen
argument_list|(
name|tree_code_name
index|[
name|code
index|]
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
else|else
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
literal|"unexpected node"
expr_stmt|;
name|internal_error
argument_list|(
literal|"tree check: %s, have %s in %s, at %s:%d"
argument_list|,
name|buffer
argument_list|,
name|tree_code_name
index|[
name|TREE_CODE
argument_list|(
name|node
argument_list|)
index|]
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Complain that the tree code of NODE does match the expected 0    terminated list of trailing codes. FILE, LINE, and FUNCTION are of    the caller.  */
end_comment

begin_function
name|void
name|tree_not_check_failed
parameter_list|(
specifier|const
name|tree
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|function
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|length
init|=
literal|0
decl_stmt|;
name|int
name|code
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|function
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|code
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|)
condition|)
name|length
operator|+=
literal|4
operator|+
name|strlen
argument_list|(
name|tree_code_name
index|[
name|code
index|]
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|alloca
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|code
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|length
condition|)
block|{
name|strcpy
argument_list|(
name|buffer
operator|+
name|length
argument_list|,
literal|" or "
argument_list|)
expr_stmt|;
name|length
operator|+=
literal|4
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|buffer
operator|+
name|length
argument_list|,
name|tree_code_name
index|[
name|code
index|]
argument_list|)
expr_stmt|;
name|length
operator|+=
name|strlen
argument_list|(
name|tree_code_name
index|[
name|code
index|]
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"tree check: expected none of %s, have %s in %s, at %s:%d"
argument_list|,
name|buffer
argument_list|,
name|tree_code_name
index|[
name|TREE_CODE
argument_list|(
name|node
argument_list|)
index|]
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to tree_check_failed, except that we check for a class of tree    code, given in CL.  */
end_comment

begin_function
name|void
name|tree_class_check_failed
parameter_list|(
specifier|const
name|tree
name|node
parameter_list|,
specifier|const
name|enum
name|tree_code_class
name|cl
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|function
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"tree check: expected class %qs, have %qs (%s) in %s, at %s:%d"
argument_list|,
name|TREE_CODE_CLASS_STRING
argument_list|(
name|cl
argument_list|)
argument_list|,
name|TREE_CODE_CLASS_STRING
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|tree_code_name
index|[
name|TREE_CODE
argument_list|(
name|node
argument_list|)
index|]
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to tree_check_failed, except that instead of specifying a    dozen codes, use the knowledge that they're all sequential.  */
end_comment

begin_function
name|void
name|tree_range_check_failed
parameter_list|(
specifier|const
name|tree
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|function
parameter_list|,
name|enum
name|tree_code
name|c1
parameter_list|,
name|enum
name|tree_code
name|c2
parameter_list|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|length
init|=
literal|0
decl_stmt|;
name|enum
name|tree_code
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|c1
init|;
name|c
operator|<=
name|c2
condition|;
operator|++
name|c
control|)
name|length
operator|+=
literal|4
operator|+
name|strlen
argument_list|(
name|tree_code_name
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|length
operator|+=
name|strlen
argument_list|(
literal|"expected "
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|alloca
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|c1
init|;
name|c
operator|<=
name|c2
condition|;
operator|++
name|c
control|)
block|{
specifier|const
name|char
modifier|*
name|prefix
init|=
name|length
condition|?
literal|" or "
else|:
literal|"expected "
decl_stmt|;
name|strcpy
argument_list|(
name|buffer
operator|+
name|length
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|length
operator|+=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
operator|+
name|length
argument_list|,
name|tree_code_name
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|length
operator|+=
name|strlen
argument_list|(
name|tree_code_name
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
name|internal_error
argument_list|(
literal|"tree check: %s, have %s in %s, at %s:%d"
argument_list|,
name|buffer
argument_list|,
name|tree_code_name
index|[
name|TREE_CODE
argument_list|(
name|node
argument_list|)
index|]
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to tree_check_failed, except that we check that a tree does    not have the specified code, given in CL.  */
end_comment

begin_function
name|void
name|tree_not_class_check_failed
parameter_list|(
specifier|const
name|tree
name|node
parameter_list|,
specifier|const
name|enum
name|tree_code_class
name|cl
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|function
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"tree check: did not expect class %qs, have %qs (%s) in %s, at %s:%d"
argument_list|,
name|TREE_CODE_CLASS_STRING
argument_list|(
name|cl
argument_list|)
argument_list|,
name|TREE_CODE_CLASS_STRING
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|tree_code_name
index|[
name|TREE_CODE
argument_list|(
name|node
argument_list|)
index|]
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to tree_check_failed but applied to OMP_CLAUSE codes.  */
end_comment

begin_function
name|void
name|omp_clause_check_failed
parameter_list|(
specifier|const
name|tree
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|function
parameter_list|,
name|enum
name|omp_clause_code
name|code
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"tree check: expected omp_clause %s, have %s in %s, at %s:%d"
argument_list|,
name|omp_clause_code_name
index|[
name|code
index|]
argument_list|,
name|tree_code_name
index|[
name|TREE_CODE
argument_list|(
name|node
argument_list|)
index|]
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to tree_range_check_failed but applied to OMP_CLAUSE codes.  */
end_comment

begin_function
name|void
name|omp_clause_range_check_failed
parameter_list|(
specifier|const
name|tree
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|function
parameter_list|,
name|enum
name|omp_clause_code
name|c1
parameter_list|,
name|enum
name|omp_clause_code
name|c2
parameter_list|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|length
init|=
literal|0
decl_stmt|;
name|enum
name|omp_clause_code
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|c1
init|;
name|c
operator|<=
name|c2
condition|;
operator|++
name|c
control|)
name|length
operator|+=
literal|4
operator|+
name|strlen
argument_list|(
name|omp_clause_code_name
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|length
operator|+=
name|strlen
argument_list|(
literal|"expected "
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|alloca
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|c1
init|;
name|c
operator|<=
name|c2
condition|;
operator|++
name|c
control|)
block|{
specifier|const
name|char
modifier|*
name|prefix
init|=
name|length
condition|?
literal|" or "
else|:
literal|"expected "
decl_stmt|;
name|strcpy
argument_list|(
name|buffer
operator|+
name|length
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|length
operator|+=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
operator|+
name|length
argument_list|,
name|omp_clause_code_name
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|length
operator|+=
name|strlen
argument_list|(
name|omp_clause_code_name
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
name|internal_error
argument_list|(
literal|"tree check: %s, have %s in %s, at %s:%d"
argument_list|,
name|buffer
argument_list|,
name|omp_clause_code_name
index|[
name|TREE_CODE
argument_list|(
name|node
argument_list|)
index|]
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|DEFTREESTRUCT
end_undef

begin_define
define|#
directive|define
name|DEFTREESTRUCT
parameter_list|(
name|VAL
parameter_list|,
name|NAME
parameter_list|)
value|NAME,
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ts_enum_names
index|[]
init|=
block|{
include|#
directive|include
file|"treestruct.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREESTRUCT
end_undef

begin_define
define|#
directive|define
name|TS_ENUM_NAME
parameter_list|(
name|EN
parameter_list|)
value|(ts_enum_names[(EN)])
end_define

begin_comment
comment|/* Similar to tree_class_check_failed, except that we check for    whether CODE contains the tree structure identified by EN.  */
end_comment

begin_function
name|void
name|tree_contains_struct_check_failed
parameter_list|(
specifier|const
name|tree
name|node
parameter_list|,
specifier|const
name|enum
name|tree_node_structure_enum
name|en
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|function
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"tree check: expected tree that contains %qs structure, have %qs  in %s, at %s:%d"
argument_list|,
name|TS_ENUM_NAME
argument_list|(
name|en
argument_list|)
argument_list|,
name|tree_code_name
index|[
name|TREE_CODE
argument_list|(
name|node
argument_list|)
index|]
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to above, except that the check is for the bounds of a TREE_VEC's    (dynamically sized) vector.  */
end_comment

begin_function
name|void
name|tree_vec_elt_check_failed
parameter_list|(
name|int
name|idx
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|function
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"tree check: accessed elt %d of tree_vec with %d elts in %s, at %s:%d"
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|len
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to above, except that the check is for the bounds of a PHI_NODE's    (dynamically sized) vector.  */
end_comment

begin_function
name|void
name|phi_node_elt_check_failed
parameter_list|(
name|int
name|idx
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|function
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"tree check: accessed elt %d of phi_node with %d elts in %s, at %s:%d"
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|len
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to above, except that the check is for the bounds of the operand    vector of an expression node.  */
end_comment

begin_function
name|void
name|tree_operand_check_failed
parameter_list|(
name|int
name|idx
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|function
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"tree check: accessed operand %d of %s with %d operands in %s, at %s:%d"
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|tree_code_name
index|[
name|code
index|]
argument_list|,
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to above, except that the check is for the number of    operands of an OMP_CLAUSE node.  */
end_comment

begin_function
name|void
name|omp_clause_operand_check_failed
parameter_list|(
name|int
name|idx
parameter_list|,
name|tree
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|function
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"tree check: accessed operand %d of omp_clause %s with %d operands "
literal|"in %s, at %s:%d"
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|omp_clause_code_name
index|[
name|OMP_CLAUSE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|,
name|omp_clause_num_ops
index|[
name|OMP_CLAUSE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_TREE_CHECKING */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Create a new vector type node holding SUBPARTS units of type INNERTYPE,    and mapped to the machine mode MODE.  Initialize its fields and build    the information necessary for debugging output.  */
end_comment

begin_function
specifier|static
name|tree
name|make_vector_type
parameter_list|(
name|tree
name|innertype
parameter_list|,
name|int
name|nunits
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|hashval_t
name|hashcode
init|=
literal|0
decl_stmt|;
comment|/* Build a main variant, based on the main variant of the inner type, then      use it to build the variant we return.  */
if|if
condition|(
operator|(
name|TYPE_ATTRIBUTES
argument_list|(
name|innertype
argument_list|)
operator|||
name|TYPE_QUALS
argument_list|(
name|innertype
argument_list|)
operator|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|innertype
argument_list|)
operator|!=
name|innertype
condition|)
return|return
name|build_type_attribute_qual_variant
argument_list|(
name|make_vector_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|innertype
argument_list|)
argument_list|,
name|nunits
argument_list|,
name|mode
argument_list|)
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|innertype
argument_list|)
argument_list|,
name|TYPE_QUALS
argument_list|(
name|innertype
argument_list|)
argument_list|)
return|;
name|t
operator|=
name|make_node
argument_list|(
name|VECTOR_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|innertype
argument_list|)
expr_stmt|;
name|SET_TYPE_VECTOR_SUBPARTS
argument_list|(
name|t
argument_list|,
name|nunits
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|=
name|mode
expr_stmt|;
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_READONLY
argument_list|(
name|innertype
argument_list|)
expr_stmt|;
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|innertype
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|{
name|tree
name|index
init|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|nunits
operator|-
literal|1
argument_list|)
decl_stmt|;
name|tree
name|array
init|=
name|build_array_type
argument_list|(
name|innertype
argument_list|,
name|build_index_type
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|rt
init|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
decl_stmt|;
name|TYPE_FIELDS
argument_list|(
name|rt
argument_list|)
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"f"
argument_list|)
argument_list|,
name|array
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|rt
argument_list|)
argument_list|)
operator|=
name|rt
expr_stmt|;
name|layout_type
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|TYPE_DEBUG_REPRESENTATION_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|rt
expr_stmt|;
comment|/* In dwarfout.c, type lookup uses TYPE_UID numbers.  We want to output        the representation type, and we want to find that die when looking up        the vector type.  This is most easily achieved by making the TYPE_UID        numbers equal.  */
name|TYPE_UID
argument_list|(
name|rt
argument_list|)
operator|=
name|TYPE_UID
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|hashcode
operator|=
name|iterative_hash_host_wide_int
argument_list|(
name|VECTOR_TYPE
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
name|hashcode
operator|=
name|iterative_hash_host_wide_int
argument_list|(
name|mode
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
name|hashcode
operator|=
name|iterative_hash_object
argument_list|(
name|TYPE_HASH
argument_list|(
name|innertype
argument_list|)
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
return|return
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|make_or_reuse_type
parameter_list|(
name|unsigned
name|size
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
name|INT_TYPE_SIZE
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|size
operator|==
name|CHAR_TYPE_SIZE
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|size
operator|==
name|SHORT_TYPE_SIZE
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|size
operator|==
name|LONG_TYPE_SIZE
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|size
operator|==
name|LONG_LONG_TYPE_SIZE
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
if|if
condition|(
name|unsignedp
condition|)
return|return
name|make_unsigned_type
argument_list|(
name|size
argument_list|)
return|;
else|else
return|return
name|make_signed_type
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create nodes for all integer types (and error_mark_node) using the sizes    of C datatypes.  The caller should call set_sizetype soon after calling    this function to select one of the types as sizetype.  */
end_comment

begin_function
name|void
name|build_common_tree_nodes
parameter_list|(
name|bool
name|signed_char
parameter_list|,
name|bool
name|signed_sizetype
parameter_list|)
block|{
name|error_mark_node
operator|=
name|make_node
argument_list|(
name|ERROR_MARK
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|error_mark_node
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|initialize_sizetypes
argument_list|(
name|signed_sizetype
argument_list|)
expr_stmt|;
comment|/* Define both `signed char' and `unsigned char'.  */
name|signed_char_type_node
operator|=
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|TYPE_STRING_FLAG
argument_list|(
name|signed_char_type_node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|unsigned_char_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|TYPE_STRING_FLAG
argument_list|(
name|unsigned_char_type_node
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Define `char', which is like either `signed char' or `unsigned char'      but not the same as either.  */
name|char_type_node
operator|=
operator|(
name|signed_char
condition|?
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
else|:
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
operator|)
expr_stmt|;
name|TYPE_STRING_FLAG
argument_list|(
name|char_type_node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|short_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|SHORT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|short_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|SHORT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|INT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|INT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|long_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|long_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|long_long_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|LONG_LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|long_long_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|LONG_LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
comment|/* Define a boolean type.  This type only represents boolean values but      may be larger than char depending on the value of BOOL_TYPE_SIZE.      Front ends which want to override this size (i.e. Java) can redefine      boolean_type_node before calling build_common_tree_nodes_2.  */
name|boolean_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|BOOL_TYPE_SIZE
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|boolean_type_node
argument_list|,
name|BOOLEAN_TYPE
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|boolean_type_node
argument_list|)
operator|=
name|build_int_cst
argument_list|(
name|boolean_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|boolean_type_node
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Fill in the rest of the sized types.  Reuse existing type nodes      when possible.  */
name|intQI_type_node
operator|=
name|make_or_reuse_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|intHI_type_node
operator|=
name|make_or_reuse_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|intSI_type_node
operator|=
name|make_or_reuse_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|intDI_type_node
operator|=
name|make_or_reuse_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|DImode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|intTI_type_node
operator|=
name|make_or_reuse_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|TImode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unsigned_intQI_type_node
operator|=
name|make_or_reuse_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|unsigned_intHI_type_node
operator|=
name|make_or_reuse_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|unsigned_intSI_type_node
operator|=
name|make_or_reuse_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|unsigned_intDI_type_node
operator|=
name|make_or_reuse_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|DImode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|unsigned_intTI_type_node
operator|=
name|make_or_reuse_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|TImode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|access_public_node
operator|=
name|get_identifier
argument_list|(
literal|"public"
argument_list|)
expr_stmt|;
name|access_protected_node
operator|=
name|get_identifier
argument_list|(
literal|"protected"
argument_list|)
expr_stmt|;
name|access_private_node
operator|=
name|get_identifier
argument_list|(
literal|"private"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this function after calling build_common_tree_nodes and set_sizetype.    It will create several other common tree nodes.  */
end_comment

begin_function
name|void
name|build_common_tree_nodes_2
parameter_list|(
name|int
name|short_double
parameter_list|)
block|{
comment|/* Define these next since types below may used them.  */
name|integer_zero_node
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|integer_one_node
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|integer_minus_one_node
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|size_zero_node
operator|=
name|size_int
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|size_one_node
operator|=
name|size_int
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bitsize_zero_node
operator|=
name|bitsize_int
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bitsize_one_node
operator|=
name|bitsize_int
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bitsize_unit_node
operator|=
name|bitsize_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|boolean_false_node
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|boolean_type_node
argument_list|)
expr_stmt|;
name|boolean_true_node
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|boolean_type_node
argument_list|)
expr_stmt|;
name|void_type_node
operator|=
name|make_node
argument_list|(
name|VOID_TYPE
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* We are not going to have real types in C with less than byte alignment,      so we might as well not have any types that claim to have it.  */
name|TYPE_ALIGN
argument_list|(
name|void_type_node
argument_list|)
operator|=
name|BITS_PER_UNIT
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|void_type_node
argument_list|)
operator|=
literal|0
expr_stmt|;
name|null_pointer_node
operator|=
name|build_int_cst
argument_list|(
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
argument_list|)
expr_stmt|;
name|ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|const_ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|void_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fileptr_type_node
operator|=
name|ptr_type_node
expr_stmt|;
name|float_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|float_type_node
argument_list|)
operator|=
name|FLOAT_TYPE_SIZE
expr_stmt|;
name|layout_type
argument_list|(
name|float_type_node
argument_list|)
expr_stmt|;
name|double_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|short_double
condition|)
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|=
name|FLOAT_TYPE_SIZE
expr_stmt|;
else|else
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|=
name|DOUBLE_TYPE_SIZE
expr_stmt|;
name|layout_type
argument_list|(
name|double_type_node
argument_list|)
expr_stmt|;
name|long_double_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|long_double_type_node
argument_list|)
operator|=
name|LONG_DOUBLE_TYPE_SIZE
expr_stmt|;
name|layout_type
argument_list|(
name|long_double_type_node
argument_list|)
expr_stmt|;
name|float_ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|float_type_node
argument_list|)
expr_stmt|;
name|double_ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|double_type_node
argument_list|)
expr_stmt|;
name|long_double_ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|long_double_type_node
argument_list|)
expr_stmt|;
name|integer_ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
comment|/* Decimal float types. */
name|dfloat32_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|dfloat32_type_node
argument_list|)
operator|=
name|DECIMAL32_TYPE_SIZE
expr_stmt|;
name|layout_type
argument_list|(
name|dfloat32_type_node
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|dfloat32_type_node
argument_list|)
operator|=
name|SDmode
expr_stmt|;
name|dfloat32_ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|dfloat32_type_node
argument_list|)
expr_stmt|;
name|dfloat64_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|dfloat64_type_node
argument_list|)
operator|=
name|DECIMAL64_TYPE_SIZE
expr_stmt|;
name|layout_type
argument_list|(
name|dfloat64_type_node
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|dfloat64_type_node
argument_list|)
operator|=
name|DDmode
expr_stmt|;
name|dfloat64_ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|dfloat64_type_node
argument_list|)
expr_stmt|;
name|dfloat128_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|dfloat128_type_node
argument_list|)
operator|=
name|DECIMAL128_TYPE_SIZE
expr_stmt|;
name|layout_type
argument_list|(
name|dfloat128_type_node
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|dfloat128_type_node
argument_list|)
operator|=
name|TDmode
expr_stmt|;
name|dfloat128_ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|dfloat128_type_node
argument_list|)
expr_stmt|;
name|complex_integer_type_node
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|complex_integer_type_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|layout_type
argument_list|(
name|complex_integer_type_node
argument_list|)
expr_stmt|;
name|complex_float_type_node
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|complex_float_type_node
argument_list|)
operator|=
name|float_type_node
expr_stmt|;
name|layout_type
argument_list|(
name|complex_float_type_node
argument_list|)
expr_stmt|;
name|complex_double_type_node
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|complex_double_type_node
argument_list|)
operator|=
name|double_type_node
expr_stmt|;
name|layout_type
argument_list|(
name|complex_double_type_node
argument_list|)
expr_stmt|;
name|complex_long_double_type_node
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|complex_long_double_type_node
argument_list|)
operator|=
name|long_double_type_node
expr_stmt|;
name|layout_type
argument_list|(
name|complex_long_double_type_node
argument_list|)
expr_stmt|;
block|{
name|tree
name|t
init|=
name|targetm
operator|.
name|build_builtin_va_list
argument_list|()
decl_stmt|;
comment|/* Many back-ends define record types without setting TYPE_NAME.        If we copied the record type here, we'd keep the original        record type without a name.  This breaks name mangling.  So,        don't copy record types and let c_common_nodes_and_builtins()        declare the type to be __builtin_va_list.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
name|t
operator|=
name|build_variant_type_copy
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|va_list_type_node
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of build_common_builtin_nodes.  Define a builtin function.  */
end_comment

begin_function
specifier|static
name|void
name|local_define_builtin
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|type
parameter_list|,
name|enum
name|built_in_function
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|library_name
parameter_list|,
name|int
name|ecf_flags
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|lang_hooks
operator|.
name|builtin_function
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|BUILT_IN_NORMAL
argument_list|,
name|library_name
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecf_flags
operator|&
name|ECF_CONST
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ecf_flags
operator|&
name|ECF_PURE
condition|)
name|DECL_IS_PURE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ecf_flags
operator|&
name|ECF_NORETURN
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ecf_flags
operator|&
name|ECF_NOTHROW
condition|)
name|TREE_NOTHROW
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ecf_flags
operator|&
name|ECF_MALLOC
condition|)
name|DECL_IS_MALLOC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|built_in_decls
index|[
name|code
index|]
operator|=
name|decl
expr_stmt|;
name|implicit_built_in_decls
index|[
name|code
index|]
operator|=
name|decl
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this function after instantiating all builtins that the language    front end cares about.  This will build the rest of the builtins that    are relied upon by the tree optimizers and the middle-end.  */
end_comment

begin_function
name|void
name|build_common_builtin_nodes
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|tmp
decl_stmt|,
name|ftype
decl_stmt|;
if|if
condition|(
name|built_in_decls
index|[
name|BUILT_IN_MEMCPY
index|]
operator|==
name|NULL
operator|||
name|built_in_decls
index|[
name|BUILT_IN_MEMMOVE
index|]
operator|==
name|NULL
condition|)
block|{
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|built_in_decls
index|[
name|BUILT_IN_MEMCPY
index|]
operator|==
name|NULL
condition|)
name|local_define_builtin
argument_list|(
literal|"__builtin_memcpy"
argument_list|,
name|ftype
argument_list|,
name|BUILT_IN_MEMCPY
argument_list|,
literal|"memcpy"
argument_list|,
name|ECF_NOTHROW
argument_list|)
expr_stmt|;
if|if
condition|(
name|built_in_decls
index|[
name|BUILT_IN_MEMMOVE
index|]
operator|==
name|NULL
condition|)
name|local_define_builtin
argument_list|(
literal|"__builtin_memmove"
argument_list|,
name|ftype
argument_list|,
name|BUILT_IN_MEMMOVE
argument_list|,
literal|"memmove"
argument_list|,
name|ECF_NOTHROW
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|built_in_decls
index|[
name|BUILT_IN_MEMCMP
index|]
operator|==
name|NULL
condition|)
block|{
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|local_define_builtin
argument_list|(
literal|"__builtin_memcmp"
argument_list|,
name|ftype
argument_list|,
name|BUILT_IN_MEMCMP
argument_list|,
literal|"memcmp"
argument_list|,
name|ECF_PURE
operator||
name|ECF_NOTHROW
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|built_in_decls
index|[
name|BUILT_IN_MEMSET
index|]
operator|==
name|NULL
condition|)
block|{
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|local_define_builtin
argument_list|(
literal|"__builtin_memset"
argument_list|,
name|ftype
argument_list|,
name|BUILT_IN_MEMSET
argument_list|,
literal|"memset"
argument_list|,
name|ECF_NOTHROW
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|built_in_decls
index|[
name|BUILT_IN_ALLOCA
index|]
operator|==
name|NULL
condition|)
block|{
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|local_define_builtin
argument_list|(
literal|"__builtin_alloca"
argument_list|,
name|ftype
argument_list|,
name|BUILT_IN_ALLOCA
argument_list|,
literal|"alloca"
argument_list|,
name|ECF_NOTHROW
operator||
name|ECF_MALLOC
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|local_define_builtin
argument_list|(
literal|"__builtin_init_trampoline"
argument_list|,
name|ftype
argument_list|,
name|BUILT_IN_INIT_TRAMPOLINE
argument_list|,
literal|"__builtin_init_trampoline"
argument_list|,
name|ECF_NOTHROW
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|local_define_builtin
argument_list|(
literal|"__builtin_adjust_trampoline"
argument_list|,
name|ftype
argument_list|,
name|BUILT_IN_ADJUST_TRAMPOLINE
argument_list|,
literal|"__builtin_adjust_trampoline"
argument_list|,
name|ECF_CONST
operator||
name|ECF_NOTHROW
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|local_define_builtin
argument_list|(
literal|"__builtin_nonlocal_goto"
argument_list|,
name|ftype
argument_list|,
name|BUILT_IN_NONLOCAL_GOTO
argument_list|,
literal|"__builtin_nonlocal_goto"
argument_list|,
name|ECF_NORETURN
operator||
name|ECF_NOTHROW
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|local_define_builtin
argument_list|(
literal|"__builtin_setjmp_setup"
argument_list|,
name|ftype
argument_list|,
name|BUILT_IN_SETJMP_SETUP
argument_list|,
literal|"__builtin_setjmp_setup"
argument_list|,
name|ECF_NOTHROW
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|local_define_builtin
argument_list|(
literal|"__builtin_setjmp_dispatcher"
argument_list|,
name|ftype
argument_list|,
name|BUILT_IN_SETJMP_DISPATCHER
argument_list|,
literal|"__builtin_setjmp_dispatcher"
argument_list|,
name|ECF_PURE
operator||
name|ECF_NOTHROW
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|local_define_builtin
argument_list|(
literal|"__builtin_setjmp_receiver"
argument_list|,
name|ftype
argument_list|,
name|BUILT_IN_SETJMP_RECEIVER
argument_list|,
literal|"__builtin_setjmp_receiver"
argument_list|,
name|ECF_NOTHROW
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|local_define_builtin
argument_list|(
literal|"__builtin_stack_save"
argument_list|,
name|ftype
argument_list|,
name|BUILT_IN_STACK_SAVE
argument_list|,
literal|"__builtin_stack_save"
argument_list|,
name|ECF_NOTHROW
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|local_define_builtin
argument_list|(
literal|"__builtin_stack_restore"
argument_list|,
name|ftype
argument_list|,
name|BUILT_IN_STACK_RESTORE
argument_list|,
literal|"__builtin_stack_restore"
argument_list|,
name|ECF_NOTHROW
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|local_define_builtin
argument_list|(
literal|"__builtin_profile_func_enter"
argument_list|,
name|ftype
argument_list|,
name|BUILT_IN_PROFILE_FUNC_ENTER
argument_list|,
literal|"profile_func_enter"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|local_define_builtin
argument_list|(
literal|"__builtin_profile_func_exit"
argument_list|,
name|ftype
argument_list|,
name|BUILT_IN_PROFILE_FUNC_EXIT
argument_list|,
literal|"profile_func_exit"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Complex multiplication and division.  These are handled as builtins      rather than optabs because emit_library_call_value doesn't support      complex.  Further, we can do slightly better with folding these       beasties if the real and complex parts of the arguments are separate.  */
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|MIN_MODE_COMPLEX_FLOAT
init|;
name|mode
operator|<=
name|MAX_MODE_COMPLEX_FLOAT
condition|;
operator|++
name|mode
control|)
block|{
name|char
name|mode_name_buf
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|enum
name|built_in_function
name|mcode
decl_stmt|,
name|dcode
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|inner_type
decl_stmt|;
name|type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
continue|continue;
name|inner_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|inner_type
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|inner_type
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|inner_type
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|inner_type
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|type
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|mcode
operator|=
name|BUILT_IN_COMPLEX_MUL_MIN
operator|+
name|mode
operator|-
name|MIN_MODE_COMPLEX_FLOAT
expr_stmt|;
name|dcode
operator|=
name|BUILT_IN_COMPLEX_DIV_MIN
operator|+
name|mode
operator|-
name|MIN_MODE_COMPLEX_FLOAT
expr_stmt|;
for|for
control|(
name|p
operator|=
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
operator|,
name|q
operator|=
name|mode_name_buf
init|;
operator|*
name|p
condition|;
name|p
operator|++
operator|,
name|q
operator|++
control|)
operator|*
name|q
operator|=
name|TOLOWER
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|built_in_names
index|[
name|mcode
index|]
operator|=
name|concat
argument_list|(
literal|"__mul"
argument_list|,
name|mode_name_buf
argument_list|,
literal|"3"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|local_define_builtin
argument_list|(
name|built_in_names
index|[
name|mcode
index|]
argument_list|,
name|ftype
argument_list|,
name|mcode
argument_list|,
name|built_in_names
index|[
name|mcode
index|]
argument_list|,
name|ECF_CONST
operator||
name|ECF_NOTHROW
argument_list|)
expr_stmt|;
name|built_in_names
index|[
name|dcode
index|]
operator|=
name|concat
argument_list|(
literal|"__div"
argument_list|,
name|mode_name_buf
argument_list|,
literal|"3"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|local_define_builtin
argument_list|(
name|built_in_names
index|[
name|dcode
index|]
argument_list|,
name|ftype
argument_list|,
name|dcode
argument_list|,
name|built_in_names
index|[
name|dcode
index|]
argument_list|,
name|ECF_CONST
operator||
name|ECF_NOTHROW
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* HACK.  GROSS.  This is absolutely disgusting.  I wish there was a    better way.     If we requested a pointer to a vector, build up the pointers that    we stripped off while looking for the inner type.  Similarly for    return values from functions.     The argument TYPE is the top of the chain, and BOTTOM is the    new type which we will point to.  */
end_comment

begin_function
name|tree
name|reconstruct_complex_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|bottom
parameter_list|)
block|{
name|tree
name|inner
decl_stmt|,
name|outer
decl_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|inner
operator|=
name|reconstruct_complex_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|outer
operator|=
name|build_pointer_type
argument_list|(
name|inner
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|inner
operator|=
name|reconstruct_complex_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|outer
operator|=
name|build_array_type
argument_list|(
name|inner
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|inner
operator|=
name|reconstruct_complex_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|outer
operator|=
name|build_function_type
argument_list|(
name|inner
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|argtypes
decl_stmt|;
name|inner
operator|=
name|reconstruct_complex_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
comment|/* The build_method_type_directly() routine prepends 'this' to argument list,          so we must compensate by getting rid of it.  */
name|argtypes
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|outer
operator|=
name|build_method_type_directly
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|inner
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|outer
argument_list|)
operator|=
name|argtypes
expr_stmt|;
block|}
else|else
return|return
name|bottom
return|;
name|TYPE_READONLY
argument_list|(
name|outer
argument_list|)
operator|=
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_VOLATILE
argument_list|(
name|outer
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|outer
return|;
block|}
end_function

begin_comment
comment|/* Returns a vector tree node given a mode (integer, vector, or BLKmode) and    the inner type.  */
end_comment

begin_function
name|tree
name|build_vector_type_for_mode
parameter_list|(
name|tree
name|innertype
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|int
name|nunits
decl_stmt|;
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
name|MODE_VECTOR_INT
case|:
case|case
name|MODE_VECTOR_FLOAT
case|:
name|nunits
operator|=
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_INT
case|:
comment|/* Check that there are no leftover bits.  */
name|gcc_assert
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|%
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|innertype
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nunits
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|innertype
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|make_vector_type
argument_list|(
name|innertype
argument_list|,
name|nunits
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similarly, but takes the inner type and number of units, which must be    a power of two.  */
end_comment

begin_function
name|tree
name|build_vector_type
parameter_list|(
name|tree
name|innertype
parameter_list|,
name|int
name|nunits
parameter_list|)
block|{
return|return
name|make_vector_type
argument_list|(
name|innertype
argument_list|,
name|nunits
argument_list|,
name|VOIDmode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build RESX_EXPR with given REGION_NUMBER.  */
end_comment

begin_function
name|tree
name|build_resx
parameter_list|(
name|int
name|region_number
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|RESX_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|region_number
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Given an initializer INIT, return TRUE if INIT is zero or some    aggregate of zeros.  Otherwise return FALSE.  */
end_comment

begin_function
name|bool
name|initializer_zerop
parameter_list|(
name|tree
name|init
parameter_list|)
block|{
name|tree
name|elt
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|init
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
return|return
name|integer_zerop
argument_list|(
name|init
argument_list|)
return|;
case|case
name|REAL_CST
case|:
comment|/* ??? Note that this is not correct for C4X float formats.  There, 	 a bit pattern of all zeros is 1.0; 0.0 is encoded with the most 	 negative exponent.  */
return|return
name|real_zerop
argument_list|(
name|init
argument_list|)
operator|&&
operator|!
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|init
argument_list|)
argument_list|)
return|;
case|case
name|COMPLEX_CST
case|:
return|return
name|integer_zerop
argument_list|(
name|init
argument_list|)
operator|||
operator|(
name|real_zerop
argument_list|(
name|init
argument_list|)
operator|&&
operator|!
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|TREE_REALPART
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|VECTOR_CST
case|:
for|for
control|(
name|elt
operator|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|init
argument_list|)
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
if|if
condition|(
operator|!
name|initializer_zerop
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
case|case
name|CONSTRUCTOR
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|FOR_EACH_CONSTRUCTOR_VALUE
argument_list|(
argument|CONSTRUCTOR_ELTS (init)
argument_list|,
argument|idx
argument_list|,
argument|elt
argument_list|)
if|if
condition|(
operator|!
name|initializer_zerop
argument_list|(
name|elt
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Build an empty statement.  */
end_comment

begin_function
name|tree
name|build_empty_stmt
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|size_zero_node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an OpenMP clause with code CODE.  */
end_comment

begin_function
name|tree
name|build_omp_clause
parameter_list|(
name|enum
name|omp_clause_code
name|code
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|int
name|size
decl_stmt|,
name|length
decl_stmt|;
name|length
operator|=
name|omp_clause_num_ops
index|[
name|code
index|]
expr_stmt|;
name|size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_omp_clause
argument_list|)
operator|+
operator|(
name|length
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|)
expr_stmt|;
name|t
operator|=
name|ggc_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|OMP_CLAUSE
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_SET_CODE
argument_list|(
name|t
argument_list|,
name|code
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|omp_clause_kind
index|]
operator|++
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|omp_clause_kind
index|]
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Returns true if it is possible to prove that the index of    an array access REF (an ARRAY_REF expression) falls into the    array bounds.  */
end_comment

begin_function
name|bool
name|in_array_bounds_p
parameter_list|(
name|tree
name|ref
parameter_list|)
block|{
name|tree
name|idx
init|=
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|min
decl_stmt|,
name|max
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|idx
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|false
return|;
name|min
operator|=
name|array_ref_low_bound
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|max
operator|=
name|array_ref_up_bound
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|min
operator|||
operator|!
name|max
operator|||
name|TREE_CODE
argument_list|(
name|min
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|max
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|false
return|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|idx
argument_list|,
name|min
argument_list|)
operator|||
name|tree_int_cst_lt
argument_list|(
name|max
argument_list|,
name|idx
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Returns true if it is possible to prove that the range of    an array access REF (an ARRAY_RANGE_REF expression) falls    into the array bounds.  */
end_comment

begin_function
name|bool
name|range_in_array_bounds_p
parameter_list|(
name|tree
name|ref
parameter_list|)
block|{
name|tree
name|domain_type
init|=
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|range_min
decl_stmt|,
name|range_max
decl_stmt|,
name|min
decl_stmt|,
name|max
decl_stmt|;
name|range_min
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|domain_type
argument_list|)
expr_stmt|;
name|range_max
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|domain_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|range_min
operator|||
operator|!
name|range_max
operator|||
name|TREE_CODE
argument_list|(
name|range_min
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|range_max
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|false
return|;
name|min
operator|=
name|array_ref_low_bound
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|max
operator|=
name|array_ref_up_bound
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|min
operator|||
operator|!
name|max
operator|||
name|TREE_CODE
argument_list|(
name|min
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|max
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|false
return|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|range_min
argument_list|,
name|min
argument_list|)
operator|||
name|tree_int_cst_lt
argument_list|(
name|max
argument_list|,
name|range_max
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if T (assumed to be a DECL) is a global variable.  */
end_comment

begin_function
name|bool
name|is_global_var
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|MTAG_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|||
name|MTAG_GLOBAL
argument_list|(
name|t
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if T (assumed to be a DECL) must be assigned a memory    location.  */
end_comment

begin_function
name|bool
name|needs_to_live_in_memory
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
operator|(
name|TREE_ADDRESSABLE
argument_list|(
name|t
argument_list|)
operator|||
name|is_global_var
argument_list|(
name|t
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RESULT_DECL
operator|&&
name|aggregate_value_p
argument_list|(
name|t
argument_list|,
name|current_function_decl
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* There are situations in which a language considers record types    compatible which have different field lists.  Decide if two fields    are compatible.  It is assumed that the parent records are compatible.  */
end_comment

begin_function
name|bool
name|fields_compatible_p
parameter_list|(
name|tree
name|f1
parameter_list|,
name|tree
name|f2
parameter_list|)
block|{
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|f1
argument_list|)
argument_list|,
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|f2
argument_list|)
argument_list|,
name|OEP_ONLY_CONST
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|f1
argument_list|)
argument_list|,
name|DECL_FIELD_OFFSET
argument_list|(
name|f2
argument_list|)
argument_list|,
name|OEP_ONLY_CONST
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|f1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|f2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Locate within RECORD a field that is compatible with ORIG_FIELD.  */
end_comment

begin_function
name|tree
name|find_compatible_field
parameter_list|(
name|tree
name|record
parameter_list|,
name|tree
name|orig_field
parameter_list|)
block|{
name|tree
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|TYPE_FIELDS
argument_list|(
name|record
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|fields_compatible_p
argument_list|(
name|f
argument_list|,
name|orig_field
argument_list|)
condition|)
return|return
name|f
return|;
comment|/* ??? Why isn't this on the main fields list?  */
name|f
operator|=
name|TYPE_VFIELD
argument_list|(
name|record
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&&
name|TREE_CODE
argument_list|(
name|f
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|fields_compatible_p
argument_list|(
name|f
argument_list|,
name|orig_field
argument_list|)
condition|)
return|return
name|f
return|;
comment|/* ??? We should abort here, but Java appears to do Bad Things      with inherited fields.  */
return|return
name|orig_field
return|;
block|}
end_function

begin_comment
comment|/* Return value of a constant X.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|int_cst_value
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
name|unsigned
name|bits
init|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|val
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|bool
name|negative
init|=
operator|(
operator|(
name|val
operator|>>
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
operator|!=
literal|0
decl_stmt|;
name|gcc_assert
argument_list|(
name|bits
operator|<=
name|HOST_BITS_PER_WIDE_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|negative
condition|)
name|val
operator||=
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|<<
literal|1
expr_stmt|;
else|else
name|val
operator|&=
operator|~
operator|(
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Returns the greatest common divisor of A and B, which must be    INTEGER_CSTs.  */
end_comment

begin_function
name|tree
name|tree_fold_gcd
parameter_list|(
name|tree
name|a
parameter_list|,
name|tree
name|b
parameter_list|)
block|{
name|tree
name|a_mod_b
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|a
argument_list|)
condition|)
return|return
name|b
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|a
return|;
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|a
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|a
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|a
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|b
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|b
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|b
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|a_mod_b
operator|=
name|fold_build2
argument_list|(
name|FLOOR_MOD_EXPR
argument_list|,
name|type
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_INT_CST_LOW
argument_list|(
name|a_mod_b
argument_list|)
operator|&&
operator|!
name|TREE_INT_CST_HIGH
argument_list|(
name|a_mod_b
argument_list|)
condition|)
return|return
name|b
return|;
name|a
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|a_mod_b
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns unsigned variant of TYPE.  */
end_comment

begin_function
name|tree
name|unsigned_type_for
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|lang_hooks
operator|.
name|types
operator|.
name|unsigned_type
argument_list|(
name|size_type_node
argument_list|)
return|;
return|return
name|lang_hooks
operator|.
name|types
operator|.
name|unsigned_type
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns signed variant of TYPE.  */
end_comment

begin_function
name|tree
name|signed_type_for
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
argument_list|(
name|size_type_node
argument_list|)
return|;
return|return
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the largest value obtainable by casting something in INNER type to    OUTER type.  */
end_comment

begin_function
name|tree
name|upper_bound_in_type
parameter_list|(
name|tree
name|outer
parameter_list|,
name|tree
name|inner
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|unsigned
name|int
name|det
init|=
literal|0
decl_stmt|;
name|unsigned
name|oprec
init|=
name|TYPE_PRECISION
argument_list|(
name|outer
argument_list|)
decl_stmt|;
name|unsigned
name|iprec
init|=
name|TYPE_PRECISION
argument_list|(
name|inner
argument_list|)
decl_stmt|;
name|unsigned
name|prec
decl_stmt|;
comment|/* Compute a unique number for every combination.  */
name|det
operator||=
operator|(
name|oprec
operator|>
name|iprec
operator|)
condition|?
literal|4
else|:
literal|0
expr_stmt|;
name|det
operator||=
name|TYPE_UNSIGNED
argument_list|(
name|outer
argument_list|)
condition|?
literal|2
else|:
literal|0
expr_stmt|;
name|det
operator||=
name|TYPE_UNSIGNED
argument_list|(
name|inner
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* Determine the exponent to use.  */
switch|switch
condition|(
name|det
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
comment|/* oprec<= iprec, outer: signed, inner: don't care.  */
name|prec
operator|=
name|oprec
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|3
case|:
comment|/* oprec<= iprec, outer: unsigned, inner: don't care.  */
name|prec
operator|=
name|oprec
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* oprec> iprec, outer: signed, inner: signed.  */
name|prec
operator|=
name|iprec
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* oprec> iprec, outer: signed, inner: unsigned.  */
name|prec
operator|=
name|iprec
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* oprec> iprec, outer: unsigned, inner: signed.  */
name|prec
operator|=
name|oprec
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* oprec> iprec, outer: unsigned, inner: unsigned.  */
name|prec
operator|=
name|iprec
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Compute 2^^prec - 1.  */
if|if
condition|(
name|prec
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|hi
operator|=
literal|0
expr_stmt|;
name|lo
operator|=
operator|(
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|prec
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
operator|(
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|>>
operator|(
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|-
name|prec
operator|)
operator|)
expr_stmt|;
name|lo
operator|=
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
expr_stmt|;
block|}
return|return
name|build_int_cst_wide
argument_list|(
name|outer
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the smallest value obtainable by casting something in INNER type to    OUTER type.  */
end_comment

begin_function
name|tree
name|lower_bound_in_type
parameter_list|(
name|tree
name|outer
parameter_list|,
name|tree
name|inner
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|unsigned
name|oprec
init|=
name|TYPE_PRECISION
argument_list|(
name|outer
argument_list|)
decl_stmt|;
name|unsigned
name|iprec
init|=
name|TYPE_PRECISION
argument_list|(
name|inner
argument_list|)
decl_stmt|;
comment|/* If OUTER type is unsigned, we can definitely cast 0 to OUTER type      and obtain 0.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|outer
argument_list|)
comment|/* If we are widening something of an unsigned type, OUTER type 	 contains all values of INNER type.  In particular, both INNER 	 and OUTER types have zero in common.  */
operator|||
operator|(
name|oprec
operator|>
name|iprec
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|inner
argument_list|)
operator|)
condition|)
name|lo
operator|=
name|hi
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* If we are widening a signed type to another signed type, we 	 want to obtain -2^^(iprec-1).  If we are keeping the 	 precision or narrowing to a signed type, we want to obtain 	 -2^(oprec-1).  */
name|unsigned
name|prec
init|=
name|oprec
operator|>
name|iprec
condition|?
name|iprec
else|:
name|oprec
decl_stmt|;
if|if
condition|(
name|prec
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|hi
operator|=
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
expr_stmt|;
name|lo
operator|=
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|<<
operator|(
name|prec
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
operator|(
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|build_int_cst_wide
argument_list|(
name|outer
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if two operands that are suitable for PHI nodes are    necessarily equal.  Specifically, both ARG0 and ARG1 must be either    SSA_NAME or invariant.  Note that this is strictly an optimization.    That is, callers of this function can directly call operand_equal_p    and get the same result, only slower.  */
end_comment

begin_function
name|int
name|operand_equal_for_phi_arg_p
parameter_list|(
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
if|if
condition|(
name|arg0
operator|==
name|arg1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|SSA_NAME
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|SSA_NAME
condition|)
return|return
literal|0
return|;
return|return
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns number of zeros at the end of binary representation of X.        ??? Use ffs if available?  */
end_comment

begin_function
name|tree
name|num_ending_zeros
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|fr
decl_stmt|,
name|nfr
decl_stmt|;
name|unsigned
name|num
decl_stmt|,
name|abits
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
name|num
operator|=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
name|fr
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num
operator|=
literal|0
expr_stmt|;
name|fr
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|abits
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
init|;
name|abits
condition|;
name|abits
operator|/=
literal|2
control|)
block|{
name|nfr
operator|=
name|fr
operator|>>
name|abits
expr_stmt|;
if|if
condition|(
name|nfr
operator|<<
name|abits
operator|==
name|fr
condition|)
block|{
name|num
operator|+=
name|abits
expr_stmt|;
name|fr
operator|=
name|nfr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|num
operator|>
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
condition|)
name|num
operator|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|build_int_cst_type
argument_list|(
name|type
argument_list|,
name|num
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|WALK_SUBTREE
parameter_list|(
name|NODE
parameter_list|)
define|\
value|do							\     {							\       result = walk_tree (&(NODE), func, data, pset);	\       if (result)					\ 	return result;					\     }							\   while (0)
end_define

begin_comment
comment|/* This is a subroutine of walk_tree that walks field of TYPE that are to    be walked whenever a type is seen in the tree.  Rest of operands and return    value are as for walk_tree.  */
end_comment

begin_function
specifier|static
name|tree
name|walk_type_fields
parameter_list|(
name|tree
name|type
parameter_list|,
name|walk_tree_fn
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|pointer_set_t
modifier|*
name|pset
parameter_list|)
block|{
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* We have to worry about mutually recursive pointers.  These can't 	 be written in C.  They can in Ada.  It's pathological, but 	 there's an ACATS test (c38102a) that checks it.  Deal with this 	 by checking if we're pointing to another pointer, that one 	 points to another pointer, that one does too, and we have no htab. 	 If so, get a hash table.  We check three levels deep to avoid 	 the cost of the hash table if we don't need one.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|pset
condition|)
block|{
name|result
operator|=
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|func
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
break|break;
block|}
comment|/* ... fall through ... */
case|case
name|COMPLEX_TYPE
case|:
name|WALK_SUBTREE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
name|WALK_SUBTREE
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|FUNCTION_TYPE
case|:
name|WALK_SUBTREE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|tree
name|arg
decl_stmt|;
comment|/* We never want to walk into default arguments.  */
for|for
control|(
name|arg
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
name|WALK_SUBTREE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARRAY_TYPE
case|:
comment|/* Don't follow this nodes's type if a pointer for fear that 	 we'll have infinite recursion.  If we have a PSET, then we 	 need not fear.  */
if|if
condition|(
name|pset
operator|||
operator|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|OFFSET_TYPE
operator|)
condition|)
name|WALK_SUBTREE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
name|WALK_SUBTREE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFSET_TYPE
case|:
name|WALK_SUBTREE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Apply FUNC to all the sub-trees of TP in a pre-order traversal.  FUNC is    called with the DATA and the address of each sub-tree.  If FUNC returns a    non-NULL value, the traversal is stopped, and the value returned by FUNC    is returned.  If PSET is non-NULL it is used to record the nodes visited,    and to avoid visiting a node more than once.  */
end_comment

begin_function
name|tree
name|walk_tree
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|walk_tree_fn
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|pointer_set_t
modifier|*
name|pset
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|walk_subtrees
decl_stmt|;
name|tree
name|result
decl_stmt|;
define|#
directive|define
name|WALK_SUBTREE_TAIL
parameter_list|(
name|NODE
parameter_list|)
define|\
value|do							\     {							\        tp =& (NODE);					\        goto tail_recurse;				\     }							\   while (0)
name|tail_recurse
label|:
comment|/* Skip empty subtrees.  */
if|if
condition|(
operator|!
operator|*
name|tp
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Don't walk the same tree twice, if the user has requested      that we avoid doing so.  */
if|if
condition|(
name|pset
operator|&&
name|pointer_set_insert
argument_list|(
name|pset
argument_list|,
operator|*
name|tp
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Call the function.  */
name|walk_subtrees
operator|=
literal|1
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|tp
argument_list|,
operator|&
name|walk_subtrees
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* If we found something, return it.  */
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
comment|/* Even if we didn't, FUNC may have decided that there was nothing      interesting below this point in the tree.  */
if|if
condition|(
operator|!
name|walk_subtrees
condition|)
block|{
comment|/* But we still need to check our siblings.  */
if|if
condition|(
name|code
operator|==
name|TREE_LIST
condition|)
name|WALK_SUBTREE_TAIL
argument_list|(
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|OMP_CLAUSE
condition|)
name|WALK_SUBTREE_TAIL
argument_list|(
name|OMP_CLAUSE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL_TREE
return|;
block|}
name|result
operator|=
name|lang_hooks
operator|.
name|tree_inlining
operator|.
name|walk_subtrees
argument_list|(
name|tp
argument_list|,
operator|&
name|walk_subtrees
argument_list|,
name|func
argument_list|,
name|data
argument_list|,
name|pset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|||
operator|!
name|walk_subtrees
condition|)
return|return
name|result
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ERROR_MARK
case|:
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|VECTOR_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|BLOCK
case|:
case|case
name|PLACEHOLDER_EXPR
case|:
case|case
name|SSA_NAME
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|RESULT_DECL
case|:
comment|/* None of these have subtrees other than those already walked 	 above.  */
break|break;
case|case
name|TREE_LIST
case|:
name|WALK_SUBTREE
argument_list|(
name|TREE_VALUE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE_TAIL
argument_list|(
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TREE_VEC
case|:
block|{
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
operator|*
name|tp
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
comment|/* Walk all elements but the first.  */
while|while
condition|(
operator|--
name|len
condition|)
name|WALK_SUBTREE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
operator|*
name|tp
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now walk the first one as a tail call.  */
name|WALK_SUBTREE_TAIL
argument_list|(
name|TREE_VEC_ELT
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
case|case
name|COMPLEX_CST
case|:
name|WALK_SUBTREE
argument_list|(
name|TREE_REALPART
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE_TAIL
argument_list|(
name|TREE_IMAGPART
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|CONSTRUCTOR
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|constructor_elt
modifier|*
name|ce
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|,
name|idx
argument_list|,
name|ce
argument_list|)
condition|;
name|idx
operator|++
control|)
name|WALK_SUBTREE
argument_list|(
name|ce
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SAVE_EXPR
case|:
name|WALK_SUBTREE_TAIL
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|BIND_EXPR
case|:
block|{
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|BIND_EXPR_VARS
argument_list|(
operator|*
name|tp
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
comment|/* Walk the DECL_INITIAL and DECL_SIZE.  We don't want to walk 	       into declarations that are just mentioned, rather than 	       declared; they don't really belong to this part of the tree. 	       And, we can see cycles: the initializer for a declaration 	       can refer to the declaration itself.  */
name|WALK_SUBTREE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|WALK_SUBTREE_TAIL
argument_list|(
name|BIND_EXPR_BODY
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
case|case
name|STATEMENT_LIST
case|:
block|{
name|tree_stmt_iterator
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|tsi_start
argument_list|(
operator|*
name|tp
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
name|WALK_SUBTREE
argument_list|(
operator|*
name|tsi_stmt_ptr
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OMP_CLAUSE
case|:
switch|switch
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_PRIVATE
case|:
case|case
name|OMP_CLAUSE_SHARED
case|:
case|case
name|OMP_CLAUSE_FIRSTPRIVATE
case|:
case|case
name|OMP_CLAUSE_LASTPRIVATE
case|:
case|case
name|OMP_CLAUSE_COPYIN
case|:
case|case
name|OMP_CLAUSE_COPYPRIVATE
case|:
case|case
name|OMP_CLAUSE_IF
case|:
case|case
name|OMP_CLAUSE_NUM_THREADS
case|:
case|case
name|OMP_CLAUSE_SCHEDULE
case|:
name|WALK_SUBTREE
argument_list|(
name|OMP_CLAUSE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|OMP_CLAUSE_NOWAIT
case|:
case|case
name|OMP_CLAUSE_ORDERED
case|:
case|case
name|OMP_CLAUSE_DEFAULT
case|:
name|WALK_SUBTREE_TAIL
argument_list|(
name|OMP_CLAUSE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|OMP_CLAUSE_REDUCTION
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|WALK_SUBTREE
argument_list|(
name|OMP_CLAUSE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE_TAIL
argument_list|(
name|OMP_CLAUSE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|TARGET_EXPR
case|:
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
comment|/* TARGET_EXPRs are peculiar: operands 1 and 3 can be the same. 	   But, we only want to walk once.  */
name|len
operator|=
operator|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|3
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|1
argument_list|)
operator|)
condition|?
literal|2
else|:
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|WALK_SUBTREE
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE_TAIL
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
case|case
name|DECL_EXPR
case|:
comment|/* Walk into various fields of the type that it's defining.  We only 	 want to walk into these fields of a type in this case.  Note that 	 decls get walked as part of the processing of a BIND_EXPR.  	 ??? Precisely which fields of types that we are supposed to walk in 	 this case vs. the normal case aren't well defined.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_EXPR_DECL
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_EXPR_DECL
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
block|{
name|tree
modifier|*
name|type_p
init|=
operator|&
name|TREE_TYPE
argument_list|(
name|DECL_EXPR_DECL
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Call the function for the type.  See if it returns anything or 	     doesn't want us to continue.  If we are to continue, walk both 	     the normal fields and those for the declaration case.  */
name|result
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|type_p
argument_list|,
operator|&
name|walk_subtrees
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|||
operator|!
name|walk_subtrees
condition|)
return|return
name|NULL_TREE
return|;
name|result
operator|=
name|walk_type_fields
argument_list|(
operator|*
name|type_p
argument_list|,
name|func
argument_list|,
name|data
argument_list|,
name|pset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
comment|/* If this is a record type, also walk the fields.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|type_p
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|type_p
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|type_p
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
block|{
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
operator|*
name|type_p
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
comment|/* We'd like to look at the type of the field, but we can 		     easily get infinite recursion.  So assume it's pointed 		     to elsewhere in the tree.  Also, ignore things that 		     aren't fields.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|WALK_SUBTREE
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|type_p
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
name|WALK_SUBTREE
argument_list|(
name|DECL_QUALIFIER
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|WALK_SUBTREE
argument_list|(
name|TYPE_SIZE
argument_list|(
operator|*
name|type_p
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE_TAIL
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
operator|*
name|type_p
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* FALLTHRU */
default|default:
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
comment|/* Walk over all the sub-trees of this operand.  */
name|len
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Go through the subtrees.  We need to do this in forward order so 	     that the scope of a FOR_EXPR is handled properly.  */
if|if
condition|(
name|len
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|-
literal|1
condition|;
operator|++
name|i
control|)
name|WALK_SUBTREE
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|WALK_SUBTREE_TAIL
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
name|len
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this is a type, walk the needed fields in the type.  */
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
return|return
name|walk_type_fields
argument_list|(
operator|*
name|tp
argument_list|,
name|func
argument_list|,
name|data
argument_list|,
name|pset
argument_list|)
return|;
break|break;
block|}
comment|/* We didn't find what we were looking for.  */
return|return
name|NULL_TREE
return|;
undef|#
directive|undef
name|WALK_SUBTREE_TAIL
block|}
end_function

begin_undef
undef|#
directive|undef
name|WALK_SUBTREE
end_undef

begin_comment
comment|/* Like walk_tree, but does not walk duplicate nodes more than once.  */
end_comment

begin_function
name|tree
name|walk_tree_without_duplicates
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|walk_tree_fn
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
name|struct
name|pointer_set_t
modifier|*
name|pset
decl_stmt|;
name|pset
operator|=
name|pointer_set_create
argument_list|()
expr_stmt|;
name|result
operator|=
name|walk_tree
argument_list|(
name|tp
argument_list|,
name|func
argument_list|,
name|data
argument_list|,
name|pset
argument_list|)
expr_stmt|;
name|pointer_set_destroy
argument_list|(
name|pset
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return true if STMT is an empty statement or contains nothing but    empty statements.  */
end_comment

begin_function
name|bool
name|empty_body_p
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree_stmt_iterator
name|i
decl_stmt|;
name|tree
name|body
decl_stmt|;
if|if
condition|(
name|IS_EMPTY_STMT
argument_list|(
name|stmt
argument_list|)
condition|)
return|return
name|true
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|BIND_EXPR
condition|)
name|body
operator|=
name|BIND_EXPR_BODY
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|STATEMENT_LIST
condition|)
name|body
operator|=
name|stmt
expr_stmt|;
else|else
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
name|tsi_start
argument_list|(
name|body
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
if|if
condition|(
operator|!
name|empty_body_p
argument_list|(
name|tsi_stmt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-tree.h"
end_include

end_unit

