begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Language-independent node constructors for parse phase of GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains the low level primitives for operating on tree nodes,    including allocation, list operations, interning of identifiers,    construction of data type nodes and statement nodes,    and construction of type conversion nodes.  It also contains    tables index by tree code that describe how to take apart    nodes of that code.     It is intended to be language-independent, but occasionally    calls language-dependent routines defined (for C) in typecheck.c.     The low-level allocation routines oballoc and permalloc    are used also for allocating many other kinds of objects    by all passes of the compiler.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* obstack.[ch] explicitly declined to prototype this.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|_obstack_allocated_p
name|PARAMS
argument_list|(
operator|(
expr|struct
name|obstack
operator|*
name|h
operator|,
name|PTR
name|obj
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unsave_expr_now_r
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Objects allocated on this obstack last forever.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table indexed by tree code giving a string containing a character    classifying the tree code.  Possibilities are    t, d, s, c, r,<, 1, 2 and e.  See tree.def for details.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LENGTH
parameter_list|)
value|TYPE,
end_define

begin_decl_stmt
name|char
name|tree_code_type
index|[
name|MAX_TREE_CODES
index|]
init|=
block|{
include|#
directive|include
file|"tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Table indexed by tree code giving number of expression    operands beyond the fixed part of the node structure.    Not used for types or decls.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LENGTH
parameter_list|)
value|LENGTH,
end_define

begin_decl_stmt
name|int
name|tree_code_length
index|[
name|MAX_TREE_CODES
index|]
init|=
block|{
include|#
directive|include
file|"tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Names of tree components.    Used for printing out the tree and error messages.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LEN
parameter_list|)
value|NAME,
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|tree_code_name
index|[
name|MAX_TREE_CODES
index|]
init|=
block|{
include|#
directive|include
file|"tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Statistics-gathering stuff.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|d_kind
block|,
name|t_kind
block|,
name|b_kind
block|,
name|s_kind
block|,
name|r_kind
block|,
name|e_kind
block|,
name|c_kind
block|,
name|id_kind
block|,
name|perm_list_kind
block|,
name|temp_list_kind
block|,
name|vec_kind
block|,
name|x_kind
block|,
name|lang_decl
block|,
name|lang_type
block|,
name|all_kinds
block|}
name|tree_node_kind
typedef|;
end_typedef

begin_decl_stmt
name|int
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|all_kinds
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|all_kinds
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tree_node_kind_names
index|[]
init|=
block|{
literal|"decls"
block|,
literal|"types"
block|,
literal|"blocks"
block|,
literal|"stmts"
block|,
literal|"refs"
block|,
literal|"exprs"
block|,
literal|"constants"
block|,
literal|"identifiers"
block|,
literal|"perm_tree_lists"
block|,
literal|"temp_tree_lists"
block|,
literal|"vecs"
block|,
literal|"random kinds"
block|,
literal|"lang_decl kinds"
block|,
literal|"lang_type kinds"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Unique id for next decl created.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_decl_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Unique id for next type created.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_type_uid
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Since we cannot rehash a type after it is in the table, we have to    keep the hash code.  */
end_comment

begin_struct
struct|struct
name|type_hash
block|{
name|unsigned
name|long
name|hash
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Initial size of the hash table (rounded to next prime).  */
end_comment

begin_define
define|#
directive|define
name|TYPE_HASH_INITIAL_SIZE
value|1000
end_define

begin_comment
comment|/* Now here is the hash table.  When recording a type, it is added to    the slot whose index is the hash code.  Note that the hash table is    used for several kinds of types (function types, array types and    array index range types, for now).  While all these live in the    same table, they are completely independent, and the hash code is    computed differently for each of these.  */
end_comment

begin_decl_stmt
name|htab_t
name|type_hash_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_real_from_int_cst_1
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_type_quals
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|append_random_chars
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|type_hash_eq
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|type_hash_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_type_hash_statistics
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_vector_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|make_vector
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|type_hash_marked_p
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|type_hash_mark
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mark_tree_hashtable_entry
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-null, these are language-specific helper functions for    unsave_expr_now.  If present, LANG_UNSAVE is called before its    argument (an UNSAVE_EXPR) is to be unsaved, and all other    processing in unsave_expr_now is aborted.  LANG_UNSAVE_EXPR_NOW is    called from unsave_expr_1 for language-specific tree codes.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*lang_unsave
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|void
argument_list|(
argument|*lang_unsave_expr_now
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* If non-null, these are language-specific helper functions for    unsafe_for_reeval.  Return negative to not handle some tree.  */
end_comment

begin_macro
name|int
argument_list|(
argument|*lang_unsafe_for_reeval
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Set the DECL_ASSEMBLER_NAME for a node.  If it is the sort of thing    that the assembler should talk about, set DECL_ASSEMBLER_NAME to an    appropriate IDENTIFIER_NODE.  Otherwise, set it to the    ERROR_MARK_NODE to ensure that the assembler does not talk about    it.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*lang_set_decl_assembler_name
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_escape
end_escape

begin_decl_stmt
name|tree
name|global_trees
index|[
name|TI_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|integer_types
index|[
name|itk_none
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Set the DECL_ASSEMBLER_NAME for DECL.  */
end_comment

begin_function
name|void
name|set_decl_assembler_name
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* The language-independent code should never use the      DECL_ASSEMBLER_NAME for lots of DECLs.  Only FUNCTION_DECLs and      VAR_DECLs for variables with static storage duration need a real      DECL_ASSEMBLER_NAME.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
condition|)
comment|/* By default, assume the name to use in assembly code is the        same as that used in the source language.  (That's correct        for C, and GCC used to set DECL_ASSEMBLER_NAME to the same        value as DECL_NAME in build_decl, so this choice provides        backwards compatibility with existing front-ends.  */
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Nobody should ever be asking for the DECL_ASSEMBLER_NAME of        these DECLs -- unless they're in language-dependent code, in        which case lang_set_decl_assembler_name should handle things.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Init the principal obstacks.  */
end_comment

begin_function
name|void
name|init_obstacks
parameter_list|()
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
comment|/* Initialize the hash table of types.  */
name|type_hash_table
operator|=
name|htab_create
argument_list|(
name|TYPE_HASH_INITIAL_SIZE
argument_list|,
name|type_hash_hash
argument_list|,
name|type_hash_eq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ggc_add_deletable_htab
argument_list|(
name|type_hash_table
argument_list|,
name|type_hash_marked_p
argument_list|,
name|type_hash_mark
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
name|global_trees
argument_list|,
name|TI_MAX
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
name|integer_types
argument_list|,
name|itk_none
argument_list|)
expr_stmt|;
comment|/* Set lang_set_decl_set_assembler_name to a default value.  */
name|lang_set_decl_assembler_name
operator|=
name|set_decl_assembler_name
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate SIZE bytes in the permanent obstack    and return a pointer to them.  */
end_comment

begin_function
name|char
modifier|*
name|permalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate NELEM items of SIZE bytes in the permanent obstack    and return a pointer to them.  The storage is cleared before    returning the value.  */
end_comment

begin_function
name|char
modifier|*
name|perm_calloc
parameter_list|(
name|nelem
parameter_list|,
name|size
parameter_list|)
name|int
name|nelem
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|rval
init|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|nelem
operator|*
name|size
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|rval
argument_list|,
literal|0
argument_list|,
name|nelem
operator|*
name|size
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Compute the number of bytes occupied by 'node'.  This routine only    looks at TREE_CODE and, if the code is TREE_VEC, TREE_VEC_LENGTH.  */
end_comment

begin_function
name|size_t
name|tree_size
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|node
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* A decl node */
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
return|;
case|case
literal|'t'
case|:
comment|/* a type node */
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_type
argument_list|)
return|;
case|case
literal|'b'
case|:
comment|/* a lexical block node */
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_block
argument_list|)
return|;
case|case
literal|'r'
case|:
comment|/* a reference */
case|case
literal|'e'
case|:
comment|/* an expression */
case|case
literal|'s'
case|:
comment|/* an expression with side effects */
case|case
literal|'<'
case|:
comment|/* a comparison expression */
case|case
literal|'1'
case|:
comment|/* a unary arithmetic expression */
case|case
literal|'2'
case|:
comment|/* a binary arithmetic expression */
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_exp
argument_list|)
operator|+
operator|(
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
return|;
case|case
literal|'c'
case|:
comment|/* a constant */
comment|/* We can't use TREE_CODE_LENGTH for INTEGER_CST, since the number of 	 words is machine-dependent due to varying length of HOST_WIDE_INT, 	 which might be wider than a pointer (e.g., long long).  Similarly 	 for REAL_CST, since the number of words is machine-dependent due 	 to varying size and alignment of `double'.  */
if|if
condition|(
name|code
operator|==
name|INTEGER_CST
condition|)
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_int_cst
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|REAL_CST
condition|)
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_real_cst
argument_list|)
return|;
else|else
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
operator|+
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
return|;
case|case
literal|'x'
case|:
comment|/* something random, like an identifier.  */
block|{
name|size_t
name|length
decl_stmt|;
name|length
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
operator|+
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TREE_VEC
condition|)
name|length
operator|+=
operator|(
name|TREE_VEC_LENGTH
argument_list|(
name|node
argument_list|)
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a newly allocated node of code CODE.    For decl and type nodes, some other fields are initialized.    The rest of the node is initialized to zero.     Achoo!  I got a code in the node.  */
end_comment

begin_function
name|tree
name|make_node
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|int
name|type
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|size_t
name|length
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_kind
name|kind
decl_stmt|;
endif|#
directive|endif
name|struct
name|tree_common
name|ttmp
decl_stmt|;
comment|/* We can't allocate a TREE_VEC without knowing how many elements      it will have.  */
if|if
condition|(
name|code
operator|==
name|TREE_VEC
condition|)
name|abort
argument_list|()
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
operator|(
name|tree
operator|)
operator|&
name|ttmp
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|length
operator|=
name|tree_size
argument_list|(
operator|(
name|tree
operator|)
operator|&
name|ttmp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* A decl node */
name|kind
operator|=
name|d_kind
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* a type node */
name|kind
operator|=
name|t_kind
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* a lexical block */
name|kind
operator|=
name|b_kind
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* an expression with side effects */
name|kind
operator|=
name|s_kind
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* a reference */
name|kind
operator|=
name|r_kind
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* an expression */
case|case
literal|'<'
case|:
comment|/* a comparison expression */
case|case
literal|'1'
case|:
comment|/* a unary arithmetic expression */
case|case
literal|'2'
case|:
comment|/* a binary arithmetic expression */
name|kind
operator|=
name|e_kind
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* a constant */
name|kind
operator|=
name|c_kind
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* something random, like an identifier.  */
if|if
condition|(
name|code
operator|==
name|IDENTIFIER_NODE
condition|)
name|kind
operator|=
name|id_kind
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|TREE_VEC
condition|)
name|kind
operator|=
name|vec_kind
expr_stmt|;
else|else
name|kind
operator|=
name|x_kind
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|kind
index|]
operator|++
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|kind
index|]
operator|+=
name|length
expr_stmt|;
endif|#
directive|endif
name|t
operator|=
name|ggc_alloc_tree
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|t
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'s'
case|:
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|code
operator|!=
name|FUNCTION_DECL
condition|)
name|DECL_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|t
argument_list|)
operator|=
name|in_system_header
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
operator|=
operator|(
name|input_filename
operator|)
condition|?
name|input_filename
else|:
literal|"<built-in>"
expr_stmt|;
name|DECL_UID
argument_list|(
name|t
argument_list|)
operator|=
name|next_decl_uid
operator|++
expr_stmt|;
comment|/* We have not yet computed the alias set for this declaration.  */
name|DECL_POINTER_ALIAS_SET
argument_list|(
name|t
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|TYPE_UID
argument_list|(
name|t
argument_list|)
operator|=
name|next_type_uid
operator|++
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|char_type_node
condition|?
name|TYPE_ALIGN
argument_list|(
name|char_type_node
argument_list|)
else|:
literal|0
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Default to no attributes for type, but let target change that.  */
name|TYPE_ATTRIBUTES
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|set_default_type_attributes
call|)
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* We have not yet computed the alias set for this type.  */
name|TYPE_ALIAS_SET
argument_list|(
name|t
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INIT_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|VA_ARG_EXPR
case|:
case|case
name|RTL_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
comment|/* All of these have side-effects, no matter what their 	     operands are.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* A front-end can reset this to an appropriate function if types need    special handling.  */
end_comment

begin_macro
name|tree
argument_list|(
argument|*make_lang_type_fn
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|)
argument_list|)
operator|=
name|make_node
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Return a new type (with the indicated CODE), doing whatever    language-specific processing is required.  */
end_comment

begin_function
name|tree
name|make_lang_type
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
return|return
call|(
modifier|*
name|make_lang_type_fn
call|)
argument_list|(
name|code
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a new node with the same contents as NODE except that its    TREE_CHAIN is zero and it has a fresh uid.  */
end_comment

begin_function
name|tree
name|copy_node
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|length
operator|=
name|tree_size
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|t
operator|=
name|ggc_alloc_tree
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|t
argument_list|,
name|node
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'d'
condition|)
name|DECL_UID
argument_list|(
name|t
argument_list|)
operator|=
name|next_decl_uid
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'t'
condition|)
block|{
name|TYPE_UID
argument_list|(
name|t
argument_list|)
operator|=
name|next_type_uid
operator|++
expr_stmt|;
comment|/* The following is so that the debug code for 	 the copy is different from the original type. 	 The two statements usually duplicate each other 	 (because they clear fields of the same union), 	 but the optimizer should catch that.  */
name|TYPE_SYMTAB_POINTER
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return a copy of a chain of nodes, chained through the TREE_CHAIN field.    For example, this can copy a list made of TREE_LIST nodes.  */
end_comment

begin_function
name|tree
name|copy_list
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|head
decl_stmt|;
name|tree
name|prev
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|head
operator|=
name|prev
operator|=
name|copy_node
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|copy_node
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|prev
operator|=
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
return|return
name|head
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a newly constructed INTEGER_CST node whose constant value    is specified by the two ints LOW and HI.    The TREE_TYPE is set to `int'.     This function should be used via the `build_int_2' macro.  */
end_comment

begin_function
name|tree
name|build_int_2_wide
parameter_list|(
name|low
parameter_list|,
name|hi
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|hi
decl_stmt|;
block|{
name|tree
name|t
init|=
name|make_node
argument_list|(
name|INTEGER_CST
argument_list|)
decl_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|=
name|low
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|=
name|hi
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return a new REAL_CST node whose type is TYPE and value is D.  */
end_comment

begin_function
name|tree
name|build_real
parameter_list|(
name|type
parameter_list|,
name|d
parameter_list|)
name|tree
name|type
decl_stmt|;
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
block|{
name|tree
name|v
decl_stmt|;
name|int
name|overflow
init|=
literal|0
decl_stmt|;
comment|/* Check for valid float value for this type on this target machine;      if not, can print error message and store a valid value in D.  */
ifdef|#
directive|ifdef
name|CHECK_FLOAT_VALUE
name|CHECK_FLOAT_VALUE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|d
argument_list|,
name|overflow
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|make_node
argument_list|(
name|REAL_CST
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|v
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_REAL_CST
argument_list|(
name|v
argument_list|)
operator|=
name|d
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|v
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|v
argument_list|)
operator|=
name|overflow
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Return a new REAL_CST node whose type is TYPE    and whose value is the integer value of the INTEGER_CST node I.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
end_if

begin_function
name|REAL_VALUE_TYPE
name|real_value_from_int_cst
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|)
name|tree
name|type
name|ATTRIBUTE_UNUSED
decl_stmt|,
name|i
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
comment|/* Clear all bits of the real value type so that we can later do      bitwise comparisons to see if two values are the same.  */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|d
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
name|REAL_VALUE_FROM_INT
argument_list|(
name|d
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|REAL_VALUE_FROM_UNSIGNED_INT
argument_list|(
name|d
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not REAL_ARITHMETIC */
comment|/* Some 386 compilers mishandle unsigned int to float conversions,      so introduce a temporary variable E to avoid those bugs.  */
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|i
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|e
decl_stmt|;
name|d
operator|=
call|(
name|double
call|)
argument_list|(
operator|~
name|TREE_INT_CST_HIGH
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
operator|(
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|*
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|)
expr_stmt|;
name|d
operator|*=
name|e
expr_stmt|;
name|e
operator|=
call|(
name|double
call|)
argument_list|(
operator|~
name|TREE_INT_CST_LOW
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|+=
name|e
expr_stmt|;
name|d
operator|=
operator|(
operator|-
name|d
operator|-
literal|1.0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|REAL_VALUE_TYPE
name|e
decl_stmt|;
name|d
operator|=
operator|(
name|double
operator|)
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_HIGH
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|e
operator|=
operator|(
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|*
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|)
expr_stmt|;
name|d
operator|*=
name|e
expr_stmt|;
name|e
operator|=
operator|(
name|double
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|d
operator|+=
name|e
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not REAL_ARITHMETIC */
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/* Args to pass to and from build_real_from_int_cst_1.  */
end_comment

begin_struct
struct|struct
name|brfic_args
block|{
name|tree
name|type
decl_stmt|;
comment|/* Input: type to conver to.  */
name|tree
name|i
decl_stmt|;
comment|/* Input: operand to convert.  */
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
comment|/* Output: floating point value.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Convert an integer to a floating point value while protected by a floating    point exception handler.  */
end_comment

begin_function
specifier|static
name|void
name|build_real_from_int_cst_1
parameter_list|(
name|data
parameter_list|)
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|brfic_args
modifier|*
name|args
init|=
operator|(
expr|struct
name|brfic_args
operator|*
operator|)
name|data
decl_stmt|;
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
name|args
operator|->
name|d
operator|=
name|real_value_from_int_cst
argument_list|(
name|args
operator|->
name|type
argument_list|,
name|args
operator|->
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|args
operator|->
name|d
operator|=
name|REAL_VALUE_TRUNCATE
argument_list|(
name|TYPE_MODE
argument_list|(
name|args
operator|->
name|type
argument_list|)
argument_list|,
name|real_value_from_int_cst
argument_list|(
name|args
operator|->
name|type
argument_list|,
name|args
operator|->
name|i
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Given a tree representing an integer constant I, return a tree    representing the same value as a floating-point constant of type TYPE.    We cannot perform this operation if there is no way of doing arithmetic    on floating-point values.  */
end_comment

begin_function
name|tree
name|build_real_from_int_cst
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|i
decl_stmt|;
block|{
name|tree
name|v
decl_stmt|;
name|int
name|overflow
init|=
name|TREE_OVERFLOW
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|struct
name|brfic_args
name|args
decl_stmt|;
name|v
operator|=
name|make_node
argument_list|(
name|REAL_CST
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|v
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Setup input for build_real_from_int_cst_1() */
name|args
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|args
operator|.
name|i
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|do_float_handler
argument_list|(
name|build_real_from_int_cst_1
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|args
argument_list|)
condition|)
comment|/* Receive output from build_real_from_int_cst_1() */
name|d
operator|=
name|args
operator|.
name|d
expr_stmt|;
else|else
block|{
comment|/* We got an exception from build_real_from_int_cst_1() */
name|d
operator|=
name|dconst0
expr_stmt|;
name|overflow
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check for valid float value for this type on this target machine.  */
ifdef|#
directive|ifdef
name|CHECK_FLOAT_VALUE
name|CHECK_FLOAT_VALUE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|d
argument_list|,
name|overflow
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TREE_REAL_CST
argument_list|(
name|v
argument_list|)
operator|=
name|d
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|v
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|v
argument_list|)
operator|=
name|overflow
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
end_comment

begin_comment
comment|/* Return a newly constructed STRING_CST node whose value is    the LEN characters at STR.    The TREE_TYPE is not initialized.  */
end_comment

begin_function
name|tree
name|build_string
parameter_list|(
name|len
parameter_list|,
name|str
parameter_list|)
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|tree
name|s
init|=
name|make_node
argument_list|(
name|STRING_CST
argument_list|)
decl_stmt|;
name|TREE_STRING_LENGTH
argument_list|(
name|s
argument_list|)
operator|=
name|len
expr_stmt|;
name|TREE_STRING_POINTER
argument_list|(
name|s
argument_list|)
operator|=
name|ggc_alloc_string
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Return a newly constructed COMPLEX_CST node whose value is    specified by the real and imaginary parts REAL and IMAG.    Both REAL and IMAG should be constant nodes.  TYPE, if specified,    will be the type of the COMPLEX_CST; otherwise a new type will be made.  */
end_comment

begin_function
name|tree
name|build_complex
parameter_list|(
name|type
parameter_list|,
name|real
parameter_list|,
name|imag
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|real
decl_stmt|,
name|imag
decl_stmt|;
block|{
name|tree
name|t
init|=
name|make_node
argument_list|(
name|COMPLEX_CST
argument_list|)
decl_stmt|;
name|TREE_REALPART
argument_list|(
name|t
argument_list|)
operator|=
name|real
expr_stmt|;
name|TREE_IMAGPART
argument_list|(
name|t
argument_list|)
operator|=
name|imag
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
condition|?
name|type
else|:
name|build_complex_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|real
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|real
argument_list|)
operator||
name|TREE_OVERFLOW
argument_list|(
name|imag
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|real
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|imag
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Build a newly constructed TREE_VEC node of length LEN.  */
end_comment

begin_function
name|tree
name|make_tree_vec
parameter_list|(
name|len
parameter_list|)
name|int
name|len
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|int
name|length
init|=
operator|(
name|len
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_vec
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|vec_kind
index|]
operator|++
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|vec_kind
index|]
operator|+=
name|length
expr_stmt|;
endif|#
directive|endif
name|t
operator|=
name|ggc_alloc_tree
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|t
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|TREE_VEC
argument_list|)
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
operator|=
name|len
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if EXPR is the integer constant zero or a complex constant    of zero.  */
end_comment

begin_function
name|int
name|integer_zerop
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|integer_zerop
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is the integer constant one or the corresponding    complex constant.  */
end_comment

begin_function
name|int
name|integer_onep
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
operator|==
literal|1
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|integer_onep
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is an integer containing all 1's in as much precision as    it contains.  Likewise for the corresponding complex constant.  */
end_comment

begin_function
name|int
name|integer_all_onesp
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|int
name|uns
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|integer_all_onesp
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
condition|)
return|return
literal|0
return|;
name|uns
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uns
condition|)
return|return
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
operator|==
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
operator|==
operator|-
literal|1
operator|)
return|;
comment|/* Note that using TYPE_PRECISION here is wrong.  We care about the      actual bits, not the (arbitrary) range of the type.  */
name|prec
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prec
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|HOST_WIDE_INT
name|high_value
decl_stmt|;
name|int
name|shift_amount
decl_stmt|;
name|shift_amount
operator|=
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
if|if
condition|(
name|shift_amount
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
comment|/* Can not handle precisions greater than twice the host int size.  */
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|shift_amount
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
comment|/* Shifting by the host word size is undefined according to the ANSI 	   standard, so we must handle this as a special case.  */
name|high_value
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|high_value
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|shift_amount
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
operator|==
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
operator|==
name|high_value
operator|)
return|;
block|}
else|else
return|return
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
operator|==
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|prec
operator|)
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is an integer constant that is a power of 2 (i.e., has only    one bit on).  */
end_comment

begin_function
name|int
name|integer_pow2p
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|low
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
condition|)
return|return
literal|0
return|;
name|prec
operator|=
operator|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|?
name|POINTER_SIZE
else|:
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|high
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|low
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* First clear all bits that are beyond the type's precision in case      we've been sign extended.  */
if|if
condition|(
name|prec
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|high
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
else|else
block|{
name|high
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|low
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|prec
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|high
operator|==
literal|0
operator|&&
name|low
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|high
operator|==
literal|0
operator|&&
operator|(
name|low
operator|&
operator|(
name|low
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|low
operator|==
literal|0
operator|&&
operator|(
name|high
operator|&
operator|(
name|high
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the power of two represented by a tree node known to be a    power of two.  */
end_comment

begin_function
name|int
name|tree_log2
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|low
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|tree_log2
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
name|prec
operator|=
operator|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|?
name|POINTER_SIZE
else|:
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|high
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|low
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* First clear all bits that are beyond the type's precision in case      we've been sign extended.  */
if|if
condition|(
name|prec
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|high
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
else|else
block|{
name|high
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|low
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|prec
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|high
operator|!=
literal|0
condition|?
name|HOST_BITS_PER_WIDE_INT
operator|+
name|exact_log2
argument_list|(
name|high
argument_list|)
else|:
name|exact_log2
argument_list|(
name|low
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but return the largest integer Y such that 2 ** Y is less    than or equal to EXPR.  */
end_comment

begin_function
name|int
name|tree_floor_log2
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|low
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|tree_log2
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
name|prec
operator|=
operator|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|?
name|POINTER_SIZE
else|:
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|high
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|low
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* First clear all bits that are beyond the type's precision in case      we've been sign extended.  Ignore if type's precision hasn't been set      since what we are doing is setting it.  */
if|if
condition|(
name|prec
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|||
name|prec
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|high
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
else|else
block|{
name|high
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|low
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|prec
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|high
operator|!=
literal|0
condition|?
name|HOST_BITS_PER_WIDE_INT
operator|+
name|floor_log2
argument_list|(
name|high
argument_list|)
else|:
name|floor_log2
argument_list|(
name|low
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is the real constant zero.  */
end_comment

begin_function
name|int
name|real_zerop
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|expr
argument_list|)
argument_list|,
name|dconst0
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|real_zerop
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|real_zerop
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is the real constant one in real or complex form.  */
end_comment

begin_function
name|int
name|real_onep
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|expr
argument_list|)
argument_list|,
name|dconst1
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|real_onep
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|real_zerop
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is the real constant two.  */
end_comment

begin_function
name|int
name|real_twop
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|expr
argument_list|)
argument_list|,
name|dconst2
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|real_twop
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|real_zerop
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if EXP is a constant or a cast of a constant.  */
end_comment

begin_function
name|int
name|really_constant_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
comment|/* This is not quite the same as STRIP_NOPS.  It does more.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TREE_CONSTANT
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return first list element whose TREE_VALUE is ELEM.    Return 0 if ELEM is not in LIST.  */
end_comment

begin_function
name|tree
name|value_member
parameter_list|(
name|elem
parameter_list|,
name|list
parameter_list|)
name|tree
name|elem
decl_stmt|,
name|list
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|elem
operator|==
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
condition|)
return|return
name|list
return|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return first list element whose TREE_PURPOSE is ELEM.    Return 0 if ELEM is not in LIST.  */
end_comment

begin_function
name|tree
name|purpose_member
parameter_list|(
name|elem
parameter_list|,
name|list
parameter_list|)
name|tree
name|elem
decl_stmt|,
name|list
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|elem
operator|==
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
condition|)
return|return
name|list
return|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return first list element whose BINFO_TYPE is ELEM.    Return 0 if ELEM is not in LIST.  */
end_comment

begin_function
name|tree
name|binfo_member
parameter_list|(
name|elem
parameter_list|,
name|list
parameter_list|)
name|tree
name|elem
decl_stmt|,
name|list
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|elem
operator|==
name|BINFO_TYPE
argument_list|(
name|list
argument_list|)
condition|)
return|return
name|list
return|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if ELEM is part of the chain CHAIN.  */
end_comment

begin_function
name|int
name|chain_member
parameter_list|(
name|elem
parameter_list|,
name|chain
parameter_list|)
name|tree
name|elem
decl_stmt|,
name|chain
decl_stmt|;
block|{
while|while
condition|(
name|chain
condition|)
block|{
if|if
condition|(
name|elem
operator|==
name|chain
condition|)
return|return
literal|1
return|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if ELEM is equal to TREE_VALUE (CHAIN) for any piece of    chain CHAIN.  This and the next function are currently unused, but    are retained for completeness.  */
end_comment

begin_function
name|int
name|chain_member_value
parameter_list|(
name|elem
parameter_list|,
name|chain
parameter_list|)
name|tree
name|elem
decl_stmt|,
name|chain
decl_stmt|;
block|{
while|while
condition|(
name|chain
condition|)
block|{
if|if
condition|(
name|elem
operator|==
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
condition|)
return|return
literal|1
return|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if ELEM is equal to TREE_PURPOSE (CHAIN)    for any piece of chain CHAIN.  */
end_comment

begin_function
name|int
name|chain_member_purpose
parameter_list|(
name|elem
parameter_list|,
name|chain
parameter_list|)
name|tree
name|elem
decl_stmt|,
name|chain
decl_stmt|;
block|{
while|while
condition|(
name|chain
condition|)
block|{
if|if
condition|(
name|elem
operator|==
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
condition|)
return|return
literal|1
return|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the length of a chain of nodes chained through TREE_CHAIN.    We expect a null pointer to mark the end of the chain.    This is the Lisp primitive `length'.  */
end_comment

begin_function
name|int
name|list_length
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|tail
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|t
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
name|len
operator|++
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Returns the number of FIELD_DECLs in TYPE.  */
end_comment

begin_function
name|int
name|fields_length
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
condition|)
operator|++
name|count
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Concatenate two chains of nodes (chained through TREE_CHAIN)    by modifying the last node in chain 1 to point to chain 2.    This is the Lisp primitive `nconc'.  */
end_comment

begin_function
name|tree
name|chainon
parameter_list|(
name|op1
parameter_list|,
name|op2
parameter_list|)
name|tree
name|op1
decl_stmt|,
name|op2
decl_stmt|;
block|{
if|if
condition|(
name|op1
condition|)
block|{
name|tree
name|t1
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_TREE_CHECKING
name|tree
name|t2
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|t1
operator|=
name|op1
init|;
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
control|)
empty_stmt|;
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|=
name|op2
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_TREE_CHECKING
for|for
control|(
name|t2
operator|=
name|op2
init|;
name|t2
condition|;
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
control|)
if|if
condition|(
name|t2
operator|==
name|t1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Circularity created.  */
endif|#
directive|endif
return|return
name|op1
return|;
block|}
else|else
return|return
name|op2
return|;
block|}
end_function

begin_comment
comment|/* Return the last node in a chain of nodes (chained through TREE_CHAIN).  */
end_comment

begin_function
name|tree
name|tree_last
parameter_list|(
name|chain
parameter_list|)
name|tree
name|chain
decl_stmt|;
block|{
name|tree
name|next
decl_stmt|;
if|if
condition|(
name|chain
condition|)
while|while
condition|(
operator|(
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
operator|)
condition|)
name|chain
operator|=
name|next
expr_stmt|;
return|return
name|chain
return|;
block|}
end_function

begin_comment
comment|/* Reverse the order of elements in the chain T,    and return the new head of the chain (old last element).  */
end_comment

begin_function
name|tree
name|nreverse
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|prev
init|=
literal|0
decl_stmt|,
name|decl
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|t
init|;
name|decl
condition|;
name|decl
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|decl
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Given a chain CHAIN of tree nodes,    construct and return a list of those nodes.  */
end_comment

begin_function
name|tree
name|listify
parameter_list|(
name|chain
parameter_list|)
name|tree
name|chain
decl_stmt|;
block|{
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|in_tail
init|=
name|chain
decl_stmt|;
name|tree
name|out_tail
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|in_tail
condition|)
block|{
name|tree
name|next
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|in_tail
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
if|if
condition|(
name|out_tail
condition|)
name|TREE_CHAIN
argument_list|(
name|out_tail
argument_list|)
operator|=
name|next
expr_stmt|;
else|else
name|result
operator|=
name|next
expr_stmt|;
name|out_tail
operator|=
name|next
expr_stmt|;
name|in_tail
operator|=
name|TREE_CHAIN
argument_list|(
name|in_tail
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a newly created TREE_LIST node whose    purpose and value fields are PARM and VALUE.  */
end_comment

begin_function
name|tree
name|build_tree_list
parameter_list|(
name|parm
parameter_list|,
name|value
parameter_list|)
name|tree
name|parm
decl_stmt|,
name|value
decl_stmt|;
block|{
name|tree
name|t
init|=
name|make_node
argument_list|(
name|TREE_LIST
argument_list|)
decl_stmt|;
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|=
name|parm
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|value
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return a newly created TREE_LIST node whose    purpose and value fields are PARM and VALUE    and whose TREE_CHAIN is CHAIN.  */
end_comment

begin_function
name|tree
name|tree_cons
parameter_list|(
name|purpose
parameter_list|,
name|value
parameter_list|,
name|chain
parameter_list|)
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
name|tree
name|node
decl_stmt|;
name|node
operator|=
name|ggc_alloc_tree
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_list
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|x_kind
index|]
operator|++
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|x_kind
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_list
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TREE_SET_CODE
argument_list|(
name|node
argument_list|,
name|TREE_LIST
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|node
argument_list|)
operator|=
name|chain
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|node
argument_list|)
operator|=
name|purpose
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|node
argument_list|)
operator|=
name|value
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the size nominally occupied by an object of type TYPE    when it resides in memory.  The value is measured in units of bytes,    and its data type is that normally used for type sizes    (which is the first type created by make_signed_type or    make_unsigned_type).  */
end_comment

begin_function
name|tree
name|size_in_bytes
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|integer_zero_node
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|t
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|incomplete_type_error
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|size_zero_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return the size of TYPE (in bytes) as a wide integer    or return -1 if the size can vary or is larger than an integer.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|int_size_in_bytes
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|t
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
comment|/* If the result would appear negative, it's too big to represent.  */
operator|||
operator|(
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the bit position of FIELD, in bits from the start of the record.    This is a tree of type bitsizetype.  */
end_comment

begin_function
name|tree
name|bit_position
parameter_list|(
name|field
parameter_list|)
name|tree
name|field
decl_stmt|;
block|{
return|return
name|bit_from_pos
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Likewise, but return as an integer.  Abort if it cannot be represented    in that way (since it could be a signed value, we don't have the option    of returning -1 like int_size_in_byte can.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|int_bit_position
parameter_list|(
name|field
parameter_list|)
name|tree
name|field
decl_stmt|;
block|{
return|return
name|tree_low_cst
argument_list|(
name|bit_position
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the byte position of FIELD, in bytes from the start of the record.    This is a tree of type sizetype.  */
end_comment

begin_function
name|tree
name|byte_position
parameter_list|(
name|field
parameter_list|)
name|tree
name|field
decl_stmt|;
block|{
return|return
name|byte_from_pos
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Likewise, but return as an integer.  Abort if it cannot be represented    in that way (since it could be a signed value, we don't have the option    of returning -1 like int_size_in_byte can.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|int_byte_position
parameter_list|(
name|field
parameter_list|)
name|tree
name|field
decl_stmt|;
block|{
return|return
name|tree_low_cst
argument_list|(
name|byte_position
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the strictest alignment, in bits, that T is known to have.  */
end_comment

begin_function
name|unsigned
name|int
name|expr_align
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|unsigned
name|int
name|align0
decl_stmt|,
name|align1
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
comment|/* If we have conversions, we know that the alignment of the 	 object must meet each of the alignments of the types.  */
name|align0
operator|=
name|expr_align
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|align1
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MAX
argument_list|(
name|align0
argument_list|,
name|align1
argument_list|)
return|;
case|case
name|SAVE_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|INIT_EXPR
case|:
case|case
name|TARGET_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|WITH_RECORD_EXPR
case|:
case|case
name|CLEANUP_POINT_EXPR
case|:
case|case
name|UNSAVE_EXPR
case|:
comment|/* These don't change the alignment of an object.  */
return|return
name|expr_align
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
comment|/* The best we can do is say that the alignment is the least aligned 	 of the two arms.  */
name|align0
operator|=
name|expr_align
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|align1
operator|=
name|expr_align
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MIN
argument_list|(
name|align0
argument_list|,
name|align1
argument_list|)
return|;
case|case
name|LABEL_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|DECL_ALIGN
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|DECL_ALIGN
argument_list|(
name|t
argument_list|)
return|;
break|break;
case|case
name|FUNCTION_DECL
case|:
return|return
name|FUNCTION_BOUNDARY
return|;
default|default:
break|break;
block|}
comment|/* Otherwise take the alignment from that of the type.  */
return|return
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return, as a tree node, the number of elements for TYPE (which is an    ARRAY_TYPE) minus one. This counts only elements of the top array.  */
end_comment

begin_function
name|tree
name|array_type_nelts
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|index_type
decl_stmt|,
name|min
decl_stmt|,
name|max
decl_stmt|;
comment|/* If they did it with unspecified bounds, then we should have already      given an error about it before we got here.  */
if|if
condition|(
operator|!
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|index_type
operator|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|min
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
name|max
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|integer_zerop
argument_list|(
name|min
argument_list|)
condition|?
name|max
else|:
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|max
argument_list|)
argument_list|,
name|max
argument_list|,
name|min
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if arg is static -- a reference to an object in    static storage.  This is not the same as the C meaning of `static'.  */
end_comment

begin_function
name|int
name|staticp
parameter_list|(
name|arg
parameter_list|)
name|tree
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|FUNCTION_DECL
case|:
comment|/* Nested functions aren't static, since taking their address 	 involves a trampoline.  */
return|return
operator|(
name|decl_function_context
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
operator|||
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|arg
argument_list|)
operator|)
operator|&&
operator|!
name|DECL_NON_ADDR_CONST_P
argument_list|(
name|arg
argument_list|)
return|;
case|case
name|VAR_DECL
case|:
return|return
operator|(
name|TREE_STATIC
argument_list|(
name|arg
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|arg
argument_list|)
operator|)
operator|&&
operator|!
name|DECL_NON_ADDR_CONST_P
argument_list|(
name|arg
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
return|return
name|TREE_STATIC
argument_list|(
name|arg
argument_list|)
return|;
case|case
name|LABEL_DECL
case|:
case|case
name|STRING_CST
case|:
return|return
literal|1
return|;
comment|/* If we are referencing a bitfield, we can't evaluate an 	 ADDR_EXPR at compile time and so it isn't a constant.  */
case|case
name|COMPONENT_REF
case|:
return|return
operator|(
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|staticp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|BIT_FIELD_REF
case|:
return|return
literal|0
return|;
if|#
directive|if
literal|0
comment|/* This case is technically correct, but results in setting 	  TREE_CONSTANT on ADDR_EXPRs that cannot be evaluated at 	  compile time.  */
block|case INDIRECT_REF:       return TREE_CONSTANT (TREE_OPERAND (arg, 0));
endif|#
directive|endif
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|staticp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
condition|)
return|return
call|(
modifier|*
name|lang_hooks
operator|.
name|staticp
call|)
argument_list|(
name|arg
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wrap a SAVE_EXPR around EXPR, if appropriate.    Do this to any expression which may be used in more than one place,    but must be evaluated only once.     Normally, expand_expr would reevaluate the expression each time.    Calling save_expr produces something that is evaluated and recorded    the first time expand_expr is called on it.  Subsequent calls to    expand_expr just reuse the recorded value.     The call to expand_expr that generates code that actually computes    the value is the first call *at compile time*.  Subsequent calls    *at compile time* generate code to use the saved value.    This produces correct result provided that *at run time* control    always flows through the insns made by the first expand_expr    before reaching the other places where the save_expr was evaluated.    You, the caller of save_expr, must make sure this is so.     Constants, and certain read-only nodes, are returned with no    SAVE_EXPR because that is safe.  Expressions containing placeholders    are not touched; see tree.def for an explanation of what these    are used for.  */
end_comment

begin_function
name|tree
name|save_expr
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|t
init|=
name|fold
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|inner
decl_stmt|;
comment|/* We don't care about whether this can be used as an lvalue in this      context.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we have simple operations applied to a SAVE_EXPR or to a SAVE_EXPR and      a constant, it will be more efficient to not make another SAVE_EXPR since      it will allow better simplification and GCSE will be able to merge the      computations if they actualy occur.  */
for|for
control|(
name|inner
operator|=
name|t
init|;
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
comment|/* If the tree evaluates to a constant, then we don't want to hide that      fact (i.e. this allows further folding, and direct checks for constants).      However, a read-only object that has side effects cannot be bypassed.      Since it is no problem to reevaluate literals, we just return the      literal node.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|inner
argument_list|)
operator|||
operator|(
name|TREE_READONLY
argument_list|(
name|inner
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|inner
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|SAVE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|t
return|;
comment|/* If T contains a PLACEHOLDER_EXPR, we must evaluate it each time, since      it means that the size or offset of some field of an object depends on      the value within another field.       Note that it must not be the case that T contains both a PLACEHOLDER_EXPR      and some variable since it would then need to be both evaluated once and      evaluated more than once.  Front-ends must assure this case cannot      happen by surrounding any such subexpressions in their own SAVE_EXPR      and forcing evaluation at the proper time.  */
if|if
condition|(
name|contains_placeholder_p
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
name|t
operator|=
name|build
argument_list|(
name|SAVE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|t
argument_list|,
name|current_function_decl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* This expression might be placed ahead of a jump to ensure that the      value was computed on both sides of the jump.  So make sure it isn't      eliminated as dead.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Arrange for an expression to be expanded multiple independent    times.  This is useful for cleanup actions, as the backend can    expand them multiple times in different places.  */
end_comment

begin_function
name|tree
name|unsave_expr
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
comment|/* If this is already protected, no sense in protecting it again.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|UNSAVE_EXPR
condition|)
return|return
name|expr
return|;
name|t
operator|=
name|build1
argument_list|(
name|UNSAVE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Returns the index of the first non-tree operand for CODE, or the number    of operands if all are trees.  */
end_comment

begin_function
name|int
name|first_rtl_op
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SAVE_EXPR
case|:
return|return
literal|2
return|;
case|case
name|GOTO_SUBROUTINE_EXPR
case|:
case|case
name|RTL_EXPR
case|:
return|return
literal|0
return|;
case|case
name|WITH_CLEANUP_EXPR
case|:
return|return
literal|2
return|;
case|case
name|METHOD_CALL_EXPR
case|:
return|return
literal|3
return|;
default|default:
return|return
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Perform any modifications to EXPR required when it is unsaved.  Does    not recurse into EXPR's subtrees.  */
end_comment

begin_function
name|void
name|unsave_expr_1
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|SAVE_EXPR
case|:
if|if
condition|(
operator|!
name|SAVE_EXPR_PERSISTENT_P
argument_list|(
name|expr
argument_list|)
condition|)
name|SAVE_EXPR_RTL
argument_list|(
name|expr
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TARGET_EXPR
case|:
comment|/* Don't mess with a TARGET_EXPR that hasn't been expanded.          It's OK for this to happen if it was part of a subtree that          isn't immediately expanded, such as operand 2 of another          TARGET_EXPR.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|3
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|RTL_EXPR
case|:
comment|/* I don't yet know how to emit a sequence multiple times.  */
if|if
condition|(
name|RTL_EXPR_SEQUENCE
argument_list|(
name|expr
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|lang_unsave_expr_now
operator|!=
literal|0
condition|)
call|(
modifier|*
name|lang_unsave_expr_now
call|)
argument_list|(
name|expr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Helper function for unsave_expr_now.  */
end_comment

begin_function
specifier|static
name|void
name|unsave_expr_now_r
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
comment|/* There's nothing to do for NULL_TREE.  */
if|if
condition|(
name|expr
operator|==
literal|0
condition|)
return|return;
name|unsave_expr_1
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* a constant */
case|case
literal|'t'
case|:
comment|/* a type node */
case|case
literal|'d'
case|:
comment|/* A decl node */
case|case
literal|'b'
case|:
comment|/* A block node */
break|break;
case|case
literal|'x'
case|:
comment|/* miscellaneous: e.g., identifier, TREE_LIST or ERROR_MARK.  */
if|if
condition|(
name|code
operator|==
name|TREE_LIST
condition|)
block|{
name|unsave_expr_now_r
argument_list|(
name|TREE_VALUE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|unsave_expr_now_r
argument_list|(
name|TREE_CHAIN
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'e'
case|:
comment|/* an expression */
case|case
literal|'r'
case|:
comment|/* a reference */
case|case
literal|'s'
case|:
comment|/* an expression with side effects */
case|case
literal|'<'
case|:
comment|/* a comparison expression */
case|case
literal|'2'
case|:
comment|/* a binary arithmetic expression */
case|case
literal|'1'
case|:
comment|/* a unary arithmetic expression */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|first_rtl_op
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|unsave_expr_now_r
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Modify a tree in place so that all the evaluate only once things    are cleared out.  Return the EXPR given.  */
end_comment

begin_function
name|tree
name|unsave_expr_now
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|lang_unsave
operator|!=
literal|0
condition|)
call|(
modifier|*
name|lang_unsave
call|)
argument_list|(
operator|&
name|expr
argument_list|)
expr_stmt|;
else|else
name|unsave_expr_now_r
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if it is safe to evaluate EXPR multiple times,    return 1 if it is safe if EXPR is unsaved afterward, or    return 2 if it is completely unsafe.     This assumes that CALL_EXPRs and TARGET_EXPRs are never replicated in    an expression tree, so that it safe to unsave them and the surrounding    context will be correct.     SAVE_EXPRs basically *only* appear replicated in an expression tree,    occasionally across the whole of a function.  It is therefore only    safe to unsave a SAVE_EXPR if you know that all occurrences appear    below the UNSAVE_EXPR.     RTL_EXPRs consume their rtl during evaluation.  It is therefore    never possible to unsave them.  */
end_comment

begin_function
name|int
name|unsafe_for_reeval
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|int
name|unsafeness
init|=
literal|0
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|tmp
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|int
name|first_rtl
decl_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL_TREE
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|first_rtl
operator|=
name|first_rtl_op
argument_list|(
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SAVE_EXPR
case|:
case|case
name|RTL_EXPR
case|:
return|return
literal|2
return|;
case|case
name|TREE_LIST
case|:
for|for
control|(
name|exp
operator|=
name|expr
init|;
name|exp
operator|!=
literal|0
condition|;
name|exp
operator|=
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
control|)
block|{
name|tmp
operator|=
name|unsafe_for_reeval
argument_list|(
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|unsafeness
operator|=
name|MAX
argument_list|(
name|tmp
argument_list|,
name|unsafeness
argument_list|)
expr_stmt|;
block|}
return|return
name|unsafeness
return|;
case|case
name|CALL_EXPR
case|:
name|tmp
operator|=
name|unsafe_for_reeval
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MAX
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|TARGET_EXPR
case|:
name|unsafeness
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|lang_unsafe_for_reeval
operator|!=
literal|0
condition|)
block|{
name|tmp
operator|=
call|(
modifier|*
name|lang_unsafe_for_reeval
call|)
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>=
literal|0
condition|)
return|return
name|tmp
return|;
block|}
break|break;
block|}
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* a constant */
case|case
literal|'t'
case|:
comment|/* a type node */
case|case
literal|'x'
case|:
comment|/* something random, like an identifier or an ERROR_MARK.  */
case|case
literal|'d'
case|:
comment|/* A decl node */
case|case
literal|'b'
case|:
comment|/* A block node */
return|return
literal|0
return|;
case|case
literal|'e'
case|:
comment|/* an expression */
case|case
literal|'r'
case|:
comment|/* a reference */
case|case
literal|'s'
case|:
comment|/* an expression with side effects */
case|case
literal|'<'
case|:
comment|/* a comparison expression */
case|case
literal|'2'
case|:
comment|/* a binary arithmetic expression */
case|case
literal|'1'
case|:
comment|/* a unary arithmetic expression */
for|for
control|(
name|i
operator|=
name|first_rtl
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tmp
operator|=
name|unsafe_for_reeval
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|unsafeness
operator|=
name|MAX
argument_list|(
name|tmp
argument_list|,
name|unsafeness
argument_list|)
expr_stmt|;
block|}
return|return
name|unsafeness
return|;
default|default:
return|return
literal|2
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size    or offset that depends on a field within a record.  */
end_comment

begin_function
name|int
name|contains_placeholder_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|exp
condition|)
return|return
literal|0
return|;
comment|/* If we have a WITH_RECORD_EXPR, it "cancels" any PLACEHOLDER_EXPR      in it since it is supplying a value for it.  */
name|code
operator|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|WITH_RECORD_EXPR
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PLACEHOLDER_EXPR
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'r'
case|:
comment|/* Don't look at any PLACEHOLDER_EXPRs that might be in index or bit 	 position computations since they will be converted into a 	 WITH_RECORD_EXPR involving the reference, which will assume 	 here will be valid.  */
return|return
name|contains_placeholder_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
literal|'x'
case|:
if|if
condition|(
name|code
operator|==
name|TREE_LIST
condition|)
return|return
operator|(
name|contains_placeholder_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
operator|!=
literal|0
operator|&&
name|contains_placeholder_p
argument_list|(
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
operator|)
return|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'<'
case|:
case|case
literal|'e'
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|COMPOUND_EXPR
case|:
comment|/* Ignoring the first operand isn't quite right, but works best.  */
return|return
name|contains_placeholder_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|RTL_EXPR
case|:
case|case
name|CONSTRUCTOR
case|:
return|return
literal|0
return|;
case|case
name|COND_EXPR
case|:
return|return
operator|(
name|contains_placeholder_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|contains_placeholder_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|contains_placeholder_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|SAVE_EXPR
case|:
comment|/* If we already know this doesn't have a placeholder, don't 	     check again.  */
if|if
condition|(
name|SAVE_EXPR_NOPLACEHOLDER
argument_list|(
name|exp
argument_list|)
operator|||
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|SAVE_EXPR_NOPLACEHOLDER
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|contains_placeholder_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|SAVE_EXPR_NOPLACEHOLDER
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
case|case
name|CALL_EXPR
case|:
return|return
operator|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
operator|&&
name|contains_placeholder_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
return|return
name|contains_placeholder_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
literal|2
case|:
return|return
operator|(
name|contains_placeholder_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|contains_placeholder_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXP contains any expressions that produce cleanups for an    outer scope to deal with.  Used by fold.  */
end_comment

begin_function
name|int
name|has_cleanups
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|nops
decl_stmt|,
name|cmp
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|TARGET_EXPR
case|:
case|case
name|GOTO_SUBROUTINE_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
return|return
literal|1
return|;
case|case
name|CLEANUP_POINT_EXPR
case|:
return|return
literal|0
return|;
case|case
name|CALL_EXPR
case|:
for|for
control|(
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
init|;
name|exp
condition|;
name|exp
operator|=
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
control|)
block|{
name|cmp
operator|=
name|has_cleanups
argument_list|(
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
condition|)
return|return
name|cmp
return|;
block|}
return|return
literal|0
return|;
default|default:
break|break;
block|}
comment|/* This general rule works for most tree codes.  All exceptions should be      handled above.  If this is a language-specific tree code, we can't      trust what might be in the operand, so say we don't know      the situation.  */
if|if
condition|(
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|>=
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
condition|)
return|return
operator|-
literal|1
return|;
name|nops
operator|=
name|first_rtl_op
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|type
init|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|'e'
operator|||
name|type
operator|==
literal|'<'
operator|||
name|type
operator|==
literal|'1'
operator|||
name|type
operator|==
literal|'2'
operator|||
name|type
operator|==
literal|'r'
operator|||
name|type
operator|==
literal|'s'
condition|)
block|{
name|cmp
operator|=
name|has_cleanups
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
condition|)
return|return
name|cmp
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a tree EXP, a FIELD_DECL F, and a replacement value R,    return a tree with all occurrences of references to F in a    PLACEHOLDER_EXPR replaced by R.   Note that we assume here that EXP    contains only arithmetic expressions or a CALL_EXPR with a    PLACEHOLDER_EXPR occurring only in its arglist.  */
end_comment

begin_function
name|tree
name|substitute_in_expr
parameter_list|(
name|exp
parameter_list|,
name|f
parameter_list|,
name|r
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|tree
name|f
decl_stmt|;
name|tree
name|r
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
name|tree
name|new
decl_stmt|;
name|tree
name|inner
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
return|return
name|exp
return|;
case|case
literal|'x'
case|:
if|if
condition|(
name|code
operator|==
name|PLACEHOLDER_EXPR
condition|)
return|return
name|exp
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|TREE_LIST
condition|)
block|{
name|op0
operator|=
operator|(
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|?
literal|0
else|:
name|substitute_in_expr
argument_list|(
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
operator|)
expr_stmt|;
name|op1
operator|=
name|substitute_in_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
operator|&&
name|op1
operator|==
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|exp
return|;
return|return
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'<'
case|:
case|case
literal|'e'
case|:
switch|switch
condition|(
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|op0
operator|=
name|substitute_in_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|exp
return|;
if|if
condition|(
name|code
operator|==
name|NON_LVALUE_EXPR
condition|)
return|return
name|op0
return|;
name|new
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* An RTL_EXPR cannot contain a PLACEHOLDER_EXPR; a CONSTRUCTOR 	     could, but we don't support it.  */
if|if
condition|(
name|code
operator|==
name|RTL_EXPR
condition|)
return|return
name|exp
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|CONSTRUCTOR
condition|)
name|abort
argument_list|()
expr_stmt|;
name|op0
operator|=
name|substitute_in_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|op1
operator|=
name|substitute_in_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|exp
return|;
name|new
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* It cannot be that anything inside a SAVE_EXPR contains a 	     PLACEHOLDER_EXPR.  */
if|if
condition|(
name|code
operator|==
name|SAVE_EXPR
condition|)
return|return
name|exp
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|CALL_EXPR
condition|)
block|{
name|op1
operator|=
name|substitute_in_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|exp
return|;
return|return
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|!=
name|COND_EXPR
condition|)
name|abort
argument_list|()
expr_stmt|;
name|op0
operator|=
name|substitute_in_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|op1
operator|=
name|substitute_in_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|op2
operator|=
name|substitute_in_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|&&
name|op2
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|exp
return|;
name|new
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|COMPONENT_REF
case|:
comment|/* If this expression is getting a value from a PLACEHOLDER_EXPR 	     and it is the right field, replace it with R.  */
for|for
control|(
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
init|;
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|==
literal|'r'
condition|;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|==
name|f
condition|)
return|return
name|r
return|;
comment|/* If this expression hasn't been completed let, leave it 	     alone.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
operator|==
literal|0
condition|)
return|return
name|exp
return|;
name|op0
operator|=
name|substitute_in_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|exp
return|;
name|new
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_FIELD_REF
case|:
name|op0
operator|=
name|substitute_in_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|op1
operator|=
name|substitute_in_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|op2
operator|=
name|substitute_in_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|&&
name|op2
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|exp
return|;
name|new
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDIRECT_REF
case|:
case|case
name|BUFFER_REF
case|:
name|op0
operator|=
name|substitute_in_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|f
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|exp
return|;
name|new
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|TREE_READONLY
argument_list|(
name|new
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stabilize a reference so that we can use it any number of times    without causing its operands to be evaluated more than once.    Returns the stabilized reference.  This works by means of save_expr,    so see the caveats in the comments about save_expr.     Also allows conversion expressions whose operands are references.    Any other kind of expression is returned unchanged.  */
end_comment

begin_function
name|tree
name|stabilize_reference
parameter_list|(
name|ref
parameter_list|)
name|tree
name|ref
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
comment|/* No action is needed in this case.  */
return|return
name|ref
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDIRECT_REF
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|INDIRECT_REF
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|COMPONENT_REF
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_FIELD_REF
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|BIT_FIELD_REF
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_RANGE_REF
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|ARRAY_RANGE_REF
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPOUND_EXPR
case|:
comment|/* We cannot wrap the first expression in a SAVE_EXPR, as then 	 it wouldn't be ignored.  This matters when dealing with 	 volatiles.  */
return|return
name|stabilize_reference_1
argument_list|(
name|ref
argument_list|)
return|;
case|case
name|RTL_EXPR
case|:
name|result
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|save_expr
argument_list|(
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
argument_list|,
name|ref
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* If arg isn't a kind of lvalue we recognize, make no change. 	 Caller should recognize the error for an invalid lvalue.  */
default|default:
return|return
name|ref
return|;
case|case
name|ERROR_MARK
case|:
return|return
name|error_mark_node
return|;
block|}
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of stabilize_reference; this is called for subtrees of    references.  Any expression with side-effects must be put in a SAVE_EXPR    to ensure that it is only evaluated once.     We don't put SAVE_EXPR nodes around everything, because assigning very    simple expressions to temporaries causes us to miss good opportunities    for optimizations.  Among other things, the opportunity to fold in the    addition of a constant into an addressing mode often gets lost, e.g.    "y[i+1] += x;".  In general, we take the approach that we should not make    an assignment unless we are forced into it - i.e., that any non-side effect    operator should be allowed, and that cse should take care of coalescing    multiple utterances of the same expression should that prove fruitful.  */
end_comment

begin_function
name|tree
name|stabilize_reference_1
parameter_list|(
name|e
parameter_list|)
name|tree
name|e
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
comment|/* We cannot ignore const expressions because it might be a reference      to a const array but whose index contains side-effects.  But we can      ignore things that are actual constant or that already have been      handled by this function.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|e
argument_list|)
operator|||
name|code
operator|==
name|SAVE_EXPR
condition|)
return|return
name|e
return|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'x'
case|:
case|case
literal|'t'
case|:
case|case
literal|'d'
case|:
case|case
literal|'b'
case|:
case|case
literal|'<'
case|:
case|case
literal|'s'
case|:
case|case
literal|'e'
case|:
case|case
literal|'r'
case|:
comment|/* If the expression has side-effects, then encase it in a SAVE_EXPR 	 so that it will only be evaluated once.  */
comment|/* The reference (r) and comparison (<) classes could be handled as 	 below, but it is generally faster to only evaluate them once.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|e
argument_list|)
condition|)
return|return
name|save_expr
argument_list|(
name|e
argument_list|)
return|;
return|return
name|e
return|;
case|case
literal|'c'
case|:
comment|/* Constants need no processing.  In fact, we should never reach 	 here.  */
return|return
name|e
return|;
case|case
literal|'2'
case|:
comment|/* Division is slow and tends to be compiled with jumps, 	 especially the division by powers of 2 that is often 	 found inside of an array reference.  So do it just once.  */
if|if
condition|(
name|code
operator|==
name|TRUNC_DIV_EXPR
operator|||
name|code
operator|==
name|TRUNC_MOD_EXPR
operator|||
name|code
operator|==
name|FLOOR_DIV_EXPR
operator|||
name|code
operator|==
name|FLOOR_MOD_EXPR
operator|||
name|code
operator|==
name|CEIL_DIV_EXPR
operator|||
name|code
operator|==
name|CEIL_MOD_EXPR
operator|||
name|code
operator|==
name|ROUND_DIV_EXPR
operator|||
name|code
operator|==
name|ROUND_MOD_EXPR
condition|)
return|return
name|save_expr
argument_list|(
name|e
argument_list|)
return|;
comment|/* Recursively stabilize each operand.  */
name|result
operator|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
comment|/* Recursively stabilize each operand.  */
name|result
operator|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Low-level constructors for expressions.  */
end_comment

begin_comment
comment|/* Build an expression of code CODE, data type TYPE,    and operands as specified by the arguments ARG1 and following arguments.    Expressions and reference nodes can be created this way.    Constants, decls, types and misc nodes cannot be.  */
end_comment

begin_decl_stmt
name|tree
name|build
name|VPARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
name|code
operator|,
name|tree
name|tt
operator|,
operator|...
operator|)
argument_list|)
block|{
name|tree
name|t
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|fro
decl_stmt|;
name|int
name|constant
decl_stmt|;
name|VA_OPEN
argument_list|(
name|p
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|p
argument_list|,
expr|enum
name|tree_code
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|p
argument_list|,
name|tree
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|length
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|tt
expr_stmt|;
comment|/* Below, we automatically set TREE_SIDE_EFFECTS and TREE_READONLY for the      result based on those same flags for the arguments.  But if the      arguments aren't really even `tree' expressions, we shouldn't be trying      to do this.  */
name|fro
operator|=
name|first_rtl_op
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Expressions without side effects may be constant if their      arguments are as well.  */
name|constant
operator|=
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|2
condition|)
block|{
comment|/* This is equivalent to the loop below, but faster.  */
name|tree
name|arg0
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|arg0
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|arg1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arg0
operator|&&
name|fro
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_READONLY
argument_list|(
name|arg0
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|arg0
argument_list|)
condition|)
name|constant
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|arg1
operator|&&
name|fro
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg1
argument_list|)
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_READONLY
argument_list|(
name|arg1
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|arg1
argument_list|)
condition|)
name|constant
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|length
operator|==
literal|1
condition|)
block|{
name|tree
name|arg0
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
decl_stmt|;
comment|/* The only one-operand cases we handle here are those with side-effects. 	 Others are handled with build1.  So don't bother checked if the 	 arg has side-effects since we'll already have set it.  	 ??? This really should use build1 too.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'s'
condition|)
name|abort
argument_list|()
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|arg0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|operand
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|operand
expr_stmt|;
if|if
condition|(
name|operand
operator|&&
name|fro
operator|>
name|i
condition|)
block|{
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|operand
argument_list|)
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|operand
argument_list|)
condition|)
name|constant
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|VA_CLOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
name|constant
expr_stmt|;
return|return
name|t
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Same as above, but only builds for unary operators.    Saves lions share of calls to `build'; cuts down use    of varargs, which is expensive for RISC machines.  */
end_comment

begin_function
name|tree
name|build1
parameter_list|(
name|code
parameter_list|,
name|type
parameter_list|,
name|node
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|node
decl_stmt|;
block|{
name|int
name|length
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_kind
name|kind
decl_stmt|;
endif|#
directive|endif
name|tree
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'r'
condition|)
name|kind
operator|=
name|r_kind
expr_stmt|;
else|else
name|kind
operator|=
name|e_kind
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* ENABLE_CHECKING */
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_exp
argument_list|)
expr_stmt|;
name|t
operator|=
name|ggc_alloc_tree
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|kind
index|]
operator|++
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|kind
index|]
operator|+=
name|length
expr_stmt|;
endif|#
directive|endif
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|node
operator|&&
name|first_rtl_op
argument_list|(
name|code
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INIT_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|VA_ARG_EXPR
case|:
case|case
name|RTL_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
comment|/* All of these have side-effects, no matter what their 	 operands are.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|INDIRECT_REF
case|:
comment|/* Whether a dereference is readonly has nothing to do with whether 	 its operand is readonly.  */
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
operator|&&
name|node
operator|&&
name|TREE_CONSTANT
argument_list|(
name|node
argument_list|)
condition|)
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Similar except don't specify the TREE_TYPE    and leave the TREE_SIDE_EFFECTS as 0.    It is permissible for arguments to be null,    or even garbage if their values do not matter.  */
end_comment

begin_decl_stmt
name|tree
name|build_nt
name|VPARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
name|code
operator|,
operator|...
operator|)
argument_list|)
block|{
name|tree
name|t
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VA_OPEN
argument_list|(
name|p
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|p
argument_list|,
expr|enum
name|tree_code
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|length
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Create a DECL_... node of code CODE, name NAME and data type TYPE.    We do NOT enter this node in any sort of symbol table.     layout_decl is used to set up the decl's storage layout.    Other slots are initialized to 0 or null pointers.  */
end_comment

begin_function
name|tree
name|build_decl
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|name
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/*  if (type == error_mark_node)     type = integer_type_node; */
comment|/* That is not done, deliberately, so that having error_mark_node    as the type can suppress useless errors in the use of this variable.  */
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|name
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|VAR_DECL
operator|||
name|code
operator|==
name|PARM_DECL
operator|||
name|code
operator|==
name|RESULT_DECL
condition|)
name|layout_decl
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|FUNCTION_DECL
condition|)
name|DECL_MODE
argument_list|(
name|t
argument_list|)
operator|=
name|FUNCTION_MODE
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* BLOCK nodes are used to represent the structure of binding contours    and declarations, once those contours have been exited and their contents    compiled.  This information is used for outputting debugging info.  */
end_comment

begin_function
name|tree
name|build_block
parameter_list|(
name|vars
parameter_list|,
name|tags
parameter_list|,
name|subblocks
parameter_list|,
name|supercontext
parameter_list|,
name|chain
parameter_list|)
name|tree
name|vars
decl_stmt|,
name|tags
name|ATTRIBUTE_UNUSED
decl_stmt|,
name|subblocks
decl_stmt|,
name|supercontext
decl_stmt|,
name|chain
decl_stmt|;
block|{
name|tree
name|block
init|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
decl_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|vars
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
name|subblocks
expr_stmt|;
name|BLOCK_SUPERCONTEXT
argument_list|(
name|block
argument_list|)
operator|=
name|supercontext
expr_stmt|;
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
operator|=
name|chain
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_comment
comment|/* EXPR_WITH_FILE_LOCATION are used to keep track of the exact    location where an expression or an identifier were encountered. It    is necessary for languages where the frontend parser will handle    recursively more than one file (Java is one of them).  */
end_comment

begin_function
name|tree
name|build_expr_wfl
parameter_list|(
name|node
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|col
parameter_list|)
name|tree
name|node
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|,
name|col
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
name|last_file
init|=
literal|0
decl_stmt|;
specifier|static
name|tree
name|last_filenode
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|wfl
init|=
name|make_node
argument_list|(
name|EXPR_WITH_FILE_LOCATION
argument_list|)
decl_stmt|;
name|EXPR_WFL_NODE
argument_list|(
name|wfl
argument_list|)
operator|=
name|node
expr_stmt|;
name|EXPR_WFL_SET_LINECOL
argument_list|(
name|wfl
argument_list|,
name|line
argument_list|,
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|!=
name|last_file
condition|)
block|{
name|last_file
operator|=
name|file
expr_stmt|;
name|last_filenode
operator|=
name|file
condition|?
name|get_identifier
argument_list|(
name|file
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
block|}
name|EXPR_WFL_FILENAME_NODE
argument_list|(
name|wfl
argument_list|)
operator|=
name|last_filenode
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|TREE_SIDE_EFFECTS
argument_list|(
name|wfl
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|wfl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|wfl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a declaration like DDECL except that its DECL_ATTRIBUTES    is ATTRIBUTE.  */
end_comment

begin_function
name|tree
name|build_decl_attribute_variant
parameter_list|(
name|ddecl
parameter_list|,
name|attribute
parameter_list|)
name|tree
name|ddecl
decl_stmt|,
name|attribute
decl_stmt|;
block|{
name|DECL_ATTRIBUTES
argument_list|(
name|ddecl
argument_list|)
operator|=
name|attribute
expr_stmt|;
return|return
name|ddecl
return|;
block|}
end_function

begin_comment
comment|/* Return a type like TTYPE except that its TYPE_ATTRIBUTE    is ATTRIBUTE.     Record such modified types already made so we don't make duplicates.  */
end_comment

begin_function
name|tree
name|build_type_attribute_variant
parameter_list|(
name|ttype
parameter_list|,
name|attribute
parameter_list|)
name|tree
name|ttype
decl_stmt|,
name|attribute
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|attribute_list_equal
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|ttype
argument_list|)
argument_list|,
name|attribute
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|hashcode
decl_stmt|;
name|tree
name|ntype
decl_stmt|;
name|ntype
operator|=
name|copy_node
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
name|TYPE_POINTER_TO
argument_list|(
name|ntype
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|ntype
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_ATTRIBUTES
argument_list|(
name|ntype
argument_list|)
operator|=
name|attribute
expr_stmt|;
comment|/* Create a new main variant of TYPE.  */
name|TYPE_MAIN_VARIANT
argument_list|(
name|ntype
argument_list|)
operator|=
name|ntype
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|ntype
argument_list|)
operator|=
literal|0
expr_stmt|;
name|set_type_quals
argument_list|(
name|ntype
argument_list|,
name|TYPE_UNQUALIFIED
argument_list|)
expr_stmt|;
name|hashcode
operator|=
operator|(
name|TYPE_HASH
argument_list|(
name|TREE_CODE
argument_list|(
name|ntype
argument_list|)
argument_list|)
operator|+
name|TYPE_HASH
argument_list|(
name|TREE_TYPE
argument_list|(
name|ntype
argument_list|)
argument_list|)
operator|+
name|attribute_hash_list
argument_list|(
name|attribute
argument_list|)
operator|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|ntype
argument_list|)
condition|)
block|{
case|case
name|FUNCTION_TYPE
case|:
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|ntype
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|ntype
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|ntype
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|ntype
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|ntype
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|ntype
argument_list|)
expr_stmt|;
name|ttype
operator|=
name|build_qualified_type
argument_list|(
name|ntype
argument_list|,
name|TYPE_QUALS
argument_list|(
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ttype
return|;
block|}
end_function

begin_comment
comment|/* Default value of targetm.comp_type_attributes that always returns 1.  */
end_comment

begin_function
name|int
name|default_comp_type_attributes
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|tree
name|type1
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|type2
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Default version of targetm.set_default_type_attributes that always does    nothing.  */
end_comment

begin_function
name|void
name|default_set_default_type_attributes
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Default version of targetm.insert_attributes that always does nothing.  */
end_comment

begin_function
name|void
name|default_insert_attributes
parameter_list|(
name|decl
parameter_list|,
name|attr_ptr
parameter_list|)
name|tree
name|decl
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
modifier|*
name|attr_ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Default value of targetm.attribute_table that is empty.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|default_target_attribute_table
index|[]
init|=
block|{
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default value of targetm.function_attribute_inlinable_p that always    returns false.  */
end_comment

begin_function
name|bool
name|default_function_attribute_inlinable_p
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* By default, functions with machine attributes cannot be inlined.  */
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if IDENT is a valid name for attribute ATTR,    or zero if not.     We try both `text' and `__text__', ATTR may be either one.  */
end_comment

begin_comment
comment|/* ??? It might be a reasonable simplification to require ATTR to be only    `text'.  One might then also require attribute lists to be stored in    their canonicalized form.  */
end_comment

begin_function
name|int
name|is_attribute_p
parameter_list|(
name|attr
parameter_list|,
name|ident
parameter_list|)
specifier|const
name|char
modifier|*
name|attr
decl_stmt|;
name|tree
name|ident
decl_stmt|;
block|{
name|int
name|ident_len
decl_stmt|,
name|attr_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ident
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|attr
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|ident
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|p
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|ident_len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|attr_len
operator|=
name|strlen
argument_list|(
name|attr
argument_list|)
expr_stmt|;
comment|/* If ATTR is `__text__', IDENT must be `text'; and vice versa.  */
if|if
condition|(
name|attr
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|attr
index|[
literal|1
index|]
operator|!=
literal|'_'
operator|||
name|attr
index|[
name|attr_len
operator|-
literal|2
index|]
operator|!=
literal|'_'
operator|||
name|attr
index|[
name|attr_len
operator|-
literal|1
index|]
operator|!=
literal|'_'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ident_len
operator|==
name|attr_len
operator|-
literal|4
operator|&&
name|strncmp
argument_list|(
name|attr
operator|+
literal|2
argument_list|,
name|p
argument_list|,
name|attr_len
operator|-
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|ident_len
operator|==
name|attr_len
operator|+
literal|4
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
name|ident_len
operator|-
literal|2
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
name|ident_len
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|strncmp
argument_list|(
name|attr
argument_list|,
name|p
operator|+
literal|2
argument_list|,
name|attr_len
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given an attribute name and a list of attributes, return a pointer to the    attribute's list element if the attribute is part of the list, or NULL_TREE    if not found.  If the attribute appears more than once, this only    returns the first occurrence; the TREE_CHAIN of the return value should    be passed back in if further occurrences are wanted.  */
end_comment

begin_function
name|tree
name|lookup_attribute
parameter_list|(
name|attr_name
parameter_list|,
name|list
parameter_list|)
specifier|const
name|char
modifier|*
name|attr_name
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|list
init|;
name|l
condition|;
name|l
operator|=
name|TREE_CHAIN
argument_list|(
name|l
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|l
argument_list|)
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_attribute_p
argument_list|(
name|attr_name
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|l
argument_list|)
argument_list|)
condition|)
return|return
name|l
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return an attribute list that is the union of a1 and a2.  */
end_comment

begin_function
name|tree
name|merge_attributes
parameter_list|(
name|a1
parameter_list|,
name|a2
parameter_list|)
name|tree
name|a1
decl_stmt|,
name|a2
decl_stmt|;
block|{
name|tree
name|attributes
decl_stmt|;
comment|/* Either one unset?  Take the set one.  */
if|if
condition|(
operator|(
name|attributes
operator|=
name|a1
operator|)
operator|==
literal|0
condition|)
name|attributes
operator|=
name|a2
expr_stmt|;
comment|/* One that completely contains the other?  Take it.  */
elseif|else
if|if
condition|(
name|a2
operator|!=
literal|0
operator|&&
operator|!
name|attribute_list_contained
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
condition|)
block|{
if|if
condition|(
name|attribute_list_contained
argument_list|(
name|a2
argument_list|,
name|a1
argument_list|)
condition|)
name|attributes
operator|=
name|a2
expr_stmt|;
else|else
block|{
comment|/* Pick the longest list, and hang on the other list.  */
if|if
condition|(
name|list_length
argument_list|(
name|a1
argument_list|)
operator|<
name|list_length
argument_list|(
name|a2
argument_list|)
condition|)
name|attributes
operator|=
name|a2
operator|,
name|a2
operator|=
name|a1
expr_stmt|;
for|for
control|(
init|;
name|a2
operator|!=
literal|0
condition|;
name|a2
operator|=
name|TREE_CHAIN
argument_list|(
name|a2
argument_list|)
control|)
block|{
name|tree
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
name|lookup_attribute
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|a2
argument_list|)
argument_list|)
argument_list|,
name|attributes
argument_list|)
init|;
name|a
operator|!=
name|NULL_TREE
condition|;
name|a
operator|=
name|lookup_attribute
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|a2
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|a2
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|a
operator|==
name|NULL_TREE
condition|)
block|{
name|a1
operator|=
name|copy_node
argument_list|(
name|a2
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|a1
argument_list|)
operator|=
name|attributes
expr_stmt|;
name|attributes
operator|=
name|a1
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|attributes
return|;
block|}
end_function

begin_comment
comment|/* Given types T1 and T2, merge their attributes and return   the result.  */
end_comment

begin_function
name|tree
name|merge_type_attributes
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
return|return
name|merge_attributes
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given decls OLDDECL and NEWDECL, merge their attributes and return    the result.  */
end_comment

begin_function
name|tree
name|merge_decl_attributes
parameter_list|(
name|olddecl
parameter_list|,
name|newdecl
parameter_list|)
name|tree
name|olddecl
decl_stmt|,
name|newdecl
decl_stmt|;
block|{
return|return
name|merge_attributes
argument_list|(
name|DECL_ATTRIBUTES
argument_list|(
name|olddecl
argument_list|)
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_DLLIMPORT_DECL_ATTRIBUTES
end_ifdef

begin_comment
comment|/* Specialization of merge_decl_attributes for various Windows targets.     This handles the following situation:       __declspec (dllimport) int foo;      int foo;     The second instance of `foo' nullifies the dllimport.  */
end_comment

begin_function
name|tree
name|merge_dllimport_decl_attributes
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|)
name|tree
name|old
decl_stmt|;
name|tree
name|new
decl_stmt|;
block|{
name|tree
name|a
decl_stmt|;
name|int
name|delete_dllimport_p
decl_stmt|;
name|old
operator|=
name|DECL_ATTRIBUTES
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|new
operator|=
name|DECL_ATTRIBUTES
argument_list|(
name|new
argument_list|)
expr_stmt|;
comment|/* What we need to do here is remove from `old' dllimport if it doesn't      appear in `new'.  dllimport behaves like extern: if a declaration is      marked dllimport and a definition appears later, then the object      is not dllimport'd.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"dllimport"
argument_list|,
name|old
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|lookup_attribute
argument_list|(
literal|"dllimport"
argument_list|,
name|new
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|delete_dllimport_p
operator|=
literal|1
expr_stmt|;
else|else
name|delete_dllimport_p
operator|=
literal|0
expr_stmt|;
name|a
operator|=
name|merge_attributes
argument_list|(
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_dllimport_p
condition|)
block|{
name|tree
name|prev
decl_stmt|,
name|t
decl_stmt|;
comment|/* Scan the list for dllimport and delete it.  */
for|for
control|(
name|prev
operator|=
name|NULL_TREE
operator|,
name|t
operator|=
name|a
init|;
name|t
condition|;
name|prev
operator|=
name|t
operator|,
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"dllimport"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev
operator|==
name|NULL_TREE
condition|)
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|a
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_DLLIMPORT_DECL_ATTRIBUTES  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Set the type qualifiers for TYPE to TYPE_QUALS, which is a bitmask    of the various TYPE_QUAL values.  */
end_comment

begin_function
specifier|static
name|void
name|set_type_quals
parameter_list|(
name|type
parameter_list|,
name|type_quals
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|type_quals
decl_stmt|;
block|{
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_CONST
operator|)
operator|!=
literal|0
expr_stmt|;
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_VOLATILE
operator|)
operator|!=
literal|0
expr_stmt|;
name|TYPE_RESTRICT
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_RESTRICT
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a version of the TYPE, qualified as indicated by the    TYPE_QUALS, if one exists.  If no qualified version exists yet,    return NULL_TREE.  */
end_comment

begin_function
name|tree
name|get_qualified_type
parameter_list|(
name|type
parameter_list|,
name|type_quals
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|type_quals
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
comment|/* Search the chain of variants to see if there is already one there just      like the one we need to have.  If so, use that existing one.  We must      preserve the TYPE_NAME, since there is code that depends on this.  */
for|for
control|(
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|t
argument_list|)
operator|==
name|type_quals
operator|&&
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|t
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Like get_qualified_type, but creates the type if it does not    exist.  This function never returns NULL_TREE.  */
end_comment

begin_function
name|tree
name|build_qualified_type
parameter_list|(
name|type
parameter_list|,
name|type_quals
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|type_quals
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
comment|/* See if we already have the appropriate qualified variant.  */
name|t
operator|=
name|get_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
comment|/* If not, build it.  */
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|t
operator|=
name|build_type_copy
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|set_type_quals
argument_list|(
name|t
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Create a new variant of TYPE, equivalent but distinct.    This is so the caller can modify it.  */
end_comment

begin_function
name|tree
name|build_type_copy
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|,
name|m
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_POINTER_TO
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Add this type to the chain of variants of TYPE.  */
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
operator|=
name|t
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hashing of types so that we don't make duplicates.    The entry point is `type_hash_canon'.  */
end_comment

begin_comment
comment|/* Compute a hash code for a list of types (chain of TREE_LIST nodes    with types in the TREE_VALUE slots), by adding the hash codes    of the individual types.  */
end_comment

begin_function
name|unsigned
name|int
name|type_hash_list
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
name|unsigned
name|int
name|hashcode
decl_stmt|;
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|hashcode
operator|=
literal|0
operator|,
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|hashcode
return|;
block|}
end_function

begin_comment
comment|/* These are the Hashtable callback functions.  */
end_comment

begin_comment
comment|/* Returns true if the types are equal.  */
end_comment

begin_function
specifier|static
name|int
name|type_hash_eq
parameter_list|(
name|va
parameter_list|,
name|vb
parameter_list|)
specifier|const
name|void
modifier|*
name|va
decl_stmt|;
specifier|const
name|void
modifier|*
name|vb
decl_stmt|;
block|{
specifier|const
name|struct
name|type_hash
modifier|*
name|a
init|=
name|va
decl_stmt|,
modifier|*
name|b
init|=
name|vb
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|hash
operator|==
name|b
operator|->
name|hash
operator|&&
name|TREE_CODE
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|&&
name|attribute_list_equal
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|a
operator|->
name|type
argument_list|)
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|b
operator|->
name|type
argument_list|)
argument_list|)
operator|&&
name|TYPE_ALIGN
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|==
name|TYPE_ALIGN
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|&&
operator|(
name|TYPE_MAX_VALUE
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|==
name|TYPE_MAX_VALUE
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|||
name|tree_int_cst_equal
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|a
operator|->
name|type
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|b
operator|->
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_MIN_VALUE
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|==
name|TYPE_MIN_VALUE
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|||
name|tree_int_cst_equal
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|a
operator|->
name|type
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|b
operator|->
name|type
argument_list|)
argument_list|)
operator|)
comment|/* Note that TYPE_DOMAIN is TYPE_ARG_TYPES for FUNCTION_TYPE.  */
operator|&&
operator|(
name|TYPE_DOMAIN
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|==
name|TYPE_DOMAIN
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|||
operator|(
name|TYPE_DOMAIN
argument_list|(
name|a
operator|->
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|a
operator|->
name|type
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|b
operator|->
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|b
operator|->
name|type
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|type_list_equal
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|a
operator|->
name|type
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|b
operator|->
name|type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the cached hash value.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|type_hash_hash
parameter_list|(
name|item
parameter_list|)
specifier|const
name|void
modifier|*
name|item
decl_stmt|;
block|{
return|return
operator|(
operator|(
specifier|const
expr|struct
name|type_hash
operator|*
operator|)
name|item
operator|)
operator|->
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Look in the type hash table for a type isomorphic to TYPE.    If one is found, return it.  Otherwise return 0.  */
end_comment

begin_function
name|tree
name|type_hash_lookup
parameter_list|(
name|hashcode
parameter_list|,
name|type
parameter_list|)
name|unsigned
name|int
name|hashcode
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|struct
name|type_hash
modifier|*
name|h
decl_stmt|,
name|in
decl_stmt|;
comment|/* The TYPE_ALIGN field of a type is set by layout_type(), so we      must call that routine before comparing TYPE_ALIGNs.  */
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|in
operator|.
name|hash
operator|=
name|hashcode
expr_stmt|;
name|in
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|h
operator|=
name|htab_find_with_hash
argument_list|(
name|type_hash_table
argument_list|,
operator|&
name|in
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
return|return
name|h
operator|->
name|type
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Add an entry to the type-hash-table    for a type TYPE whose hash code is HASHCODE.  */
end_comment

begin_function
name|void
name|type_hash_add
parameter_list|(
name|hashcode
parameter_list|,
name|type
parameter_list|)
name|unsigned
name|int
name|hashcode
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|struct
name|type_hash
modifier|*
name|h
decl_stmt|;
name|void
modifier|*
modifier|*
name|loc
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|type_hash
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type_hash
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|hash
operator|=
name|hashcode
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|loc
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|type_hash_table
argument_list|,
name|h
argument_list|,
name|hashcode
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|type_hash
operator|*
operator|*
operator|)
name|loc
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given TYPE, and HASHCODE its hash code, return the canonical    object for an identical type if one already exists.    Otherwise, return TYPE, and record it as the canonical object    if it is a permanent object.     To use this function, first create a type of the sort you want.    Then compute its hash code from the fields of the type that    make it different from other similar types.    Then call this function and use the value.    This function frees the type you pass in if it is a duplicate.  */
end_comment

begin_comment
comment|/* Set to 1 to debug without canonicalization.  Never set by program.  */
end_comment

begin_decl_stmt
name|int
name|debug_no_type_hash
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|type_hash_canon
parameter_list|(
name|hashcode
parameter_list|,
name|type
parameter_list|)
name|unsigned
name|int
name|hashcode
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t1
decl_stmt|;
if|if
condition|(
name|debug_no_type_hash
condition|)
return|return
name|type
return|;
comment|/* See if the type is in the hash table already.  If so, return it.      Otherwise, add the type.  */
name|t1
operator|=
name|type_hash_lookup
argument_list|(
name|hashcode
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|t_kind
index|]
operator|--
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|t_kind
index|]
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|t1
return|;
block|}
else|else
block|{
name|type_hash_add
argument_list|(
name|hashcode
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
block|}
end_function

begin_comment
comment|/* See if the data pointed to by the type hash table is marked.  We consider    it marked if the type is marked or if a debug type number or symbol    table entry has been made for the type.  This reduces the amount of    debugging output and eliminates that dependency of the debug output on    the number of garbage collections.  */
end_comment

begin_function
specifier|static
name|int
name|type_hash_marked_p
parameter_list|(
name|p
parameter_list|)
specifier|const
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|tree
name|type
init|=
operator|(
operator|(
expr|struct
name|type_hash
operator|*
operator|)
name|p
operator|)
operator|->
name|type
decl_stmt|;
return|return
name|ggc_marked_p
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_SYMTAB_POINTER
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Mark the entry in the type hash table the type it points to is marked.    Also mark the type in case we are considering this entry "marked" by    virtue of TYPE_SYMTAB_POINTER being set.  */
end_comment

begin_function
specifier|static
name|void
name|type_hash_mark
parameter_list|(
name|p
parameter_list|)
specifier|const
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|ggc_mark
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
operator|(
operator|(
expr|struct
name|type_hash
operator|*
operator|)
name|p
operator|)
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark the hashtable slot pointed to by ENTRY (which is really a    `tree**') for GC.  */
end_comment

begin_function
specifier|static
name|int
name|mark_tree_hashtable_entry
parameter_list|(
name|entry
parameter_list|,
name|data
parameter_list|)
name|void
modifier|*
modifier|*
name|entry
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|ggc_mark_tree
argument_list|(
operator|(
name|tree
operator|)
operator|*
name|entry
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Mark ARG (which is really a htab_t whose slots are trees) for     GC.  */
end_comment

begin_function
name|void
name|mark_tree_hashtable
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|htab_t
name|t
init|=
operator|*
operator|(
name|htab_t
operator|*
operator|)
name|arg
decl_stmt|;
name|htab_traverse
argument_list|(
name|t
argument_list|,
name|mark_tree_hashtable_entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_type_hash_statistics
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Type hash: size %ld, %ld elements, %f collisions\n"
argument_list|,
operator|(
name|long
operator|)
name|htab_size
argument_list|(
name|type_hash_table
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|htab_elements
argument_list|(
name|type_hash_table
argument_list|)
argument_list|,
name|htab_collisions
argument_list|(
name|type_hash_table
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute a hash code for a list of attributes (chain of TREE_LIST nodes    with names in the TREE_PURPOSE slots and args in the TREE_VALUE slots),    by adding the hash codes of the individual attributes.  */
end_comment

begin_function
name|unsigned
name|int
name|attribute_hash_list
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
name|unsigned
name|int
name|hashcode
decl_stmt|;
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|hashcode
operator|=
literal|0
operator|,
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
comment|/* ??? Do we want to add in TREE_VALUE too? */
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|hashcode
return|;
block|}
end_function

begin_comment
comment|/* Given two lists of attributes, return true if list l2 is    equivalent to l1.  */
end_comment

begin_function
name|int
name|attribute_list_equal
parameter_list|(
name|l1
parameter_list|,
name|l2
parameter_list|)
name|tree
name|l1
decl_stmt|,
name|l2
decl_stmt|;
block|{
return|return
name|attribute_list_contained
argument_list|(
name|l1
argument_list|,
name|l2
argument_list|)
operator|&&
name|attribute_list_contained
argument_list|(
name|l2
argument_list|,
name|l1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given two lists of attributes, return true if list L2 is    completely contained within L1.  */
end_comment

begin_comment
comment|/* ??? This would be faster if attribute names were stored in a canonicalized    form.  Otherwise, if L1 uses `foo' and L2 uses `__foo__', the long method    must be used to show these elements are equivalent (which they are).  */
end_comment

begin_comment
comment|/* ??? It's not clear that attributes with arguments will always be handled    correctly.  */
end_comment

begin_function
name|int
name|attribute_list_contained
parameter_list|(
name|l1
parameter_list|,
name|l2
parameter_list|)
name|tree
name|l1
decl_stmt|,
name|l2
decl_stmt|;
block|{
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
comment|/* First check the obvious, maybe the lists are identical.  */
if|if
condition|(
name|l1
operator|==
name|l2
condition|)
return|return
literal|1
return|;
comment|/* Maybe the lists are similar.  */
for|for
control|(
name|t1
operator|=
name|l1
operator|,
name|t2
operator|=
name|l2
init|;
name|t1
operator|!=
literal|0
operator|&&
name|t2
operator|!=
literal|0
operator|&&
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
operator|&&
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|,
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
control|)
empty_stmt|;
comment|/* Maybe the lists are equal.  */
if|if
condition|(
name|t1
operator|==
literal|0
operator|&&
name|t2
operator|==
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
init|;
name|t2
operator|!=
literal|0
condition|;
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
control|)
block|{
name|tree
name|attr
decl_stmt|;
for|for
control|(
name|attr
operator|=
name|lookup_attribute
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|,
name|l1
argument_list|)
init|;
name|attr
operator|!=
name|NULL_TREE
condition|;
name|attr
operator|=
name|lookup_attribute
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|attr
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|attr
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|attr
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|attr
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given two lists of types    (chains of TREE_LIST nodes with types in the TREE_VALUE slots)    return 1 if the lists contain the same types in the same order.    Also, the TREE_PURPOSEs must match.  */
end_comment

begin_function
name|int
name|type_list_equal
parameter_list|(
name|l1
parameter_list|,
name|l2
parameter_list|)
name|tree
name|l1
decl_stmt|,
name|l2
decl_stmt|;
block|{
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
for|for
control|(
name|t1
operator|=
name|l1
operator|,
name|t2
operator|=
name|l2
init|;
name|t1
operator|&&
name|t2
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|,
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
operator|||
operator|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
operator|(
literal|1
operator|==
name|simple_cst_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|t1
operator|==
name|t2
return|;
block|}
end_function

begin_comment
comment|/* Returns the number of arguments to the FUNCTION_TYPE or METHOD_TYPE    given by TYPE.  If the argument list accepts variable arguments,    then this function counts only the ordinary arguments.  */
end_comment

begin_function
name|int
name|type_num_arguments
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
comment|/* If the function does not take a variable number of arguments,        the last element in the list will have type `void'.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
break|break;
else|else
operator|++
name|i
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if integer constants T1 and T2    represent the same constant value.  */
end_comment

begin_function
name|int
name|tree_int_cst_equal
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|t1
operator|==
literal|0
operator|||
name|t2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|t2
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if integer constants T1 and T2 represent values that satisfy<.    The precise way of comparison depends on their data type.  */
end_comment

begin_function
name|int
name|tree_int_cst_lt
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
condition|)
return|return
name|INT_CST_LT
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
return|;
return|return
name|INT_CST_LT_UNSIGNED
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns -1 if T1< T2, 0 if T1 == T2, and 1 if T1> T2.  */
end_comment

begin_function
name|int
name|tree_int_cst_compare
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|;
name|tree
name|t2
decl_stmt|;
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if T is an INTEGER_CST that can be represented in a single    HOST_WIDE_INT value.  If POS is nonzero, the result must be positive.  */
end_comment

begin_function
name|int
name|host_integerp
parameter_list|(
name|t
parameter_list|,
name|pos
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|pos
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|>=
literal|0
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|!
name|pos
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the HOST_WIDE_INT least significant bits of T if it is an    INTEGER_CST and there is no overflow.  POS is nonzero if the result must    be positive.  Abort if we cannot satisfy the above conditions.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|tree_low_cst
parameter_list|(
name|t
parameter_list|,
name|pos
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|pos
decl_stmt|;
block|{
if|if
condition|(
name|host_integerp
argument_list|(
name|t
argument_list|,
name|pos
argument_list|)
condition|)
return|return
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the most significant bit of the integer constant T.  */
end_comment

begin_function
name|int
name|tree_int_cst_msb
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|HOST_WIDE_INT
name|h
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|l
decl_stmt|;
comment|/* Note that using TYPE_PRECISION here is wrong.  We care about the      actual bits, not the (arbitrary) range of the type.  */
name|prec
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|rshift_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
argument_list|,
name|prec
argument_list|,
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|l
operator|&
literal|1
operator|)
operator|==
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return an indication of the sign of the integer constant T.    The return value is -1 if T< 0, 0 if T == 0, and 1 if T> 0.    Note that -1 will never be returned it T's type is unsigned.  */
end_comment

begin_function
name|int
name|tree_int_cst_sgn
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Compare two constructor-element-type constants.  Return 1 if the lists    are known to be equal; otherwise return 0.  */
end_comment

begin_function
name|int
name|simple_cst_list_equal
parameter_list|(
name|l1
parameter_list|,
name|l2
parameter_list|)
name|tree
name|l1
decl_stmt|,
name|l2
decl_stmt|;
block|{
while|while
condition|(
name|l1
operator|!=
name|NULL_TREE
operator|&&
name|l2
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|l1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|l2
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
name|l1
operator|=
name|TREE_CHAIN
argument_list|(
name|l1
argument_list|)
expr_stmt|;
name|l2
operator|=
name|TREE_CHAIN
argument_list|(
name|l2
argument_list|)
expr_stmt|;
block|}
return|return
name|l1
operator|==
name|l2
return|;
block|}
end_function

begin_comment
comment|/* Return truthvalue of whether T1 is the same tree structure as T2.    Return 1 if they are the same.    Return 0 if they are understandably different.    Return -1 if either contains tree structure not understood by    this function.  */
end_comment

begin_function
name|int
name|simple_cst_equal
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
name|enum
name|tree_code
name|code1
decl_stmt|,
name|code2
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|t1
operator|==
literal|0
operator|||
name|t2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|NOP_EXPR
operator|||
name|code1
operator|==
name|CONVERT_EXPR
operator|||
name|code1
operator|==
name|NON_LVALUE_EXPR
condition|)
block|{
if|if
condition|(
name|code2
operator|==
name|NOP_EXPR
operator|||
name|code2
operator|==
name|CONVERT_EXPR
operator|||
name|code2
operator|==
name|NON_LVALUE_EXPR
condition|)
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
else|else
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|t2
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code2
operator|==
name|NOP_EXPR
operator|||
name|code2
operator|==
name|CONVERT_EXPR
operator|||
name|code2
operator|==
name|NON_LVALUE_EXPR
condition|)
return|return
name|simple_cst_equal
argument_list|(
name|t1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code1
operator|!=
name|code2
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code1
condition|)
block|{
case|case
name|INTEGER_CST
case|:
return|return
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|t2
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|t2
argument_list|)
operator|)
return|;
case|case
name|REAL_CST
case|:
return|return
name|REAL_VALUES_IDENTICAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
case|case
name|STRING_CST
case|:
return|return
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_STRING_LENGTH
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|t1
argument_list|)
operator|==
name|CONSTRUCTOR_ELTS
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
case|case
name|SAVE_EXPR
case|:
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
name|cmp
operator|=
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|simple_cst_list_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|TARGET_EXPR
case|:
comment|/* Special case: if either target is an unallocated VAR_DECL, 	 it means that it's going to be unified with whatever the 	 TARGET_EXPR is really supposed to initialize, so treat it 	 as being equivalent to anything.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|cmp
operator|=
literal|1
expr_stmt|;
else|else
name|cmp
operator|=
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|WITH_CLEANUP_EXPR
case|:
name|cmp
operator|=
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
comment|/* This general rule works for most tree codes.  All exceptions should be      handled above.  If this is a language-specific tree code, we can't      trust what might be in the operand, so say we don't know      the situation.  */
if|if
condition|(
operator|(
name|int
operator|)
name|code1
operator|>=
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code1
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'<'
case|:
case|case
literal|'e'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
name|cmp
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_CODE_LENGTH
argument_list|(
name|code1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|cmp
operator|=
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
name|i
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
block|}
return|return
name|cmp
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Compare the value of T, an INTEGER_CST, with U, an unsigned integer value.    Return -1, 0, or 1 if the value of T is less than, equal to, or greater    than U, respectively.  */
end_comment

begin_function
name|int
name|compare_tree_int
parameter_list|(
name|t
parameter_list|,
name|u
parameter_list|)
name|tree
name|t
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|u
decl_stmt|;
block|{
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|t
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|==
name|u
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|<
name|u
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Constructors for pointer, array and function types.    (RECORD_TYPE, UNION_TYPE and ENUMERAL_TYPE nodes are    constructed by language-dependent code, not here.)  */
end_comment

begin_comment
comment|/* Construct, lay out and return the type of pointers to TO_TYPE.    If such a type has already been constructed, reuse it.  */
end_comment

begin_function
name|tree
name|build_pointer_type
parameter_list|(
name|to_type
parameter_list|)
name|tree
name|to_type
decl_stmt|;
block|{
name|tree
name|t
init|=
name|TYPE_POINTER_TO
argument_list|(
name|to_type
argument_list|)
decl_stmt|;
comment|/* First, if we already have a type for pointers to TO_TYPE, use it.  */
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
comment|/* We need a new one.  */
name|t
operator|=
name|make_node
argument_list|(
name|POINTER_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|to_type
expr_stmt|;
comment|/* Record this type as the pointer to TO_TYPE.  */
name|TYPE_POINTER_TO
argument_list|(
name|to_type
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Lay out the type.  This function has many callers that are concerned      with expression-construction, and this simplifies them all.      Also, it guarantees the TYPE_SIZE is in the same obstack as the type.  */
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Build the node for the type of references-to-TO_TYPE.  */
end_comment

begin_function
name|tree
name|build_reference_type
parameter_list|(
name|to_type
parameter_list|)
name|tree
name|to_type
decl_stmt|;
block|{
name|tree
name|t
init|=
name|TYPE_REFERENCE_TO
argument_list|(
name|to_type
argument_list|)
decl_stmt|;
comment|/* First, if we already have a type for pointers to TO_TYPE, use it.  */
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
comment|/* We need a new one.  */
name|t
operator|=
name|make_node
argument_list|(
name|REFERENCE_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|to_type
expr_stmt|;
comment|/* Record this type as the pointer to TO_TYPE.  */
name|TYPE_REFERENCE_TO
argument_list|(
name|to_type
argument_list|)
operator|=
name|t
expr_stmt|;
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Build a type that is compatible with t but has no cv quals anywhere    in its type, thus     const char *const *const *  ->  char ***.  */
end_comment

begin_function
name|tree
name|build_type_no_quals
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
return|return
name|build_pointer_type
argument_list|(
name|build_type_no_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|REFERENCE_TYPE
case|:
return|return
name|build_reference_type
argument_list|(
name|build_type_no_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Create a type of integers to be the TYPE_DOMAIN of an ARRAY_TYPE.    MAXVAL should be the maximum value in the domain    (one less than the length of the array).     The maximum value that MAXVAL can have is INT_MAX for a HOST_WIDE_INT.    We don't enforce this limit, that is up to caller (e.g. language front end).    The limit exists because the result is a signed type and we don't handle    sizes that use more than one HOST_WIDE_INT.  */
end_comment

begin_function
name|tree
name|build_index_type
parameter_list|(
name|maxval
parameter_list|)
name|tree
name|maxval
decl_stmt|;
block|{
name|tree
name|itype
init|=
name|make_node
argument_list|(
name|INTEGER_TYPE
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|itype
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|itype
argument_list|)
operator|=
name|size_zero_node
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|itype
argument_list|)
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|maxval
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|type_hash_canon
argument_list|(
name|tree_low_cst
argument_list|(
name|maxval
argument_list|,
literal|1
argument_list|)
argument_list|,
name|itype
argument_list|)
return|;
else|else
return|return
name|itype
return|;
block|}
end_function

begin_comment
comment|/* Builds a signed or unsigned integer type of precision PRECISION.    Used for C bitfields whose precision does not match that of    built-in target types.  */
end_comment

begin_function
name|tree
name|build_nonstandard_integer_type
parameter_list|(
name|precision
parameter_list|,
name|unsignedp
parameter_list|)
name|unsigned
name|int
name|precision
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|tree
name|itype
init|=
name|make_node
argument_list|(
name|INTEGER_TYPE
argument_list|)
decl_stmt|;
name|TYPE_PRECISION
argument_list|(
name|itype
argument_list|)
operator|=
name|precision
expr_stmt|;
if|if
condition|(
name|unsignedp
condition|)
name|fixup_unsigned_type
argument_list|(
name|itype
argument_list|)
expr_stmt|;
else|else
name|fixup_signed_type
argument_list|(
name|itype
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|itype
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|type_hash_canon
argument_list|(
name|tree_low_cst
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|itype
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|itype
argument_list|)
return|;
return|return
name|itype
return|;
block|}
end_function

begin_comment
comment|/* Create a range of some discrete type TYPE (an INTEGER_TYPE,    ENUMERAL_TYPE, BOOLEAN_TYPE, or CHAR_TYPE), with    low bound LOWVAL and high bound HIGHVAL.    if TYPE==NULL_TREE, sizetype is used.  */
end_comment

begin_function
name|tree
name|build_range_type
parameter_list|(
name|type
parameter_list|,
name|lowval
parameter_list|,
name|highval
parameter_list|)
name|tree
name|type
decl_stmt|,
name|lowval
decl_stmt|,
name|highval
decl_stmt|;
block|{
name|tree
name|itype
init|=
name|make_node
argument_list|(
name|INTEGER_TYPE
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|itype
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
name|type
operator|=
name|sizetype
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|itype
argument_list|)
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|lowval
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|itype
argument_list|)
operator|=
name|highval
condition|?
name|convert
argument_list|(
name|type
argument_list|,
name|highval
argument_list|)
else|:
name|NULL
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|lowval
argument_list|,
literal|0
argument_list|)
operator|&&
name|highval
operator|!=
literal|0
operator|&&
name|host_integerp
argument_list|(
name|highval
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|type_hash_canon
argument_list|(
name|tree_low_cst
argument_list|(
name|highval
argument_list|,
literal|0
argument_list|)
operator|-
name|tree_low_cst
argument_list|(
name|lowval
argument_list|,
literal|0
argument_list|)
argument_list|,
name|itype
argument_list|)
return|;
else|else
return|return
name|itype
return|;
block|}
end_function

begin_comment
comment|/* Just like build_index_type, but takes lowval and highval instead    of just highval (maxval).  */
end_comment

begin_function
name|tree
name|build_index_2_type
parameter_list|(
name|lowval
parameter_list|,
name|highval
parameter_list|)
name|tree
name|lowval
decl_stmt|,
name|highval
decl_stmt|;
block|{
return|return
name|build_range_type
argument_list|(
name|sizetype
argument_list|,
name|lowval
argument_list|,
name|highval
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero iff ITYPE1 and ITYPE2 are equal (in the LISP sense).    Needed because when index types are not hashed, equal index types    built at different times appear distinct, even though structurally,    they are not.  */
end_comment

begin_function
name|int
name|index_type_equal
parameter_list|(
name|itype1
parameter_list|,
name|itype2
parameter_list|)
name|tree
name|itype1
decl_stmt|,
name|itype2
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|itype1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|itype2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|itype1
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|itype1
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|itype2
argument_list|)
operator|||
name|TYPE_MODE
argument_list|(
name|itype1
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|itype2
argument_list|)
operator|||
name|simple_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|itype1
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|itype2
argument_list|)
argument_list|)
operator|!=
literal|1
operator|||
name|TYPE_ALIGN
argument_list|(
name|itype1
argument_list|)
operator|!=
name|TYPE_ALIGN
argument_list|(
name|itype2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
literal|1
operator|==
name|simple_cst_equal
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|itype1
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|itype2
argument_list|)
argument_list|)
operator|&&
literal|1
operator|==
name|simple_cst_equal
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|itype1
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|itype2
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Construct, lay out and return the type of arrays of elements with ELT_TYPE    and number of elements specified by the range of values of INDEX_TYPE.    If such a type has already been constructed, reuse it.  */
end_comment

begin_function
name|tree
name|build_array_type
parameter_list|(
name|elt_type
parameter_list|,
name|index_type
parameter_list|)
name|tree
name|elt_type
decl_stmt|,
name|index_type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|unsigned
name|int
name|hashcode
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elt_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"arrays of functions are not meaningful"
argument_list|)
expr_stmt|;
name|elt_type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Make sure TYPE_POINTER_TO (elt_type) is filled in.  */
name|build_pointer_type
argument_list|(
name|elt_type
argument_list|)
expr_stmt|;
comment|/* Allocate the array after the pointer type,      in case we free it in type_hash_canon.  */
name|t
operator|=
name|make_node
argument_list|(
name|ARRAY_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|elt_type
expr_stmt|;
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
operator|=
name|index_type
expr_stmt|;
if|if
condition|(
name|index_type
operator|==
literal|0
condition|)
block|{
return|return
name|t
return|;
block|}
name|hashcode
operator|=
name|TYPE_HASH
argument_list|(
name|elt_type
argument_list|)
operator|+
name|TYPE_HASH
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return the TYPE of the elements comprising    the innermost dimension of ARRAY.  */
end_comment

begin_function
name|tree
name|get_inner_array_type
parameter_list|(
name|array
parameter_list|)
name|tree
name|array
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Construct, lay out and return    the type of functions returning type VALUE_TYPE    given arguments of types ARG_TYPES.    ARG_TYPES is a chain of TREE_LIST nodes whose TREE_VALUEs    are data type nodes for the arguments of the function.    If such a type has already been constructed, reuse it.  */
end_comment

begin_function
name|tree
name|build_function_type
parameter_list|(
name|value_type
parameter_list|,
name|arg_types
parameter_list|)
name|tree
name|value_type
decl_stmt|,
name|arg_types
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|unsigned
name|int
name|hashcode
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"function return type cannot be function"
argument_list|)
expr_stmt|;
name|value_type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Make a node of the sort we want.  */
name|t
operator|=
name|make_node
argument_list|(
name|FUNCTION_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|value_type
expr_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
operator|=
name|arg_types
expr_stmt|;
comment|/* If we already have such a type, use the old one and free this one.  */
name|hashcode
operator|=
name|TYPE_HASH
argument_list|(
name|value_type
argument_list|)
operator|+
name|type_hash_list
argument_list|(
name|arg_types
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Construct, lay out and return the type of methods belonging to class    BASETYPE and whose arguments and values are described by TYPE.    If that type exists already, reuse it.    TYPE must be a FUNCTION_TYPE node.  */
end_comment

begin_function
name|tree
name|build_method_type
parameter_list|(
name|basetype
parameter_list|,
name|type
parameter_list|)
name|tree
name|basetype
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|unsigned
name|int
name|hashcode
decl_stmt|;
comment|/* Make a node of the sort we want.  */
name|t
operator|=
name|make_node
argument_list|(
name|METHOD_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* The actual arglist for this function includes a "hidden" argument      which is "this".  Put it into the list of argument types.  */
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we already have such a type, use the old one and free this one.  */
name|hashcode
operator|=
name|TYPE_HASH
argument_list|(
name|basetype
argument_list|)
operator|+
name|TYPE_HASH
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Construct, lay out and return the type of offsets to a value    of type TYPE, within an object of type BASETYPE.    If a suitable offset type exists already, reuse it.  */
end_comment

begin_function
name|tree
name|build_offset_type
parameter_list|(
name|basetype
parameter_list|,
name|type
parameter_list|)
name|tree
name|basetype
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|unsigned
name|int
name|hashcode
decl_stmt|;
comment|/* Make a node of the sort we want.  */
name|t
operator|=
name|make_node
argument_list|(
name|OFFSET_TYPE
argument_list|)
expr_stmt|;
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* If we already have such a type, use the old one and free this one.  */
name|hashcode
operator|=
name|TYPE_HASH
argument_list|(
name|basetype
argument_list|)
operator|+
name|TYPE_HASH
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Create a complex type whose components are COMPONENT_TYPE.  */
end_comment

begin_function
name|tree
name|build_complex_type
parameter_list|(
name|component_type
parameter_list|)
name|tree
name|component_type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|unsigned
name|int
name|hashcode
decl_stmt|;
comment|/* Make a node of the sort we want.  */
name|t
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|component_type
argument_list|)
expr_stmt|;
name|set_type_quals
argument_list|(
name|t
argument_list|,
name|TYPE_QUALS
argument_list|(
name|component_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we already have such a type, use the old one and free this one.  */
name|hashcode
operator|=
name|TYPE_HASH
argument_list|(
name|component_type
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* If we are writing Dwarf2 output we need to create a name,      since complex is a fundamental type.  */
if|if
condition|(
operator|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
operator|||
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
operator|)
operator|&&
operator|!
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|component_type
operator|==
name|char_type_node
condition|)
name|name
operator|=
literal|"complex char"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|signed_char_type_node
condition|)
name|name
operator|=
literal|"complex signed char"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|unsigned_char_type_node
condition|)
name|name
operator|=
literal|"complex unsigned char"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|short_integer_type_node
condition|)
name|name
operator|=
literal|"complex short int"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|short_unsigned_type_node
condition|)
name|name
operator|=
literal|"complex short unsigned int"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|integer_type_node
condition|)
name|name
operator|=
literal|"complex int"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|unsigned_type_node
condition|)
name|name
operator|=
literal|"complex unsigned int"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|long_integer_type_node
condition|)
name|name
operator|=
literal|"complex long int"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|long_unsigned_type_node
condition|)
name|name
operator|=
literal|"complex long unsigned int"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|long_long_integer_type_node
condition|)
name|name
operator|=
literal|"complex long long int"
expr_stmt|;
elseif|else
if|if
condition|(
name|component_type
operator|==
name|long_long_unsigned_type_node
condition|)
name|name
operator|=
literal|"complex long long unsigned int"
expr_stmt|;
else|else
name|name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
operator|!=
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return OP, stripped of any conversions to wider types as much as is safe.    Converting the value back to OP's type makes a value equivalent to OP.     If FOR_TYPE is nonzero, we return a value which, if converted to    type FOR_TYPE, would be equivalent to converting OP to type FOR_TYPE.     If FOR_TYPE is nonzero, unaligned bit-field references may be changed to the    narrowest type that can hold the value, even if they don't exactly fit.    Otherwise, bit-field references are changed to a narrower type    only if they can be fetched directly from memory in that type.     OP must have integer, real or enumeral type.  Pointers are not allowed!     There are some cases where the obvious value we could return    would regenerate to OP if converted to OP's type,    but would not extend like OP to wider types.    If FOR_TYPE indicates such extension is contemplated, we eschew such values.    For example, if OP is (unsigned short)(signed char)-1,    we avoid returning (signed char)-1 if FOR_TYPE is int,    even though extending that to an unsigned short would regenerate OP,    since the result of extending (signed char)-1 to (int)    is different from (int) OP.  */
end_comment

begin_function
name|tree
name|get_unwidened
parameter_list|(
name|op
parameter_list|,
name|for_type
parameter_list|)
name|tree
name|op
decl_stmt|;
name|tree
name|for_type
decl_stmt|;
block|{
comment|/* Set UNS initially if converting OP to FOR_TYPE is a zero-extension.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|unsigned
name|final_prec
init|=
name|TYPE_PRECISION
argument_list|(
name|for_type
operator|!=
literal|0
condition|?
name|for_type
else|:
name|type
argument_list|)
decl_stmt|;
name|int
name|uns
init|=
operator|(
name|for_type
operator|!=
literal|0
operator|&&
name|for_type
operator|!=
name|type
operator|&&
name|final_prec
operator|>
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
decl_stmt|;
name|tree
name|win
init|=
name|op
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
name|int
name|bitschange
init|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Truncations are many-one so cannot be removed. 	 Unless we are later going to truncate down even farther.  */
if|if
condition|(
name|bitschange
operator|<
literal|0
operator|&&
name|final_prec
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* See what's inside this conversion.  If we decide to strip it, 	 we will set WIN.  */
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we have not stripped any zero-extensions (uns is 0), 	 we can strip any kind of extension. 	 If we have previously stripped a zero-extension, 	 only zero-extensions can safely be stripped. 	 Any extension can be stripped if the bits it would produce 	 are all going to be discarded later by truncating to FOR_TYPE.  */
if|if
condition|(
name|bitschange
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|uns
operator|||
name|final_prec
operator|<=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
name|win
operator|=
name|op
expr_stmt|;
comment|/* TREE_UNSIGNED says whether this is a zero-extension. 	     Let's avoid computing it if it does not affect WIN 	     and if UNS will not be needed again.  */
if|if
condition|(
operator|(
name|uns
operator|||
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NOP_EXPR
operator|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
block|{
name|uns
operator|=
literal|1
expr_stmt|;
name|win
operator|=
name|op
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|COMPONENT_REF
comment|/* Since type_for_size always gives an integer type.  */
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
comment|/* Don't crash if field not laid out yet.  */
operator|&&
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|innerprec
init|=
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|type
operator|=
name|type_for_size
argument_list|(
name|innerprec
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can get this structure field in the narrowest type it fits in. 	 If FOR_TYPE is 0, do this only for a field that matches the 	 narrower type exactly and is aligned for it 	 The resulting extension to its nominal type (a fullword type) 	 must fit the same conditions as for other extensions.  */
if|if
condition|(
name|innerprec
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
operator|(
name|for_type
operator|||
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|uns
operator|||
name|final_prec
operator|<=
name|innerprec
operator|||
name|TREE_UNSIGNED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
name|type
operator|!=
literal|0
condition|)
block|{
name|win
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|win
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|win
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|win
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return OP or a simpler expression for a narrower value    which can be sign-extended or zero-extended to give back OP.    Store in *UNSIGNEDP_PTR either 1 if the value should be zero-extended    or 0 if the value should be sign-extended.  */
end_comment

begin_function
name|tree
name|get_narrower
parameter_list|(
name|op
parameter_list|,
name|unsignedp_ptr
parameter_list|)
name|tree
name|op
decl_stmt|;
name|int
modifier|*
name|unsignedp_ptr
decl_stmt|;
block|{
name|int
name|uns
init|=
literal|0
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|tree
name|win
init|=
name|op
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
name|int
name|bitschange
init|=
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
decl_stmt|;
comment|/* Truncations are many-one so cannot be removed.  */
if|if
condition|(
name|bitschange
operator|<
literal|0
condition|)
break|break;
comment|/* See what's inside this conversion.  If we decide to strip it, 	 we will set WIN.  */
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitschange
operator|>
literal|0
condition|)
block|{
comment|/* An extension: the outermost one can be stripped, 	     but remember whether it is zero or sign extension.  */
if|if
condition|(
name|first
condition|)
name|uns
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Otherwise, if a sign extension has been stripped, 	     only sign extensions can now be stripped; 	     if a zero extension has been stripped, only zero-extensions.  */
elseif|else
if|if
condition|(
name|uns
operator|!=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
break|break;
name|first
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* bitschange == 0 */
block|{
comment|/* A change in nominal type can always be stripped, but we must 	     preserve the unsignedness.  */
if|if
condition|(
name|first
condition|)
name|uns
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|win
operator|=
name|op
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|COMPONENT_REF
comment|/* Since type_for_size always gives an integer type.  */
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REAL_TYPE
comment|/* Ensure field is laid out already.  */
operator|&&
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|innerprec
init|=
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|type_for_size
argument_list|(
name|innerprec
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|op
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We can get this structure field in a narrower type that fits it, 	 but the resulting extension to its nominal type (a fullword type) 	 must satisfy the same conditions as for other extensions.  	 Do this only for fields that are aligned (not bit-fields), 	 because when bit-field insns will be used there is no 	 advantage in doing this.  */
if|if
condition|(
name|innerprec
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
name|first
operator|||
name|uns
operator|==
name|TREE_UNSIGNED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
name|type
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|first
condition|)
name|uns
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|win
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|win
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|win
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|unsignedp_ptr
operator|=
name|uns
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if integer constant C has a value that is permissible    for type TYPE (an INTEGER_TYPE).  */
end_comment

begin_function
name|int
name|int_fits_type_p
parameter_list|(
name|c
parameter_list|,
name|type
parameter_list|)
name|tree
name|c
decl_stmt|,
name|type
decl_stmt|;
block|{
comment|/* If the bounds of the type are integers, we can check ourselves.      If not, but this type is a subtype, try checking against that.      Otherwise, use force_fit_type, which checks against the precision.  */
if|if
condition|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
return|return
operator|(
operator|!
name|INT_CST_LT_UNSIGNED
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|c
argument_list|)
operator|&&
operator|!
name|INT_CST_LT_UNSIGNED
argument_list|(
name|c
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
comment|/* Negative ints never fit unsigned types.  */
operator|&&
operator|!
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|c
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|c
argument_list|)
argument_list|)
operator|)
operator|)
return|;
else|else
return|return
operator|(
operator|!
name|INT_CST_LT
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|c
argument_list|)
operator|&&
operator|!
name|INT_CST_LT
argument_list|(
name|c
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
comment|/* Unsigned ints with top bit set never fit signed types.  */
operator|&&
operator|!
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|c
argument_list|)
operator|<
literal|0
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|c
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|int_fits_type_p
argument_list|(
name|c
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
else|else
block|{
name|c
operator|=
name|copy_node
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|c
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
operator|!
name|force_fit_type
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Given a DECL or TYPE, return the scope in which it was declared, or    NULL_TREE if there is no containing scope.  */
end_comment

begin_function
name|tree
name|get_containing_scope
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
return|return
operator|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|?
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
else|:
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost context enclosing DECL that is    a FUNCTION_DECL, or zero if none.  */
end_comment

begin_function
name|tree
name|decl_function_context
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|context
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|context
operator|=
name|SAVE_EXPR_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* C++ virtual functions use DECL_CONTEXT for the class of the vtable      where we look up the function at runtime.  Such functions always take      a first argument of type 'pointer to real context'.       C++ should really be fixed to use DECL_CONTEXT for the real context,      and use something else for the "virtual context".  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
condition|)
name|context
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
while|while
condition|(
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|BLOCK
condition|)
name|context
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
else|else
name|context
operator|=
name|get_containing_scope
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
return|return
name|context
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost context enclosing DECL that is    a RECORD_TYPE, UNION_TYPE or QUAL_UNION_TYPE, or zero if none.    TYPE_DECLs and FUNCTION_DECLs are transparent to this function.  */
end_comment

begin_function
name|tree
name|decl_type_context
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
while|while
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
return|return
name|context
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|BLOCK
condition|)
name|context
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
else|else
comment|/* Unhandled CONTEXT!?  */
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* CALL is a CALL_EXPR.  Return the declaration for the function    called, or NULL_TREE if the called function cannot be    determined.  */
end_comment

begin_function
name|tree
name|get_callee_fndecl
parameter_list|(
name|call
parameter_list|)
name|tree
name|call
decl_stmt|;
block|{
name|tree
name|addr
decl_stmt|;
comment|/* It's invalid to call this function with anything but a      CALL_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|call
argument_list|)
operator|!=
name|CALL_EXPR
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The first operand to the CALL is the address of the function      called.  */
name|addr
operator|=
name|TREE_OPERAND
argument_list|(
name|call
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* If this is a readonly function pointer, extract its initial value.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|addr
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_READONLY
argument_list|(
name|addr
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|addr
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|DECL_INITIAL
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* If the address is just `&f' for some function `f', then we know      that `f' is being called.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
return|;
comment|/* We couldn't figure out what was being called.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Print debugging information about the obstack O, named STR.  */
end_comment

begin_function
name|void
name|print_obstack_statistics
parameter_list|(
name|str
parameter_list|,
name|o
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|struct
name|obstack
modifier|*
name|o
decl_stmt|;
block|{
name|struct
name|_obstack_chunk
modifier|*
name|chunk
init|=
name|o
operator|->
name|chunk
decl_stmt|;
name|int
name|n_chunks
init|=
literal|1
decl_stmt|;
name|int
name|n_alloc
init|=
literal|0
decl_stmt|;
name|n_alloc
operator|+=
name|o
operator|->
name|next_free
operator|-
name|chunk
operator|->
name|contents
expr_stmt|;
name|chunk
operator|=
name|chunk
operator|->
name|prev
expr_stmt|;
while|while
condition|(
name|chunk
condition|)
block|{
name|n_chunks
operator|+=
literal|1
expr_stmt|;
name|n_alloc
operator|+=
name|chunk
operator|->
name|limit
operator|-
operator|&
name|chunk
operator|->
name|contents
index|[
literal|0
index|]
expr_stmt|;
name|chunk
operator|=
name|chunk
operator|->
name|prev
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"obstack %s: %u bytes, %d chunks\n"
argument_list|,
name|str
argument_list|,
name|n_alloc
argument_list|,
name|n_chunks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print debugging information about tree nodes generated during the compile,    and any language-specific information.  */
end_comment

begin_function
name|void
name|dump_tree_statistics
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|int
name|i
decl_stmt|;
name|int
name|total_nodes
decl_stmt|,
name|total_bytes
decl_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n??? tree nodes created\n\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Kind                  Nodes     Bytes\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-------------------------------------\n"
argument_list|)
expr_stmt|;
name|total_nodes
operator|=
name|total_bytes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|all_kinds
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-20s %6d %9d\n"
argument_list|,
name|tree_node_kind_names
index|[
name|i
index|]
argument_list|,
name|tree_node_counts
index|[
name|i
index|]
argument_list|,
name|tree_node_sizes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|total_nodes
operator|+=
name|tree_node_counts
index|[
name|i
index|]
expr_stmt|;
name|total_bytes
operator|+=
name|tree_node_sizes
index|[
name|i
index|]
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-20s %6d %9d\n"
argument_list|,
literal|"Total"
argument_list|,
name|total_nodes
argument_list|,
name|total_bytes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-------------------------------------\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(No per-node statistics)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|print_obstack_statistics
argument_list|(
literal|"permanent_obstack"
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|print_type_hash_statistics
argument_list|()
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|print_statistics
call|)
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|FILE_FUNCTION_PREFIX_LEN
value|9
end_define

begin_define
define|#
directive|define
name|FILE_FUNCTION_FORMAT
value|"_GLOBAL__%s_%s"
end_define

begin_comment
comment|/* Appends 6 random characters to TEMPLATE to (hopefully) avoid name    clashes in cases where we can't reliably choose a unique name.     Derived from mkstemp.c in libiberty.  */
end_comment

begin_function
specifier|static
name|void
name|append_random_chars
parameter_list|(
name|template
parameter_list|)
name|char
modifier|*
name|template
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
name|letters
index|[]
init|=
literal|"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
decl_stmt|;
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
comment|/* VALUE should be unique for each file and must not change between 	 compiles since this can cause bootstrap comparison errors.  */
if|if
condition|(
name|stat
argument_list|(
name|main_input_filename
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* In VMS, ino is an array, so we have to use both values.  We 	 conditionalize that.  */
ifdef|#
directive|ifdef
name|VMS
define|#
directive|define
name|INO_TO_INT
parameter_list|(
name|INO
parameter_list|)
value|((int) (INO)[1]<< 16 ^ (int) (INO)[2])
else|#
directive|else
define|#
directive|define
name|INO_TO_INT
parameter_list|(
name|INO
parameter_list|)
value|INO
endif|#
directive|endif
name|value
operator|=
name|st
operator|.
name|st_dev
operator|^
name|INO_TO_INT
argument_list|(
name|st
operator|.
name|st_ino
argument_list|)
operator|^
name|st
operator|.
name|st_mtime
expr_stmt|;
block|}
name|template
operator|+=
name|strlen
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|v
operator|=
name|value
expr_stmt|;
comment|/* Fill in the random bits.  */
name|template
index|[
literal|0
index|]
operator|=
name|letters
index|[
name|v
operator|%
literal|62
index|]
expr_stmt|;
name|v
operator|/=
literal|62
expr_stmt|;
name|template
index|[
literal|1
index|]
operator|=
name|letters
index|[
name|v
operator|%
literal|62
index|]
expr_stmt|;
name|v
operator|/=
literal|62
expr_stmt|;
name|template
index|[
literal|2
index|]
operator|=
name|letters
index|[
name|v
operator|%
literal|62
index|]
expr_stmt|;
name|v
operator|/=
literal|62
expr_stmt|;
name|template
index|[
literal|3
index|]
operator|=
name|letters
index|[
name|v
operator|%
literal|62
index|]
expr_stmt|;
name|v
operator|/=
literal|62
expr_stmt|;
name|template
index|[
literal|4
index|]
operator|=
name|letters
index|[
name|v
operator|%
literal|62
index|]
expr_stmt|;
name|v
operator|/=
literal|62
expr_stmt|;
name|template
index|[
literal|5
index|]
operator|=
name|letters
index|[
name|v
operator|%
literal|62
index|]
expr_stmt|;
name|template
index|[
literal|6
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* P is a string that will be used in a symbol.  Mask out any characters    that are not valid in that context.  */
end_comment

begin_function
name|void
name|clean_symbol_name
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|ISALNUM
argument_list|(
operator|*
name|p
argument_list|)
ifndef|#
directive|ifndef
name|NO_DOLLAR_IN_LABEL
comment|/* this for `$'; unlikely, but... -- kr */
operator|||
operator|*
name|p
operator|==
literal|'$'
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_DOT_IN_LABEL
comment|/* this for `.'; unlikely, but...  */
operator|||
operator|*
name|p
operator|==
literal|'.'
endif|#
directive|endif
operator|)
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a name for a function unique to this translation unit.    TYPE is some string to identify the purpose of this function to the    linker or collect2.  */
end_comment

begin_function
name|tree
name|get_file_function_name_long
parameter_list|(
name|type
parameter_list|)
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|first_global_object_name
condition|)
name|p
operator|=
name|first_global_object_name
expr_stmt|;
else|else
block|{
comment|/* We don't have anything that we know to be unique to this translation 	 unit, so use what we do have and throw in some randomness.  */
specifier|const
name|char
modifier|*
name|name
init|=
name|weak_global_object_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
init|=
name|main_input_filename
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
name|name
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
name|file
operator|=
name|input_filename
expr_stmt|;
name|q
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|7
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|q
argument_list|,
literal|"%s%s"
argument_list|,
name|name
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|append_random_chars
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|FILE_FUNCTION_FORMAT
argument_list|)
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
name|strlen
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the name of the file-level functions we may need.      Use a global object (which is already required to be unique over      the program) rather than the file name (which imposes extra      constraints).  */
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILE_FUNCTION_FORMAT
argument_list|,
name|type
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Don't need to pull weird characters out of global names.  */
if|if
condition|(
name|p
operator|!=
name|first_global_object_name
condition|)
name|clean_symbol_name
argument_list|(
name|buf
operator|+
literal|11
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If KIND=='I', return a suitable global initializer (constructor) name.    If KIND=='D', return a suitable global clean-up (destructor) name.  */
end_comment

begin_function
name|tree
name|get_file_function_name
parameter_list|(
name|kind
parameter_list|)
name|int
name|kind
decl_stmt|;
block|{
name|char
name|p
index|[
literal|2
index|]
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|kind
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|get_file_function_name_long
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand (the constant part of) a SET_TYPE CONSTRUCTOR node.    The result is placed in BUFFER (which has length BIT_SIZE),    with one bit in each char ('\000' or '\001').     If the constructor is constant, NULL_TREE is returned.    Otherwise, a TREE_LIST of the non-constant elements is emitted.  */
end_comment

begin_function
name|tree
name|get_set_constructor_bits
parameter_list|(
name|init
parameter_list|,
name|buffer
parameter_list|,
name|bit_size
parameter_list|)
name|tree
name|init
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|bit_size
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|tree
name|vals
decl_stmt|;
name|HOST_WIDE_INT
name|domain_min
init|=
name|tree_low_cst
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|non_const_bits
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bit_size
condition|;
name|i
operator|++
control|)
name|buffer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vals
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
init|;
name|vals
operator|!=
name|NULL_TREE
condition|;
name|vals
operator|=
name|TREE_CHAIN
argument_list|(
name|vals
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|TREE_VALUE
argument_list|(
name|vals
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|||
operator|(
name|TREE_PURPOSE
argument_list|(
name|vals
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|host_integerp
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|vals
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|non_const_bits
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|vals
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|vals
argument_list|)
argument_list|,
name|non_const_bits
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|vals
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Set a range of bits to ones.  */
name|HOST_WIDE_INT
name|lo_index
init|=
name|tree_low_cst
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|vals
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
name|domain_min
decl_stmt|;
name|HOST_WIDE_INT
name|hi_index
init|=
name|tree_low_cst
argument_list|(
name|TREE_VALUE
argument_list|(
name|vals
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
name|domain_min
decl_stmt|;
if|if
condition|(
name|lo_index
operator|<
literal|0
operator|||
name|lo_index
operator|>=
name|bit_size
operator|||
name|hi_index
operator|<
literal|0
operator|||
name|hi_index
operator|>=
name|bit_size
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|lo_index
operator|<=
name|hi_index
condition|;
name|lo_index
operator|++
control|)
name|buffer
index|[
name|lo_index
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Set a single bit to one.  */
name|HOST_WIDE_INT
name|index
init|=
name|tree_low_cst
argument_list|(
name|TREE_VALUE
argument_list|(
name|vals
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
name|domain_min
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|bit_size
condition|)
block|{
name|error
argument_list|(
literal|"invalid initializer for bit string"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|buffer
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|non_const_bits
return|;
block|}
end_function

begin_comment
comment|/* Expand (the constant part of) a SET_TYPE CONSTRUCTOR node.    The result is placed in BUFFER (which is an array of bytes).    If the constructor is constant, NULL_TREE is returned.    Otherwise, a TREE_LIST of the non-constant elements is emitted.  */
end_comment

begin_function
name|tree
name|get_set_constructor_bytes
parameter_list|(
name|init
parameter_list|,
name|buffer
parameter_list|,
name|wd_size
parameter_list|)
name|tree
name|init
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|wd_size
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|set_word_size
init|=
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|bit_size
init|=
name|wd_size
operator|*
name|set_word_size
decl_stmt|;
name|int
name|bit_pos
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bytep
init|=
name|buffer
decl_stmt|;
name|char
modifier|*
name|bit_buffer
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|bit_size
argument_list|)
decl_stmt|;
name|tree
name|non_const_bits
init|=
name|get_set_constructor_bits
argument_list|(
name|init
argument_list|,
name|bit_buffer
argument_list|,
name|bit_size
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wd_size
condition|;
name|i
operator|++
control|)
name|buffer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bit_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bit_buffer
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
operator|*
name|bytep
operator||=
operator|(
literal|1
operator|<<
operator|(
name|set_word_size
operator|-
literal|1
operator|-
name|bit_pos
operator|)
operator|)
expr_stmt|;
else|else
operator|*
name|bytep
operator||=
literal|1
operator|<<
name|bit_pos
expr_stmt|;
block|}
name|bit_pos
operator|++
expr_stmt|;
if|if
condition|(
name|bit_pos
operator|>=
name|set_word_size
condition|)
name|bit_pos
operator|=
literal|0
operator|,
name|bytep
operator|++
expr_stmt|;
block|}
return|return
name|non_const_bits
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
name|ENABLE_TREE_CHECKING
operator|&&
operator|(
name|GCC_VERSION
operator|>=
literal|2007
operator|)
end_if

begin_comment
comment|/* Complain that the tree code of NODE does not match the expected CODE.    FILE, LINE, and FUNCTION are of the caller.  */
end_comment

begin_function
name|void
name|tree_check_failed
parameter_list|(
name|node
parameter_list|,
name|code
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|function
parameter_list|)
specifier|const
name|tree
name|node
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|function
decl_stmt|;
block|{
name|internal_error
argument_list|(
literal|"tree check: expected %s, have %s in %s, at %s:%d"
argument_list|,
name|tree_code_name
index|[
name|code
index|]
argument_list|,
name|tree_code_name
index|[
name|TREE_CODE
argument_list|(
name|node
argument_list|)
index|]
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to above, except that we check for a class of tree    code, given in CL.  */
end_comment

begin_function
name|void
name|tree_class_check_failed
parameter_list|(
name|node
parameter_list|,
name|cl
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|function
parameter_list|)
specifier|const
name|tree
name|node
decl_stmt|;
name|int
name|cl
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|function
decl_stmt|;
block|{
name|internal_error
argument_list|(
literal|"tree check: expected class '%c', have '%c' (%s) in %s, at %s:%d"
argument_list|,
name|cl
argument_list|,
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|,
name|tree_code_name
index|[
name|TREE_CODE
argument_list|(
name|node
argument_list|)
index|]
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_TREE_CHECKING */
end_comment

begin_escape
end_escape

begin_comment
comment|/* For a new vector type node T, build the information necessary for    debuggint output.  */
end_comment

begin_function
specifier|static
name|void
name|finish_vector_type
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|{
name|tree
name|index
init|=
name|build_int_2
argument_list|(
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|t
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|array
init|=
name|build_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|build_index_type
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|rt
init|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
decl_stmt|;
name|TYPE_FIELDS
argument_list|(
name|rt
argument_list|)
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"f"
argument_list|)
argument_list|,
name|array
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|rt
argument_list|)
argument_list|)
operator|=
name|rt
expr_stmt|;
name|layout_type
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|TYPE_DEBUG_REPRESENTATION_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|rt
expr_stmt|;
comment|/* In dwarfout.c, type lookup uses TYPE_UID numbers.  We want to output        the representation type, and we want to find that die when looking up        the vector type.  This is most easily achieved by making the TYPE_UID        numbers equal.  */
name|TYPE_UID
argument_list|(
name|rt
argument_list|)
operator|=
name|TYPE_UID
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create nodes for all integer types (and error_mark_node) using the sizes    of C datatypes.  The caller should call set_sizetype soon after calling    this function to select one of the types as sizetype.  */
end_comment

begin_function
name|void
name|build_common_tree_nodes
parameter_list|(
name|signed_char
parameter_list|)
name|int
name|signed_char
decl_stmt|;
block|{
name|error_mark_node
operator|=
name|make_node
argument_list|(
name|ERROR_MARK
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|error_mark_node
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|initialize_sizetypes
argument_list|()
expr_stmt|;
comment|/* Define both `signed char' and `unsigned char'.  */
name|signed_char_type_node
operator|=
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|unsigned_char_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
comment|/* Define `char', which is like either `signed char' or `unsigned char'      but not the same as either.  */
name|char_type_node
operator|=
operator|(
name|signed_char
condition|?
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
else|:
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
operator|)
expr_stmt|;
name|short_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|SHORT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|short_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|SHORT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|INT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|INT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|long_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|long_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|long_long_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|LONG_LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|long_long_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|LONG_LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|intQI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
name|intHI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|intSI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
name|intDI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|DImode
argument_list|)
argument_list|)
expr_stmt|;
name|intTI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|TImode
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intQI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intHI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intSI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intDI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|DImode
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intTI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|TImode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this function after calling build_common_tree_nodes and set_sizetype.    It will create several other common tree nodes.  */
end_comment

begin_function
name|void
name|build_common_tree_nodes_2
parameter_list|(
name|short_double
parameter_list|)
name|int
name|short_double
decl_stmt|;
block|{
comment|/* Define these next since types below may used them.  */
name|integer_zero_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|integer_one_node
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|integer_minus_one_node
operator|=
name|build_int_2
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|size_zero_node
operator|=
name|size_int
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|size_one_node
operator|=
name|size_int
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bitsize_zero_node
operator|=
name|bitsize_int
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bitsize_one_node
operator|=
name|bitsize_int
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bitsize_unit_node
operator|=
name|bitsize_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|void_type_node
operator|=
name|make_node
argument_list|(
name|VOID_TYPE
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* We are not going to have real types in C with less than byte alignment,      so we might as well not have any types that claim to have it.  */
name|TYPE_ALIGN
argument_list|(
name|void_type_node
argument_list|)
operator|=
name|BITS_PER_UNIT
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|void_type_node
argument_list|)
operator|=
literal|0
expr_stmt|;
name|null_pointer_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
argument_list|)
expr_stmt|;
name|ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|const_ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|void_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|float_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|float_type_node
argument_list|)
operator|=
name|FLOAT_TYPE_SIZE
expr_stmt|;
name|layout_type
argument_list|(
name|float_type_node
argument_list|)
expr_stmt|;
name|double_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|short_double
condition|)
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|=
name|FLOAT_TYPE_SIZE
expr_stmt|;
else|else
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|=
name|DOUBLE_TYPE_SIZE
expr_stmt|;
name|layout_type
argument_list|(
name|double_type_node
argument_list|)
expr_stmt|;
name|long_double_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|long_double_type_node
argument_list|)
operator|=
name|LONG_DOUBLE_TYPE_SIZE
expr_stmt|;
name|layout_type
argument_list|(
name|long_double_type_node
argument_list|)
expr_stmt|;
name|complex_integer_type_node
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|complex_integer_type_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|layout_type
argument_list|(
name|complex_integer_type_node
argument_list|)
expr_stmt|;
name|complex_float_type_node
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|complex_float_type_node
argument_list|)
operator|=
name|float_type_node
expr_stmt|;
name|layout_type
argument_list|(
name|complex_float_type_node
argument_list|)
expr_stmt|;
name|complex_double_type_node
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|complex_double_type_node
argument_list|)
operator|=
name|double_type_node
expr_stmt|;
name|layout_type
argument_list|(
name|complex_double_type_node
argument_list|)
expr_stmt|;
name|complex_long_double_type_node
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|complex_long_double_type_node
argument_list|)
operator|=
name|long_double_type_node
expr_stmt|;
name|layout_type
argument_list|(
name|complex_long_double_type_node
argument_list|)
expr_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|BUILD_VA_LIST_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Many back-ends define record types without seting TYPE_NAME.        If we copied the record type here, we'd keep the original        record type without a name.  This breaks name mangling.  So,        don't copy record types and let c_common_nodes_and_builtins()        declare the type to be __builtin_va_list.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
name|t
operator|=
name|build_type_copy
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|va_list_type_node
operator|=
name|t
expr_stmt|;
block|}
name|unsigned_V4SI_type_node
operator|=
name|make_vector
argument_list|(
name|V4SImode
argument_list|,
name|unsigned_intSI_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|unsigned_V2SI_type_node
operator|=
name|make_vector
argument_list|(
name|V2SImode
argument_list|,
name|unsigned_intSI_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|unsigned_V4HI_type_node
operator|=
name|make_vector
argument_list|(
name|V4HImode
argument_list|,
name|unsigned_intHI_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|unsigned_V8QI_type_node
operator|=
name|make_vector
argument_list|(
name|V8QImode
argument_list|,
name|unsigned_intQI_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|unsigned_V8HI_type_node
operator|=
name|make_vector
argument_list|(
name|V8HImode
argument_list|,
name|unsigned_intHI_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|unsigned_V16QI_type_node
operator|=
name|make_vector
argument_list|(
name|V16QImode
argument_list|,
name|unsigned_intQI_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|V4SF_type_node
operator|=
name|make_vector
argument_list|(
name|V4SFmode
argument_list|,
name|float_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|V4SI_type_node
operator|=
name|make_vector
argument_list|(
name|V4SImode
argument_list|,
name|intSI_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|V2SI_type_node
operator|=
name|make_vector
argument_list|(
name|V2SImode
argument_list|,
name|intSI_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|V4HI_type_node
operator|=
name|make_vector
argument_list|(
name|V4HImode
argument_list|,
name|intHI_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|V8QI_type_node
operator|=
name|make_vector
argument_list|(
name|V8QImode
argument_list|,
name|intQI_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|V8HI_type_node
operator|=
name|make_vector
argument_list|(
name|V8HImode
argument_list|,
name|intHI_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|V2SF_type_node
operator|=
name|make_vector
argument_list|(
name|V2SFmode
argument_list|,
name|float_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|V16QI_type_node
operator|=
name|make_vector
argument_list|(
name|V16QImode
argument_list|,
name|intQI_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns a vector tree node given a vector mode, the inner type, and    the signness.  */
end_comment

begin_function
specifier|static
name|tree
name|make_vector
parameter_list|(
name|mode
parameter_list|,
name|innertype
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|innertype
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|VECTOR_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|innertype
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|=
name|mode
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|unsignedp
expr_stmt|;
name|finish_vector_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

end_unit

