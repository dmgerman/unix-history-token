begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* SSA operands management for trees.    Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"ipa-reference.h"
end_include

begin_comment
comment|/* This file contains the code required to manage the operands cache of the     SSA optimizer.  For every stmt, we maintain an operand cache in the stmt     annotation.  This cache contains operands that will be of interest to     optimizers and other passes wishing to manipulate the IL.      The operand type are broken up into REAL and VIRTUAL operands.  The real     operands are represented as pointers into the stmt's operand tree.  Thus     any manipulation of the real operands will be reflected in the actual tree.    Virtual operands are represented solely in the cache, although the base     variable for the SSA_NAME may, or may not occur in the stmt's tree.      Manipulation of the virtual operands will not be reflected in the stmt tree.     The routines in this file are concerned with creating this operand cache     from a stmt tree.     The operand tree is the parsed by the various get_* routines which look     through the stmt tree for the occurrence of operands which may be of     interest, and calls are made to the append_* routines whenever one is     found.  There are 5 of these routines, each representing one of the     5 types of operands. Defs, Uses, Virtual Uses, Virtual May Defs, and     Virtual Must Defs.     The append_* routines check for duplication, and simply keep a list of     unique objects for each operand type in the build_* extendable vectors.     Once the stmt tree is completely parsed, the finalize_ssa_operands()     routine is called, which proceeds to perform the finalization routine     on each of the 5 operand vectors which have been built up.     If the stmt had a previous operand cache, the finalization routines     attempt to match up the new operands with the old ones.  If it's a perfect     match, the old vector is simply reused.  If it isn't a perfect match, then     a new vector is created and the new operands are placed there.  For     virtual operands, if the previous cache had SSA_NAME version of a     variable, and that same variable occurs in the same operands cache, then     the new cache vector will also get the same SSA_NAME.    i.e., if a stmt had a VUSE of 'a_5', and 'a' occurs in the new operand    vector for VUSE, then the new vector will also be modified such that    it contains 'a_5' rather than 'a'.  */
end_comment

begin_comment
comment|/* Flags to describe operand properties in helpers.  */
end_comment

begin_comment
comment|/* By default, operands are loaded.  */
end_comment

begin_define
define|#
directive|define
name|opf_none
value|0
end_define

begin_comment
comment|/* Operand is the target of an assignment expression or a     call-clobbered variable.  */
end_comment

begin_define
define|#
directive|define
name|opf_is_def
value|(1<< 0)
end_define

begin_comment
comment|/* Operand is the target of an assignment expression.  */
end_comment

begin_define
define|#
directive|define
name|opf_kill_def
value|(1<< 1)
end_define

begin_comment
comment|/* No virtual operands should be created in the expression.  This is used    when traversing ADDR_EXPR nodes which have different semantics than    other expressions.  Inside an ADDR_EXPR node, the only operands that we    need to consider are indices into arrays.  For instance,&a.b[i] should    generate a USE of 'i' but it should not generate a VUSE for 'a' nor a    VUSE for 'b'.  */
end_comment

begin_define
define|#
directive|define
name|opf_no_vops
value|(1<< 2)
end_define

begin_comment
comment|/* Operand is a "non-specific" kill for call-clobbers and such.  This    is used to distinguish "reset the world" events from explicit    MODIFY_EXPRs.  */
end_comment

begin_define
define|#
directive|define
name|opf_non_specific
value|(1<< 3)
end_define

begin_comment
comment|/* Array for building all the def operands.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|build_defs
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Array for building all the use operands.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|build_uses
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Array for building all the V_MAY_DEF operands.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|build_v_may_defs
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Array for building all the VUSE operands.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|build_vuses
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Array for building all the V_MUST_DEF operands.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|build_v_must_defs
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* These arrays are the cached operand vectors for call clobbered calls.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ops_active
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|ssa_operand_memory_d
operator|*
name|operand_memory
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|operand_memory_index
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|get_expr_operands
parameter_list|(
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|def_optype_p
name|free_defs
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|use_optype_p
name|free_uses
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vuse_optype_p
name|free_vuses
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|maydef_optype_p
name|free_maydefs
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mustdef_optype_p
name|free_mustdefs
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocates operand OP of given TYPE from the appropriate free list,    or of the new value if the list is empty.  */
end_comment

begin_define
define|#
directive|define
name|ALLOC_OPTYPE
parameter_list|(
name|OP
parameter_list|,
name|TYPE
parameter_list|)
define|\
value|do							\     {							\       TYPE##_optype_p ret = free_##TYPE##s;		\       if (ret)						\ 	free_##TYPE##s = ret->next;			\       else						\ 	ret = ssa_operand_alloc (sizeof (*ret));	\       (OP) = ret;					\     } while (0)
end_define

begin_comment
comment|/* Return the DECL_UID of the base variable of T.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|get_name_decl
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|DECL_UID
argument_list|(
name|t
argument_list|)
return|;
else|else
return|return
name|DECL_UID
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Comparison function for qsort used in operand_build_sort_virtual.  */
end_comment

begin_function
specifier|static
name|int
name|operand_build_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|q
parameter_list|)
block|{
name|tree
name|e1
init|=
operator|*
operator|(
operator|(
specifier|const
name|tree
operator|*
operator|)
name|p
operator|)
decl_stmt|;
name|tree
name|e2
init|=
operator|*
operator|(
operator|(
specifier|const
name|tree
operator|*
operator|)
name|q
operator|)
decl_stmt|;
name|unsigned
name|int
name|u1
decl_stmt|,
name|u2
decl_stmt|;
name|u1
operator|=
name|get_name_decl
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|u2
operator|=
name|get_name_decl
argument_list|(
name|e2
argument_list|)
expr_stmt|;
comment|/* We want to sort in ascending order.  They can never be equal.  */
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|u1
operator|!=
name|u2
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|u1
operator|>
name|u2
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Sort the virtual operands in LIST from lowest DECL_UID to highest.  */
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|operand_build_sort_virtual
argument_list|(
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|list
argument_list|)
block|{
name|int
name|num
init|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|list
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|<
literal|2
condition|)
return|return;
if|if
condition|(
name|num
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|get_name_decl
argument_list|(
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|list
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|get_name_decl
argument_list|(
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|list
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Swap elements if in the wrong order.  */
name|tree
name|tmp
init|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|list
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|VEC_replace
argument_list|(
name|tree
argument_list|,
name|list
argument_list|,
literal|0
argument_list|,
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|list
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|tree
argument_list|,
name|list
argument_list|,
literal|1
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* There are 3 or more elements, call qsort.  */
name|qsort
argument_list|(
name|VEC_address
argument_list|(
name|tree
argument_list|,
name|list
argument_list|)
argument_list|,
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|list
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|,
name|operand_build_cmp
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  Return true if the SSA operands cache is active.  */
end_comment

begin_function
name|bool
name|ssa_operands_active
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ops_active
return|;
block|}
end_function

begin_comment
comment|/* Structure storing statistics on how many call clobbers we have, and    how many where avoided.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
comment|/* Number of call-clobbered ops we attempt to add to calls in      add_call_clobber_ops.  */
name|unsigned
name|int
name|clobbered_vars
decl_stmt|;
comment|/* Number of write-clobbers (V_MAY_DEFs) avoided by using      not_written information.  */
name|unsigned
name|int
name|static_write_clobbers_avoided
decl_stmt|;
comment|/* Number of reads (VUSEs) avoided by using not_read information.  */
name|unsigned
name|int
name|static_read_clobbers_avoided
decl_stmt|;
comment|/* Number of write-clobbers avoided because the variable can't escape to      this call.  */
name|unsigned
name|int
name|unescapable_clobbers_avoided
decl_stmt|;
comment|/* Number of read-only uses we attempt to add to calls in      add_call_read_ops.  */
name|unsigned
name|int
name|readonly_clobbers
decl_stmt|;
comment|/* Number of read-only uses we avoid using not_read information.  */
name|unsigned
name|int
name|static_readonly_clobbers_avoided
decl_stmt|;
block|}
name|clobber_stats
struct|;
end_struct

begin_comment
comment|/* Initialize the operand cache routines.  */
end_comment

begin_function
name|void
name|init_ssa_operands
parameter_list|(
name|void
parameter_list|)
block|{
name|build_defs
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|build_uses
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|build_vuses
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|build_v_may_defs
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|build_v_must_defs
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|operand_memory
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|operand_memory_index
operator|=
name|SSA_OPERAND_MEMORY_SIZE
expr_stmt|;
name|ops_active
operator|=
name|true
expr_stmt|;
name|memset
argument_list|(
operator|&
name|clobber_stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|clobber_stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dispose of anything required by the operand routines.  */
end_comment

begin_function
name|void
name|fini_ssa_operands
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ssa_operand_memory_d
modifier|*
name|ptr
decl_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|build_defs
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|build_uses
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|build_v_must_defs
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|build_v_may_defs
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|build_vuses
argument_list|)
expr_stmt|;
name|free_defs
operator|=
name|NULL
expr_stmt|;
name|free_uses
operator|=
name|NULL
expr_stmt|;
name|free_vuses
operator|=
name|NULL
expr_stmt|;
name|free_maydefs
operator|=
name|NULL
expr_stmt|;
name|free_mustdefs
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|ptr
operator|=
name|operand_memory
operator|)
operator|!=
name|NULL
condition|)
block|{
name|operand_memory
operator|=
name|operand_memory
operator|->
name|next
expr_stmt|;
name|ggc_free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
name|ops_active
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Original clobbered vars:%d\n"
argument_list|,
name|clobber_stats
operator|.
name|clobbered_vars
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Static write clobbers avoided:%d\n"
argument_list|,
name|clobber_stats
operator|.
name|static_write_clobbers_avoided
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Static read clobbers avoided:%d\n"
argument_list|,
name|clobber_stats
operator|.
name|static_read_clobbers_avoided
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Unescapable clobbers avoided:%d\n"
argument_list|,
name|clobber_stats
operator|.
name|unescapable_clobbers_avoided
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Original read-only clobbers:%d\n"
argument_list|,
name|clobber_stats
operator|.
name|readonly_clobbers
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Static read-only clobbers avoided:%d\n"
argument_list|,
name|clobber_stats
operator|.
name|static_readonly_clobbers_avoided
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return memory for operands of SIZE chunks.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|ssa_operand_alloc
parameter_list|(
name|unsigned
name|size
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|operand_memory_index
operator|+
name|size
operator|>=
name|SSA_OPERAND_MEMORY_SIZE
condition|)
block|{
name|struct
name|ssa_operand_memory_d
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|ssa_operand_memory_d
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|next
operator|=
name|operand_memory
expr_stmt|;
name|operand_memory
operator|=
name|ptr
expr_stmt|;
name|operand_memory_index
operator|=
literal|0
expr_stmt|;
block|}
name|ptr
operator|=
operator|&
operator|(
name|operand_memory
operator|->
name|mem
index|[
name|operand_memory_index
index|]
operator|)
expr_stmt|;
name|operand_memory_index
operator|+=
name|size
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* This routine makes sure that PTR is in an immediate use list, and makes    sure the stmt pointer is set to the current stmt.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_virtual_use_link
parameter_list|(
name|use_operand_p
name|ptr
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
comment|/*  fold_stmt may have changed the stmt pointers.  */
if|if
condition|(
name|ptr
operator|->
name|stmt
operator|!=
name|stmt
condition|)
name|ptr
operator|->
name|stmt
operator|=
name|stmt
expr_stmt|;
comment|/* If this use isn't in a list, add it to the correct list.  */
if|if
condition|(
operator|!
name|ptr
operator|->
name|prev
condition|)
name|link_imm_use
argument_list|(
name|ptr
argument_list|,
operator|*
operator|(
name|ptr
operator|->
name|use
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Appends ELT after TO, and moves the TO pointer to ELT.  */
end_comment

begin_define
define|#
directive|define
name|APPEND_OP_AFTER
parameter_list|(
name|ELT
parameter_list|,
name|TO
parameter_list|)
define|\
value|do					\     {					\       (TO)->next = (ELT);		\       (TO) = (ELT);			\     } while (0)
end_define

begin_comment
comment|/* Appends head of list FROM after TO, and move both pointers    to their successors.  */
end_comment

begin_define
define|#
directive|define
name|MOVE_HEAD_AFTER
parameter_list|(
name|FROM
parameter_list|,
name|TO
parameter_list|)
define|\
value|do					\     {					\       APPEND_OP_AFTER (FROM, TO);	\       (FROM) = (FROM)->next;		\     } while (0)
end_define

begin_comment
comment|/* Moves OP to appropriate freelist.  OP is set to its successor.  */
end_comment

begin_define
define|#
directive|define
name|MOVE_HEAD_TO_FREELIST
parameter_list|(
name|OP
parameter_list|,
name|TYPE
parameter_list|)
define|\
value|do							\     {							\       TYPE##_optype_p next = (OP)->next;		\       (OP)->next = free_##TYPE##s;			\       free_##TYPE##s = (OP);				\       (OP) = next;					\     } while (0)
end_define

begin_comment
comment|/* Initializes immediate use at USE_PTR to value VAL, and links it to the list    of immediate uses.  STMT is the current statement.  */
end_comment

begin_define
define|#
directive|define
name|INITIALIZE_USE
parameter_list|(
name|USE_PTR
parameter_list|,
name|VAL
parameter_list|,
name|STMT
parameter_list|)
define|\
value|do							\     {							\       (USE_PTR)->use = (VAL);				\       link_imm_use_stmt ((USE_PTR), *(VAL), (STMT));	\     } while (0)
end_define

begin_comment
comment|/* Adds OP to the list of defs after LAST, and moves    LAST to the new element.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_def_op
parameter_list|(
name|tree
modifier|*
name|op
parameter_list|,
name|def_optype_p
modifier|*
name|last
parameter_list|)
block|{
name|def_optype_p
name|new
decl_stmt|;
name|ALLOC_OPTYPE
argument_list|(
name|new
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|DEF_OP_PTR
argument_list|(
name|new
argument_list|)
operator|=
name|op
expr_stmt|;
name|APPEND_OP_AFTER
argument_list|(
name|new
argument_list|,
operator|*
name|last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adds OP to the list of uses of statement STMT after LAST, and moves    LAST to the new element.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_use_op
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
modifier|*
name|op
parameter_list|,
name|use_optype_p
modifier|*
name|last
parameter_list|)
block|{
name|use_optype_p
name|new
decl_stmt|;
name|ALLOC_OPTYPE
argument_list|(
name|new
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|INITIALIZE_USE
argument_list|(
name|USE_OP_PTR
argument_list|(
name|new
argument_list|)
argument_list|,
name|op
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|APPEND_OP_AFTER
argument_list|(
name|new
argument_list|,
operator|*
name|last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adds OP to the list of vuses of statement STMT after LAST, and moves    LAST to the new element.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_vuse_op
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|op
parameter_list|,
name|vuse_optype_p
modifier|*
name|last
parameter_list|)
block|{
name|vuse_optype_p
name|new
decl_stmt|;
name|ALLOC_OPTYPE
argument_list|(
name|new
argument_list|,
name|vuse
argument_list|)
expr_stmt|;
name|VUSE_OP
argument_list|(
name|new
argument_list|)
operator|=
name|op
expr_stmt|;
name|INITIALIZE_USE
argument_list|(
name|VUSE_OP_PTR
argument_list|(
name|new
argument_list|)
argument_list|,
operator|&
name|VUSE_OP
argument_list|(
name|new
argument_list|)
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|APPEND_OP_AFTER
argument_list|(
name|new
argument_list|,
operator|*
name|last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adds OP to the list of maydefs of statement STMT after LAST, and moves    LAST to the new element.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_maydef_op
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|op
parameter_list|,
name|maydef_optype_p
modifier|*
name|last
parameter_list|)
block|{
name|maydef_optype_p
name|new
decl_stmt|;
name|ALLOC_OPTYPE
argument_list|(
name|new
argument_list|,
name|maydef
argument_list|)
expr_stmt|;
name|MAYDEF_RESULT
argument_list|(
name|new
argument_list|)
operator|=
name|op
expr_stmt|;
name|MAYDEF_OP
argument_list|(
name|new
argument_list|)
operator|=
name|op
expr_stmt|;
name|INITIALIZE_USE
argument_list|(
name|MAYDEF_OP_PTR
argument_list|(
name|new
argument_list|)
argument_list|,
operator|&
name|MAYDEF_OP
argument_list|(
name|new
argument_list|)
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|APPEND_OP_AFTER
argument_list|(
name|new
argument_list|,
operator|*
name|last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adds OP to the list of mustdefs of statement STMT after LAST, and moves    LAST to the new element.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_mustdef_op
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|op
parameter_list|,
name|mustdef_optype_p
modifier|*
name|last
parameter_list|)
block|{
name|mustdef_optype_p
name|new
decl_stmt|;
name|ALLOC_OPTYPE
argument_list|(
name|new
argument_list|,
name|mustdef
argument_list|)
expr_stmt|;
name|MUSTDEF_RESULT
argument_list|(
name|new
argument_list|)
operator|=
name|op
expr_stmt|;
name|MUSTDEF_KILL
argument_list|(
name|new
argument_list|)
operator|=
name|op
expr_stmt|;
name|INITIALIZE_USE
argument_list|(
name|MUSTDEF_KILL_PTR
argument_list|(
name|new
argument_list|)
argument_list|,
operator|&
name|MUSTDEF_KILL
argument_list|(
name|new
argument_list|)
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|APPEND_OP_AFTER
argument_list|(
name|new
argument_list|,
operator|*
name|last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Takes elements from build_defs and turns them into def operands of STMT.    TODO -- Given that def operands list is not necessarily sorted, merging 	   the operands this way does not make much sense. 	-- Make build_defs VEC of tree *.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|finalize_ssa_def_ops
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|unsigned
name|new_i
decl_stmt|;
name|struct
name|def_optype_d
name|new_list
decl_stmt|;
name|def_optype_p
name|old_ops
decl_stmt|,
name|last
decl_stmt|;
name|tree
modifier|*
name|old_base
decl_stmt|;
name|new_list
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|last
operator|=
operator|&
name|new_list
expr_stmt|;
name|old_ops
operator|=
name|DEF_OPS
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|new_i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|old_ops
operator|&&
name|new_i
operator|<
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_defs
argument_list|)
condition|)
block|{
name|tree
modifier|*
name|new_base
init|=
operator|(
name|tree
operator|*
operator|)
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|build_defs
argument_list|,
name|new_i
argument_list|)
decl_stmt|;
name|old_base
operator|=
name|DEF_OP_PTR
argument_list|(
name|old_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_base
operator|==
name|new_base
condition|)
block|{
comment|/* if variables are the same, reuse this node.  */
name|MOVE_HEAD_AFTER
argument_list|(
name|old_ops
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|new_i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old_base
operator|<
name|new_base
condition|)
block|{
comment|/* if old is less than new, old goes to the free list.  */
name|MOVE_HEAD_TO_FREELIST
argument_list|(
name|old_ops
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a new operand.  */
name|add_def_op
argument_list|(
name|new_base
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|new_i
operator|++
expr_stmt|;
block|}
block|}
comment|/* If there is anything remaining in the build_defs list, simply emit it.  */
for|for
control|(
init|;
name|new_i
operator|<
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_defs
argument_list|)
condition|;
name|new_i
operator|++
control|)
name|add_def_op
argument_list|(
operator|(
name|tree
operator|*
operator|)
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|build_defs
argument_list|,
name|new_i
argument_list|)
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|last
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* If there is anything in the old list, free it.  */
if|if
condition|(
name|old_ops
condition|)
block|{
name|old_ops
operator|->
name|next
operator|=
name|free_defs
expr_stmt|;
name|free_defs
operator|=
name|old_ops
expr_stmt|;
block|}
comment|/* Now set the stmt's operands.  */
name|DEF_OPS
argument_list|(
name|stmt
argument_list|)
operator|=
name|new_list
operator|.
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
block|{
name|def_optype_p
name|ptr
decl_stmt|;
name|unsigned
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|DEF_OPS
argument_list|(
name|stmt
argument_list|)
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|x
operator|++
expr_stmt|;
name|gcc_assert
argument_list|(
name|x
operator|==
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_defs
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This routine will create stmt operands for STMT from the def build list.  */
end_comment

begin_function
specifier|static
name|void
name|finalize_ssa_defs
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|unsigned
name|int
name|num
init|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_defs
argument_list|)
decl_stmt|;
comment|/* There should only be a single real definition per assignment.  */
name|gcc_assert
argument_list|(
operator|(
name|stmt
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
operator|)
operator|||
name|num
operator|<=
literal|1
argument_list|)
expr_stmt|;
comment|/* If there is an old list, often the new list is identical, or close, so      find the elements at the beginning that are the same as the vector.  */
name|finalize_ssa_def_ops
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|VEC_truncate
argument_list|(
name|tree
argument_list|,
name|build_defs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Takes elements from build_uses and turns them into use operands of STMT.    TODO -- Make build_uses VEC of tree *.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|finalize_ssa_use_ops
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|unsigned
name|new_i
decl_stmt|;
name|struct
name|use_optype_d
name|new_list
decl_stmt|;
name|use_optype_p
name|old_ops
decl_stmt|,
name|ptr
decl_stmt|,
name|last
decl_stmt|;
name|new_list
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|last
operator|=
operator|&
name|new_list
expr_stmt|;
name|old_ops
operator|=
name|USE_OPS
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* If there is anything in the old list, free it.  */
if|if
condition|(
name|old_ops
condition|)
block|{
for|for
control|(
name|ptr
operator|=
name|old_ops
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|delink_imm_use
argument_list|(
name|USE_OP_PTR
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|old_ops
operator|->
name|next
operator|=
name|free_uses
expr_stmt|;
name|free_uses
operator|=
name|old_ops
expr_stmt|;
block|}
comment|/* Now create nodes for all the new nodes.  */
for|for
control|(
name|new_i
operator|=
literal|0
init|;
name|new_i
operator|<
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_uses
argument_list|)
condition|;
name|new_i
operator|++
control|)
name|add_use_op
argument_list|(
name|stmt
argument_list|,
operator|(
name|tree
operator|*
operator|)
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|build_uses
argument_list|,
name|new_i
argument_list|)
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|last
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Now set the stmt's operands.  */
name|USE_OPS
argument_list|(
name|stmt
argument_list|)
operator|=
name|new_list
operator|.
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
block|{
name|unsigned
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|USE_OPS
argument_list|(
name|stmt
argument_list|)
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|x
operator|++
expr_stmt|;
name|gcc_assert
argument_list|(
name|x
operator|==
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_uses
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return a new use operand vector for STMT, comparing to OLD_OPS_P.  */
end_comment

begin_function
specifier|static
name|void
name|finalize_ssa_uses
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
block|{
name|unsigned
name|x
decl_stmt|;
name|unsigned
name|num
init|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_uses
argument_list|)
decl_stmt|;
comment|/* If the pointer to the operand is the statement itself, something is        wrong.  It means that we are pointing to a local variable (the         initial call to update_stmt_operands does not pass a pointer to a         statement).  */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|num
condition|;
name|x
operator|++
control|)
name|gcc_assert
argument_list|(
operator|*
operator|(
operator|(
name|tree
operator|*
operator|)
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|build_uses
argument_list|,
name|x
argument_list|)
operator|)
operator|!=
name|stmt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|finalize_ssa_use_ops
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|VEC_truncate
argument_list|(
name|tree
argument_list|,
name|build_uses
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Takes elements from build_v_may_defs and turns them into maydef operands of    STMT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|finalize_ssa_v_may_def_ops
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|unsigned
name|new_i
decl_stmt|;
name|struct
name|maydef_optype_d
name|new_list
decl_stmt|;
name|maydef_optype_p
name|old_ops
decl_stmt|,
name|ptr
decl_stmt|,
name|last
decl_stmt|;
name|tree
name|act
decl_stmt|;
name|unsigned
name|old_base
decl_stmt|,
name|new_base
decl_stmt|;
name|new_list
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|last
operator|=
operator|&
name|new_list
expr_stmt|;
name|old_ops
operator|=
name|MAYDEF_OPS
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|new_i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|old_ops
operator|&&
name|new_i
operator|<
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_v_may_defs
argument_list|)
condition|)
block|{
name|act
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|build_v_may_defs
argument_list|,
name|new_i
argument_list|)
expr_stmt|;
name|new_base
operator|=
name|get_name_decl
argument_list|(
name|act
argument_list|)
expr_stmt|;
name|old_base
operator|=
name|get_name_decl
argument_list|(
name|MAYDEF_OP
argument_list|(
name|old_ops
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_base
operator|==
name|new_base
condition|)
block|{
comment|/* if variables are the same, reuse this node.  */
name|MOVE_HEAD_AFTER
argument_list|(
name|old_ops
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|set_virtual_use_link
argument_list|(
name|MAYDEF_OP_PTR
argument_list|(
name|last
argument_list|)
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|new_i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old_base
operator|<
name|new_base
condition|)
block|{
comment|/* if old is less than new, old goes to the free list.  */
name|delink_imm_use
argument_list|(
name|MAYDEF_OP_PTR
argument_list|(
name|old_ops
argument_list|)
argument_list|)
expr_stmt|;
name|MOVE_HEAD_TO_FREELIST
argument_list|(
name|old_ops
argument_list|,
name|maydef
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a new operand.  */
name|add_maydef_op
argument_list|(
name|stmt
argument_list|,
name|act
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|new_i
operator|++
expr_stmt|;
block|}
block|}
comment|/* If there is anything remaining in the build_v_may_defs list, simply emit it.  */
for|for
control|(
init|;
name|new_i
operator|<
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_v_may_defs
argument_list|)
condition|;
name|new_i
operator|++
control|)
name|add_maydef_op
argument_list|(
name|stmt
argument_list|,
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|build_v_may_defs
argument_list|,
name|new_i
argument_list|)
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|last
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* If there is anything in the old list, free it.  */
if|if
condition|(
name|old_ops
condition|)
block|{
for|for
control|(
name|ptr
operator|=
name|old_ops
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|delink_imm_use
argument_list|(
name|MAYDEF_OP_PTR
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|old_ops
operator|->
name|next
operator|=
name|free_maydefs
expr_stmt|;
name|free_maydefs
operator|=
name|old_ops
expr_stmt|;
block|}
comment|/* Now set the stmt's operands.  */
name|MAYDEF_OPS
argument_list|(
name|stmt
argument_list|)
operator|=
name|new_list
operator|.
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
block|{
name|unsigned
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|MAYDEF_OPS
argument_list|(
name|stmt
argument_list|)
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|x
operator|++
expr_stmt|;
name|gcc_assert
argument_list|(
name|x
operator|==
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_v_may_defs
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|finalize_ssa_v_may_defs
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|finalize_ssa_v_may_def_ops
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the in_list bits and empty the build array for V_MAY_DEFs.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|cleanup_v_may_defs
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|x
decl_stmt|,
name|num
decl_stmt|;
name|num
operator|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_v_may_defs
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|num
condition|;
name|x
operator|++
control|)
block|{
name|tree
name|t
init|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|build_v_may_defs
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|SSA_NAME
condition|)
block|{
name|var_ann_t
name|ann
init|=
name|var_ann
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|ann
operator|->
name|in_v_may_def_list
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|VEC_truncate
argument_list|(
name|tree
argument_list|,
name|build_v_may_defs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Takes elements from build_vuses and turns them into vuse operands of    STMT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|finalize_ssa_vuse_ops
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|unsigned
name|new_i
decl_stmt|;
name|struct
name|vuse_optype_d
name|new_list
decl_stmt|;
name|vuse_optype_p
name|old_ops
decl_stmt|,
name|ptr
decl_stmt|,
name|last
decl_stmt|;
name|tree
name|act
decl_stmt|;
name|unsigned
name|old_base
decl_stmt|,
name|new_base
decl_stmt|;
name|new_list
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|last
operator|=
operator|&
name|new_list
expr_stmt|;
name|old_ops
operator|=
name|VUSE_OPS
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|new_i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|old_ops
operator|&&
name|new_i
operator|<
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_vuses
argument_list|)
condition|)
block|{
name|act
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|build_vuses
argument_list|,
name|new_i
argument_list|)
expr_stmt|;
name|new_base
operator|=
name|get_name_decl
argument_list|(
name|act
argument_list|)
expr_stmt|;
name|old_base
operator|=
name|get_name_decl
argument_list|(
name|VUSE_OP
argument_list|(
name|old_ops
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_base
operator|==
name|new_base
condition|)
block|{
comment|/* if variables are the same, reuse this node.  */
name|MOVE_HEAD_AFTER
argument_list|(
name|old_ops
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|set_virtual_use_link
argument_list|(
name|VUSE_OP_PTR
argument_list|(
name|last
argument_list|)
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|new_i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old_base
operator|<
name|new_base
condition|)
block|{
comment|/* if old is less than new, old goes to the free list.  */
name|delink_imm_use
argument_list|(
name|USE_OP_PTR
argument_list|(
name|old_ops
argument_list|)
argument_list|)
expr_stmt|;
name|MOVE_HEAD_TO_FREELIST
argument_list|(
name|old_ops
argument_list|,
name|vuse
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a new operand.  */
name|add_vuse_op
argument_list|(
name|stmt
argument_list|,
name|act
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|new_i
operator|++
expr_stmt|;
block|}
block|}
comment|/* If there is anything remaining in the build_vuses list, simply emit it.  */
for|for
control|(
init|;
name|new_i
operator|<
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_vuses
argument_list|)
condition|;
name|new_i
operator|++
control|)
name|add_vuse_op
argument_list|(
name|stmt
argument_list|,
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|build_vuses
argument_list|,
name|new_i
argument_list|)
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|last
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* If there is anything in the old list, free it.  */
if|if
condition|(
name|old_ops
condition|)
block|{
for|for
control|(
name|ptr
operator|=
name|old_ops
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|delink_imm_use
argument_list|(
name|VUSE_OP_PTR
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|old_ops
operator|->
name|next
operator|=
name|free_vuses
expr_stmt|;
name|free_vuses
operator|=
name|old_ops
expr_stmt|;
block|}
comment|/* Now set the stmt's operands.  */
name|VUSE_OPS
argument_list|(
name|stmt
argument_list|)
operator|=
name|new_list
operator|.
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
block|{
name|unsigned
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|VUSE_OPS
argument_list|(
name|stmt
argument_list|)
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|x
operator|++
expr_stmt|;
name|gcc_assert
argument_list|(
name|x
operator|==
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_vuses
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return a new VUSE operand vector, comparing to OLD_OPS_P.  */
end_comment

begin_function
specifier|static
name|void
name|finalize_ssa_vuses
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|unsigned
name|num
decl_stmt|,
name|num_v_may_defs
decl_stmt|;
name|unsigned
name|vuse_index
decl_stmt|;
comment|/* Remove superfluous VUSE operands.  If the statement already has a      V_MAY_DEF operation for a variable 'a', then a VUSE for 'a' is      not needed because V_MAY_DEFs imply a VUSE of the variable.  For      instance, suppose that variable 'a' is aliased:  	      # VUSE<a_2> 	      # a_3 = V_MAY_DEF<a_2> 	      a = a + 1;       The VUSE<a_2> is superfluous because it is implied by the      V_MAY_DEF operation.  */
name|num
operator|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_vuses
argument_list|)
expr_stmt|;
name|num_v_may_defs
operator|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_v_may_defs
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|>
literal|0
operator|&&
name|num_v_may_defs
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|vuse_index
operator|=
literal|0
init|;
name|vuse_index
operator|<
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_vuses
argument_list|)
condition|;
control|)
block|{
name|tree
name|vuse
decl_stmt|;
name|vuse
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|build_vuses
argument_list|,
name|vuse_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|vuse
argument_list|)
operator|!=
name|SSA_NAME
condition|)
block|{
name|var_ann_t
name|ann
init|=
name|var_ann
argument_list|(
name|vuse
argument_list|)
decl_stmt|;
name|ann
operator|->
name|in_vuse_list
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ann
operator|->
name|in_v_may_def_list
condition|)
block|{
name|VEC_ordered_remove
argument_list|(
name|tree
argument_list|,
name|build_vuses
argument_list|,
name|vuse_index
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|vuse_index
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Clear out the in_list bits.  */
for|for
control|(
name|vuse_index
operator|=
literal|0
init|;
name|vuse_index
operator|<
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_vuses
argument_list|)
condition|;
name|vuse_index
operator|++
control|)
block|{
name|tree
name|t
init|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|build_vuses
argument_list|,
name|vuse_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|SSA_NAME
condition|)
block|{
name|var_ann_t
name|ann
init|=
name|var_ann
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|ann
operator|->
name|in_vuse_list
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|finalize_ssa_vuse_ops
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* The V_MAY_DEF build vector wasn't cleaned up because we needed it.  */
name|cleanup_v_may_defs
argument_list|()
expr_stmt|;
comment|/* Free the VUSEs build vector.  */
name|VEC_truncate
argument_list|(
name|tree
argument_list|,
name|build_vuses
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Takes elements from build_v_must_defs and turns them into mustdef operands of    STMT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|finalize_ssa_v_must_def_ops
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|unsigned
name|new_i
decl_stmt|;
name|struct
name|mustdef_optype_d
name|new_list
decl_stmt|;
name|mustdef_optype_p
name|old_ops
decl_stmt|,
name|ptr
decl_stmt|,
name|last
decl_stmt|;
name|tree
name|act
decl_stmt|;
name|unsigned
name|old_base
decl_stmt|,
name|new_base
decl_stmt|;
name|new_list
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|last
operator|=
operator|&
name|new_list
expr_stmt|;
name|old_ops
operator|=
name|MUSTDEF_OPS
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|new_i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|old_ops
operator|&&
name|new_i
operator|<
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_v_must_defs
argument_list|)
condition|)
block|{
name|act
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|build_v_must_defs
argument_list|,
name|new_i
argument_list|)
expr_stmt|;
name|new_base
operator|=
name|get_name_decl
argument_list|(
name|act
argument_list|)
expr_stmt|;
name|old_base
operator|=
name|get_name_decl
argument_list|(
name|MUSTDEF_KILL
argument_list|(
name|old_ops
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_base
operator|==
name|new_base
condition|)
block|{
comment|/* If variables are the same, reuse this node.  */
name|MOVE_HEAD_AFTER
argument_list|(
name|old_ops
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|set_virtual_use_link
argument_list|(
name|MUSTDEF_KILL_PTR
argument_list|(
name|last
argument_list|)
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|new_i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old_base
operator|<
name|new_base
condition|)
block|{
comment|/* If old is less than new, old goes to the free list.  */
name|delink_imm_use
argument_list|(
name|MUSTDEF_KILL_PTR
argument_list|(
name|old_ops
argument_list|)
argument_list|)
expr_stmt|;
name|MOVE_HEAD_TO_FREELIST
argument_list|(
name|old_ops
argument_list|,
name|mustdef
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a new operand.  */
name|add_mustdef_op
argument_list|(
name|stmt
argument_list|,
name|act
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|new_i
operator|++
expr_stmt|;
block|}
block|}
comment|/* If there is anything remaining in the build_v_must_defs list, simply emit it.  */
for|for
control|(
init|;
name|new_i
operator|<
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_v_must_defs
argument_list|)
condition|;
name|new_i
operator|++
control|)
name|add_mustdef_op
argument_list|(
name|stmt
argument_list|,
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|build_v_must_defs
argument_list|,
name|new_i
argument_list|)
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|last
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* If there is anything in the old list, free it.  */
if|if
condition|(
name|old_ops
condition|)
block|{
for|for
control|(
name|ptr
operator|=
name|old_ops
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|delink_imm_use
argument_list|(
name|MUSTDEF_KILL_PTR
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|old_ops
operator|->
name|next
operator|=
name|free_mustdefs
expr_stmt|;
name|free_mustdefs
operator|=
name|old_ops
expr_stmt|;
block|}
comment|/* Now set the stmt's operands.  */
name|MUSTDEF_OPS
argument_list|(
name|stmt
argument_list|)
operator|=
name|new_list
operator|.
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
block|{
name|unsigned
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|MUSTDEF_OPS
argument_list|(
name|stmt
argument_list|)
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|x
operator|++
expr_stmt|;
name|gcc_assert
argument_list|(
name|x
operator|==
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_v_must_defs
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|finalize_ssa_v_must_defs
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
comment|/* In the presence of subvars, there may be more than one V_MUST_DEF      per statement (one for each subvar).  It is a bit expensive to      verify that all must-defs in a statement belong to subvars if      there is more than one must-def, so we don't do it.  Suffice to      say, if you reach here without having subvars, and have num>1,      you have hit a bug.  */
name|finalize_ssa_v_must_def_ops
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|VEC_truncate
argument_list|(
name|tree
argument_list|,
name|build_v_must_defs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finalize all the build vectors, fill the new ones into INFO.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|finalize_ssa_stmt_operands
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|finalize_ssa_defs
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|finalize_ssa_uses
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|finalize_ssa_v_must_defs
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|finalize_ssa_v_may_defs
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|finalize_ssa_vuses
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start the process of building up operands vectors in INFO.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|start_ssa_stmt_operands
parameter_list|(
name|void
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_defs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_uses
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_vuses
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_v_may_defs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_v_must_defs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add DEF_P to the list of pointers to operands.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|append_def
parameter_list|(
name|tree
modifier|*
name|def_p
parameter_list|)
block|{
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|build_defs
argument_list|,
operator|(
name|tree
operator|)
name|def_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add USE_P to the list of pointers to operands.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|append_use
parameter_list|(
name|tree
modifier|*
name|use_p
parameter_list|)
block|{
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|build_uses
argument_list|,
operator|(
name|tree
operator|)
name|use_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a new virtual may def for variable VAR to the build array.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|append_v_may_def
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|SSA_NAME
condition|)
block|{
name|var_ann_t
name|ann
init|=
name|get_var_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
comment|/* Don't allow duplicate entries.  */
if|if
condition|(
name|ann
operator|->
name|in_v_may_def_list
condition|)
return|return;
name|ann
operator|->
name|in_v_may_def_list
operator|=
literal|1
expr_stmt|;
block|}
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|build_v_may_defs
argument_list|,
operator|(
name|tree
operator|)
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add VAR to the list of virtual uses.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|append_vuse
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
comment|/* Don't allow duplicate entries.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|SSA_NAME
condition|)
block|{
name|var_ann_t
name|ann
init|=
name|get_var_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|ann
operator|->
name|in_vuse_list
operator|||
name|ann
operator|->
name|in_v_may_def_list
condition|)
return|return;
name|ann
operator|->
name|in_vuse_list
operator|=
literal|1
expr_stmt|;
block|}
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|build_vuses
argument_list|,
operator|(
name|tree
operator|)
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add VAR to the list of virtual must definitions for INFO.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|append_v_must_def
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
comment|/* Don't allow duplicate entries.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_v_must_defs
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|var
operator|==
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|build_v_must_defs
argument_list|,
name|i
argument_list|)
condition|)
return|return;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|build_v_must_defs
argument_list|,
operator|(
name|tree
operator|)
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* REF is a tree that contains the entire pointer dereference    expression, if available, or NULL otherwise.  ALIAS is the variable    we are asking if REF can access.  OFFSET and SIZE come from the    memory access expression that generated this virtual operand.  */
end_comment

begin_function
specifier|static
name|bool
name|access_can_touch_variable
parameter_list|(
name|tree
name|ref
parameter_list|,
name|tree
name|alias
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|,
name|HOST_WIDE_INT
name|size
parameter_list|)
block|{
name|bool
name|offsetgtz
init|=
name|offset
operator|>
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|uoffset
init|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|offset
decl_stmt|;
name|tree
name|base
init|=
name|ref
condition|?
name|get_base_address
argument_list|(
name|ref
argument_list|)
else|:
name|NULL
decl_stmt|;
comment|/* If ALIAS is .GLOBAL_VAR then the memory reference REF must be      using a call-clobbered memory tag.  By definition, call-clobbered      memory tags can always touch .GLOBAL_VAR.  */
if|if
condition|(
name|alias
operator|==
name|global_var
condition|)
return|return
name|true
return|;
comment|/* We cannot prune nonlocal aliases because they are not type      specific.  */
if|if
condition|(
name|alias
operator|==
name|nonlocal_all
condition|)
return|return
name|true
return|;
comment|/* If ALIAS is an SFT, it can't be touched if the offset           and size of the access is not overlapping with the SFT offset and      size.  This is only true if we are accessing through a pointer      to a type that is the same as SFT_PARENT_VAR.  Otherwise, we may      be accessing through a pointer to some substruct of the      structure, and if we try to prune there, we will have the wrong      offset, and get the wrong answer.      i.e., we can't prune without more work if we have something like       struct gcc_target      {        struct asm_out        {          const char *byte_op; 	 struct asm_int_op 	 {     	   const char *hi; 	 } aligned_op;        } asm_out;      } targetm;            foo =&targetm.asm_out.aligned_op;      return foo->hi;       SFT.1, which represents hi, will have SFT_OFFSET=32 because in      terms of SFT_PARENT_VAR, that is where it is.      However, the access through the foo pointer will be at offset 0.  */
if|if
condition|(
name|size
operator|!=
operator|-
literal|1
operator|&&
name|TREE_CODE
argument_list|(
name|alias
argument_list|)
operator|==
name|STRUCT_FIELD_TAG
operator|&&
name|base
operator|&&
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|SFT_PARENT_VAR
argument_list|(
name|alias
argument_list|)
argument_list|)
operator|&&
operator|!
name|overlap_subvar
argument_list|(
name|offset
argument_list|,
name|size
argument_list|,
name|alias
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ACCESS_DEBUGGING
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Access to "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" may not touch "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|alias
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" in function %s\n"
argument_list|,
name|get_name
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|false
return|;
block|}
comment|/* Without strict aliasing, it is impossible for a component access      through a pointer to touch a random variable, unless that      variable *is* a structure or a pointer.       That is, given p->c, and some random global variable b,      there is no legal way that p->c could be an access to b.            Without strict aliasing on, we consider it legal to do something      like:       struct foos { int l; };      int foo;      static struct foos *getfoo(void);      int main (void)      {        struct foos *f = getfoo();        f->l = 1;        foo = 2;        if (f->l == 1)          abort();        exit(0);      }      static struct foos *getfoo(void)           { return (struct foos *)&foo; }            (taken from 20000623-1.c)       The docs also say/imply that access through union pointers      is legal (but *not* if you take the address of the union member,      i.e. the inverse), such that you can do       typedef union {        int d;      } U;       int rv;      void breakme()      {        U *rv0;        U *pretmp = (U*)&rv;        rv0 = pretmp;        rv0->d = 42;          }      To implement this, we just punt on accesses through union      pointers entirely.   */
elseif|else
if|if
condition|(
name|ref
operator|&&
name|flag_strict_aliasing
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|!=
name|INDIRECT_REF
operator|&&
operator|!
name|MTAG_P
argument_list|(
name|alias
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|INDIRECT_REF
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
operator|!=
name|UNION_TYPE
operator|)
operator|&&
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|alias
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|alias
argument_list|)
argument_list|)
operator|!=
name|COMPLEX_TYPE
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|alias
argument_list|)
argument_list|)
comment|/* When the struct has may_alias attached to it, we need not to 	      return true.  */
operator|&&
name|get_alias_set
argument_list|(
name|base
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ACCESS_DEBUGGING
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Access to "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" may not touch "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|alias
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" in function %s\n"
argument_list|,
name|get_name
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|false
return|;
block|}
comment|/* If the offset of the access is greater than the size of one of      the possible aliases, it can't be touching that alias, because it      would be past the end of the structure.  */
elseif|else
if|if
condition|(
name|ref
operator|&&
name|flag_strict_aliasing
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|!=
name|INDIRECT_REF
operator|&&
operator|!
name|MTAG_P
argument_list|(
name|alias
argument_list|)
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|alias
argument_list|)
argument_list|)
operator|&&
name|offsetgtz
operator|&&
name|DECL_SIZE
argument_list|(
name|alias
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|alias
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|uoffset
operator|>
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|alias
argument_list|)
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ACCESS_DEBUGGING
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Access to "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" may not touch "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|alias
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" in function %s\n"
argument_list|,
name|get_name
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add VAR to the virtual operands array.  FLAGS is as in    get_expr_operands.  FULL_REF is a tree that contains the entire    pointer dereference expression, if available, or NULL otherwise.    OFFSET and SIZE come from the memory access expression that    generated this virtual operand.  FOR_CLOBBER is true is this is    adding a virtual operand for a call clobber.  */
end_comment

begin_function
specifier|static
name|void
name|add_virtual_operand
parameter_list|(
name|tree
name|var
parameter_list|,
name|stmt_ann_t
name|s_ann
parameter_list|,
name|int
name|flags
parameter_list|,
name|tree
name|full_ref
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|,
name|HOST_WIDE_INT
name|size
parameter_list|,
name|bool
name|for_clobber
parameter_list|)
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|aliases
expr_stmt|;
name|tree
name|sym
decl_stmt|;
name|var_ann_t
name|v_ann
decl_stmt|;
name|sym
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|?
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
else|:
name|var
operator|)
expr_stmt|;
name|v_ann
operator|=
name|var_ann
argument_list|(
name|sym
argument_list|)
expr_stmt|;
comment|/* Mark statements with volatile operands.  Optimizers should back      off from statements having volatile operands.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|sym
argument_list|)
operator|&&
name|s_ann
condition|)
name|s_ann
operator|->
name|has_volatile_ops
operator|=
name|true
expr_stmt|;
comment|/* If the variable cannot be modified and this is a V_MAY_DEF change      it into a VUSE.  This happens when read-only variables are marked      call-clobbered and/or aliased to writable variables.  So we only      check that this only happens on non-specific stores.       Note that if this is a specific store, i.e. associated with a      modify_expr, then we can't suppress the V_MAY_DEF, lest we run      into validation problems.       This can happen when programs cast away const, leaving us with a      store to read-only memory.  If the statement is actually executed      at runtime, then the program is ill formed.  If the statement is      not executed then all is well.  At the very least, we cannot ICE.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|opf_non_specific
operator|)
operator|&&
name|unmodifiable_var_p
argument_list|(
name|var
argument_list|)
condition|)
name|flags
operator|&=
operator|~
operator|(
name|opf_is_def
operator||
name|opf_kill_def
operator|)
expr_stmt|;
comment|/* The variable is not a GIMPLE register.  Add it (or its aliases) to      virtual operands, unless the caller has specifically requested      not to add virtual operands (used when adding operands inside an      ADDR_EXPR expression).  */
if|if
condition|(
name|flags
operator|&
name|opf_no_vops
condition|)
return|return;
name|aliases
operator|=
name|v_ann
operator|->
name|may_aliases
expr_stmt|;
if|if
condition|(
name|aliases
operator|==
name|NULL
condition|)
block|{
comment|/* The variable is not aliased or it is an alias tag.  */
if|if
condition|(
name|flags
operator|&
name|opf_is_def
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|opf_kill_def
condition|)
block|{
comment|/* V_MUST_DEF for non-aliased, non-GIMPLE register  		 variable definitions.  */
name|gcc_assert
argument_list|(
operator|!
name|MTAG_P
argument_list|(
name|var
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|STRUCT_FIELD_TAG
argument_list|)
expr_stmt|;
name|append_v_must_def
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add a V_MAY_DEF for call-clobbered variables and 		 memory tags.  */
name|append_v_may_def
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|append_vuse
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|i
decl_stmt|;
name|tree
name|al
decl_stmt|;
comment|/* The variable is aliased.  Add its aliases to the virtual 	 operands.  */
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|aliases
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|opf_is_def
condition|)
block|{
name|bool
name|none_added
init|=
name|true
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|aliases
argument_list|,
name|i
argument_list|,
name|al
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|access_can_touch_variable
argument_list|(
name|full_ref
argument_list|,
name|al
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
condition|)
continue|continue;
name|none_added
operator|=
name|false
expr_stmt|;
name|append_v_may_def
argument_list|(
name|al
argument_list|)
expr_stmt|;
block|}
comment|/* If the variable is also an alias tag, add a virtual 	     operand for it, otherwise we will miss representing 	     references to the members of the variable's alias set.	      	     This fixes the bug in gcc.c-torture/execute/20020503-1.c. 	      	     It is also necessary to add bare defs on clobbers for 	     SMT's, so that bare SMT uses caused by pruning all the 	     aliases will link up properly with calls.   In order to 	     keep the number of these bare defs we add down to the 	     minimum necessary, we keep track of which SMT's were used 	     alone in statement vdefs or VUSEs.  */
if|if
condition|(
name|v_ann
operator|->
name|is_aliased
operator|||
name|none_added
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SYMBOL_MEMORY_TAG
operator|&&
name|for_clobber
operator|&&
name|SMT_USED_ALONE
argument_list|(
name|var
argument_list|)
operator|)
condition|)
block|{
comment|/* Every bare SMT def we add should have SMT_USED_ALONE 		 set on it, or else we will get the wrong answer on 		 clobbers.  Sadly, this assertion trips on code that 		 violates strict aliasing rules, because they *do* get 		 the clobbers wrong, since it is illegal code.  As a 		 result, we currently only enable it for aliasing 		 debugging.  Someone might wish to turn this code into 		 a nice strict-aliasing warning, since we *know* it 		 will get the wrong answer...  */
ifdef|#
directive|ifdef
name|ACCESS_DEBUGGING
if|if
condition|(
name|none_added
operator|&&
operator|!
name|updating_used_alone
operator|&&
name|aliases_computed_p
operator|&&
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SYMBOL_MEMORY_TAG
condition|)
name|gcc_assert
argument_list|(
name|SMT_USED_ALONE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|append_v_may_def
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|bool
name|none_added
init|=
name|true
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|aliases
argument_list|,
name|i
argument_list|,
name|al
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|access_can_touch_variable
argument_list|(
name|full_ref
argument_list|,
name|al
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
condition|)
continue|continue;
name|none_added
operator|=
name|false
expr_stmt|;
name|append_vuse
argument_list|(
name|al
argument_list|)
expr_stmt|;
block|}
comment|/* Similarly, append a virtual uses for VAR itself, when 	     it is an alias tag.  */
if|if
condition|(
name|v_ann
operator|->
name|is_aliased
operator|||
name|none_added
condition|)
name|append_vuse
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add *VAR_P to the appropriate operand array for S_ANN.  FLAGS is as in    get_expr_operands.  If *VAR_P is a GIMPLE register, it will be added to    the statement's real operands, otherwise it is added to virtual    operands.  */
end_comment

begin_function
specifier|static
name|void
name|add_stmt_operand
parameter_list|(
name|tree
modifier|*
name|var_p
parameter_list|,
name|stmt_ann_t
name|s_ann
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|bool
name|is_real_op
decl_stmt|;
name|tree
name|var
decl_stmt|,
name|sym
decl_stmt|;
name|var_ann_t
name|v_ann
decl_stmt|;
name|var
operator|=
operator|*
name|var_p
expr_stmt|;
name|gcc_assert
argument_list|(
name|SSA_VAR_P
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|is_real_op
operator|=
name|is_gimple_reg
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* If this is a real operand, the operand is either an SSA name or a       decl.  Virtual operands may only be decls.  */
name|gcc_assert
argument_list|(
name|is_real_op
operator|||
name|DECL_P
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|?
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
else|:
name|var
operator|)
expr_stmt|;
name|v_ann
operator|=
name|var_ann
argument_list|(
name|sym
argument_list|)
expr_stmt|;
comment|/* Mark statements with volatile operands.  Optimizers should back      off from statements having volatile operands.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|sym
argument_list|)
operator|&&
name|s_ann
condition|)
name|s_ann
operator|->
name|has_volatile_ops
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|is_real_op
condition|)
block|{
comment|/* The variable is a GIMPLE register.  Add it to real operands.  */
if|if
condition|(
name|flags
operator|&
name|opf_is_def
condition|)
name|append_def
argument_list|(
name|var_p
argument_list|)
expr_stmt|;
else|else
name|append_use
argument_list|(
name|var_p
argument_list|)
expr_stmt|;
block|}
else|else
name|add_virtual_operand
argument_list|(
name|var
argument_list|,
name|s_ann
argument_list|,
name|flags
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of get_expr_operands to handle INDIRECT_REF,    ALIGN_INDIRECT_REF and MISALIGNED_INDIRECT_REF.       STMT is the statement being processed, EXPR is the INDIRECT_REF       that got us here.        FLAGS is as in get_expr_operands.     FULL_REF contains the full pointer dereference expression, if we       have it, or NULL otherwise.     OFFSET and SIZE are the location of the access inside the       dereferenced pointer, if known.     RECURSE_ON_BASE should be set to true if we want to continue       calling get_expr_operands on the base pointer, and false if       something else will do it for us.  */
end_comment

begin_function
specifier|static
name|void
name|get_indirect_ref_operands
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|expr
parameter_list|,
name|int
name|flags
parameter_list|,
name|tree
name|full_ref
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|,
name|HOST_WIDE_INT
name|size
parameter_list|,
name|bool
name|recurse_on_base
parameter_list|)
block|{
name|tree
modifier|*
name|pptr
init|=
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|ptr
init|=
operator|*
name|pptr
decl_stmt|;
name|stmt_ann_t
name|s_ann
init|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
comment|/* Stores into INDIRECT_REF operands are never killing definitions.  */
name|flags
operator|&=
operator|~
name|opf_kill_def
expr_stmt|;
if|if
condition|(
name|SSA_VAR_P
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
name|struct
name|ptr_info_def
modifier|*
name|pi
init|=
name|NULL
decl_stmt|;
comment|/* If PTR has flow-sensitive points-to information, use it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ptr
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|(
name|pi
operator|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|ptr
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|pi
operator|->
name|name_mem_tag
condition|)
block|{
comment|/* PTR has its own memory tag.  Use it.  */
name|add_virtual_operand
argument_list|(
name|pi
operator|->
name|name_mem_tag
argument_list|,
name|s_ann
argument_list|,
name|flags
argument_list|,
name|full_ref
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If PTR is not an SSA_NAME or it doesn't have a name 	     tag, use its symbol memory tag.  */
name|var_ann_t
name|v_ann
decl_stmt|;
comment|/* If we are emitting debugging dumps, display a warning if 	     PTR is an SSA_NAME with no flow-sensitive alias 	     information.  That means that we may need to compute 	     aliasing again.  */
if|if
condition|(
name|dump_file
operator|&&
name|TREE_CODE
argument_list|(
name|ptr
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|pi
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"NOTE: no flow-sensitive alias info for "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|ptr
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" in "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ptr
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|ptr
operator|=
name|SSA_NAME_VAR
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|v_ann
operator|=
name|var_ann
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|v_ann
operator|->
name|symbol_mem_tag
condition|)
name|add_virtual_operand
argument_list|(
name|v_ann
operator|->
name|symbol_mem_tag
argument_list|,
name|s_ann
argument_list|,
name|flags
argument_list|,
name|full_ref
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ptr
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* If a constant is used as a pointer, we can't generate a real 	 operand for it but we mark the statement volatile to prevent 	 optimizations from messing things up.  */
if|if
condition|(
name|s_ann
condition|)
name|s_ann
operator|->
name|has_volatile_ops
operator|=
name|true
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Ok, this isn't even is_gimple_min_invariant.  Something's broke.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* If requested, add a USE operand for the base pointer.  */
if|if
condition|(
name|recurse_on_base
condition|)
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
name|pptr
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of get_expr_operands to handle TARGET_MEM_REF.  */
end_comment

begin_function
specifier|static
name|void
name|get_tmr_operands
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|expr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|tag
init|=
name|TMR_TAG
argument_list|(
name|expr
argument_list|)
decl_stmt|,
name|ref
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|,
name|size
decl_stmt|,
name|maxsize
decl_stmt|;
name|subvar_t
name|svars
decl_stmt|,
name|sv
decl_stmt|;
name|stmt_ann_t
name|s_ann
init|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
comment|/* First record the real operands.  */
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TMR_BASE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TMR_INDEX
argument_list|(
name|expr
argument_list|)
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
comment|/* MEM_REFs should never be killing.  */
name|flags
operator|&=
operator|~
name|opf_kill_def
expr_stmt|;
if|if
condition|(
name|TMR_SYMBOL
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|stmt_ann_t
name|ann
init|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|add_to_addressable_set
argument_list|(
name|TMR_SYMBOL
argument_list|(
name|expr
argument_list|)
argument_list|,
operator|&
name|ann
operator|->
name|addresses_taken
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tag
condition|)
block|{
comment|/* Something weird, so ensure that we will be careful.  */
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
operator|->
name|has_volatile_ops
operator|=
name|true
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DECL_P
argument_list|(
name|tag
argument_list|)
condition|)
block|{
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|tag
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
name|ref
operator|=
name|get_ref_base_and_extent
argument_list|(
name|tag
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|maxsize
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ref
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|svars
operator|=
name|get_subvars_for_var
argument_list|(
name|ref
argument_list|)
expr_stmt|;
for|for
control|(
name|sv
operator|=
name|svars
init|;
name|sv
condition|;
name|sv
operator|=
name|sv
operator|->
name|next
control|)
block|{
name|bool
name|exact
decl_stmt|;
if|if
condition|(
name|overlap_subvar
argument_list|(
name|offset
argument_list|,
name|maxsize
argument_list|,
name|sv
operator|->
name|var
argument_list|,
operator|&
name|exact
argument_list|)
condition|)
block|{
name|int
name|subvar_flags
init|=
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|exact
operator|||
name|size
operator|!=
name|maxsize
condition|)
name|subvar_flags
operator|&=
operator|~
name|opf_kill_def
expr_stmt|;
name|add_stmt_operand
argument_list|(
operator|&
name|sv
operator|->
name|var
argument_list|,
name|s_ann
argument_list|,
name|subvar_flags
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add clobbering definitions for .GLOBAL_VAR or for each of the call    clobbered variables in the function.  */
end_comment

begin_function
specifier|static
name|void
name|add_call_clobber_ops
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|callee
parameter_list|)
block|{
name|unsigned
name|u
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|stmt_ann_t
name|s_ann
init|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|bitmap
name|not_read_b
decl_stmt|,
name|not_written_b
decl_stmt|;
comment|/* Functions that are not const, pure or never return may clobber      call-clobbered variables.  */
if|if
condition|(
name|s_ann
condition|)
name|s_ann
operator|->
name|makes_clobbering_call
operator|=
name|true
expr_stmt|;
comment|/* If we created .GLOBAL_VAR earlier, just use it.  See compute_may_aliases       for the heuristic used to decide whether to create .GLOBAL_VAR or not.  */
if|if
condition|(
name|global_var
condition|)
block|{
name|add_stmt_operand
argument_list|(
operator|&
name|global_var
argument_list|,
name|s_ann
argument_list|,
name|opf_is_def
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get info for local and module level statics.  There is a bit      set for each static if the call being processed does not read      or write that variable.  */
name|not_read_b
operator|=
name|callee
condition|?
name|ipa_reference_get_not_read_global
argument_list|(
name|callee
argument_list|)
else|:
name|NULL
expr_stmt|;
name|not_written_b
operator|=
name|callee
condition|?
name|ipa_reference_get_not_written_global
argument_list|(
name|callee
argument_list|)
else|:
name|NULL
expr_stmt|;
comment|/* Add a V_MAY_DEF operand for every call clobbered variable.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|call_clobbered_vars
argument_list|,
literal|0
argument_list|,
argument|u
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|var
init|=
name|referenced_var_lookup
argument_list|(
name|u
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|escape_mask
init|=
name|var_ann
argument_list|(
name|var
argument_list|)
operator|->
name|escape_mask
decl_stmt|;
name|tree
name|real_var
init|=
name|var
decl_stmt|;
name|bool
name|not_read
decl_stmt|;
name|bool
name|not_written
decl_stmt|;
comment|/* Not read and not written are computed on regular vars, not 	 subvars, so look at the parent var if this is an SFT. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|STRUCT_FIELD_TAG
condition|)
name|real_var
operator|=
name|SFT_PARENT_VAR
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|not_read
operator|=
name|not_read_b
condition|?
name|bitmap_bit_p
argument_list|(
name|not_read_b
argument_list|,
name|DECL_UID
argument_list|(
name|real_var
argument_list|)
argument_list|)
else|:
name|false
expr_stmt|;
name|not_written
operator|=
name|not_written_b
condition|?
name|bitmap_bit_p
argument_list|(
name|not_written_b
argument_list|,
name|DECL_UID
argument_list|(
name|real_var
argument_list|)
argument_list|)
else|:
name|false
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|unmodifiable_var_p
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|clobber_stats
operator|.
name|clobbered_vars
operator|++
expr_stmt|;
comment|/* See if this variable is really clobbered by this function.  */
comment|/* Trivial case: Things escaping only to pure/const are not 	 clobbered by non-pure-const, and only read by pure/const. */
if|if
condition|(
operator|(
name|escape_mask
operator|&
operator|~
operator|(
name|ESCAPE_TO_PURE_CONST
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|tree
name|call
init|=
name|get_call_expr_in
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|call_expr_flags
argument_list|(
name|call
argument_list|)
operator|&
operator|(
name|ECF_CONST
operator||
name|ECF_PURE
operator|)
condition|)
block|{
name|add_stmt_operand
argument_list|(
operator|&
name|var
argument_list|,
name|s_ann
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
name|clobber_stats
operator|.
name|unescapable_clobbers_avoided
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|clobber_stats
operator|.
name|unescapable_clobbers_avoided
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|not_written
condition|)
block|{
name|clobber_stats
operator|.
name|static_write_clobbers_avoided
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|not_read
condition|)
name|add_stmt_operand
argument_list|(
operator|&
name|var
argument_list|,
name|s_ann
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
else|else
name|clobber_stats
operator|.
name|static_read_clobbers_avoided
operator|++
expr_stmt|;
block|}
else|else
name|add_virtual_operand
argument_list|(
name|var
argument_list|,
name|s_ann
argument_list|,
name|opf_is_def
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add VUSE operands for .GLOBAL_VAR or all call clobbered variables in the    function.  */
end_comment

begin_function
specifier|static
name|void
name|add_call_read_ops
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|callee
parameter_list|)
block|{
name|unsigned
name|u
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|stmt_ann_t
name|s_ann
init|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|bitmap
name|not_read_b
decl_stmt|;
comment|/* if the function is not pure, it may reference memory.  Add      a VUSE for .GLOBAL_VAR if it has been created.  See add_referenced_var      for the heuristic used to decide whether to create .GLOBAL_VAR.  */
if|if
condition|(
name|global_var
condition|)
block|{
name|add_stmt_operand
argument_list|(
operator|&
name|global_var
argument_list|,
name|s_ann
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
return|return;
block|}
name|not_read_b
operator|=
name|callee
condition|?
name|ipa_reference_get_not_read_global
argument_list|(
name|callee
argument_list|)
else|:
name|NULL
expr_stmt|;
comment|/* Add a VUSE for each call-clobbered variable.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|call_clobbered_vars
argument_list|,
literal|0
argument_list|,
argument|u
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|var
init|=
name|referenced_var
argument_list|(
name|u
argument_list|)
decl_stmt|;
name|tree
name|real_var
init|=
name|var
decl_stmt|;
name|bool
name|not_read
decl_stmt|;
name|clobber_stats
operator|.
name|readonly_clobbers
operator|++
expr_stmt|;
comment|/* Not read and not written are computed on regular vars, not 	 subvars, so look at the parent var if this is an SFT. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|STRUCT_FIELD_TAG
condition|)
name|real_var
operator|=
name|SFT_PARENT_VAR
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|not_read
operator|=
name|not_read_b
condition|?
name|bitmap_bit_p
argument_list|(
name|not_read_b
argument_list|,
name|DECL_UID
argument_list|(
name|real_var
argument_list|)
argument_list|)
else|:
name|false
expr_stmt|;
if|if
condition|(
name|not_read
condition|)
block|{
name|clobber_stats
operator|.
name|static_readonly_clobbers_avoided
operator|++
expr_stmt|;
continue|continue;
block|}
name|add_stmt_operand
argument_list|(
operator|&
name|var
argument_list|,
name|s_ann
argument_list|,
name|opf_none
operator||
name|opf_non_specific
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of get_expr_operands to handle CALL_EXPR.  */
end_comment

begin_function
specifier|static
name|void
name|get_call_expr_operands
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|op
decl_stmt|;
name|int
name|call_flags
init|=
name|call_expr_flags
argument_list|(
name|expr
argument_list|)
decl_stmt|;
comment|/* If aliases have been computed already, add V_MAY_DEF or V_USE      operands for all the symbols that have been found to be      call-clobbered.            Note that if aliases have not been computed, the global effects      of calls will not be included in the SSA web. This is fine      because no optimizer should run before aliases have been      computed.  By not bothering with virtual operands for CALL_EXPRs      we avoid adding superfluous virtual operands, which can be a      significant compile time sink (See PR 15855).  */
if|if
condition|(
name|aliases_computed_p
operator|&&
operator|!
name|bitmap_empty_p
argument_list|(
name|call_clobbered_vars
argument_list|)
operator|&&
operator|!
operator|(
name|call_flags
operator|&
name|ECF_NOVOPS
operator|)
condition|)
block|{
comment|/* A 'pure' or a 'const' function never call-clobbers anything.  	 A 'noreturn' function might, but since we don't return anyway  	 there is no point in recording that.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
operator|&&
operator|!
operator|(
name|call_flags
operator|&
operator|(
name|ECF_PURE
operator||
name|ECF_CONST
operator||
name|ECF_NORETURN
operator|)
operator|)
condition|)
name|add_call_clobber_ops
argument_list|(
name|stmt
argument_list|,
name|get_callee_fndecl
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|call_flags
operator|&
name|ECF_CONST
operator|)
condition|)
name|add_call_read_ops
argument_list|(
name|stmt
argument_list|,
name|get_callee_fndecl
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Find uses in the called function.  */
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
for|for
control|(
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
init|;
name|op
condition|;
name|op
operator|=
name|TREE_CHAIN
argument_list|(
name|op
argument_list|)
control|)
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_VALUE
argument_list|(
name|op
argument_list|)
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan operands in the ASM_EXPR stmt referred to in INFO.  */
end_comment

begin_function
specifier|static
name|void
name|get_asm_expr_operands
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|stmt_ann_t
name|s_ann
init|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|ASM_OUTPUTS
argument_list|(
name|stmt
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|oconstraints
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|noutputs
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|link
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
name|bool
name|allows_mem
decl_stmt|,
name|allows_reg
decl_stmt|,
name|is_inout
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|link
operator|=
name|ASM_OUTPUTS
argument_list|(
name|stmt
argument_list|)
init|;
name|link
condition|;
operator|++
name|i
operator|,
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|oconstraints
index|[
name|i
index|]
operator|=
name|constraint
expr_stmt|;
name|parse_output_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|,
operator|&
name|is_inout
argument_list|)
expr_stmt|;
comment|/* This should have been split in gimplify_asm_expr.  */
name|gcc_assert
argument_list|(
operator|!
name|allows_reg
operator|||
operator|!
name|is_inout
argument_list|)
expr_stmt|;
comment|/* Memory operands are addressable.  Note that STMT needs the 	 address of this operand.  */
if|if
condition|(
operator|!
name|allows_reg
operator|&&
name|allows_mem
condition|)
block|{
name|tree
name|t
init|=
name|get_base_address
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|&&
name|DECL_P
argument_list|(
name|t
argument_list|)
operator|&&
name|s_ann
condition|)
name|add_to_addressable_set
argument_list|(
name|t
argument_list|,
operator|&
name|s_ann
operator|->
name|addresses_taken
argument_list|)
expr_stmt|;
block|}
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|opf_is_def
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|ASM_INPUTS
argument_list|(
name|stmt
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parse_input_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|noutputs
argument_list|,
literal|0
argument_list|,
name|oconstraints
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|)
expr_stmt|;
comment|/* Memory operands are addressable.  Note that STMT needs the 	 address of this operand.  */
if|if
condition|(
operator|!
name|allows_reg
operator|&&
name|allows_mem
condition|)
block|{
name|tree
name|t
init|=
name|get_base_address
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|&&
name|DECL_P
argument_list|(
name|t
argument_list|)
operator|&&
name|s_ann
condition|)
name|add_to_addressable_set
argument_list|(
name|t
argument_list|,
operator|&
name|s_ann
operator|->
name|addresses_taken
argument_list|)
expr_stmt|;
block|}
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Clobber memory for asm ("" : : : "memory");  */
for|for
control|(
name|link
operator|=
name|ASM_CLOBBERS
argument_list|(
name|stmt
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|,
literal|"memory"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* Clobber all call-clobbered variables (or .GLOBAL_VAR if we 	   decided to group them).  */
if|if
condition|(
name|global_var
condition|)
name|add_stmt_operand
argument_list|(
operator|&
name|global_var
argument_list|,
name|s_ann
argument_list|,
name|opf_is_def
argument_list|)
expr_stmt|;
else|else
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|call_clobbered_vars
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|var
init|=
name|referenced_var
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|add_stmt_operand
argument_list|(
operator|&
name|var
argument_list|,
name|s_ann
argument_list|,
name|opf_is_def
operator||
name|opf_non_specific
argument_list|)
expr_stmt|;
block|}
comment|/* Now clobber all addressables.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|addressable_vars
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|var
init|=
name|referenced_var
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|/* Subvars are explicitly represented in this list, so 		 we don't need the original to be added to the clobber 		 ops, but the original *will* be in this list because  		 we keep the addressability of the original 		 variable up-to-date so we don't screw up the rest of 		 the backend.  */
if|if
condition|(
name|var_can_have_subvars
argument_list|(
name|var
argument_list|)
operator|&&
name|get_subvars_for_var
argument_list|(
name|var
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
name|add_stmt_operand
argument_list|(
operator|&
name|var
argument_list|,
name|s_ann
argument_list|,
name|opf_is_def
operator||
name|opf_non_specific
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Scan operands for the assignment expression EXPR in statement STMT.  */
end_comment

begin_function
specifier|static
name|void
name|get_modify_expr_operands
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
comment|/* First get operands from the RHS.  */
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
comment|/* For the LHS, use a regular definition (OPF_IS_DEF) for GIMPLE      registers.  If the LHS is a store to memory, we will either need      a preserving definition (V_MAY_DEF) or a killing definition      (V_MUST_DEF).       Preserving definitions are those that modify a part of an      aggregate object for which no subvars have been computed (or the      reference does not correspond exactly to one of them). Stores      through a pointer are also represented with V_MAY_DEF operators.       The determination of whether to use a preserving or a killing      definition is done while scanning the LHS of the assignment.  By      default, assume that we will emit a V_MUST_DEF.  */
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opf_is_def
operator||
name|opf_kill_def
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recursively scan the expression pointed to by EXPR_P in statement    STMT.  FLAGS is one of the OPF_* constants modifying how to    interpret the operands found.  */
end_comment

begin_function
specifier|static
name|void
name|get_expr_operands
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
modifier|*
name|expr_p
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|enum
name|tree_code_class
name|class
decl_stmt|;
name|tree
name|expr
init|=
operator|*
name|expr_p
decl_stmt|;
name|stmt_ann_t
name|s_ann
init|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
return|return;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|class
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
comment|/* Taking the address of a variable does not represent a 	 reference to it, but the fact that the statement takes its 	 address will be of interest to some passes (e.g. alias 	 resolution).  */
name|add_to_addressable_set
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|s_ann
operator|->
name|addresses_taken
argument_list|)
expr_stmt|;
comment|/* If the address is invariant, there may be no interesting 	 variable references inside.  */
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|expr
argument_list|)
condition|)
return|return;
comment|/* Otherwise, there may be variables referenced inside but there 	 should be no VUSEs created, since the referenced objects are 	 not really accessed.  The only operands that we should find 	 here are ARRAY_REF indices which will always be real operands 	 (GIMPLE does not allow non-registers as array indices).  */
name|flags
operator||=
name|opf_no_vops
expr_stmt|;
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
case|case
name|SSA_NAME
case|:
case|case
name|STRUCT_FIELD_TAG
case|:
case|case
name|SYMBOL_MEMORY_TAG
case|:
case|case
name|NAME_MEMORY_TAG
case|:
name|add_stmt_operand
argument_list|(
name|expr_p
argument_list|,
name|s_ann
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
block|{
name|subvar_t
name|svars
decl_stmt|;
comment|/* Add the subvars for a variable, if it has subvars, to DEFS 	   or USES.  Otherwise, add the variable itself.  Whether it 	   goes to USES or DEFS depends on the operand flags.  */
if|if
condition|(
name|var_can_have_subvars
argument_list|(
name|expr
argument_list|)
operator|&&
operator|(
name|svars
operator|=
name|get_subvars_for_var
argument_list|(
name|expr
argument_list|)
operator|)
condition|)
block|{
name|subvar_t
name|sv
decl_stmt|;
for|for
control|(
name|sv
operator|=
name|svars
init|;
name|sv
condition|;
name|sv
operator|=
name|sv
operator|->
name|next
control|)
name|add_stmt_operand
argument_list|(
operator|&
name|sv
operator|->
name|var
argument_list|,
name|s_ann
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
name|add_stmt_operand
argument_list|(
name|expr_p
argument_list|,
name|s_ann
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|MISALIGNED_INDIRECT_REF
case|:
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|ALIGN_INDIRECT_REF
case|:
case|case
name|INDIRECT_REF
case|:
name|get_indirect_ref_operands
argument_list|(
name|stmt
argument_list|,
name|expr
argument_list|,
name|flags
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return;
case|case
name|TARGET_MEM_REF
case|:
name|get_tmr_operands
argument_list|(
name|stmt
argument_list|,
name|expr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
block|{
name|tree
name|ref
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|,
name|size
decl_stmt|,
name|maxsize
decl_stmt|;
name|bool
name|none
init|=
name|true
decl_stmt|;
comment|/* This component reference becomes an access to all of the 	   subvariables it can touch, if we can determine that, but 	   *NOT* the real one.  If we can't determine which fields we 	   could touch, the recursion will eventually get to a 	   variable and add *all* of its subvars, or whatever is the 	   minimum correct subset.  */
name|ref
operator|=
name|get_ref_base_and_extent
argument_list|(
name|expr
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|maxsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|SSA_VAR_P
argument_list|(
name|ref
argument_list|)
operator|&&
name|get_subvars_for_var
argument_list|(
name|ref
argument_list|)
condition|)
block|{
name|subvar_t
name|sv
decl_stmt|;
name|subvar_t
name|svars
init|=
name|get_subvars_for_var
argument_list|(
name|ref
argument_list|)
decl_stmt|;
for|for
control|(
name|sv
operator|=
name|svars
init|;
name|sv
condition|;
name|sv
operator|=
name|sv
operator|->
name|next
control|)
block|{
name|bool
name|exact
decl_stmt|;
if|if
condition|(
name|overlap_subvar
argument_list|(
name|offset
argument_list|,
name|maxsize
argument_list|,
name|sv
operator|->
name|var
argument_list|,
operator|&
name|exact
argument_list|)
condition|)
block|{
name|int
name|subvar_flags
init|=
name|flags
decl_stmt|;
name|none
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|exact
operator|||
name|size
operator|!=
name|maxsize
condition|)
name|subvar_flags
operator|&=
operator|~
name|opf_kill_def
expr_stmt|;
name|add_stmt_operand
argument_list|(
operator|&
name|sv
operator|->
name|var
argument_list|,
name|s_ann
argument_list|,
name|subvar_flags
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|none
condition|)
name|flags
operator||=
name|opf_no_vops
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|get_indirect_ref_operands
argument_list|(
name|stmt
argument_list|,
name|ref
argument_list|,
name|flags
argument_list|,
name|expr
argument_list|,
name|offset
argument_list|,
name|maxsize
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|flags
operator||=
name|opf_no_vops
expr_stmt|;
block|}
comment|/* Even if we found subvars above we need to ensure to see 	   immediate uses for d in s.a[d].  In case of s.a having 	   a subvar or we would miss it otherwise.  */
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator|&
operator|~
name|opf_kill_def
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|COMPONENT_REF
condition|)
block|{
if|if
condition|(
name|s_ann
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|s_ann
operator|->
name|has_volatile_ops
operator|=
name|true
expr_stmt|;
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|ARRAY_REF
operator|||
name|code
operator|==
name|ARRAY_RANGE_REF
condition|)
block|{
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|3
argument_list|)
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
name|WITH_SIZE_EXPR
case|:
comment|/* WITH_SIZE_EXPR is a pass-through reference to its first argument, 	 and an rvalue reference to its second argument.  */
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
case|case
name|CALL_EXPR
case|:
name|get_call_expr_operands
argument_list|(
name|stmt
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return;
case|case
name|COND_EXPR
case|:
case|case
name|VEC_COND_EXPR
case|:
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
return|return;
case|case
name|MODIFY_EXPR
case|:
name|get_modify_expr_operands
argument_list|(
name|stmt
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONSTRUCTOR
case|:
block|{
comment|/* General aggregate CONSTRUCTORs have been decomposed, but they 	   are still in use as the COMPLEX_EXPR equivalent for vectors.  */
name|constructor_elt
modifier|*
name|ce
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|expr
argument_list|)
argument_list|,
name|idx
argument_list|,
name|ce
argument_list|)
condition|;
name|idx
operator|++
control|)
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|ce
operator|->
name|value
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|BIT_FIELD_REF
case|:
comment|/* Stores using BIT_FIELD_REF are always preserving definitions.  */
name|flags
operator|&=
operator|~
name|opf_kill_def
expr_stmt|;
comment|/* Fallthru  */
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
name|do_unary
label|:
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|OBJ_TYPE_REF
case|:
case|case
name|ASSERT_EXPR
case|:
name|do_binary
label|:
block|{
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|DOT_PROD_EXPR
case|:
case|case
name|REALIGN_LOAD_EXPR
case|:
block|{
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|BLOCK
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|EXC_PTR_EXPR
case|:
case|case
name|FILTER_EXPR
case|:
case|case
name|LABEL_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|OMP_PARALLEL
case|:
case|case
name|OMP_SECTIONS
case|:
case|case
name|OMP_FOR
case|:
case|case
name|OMP_SINGLE
case|:
case|case
name|OMP_MASTER
case|:
case|case
name|OMP_ORDERED
case|:
case|case
name|OMP_CRITICAL
case|:
case|case
name|OMP_RETURN
case|:
case|case
name|OMP_CONTINUE
case|:
comment|/* Expressions that make no memory references.  */
return|return;
default|default:
if|if
condition|(
name|class
operator|==
name|tcc_unary
condition|)
goto|goto
name|do_unary
goto|;
if|if
condition|(
name|class
operator|==
name|tcc_binary
operator|||
name|class
operator|==
name|tcc_comparison
condition|)
goto|goto
name|do_binary
goto|;
if|if
condition|(
name|class
operator|==
name|tcc_constant
operator|||
name|class
operator|==
name|tcc_type
condition|)
return|return;
block|}
comment|/* If we get here, something has gone wrong.  */
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unhandled expression in get_expr_operands():\n"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse STMT looking for operands.  When finished, the various    build_* operand vectors will have potential operands in them.  */
end_comment

begin_function
specifier|static
name|void
name|parse_ssa_operands
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MODIFY_EXPR
case|:
name|get_modify_expr_operands
argument_list|(
name|stmt
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
break|break;
case|case
name|SWITCH_EXPR
case|:
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|SWITCH_COND
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASM_EXPR
case|:
name|get_asm_expr_operands
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN_EXPR
case|:
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
break|break;
case|case
name|GOTO_EXPR
case|:
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|GOTO_DESTINATION
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_EXPR
case|:
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIND_EXPR
case|:
case|case
name|CASE_LABEL_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
case|case
name|TRY_FINALLY_EXPR
case|:
case|case
name|EH_FILTER_EXPR
case|:
case|case
name|CATCH_EXPR
case|:
case|case
name|RESX_EXPR
case|:
comment|/* These nodes contain no variable references.  */
break|break;
default|default:
comment|/* Notice that if get_expr_operands tries to use&STMT as the 	 operand pointer (which may only happen for USE operands), we 	 will fail in add_stmt_operand.  This default will handle 	 statements like empty statements, or CALL_EXPRs that may 	 appear on the RHS of a statement or as statements themselves.  */
name|get_expr_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|stmt
argument_list|,
name|opf_none
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Create an operands cache for STMT.  */
end_comment

begin_function
specifier|static
name|void
name|build_ssa_operands
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|stmt_ann_t
name|ann
init|=
name|get_stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
comment|/* Initially assume that the statement has no volatile operands and      does not take the address of any symbols.  */
if|if
condition|(
name|ann
condition|)
block|{
name|ann
operator|->
name|has_volatile_ops
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|ann
operator|->
name|addresses_taken
condition|)
name|ann
operator|->
name|addresses_taken
operator|=
name|NULL
expr_stmt|;
block|}
name|start_ssa_stmt_operands
argument_list|()
expr_stmt|;
name|parse_ssa_operands
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|operand_build_sort_virtual
argument_list|(
name|build_vuses
argument_list|)
expr_stmt|;
name|operand_build_sort_virtual
argument_list|(
name|build_v_may_defs
argument_list|)
expr_stmt|;
name|operand_build_sort_virtual
argument_list|(
name|build_v_must_defs
argument_list|)
expr_stmt|;
name|finalize_ssa_stmt_operands
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free any operands vectors in OPS.  */
end_comment

begin_function
name|void
name|free_ssa_operands
parameter_list|(
name|stmt_operands_p
name|ops
parameter_list|)
block|{
name|ops
operator|->
name|def_ops
operator|=
name|NULL
expr_stmt|;
name|ops
operator|->
name|use_ops
operator|=
name|NULL
expr_stmt|;
name|ops
operator|->
name|maydef_ops
operator|=
name|NULL
expr_stmt|;
name|ops
operator|->
name|mustdef_ops
operator|=
name|NULL
expr_stmt|;
name|ops
operator|->
name|vuse_ops
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the operands of statement STMT.  */
end_comment

begin_function
name|void
name|update_stmt_operands
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|stmt_ann_t
name|ann
init|=
name|get_stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
comment|/* If update_stmt_operands is called before SSA is initialized, do      nothing.  */
if|if
condition|(
operator|!
name|ssa_operands_active
argument_list|()
condition|)
return|return;
comment|/* The optimizers cannot handle statements that are nothing but a      _DECL.  This indicates a bug in the gimplifier.  */
name|gcc_assert
argument_list|(
operator|!
name|SSA_VAR_P
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ann
operator|->
name|modified
argument_list|)
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_TREE_OPS
argument_list|)
expr_stmt|;
name|build_ssa_operands
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* Clear the modified bit for STMT.  */
name|ann
operator|->
name|modified
operator|=
literal|0
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_TREE_OPS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copies virtual operands from SRC to DST.  */
end_comment

begin_function
name|void
name|copy_virtual_operands
parameter_list|(
name|tree
name|dest
parameter_list|,
name|tree
name|src
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|,
name|old_iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|,
name|u2
decl_stmt|;
name|def_operand_p
name|def_p
decl_stmt|,
name|d2
decl_stmt|;
name|build_ssa_operands
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* Copy all the virtual fields.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|t
argument_list|,
argument|src
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VUSE
argument_list|)
name|append_vuse
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|t
argument_list|,
argument|src
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VMAYDEF
argument_list|)
name|append_v_may_def
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|t
argument_list|,
argument|src
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VMUSTDEF
argument_list|)
name|append_v_must_def
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_vuses
argument_list|)
operator|==
literal|0
operator|&&
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_v_may_defs
argument_list|)
operator|==
literal|0
operator|&&
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_v_must_defs
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Now commit the virtual operands to this stmt.  */
name|finalize_ssa_v_must_defs
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|finalize_ssa_v_may_defs
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|finalize_ssa_vuses
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* Finally, set the field to the same values as then originals.  */
name|t
operator|=
name|op_iter_init_tree
argument_list|(
operator|&
name|old_iter
argument_list|,
name|src
argument_list|,
name|SSA_OP_VUSE
argument_list|)
expr_stmt|;
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|dest
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VUSE
argument_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|op_iter_done
argument_list|(
operator|&
name|old_iter
argument_list|)
argument_list|)
expr_stmt|;
name|SET_USE
argument_list|(
name|use_p
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|op_iter_next_tree
argument_list|(
operator|&
name|old_iter
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|op_iter_done
argument_list|(
operator|&
name|old_iter
argument_list|)
argument_list|)
expr_stmt|;
name|op_iter_init_maydef
argument_list|(
operator|&
name|old_iter
argument_list|,
name|src
argument_list|,
operator|&
name|u2
argument_list|,
operator|&
name|d2
argument_list|)
expr_stmt|;
name|FOR_EACH_SSA_MAYDEF_OPERAND
argument_list|(
argument|def_p
argument_list|,
argument|use_p
argument_list|,
argument|dest
argument_list|,
argument|iter
argument_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|op_iter_done
argument_list|(
operator|&
name|old_iter
argument_list|)
argument_list|)
expr_stmt|;
name|SET_USE
argument_list|(
name|use_p
argument_list|,
name|USE_FROM_PTR
argument_list|(
name|u2
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DEF
argument_list|(
name|def_p
argument_list|,
name|DEF_FROM_PTR
argument_list|(
name|d2
argument_list|)
argument_list|)
expr_stmt|;
name|op_iter_next_maymustdef
argument_list|(
operator|&
name|u2
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|old_iter
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|op_iter_done
argument_list|(
operator|&
name|old_iter
argument_list|)
argument_list|)
expr_stmt|;
name|op_iter_init_mustdef
argument_list|(
operator|&
name|old_iter
argument_list|,
name|src
argument_list|,
operator|&
name|u2
argument_list|,
operator|&
name|d2
argument_list|)
expr_stmt|;
name|FOR_EACH_SSA_MUSTDEF_OPERAND
argument_list|(
argument|def_p
argument_list|,
argument|use_p
argument_list|,
argument|dest
argument_list|,
argument|iter
argument_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|op_iter_done
argument_list|(
operator|&
name|old_iter
argument_list|)
argument_list|)
expr_stmt|;
name|SET_USE
argument_list|(
name|use_p
argument_list|,
name|USE_FROM_PTR
argument_list|(
name|u2
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DEF
argument_list|(
name|def_p
argument_list|,
name|DEF_FROM_PTR
argument_list|(
name|d2
argument_list|)
argument_list|)
expr_stmt|;
name|op_iter_next_maymustdef
argument_list|(
operator|&
name|u2
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|old_iter
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|op_iter_done
argument_list|(
operator|&
name|old_iter
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Specifically for use in DOM's expression analysis.  Given a store, we    create an artificial stmt which looks like a load from the store, this can    be used to eliminate redundant loads.  OLD_OPS are the operands from the     store stmt, and NEW_STMT is the new load which represents a load of the    values stored.  */
end_comment

begin_function
name|void
name|create_ssa_artficial_load_stmt
parameter_list|(
name|tree
name|new_stmt
parameter_list|,
name|tree
name|old_stmt
parameter_list|)
block|{
name|stmt_ann_t
name|ann
decl_stmt|;
name|tree
name|op
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|unsigned
name|x
decl_stmt|;
name|ann
operator|=
name|get_stmt_ann
argument_list|(
name|new_stmt
argument_list|)
expr_stmt|;
comment|/* Process the stmt looking for operands.  */
name|start_ssa_stmt_operands
argument_list|()
expr_stmt|;
name|parse_ssa_operands
argument_list|(
name|new_stmt
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_vuses
argument_list|)
condition|;
name|x
operator|++
control|)
block|{
name|tree
name|t
init|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|build_vuses
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|SSA_NAME
condition|)
block|{
name|var_ann_t
name|ann
init|=
name|var_ann
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|ann
operator|->
name|in_vuse_list
operator|=
literal|0
expr_stmt|;
block|}
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|build_v_may_defs
argument_list|)
condition|;
name|x
operator|++
control|)
block|{
name|tree
name|t
init|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|build_v_may_defs
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|SSA_NAME
condition|)
block|{
name|var_ann_t
name|ann
init|=
name|var_ann
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|ann
operator|->
name|in_v_may_def_list
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Remove any virtual operands that were found.  */
name|VEC_truncate
argument_list|(
name|tree
argument_list|,
name|build_v_may_defs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VEC_truncate
argument_list|(
name|tree
argument_list|,
name|build_v_must_defs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VEC_truncate
argument_list|(
name|tree
argument_list|,
name|build_vuses
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For each VDEF on the original statement, we want to create a      VUSE of the V_MAY_DEF result or V_MUST_DEF op on the new       statement.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|op
argument_list|,
argument|old_stmt
argument_list|,
argument|iter
argument_list|,
argument|(SSA_OP_VMAYDEF | SSA_OP_VMUSTDEF)
argument_list|)
name|append_vuse
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* Now build the operands for this new stmt.  */
name|finalize_ssa_stmt_operands
argument_list|(
name|new_stmt
argument_list|)
expr_stmt|;
comment|/* All uses in this fake stmt must not be in the immediate use lists.  */
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|new_stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_USES
argument_list|)
name|delink_imm_use
argument_list|(
name|use_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap operands EXP0 and EXP1 in statement STMT.  No attempt is done    to test the validity of the swap operation.  */
end_comment

begin_function
name|void
name|swap_tree_operands
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
modifier|*
name|exp0
parameter_list|,
name|tree
modifier|*
name|exp1
parameter_list|)
block|{
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|op0
operator|=
operator|*
name|exp0
expr_stmt|;
name|op1
operator|=
operator|*
name|exp1
expr_stmt|;
comment|/* If the operand cache is active, attempt to preserve the relative      positions of these two operands in their respective immediate use      lists.  */
if|if
condition|(
name|ssa_operands_active
argument_list|()
operator|&&
name|op0
operator|!=
name|op1
condition|)
block|{
name|use_optype_p
name|use0
decl_stmt|,
name|use1
decl_stmt|,
name|ptr
decl_stmt|;
name|use0
operator|=
name|use1
operator|=
name|NULL
expr_stmt|;
comment|/* Find the 2 operands in the cache, if they are there.  */
for|for
control|(
name|ptr
operator|=
name|USE_OPS
argument_list|(
name|stmt
argument_list|)
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
name|USE_OP_PTR
argument_list|(
name|ptr
argument_list|)
operator|->
name|use
operator|==
name|exp0
condition|)
block|{
name|use0
operator|=
name|ptr
expr_stmt|;
break|break;
block|}
for|for
control|(
name|ptr
operator|=
name|USE_OPS
argument_list|(
name|stmt
argument_list|)
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
name|USE_OP_PTR
argument_list|(
name|ptr
argument_list|)
operator|->
name|use
operator|==
name|exp1
condition|)
block|{
name|use1
operator|=
name|ptr
expr_stmt|;
break|break;
block|}
comment|/* If both uses don't have operand entries, there isn't much we can do          at this point.  Presumably we don't need to worry about it.  */
if|if
condition|(
name|use0
operator|&&
name|use1
condition|)
block|{
name|tree
modifier|*
name|tmp
init|=
name|USE_OP_PTR
argument_list|(
name|use1
argument_list|)
operator|->
name|use
decl_stmt|;
name|USE_OP_PTR
argument_list|(
name|use1
argument_list|)
operator|->
name|use
operator|=
name|USE_OP_PTR
argument_list|(
name|use0
argument_list|)
operator|->
name|use
expr_stmt|;
name|USE_OP_PTR
argument_list|(
name|use0
argument_list|)
operator|->
name|use
operator|=
name|tmp
expr_stmt|;
block|}
block|}
comment|/* Now swap the data.  */
operator|*
name|exp0
operator|=
name|op1
expr_stmt|;
operator|*
name|exp1
operator|=
name|op0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the base address of REF to the set *ADDRESSES_TAKEN.  If    *ADDRESSES_TAKEN is NULL, a new set is created.  REF may be    a single variable whose address has been taken or any other valid    GIMPLE memory reference (structure reference, array, etc).  If the    base address of REF is a decl that has sub-variables, also add all    of its sub-variables.  */
end_comment

begin_function
name|void
name|add_to_addressable_set
parameter_list|(
name|tree
name|ref
parameter_list|,
name|bitmap
modifier|*
name|addresses_taken
parameter_list|)
block|{
name|tree
name|var
decl_stmt|;
name|subvar_t
name|svars
decl_stmt|;
name|gcc_assert
argument_list|(
name|addresses_taken
argument_list|)
expr_stmt|;
comment|/* Note that it is *NOT OKAY* to use the target of a COMPONENT_REF      as the only thing we take the address of.  If VAR is a structure,      taking the address of a field means that the whole structure may      be referenced using pointer arithmetic.  See PR 21407 and the      ensuing mailing list discussion.  */
name|var
operator|=
name|get_base_address
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|&&
name|SSA_VAR_P
argument_list|(
name|var
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|addresses_taken
operator|==
name|NULL
condition|)
operator|*
name|addresses_taken
operator|=
name|BITMAP_GGC_ALLOC
argument_list|()
expr_stmt|;
if|if
condition|(
name|var_can_have_subvars
argument_list|(
name|var
argument_list|)
operator|&&
operator|(
name|svars
operator|=
name|get_subvars_for_var
argument_list|(
name|var
argument_list|)
operator|)
condition|)
block|{
name|subvar_t
name|sv
decl_stmt|;
for|for
control|(
name|sv
operator|=
name|svars
init|;
name|sv
condition|;
name|sv
operator|=
name|sv
operator|->
name|next
control|)
block|{
name|bitmap_set_bit
argument_list|(
operator|*
name|addresses_taken
argument_list|,
name|DECL_UID
argument_list|(
name|sv
operator|->
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|sv
operator|->
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|bitmap_set_bit
argument_list|(
operator|*
name|addresses_taken
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Scan the immediate_use list for VAR making sure its linked properly.    Return TRUE if there is a problem and emit an error message to F.  */
end_comment

begin_function
name|bool
name|verify_imm_links
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|use_operand_p
name|ptr
decl_stmt|,
name|prev
decl_stmt|,
name|list
decl_stmt|;
name|int
name|count
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
name|list
operator|=
operator|&
operator|(
name|SSA_NAME_IMM_USE_NODE
argument_list|(
name|var
argument_list|)
operator|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|list
operator|->
name|use
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|prev
operator|==
name|NULL
condition|)
block|{
name|gcc_assert
argument_list|(
name|list
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|prev
operator|=
name|list
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|list
operator|->
name|next
init|;
name|ptr
operator|!=
name|list
condition|;
control|)
block|{
if|if
condition|(
name|prev
operator|!=
name|ptr
operator|->
name|prev
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|ptr
operator|->
name|use
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
comment|/* 2 roots, or SAFE guard node.  */
elseif|else
if|if
condition|(
operator|*
operator|(
name|ptr
operator|->
name|use
operator|)
operator|!=
name|var
condition|)
goto|goto
name|error
goto|;
name|prev
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
comment|/* Avoid infinite loops.  50,000,000 uses probably indicates a 	 problem.  */
if|if
condition|(
name|count
operator|++
operator|>
literal|50000000
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* Verify list in the other direction.  */
name|prev
operator|=
name|list
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|list
operator|->
name|prev
init|;
name|ptr
operator|!=
name|list
condition|;
control|)
block|{
if|if
condition|(
name|prev
operator|!=
name|ptr
operator|->
name|next
condition|)
goto|goto
name|error
goto|;
name|prev
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|count
operator|--
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
return|return
name|false
return|;
name|error
label|:
if|if
condition|(
name|ptr
operator|->
name|stmt
operator|&&
name|stmt_modified_p
argument_list|(
name|ptr
operator|->
name|stmt
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" STMT MODIFIED. -<%p> "
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ptr
operator|->
name|stmt
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|f
argument_list|,
name|ptr
operator|->
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" IMM ERROR : (use_p : tree - %p:%p)"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ptr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ptr
operator|->
name|use
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|f
argument_list|,
name|USE_FROM_PTR
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Dump all the immediate uses to FILE.  */
end_comment

begin_function
name|void
name|dump_immediate_uses_for
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|imm_use_iterator
name|iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|gcc_assert
argument_list|(
name|var
operator|&&
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|var
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" : -->"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_zero_uses
argument_list|(
name|var
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" no uses.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|has_single_use
argument_list|(
name|var
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" single use.\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d uses.\n"
argument_list|,
name|num_imm_uses
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_IMM_USE_FAST
argument_list|(
argument|use_p
argument_list|,
argument|iter
argument_list|,
argument|var
argument_list|)
block|{
if|if
condition|(
name|use_p
operator|->
name|stmt
operator|==
name|NULL
operator|&&
name|use_p
operator|->
name|use
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"***end of stmt iterator marker***\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
argument_list|)
condition|)
name|print_generic_stmt
argument_list|(
name|file
argument_list|,
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
argument_list|,
name|TDF_VOPS
argument_list|)
expr_stmt|;
else|else
name|print_generic_stmt
argument_list|(
name|file
argument_list|,
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump all the immediate uses to FILE.  */
end_comment

begin_function
name|void
name|dump_immediate_uses
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|tree
name|var
decl_stmt|;
name|unsigned
name|int
name|x
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Immediate_uses: \n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
name|num_ssa_names
condition|;
name|x
operator|++
control|)
block|{
name|var
operator|=
name|ssa_name
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|var
condition|)
continue|continue;
name|dump_immediate_uses_for
argument_list|(
name|file
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump def-use edges on stderr.  */
end_comment

begin_function
name|void
name|debug_immediate_uses
parameter_list|(
name|void
parameter_list|)
block|{
name|dump_immediate_uses
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump def-use edges on stderr.  */
end_comment

begin_function
name|void
name|debug_immediate_uses_for
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|dump_immediate_uses_for
argument_list|(
name|stderr
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-tree-ssa-operands.h"
end_include

end_unit

