begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic routines for manipulating SSA_NAME expressions    Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.                                                                                 This file is part of GCC.                                                                                 GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.                                                                                 GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.                                                                                 You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_comment
comment|/* Rewriting a function into SSA form can create a huge number of SSA_NAMEs,    many of which may be thrown away shortly after their creation if jumps    were threaded through PHI nodes.       While our garbage collection mechanisms will handle this situation, it    is extremely wasteful to create nodes and throw them away, especially    when the nodes can be reused.     For PR 8361, we can significantly reduce the number of nodes allocated    and thus the total amount of memory allocated by managing SSA_NAMEs a    little.  This additionally helps reduce the amount of work done by the    garbage collector.  Similar results have been seen on a wider variety    of tests (such as the compiler itself).     Right now we maintain our free list on a per-function basis.  It may    or may not make sense to maintain the free list for the duration of    a compilation unit.      External code should rely solely upon HIGHEST_SSA_VERSION and the    externally defined functions.  External code should not know about    the details of the free list management.     External code should also not assume the version number on nodes is    monotonically increasing.  We reuse the version number when we    reuse an SSA_NAME expression.  This helps keep arrays and bitmaps    more compact.     We could also use a zone allocator for these objects since they have    a very well defined lifetime.  If someone wants to experiment with that    this is the place to try it.  */
end_comment

begin_comment
comment|/* Array of all SSA_NAMEs used in the function.  */
end_comment

begin_expr_stmt
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|ssa_names
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Free list of SSA_NAMEs.  This list is wiped at the end of each function    after we leave SSA form.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|free_ssanames
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Version numbers with special meanings.  We start allocating new version    numbers after the special ones.  */
end_comment

begin_define
define|#
directive|define
name|UNUSED_NAME_VERSION
value|0
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
name|unsigned
name|int
name|ssa_name_nodes_reused
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|ssa_name_nodes_created
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Initialize management of SSA_NAMEs.  */
end_comment

begin_function
name|void
name|init_ssanames
parameter_list|(
name|void
parameter_list|)
block|{
name|ssa_names
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
literal|50
argument_list|)
expr_stmt|;
comment|/* Version 0 is special, so reserve the first slot in the table.  Though      currently unused, we may use version 0 in alias analysis as part of      the heuristics used to group aliases when the alias sets are too      large.       We use VEC_quick_push here because we know that SSA_NAMES has at      least 50 elements reserved in it.  */
name|VEC_quick_push
argument_list|(
name|tree
argument_list|,
name|ssa_names
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|free_ssanames
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finalize management of SSA_NAMEs.  */
end_comment

begin_function
name|void
name|fini_ssanames
parameter_list|(
name|void
parameter_list|)
block|{
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|ssa_names
argument_list|)
expr_stmt|;
name|free_ssanames
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump some simple statistics regarding the re-use of SSA_NAME nodes.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_function
name|void
name|ssanames_print_statistics
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SSA_NAME nodes allocated: %u\n"
argument_list|,
name|ssa_name_nodes_created
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SSA_NAME nodes reused: %u\n"
argument_list|,
name|ssa_name_nodes_reused
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return an SSA_NAME node for variable VAR defined in statement STMT.    STMT may be an empty statement for artificial references (e.g., default    definitions created when a variable is used without a preceding    definition).  */
end_comment

begin_function
name|tree
name|make_ssa_name
parameter_list|(
name|tree
name|var
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|use_operand_p
name|imm
decl_stmt|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|var
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|INDIRECT_REF
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|stmt
operator|||
name|EXPR_P
argument_list|(
name|stmt
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
argument_list|)
expr_stmt|;
comment|/* If our free list has an element, then use it.  */
if|if
condition|(
name|free_ssanames
condition|)
block|{
name|t
operator|=
name|free_ssanames
expr_stmt|;
name|free_ssanames
operator|=
name|TREE_CHAIN
argument_list|(
name|free_ssanames
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|ssa_name_nodes_reused
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* The node was cleared out when we put it on the free list, so 	 there is no need to do so again here.  */
name|gcc_assert
argument_list|(
name|ssa_name
argument_list|(
name|SSA_NAME_VERSION
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|tree
argument_list|,
name|ssa_names
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|make_node
argument_list|(
name|SSA_NAME
argument_list|)
expr_stmt|;
name|SSA_NAME_VERSION
argument_list|(
name|t
argument_list|)
operator|=
name|num_ssa_names
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|ssa_names
argument_list|,
name|t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|ssa_name_nodes_created
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|SSA_NAME_VAR
argument_list|(
name|t
argument_list|)
operator|=
name|var
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|t
argument_list|)
operator|=
name|stmt
expr_stmt|;
name|SSA_NAME_PTR_INFO
argument_list|(
name|t
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|SSA_NAME_IN_FREE_LIST
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|imm
operator|=
operator|&
operator|(
name|SSA_NAME_IMM_USE_NODE
argument_list|(
name|t
argument_list|)
operator|)
expr_stmt|;
name|imm
operator|->
name|use
operator|=
name|NULL
expr_stmt|;
name|imm
operator|->
name|prev
operator|=
name|imm
expr_stmt|;
name|imm
operator|->
name|next
operator|=
name|imm
expr_stmt|;
name|imm
operator|->
name|stmt
operator|=
name|t
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* We no longer need the SSA_NAME expression VAR, release it so that    it may be reused.      Note it is assumed that no calls to make_ssa_name will be made    until all uses of the ssa name are released and that the only    use of the SSA_NAME expression is to check its SSA_NAME_VAR.  All    other fields must be assumed clobbered.  */
end_comment

begin_function
name|void
name|release_ssa_name
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
if|if
condition|(
operator|!
name|var
condition|)
return|return;
comment|/* Never release the default definition for a symbol.  It's a      special SSA name that should always exist once it's created.  */
if|if
condition|(
name|var
operator|==
name|default_def
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* If VAR has been registered for SSA updating, don't remove it.      After update_ssa has run, the name will be released.  */
if|if
condition|(
name|name_registered_for_update_p
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|release_ssa_name_after_update_ssa
argument_list|(
name|var
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* release_ssa_name can be called multiple times on a single SSA_NAME.      However, it should only end up on our free list one time.   We      keep a status bit in the SSA_NAME node itself to indicate it has      been put on the free list.        Note that once on the freelist you can not reference the SSA_NAME's      defining statement.  */
if|if
condition|(
operator|!
name|SSA_NAME_IN_FREE_LIST
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|tree
name|saved_ssa_name_var
init|=
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|int
name|saved_ssa_name_version
init|=
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|use_operand_p
name|imm
init|=
operator|&
operator|(
name|SSA_NAME_IMM_USE_NODE
argument_list|(
name|var
argument_list|)
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_imm_links
argument_list|(
name|stderr
argument_list|,
name|var
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|imm
operator|->
name|next
operator|!=
name|imm
condition|)
name|delink_imm_use
argument_list|(
name|imm
operator|->
name|next
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|tree
argument_list|,
name|ssa_names
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|var
argument_list|,
literal|0
argument_list|,
name|tree_size
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|imm
operator|->
name|prev
operator|=
name|imm
expr_stmt|;
name|imm
operator|->
name|next
operator|=
name|imm
expr_stmt|;
name|imm
operator|->
name|stmt
operator|=
name|var
expr_stmt|;
comment|/* First put back the right tree node so that the tree checking 	 macros do not complain.  */
name|TREE_SET_CODE
argument_list|(
name|var
argument_list|,
name|SSA_NAME
argument_list|)
expr_stmt|;
comment|/* Restore the version number.  */
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
operator|=
name|saved_ssa_name_version
expr_stmt|;
comment|/* Hopefully this can go away once we have the new incremental          SSA updating code installed.  */
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
operator|=
name|saved_ssa_name_var
expr_stmt|;
comment|/* Note this SSA_NAME is now in the first list.  */
name|SSA_NAME_IN_FREE_LIST
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* And finally link it into the free list.  */
name|TREE_CHAIN
argument_list|(
name|var
argument_list|)
operator|=
name|free_ssanames
expr_stmt|;
name|free_ssanames
operator|=
name|var
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Creates a duplicate of a ssa name NAME defined in statement STMT.  */
end_comment

begin_function
name|tree
name|duplicate_ssa_name
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|new_name
init|=
name|make_ssa_name
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|name
argument_list|)
argument_list|,
name|stmt
argument_list|)
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|old_ptr_info
init|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|old_ptr_info
condition|)
name|duplicate_ssa_name_ptr_info
argument_list|(
name|new_name
argument_list|,
name|old_ptr_info
argument_list|)
expr_stmt|;
return|return
name|new_name
return|;
block|}
end_function

begin_comment
comment|/* Creates a duplicate of the ptr_info_def at PTR_INFO for use by    the SSA name NAME.  */
end_comment

begin_function
name|void
name|duplicate_ssa_name_ptr_info
parameter_list|(
name|tree
name|name
parameter_list|,
name|struct
name|ptr_info_def
modifier|*
name|ptr_info
parameter_list|)
block|{
name|struct
name|ptr_info_def
modifier|*
name|new_ptr_info
decl_stmt|;
name|gcc_assert
argument_list|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|SSA_NAME_PTR_INFO
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr_info
condition|)
return|return;
name|new_ptr_info
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ptr_info_def
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|new_ptr_info
operator|=
operator|*
name|ptr_info
expr_stmt|;
if|if
condition|(
name|ptr_info
operator|->
name|pt_vars
condition|)
block|{
name|new_ptr_info
operator|->
name|pt_vars
operator|=
name|BITMAP_GGC_ALLOC
argument_list|()
expr_stmt|;
name|bitmap_copy
argument_list|(
name|new_ptr_info
operator|->
name|pt_vars
argument_list|,
name|ptr_info
operator|->
name|pt_vars
argument_list|)
expr_stmt|;
block|}
name|SSA_NAME_PTR_INFO
argument_list|(
name|name
argument_list|)
operator|=
name|new_ptr_info
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Release all the SSA_NAMEs created by STMT.  */
end_comment

begin_function
name|void
name|release_defs
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|def
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
comment|/* Make sure that we are in SSA.  Otherwise, operand cache may point      to garbage.  */
name|gcc_assert
argument_list|(
name|in_ssa_p
argument_list|)
expr_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|def
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_DEFS
argument_list|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|release_ssa_name
argument_list|(
name|def
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Replace the symbol associated with SSA_NAME with SYM.  */
end_comment

begin_function
name|void
name|replace_ssa_name_symbol
parameter_list|(
name|tree
name|ssa_name
parameter_list|,
name|tree
name|sym
parameter_list|)
block|{
name|SSA_NAME_VAR
argument_list|(
name|ssa_name
argument_list|)
operator|=
name|sym
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|ssa_name
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-tree-ssanames.h"
end_include

end_unit

