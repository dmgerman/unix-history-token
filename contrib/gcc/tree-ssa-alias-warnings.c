begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Strict aliasing checks.    Copyright (C) 2007 Free Software Foundation, Inc.    Contributed by Silvius Rus<rus@google.com>.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street, Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"alloc-pool.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-ssa-structalias.h"
end_include

begin_include
include|#
directive|include
file|"tree-ssa-propagate.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* Module to issue a warning when a program uses data through a type    different from the type through which the data were defined.    Implements -Wstrict-aliasing and -Wstrict-aliasing=n.    These checks only happen when -fstrict-aliasing is present.     The idea is to use the compiler to identify occurrences of nonstandard    aliasing, and report them to programmers.  Programs free of such aliasing    are more portable, maintainable, and can usually be optimized better.     The current, as of April 2007, C and C++ language standards forbid    accessing data of type A through an lvalue of another type B,    with certain exceptions. See the C Standard ISO/IEC 9899:1999,    section 6.5, paragraph 7, and the C++ Standard ISO/IEC 14882:1998,    section 3.10, paragraph 15.     Example 1:*a is used as int but was defined as a float, *b.         int* a = ...;         float* b = reinterpret_cast<float*> (a);         *b = 2.0;         return *a     Unfortunately, the problem is in general undecidable if we take into    account arithmetic expressions such as array indices or pointer arithmetic.    (It is at least as hard as Peano arithmetic decidability.)    Even ignoring arithmetic, the problem is still NP-hard, because it is    at least as hard as flow-insensitive may-alias analysis, which was proved    NP-hard by Horwitz et al, TOPLAS 1997.     It is clear that we need to choose some heuristics.    Unfortunately, various users have different goals which correspond to    different time budgets so a common approach will not suit all.    We present the user with three effort/accuracy levels.  By accuracy, we mean    a common-sense mix of low count of false positives with a    reasonably low number of false negatives.  We are heavily biased    towards a low count of false positives.    The effort (compilation time) is likely to increase with the level.     -Wstrict-aliasing=1    ===================    Most aggressive, least accurate.  Possibly useful when higher levels    do not warn but -fstrict-aliasing still breaks the code, as    it has very few false negatives.    Warn for all bad pointer conversions, even if never dereferenced.    Implemented in the front end (c-common.c).    Uses alias_sets_might_conflict to compare types.     -Wstrict-aliasing=2    ===================    Aggressive, not too precise.    May still have many false positives (not as many as level 1 though),    and few false negatives (but possibly more than level 1).    Runs only in the front end. Uses alias_sets_might_conflict to    compare types. Does not check for pointer dereferences.    Only warns when an address is taken. Warns about incomplete type punning.     -Wstrict-aliasing=3 (default)    ===================    Should have very few false positives and few false negatives.    Takes care of the common punn+dereference pattern in the front end:    *(int*)&some_float.    Takes care of multiple statement cases in the back end,    using flow-sensitive points-to information (-O required).    Uses alias_sets_conflict_p to compare types and only warns    when the converted pointer is dereferenced.    Does not warn about incomplete type punning.     Future improvements can be included by adding higher levels.     In summary, expression level analysis is performed in the front-end,    and multiple-statement analysis is performed in the backend.    The remainder of this discussion is only about the backend analysis.     This implementation uses flow-sensitive points-to information.    Flow-sensitivity refers to accesses to the pointer, and not the object    pointed.  For instance, we do not warn about the following case.     Example 2.         int* a = (int*)malloc (...);         float* b = reinterpret_cast<float*> (a);         *b = 2.0;         a = (int*)malloc (...);         return *a;     In SSA, it becomes clear that the INT value *A_2 referenced in the    return statement is not aliased to the FLOAT defined through *B_1.         int* a_1 = (int*)malloc (...);         float* b_1 = reinterpret_cast<float*> (a_1);         *b_1 = 2.0;         a_2 = (int*)malloc (...);         return *a_2;      Algorithm Outline    =================     ForEach (ptr, object) in the points-to table      If (incompatible_types (*ptr, object))        If (referenced (ptr, current function)            and referenced (object, current function))          Issue warning (ptr, object, reference locations)     The complexity is:    O (sizeof (points-to table)       + sizeof (function body) * lookup_time (points-to table))     Pointer dereference locations are looked up on demand.  The search is    a single scan of the function body, in which all references to pointers    and objects in the points-to table are recorded.  However, this dominant    time factor occurs rarely, only when cross-type aliasing was detected.      Limitations of the Proposed Implementation    ==========================================     1. We do not catch the following case, because -fstrict-aliasing will       associate different tags with MEM while building points-to information,       thus before we get to analyze it.       XXX: this could be solved by either running with -fno-strict-aliasing       or by recording the points-to information before splitting the orignal       tag based on type.     Example 3.         void* mem = malloc (...); 	int* pi = reinterpret_cast<int*> (mem); 	float* b = reinterpret_cast<float*> (mem); 	*b = 2.0; 	return *pi+1;     2. We do not check whether the two conflicting (de)references can       reach each other in the control flow sense.  If we fixed limitation       1, we would wrongly issue a warning in the following case.     Example 4.         void* raw = malloc (...);         if (...) {          float* b = reinterpret_cast<float*> (raw);          *b = 2.0;          return (int)*b;         } else {          int* a = reinterpret_cast<int*> (raw);          *a = 1;          return *a;     3. Only simple types are compared, thus no structures, unions or classes       are analyzed.  A first attempt to deal with structures introduced much       complication and has not showed much improvement in preliminary tests,       so it was left out.     4. All analysis is intraprocedural.  */
end_comment

begin_comment
comment|/* Local declarations.  */
end_comment

begin_function_decl
specifier|static
name|void
name|find_references_in_function
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Get main type of tree TYPE, stripping array dimensions and qualifiers.  */
end_comment

begin_function
specifier|static
name|tree
name|get_main_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the type of the given object.  If IS_PTR is true, get the type of the    object pointed to or referenced by OBJECT instead.    For arrays, return the element type.  Ignore all qualifiers.  */
end_comment

begin_function
specifier|static
name|tree
name|get_otype
parameter_list|(
name|tree
name|object
parameter_list|,
name|bool
name|is_ptr
parameter_list|)
block|{
name|tree
name|otype
init|=
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_ptr
condition|)
block|{
name|gcc_assert
argument_list|(
name|POINTER_TYPE_P
argument_list|(
name|otype
argument_list|)
argument_list|)
expr_stmt|;
name|otype
operator|=
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
expr_stmt|;
block|}
return|return
name|get_main_type
argument_list|(
name|otype
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if tree TYPE is struct, class or union.  */
end_comment

begin_function
specifier|static
name|bool
name|struct_class_union_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Keep data during a search for an aliasing site.    RHS = object or pointer aliased.  No LHS is specified because we are only    looking in the UseDef paths of a given variable, so LHS will always be    an SSA name of the same variable.    When IS_RHS_POINTER = true, we are looking for ... = RHS.  Otherwise,    we are looking for ... =&RHS.    SITE is the output of a search, non-NULL if the search succeeded.  */
end_comment

begin_struct
struct|struct
name|alias_match
block|{
name|tree
name|rhs
decl_stmt|;
name|bool
name|is_rhs_pointer
decl_stmt|;
name|tree
name|site
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Callback for find_alias_site.  Return true if the right hand site    of STMT matches DATA.  */
end_comment

begin_function
specifier|static
name|bool
name|find_alias_site_helper
parameter_list|(
name|tree
name|var
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|alias_match
modifier|*
name|match
init|=
operator|(
expr|struct
name|alias_match
operator|*
operator|)
name|data
decl_stmt|;
name|tree
name|rhs_pointer
init|=
name|get_rhs
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|to_match
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|rhs_pointer
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rhs_pointer
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rhs_pointer
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
condition|)
name|rhs_pointer
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs_pointer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rhs_pointer
condition|)
comment|/* Not a type conversion.  */
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs_pointer
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|!
name|match
operator|->
name|is_rhs_pointer
condition|)
name|to_match
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs_pointer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|rhs_pointer
argument_list|)
operator|&&
name|match
operator|->
name|is_rhs_pointer
condition|)
name|to_match
operator|=
name|rhs_pointer
expr_stmt|;
if|if
condition|(
name|to_match
operator|!=
name|match
operator|->
name|rhs
condition|)
comment|/* Type conversion, but not a name match.  */
return|return
name|false
return|;
comment|/* Found it.  */
name|match
operator|->
name|site
operator|=
name|stmt
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Find the statement where OBJECT1 gets aliased to OBJECT2.    If IS_PTR2 is true, consider OBJECT2 to be the name of a pointer or    reference rather than the actual aliased object.    For now, just implement the case where OBJECT1 is an SSA name defined    by a PHI statement.  */
end_comment

begin_function
specifier|static
name|tree
name|find_alias_site
parameter_list|(
name|tree
name|object1
parameter_list|,
name|bool
name|is_ptr1
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|object2
parameter_list|,
name|bool
name|is_ptr2
parameter_list|)
block|{
name|struct
name|alias_match
name|match
decl_stmt|;
name|match
operator|.
name|rhs
operator|=
name|object2
expr_stmt|;
name|match
operator|.
name|is_rhs_pointer
operator|=
name|is_ptr2
expr_stmt|;
name|match
operator|.
name|site
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|object1
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|NULL_TREE
return|;
name|walk_use_def_chains
argument_list|(
name|object1
argument_list|,
name|find_alias_site_helper
argument_list|,
operator|&
name|match
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|match
operator|.
name|site
return|;
block|}
end_function

begin_comment
comment|/* Structure to store temporary results when trying to figure out whether    an object is referenced.  Just its presence in the text is not enough,    as we may just be taking its address.  */
end_comment

begin_struct
struct|struct
name|match_info
block|{
name|tree
name|object
decl_stmt|;
name|bool
name|is_ptr
decl_stmt|;
comment|/* The difference between the number of references to OBJECT      and the number of occurences of&OBJECT.  */
name|int
name|found
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Return the base if EXPR is an SSA name.  Return EXPR otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|get_ssa_base
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SSA_NAME
condition|)
return|return
name|SSA_NAME_VAR
argument_list|(
name|expr
argument_list|)
return|;
else|else
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Record references to objects and pointer dereferences across some piece of    code.  The number of references is recorded for each item.    References to an object just to take its address are not counted.    For instance, if PTR is a pointer and OBJ is an object:    1. Expression&obj + *ptr will have the following reference match structure:    ptrs:<ptr, 1>    objs:<ptr, 1>    OBJ does not appear as referenced because we just take its address.    2. Expression ptr + *ptr will have the following reference match structure:    ptrs:<ptr, 1>    objs:<ptr, 2>    PTR shows up twice as an object, but is dereferenced only once.     The elements of the hash tables are tree_map objects.  */
end_comment

begin_struct
struct|struct
name|reference_matches
block|{
name|htab_t
name|ptrs
decl_stmt|;
name|htab_t
name|objs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Return the match, if any.  Otherwise, return NULL_TREE.  It will    return NULL_TREE even when a match was found, if the value associated    to KEY is NULL_TREE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|match
parameter_list|(
name|htab_t
name|ref_map
parameter_list|,
name|tree
name|key
parameter_list|)
block|{
name|struct
name|tree_map
name|to_find
decl_stmt|;
name|struct
name|tree_map
modifier|*
name|found
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
init|=
name|NULL
decl_stmt|;
name|to_find
operator|.
name|from
operator|=
name|key
expr_stmt|;
name|to_find
operator|.
name|hash
operator|=
name|htab_hash_pointer
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|ref_map
argument_list|,
operator|&
name|to_find
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slot
condition|)
return|return
name|NULL_TREE
return|;
name|found
operator|=
operator|(
expr|struct
name|tree_map
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
return|return
name|found
operator|->
name|to
return|;
block|}
end_function

begin_comment
comment|/* Set the entry corresponding to KEY, but only if the entry    already exists and its value is NULL_TREE.  Otherwise, do nothing.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|maybe_add_match
parameter_list|(
name|htab_t
name|ref_map
parameter_list|,
name|struct
name|tree_map
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|tree_map
modifier|*
name|found
init|=
name|htab_find
argument_list|(
name|ref_map
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
operator|&&
operator|!
name|found
operator|->
name|to
condition|)
name|found
operator|->
name|to
operator|=
name|key
operator|->
name|to
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an entry to HT, with key T and value NULL_TREE.  */
end_comment

begin_function
specifier|static
name|void
name|add_key
parameter_list|(
name|htab_t
name|ht
parameter_list|,
name|tree
name|t
parameter_list|,
name|alloc_pool
name|references_pool
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|struct
name|tree_map
modifier|*
name|tp
init|=
name|pool_alloc
argument_list|(
name|references_pool
argument_list|)
decl_stmt|;
name|tp
operator|->
name|from
operator|=
name|t
expr_stmt|;
name|tp
operator|->
name|to
operator|=
name|NULL_TREE
expr_stmt|;
name|tp
operator|->
name|hash
operator|=
name|htab_hash_pointer
argument_list|(
name|tp
operator|->
name|from
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|ht
argument_list|,
name|tp
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
operator|(
name|void
operator|*
operator|)
name|tp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Some memory to keep the objects in the reference table.  */
end_comment

begin_decl_stmt
specifier|static
name|alloc_pool
name|ref_table_alloc_pool
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get some memory to keep the objects in the reference table.  */
end_comment

begin_function
specifier|static
specifier|inline
name|alloc_pool
name|reference_table_alloc_pool
parameter_list|(
name|bool
name|build
parameter_list|)
block|{
if|if
condition|(
name|ref_table_alloc_pool
operator|||
operator|!
name|build
condition|)
return|return
name|ref_table_alloc_pool
return|;
name|ref_table_alloc_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"ref_table_alloc_pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_map
argument_list|)
argument_list|,
literal|20
argument_list|)
expr_stmt|;
return|return
name|ref_table_alloc_pool
return|;
block|}
end_function

begin_comment
comment|/* Initialize the reference table by adding all pointers in the points-to    table as keys, and NULL_TREE as associated values.  */
end_comment

begin_function
specifier|static
name|struct
name|reference_matches
modifier|*
name|build_reference_table
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|reference_matches
modifier|*
name|ref_table
init|=
name|NULL
decl_stmt|;
name|alloc_pool
name|references_pool
init|=
name|reference_table_alloc_pool
argument_list|(
name|true
argument_list|)
decl_stmt|;
name|ref_table
operator|=
name|XNEW
argument_list|(
expr|struct
name|reference_matches
argument_list|)
expr_stmt|;
name|ref_table
operator|->
name|objs
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|tree_map_hash
argument_list|,
name|tree_map_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ref_table
operator|->
name|ptrs
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|tree_map_hash
argument_list|,
name|tree_map_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_ssa_names
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|ptr
init|=
name|ssa_name
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL_TREE
condition|)
continue|continue;
name|pi
operator|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SSA_NAME_IN_FREE_LIST
argument_list|(
name|ptr
argument_list|)
operator|&&
name|pi
operator|&&
name|pi
operator|->
name|name_mem_tag
condition|)
block|{
comment|/* Add pointer to the interesting dereference list.  */
name|add_key
argument_list|(
name|ref_table
operator|->
name|ptrs
argument_list|,
name|ptr
argument_list|,
name|references_pool
argument_list|)
expr_stmt|;
comment|/* Add all aliased names to the interesting reference list.  */
if|if
condition|(
name|pi
operator|->
name|pt_vars
condition|)
block|{
name|unsigned
name|ix
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|pi->pt_vars
argument_list|,
literal|0
argument_list|,
argument|ix
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|alias
init|=
name|referenced_var
argument_list|(
name|ix
argument_list|)
decl_stmt|;
name|add_key
argument_list|(
name|ref_table
operator|->
name|objs
argument_list|,
name|alias
argument_list|,
name|references_pool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|ref_table
return|;
block|}
end_function

begin_comment
comment|/*  Reference table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|reference_matches
modifier|*
name|ref_table
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Clean up the reference table if allocated.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_free_reference_table
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ref_table
condition|)
block|{
name|htab_delete
argument_list|(
name|ref_table
operator|->
name|ptrs
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|ref_table
operator|->
name|objs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref_table
argument_list|)
expr_stmt|;
name|ref_table
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ref_table_alloc_pool
condition|)
block|{
name|free_alloc_pool
argument_list|(
name|ref_table_alloc_pool
argument_list|)
expr_stmt|;
name|ref_table_alloc_pool
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get the reference table.  Initialize it if needed.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|reference_matches
modifier|*
name|reference_table
parameter_list|(
name|bool
name|build
parameter_list|)
block|{
if|if
condition|(
name|ref_table
operator|||
operator|!
name|build
condition|)
return|return
name|ref_table
return|;
name|ref_table
operator|=
name|build_reference_table
argument_list|()
expr_stmt|;
name|find_references_in_function
argument_list|()
expr_stmt|;
return|return
name|ref_table
return|;
block|}
end_function

begin_comment
comment|/* Callback for find_references_in_function.    Check whether *TP is an object reference or pointer dereference for the    variables given in ((struct match_info*)DATA)->OBJS or    ((struct match_info*)DATA)->PTRS.  The total number of references    is stored in the same structures.  */
end_comment

begin_function
specifier|static
name|tree
name|find_references_in_tree_helper
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|tree_map
name|match
decl_stmt|;
specifier|static
name|int
name|parent_tree_code
init|=
name|ERROR_MARK
decl_stmt|;
comment|/* Do not report references just for the purpose of taking an address.      XXX: we rely on the fact that the tree walk is in preorder      and that ADDR_EXPR is not a leaf, thus cannot be carried over across      walks.  */
if|if
condition|(
name|parent_tree_code
operator|==
name|ADDR_EXPR
condition|)
goto|goto
name|finish
goto|;
name|match
operator|.
name|to
operator|=
operator|(
name|tree
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|match
operator|.
name|from
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|match
operator|.
name|hash
operator|=
name|htab_hash_pointer
argument_list|(
name|match
operator|.
name|from
argument_list|)
expr_stmt|;
name|maybe_add_match
argument_list|(
name|reference_table
argument_list|(
name|true
argument_list|)
operator|->
name|ptrs
argument_list|,
operator|&
name|match
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|match
operator|.
name|from
operator|=
operator|*
name|tp
expr_stmt|;
name|match
operator|.
name|hash
operator|=
name|htab_hash_pointer
argument_list|(
name|match
operator|.
name|from
argument_list|)
expr_stmt|;
name|maybe_add_match
argument_list|(
name|reference_table
argument_list|(
name|true
argument_list|)
operator|->
name|objs
argument_list|,
operator|&
name|match
argument_list|)
expr_stmt|;
block|}
name|finish
label|:
name|parent_tree_code
operator|=
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Find all the references to aliased variables in the current function.  */
end_comment

begin_function
specifier|static
name|void
name|find_references_in_function
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|i
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
for|for
control|(
name|i
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
name|walk_tree
argument_list|(
name|bsi_stmt_ptr
argument_list|(
name|i
argument_list|)
argument_list|,
name|find_references_in_tree_helper
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|*
name|bsi_stmt_ptr
argument_list|(
name|i
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the reference site for OBJECT.    If IS_PTR is true, look for derferences of OBJECT instead.    XXX: only the first site is returned in the current    implementation.  If there are no matching sites, return NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|reference_site
parameter_list|(
name|tree
name|object
parameter_list|,
name|bool
name|is_ptr
parameter_list|)
block|{
if|if
condition|(
name|is_ptr
condition|)
return|return
name|match
argument_list|(
name|reference_table
argument_list|(
name|true
argument_list|)
operator|->
name|ptrs
argument_list|,
name|object
argument_list|)
return|;
else|else
return|return
name|match
argument_list|(
name|reference_table
argument_list|(
name|true
argument_list|)
operator|->
name|objs
argument_list|,
name|object
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Try to get more location info when something is missing.    OBJECT1 and OBJECT2 are aliased names.  If IS_PTR1 or IS_PTR2, the alias    is on the memory referenced or pointed to by OBJECT1 and OBJECT2.    ALIAS_SITE, DEREF_SITE1 and DEREF_SITE2 are the statements where the    alias takes place (some pointer assignment usually) and where the    alias is referenced through OBJECT1 and OBJECT2 respectively.    REF_TYPE1 and REF_TYPE2 will return the type of the reference at the    respective sites.  Only the first matching reference is returned for    each name.  If no statement is found, the function header is returned.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_find_missing_stmts
parameter_list|(
name|tree
name|object1
parameter_list|,
name|bool
name|is_ptr1
parameter_list|,
name|tree
name|object2
parameter_list|,
name|bool
name|is_ptr2
parameter_list|,
name|tree
modifier|*
name|alias_site
parameter_list|,
name|tree
modifier|*
name|deref_site1
parameter_list|,
name|tree
modifier|*
name|deref_site2
parameter_list|)
block|{
if|if
condition|(
name|object1
operator|&&
name|object2
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|alias_site
operator|||
operator|!
name|EXPR_HAS_LOCATION
argument_list|(
operator|*
name|alias_site
argument_list|)
condition|)
operator|*
name|alias_site
operator|=
name|find_alias_site
argument_list|(
name|object1
argument_list|,
name|is_ptr1
argument_list|,
name|object2
argument_list|,
name|is_ptr2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|deref_site1
operator|||
operator|!
name|EXPR_HAS_LOCATION
argument_list|(
operator|*
name|deref_site1
argument_list|)
condition|)
operator|*
name|deref_site1
operator|=
name|reference_site
argument_list|(
name|object1
argument_list|,
name|is_ptr1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|deref_site2
operator|||
operator|!
name|EXPR_HAS_LOCATION
argument_list|(
operator|*
name|deref_site2
argument_list|)
condition|)
operator|*
name|deref_site2
operator|=
name|reference_site
argument_list|(
name|object2
argument_list|,
name|is_ptr2
argument_list|)
expr_stmt|;
block|}
comment|/* If we could not find the alias site, set it to one of the dereference      sites, if available.  */
if|if
condition|(
operator|!
operator|*
name|alias_site
condition|)
block|{
if|if
condition|(
operator|*
name|deref_site1
condition|)
operator|*
name|alias_site
operator|=
operator|*
name|deref_site1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|deref_site2
condition|)
operator|*
name|alias_site
operator|=
operator|*
name|deref_site2
expr_stmt|;
block|}
comment|/* If we could not find the dereference sites, set them to the alias site,      if known.  */
if|if
condition|(
operator|!
operator|*
name|deref_site1
operator|&&
operator|*
name|alias_site
condition|)
operator|*
name|deref_site1
operator|=
operator|*
name|alias_site
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|deref_site2
operator|&&
operator|*
name|alias_site
condition|)
operator|*
name|deref_site2
operator|=
operator|*
name|alias_site
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Callback for find_first_artificial_name.    Find out if there are no artificial names at tree node *T.  */
end_comment

begin_function
specifier|static
name|tree
name|ffan_walker
parameter_list|(
name|tree
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|go_below
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|t
argument_list|)
operator|==
name|PARM_DECL
condition|)
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
operator|*
name|t
argument_list|)
condition|)
return|return
operator|*
name|t
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return the first artificial name within EXPR, or NULL_TREE if    none exists.  */
end_comment

begin_function
specifier|static
name|tree
name|find_first_artificial_name
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
return|return
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|expr
argument_list|,
name|ffan_walker
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get a name from the original program for VAR.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_var_name
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|)
return|return
name|get_var_name
argument_list|(
name|get_ssa_base
argument_list|(
name|var
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|find_first_artificial_name
argument_list|(
name|var
argument_list|)
condition|)
return|return
literal|"{unknown}"
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|PARM_DECL
condition|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|var
argument_list|)
condition|)
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|var
argument_list|)
argument_list|)
return|;
return|return
literal|"{unknown}"
return|;
block|}
end_function

begin_comment
comment|/* Return true if VAR contains an artificial name.  */
end_comment

begin_function
specifier|static
name|bool
name|contains_artificial_name_p
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|)
return|return
name|contains_artificial_name_p
argument_list|(
name|get_ssa_base
argument_list|(
name|var
argument_list|)
argument_list|)
return|;
return|return
name|find_first_artificial_name
argument_list|(
name|var
argument_list|)
operator|!=
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return "*" if OBJECT is not the actual alias but a pointer to it, or    "" otherwise.    IS_PTR is true when OBJECT is not the actual alias.    In addition to checking IS_PTR, we also make sure that OBJECT is a pointer    since IS_PTR would also be true for C++ references, but we should only    print a * before a pointer and not before a reference.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_maybe_star_prefix
parameter_list|(
name|tree
name|object
parameter_list|,
name|bool
name|is_ptr
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
operator|(
name|is_ptr
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
condition|?
literal|"*"
else|:
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Callback for contains_node_type_p.    Returns true if *T has tree code *(int*)DATA.  */
end_comment

begin_function
specifier|static
name|tree
name|contains_node_type_p_callback
parameter_list|(
name|tree
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|go_below
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
operator|*
name|t
argument_list|)
operator|==
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|)
condition|?
operator|*
name|t
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return true if T contains a node with tree code TYPE.  */
end_comment

begin_function
specifier|static
name|bool
name|contains_node_type_p
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|type
parameter_list|)
block|{
return|return
operator|(
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|t
argument_list|,
name|contains_node_type_p_callback
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if a warning was issued in the front end at STMT.  */
end_comment

begin_function
specifier|static
name|bool
name|already_warned_in_frontend_p
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|rhs_pointer
decl_stmt|;
if|if
condition|(
name|stmt
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
name|rhs_pointer
operator|=
name|get_rhs
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|rhs_pointer
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rhs_pointer
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rhs_pointer
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
operator|)
operator|&&
name|TREE_NO_WARNING
argument_list|(
name|rhs_pointer
argument_list|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if and only if TYPE is a function or method pointer type,    or pointer to a pointer to ... to a function or method.  */
end_comment

begin_function
specifier|static
name|bool
name|is_method_pointer
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
return|;
block|}
end_function

begin_comment
comment|/* Issue a -Wstrict-aliasing warning.    OBJECT1 and OBJECT2 are aliased names.    If IS_PTR1 and/or IS_PTR2 is true, then the corresponding name    OBJECT1/OBJECT2 is a pointer or reference to the aliased memory,    rather than actual storage.    ALIAS_SITE is a statement where the alias took place.  In the most common    case, that is where a pointer was assigned to the address of an object.  */
end_comment

begin_function
specifier|static
name|bool
name|strict_aliasing_warn
parameter_list|(
name|tree
name|alias_site
parameter_list|,
name|tree
name|object1
parameter_list|,
name|bool
name|is_ptr1
parameter_list|,
name|tree
name|object2
parameter_list|,
name|bool
name|is_ptr2
parameter_list|,
name|bool
name|filter_artificials
parameter_list|)
block|{
name|tree
name|ref_site1
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|ref_site2
init|=
name|NULL_TREE
decl_stmt|;
specifier|const
name|char
modifier|*
name|name1
decl_stmt|;
specifier|const
name|char
modifier|*
name|name2
decl_stmt|;
name|location_t
name|alias_loc
decl_stmt|;
name|location_t
name|ref1_loc
decl_stmt|;
name|location_t
name|ref2_loc
decl_stmt|;
name|gcc_assert
argument_list|(
name|object1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|object2
argument_list|)
expr_stmt|;
if|if
condition|(
name|contains_artificial_name_p
argument_list|(
name|object1
argument_list|)
operator|||
name|contains_artificial_name_p
argument_list|(
name|object2
argument_list|)
condition|)
return|return
name|false
return|;
name|name1
operator|=
name|get_var_name
argument_list|(
name|object1
argument_list|)
expr_stmt|;
name|name2
operator|=
name|get_var_name
argument_list|(
name|object2
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_method_pointer
argument_list|(
name|get_main_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|object2
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|maybe_find_missing_stmts
argument_list|(
name|object1
argument_list|,
name|is_ptr1
argument_list|,
name|object2
argument_list|,
name|is_ptr2
argument_list|,
operator|&
name|alias_site
argument_list|,
operator|&
name|ref_site1
argument_list|,
operator|&
name|ref_site2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alias_site
condition|)
return|return
name|false
return|;
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|alias_site
argument_list|)
condition|)
name|alias_loc
operator|=
name|EXPR_LOCATION
argument_list|(
name|alias_site
argument_list|)
expr_stmt|;
else|else
return|return
name|false
return|;
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|ref_site1
argument_list|)
condition|)
name|ref1_loc
operator|=
name|EXPR_LOCATION
argument_list|(
name|ref_site1
argument_list|)
expr_stmt|;
else|else
name|ref1_loc
operator|=
name|alias_loc
expr_stmt|;
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|ref_site2
argument_list|)
condition|)
name|ref2_loc
operator|=
name|EXPR_LOCATION
argument_list|(
name|ref_site2
argument_list|)
expr_stmt|;
else|else
name|ref2_loc
operator|=
name|alias_loc
expr_stmt|;
if|if
condition|(
name|already_warned_in_frontend_p
argument_list|(
name|alias_site
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If they are not SSA names, but contain SSA names, drop the warning      because it cannot be displayed well.      Also drop it if they both contain artificials.      XXX: this is a hack, must figure out a better way to display them.  */
if|if
condition|(
name|filter_artificials
condition|)
if|if
condition|(
operator|(
name|find_first_artificial_name
argument_list|(
name|get_ssa_base
argument_list|(
name|object1
argument_list|)
argument_list|)
operator|&&
name|find_first_artificial_name
argument_list|(
name|get_ssa_base
argument_list|(
name|object2
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|object1
argument_list|)
operator|!=
name|SSA_NAME
operator|&&
name|contains_node_type_p
argument_list|(
name|object1
argument_list|,
name|SSA_NAME
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|object2
argument_list|)
operator|!=
name|SSA_NAME
operator|&&
name|contains_node_type_p
argument_list|(
name|object2
argument_list|,
name|SSA_NAME
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* XXX: In the following format string, %s:%d should be replaced by %H.      However, in my tests only the first %H printed ok, while the      second and third were printed as blanks.  */
name|warning
argument_list|(
name|OPT_Wstrict_aliasing
argument_list|,
literal|"%Hlikely type-punning may break strict-aliasing rules: "
literal|"object %<%s%s%> of main type %qT is referenced at or around "
literal|"%s:%d and may be "
literal|"aliased to object %<%s%s%> of main type %qT which is referenced "
literal|"at or around %s:%d."
argument_list|,
operator|&
name|alias_loc
argument_list|,
name|get_maybe_star_prefix
argument_list|(
name|object1
argument_list|,
name|is_ptr1
argument_list|)
argument_list|,
name|name1
argument_list|,
name|get_otype
argument_list|(
name|object1
argument_list|,
name|is_ptr1
argument_list|)
argument_list|,
name|LOCATION_FILE
argument_list|(
name|ref1_loc
argument_list|)
argument_list|,
name|LOCATION_LINE
argument_list|(
name|ref1_loc
argument_list|)
argument_list|,
name|get_maybe_star_prefix
argument_list|(
name|object2
argument_list|,
name|is_ptr2
argument_list|)
argument_list|,
name|name2
argument_list|,
name|get_otype
argument_list|(
name|object2
argument_list|,
name|is_ptr2
argument_list|)
argument_list|,
name|LOCATION_FILE
argument_list|(
name|ref2_loc
argument_list|)
argument_list|,
name|LOCATION_LINE
argument_list|(
name|ref2_loc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true when any objects of TYPE1 and TYPE2 respectively    may not be aliased according to the language standard.  */
end_comment

begin_function
specifier|static
name|bool
name|nonstandard_alias_types_p
parameter_list|(
name|tree
name|type1
parameter_list|,
name|tree
name|type2
parameter_list|)
block|{
name|HOST_WIDE_INT
name|set1
decl_stmt|;
name|HOST_WIDE_INT
name|set2
decl_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|||
name|VOID_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
return|return
name|false
return|;
name|set1
operator|=
name|get_alias_set
argument_list|(
name|type1
argument_list|)
expr_stmt|;
name|set2
operator|=
name|get_alias_set
argument_list|(
name|type2
argument_list|)
expr_stmt|;
return|return
operator|!
name|alias_sets_conflict_p
argument_list|(
name|set1
argument_list|,
name|set2
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns true if the given name is a struct field tag (SFT).  */
end_comment

begin_function
specifier|static
name|bool
name|struct_field_tag_p
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
return|return
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|STRUCT_FIELD_TAG
return|;
block|}
end_function

begin_comment
comment|/* Returns true when *PTR may not be aliased to ALIAS.    See C standard 6.5p7 and C++ standard 3.10p15.    If PTR_PTR is true, ALIAS represents a pointer or reference to the    aliased storage rather than its actual name.  */
end_comment

begin_function
specifier|static
name|bool
name|nonstandard_alias_p
parameter_list|(
name|tree
name|ptr
parameter_list|,
name|tree
name|alias
parameter_list|,
name|bool
name|ptr_ptr
parameter_list|)
block|{
comment|/* Find the types to compare.  */
name|tree
name|ptr_type
init|=
name|get_otype
argument_list|(
name|ptr
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|tree
name|alias_type
init|=
name|get_otype
argument_list|(
name|alias
argument_list|,
name|ptr_ptr
argument_list|)
decl_stmt|;
comment|/* XXX: for now, say it's OK if the alias escapes.      Not sure this is needed in general, but otherwise GCC will not      bootstrap.  */
if|if
condition|(
name|var_ann
argument_list|(
name|get_ssa_base
argument_list|(
name|alias
argument_list|)
argument_list|)
operator|->
name|escape_mask
operator|!=
name|NO_ESCAPE
condition|)
return|return
name|false
return|;
comment|/* XXX: don't get into structures for now.  It brings much complication      and little benefit.  */
if|if
condition|(
name|struct_class_union_p
argument_list|(
name|ptr_type
argument_list|)
operator|||
name|struct_class_union_p
argument_list|(
name|alias_type
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* XXX: In 4.2.1, field resolution in alias is not as good as in pre-4.3      This fixes problems found during the backport, where a pointer to the      first field of a struct appears to be aliased to the whole struct.  */
if|if
condition|(
name|struct_field_tag_p
argument_list|(
name|alias
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If they are both SSA names of artificials, let it go, the warning      is too confusing.  */
if|if
condition|(
name|find_first_artificial_name
argument_list|(
name|ptr
argument_list|)
operator|&&
name|find_first_artificial_name
argument_list|(
name|alias
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Compare the types.  */
return|return
name|nonstandard_alias_types_p
argument_list|(
name|ptr_type
argument_list|,
name|alias_type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true when we should skip analysis for pointer PTR based on the    fact that their alias information *PI is not considered relevant.  */
end_comment

begin_function
specifier|static
name|bool
name|skip_this_pointer
parameter_list|(
name|tree
name|ptr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|ptr_info_def
modifier|*
name|pi
parameter_list|)
block|{
comment|/* If it is not dereferenced, it is not a problem (locally).  */
if|if
condition|(
operator|!
name|pi
operator|->
name|is_dereferenced
condition|)
return|return
name|true
return|;
comment|/* This would probably cause too many false positives.  */
if|if
condition|(
name|pi
operator|->
name|value_escapes_p
operator|||
name|pi
operator|->
name|pt_anything
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Find aliasing to named objects for pointer PTR.  */
end_comment

begin_function
specifier|static
name|void
name|dsa_named_for
parameter_list|(
name|tree
name|ptr
parameter_list|)
block|{
name|struct
name|ptr_info_def
modifier|*
name|pi
init|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|pi
condition|)
block|{
if|if
condition|(
name|skip_this_pointer
argument_list|(
name|ptr
argument_list|,
name|pi
argument_list|)
condition|)
return|return;
comment|/* For all the variables it could be aliased to.  */
if|if
condition|(
name|pi
operator|->
name|pt_vars
condition|)
block|{
name|unsigned
name|ix
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|pi->pt_vars
argument_list|,
literal|0
argument_list|,
argument|ix
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|alias
init|=
name|referenced_var
argument_list|(
name|ix
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_global_var
argument_list|(
name|alias
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|nonstandard_alias_p
argument_list|(
name|ptr
argument_list|,
name|alias
argument_list|,
name|false
argument_list|)
condition|)
name|strict_aliasing_warn
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|true
argument_list|,
name|alias
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Detect and report strict aliasing violation of named objects.  */
end_comment

begin_function
specifier|static
name|void
name|detect_strict_aliasing_named
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_ssa_names
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|ptr
init|=
name|ssa_name
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL_TREE
condition|)
continue|continue;
name|pi
operator|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SSA_NAME_IN_FREE_LIST
argument_list|(
name|ptr
argument_list|)
operator|&&
name|pi
operator|&&
name|pi
operator|->
name|name_mem_tag
condition|)
name|dsa_named_for
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return false only the first time I see each instance of FUNC.  */
end_comment

begin_function
specifier|static
name|bool
name|processed_func_p
parameter_list|(
name|tree
name|func
parameter_list|)
block|{
specifier|static
name|htab_t
name|seen
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
operator|!
name|seen
condition|)
name|seen
operator|=
name|htab_create
argument_list|(
literal|100
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|seen
argument_list|,
name|func
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
return|return
name|true
return|;
operator|*
name|slot
operator|=
name|func
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Detect and warn about type-punning using points-to information.  */
end_comment

begin_function
name|void
name|strict_aliasing_warning_backend
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|flag_strict_aliasing
operator|&&
name|warn_strict_aliasing
operator|==
literal|3
operator|&&
operator|!
name|processed_func_p
argument_list|(
name|current_function_decl
argument_list|)
operator|)
condition|)
return|return;
name|detect_strict_aliasing_named
argument_list|()
expr_stmt|;
name|maybe_free_reference_table
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

