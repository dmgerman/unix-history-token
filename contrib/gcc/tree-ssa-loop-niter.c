begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions to determine/estimate number of iterations of a loop.    Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree-chrec.h"
end_include

begin_include
include|#
directive|include
file|"tree-scalar-evolution.h"
end_include

begin_include
include|#
directive|include
file|"tree-data-ref.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_define
define|#
directive|define
name|SWAP
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|do { void *tmp = (X); (X) = (Y); (Y) = tmp; } while (0)
end_define

begin_comment
comment|/*     Analysis of number of iterations of an affine exit test.  */
end_comment

begin_comment
comment|/* Returns true if ARG is either NULL_TREE or constant zero.  Unlike    integer_zerop, it does not care about overflow flags.  */
end_comment

begin_function
name|bool
name|zero_p
parameter_list|(
name|tree
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arg
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|false
return|;
return|return
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if ARG a nonzero constant.  Unlike integer_nonzerop, it does    not care about overflow flags.  */
end_comment

begin_function
specifier|static
name|bool
name|nonzero_p
parameter_list|(
name|tree
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arg
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|false
return|;
return|return
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg
argument_list|)
operator|!=
literal|0
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|arg
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns inverse of X modulo 2^s, where MASK = 2^s-1.  */
end_comment

begin_function
specifier|static
name|tree
name|inverse
parameter_list|(
name|tree
name|x
parameter_list|,
name|tree
name|mask
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|tree
name|rslt
decl_stmt|;
name|unsigned
name|ctr
init|=
name|tree_floor_log2
argument_list|(
name|mask
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|ix
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|imask
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|irslt
init|=
literal|1
decl_stmt|;
name|gcc_assert
argument_list|(
name|cst_and_fits_in_hwi
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|cst_and_fits_in_hwi
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|ix
operator|=
name|int_cst_value
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|imask
operator|=
name|int_cst_value
argument_list|(
name|mask
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ctr
condition|;
name|ctr
operator|--
control|)
block|{
name|irslt
operator|*=
name|ix
expr_stmt|;
name|ix
operator|*=
name|ix
expr_stmt|;
block|}
name|irslt
operator|&=
name|imask
expr_stmt|;
name|rslt
operator|=
name|build_int_cst_type
argument_list|(
name|type
argument_list|,
name|irslt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rslt
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ctr
condition|;
name|ctr
operator|--
control|)
block|{
name|rslt
operator|=
name|int_const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|rslt
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|int_const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|x
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|rslt
operator|=
name|int_const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|rslt
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|rslt
return|;
block|}
end_function

begin_comment
comment|/* Determines number of iterations of loop whose ending condition    is IV<> FINAL.  TYPE is the type of the iv.  The number of    iterations is stored to NITER.  NEVER_INFINITE is true if    we know that the exit must be taken eventually, i.e., that the IV    ever reaches the value FINAL (we derived this earlier, and possibly set    NITER->assumptions to make sure this is the case).  */
end_comment

begin_function
specifier|static
name|bool
name|number_of_iterations_ne
parameter_list|(
name|tree
name|type
parameter_list|,
name|affine_iv
modifier|*
name|iv
parameter_list|,
name|tree
name|final
parameter_list|,
name|struct
name|tree_niter_desc
modifier|*
name|niter
parameter_list|,
name|bool
name|never_infinite
parameter_list|)
block|{
name|tree
name|niter_type
init|=
name|unsigned_type_for
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|s
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|bits
decl_stmt|,
name|assumption
decl_stmt|,
name|tmp
decl_stmt|,
name|bound
decl_stmt|;
name|niter
operator|->
name|control
operator|=
operator|*
name|iv
expr_stmt|;
name|niter
operator|->
name|bound
operator|=
name|final
expr_stmt|;
name|niter
operator|->
name|cmp
operator|=
name|NE_EXPR
expr_stmt|;
comment|/* Rearrange the terms so that we get inequality s * i<> c, with s      positive.  Also cast everything to the unsigned type.  */
if|if
condition|(
name|tree_int_cst_sign_bit
argument_list|(
name|iv
operator|->
name|step
argument_list|)
condition|)
block|{
name|s
operator|=
name|fold_convert
argument_list|(
name|niter_type
argument_list|,
name|fold_build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|iv
operator|->
name|step
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|niter_type
argument_list|,
name|fold_convert
argument_list|(
name|niter_type
argument_list|,
name|iv
operator|->
name|base
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|niter_type
argument_list|,
name|final
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|fold_convert
argument_list|(
name|niter_type
argument_list|,
name|iv
operator|->
name|step
argument_list|)
expr_stmt|;
name|c
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|niter_type
argument_list|,
name|fold_convert
argument_list|(
name|niter_type
argument_list|,
name|final
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|niter_type
argument_list|,
name|iv
operator|->
name|base
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* First the trivial cases -- when the step is 1.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|niter
operator|->
name|niter
operator|=
name|c
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Let nsd (step, size of mode) = d.  If d does not divide c, the loop      is infinite.  Otherwise, the number of iterations is      (inverse(s/d) * (c/d)) mod (size of mode/d).  */
name|bits
operator|=
name|num_ending_zeros
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bound
operator|=
name|build_low_bits_mask
argument_list|(
name|niter_type
argument_list|,
operator|(
name|TYPE_PRECISION
argument_list|(
name|niter_type
argument_list|)
operator|-
name|tree_low_cst
argument_list|(
name|bits
argument_list|,
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|fold_binary_to_constant
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|niter_type
argument_list|,
name|build_int_cst
argument_list|(
name|niter_type
argument_list|,
literal|1
argument_list|)
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|s
operator|=
name|fold_binary_to_constant
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|niter_type
argument_list|,
name|s
argument_list|,
name|bits
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|never_infinite
condition|)
block|{
comment|/* If we cannot assume that the loop is not infinite, record the 	 assumptions for divisibility of c.  */
name|assumption
operator|=
name|fold_build2
argument_list|(
name|FLOOR_MOD_EXPR
argument_list|,
name|niter_type
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|assumption
operator|=
name|fold_build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|assumption
argument_list|,
name|build_int_cst
argument_list|(
name|niter_type
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nonzero_p
argument_list|(
name|assumption
argument_list|)
condition|)
name|niter
operator|->
name|assumptions
operator|=
name|fold_build2
argument_list|(
name|TRUTH_AND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|niter
operator|->
name|assumptions
argument_list|,
name|assumption
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|fold_build2
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|niter_type
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|niter_type
argument_list|,
name|c
argument_list|,
name|inverse
argument_list|(
name|s
argument_list|,
name|bound
argument_list|)
argument_list|)
expr_stmt|;
name|niter
operator|->
name|niter
operator|=
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|niter_type
argument_list|,
name|tmp
argument_list|,
name|bound
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Checks whether we can determine the final value of the control variable    of the loop with ending condition IV0< IV1 (computed in TYPE).    DELTA is the difference IV1->base - IV0->base, STEP is the absolute value    of the step.  The assumptions necessary to ensure that the computation    of the final value does not overflow are recorded in NITER.  If we    find the final value, we adjust DELTA and return TRUE.  Otherwise    we return false.  */
end_comment

begin_function
specifier|static
name|bool
name|number_of_iterations_lt_to_ne
parameter_list|(
name|tree
name|type
parameter_list|,
name|affine_iv
modifier|*
name|iv0
parameter_list|,
name|affine_iv
modifier|*
name|iv1
parameter_list|,
name|struct
name|tree_niter_desc
modifier|*
name|niter
parameter_list|,
name|tree
modifier|*
name|delta
parameter_list|,
name|tree
name|step
parameter_list|)
block|{
name|tree
name|niter_type
init|=
name|TREE_TYPE
argument_list|(
name|step
argument_list|)
decl_stmt|;
name|tree
name|mod
init|=
name|fold_build2
argument_list|(
name|FLOOR_MOD_EXPR
argument_list|,
name|niter_type
argument_list|,
operator|*
name|delta
argument_list|,
name|step
argument_list|)
decl_stmt|;
name|tree
name|tmod
decl_stmt|;
name|tree
name|assumption
init|=
name|boolean_true_node
decl_stmt|,
name|bound
decl_stmt|,
name|noloop
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|mod
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|false
return|;
if|if
condition|(
name|nonzero_p
argument_list|(
name|mod
argument_list|)
condition|)
name|mod
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|niter_type
argument_list|,
name|step
argument_list|,
name|mod
argument_list|)
expr_stmt|;
name|tmod
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|mod
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonzero_p
argument_list|(
name|iv0
operator|->
name|step
argument_list|)
condition|)
block|{
comment|/* The final value of the iv is iv1->base + MOD, assuming that this 	 computation does not overflow, and that 	 iv0->base<= iv1->base + MOD.  */
if|if
condition|(
operator|!
name|iv1
operator|->
name|no_overflow
operator|&&
operator|!
name|zero_p
argument_list|(
name|mod
argument_list|)
condition|)
block|{
name|bound
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|tmod
argument_list|)
expr_stmt|;
name|assumption
operator|=
name|fold_build2
argument_list|(
name|LE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|iv1
operator|->
name|base
argument_list|,
name|bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero_p
argument_list|(
name|assumption
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|noloop
operator|=
name|fold_build2
argument_list|(
name|GT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|iv0
operator|->
name|base
argument_list|,
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|iv1
operator|->
name|base
argument_list|,
name|tmod
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The final value of the iv is iv0->base - MOD, assuming that this 	 computation does not overflow, and that 	 iv0->base - MOD<= iv1->base. */
if|if
condition|(
operator|!
name|iv0
operator|->
name|no_overflow
operator|&&
operator|!
name|zero_p
argument_list|(
name|mod
argument_list|)
condition|)
block|{
name|bound
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|tmod
argument_list|)
expr_stmt|;
name|assumption
operator|=
name|fold_build2
argument_list|(
name|GE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|iv0
operator|->
name|base
argument_list|,
name|bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero_p
argument_list|(
name|assumption
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|noloop
operator|=
name|fold_build2
argument_list|(
name|GT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|iv0
operator|->
name|base
argument_list|,
name|tmod
argument_list|)
argument_list|,
name|iv1
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nonzero_p
argument_list|(
name|assumption
argument_list|)
condition|)
name|niter
operator|->
name|assumptions
operator|=
name|fold_build2
argument_list|(
name|TRUTH_AND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|niter
operator|->
name|assumptions
argument_list|,
name|assumption
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zero_p
argument_list|(
name|noloop
argument_list|)
condition|)
name|niter
operator|->
name|may_be_zero
operator|=
name|fold_build2
argument_list|(
name|TRUTH_OR_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|niter
operator|->
name|may_be_zero
argument_list|,
name|noloop
argument_list|)
expr_stmt|;
operator|*
name|delta
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|niter_type
argument_list|,
operator|*
name|delta
argument_list|,
name|mod
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add assertions to NITER that ensure that the control variable of the loop    with ending condition IV0< IV1 does not overflow.  Types of IV0 and IV1    are TYPE.  Returns false if we can prove that there is an overflow, true    otherwise.  STEP is the absolute value of the step.  */
end_comment

begin_function
specifier|static
name|bool
name|assert_no_overflow_lt
parameter_list|(
name|tree
name|type
parameter_list|,
name|affine_iv
modifier|*
name|iv0
parameter_list|,
name|affine_iv
modifier|*
name|iv1
parameter_list|,
name|struct
name|tree_niter_desc
modifier|*
name|niter
parameter_list|,
name|tree
name|step
parameter_list|)
block|{
name|tree
name|bound
decl_stmt|,
name|d
decl_stmt|,
name|assumption
decl_stmt|,
name|diff
decl_stmt|;
name|tree
name|niter_type
init|=
name|TREE_TYPE
argument_list|(
name|step
argument_list|)
decl_stmt|;
if|if
condition|(
name|nonzero_p
argument_list|(
name|iv0
operator|->
name|step
argument_list|)
condition|)
block|{
comment|/* for (i = iv0->base; i< iv1->base; i += iv0->step) */
if|if
condition|(
name|iv0
operator|->
name|no_overflow
condition|)
return|return
name|true
return|;
comment|/* If iv0->base is a constant, we can determine the last value before 	 overflow precisely; otherwise we conservatively assume 	 MAX - STEP + 1.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|iv0
operator|->
name|base
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|d
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|niter_type
argument_list|,
name|fold_convert
argument_list|(
name|niter_type
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|niter_type
argument_list|,
name|iv0
operator|->
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|diff
operator|=
name|fold_build2
argument_list|(
name|FLOOR_MOD_EXPR
argument_list|,
name|niter_type
argument_list|,
name|d
argument_list|,
name|step
argument_list|)
expr_stmt|;
block|}
else|else
name|diff
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|niter_type
argument_list|,
name|step
argument_list|,
name|build_int_cst
argument_list|(
name|niter_type
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|bound
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|assumption
operator|=
name|fold_build2
argument_list|(
name|LE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|iv1
operator|->
name|base
argument_list|,
name|bound
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* for (i = iv1->base; i> iv0->base; i += iv1->step) */
if|if
condition|(
name|iv1
operator|->
name|no_overflow
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|iv1
operator|->
name|base
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|d
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|niter_type
argument_list|,
name|fold_convert
argument_list|(
name|niter_type
argument_list|,
name|iv1
operator|->
name|base
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|niter_type
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|diff
operator|=
name|fold_build2
argument_list|(
name|FLOOR_MOD_EXPR
argument_list|,
name|niter_type
argument_list|,
name|d
argument_list|,
name|step
argument_list|)
expr_stmt|;
block|}
else|else
name|diff
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|niter_type
argument_list|,
name|step
argument_list|,
name|build_int_cst
argument_list|(
name|niter_type
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|bound
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|assumption
operator|=
name|fold_build2
argument_list|(
name|GE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|iv0
operator|->
name|base
argument_list|,
name|bound
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zero_p
argument_list|(
name|assumption
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|nonzero_p
argument_list|(
name|assumption
argument_list|)
condition|)
name|niter
operator|->
name|assumptions
operator|=
name|fold_build2
argument_list|(
name|TRUTH_AND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|niter
operator|->
name|assumptions
argument_list|,
name|assumption
argument_list|)
expr_stmt|;
name|iv0
operator|->
name|no_overflow
operator|=
name|true
expr_stmt|;
name|iv1
operator|->
name|no_overflow
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add an assumption to NITER that a loop whose ending condition    is IV0< IV1 rolls.  TYPE is the type of the control iv.  */
end_comment

begin_function
specifier|static
name|void
name|assert_loop_rolls_lt
parameter_list|(
name|tree
name|type
parameter_list|,
name|affine_iv
modifier|*
name|iv0
parameter_list|,
name|affine_iv
modifier|*
name|iv1
parameter_list|,
name|struct
name|tree_niter_desc
modifier|*
name|niter
parameter_list|)
block|{
name|tree
name|assumption
init|=
name|boolean_true_node
decl_stmt|,
name|bound
decl_stmt|,
name|diff
decl_stmt|;
name|tree
name|mbz
decl_stmt|,
name|mbzl
decl_stmt|,
name|mbzr
decl_stmt|;
if|if
condition|(
name|nonzero_p
argument_list|(
name|iv0
operator|->
name|step
argument_list|)
condition|)
block|{
name|diff
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|iv0
operator|->
name|step
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We need to know that iv0->base>= MIN + iv0->step - 1.  Since 	 0 address never belongs to any object, we can assume this for 	 pointers.  */
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|bound
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|assumption
operator|=
name|fold_build2
argument_list|(
name|GE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|iv0
operator|->
name|base
argument_list|,
name|bound
argument_list|)
expr_stmt|;
block|}
comment|/* And then we can compute iv0->base - diff, and compare it with 	 iv1->base.  */
name|mbzl
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|iv0
operator|->
name|base
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|mbzr
operator|=
name|iv1
operator|->
name|base
expr_stmt|;
block|}
else|else
block|{
name|diff
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|iv1
operator|->
name|step
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|bound
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|assumption
operator|=
name|fold_build2
argument_list|(
name|LE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|iv1
operator|->
name|base
argument_list|,
name|bound
argument_list|)
expr_stmt|;
block|}
name|mbzl
operator|=
name|iv0
operator|->
name|base
expr_stmt|;
name|mbzr
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|iv1
operator|->
name|base
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
name|mbz
operator|=
name|fold_build2
argument_list|(
name|GT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|mbzl
argument_list|,
name|mbzr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nonzero_p
argument_list|(
name|assumption
argument_list|)
condition|)
name|niter
operator|->
name|assumptions
operator|=
name|fold_build2
argument_list|(
name|TRUTH_AND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|niter
operator|->
name|assumptions
argument_list|,
name|assumption
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zero_p
argument_list|(
name|mbz
argument_list|)
condition|)
name|niter
operator|->
name|may_be_zero
operator|=
name|fold_build2
argument_list|(
name|TRUTH_OR_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|niter
operator|->
name|may_be_zero
argument_list|,
name|mbz
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determines number of iterations of loop whose ending condition    is IV0< IV1.  TYPE is the type of the iv.  The number of    iterations is stored to NITER.  */
end_comment

begin_function
specifier|static
name|bool
name|number_of_iterations_lt
parameter_list|(
name|tree
name|type
parameter_list|,
name|affine_iv
modifier|*
name|iv0
parameter_list|,
name|affine_iv
modifier|*
name|iv1
parameter_list|,
name|struct
name|tree_niter_desc
modifier|*
name|niter
parameter_list|,
name|bool
name|never_infinite
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|niter_type
init|=
name|unsigned_type_for
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|delta
decl_stmt|,
name|step
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|nonzero_p
argument_list|(
name|iv0
operator|->
name|step
argument_list|)
condition|)
block|{
name|niter
operator|->
name|control
operator|=
operator|*
name|iv0
expr_stmt|;
name|niter
operator|->
name|cmp
operator|=
name|LT_EXPR
expr_stmt|;
name|niter
operator|->
name|bound
operator|=
name|iv1
operator|->
name|base
expr_stmt|;
block|}
else|else
block|{
name|niter
operator|->
name|control
operator|=
operator|*
name|iv1
expr_stmt|;
name|niter
operator|->
name|cmp
operator|=
name|GT_EXPR
expr_stmt|;
name|niter
operator|->
name|bound
operator|=
name|iv0
operator|->
name|base
expr_stmt|;
block|}
name|delta
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|niter_type
argument_list|,
name|fold_convert
argument_list|(
name|niter_type
argument_list|,
name|iv1
operator|->
name|base
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|niter_type
argument_list|,
name|iv0
operator|->
name|base
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First handle the special case that the step is +-1.  */
if|if
condition|(
operator|(
name|iv0
operator|->
name|step
operator|&&
name|integer_onep
argument_list|(
name|iv0
operator|->
name|step
argument_list|)
operator|&&
name|zero_p
argument_list|(
name|iv1
operator|->
name|step
argument_list|)
operator|)
operator|||
operator|(
name|iv1
operator|->
name|step
operator|&&
name|integer_all_onesp
argument_list|(
name|iv1
operator|->
name|step
argument_list|)
operator|&&
name|zero_p
argument_list|(
name|iv0
operator|->
name|step
argument_list|)
operator|)
condition|)
block|{
comment|/* for (i = iv0->base; i< iv1->base; i++)  	 or  	 for (i = iv1->base; i> iv0->base; i--). 	      	 In both cases # of iterations is iv1->base - iv0->base, assuming that 	 iv1->base>= iv0->base.  */
name|niter
operator|->
name|may_be_zero
operator|=
name|fold_build2
argument_list|(
name|LT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|iv1
operator|->
name|base
argument_list|,
name|iv0
operator|->
name|base
argument_list|)
expr_stmt|;
name|niter
operator|->
name|niter
operator|=
name|delta
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|nonzero_p
argument_list|(
name|iv0
operator|->
name|step
argument_list|)
condition|)
name|step
operator|=
name|fold_convert
argument_list|(
name|niter_type
argument_list|,
name|iv0
operator|->
name|step
argument_list|)
expr_stmt|;
else|else
name|step
operator|=
name|fold_convert
argument_list|(
name|niter_type
argument_list|,
name|fold_build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|iv1
operator|->
name|step
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we can determine the final value of the control iv exactly, we can      transform the condition to != comparison.  In particular, this will be      the case if DELTA is constant.  */
if|if
condition|(
name|number_of_iterations_lt_to_ne
argument_list|(
name|type
argument_list|,
name|iv0
argument_list|,
name|iv1
argument_list|,
name|niter
argument_list|,
operator|&
name|delta
argument_list|,
name|step
argument_list|)
condition|)
block|{
name|affine_iv
name|zps
decl_stmt|;
name|zps
operator|.
name|base
operator|=
name|build_int_cst
argument_list|(
name|niter_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zps
operator|.
name|step
operator|=
name|step
expr_stmt|;
comment|/* number_of_iterations_lt_to_ne will add assumptions that ensure that 	 zps does not overflow.  */
name|zps
operator|.
name|no_overflow
operator|=
name|true
expr_stmt|;
return|return
name|number_of_iterations_ne
argument_list|(
name|type
argument_list|,
operator|&
name|zps
argument_list|,
name|delta
argument_list|,
name|niter
argument_list|,
name|true
argument_list|)
return|;
block|}
comment|/* Make sure that the control iv does not overflow.  */
if|if
condition|(
operator|!
name|assert_no_overflow_lt
argument_list|(
name|type
argument_list|,
name|iv0
argument_list|,
name|iv1
argument_list|,
name|niter
argument_list|,
name|step
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We determine the number of iterations as (delta + step - 1) / step.  For      this to work, we must know that iv1->base>= iv0->base - step + 1,      otherwise the loop does not roll.  */
name|assert_loop_rolls_lt
argument_list|(
name|type
argument_list|,
name|iv0
argument_list|,
name|iv1
argument_list|,
name|niter
argument_list|)
expr_stmt|;
name|s
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|niter_type
argument_list|,
name|step
argument_list|,
name|build_int_cst
argument_list|(
name|niter_type
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|niter_type
argument_list|,
name|delta
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|niter
operator|->
name|niter
operator|=
name|fold_build2
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|niter_type
argument_list|,
name|delta
argument_list|,
name|step
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Determines number of iterations of loop whose ending condition    is IV0<= IV1.  TYPE is the type of the iv.  The number of    iterations is stored to NITER.  NEVER_INFINITE is true if    we know that this condition must eventually become false (we derived this    earlier, and possibly set NITER->assumptions to make sure this    is the case).  */
end_comment

begin_function
specifier|static
name|bool
name|number_of_iterations_le
parameter_list|(
name|tree
name|type
parameter_list|,
name|affine_iv
modifier|*
name|iv0
parameter_list|,
name|affine_iv
modifier|*
name|iv1
parameter_list|,
name|struct
name|tree_niter_desc
modifier|*
name|niter
parameter_list|,
name|bool
name|never_infinite
parameter_list|)
block|{
name|tree
name|assumption
decl_stmt|;
comment|/* Say that IV0 is the control variable.  Then IV0<= IV1 iff      IV0< IV1 + 1, assuming that IV1 is not equal to the greatest      value of the type.  This we must know anyway, since if it is      equal to this value, the loop rolls forever.  */
if|if
condition|(
operator|!
name|never_infinite
condition|)
block|{
if|if
condition|(
name|nonzero_p
argument_list|(
name|iv0
operator|->
name|step
argument_list|)
condition|)
name|assumption
operator|=
name|fold_build2
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|iv1
operator|->
name|base
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|assumption
operator|=
name|fold_build2
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|iv0
operator|->
name|base
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero_p
argument_list|(
name|assumption
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|nonzero_p
argument_list|(
name|assumption
argument_list|)
condition|)
name|niter
operator|->
name|assumptions
operator|=
name|fold_build2
argument_list|(
name|TRUTH_AND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|niter
operator|->
name|assumptions
argument_list|,
name|assumption
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nonzero_p
argument_list|(
name|iv0
operator|->
name|step
argument_list|)
condition|)
name|iv1
operator|->
name|base
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|iv1
operator|->
name|base
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|iv0
operator|->
name|base
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|iv0
operator|->
name|base
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|number_of_iterations_lt
argument_list|(
name|type
argument_list|,
name|iv0
argument_list|,
name|iv1
argument_list|,
name|niter
argument_list|,
name|never_infinite
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine the number of iterations according to condition (for staying    inside loop) which compares two induction variables using comparison    operator CODE.  The induction variable on left side of the comparison    is IV0, the right-hand side is IV1.  Both induction variables must have    type TYPE, which must be an integer or pointer type.  The steps of the    ivs must be constants (or NULL_TREE, which is interpreted as constant zero).     ONLY_EXIT is true if we are sure this is the only way the loop could be    exited (including possibly non-returning function calls, exceptions, etc.)    -- in this case we can use the information whether the control induction    variables can overflow or not in a more efficient way.        The results (number of iterations and assumptions as described in    comments at struct tree_niter_desc in tree-flow.h) are stored to NITER.    Returns false if it fails to determine number of iterations, true if it    was determined (possibly with some assumptions).  */
end_comment

begin_function
specifier|static
name|bool
name|number_of_iterations_cond
parameter_list|(
name|tree
name|type
parameter_list|,
name|affine_iv
modifier|*
name|iv0
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
name|affine_iv
modifier|*
name|iv1
parameter_list|,
name|struct
name|tree_niter_desc
modifier|*
name|niter
parameter_list|,
name|bool
name|only_exit
parameter_list|)
block|{
name|bool
name|never_infinite
decl_stmt|;
comment|/* The meaning of these assumptions is this:      if !assumptions        then the rest of information does not have to be valid      if may_be_zero then the loop does not roll, even if        niter != 0.  */
name|niter
operator|->
name|assumptions
operator|=
name|boolean_true_node
expr_stmt|;
name|niter
operator|->
name|may_be_zero
operator|=
name|boolean_false_node
expr_stmt|;
name|niter
operator|->
name|niter
operator|=
name|NULL_TREE
expr_stmt|;
name|niter
operator|->
name|additional_info
operator|=
name|boolean_true_node
expr_stmt|;
name|niter
operator|->
name|bound
operator|=
name|NULL_TREE
expr_stmt|;
name|niter
operator|->
name|cmp
operator|=
name|ERROR_MARK
expr_stmt|;
comment|/* Make< comparison from> ones, and for NE_EXPR comparisons, ensure that      the control variable is on lhs.  */
if|if
condition|(
name|code
operator|==
name|GE_EXPR
operator|||
name|code
operator|==
name|GT_EXPR
operator|||
operator|(
name|code
operator|==
name|NE_EXPR
operator|&&
name|zero_p
argument_list|(
name|iv0
operator|->
name|step
argument_list|)
operator|)
condition|)
block|{
name|SWAP
argument_list|(
name|iv0
argument_list|,
name|iv1
argument_list|)
expr_stmt|;
name|code
operator|=
name|swap_tree_comparison
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|only_exit
condition|)
block|{
comment|/* If this is not the only possible exit from the loop, the information 	 that the induction variables cannot overflow as derived from 	 signedness analysis cannot be relied upon.  We use them e.g. in the 	 following way:  given loop for (i = 0; i<= n; i++), if i is 	 signed, it cannot overflow, thus this loop is equivalent to 	 for (i = 0; i< n + 1; i++);  however, if n == MAX, but the loop 	 is exited in some other way before i overflows, this transformation 	 is incorrect (the new loop exits immediately).  */
name|iv0
operator|->
name|no_overflow
operator|=
name|false
expr_stmt|;
name|iv1
operator|->
name|no_overflow
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Comparison of pointers is undefined unless both iv0 and iv1 point 	 to the same object.  If they do, the control variable cannot wrap 	 (as wrap around the bounds of memory will never return a pointer 	 that would be guaranteed to point to the same object, even if we 	 avoid undefined behavior by casting to size_t and back).  The 	 restrictions on pointer arithmetics and comparisons of pointers 	 ensure that using the no-overflow assumptions is correct in this 	 case even if ONLY_EXIT is false.  */
name|iv0
operator|->
name|no_overflow
operator|=
name|true
expr_stmt|;
name|iv1
operator|->
name|no_overflow
operator|=
name|true
expr_stmt|;
block|}
comment|/* If the control induction variable does not overflow, the loop obviously      cannot be infinite.  */
if|if
condition|(
operator|!
name|zero_p
argument_list|(
name|iv0
operator|->
name|step
argument_list|)
operator|&&
name|iv0
operator|->
name|no_overflow
condition|)
name|never_infinite
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|zero_p
argument_list|(
name|iv1
operator|->
name|step
argument_list|)
operator|&&
name|iv1
operator|->
name|no_overflow
condition|)
name|never_infinite
operator|=
name|true
expr_stmt|;
else|else
name|never_infinite
operator|=
name|false
expr_stmt|;
comment|/* We can handle the case when neither of the sides of the comparison is      invariant, provided that the test is NE_EXPR.  This rarely occurs in      practice, but it is simple enough to manage.  */
if|if
condition|(
operator|!
name|zero_p
argument_list|(
name|iv0
operator|->
name|step
argument_list|)
operator|&&
operator|!
name|zero_p
argument_list|(
name|iv1
operator|->
name|step
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|!=
name|NE_EXPR
condition|)
return|return
name|false
return|;
name|iv0
operator|->
name|step
operator|=
name|fold_binary_to_constant
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|iv0
operator|->
name|step
argument_list|,
name|iv1
operator|->
name|step
argument_list|)
expr_stmt|;
name|iv0
operator|->
name|no_overflow
operator|=
name|false
expr_stmt|;
name|iv1
operator|->
name|step
operator|=
name|NULL_TREE
expr_stmt|;
name|iv1
operator|->
name|no_overflow
operator|=
name|true
expr_stmt|;
block|}
comment|/* If the result of the comparison is a constant,  the loop is weird.  More      precise handling would be possible, but the situation is not common enough      to waste time on it.  */
if|if
condition|(
name|zero_p
argument_list|(
name|iv0
operator|->
name|step
argument_list|)
operator|&&
name|zero_p
argument_list|(
name|iv1
operator|->
name|step
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Ignore loops of while (i--< 10) type.  */
if|if
condition|(
name|code
operator|!=
name|NE_EXPR
condition|)
block|{
if|if
condition|(
name|iv0
operator|->
name|step
operator|&&
name|tree_int_cst_sign_bit
argument_list|(
name|iv0
operator|->
name|step
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|zero_p
argument_list|(
name|iv1
operator|->
name|step
argument_list|)
operator|&&
operator|!
name|tree_int_cst_sign_bit
argument_list|(
name|iv1
operator|->
name|step
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* If the loop exits immediately, there is nothing to do.  */
if|if
condition|(
name|zero_p
argument_list|(
name|fold_build2
argument_list|(
name|code
argument_list|,
name|boolean_type_node
argument_list|,
name|iv0
operator|->
name|base
argument_list|,
name|iv1
operator|->
name|base
argument_list|)
argument_list|)
condition|)
block|{
name|niter
operator|->
name|niter
operator|=
name|build_int_cst
argument_list|(
name|unsigned_type_for
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* OK, now we know we have a senseful loop.  Handle several cases, depending      on what comparison operator is used.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE_EXPR
case|:
name|gcc_assert
argument_list|(
name|zero_p
argument_list|(
name|iv1
operator|->
name|step
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|number_of_iterations_ne
argument_list|(
name|type
argument_list|,
name|iv0
argument_list|,
name|iv1
operator|->
name|base
argument_list|,
name|niter
argument_list|,
name|never_infinite
argument_list|)
return|;
case|case
name|LT_EXPR
case|:
return|return
name|number_of_iterations_lt
argument_list|(
name|type
argument_list|,
name|iv0
argument_list|,
name|iv1
argument_list|,
name|niter
argument_list|,
name|never_infinite
argument_list|)
return|;
case|case
name|LE_EXPR
case|:
return|return
name|number_of_iterations_le
argument_list|(
name|type
argument_list|,
name|iv0
argument_list|,
name|iv1
argument_list|,
name|niter
argument_list|,
name|never_infinite
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Substitute NEW for OLD in EXPR and fold the result.  */
end_comment

begin_function
specifier|static
name|tree
name|simplify_replace_tree
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|old
parameter_list|,
name|tree
name|new
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|n
decl_stmt|;
name|tree
name|ret
init|=
name|NULL_TREE
decl_stmt|,
name|e
decl_stmt|,
name|se
decl_stmt|;
if|if
condition|(
operator|!
name|expr
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|expr
operator|==
name|old
operator|||
name|operand_equal_p
argument_list|(
name|expr
argument_list|,
name|old
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|unshare_expr
argument_list|(
name|new
argument_list|)
return|;
if|if
condition|(
operator|!
name|EXPR_P
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|expr
return|;
name|n
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|e
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|se
operator|=
name|simplify_replace_tree
argument_list|(
name|e
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|se
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|copy_node
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|ret
argument_list|,
name|i
argument_list|)
operator|=
name|se
expr_stmt|;
block|}
return|return
operator|(
name|ret
condition|?
name|fold
argument_list|(
name|ret
argument_list|)
else|:
name|expr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Expand definitions of ssa names in EXPR as long as they are simple    enough, and return the new expression.  */
end_comment

begin_function
name|tree
name|expand_simple_operations
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|n
decl_stmt|;
name|tree
name|ret
init|=
name|NULL_TREE
decl_stmt|,
name|e
decl_stmt|,
name|ee
decl_stmt|,
name|stmt
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL_TREE
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|expr
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
argument_list|)
condition|)
block|{
name|n
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|e
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ee
operator|=
name|expand_simple_operations
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|ee
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|copy_node
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|ret
argument_list|,
name|i
argument_list|)
operator|=
name|ee
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|expr
return|;
name|fold_defer_overflow_warnings
argument_list|()
expr_stmt|;
name|ret
operator|=
name|fold
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|fold_undefer_and_ignore_overflow_warnings
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|expr
return|;
name|stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|expr
return|;
name|e
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
comment|/* Casts are simple.  */
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|!=
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|!=
name|CONVERT_EXPR
comment|/* Copies are simple.  */
operator|&&
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|!=
name|SSA_NAME
comment|/* Assignments of invariants are simple.  */
operator|&&
operator|!
name|is_gimple_min_invariant
argument_list|(
name|e
argument_list|)
comment|/* And increments and decrements by a constant are simple.  */
operator|&&
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|expr
return|;
return|return
name|expand_simple_operations
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Tries to simplify EXPR using the condition COND.  Returns the simplified    expression (or EXPR unchanged, if no simplification was possible).  */
end_comment

begin_function
specifier|static
name|tree
name|tree_simplify_using_condition_1
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|bool
name|changed
decl_stmt|;
name|tree
name|e
decl_stmt|,
name|te
decl_stmt|,
name|e0
decl_stmt|,
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|notcond
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|INTEGER_CST
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|code
operator|==
name|TRUTH_OR_EXPR
operator|||
name|code
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code
operator|==
name|COND_EXPR
condition|)
block|{
name|changed
operator|=
name|false
expr_stmt|;
name|e0
operator|=
name|tree_simplify_using_condition_1
argument_list|(
name|cond
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
operator|!=
name|e0
condition|)
name|changed
operator|=
name|true
expr_stmt|;
name|e1
operator|=
name|tree_simplify_using_condition_1
argument_list|(
name|cond
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
operator|!=
name|e1
condition|)
name|changed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
block|{
name|e2
operator|=
name|tree_simplify_using_condition_1
argument_list|(
name|cond
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
operator|!=
name|e2
condition|)
name|changed
operator|=
name|true
expr_stmt|;
block|}
else|else
name|e2
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
name|expr
operator|=
name|fold_build3
argument_list|(
name|code
argument_list|,
name|boolean_type_node
argument_list|,
name|e0
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
else|else
name|expr
operator|=
name|fold_build2
argument_list|(
name|code
argument_list|,
name|boolean_type_node
argument_list|,
name|e0
argument_list|,
name|e1
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
comment|/* In case COND is equality, we may be able to simplify EXPR by copy/constant      propagation, and vice versa.  Fold does not handle this, since it is      considered too expensive.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ_EXPR
condition|)
block|{
name|e0
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e1
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We know that e0 == e1.  Check whether we cannot simplify expr 	 using this fact.  */
name|e
operator|=
name|simplify_replace_tree
argument_list|(
name|expr
argument_list|,
name|e0
argument_list|,
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero_p
argument_list|(
name|e
argument_list|)
operator|||
name|nonzero_p
argument_list|(
name|e
argument_list|)
condition|)
return|return
name|e
return|;
name|e
operator|=
name|simplify_replace_tree
argument_list|(
name|expr
argument_list|,
name|e1
argument_list|,
name|e0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero_p
argument_list|(
name|e
argument_list|)
operator|||
name|nonzero_p
argument_list|(
name|e
argument_list|)
condition|)
return|return
name|e
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|EQ_EXPR
condition|)
block|{
name|e0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e1
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If e0 == e1 (EXPR) implies !COND, then EXPR cannot be true.  */
name|e
operator|=
name|simplify_replace_tree
argument_list|(
name|cond
argument_list|,
name|e0
argument_list|,
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero_p
argument_list|(
name|e
argument_list|)
condition|)
return|return
name|e
return|;
name|e
operator|=
name|simplify_replace_tree
argument_list|(
name|cond
argument_list|,
name|e1
argument_list|,
name|e0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero_p
argument_list|(
name|e
argument_list|)
condition|)
return|return
name|e
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NE_EXPR
condition|)
block|{
name|e0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e1
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If e0 == e1 (!EXPR) implies !COND, then EXPR must be true.  */
name|e
operator|=
name|simplify_replace_tree
argument_list|(
name|cond
argument_list|,
name|e0
argument_list|,
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero_p
argument_list|(
name|e
argument_list|)
condition|)
return|return
name|boolean_true_node
return|;
name|e
operator|=
name|simplify_replace_tree
argument_list|(
name|cond
argument_list|,
name|e1
argument_list|,
name|e0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero_p
argument_list|(
name|e
argument_list|)
condition|)
return|return
name|boolean_true_node
return|;
block|}
name|te
operator|=
name|expand_simple_operations
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Check whether COND ==> EXPR.  */
name|notcond
operator|=
name|invert_truthvalue
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|e
operator|=
name|fold_binary
argument_list|(
name|TRUTH_OR_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|notcond
argument_list|,
name|te
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonzero_p
argument_list|(
name|e
argument_list|)
condition|)
return|return
name|e
return|;
comment|/* Check whether COND ==> not EXPR.  */
name|e
operator|=
name|fold_binary
argument_list|(
name|TRUTH_AND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|cond
argument_list|,
name|te
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|&&
name|zero_p
argument_list|(
name|e
argument_list|)
condition|)
return|return
name|e
return|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Tries to simplify EXPR using the condition COND.  Returns the simplified    expression (or EXPR unchanged, if no simplification was possible).    Wrapper around tree_simplify_using_condition_1 that ensures that chains    of simple operations in definitions of ssa names in COND are expanded,    so that things like casts or incrementing the value of the bound before    the loop do not cause us to fail.  */
end_comment

begin_function
specifier|static
name|tree
name|tree_simplify_using_condition
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|cond
operator|=
name|expand_simple_operations
argument_list|(
name|cond
argument_list|)
expr_stmt|;
return|return
name|tree_simplify_using_condition_1
argument_list|(
name|cond
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The maximum number of dominator BBs we search for conditions    of loop header copies we use for simplifying a conditional    expression.  */
end_comment

begin_define
define|#
directive|define
name|MAX_DOMINATORS_TO_WALK
value|8
end_define

begin_comment
comment|/* Tries to simplify EXPR using the conditions on entry to LOOP.    Record the conditions used for simplification to CONDS_USED.    Returns the simplified expression (or EXPR unchanged, if no    simplification was possible).*/
end_comment

begin_function
specifier|static
name|tree
name|simplify_using_initial_conditions
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|expr
parameter_list|,
name|tree
modifier|*
name|conds_used
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|tree
name|exp
decl_stmt|,
name|cond
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|expr
return|;
comment|/* Limit walking the dominators to avoid quadraticness in      the number of BBs times the number of loops in degenerate      cases.  */
for|for
control|(
name|bb
operator|=
name|loop
operator|->
name|header
init|;
name|bb
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|cnt
operator|<
name|MAX_DOMINATORS_TO_WALK
condition|;
name|bb
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|single_pred_p
argument_list|(
name|bb
argument_list|)
condition|)
continue|continue;
name|e
operator|=
name|single_pred_edge
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_TRUE_VALUE
operator||
name|EDGE_FALSE_VALUE
operator|)
operator|)
condition|)
continue|continue;
name|cond
operator|=
name|COND_EXPR_COND
argument_list|(
name|last_stmt
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALSE_VALUE
condition|)
name|cond
operator|=
name|invert_truthvalue
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|exp
operator|=
name|tree_simplify_using_condition
argument_list|(
name|cond
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|!=
name|expr
condition|)
operator|*
name|conds_used
operator|=
name|fold_build2
argument_list|(
name|TRUTH_AND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
operator|*
name|conds_used
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|expr
operator|=
name|exp
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Tries to simplify EXPR using the evolutions of the loop invariants    in the superloops of LOOP.  Returns the simplified expression    (or EXPR unchanged, if no simplification was possible).  */
end_comment

begin_function
specifier|static
name|tree
name|simplify_using_outer_evolutions
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|bool
name|changed
decl_stmt|;
name|tree
name|e
decl_stmt|,
name|e0
decl_stmt|,
name|e1
decl_stmt|,
name|e2
decl_stmt|;
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|code
operator|==
name|TRUTH_OR_EXPR
operator|||
name|code
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code
operator|==
name|COND_EXPR
condition|)
block|{
name|changed
operator|=
name|false
expr_stmt|;
name|e0
operator|=
name|simplify_using_outer_evolutions
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
operator|!=
name|e0
condition|)
name|changed
operator|=
name|true
expr_stmt|;
name|e1
operator|=
name|simplify_using_outer_evolutions
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
operator|!=
name|e1
condition|)
name|changed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
block|{
name|e2
operator|=
name|simplify_using_outer_evolutions
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
operator|!=
name|e2
condition|)
name|changed
operator|=
name|true
expr_stmt|;
block|}
else|else
name|e2
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
name|expr
operator|=
name|fold_build3
argument_list|(
name|code
argument_list|,
name|boolean_type_node
argument_list|,
name|e0
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
else|else
name|expr
operator|=
name|fold_build2
argument_list|(
name|code
argument_list|,
name|boolean_type_node
argument_list|,
name|e0
argument_list|,
name|e1
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
name|e
operator|=
name|instantiate_parameters
argument_list|(
name|loop
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|e
argument_list|)
condition|)
return|return
name|e
return|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Returns true if EXIT is the only possible exit from LOOP.  */
end_comment

begin_function
specifier|static
name|bool
name|loop_only_exit_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|edge
name|exit
parameter_list|)
block|{
name|basic_block
modifier|*
name|body
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|tree
name|call
decl_stmt|;
if|if
condition|(
name|exit
operator|!=
name|loop
operator|->
name|single_exit
condition|)
return|return
name|false
return|;
name|body
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|body
index|[
literal|0
index|]
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|call
operator|=
name|get_call_expr_in
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|call
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|call
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Stores description of number of iterations of LOOP derived from    EXIT (an exit edge of the LOOP) in NITER.  Returns true if some    useful information could be derived (and fields of NITER has    meaning described in comments at struct tree_niter_desc    declaration), false otherwise.  If WARN is true and    -Wunsafe-loop-optimizations was given, warn if the optimizer is going to use    potentially unsafe assumptions.  */
end_comment

begin_function
name|bool
name|number_of_iterations_exit
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|edge
name|exit
parameter_list|,
name|struct
name|tree_niter_desc
modifier|*
name|niter
parameter_list|,
name|bool
name|warn
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|,
name|cond
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|affine_iv
name|iv0
decl_stmt|,
name|iv1
decl_stmt|;
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loop
operator|->
name|latch
argument_list|,
name|exit
operator|->
name|src
argument_list|)
condition|)
return|return
name|false
return|;
name|niter
operator|->
name|assumptions
operator|=
name|boolean_false_node
expr_stmt|;
name|stmt
operator|=
name|last_stmt
argument_list|(
name|exit
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stmt
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|COND_EXPR
condition|)
return|return
name|false
return|;
comment|/* We want the condition for staying inside loop.  */
name|cond
operator|=
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit
operator|->
name|flags
operator|&
name|EDGE_TRUE_VALUE
condition|)
name|cond
operator|=
name|invert_truthvalue
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
break|break;
default|default:
return|return
name|false
return|;
block|}
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|simple_iv
argument_list|(
name|loop
argument_list|,
name|stmt
argument_list|,
name|op0
argument_list|,
operator|&
name|iv0
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|simple_iv
argument_list|(
name|loop
argument_list|,
name|stmt
argument_list|,
name|op1
argument_list|,
operator|&
name|iv1
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We don't want to see undefined signed overflow warnings while      computing the nmber of iterations.  */
name|fold_defer_overflow_warnings
argument_list|()
expr_stmt|;
name|iv0
operator|.
name|base
operator|=
name|expand_simple_operations
argument_list|(
name|iv0
operator|.
name|base
argument_list|)
expr_stmt|;
name|iv1
operator|.
name|base
operator|=
name|expand_simple_operations
argument_list|(
name|iv1
operator|.
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|number_of_iterations_cond
argument_list|(
name|type
argument_list|,
operator|&
name|iv0
argument_list|,
name|code
argument_list|,
operator|&
name|iv1
argument_list|,
name|niter
argument_list|,
name|loop_only_exit_p
argument_list|(
name|loop
argument_list|,
name|exit
argument_list|)
argument_list|)
condition|)
block|{
name|fold_undefer_and_ignore_overflow_warnings
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|optimize
operator|>=
literal|3
condition|)
block|{
name|niter
operator|->
name|assumptions
operator|=
name|simplify_using_outer_evolutions
argument_list|(
name|loop
argument_list|,
name|niter
operator|->
name|assumptions
argument_list|)
expr_stmt|;
name|niter
operator|->
name|may_be_zero
operator|=
name|simplify_using_outer_evolutions
argument_list|(
name|loop
argument_list|,
name|niter
operator|->
name|may_be_zero
argument_list|)
expr_stmt|;
name|niter
operator|->
name|niter
operator|=
name|simplify_using_outer_evolutions
argument_list|(
name|loop
argument_list|,
name|niter
operator|->
name|niter
argument_list|)
expr_stmt|;
block|}
name|niter
operator|->
name|additional_info
operator|=
name|boolean_true_node
expr_stmt|;
name|niter
operator|->
name|assumptions
operator|=
name|simplify_using_initial_conditions
argument_list|(
name|loop
argument_list|,
name|niter
operator|->
name|assumptions
argument_list|,
operator|&
name|niter
operator|->
name|additional_info
argument_list|)
expr_stmt|;
name|niter
operator|->
name|may_be_zero
operator|=
name|simplify_using_initial_conditions
argument_list|(
name|loop
argument_list|,
name|niter
operator|->
name|may_be_zero
argument_list|,
operator|&
name|niter
operator|->
name|additional_info
argument_list|)
expr_stmt|;
name|fold_undefer_and_ignore_overflow_warnings
argument_list|()
expr_stmt|;
if|if
condition|(
name|integer_onep
argument_list|(
name|niter
operator|->
name|assumptions
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* With -funsafe-loop-optimizations we assume that nothing bad can happen.      But if we can prove that there is overflow or some other source of weird      behavior, ignore the loop even with -funsafe-loop-optimizations.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|niter
operator|->
name|assumptions
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|flag_unsafe_loop_optimizations
condition|)
name|niter
operator|->
name|assumptions
operator|=
name|boolean_true_node
expr_stmt|;
if|if
condition|(
name|warn
condition|)
block|{
specifier|const
name|char
modifier|*
name|wording
decl_stmt|;
name|location_t
name|loc
init|=
name|EXPR_LOCATION
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
comment|/* We can provide a more specific warning if one of the operator is 	 constant and the other advances by +1 or -1.  */
if|if
condition|(
operator|!
name|zero_p
argument_list|(
name|iv1
operator|.
name|step
argument_list|)
condition|?
operator|(
name|zero_p
argument_list|(
name|iv0
operator|.
name|step
argument_list|)
operator|&&
operator|(
name|integer_onep
argument_list|(
name|iv1
operator|.
name|step
argument_list|)
operator|||
name|integer_all_onesp
argument_list|(
name|iv1
operator|.
name|step
argument_list|)
operator|)
operator|)
else|:
operator|(
name|iv0
operator|.
name|step
operator|&&
operator|(
name|integer_onep
argument_list|(
name|iv0
operator|.
name|step
argument_list|)
operator|||
name|integer_all_onesp
argument_list|(
name|iv0
operator|.
name|step
argument_list|)
operator|)
operator|)
condition|)
name|wording
operator|=
name|flag_unsafe_loop_optimizations
condition|?
name|N_
argument_list|(
literal|"assuming that the loop is not infinite"
argument_list|)
else|:
name|N_
argument_list|(
literal|"cannot optimize possibly infinite loops"
argument_list|)
expr_stmt|;
else|else
name|wording
operator|=
name|flag_unsafe_loop_optimizations
condition|?
name|N_
argument_list|(
literal|"assuming that the loop counter does not overflow"
argument_list|)
else|:
name|N_
argument_list|(
literal|"cannot optimize loop, the loop counter may overflow"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOCATION_LINE
argument_list|(
name|loc
argument_list|)
operator|>
literal|0
condition|)
name|warning
argument_list|(
name|OPT_Wunsafe_loop_optimizations
argument_list|,
literal|"%H%s"
argument_list|,
operator|&
name|loc
argument_list|,
name|gettext
argument_list|(
name|wording
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wunsafe_loop_optimizations
argument_list|,
literal|"%s"
argument_list|,
name|gettext
argument_list|(
name|wording
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|flag_unsafe_loop_optimizations
return|;
block|}
end_function

begin_comment
comment|/* Try to determine the number of iterations of LOOP.  If we succeed,    expression giving number of iterations is returned and *EXIT is    set to the edge from that the information is obtained.  Otherwise    chrec_dont_know is returned.  */
end_comment

begin_function
name|tree
name|find_loop_niter
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|edge
modifier|*
name|exit
parameter_list|)
block|{
name|unsigned
name|n_exits
decl_stmt|,
name|i
decl_stmt|;
name|edge
modifier|*
name|exits
init|=
name|get_loop_exit_edges
argument_list|(
name|loop
argument_list|,
operator|&
name|n_exits
argument_list|)
decl_stmt|;
name|edge
name|ex
decl_stmt|;
name|tree
name|niter
init|=
name|NULL_TREE
decl_stmt|,
name|aniter
decl_stmt|;
name|struct
name|tree_niter_desc
name|desc
decl_stmt|;
operator|*
name|exit
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_exits
condition|;
name|i
operator|++
control|)
block|{
name|ex
operator|=
name|exits
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|just_once_each_iteration_p
argument_list|(
name|loop
argument_list|,
name|ex
operator|->
name|src
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|number_of_iterations_exit
argument_list|(
name|loop
argument_list|,
name|ex
argument_list|,
operator|&
name|desc
argument_list|,
name|false
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|nonzero_p
argument_list|(
name|desc
operator|.
name|may_be_zero
argument_list|)
condition|)
block|{
comment|/* We exit in the first iteration through this exit. 	     We won't find anything better.  */
name|niter
operator|=
name|build_int_cst
argument_list|(
name|unsigned_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|exit
operator|=
name|ex
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|zero_p
argument_list|(
name|desc
operator|.
name|may_be_zero
argument_list|)
condition|)
continue|continue;
name|aniter
operator|=
name|desc
operator|.
name|niter
expr_stmt|;
if|if
condition|(
operator|!
name|niter
condition|)
block|{
comment|/* Nothing recorded yet.  */
name|niter
operator|=
name|aniter
expr_stmt|;
operator|*
name|exit
operator|=
name|ex
expr_stmt|;
continue|continue;
block|}
comment|/* Prefer constants, the lower the better.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|aniter
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|niter
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|niter
operator|=
name|aniter
expr_stmt|;
operator|*
name|exit
operator|=
name|ex
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|aniter
argument_list|,
name|niter
argument_list|)
condition|)
block|{
name|niter
operator|=
name|aniter
expr_stmt|;
operator|*
name|exit
operator|=
name|ex
expr_stmt|;
continue|continue;
block|}
block|}
name|free
argument_list|(
name|exits
argument_list|)
expr_stmt|;
return|return
name|niter
condition|?
name|niter
else|:
name|chrec_dont_know
return|;
block|}
end_function

begin_comment
comment|/*     Analysis of a number of iterations of a loop by a brute-force evaluation.  */
end_comment

begin_comment
comment|/* Bound on the number of iterations we try to evaluate.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ITERATIONS_TO_TRACK
define|\
value|((unsigned) PARAM_VALUE (PARAM_MAX_ITERATIONS_TO_TRACK))
end_define

begin_comment
comment|/* Returns the loop phi node of LOOP such that ssa name X is derived from its    result by a chain of operations such that all but exactly one of their    operands are constants.  */
end_comment

begin_function
specifier|static
name|tree
name|chain_of_csts_start
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|x
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|tree
name|use
decl_stmt|;
name|basic_block
name|bb
init|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bb
operator|||
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
if|if
condition|(
name|bb
operator|==
name|loop
operator|->
name|header
condition|)
return|return
name|stmt
return|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_ALL_VIRTUALS
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|SINGLE_SSA_DEF_OPERAND
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_DEF
argument_list|)
operator|==
name|NULL_DEF_OPERAND_P
condition|)
return|return
name|NULL_TREE
return|;
name|use
operator|=
name|SINGLE_SSA_TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_USE
argument_list|)
expr_stmt|;
if|if
condition|(
name|use
operator|==
name|NULL_USE_OPERAND_P
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|chain_of_csts_start
argument_list|(
name|loop
argument_list|,
name|use
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determines whether the expression X is derived from a result of a phi node    in header of LOOP such that     * the derivation of X consists only from operations with constants    * the initial value of the phi node is constant    * the value of the phi node in the next iteration can be derived from the      value in the current iteration by a chain of operations with constants.        If such phi node exists, it is returned.  If X is a constant, X is returned    unchanged.  Otherwise NULL_TREE is returned.  */
end_comment

begin_function
specifier|static
name|tree
name|get_base_for
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|x
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|,
name|init
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|x
return|;
name|phi
operator|=
name|chain_of_csts_start
argument_list|(
name|loop
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phi
condition|)
return|return
name|NULL_TREE
return|;
name|init
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
name|next
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi
argument_list|,
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|next
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
name|init
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|chain_of_csts_start
argument_list|(
name|loop
argument_list|,
name|next
argument_list|)
operator|!=
name|phi
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|phi
return|;
block|}
end_function

begin_comment
comment|/* Given an expression X, then       * if X is NULL_TREE, we return the constant BASE.    * otherwise X is a SSA name, whose value in the considered loop is derived      by a chain of operations with constant from a result of a phi node in      the header of the loop.  Then we return value of X when the value of the      result of this phi node is given by the constant BASE.  */
end_comment

begin_function
specifier|static
name|tree
name|get_val_for
parameter_list|(
name|tree
name|x
parameter_list|,
name|tree
name|base
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|,
name|nx
decl_stmt|,
name|val
decl_stmt|;
name|use_operand_p
name|op
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|gcc_assert
argument_list|(
name|is_gimple_min_invariant
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
name|base
return|;
name|stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
return|return
name|base
return|;
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|op
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
name|nx
operator|=
name|USE_FROM_PTR
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|val
operator|=
name|get_val_for
argument_list|(
name|nx
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|SET_USE
argument_list|(
name|op
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|fold
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|SET_USE
argument_list|(
name|op
argument_list|,
name|nx
argument_list|)
expr_stmt|;
comment|/* only iterate loop once.  */
return|return
name|val
return|;
block|}
comment|/* Should never reach here.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tries to count the number of iterations of LOOP till it exits by EXIT    by brute force -- i.e. by determining the value of the operands of the    condition at EXIT in first few iterations of the loop (assuming that    these values are constant) and determining the first one in that the    condition is not satisfied.  Returns the constant giving the number    of the iterations of LOOP if successful, chrec_dont_know otherwise.  */
end_comment

begin_function
name|tree
name|loop_niter_by_eval
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|edge
name|exit
parameter_list|)
block|{
name|tree
name|cond
decl_stmt|,
name|cnd
decl_stmt|,
name|acnd
decl_stmt|;
name|tree
name|op
index|[
literal|2
index|]
decl_stmt|,
name|val
index|[
literal|2
index|]
decl_stmt|,
name|next
index|[
literal|2
index|]
decl_stmt|,
name|aval
index|[
literal|2
index|]
decl_stmt|,
name|phi
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|tree_code
name|cmp
decl_stmt|;
name|cond
operator|=
name|last_stmt
argument_list|(
name|exit
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
operator|||
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|!=
name|COND_EXPR
condition|)
return|return
name|chrec_dont_know
return|;
name|cnd
operator|=
name|COND_EXPR_COND
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit
operator|->
name|flags
operator|&
name|EDGE_TRUE_VALUE
condition|)
name|cnd
operator|=
name|invert_truthvalue
argument_list|(
name|cnd
argument_list|)
expr_stmt|;
name|cmp
operator|=
name|TREE_CODE
argument_list|(
name|cnd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmp
condition|)
block|{
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
name|op
index|[
name|j
index|]
operator|=
name|TREE_OPERAND
argument_list|(
name|cnd
argument_list|,
name|j
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|chrec_dont_know
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|phi
index|[
name|j
index|]
operator|=
name|get_base_for
argument_list|(
name|loop
argument_list|,
name|op
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phi
index|[
name|j
index|]
condition|)
return|return
name|chrec_dont_know
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|phi
index|[
name|j
index|]
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
name|val
index|[
name|j
index|]
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi
index|[
name|j
index|]
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
name|next
index|[
name|j
index|]
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi
index|[
name|j
index|]
argument_list|,
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
index|[
name|j
index|]
operator|=
name|phi
index|[
name|j
index|]
expr_stmt|;
name|next
index|[
name|j
index|]
operator|=
name|NULL_TREE
expr_stmt|;
name|op
index|[
name|j
index|]
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* Don't issue signed overflow warnings.  */
name|fold_defer_overflow_warnings
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ITERATIONS_TO_TRACK
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
name|aval
index|[
name|j
index|]
operator|=
name|get_val_for
argument_list|(
name|op
index|[
name|j
index|]
argument_list|,
name|val
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|acnd
operator|=
name|fold_binary
argument_list|(
name|cmp
argument_list|,
name|boolean_type_node
argument_list|,
name|aval
index|[
literal|0
index|]
argument_list|,
name|aval
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|acnd
operator|&&
name|zero_p
argument_list|(
name|acnd
argument_list|)
condition|)
block|{
name|fold_undefer_and_ignore_overflow_warnings
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Proved that loop %d iterates %d times using brute force.\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|build_int_cst
argument_list|(
name|unsigned_type_node
argument_list|,
name|i
argument_list|)
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|val
index|[
name|j
index|]
operator|=
name|get_val_for
argument_list|(
name|next
index|[
name|j
index|]
argument_list|,
name|val
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
name|val
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|fold_undefer_and_ignore_overflow_warnings
argument_list|()
expr_stmt|;
return|return
name|chrec_dont_know
return|;
block|}
block|}
block|}
name|fold_undefer_and_ignore_overflow_warnings
argument_list|()
expr_stmt|;
return|return
name|chrec_dont_know
return|;
block|}
end_function

begin_comment
comment|/* Finds the exit of the LOOP by that the loop exits after a constant    number of iterations and stores the exit edge to *EXIT.  The constant    giving the number of iterations of LOOP is returned.  The number of    iterations is determined using loop_niter_by_eval (i.e. by brute force    evaluation).  If we are unable to find the exit for that loop_niter_by_eval    determines the number of iterations, chrec_dont_know is returned.  */
end_comment

begin_function
name|tree
name|find_loop_niter_by_eval
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|edge
modifier|*
name|exit
parameter_list|)
block|{
name|unsigned
name|n_exits
decl_stmt|,
name|i
decl_stmt|;
name|edge
modifier|*
name|exits
init|=
name|get_loop_exit_edges
argument_list|(
name|loop
argument_list|,
operator|&
name|n_exits
argument_list|)
decl_stmt|;
name|edge
name|ex
decl_stmt|;
name|tree
name|niter
init|=
name|NULL_TREE
decl_stmt|,
name|aniter
decl_stmt|;
operator|*
name|exit
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_exits
condition|;
name|i
operator|++
control|)
block|{
name|ex
operator|=
name|exits
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|just_once_each_iteration_p
argument_list|(
name|loop
argument_list|,
name|ex
operator|->
name|src
argument_list|)
condition|)
continue|continue;
name|aniter
operator|=
name|loop_niter_by_eval
argument_list|(
name|loop
argument_list|,
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|aniter
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|niter
operator|&&
operator|!
name|tree_int_cst_lt
argument_list|(
name|aniter
argument_list|,
name|niter
argument_list|)
condition|)
continue|continue;
name|niter
operator|=
name|aniter
expr_stmt|;
operator|*
name|exit
operator|=
name|ex
expr_stmt|;
block|}
name|free
argument_list|(
name|exits
argument_list|)
expr_stmt|;
return|return
name|niter
condition|?
name|niter
else|:
name|chrec_dont_know
return|;
block|}
end_function

begin_comment
comment|/*     Analysis of upper bounds on number of iterations of a loop.  */
end_comment

begin_comment
comment|/* Returns true if we can prove that COND ==> VAL>= 0.  */
end_comment

begin_function
specifier|static
name|bool
name|implies_nonnegative_p
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|tree
name|compare
decl_stmt|;
if|if
condition|(
name|tree_expr_nonnegative_p
argument_list|(
name|val
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|nonzero_p
argument_list|(
name|cond
argument_list|)
condition|)
return|return
name|false
return|;
name|compare
operator|=
name|fold_build2
argument_list|(
name|GE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|val
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|compare
operator|=
name|tree_simplify_using_condition_1
argument_list|(
name|cond
argument_list|,
name|compare
argument_list|)
expr_stmt|;
return|return
name|nonzero_p
argument_list|(
name|compare
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if we can prove that COND ==> A>= B.  */
end_comment

begin_function
specifier|static
name|bool
name|implies_ge_p
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|a
parameter_list|,
name|tree
name|b
parameter_list|)
block|{
name|tree
name|compare
init|=
name|fold_build2
argument_list|(
name|GE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|nonzero_p
argument_list|(
name|compare
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|nonzero_p
argument_list|(
name|cond
argument_list|)
condition|)
return|return
name|false
return|;
name|compare
operator|=
name|tree_simplify_using_condition_1
argument_list|(
name|cond
argument_list|,
name|compare
argument_list|)
expr_stmt|;
return|return
name|nonzero_p
argument_list|(
name|compare
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns a constant upper bound on the value of expression VAL.  VAL    is considered to be unsigned.  If its type is signed, its value must    be nonnegative.        The condition ADDITIONAL must be satisfied (for example, if VAL is    "(unsigned) n" and ADDITIONAL is "n> 0", then we can derive that    VAL is at most (unsigned) MAX_INT).  */
end_comment

begin_function
specifier|static
name|double_int
name|derive_constant_upper_bound
parameter_list|(
name|tree
name|val
parameter_list|,
name|tree
name|additional
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|subtype
decl_stmt|,
name|maxt
decl_stmt|;
name|double_int
name|bnd
decl_stmt|,
name|max
decl_stmt|,
name|mmax
decl_stmt|,
name|cst
decl_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|maxt
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|maxt
operator|=
name|upper_bound_in_type
argument_list|(
name|type
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|max
operator|=
name|tree_to_double_int
argument_list|(
name|maxt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
return|return
name|tree_to_double_int
argument_list|(
name|val
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subtype
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|subtype
argument_list|)
comment|/* If TYPE is also signed, the fact that VAL is nonnegative implies 	     that OP0 is nonnegative.  */
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|implies_nonnegative_p
argument_list|(
name|additional
argument_list|,
name|op0
argument_list|)
condition|)
block|{
comment|/* If we cannot prove that the casted expression is nonnegative, 	     we cannot establish more useful upper bound than the precision 	     of the type gives us.  */
return|return
name|max
return|;
block|}
comment|/* We now know that op0 is an nonnegative value.  Try deriving an upper 	 bound for it.  */
name|bnd
operator|=
name|derive_constant_upper_bound
argument_list|(
name|op0
argument_list|,
name|additional
argument_list|)
expr_stmt|;
comment|/* If the bound does not fit in TYPE, max. value of TYPE could be 	 attained.  */
if|if
condition|(
name|double_int_ucmp
argument_list|(
name|max
argument_list|,
name|bnd
argument_list|)
operator|<
literal|0
condition|)
return|return
name|max
return|;
return|return
name|bnd
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|!
name|implies_nonnegative_p
argument_list|(
name|additional
argument_list|,
name|op0
argument_list|)
condition|)
return|return
name|max
return|;
comment|/* Canonicalize to OP0 - CST.  Consider CST to be signed, in order to 	 choose the most logical way how to treat this constant regardless 	 of the signedness of the type.  */
name|cst
operator|=
name|tree_to_double_int
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|cst
operator|=
name|double_int_sext
argument_list|(
name|cst
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
name|cst
operator|=
name|double_int_neg
argument_list|(
name|cst
argument_list|)
expr_stmt|;
name|bnd
operator|=
name|derive_constant_upper_bound
argument_list|(
name|op0
argument_list|,
name|additional
argument_list|)
expr_stmt|;
if|if
condition|(
name|double_int_negative_p
argument_list|(
name|cst
argument_list|)
condition|)
block|{
name|cst
operator|=
name|double_int_neg
argument_list|(
name|cst
argument_list|)
expr_stmt|;
comment|/* Avoid CST == 0x80000...  */
if|if
condition|(
name|double_int_negative_p
argument_list|(
name|cst
argument_list|)
condition|)
return|return
name|max
return|;
empty_stmt|;
comment|/* OP0 + CST.  We need to check that 	     BND<= MAX (type) - CST.  */
name|mmax
operator|=
name|double_int_add
argument_list|(
name|max
argument_list|,
name|double_int_neg
argument_list|(
name|cst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|double_int_ucmp
argument_list|(
name|bnd
argument_list|,
name|mmax
argument_list|)
operator|>
literal|0
condition|)
return|return
name|max
return|;
return|return
name|double_int_add
argument_list|(
name|bnd
argument_list|,
name|cst
argument_list|)
return|;
block|}
else|else
block|{
comment|/* OP0 - CST, where CST>= 0.  	     If TYPE is signed, we have already verified that OP0>= 0, and we 	     know that the result is nonnegative.  This implies that 	     VAL<= BND - CST.  	     If TYPE is unsigned, we must additionally know that OP0>= CST, 	     otherwise the operation underflows. 	   */
comment|/* This should only happen if the type is unsigned; however, for 	     programs that use overflowing signed arithmetics even with 	     -fno-wrapv, this condition may also be true for signed values.  */
if|if
condition|(
name|double_int_ucmp
argument_list|(
name|bnd
argument_list|,
name|cst
argument_list|)
operator|<
literal|0
condition|)
return|return
name|max
return|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|implies_ge_p
argument_list|(
name|additional
argument_list|,
name|op0
argument_list|,
name|double_int_to_tree
argument_list|(
name|type
argument_list|,
name|cst
argument_list|)
argument_list|)
condition|)
return|return
name|max
return|;
name|bnd
operator|=
name|double_int_add
argument_list|(
name|bnd
argument_list|,
name|double_int_neg
argument_list|(
name|cst
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|bnd
return|;
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|tree_int_cst_sign_bit
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|max
return|;
name|bnd
operator|=
name|derive_constant_upper_bound
argument_list|(
name|op0
argument_list|,
name|additional
argument_list|)
expr_stmt|;
return|return
name|double_int_udiv
argument_list|(
name|bnd
argument_list|,
name|tree_to_double_int
argument_list|(
name|op1
argument_list|)
argument_list|,
name|FLOOR_DIV_EXPR
argument_list|)
return|;
default|default:
return|return
name|max
return|;
block|}
block|}
end_function

begin_comment
comment|/* Records that AT_STMT is executed at most BOUND times in LOOP.  The    additional condition ADDITIONAL is recorded with the bound.  */
end_comment

begin_function
name|void
name|record_estimate
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|bound
parameter_list|,
name|tree
name|additional
parameter_list|,
name|tree
name|at_stmt
parameter_list|)
block|{
name|struct
name|nb_iter_bound
modifier|*
name|elt
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nb_iter_bound
argument_list|)
argument_list|)
decl_stmt|;
name|double_int
name|i_bound
init|=
name|derive_constant_upper_bound
argument_list|(
name|bound
argument_list|,
name|additional
argument_list|)
decl_stmt|;
name|tree
name|c_bound
init|=
name|double_int_to_tree
argument_list|(
name|unsigned_type_for
argument_list|(
name|TREE_TYPE
argument_list|(
name|bound
argument_list|)
argument_list|)
argument_list|,
name|i_bound
argument_list|)
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Statements after "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|at_stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" are executed at most "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|bound
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" (bounded by "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|c_bound
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|") times in loop %d.\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
name|elt
operator|->
name|bound
operator|=
name|c_bound
expr_stmt|;
name|elt
operator|->
name|at_stmt
operator|=
name|at_stmt
expr_stmt|;
name|elt
operator|->
name|next
operator|=
name|loop
operator|->
name|bounds
expr_stmt|;
name|loop
operator|->
name|bounds
operator|=
name|elt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize LOOP->ESTIMATED_NB_ITERATIONS with the lowest safe    approximation of the number of iterations for LOOP.  */
end_comment

begin_function
specifier|static
name|void
name|compute_estimated_nb_iterations
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|struct
name|nb_iter_bound
modifier|*
name|bound
decl_stmt|;
for|for
control|(
name|bound
operator|=
name|loop
operator|->
name|bounds
init|;
name|bound
condition|;
name|bound
operator|=
name|bound
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bound
operator|->
name|bound
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
continue|continue;
comment|/* Update only when there is no previous estimation, or when the current 	 estimation is smaller.  */
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|loop
operator|->
name|estimated_nb_iterations
argument_list|)
operator|||
name|tree_int_cst_lt
argument_list|(
name|bound
operator|->
name|bound
argument_list|,
name|loop
operator|->
name|estimated_nb_iterations
argument_list|)
condition|)
name|loop
operator|->
name|estimated_nb_iterations
operator|=
name|bound
operator|->
name|bound
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following analyzers are extracting informations on the bounds    of LOOP from the following undefined behaviors:     - data references should not access elements over the statically      allocated size,     - signed variables should not overflow when flag_wrapv is not set. */
end_comment

begin_function
specifier|static
name|void
name|infer_loop_bounds_from_undefined
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|basic_block
name|bb
decl_stmt|,
modifier|*
name|bbs
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|bbs
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|MODIFY_EXPR
case|:
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* For each array access, analyze its access function 		   and record a bound on the loop iteration domain.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|ARRAY_REF
operator|&&
operator|!
name|array_ref_contains_indirect_ref
argument_list|(
name|op1
argument_list|)
condition|)
name|estimate_iters_using_array
argument_list|(
name|stmt
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ARRAY_REF
operator|&&
operator|!
name|array_ref_contains_indirect_ref
argument_list|(
name|op0
argument_list|)
condition|)
name|estimate_iters_using_array
argument_list|(
name|stmt
argument_list|,
name|op0
argument_list|)
expr_stmt|;
comment|/* For each signed type variable in LOOP, analyze its 		   scalar evolution and record a bound of the loop 		   based on the type's ranges.  */
elseif|else
if|if
condition|(
operator|!
name|flag_wrapv
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|init
decl_stmt|,
name|step
decl_stmt|,
name|diff
decl_stmt|,
name|estimation
decl_stmt|;
name|tree
name|scev
init|=
name|instantiate_parameters
argument_list|(
name|loop
argument_list|,
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|op0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|chrec_type
argument_list|(
name|scev
argument_list|)
decl_stmt|;
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|scev
argument_list|)
operator|||
name|TYPE_OVERFLOW_WRAPS
argument_list|(
name|type
argument_list|)
condition|)
break|break;
name|init
operator|=
name|initial_condition_in_loop_num
argument_list|(
name|scev
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
name|step
operator|=
name|evolution_part_in_loop_num
argument_list|(
name|scev
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|==
name|NULL_TREE
operator|||
name|step
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|step
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
break|break;
if|if
condition|(
name|integer_nonzerop
argument_list|(
name|step
argument_list|)
condition|)
block|{
name|tree
name|utype
decl_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|step
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|diff
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|diff
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|utype
operator|=
name|unsigned_type_for
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|estimation
operator|=
name|fold_build2
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|type
argument_list|,
name|diff
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|record_estimate
argument_list|(
name|loop
argument_list|,
name|fold_convert
argument_list|(
name|utype
argument_list|,
name|estimation
argument_list|)
argument_list|,
name|boolean_true_node
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|args
decl_stmt|;
for|for
control|(
name|args
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
name|ARRAY_REF
operator|&&
operator|!
name|array_ref_contains_indirect_ref
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
condition|)
name|estimate_iters_using_array
argument_list|(
name|stmt
argument_list|,
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
block|}
name|compute_estimated_nb_iterations
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Records estimates on numbers of iterations of LOOP.  */
end_comment

begin_function
specifier|static
name|void
name|estimate_numbers_of_iterations_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|edge
modifier|*
name|exits
decl_stmt|;
name|tree
name|niter
decl_stmt|,
name|type
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|n_exits
decl_stmt|;
name|struct
name|tree_niter_desc
name|niter_desc
decl_stmt|;
comment|/* Give up if we already have tried to compute an estimation.  */
if|if
condition|(
name|loop
operator|->
name|estimated_nb_iterations
operator|==
name|chrec_dont_know
comment|/* Or when we already have an estimation.  */
operator|||
operator|(
name|loop
operator|->
name|estimated_nb_iterations
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|loop
operator|->
name|estimated_nb_iterations
argument_list|)
operator|==
name|INTEGER_CST
operator|)
condition|)
return|return;
else|else
name|loop
operator|->
name|estimated_nb_iterations
operator|=
name|chrec_dont_know
expr_stmt|;
name|exits
operator|=
name|get_loop_exit_edges
argument_list|(
name|loop
argument_list|,
operator|&
name|n_exits
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_exits
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|number_of_iterations_exit
argument_list|(
name|loop
argument_list|,
name|exits
index|[
name|i
index|]
argument_list|,
operator|&
name|niter_desc
argument_list|,
name|false
argument_list|)
condition|)
continue|continue;
name|niter
operator|=
name|niter_desc
operator|.
name|niter
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|niter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zero_p
argument_list|(
name|niter_desc
operator|.
name|may_be_zero
argument_list|)
operator|&&
operator|!
name|nonzero_p
argument_list|(
name|niter_desc
operator|.
name|may_be_zero
argument_list|)
condition|)
name|niter
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|niter_desc
operator|.
name|may_be_zero
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|niter
argument_list|)
expr_stmt|;
name|record_estimate
argument_list|(
name|loop
argument_list|,
name|niter
argument_list|,
name|niter_desc
operator|.
name|additional_info
argument_list|,
name|last_stmt
argument_list|(
name|exits
index|[
name|i
index|]
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|exits
argument_list|)
expr_stmt|;
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|loop
operator|->
name|estimated_nb_iterations
argument_list|)
condition|)
name|infer_loop_bounds_from_undefined
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Records estimates on numbers of iterations of LOOPS.  */
end_comment

begin_function
name|void
name|estimate_numbers_of_iterations
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
comment|/* We don't want to issue signed overflow warnings while getting      loop iteration estimates.  */
name|fold_defer_overflow_warnings
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|loop
condition|)
name|estimate_numbers_of_iterations_loop
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
name|fold_undefer_and_ignore_overflow_warnings
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns true if statement S1 dominates statement S2.  */
end_comment

begin_function
specifier|static
name|bool
name|stmt_dominates_stmt_p
parameter_list|(
name|tree
name|s1
parameter_list|,
name|tree
name|s2
parameter_list|)
block|{
name|basic_block
name|bb1
init|=
name|bb_for_stmt
argument_list|(
name|s1
argument_list|)
decl_stmt|,
name|bb2
init|=
name|bb_for_stmt
argument_list|(
name|s2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bb1
operator|||
name|s1
operator|==
name|s2
condition|)
return|return
name|true
return|;
if|if
condition|(
name|bb1
operator|==
name|bb2
condition|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb1
argument_list|)
init|;
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
operator|!=
name|s2
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
if|if
condition|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
operator|==
name|s1
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
return|return
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb2
argument_list|,
name|bb1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true when we can prove that the number of executions of    STMT in the loop is at most NITER, according to the fact    that the statement NITER_BOUND->at_stmt is executed at most    NITER_BOUND->bound times.  */
end_comment

begin_function
specifier|static
name|bool
name|n_of_executions_at_most
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|struct
name|nb_iter_bound
modifier|*
name|niter_bound
parameter_list|,
name|tree
name|niter
parameter_list|)
block|{
name|tree
name|cond
decl_stmt|;
name|tree
name|bound
init|=
name|niter_bound
operator|->
name|bound
decl_stmt|;
name|tree
name|bound_type
init|=
name|TREE_TYPE
argument_list|(
name|bound
argument_list|)
decl_stmt|;
name|tree
name|nit_type
init|=
name|TREE_TYPE
argument_list|(
name|niter
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|cmp
decl_stmt|;
name|gcc_assert
argument_list|(
name|TYPE_UNSIGNED
argument_list|(
name|bound_type
argument_list|)
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|nit_type
argument_list|)
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|bound
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|nit_type
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|bound_type
argument_list|)
condition|)
name|bound
operator|=
name|fold_convert
argument_list|(
name|nit_type
argument_list|,
name|bound
argument_list|)
expr_stmt|;
else|else
name|niter
operator|=
name|fold_convert
argument_list|(
name|bound_type
argument_list|,
name|niter
argument_list|)
expr_stmt|;
comment|/* After the statement niter_bound->at_stmt we know that anything is      executed at most BOUND times.  */
if|if
condition|(
name|stmt
operator|&&
name|stmt_dominates_stmt_p
argument_list|(
name|niter_bound
operator|->
name|at_stmt
argument_list|,
name|stmt
argument_list|)
condition|)
name|cmp
operator|=
name|GE_EXPR
expr_stmt|;
comment|/* Before the statement niter_bound->at_stmt we know that anything      is executed at most BOUND + 1 times.  */
else|else
name|cmp
operator|=
name|GT_EXPR
expr_stmt|;
name|cond
operator|=
name|fold_binary
argument_list|(
name|cmp
argument_list|,
name|boolean_type_node
argument_list|,
name|niter
argument_list|,
name|bound
argument_list|)
expr_stmt|;
return|return
name|nonzero_p
argument_list|(
name|cond
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the arithmetics in TYPE can be assumed not to wrap.  */
end_comment

begin_function
name|bool
name|nowrap_type_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return false only when the induction variable BASE + STEP * I is    known to not overflow: i.e. when the number of iterations is small    enough with respect to the step and initial condition in order to    keep the evolution confined in TYPEs bounds.  Return true when the    iv is known to overflow or when the property is not computable.      USE_OVERFLOW_SEMANTICS is true if this function should assume that    the rules for overflow of the given language apply (e.g., that signed    arithmetics in C does not overflow).  */
end_comment

begin_function
name|bool
name|scev_probably_wraps_p
parameter_list|(
name|tree
name|base
parameter_list|,
name|tree
name|step
parameter_list|,
name|tree
name|at_stmt
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|bool
name|use_overflow_semantics
parameter_list|)
block|{
name|struct
name|nb_iter_bound
modifier|*
name|bound
decl_stmt|;
name|tree
name|delta
decl_stmt|,
name|step_abs
decl_stmt|;
name|tree
name|unsigned_type
decl_stmt|,
name|valid_niter
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|step
argument_list|)
decl_stmt|;
comment|/* FIXME: We really need something like      http://gcc.gnu.org/ml/gcc-patches/2005-06/msg02025.html.       We used to test for the following situation that frequently appears      during address arithmetics: 	         D.1621_13 = (long unsigned intD.4) D.1620_12;        D.1622_14 = D.1621_13 * 8;        D.1623_15 = (doubleD.29 *) D.1622_14;       And derived that the sequence corresponding to D_14      can be proved to not wrap because it is used for computing a      memory access; however, this is not really the case -- for example,      if D_12 = (unsigned char) [254,+,1], then D_14 has values      2032, 2040, 0, 8, ..., but the code is still legal.  */
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|base
argument_list|)
operator|||
name|chrec_contains_undetermined
argument_list|(
name|step
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|step
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|true
return|;
if|if
condition|(
name|zero_p
argument_list|(
name|step
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If we can use the fact that signed and pointer arithmetics does not      wrap, we are done.  */
if|if
condition|(
name|use_overflow_semantics
operator|&&
name|nowrap_type_p
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Don't issue signed overflow warnings.  */
name|fold_defer_overflow_warnings
argument_list|()
expr_stmt|;
comment|/* Otherwise, compute the number of iterations before we reach the      bound of the type, and verify that the loop is exited before this      occurs.  */
name|unsigned_type
operator|=
name|unsigned_type_for
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|base
operator|=
name|fold_convert
argument_list|(
name|unsigned_type
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_sign_bit
argument_list|(
name|step
argument_list|)
condition|)
block|{
name|tree
name|extreme
init|=
name|fold_convert
argument_list|(
name|unsigned_type
argument_list|,
name|lower_bound_in_type
argument_list|(
name|type
argument_list|,
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|delta
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|unsigned_type
argument_list|,
name|base
argument_list|,
name|extreme
argument_list|)
expr_stmt|;
name|step_abs
operator|=
name|fold_build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|unsigned_type
argument_list|,
name|fold_convert
argument_list|(
name|unsigned_type
argument_list|,
name|step
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|extreme
init|=
name|fold_convert
argument_list|(
name|unsigned_type
argument_list|,
name|upper_bound_in_type
argument_list|(
name|type
argument_list|,
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|delta
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|unsigned_type
argument_list|,
name|extreme
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|step_abs
operator|=
name|fold_convert
argument_list|(
name|unsigned_type
argument_list|,
name|step
argument_list|)
expr_stmt|;
block|}
name|valid_niter
operator|=
name|fold_build2
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|unsigned_type
argument_list|,
name|delta
argument_list|,
name|step_abs
argument_list|)
expr_stmt|;
name|estimate_numbers_of_iterations_loop
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|bound
operator|=
name|loop
operator|->
name|bounds
init|;
name|bound
condition|;
name|bound
operator|=
name|bound
operator|->
name|next
control|)
block|{
if|if
condition|(
name|n_of_executions_at_most
argument_list|(
name|at_stmt
argument_list|,
name|bound
argument_list|,
name|valid_niter
argument_list|)
condition|)
block|{
name|fold_undefer_and_ignore_overflow_warnings
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|fold_undefer_and_ignore_overflow_warnings
argument_list|()
expr_stmt|;
comment|/* At this point we still don't have a proof that the iv does not      overflow: give up.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Frees the information on upper bounds on numbers of iterations of LOOP.  */
end_comment

begin_function
name|void
name|free_numbers_of_iterations_estimates_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|struct
name|nb_iter_bound
modifier|*
name|bound
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|loop
operator|->
name|nb_iterations
operator|=
name|NULL
expr_stmt|;
name|loop
operator|->
name|estimated_nb_iterations
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|bound
operator|=
name|loop
operator|->
name|bounds
init|;
name|bound
condition|;
name|bound
operator|=
name|next
control|)
block|{
name|next
operator|=
name|bound
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|bound
argument_list|)
expr_stmt|;
block|}
name|loop
operator|->
name|bounds
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Frees the information on upper bounds on numbers of iterations of LOOPS.  */
end_comment

begin_function
name|void
name|free_numbers_of_iterations_estimates
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|loop
condition|)
name|free_numbers_of_iterations_estimates_loop
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Substitute value VAL for ssa name NAME inside expressions held    at LOOP.  */
end_comment

begin_function
name|void
name|substitute_in_loop_info
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
name|loop
operator|->
name|nb_iterations
operator|=
name|simplify_replace_tree
argument_list|(
name|loop
operator|->
name|nb_iterations
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|loop
operator|->
name|estimated_nb_iterations
operator|=
name|simplify_replace_tree
argument_list|(
name|loop
operator|->
name|estimated_nb_iterations
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

