begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Scan linker error messages for missing template instantiations and provide    them.     Copyright (C) 1995, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.    Contributed by Jason Merrill (jason@cygnus.com).  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"collect2.h"
end_include

begin_define
define|#
directive|define
name|MAX_ITERATIONS
value|17
end_define

begin_comment
comment|/* Obstack allocation and deallocation routines.  */
end_comment

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* Defined in the automatically-generated underscore.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|prepends_underscore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tlink_verbose
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Hash table boilerplate for working with hash.[ch].  We have hash tables    for symbol names, file names, and demangled symbols.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|symbol_hash_entry
block|{
name|struct
name|hash_entry
name|root
decl_stmt|;
name|struct
name|file_hash_entry
modifier|*
name|file
decl_stmt|;
name|int
name|chosen
decl_stmt|;
name|int
name|tweaking
decl_stmt|;
name|int
name|tweaked
decl_stmt|;
block|}
name|symbol
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|file_hash_entry
block|{
name|struct
name|hash_entry
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|main
decl_stmt|;
name|int
name|tweaking
decl_stmt|;
block|}
name|file
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|demangled_hash_entry
block|{
name|struct
name|hash_entry
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|mangled
decl_stmt|;
block|}
name|demangled
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|hash_table
name|symbol_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_entry
modifier|*
name|symbol_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|hash_entry
operator|*
operator|,
expr|struct
name|hash_table
operator|*
operator|,
name|hash_table_key
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symbol_hash_entry
modifier|*
name|symbol_hash_lookup
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_entry
modifier|*
name|file_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|hash_entry
operator|*
operator|,
expr|struct
name|hash_table
operator|*
operator|,
name|hash_table_key
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_hash_entry
modifier|*
name|file_hash_lookup
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_entry
modifier|*
name|demangled_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|hash_entry
operator|*
operator|,
expr|struct
name|hash_table
operator|*
operator|,
name|hash_table_key
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|demangled_hash_entry
modifier|*
name|demangled_hash_lookup
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|symbol_push
name|PARAMS
argument_list|(
operator|(
name|symbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbol
modifier|*
name|symbol_pop
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|file_push
name|PARAMS
argument_list|(
operator|(
name|file
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|file
modifier|*
name|file_pop
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tlink_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tlink_execute
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|frob_extension
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|obstack_fgets
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
expr|struct
name|obstack
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tfgets
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pfgets
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|freadsym
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|file
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_repo_file
name|PARAMS
argument_list|(
operator|(
name|file
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_tweak
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|file
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|recompile_files
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|read_repo_files
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|demangle_new_symbols
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|scan_linker_output
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a new entry for the symbol hash table.    Passed to hash_table_init.  */
end_comment

begin_function
specifier|static
name|struct
name|hash_entry
modifier|*
name|symbol_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|hash_table
modifier|*
name|table
decl_stmt|;
name|hash_table_key
name|string
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|symbol_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|symbol_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|(
operator|(
expr|struct
name|symbol_hash_entry
operator|*
operator|)
name|hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|ret
operator|->
name|file
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|chosen
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|tweaking
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|tweaked
operator|=
literal|0
expr_stmt|;
return|return
operator|(
expr|struct
name|hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Look up an entry in the symbol hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|symbol_hash_entry
modifier|*
name|symbol_hash_lookup
parameter_list|(
name|string
parameter_list|,
name|create
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|create
decl_stmt|;
block|{
return|return
operator|(
operator|(
expr|struct
name|symbol_hash_entry
operator|*
operator|)
name|hash_lookup
argument_list|(
operator|&
name|symbol_table
argument_list|,
operator|(
specifier|const
name|hash_table_key
operator|)
name|string
argument_list|,
name|create
argument_list|,
name|string_copy
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|hash_table
name|file_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a new entry for the file hash table.    Passed to hash_table_init.  */
end_comment

begin_function
specifier|static
name|struct
name|hash_entry
modifier|*
name|file_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|hash_table
modifier|*
name|table
decl_stmt|;
name|hash_table_key
name|string
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|file_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|file_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|(
operator|(
expr|struct
name|file_hash_entry
operator|*
operator|)
name|hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|file_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|ret
operator|->
name|args
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|dir
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
expr|main
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|tweaking
operator|=
literal|0
expr_stmt|;
return|return
operator|(
expr|struct
name|hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Look up an entry in the file hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|file_hash_entry
modifier|*
name|file_hash_lookup
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
return|return
operator|(
operator|(
expr|struct
name|file_hash_entry
operator|*
operator|)
name|hash_lookup
argument_list|(
operator|&
name|file_table
argument_list|,
operator|(
specifier|const
name|hash_table_key
operator|)
name|string
argument_list|,
name|true
argument_list|,
name|string_copy
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|hash_table
name|demangled_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a new entry for the demangled name hash table.    Passed to hash_table_init.  */
end_comment

begin_function
specifier|static
name|struct
name|hash_entry
modifier|*
name|demangled_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|hash_table
modifier|*
name|table
decl_stmt|;
name|hash_table_key
name|string
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|demangled_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|demangled_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|(
operator|(
expr|struct
name|demangled_hash_entry
operator|*
operator|)
name|hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|demangled_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|ret
operator|->
name|mangled
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
expr|struct
name|hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Look up an entry in the demangled name hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|demangled_hash_entry
modifier|*
name|demangled_hash_lookup
parameter_list|(
name|string
parameter_list|,
name|create
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|create
decl_stmt|;
block|{
return|return
operator|(
operator|(
expr|struct
name|demangled_hash_entry
operator|*
operator|)
name|hash_lookup
argument_list|(
operator|&
name|demangled_table
argument_list|,
operator|(
specifier|const
name|hash_table_key
operator|)
name|string
argument_list|,
name|create
argument_list|,
name|string_copy
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stack code.  */
end_comment

begin_struct
struct|struct
name|symbol_stack_entry
block|{
name|symbol
modifier|*
name|value
decl_stmt|;
name|struct
name|symbol_stack_entry
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|obstack
name|symbol_stack_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symbol_stack_entry
modifier|*
name|symbol_stack
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|file_stack_entry
block|{
name|file
modifier|*
name|value
decl_stmt|;
name|struct
name|file_stack_entry
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|obstack
name|file_stack_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|file_stack_entry
modifier|*
name|file_stack
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|symbol_push
parameter_list|(
name|p
parameter_list|)
name|symbol
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|symbol_stack_entry
modifier|*
name|ep
init|=
operator|(
expr|struct
name|symbol_stack_entry
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|symbol_stack_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_stack_entry
argument_list|)
argument_list|)
decl_stmt|;
name|ep
operator|->
name|value
operator|=
name|p
expr_stmt|;
name|ep
operator|->
name|next
operator|=
name|symbol_stack
expr_stmt|;
name|symbol_stack
operator|=
name|ep
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|symbol
modifier|*
name|symbol_pop
parameter_list|()
block|{
name|struct
name|symbol_stack_entry
modifier|*
name|ep
init|=
name|symbol_stack
decl_stmt|;
name|symbol
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|p
operator|=
name|ep
operator|->
name|value
expr_stmt|;
name|symbol_stack
operator|=
name|ep
operator|->
name|next
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|symbol_stack_obstack
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|file_push
parameter_list|(
name|p
parameter_list|)
name|file
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|file_stack_entry
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tweaking
condition|)
return|return;
name|ep
operator|=
operator|(
expr|struct
name|file_stack_entry
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|file_stack_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|file_stack_entry
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|value
operator|=
name|p
expr_stmt|;
name|ep
operator|->
name|next
operator|=
name|file_stack
expr_stmt|;
name|file_stack
operator|=
name|ep
expr_stmt|;
name|p
operator|->
name|tweaking
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|file
modifier|*
name|file_pop
parameter_list|()
block|{
name|struct
name|file_stack_entry
modifier|*
name|ep
init|=
name|file_stack
decl_stmt|;
name|file
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|p
operator|=
name|ep
operator|->
name|value
expr_stmt|;
name|file_stack
operator|=
name|ep
operator|->
name|next
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|file_stack_obstack
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|p
operator|->
name|tweaking
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Other machinery.  */
end_comment

begin_comment
comment|/* Initialize the tlink machinery.  Called from do_tlink.  */
end_comment

begin_function
specifier|static
name|void
name|tlink_init
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|hash_table_init
argument_list|(
operator|&
name|symbol_table
argument_list|,
name|symbol_hash_newfunc
argument_list|,
name|string_hash
argument_list|,
name|string_compare
argument_list|)
expr_stmt|;
name|hash_table_init
argument_list|(
operator|&
name|file_table
argument_list|,
name|file_hash_newfunc
argument_list|,
name|string_hash
argument_list|,
name|string_compare
argument_list|)
expr_stmt|;
name|hash_table_init
argument_list|(
operator|&
name|demangled_table
argument_list|,
name|demangled_hash_newfunc
argument_list|,
name|string_hash
argument_list|,
name|string_compare
argument_list|)
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|symbol_stack_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|file_stack_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|getenv
argument_list|(
literal|"TLINK_VERBOSE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|tlink_verbose
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
block|{
name|tlink_verbose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
name|tlink_verbose
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|tlink_verbose
operator|=
literal|3
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|tlink_execute
parameter_list|(
name|prog
parameter_list|,
name|argv
parameter_list|,
name|redir
parameter_list|)
specifier|const
name|char
modifier|*
name|prog
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|redir
decl_stmt|;
block|{
name|collect_execute
argument_list|(
name|prog
argument_list|,
name|argv
argument_list|,
name|redir
argument_list|)
expr_stmt|;
return|return
name|collect_wait
argument_list|(
name|prog
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|frob_extension
parameter_list|(
name|s
parameter_list|,
name|ext
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|ext
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|strrchr
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|s
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|s
argument_list|,
name|p
operator|-
name|s
argument_list|)
expr_stmt|;
return|return
name|obstack_copy0
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|ext
argument_list|,
name|strlen
argument_list|(
name|ext
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|obstack_fgets
parameter_list|(
name|stream
parameter_list|,
name|ob
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|struct
name|obstack
modifier|*
name|ob
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|obstack_1grow
argument_list|(
name|ob
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|obstack_object_size
argument_list|(
name|ob
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|obstack_1grow
argument_list|(
name|ob
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
return|return
name|obstack_finish
argument_list|(
name|ob
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|tfgets
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
return|return
name|obstack_fgets
argument_list|(
name|stream
argument_list|,
operator|&
name|temporary_obstack
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pfgets
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
return|return
name|obstack_fgets
argument_list|(
name|stream
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Real tlink code.  */
end_comment

begin_comment
comment|/* Subroutine of read_repo_file.  We are reading the repo file for file F,    which is coming in on STREAM, and the symbol that comes next in STREAM    is offerred, chosen or provided if CHOSEN is 0, 1 or 2, respectively.     XXX "provided" is unimplemented, both here and in the compiler.  */
end_comment

begin_function
specifier|static
name|void
name|freadsym
parameter_list|(
name|stream
parameter_list|,
name|f
parameter_list|,
name|chosen
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|file
modifier|*
name|f
decl_stmt|;
name|int
name|chosen
decl_stmt|;
block|{
name|symbol
modifier|*
name|sym
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|tfgets
argument_list|(
name|stream
argument_list|)
decl_stmt|;
name|sym
operator|=
name|symbol_hash_lookup
argument_list|(
name|name
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sym
operator|->
name|file
operator|==
name|NULL
condition|)
block|{
comment|/* We didn't have this symbol already, so we choose this file.  */
name|symbol_push
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|sym
operator|->
name|file
operator|=
name|f
expr_stmt|;
name|sym
operator|->
name|chosen
operator|=
name|chosen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chosen
condition|)
block|{
comment|/* We want this file; cast aside any pretender.  */
if|if
condition|(
name|sym
operator|->
name|chosen
operator|&&
name|sym
operator|->
name|file
operator|!=
name|f
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|chosen
operator|==
literal|1
condition|)
name|file_push
argument_list|(
name|sym
operator|->
name|file
argument_list|)
expr_stmt|;
else|else
block|{
name|file_push
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|=
name|sym
operator|->
name|file
expr_stmt|;
name|chosen
operator|=
name|sym
operator|->
name|chosen
expr_stmt|;
block|}
block|}
name|sym
operator|->
name|file
operator|=
name|f
expr_stmt|;
name|sym
operator|->
name|chosen
operator|=
name|chosen
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read in the repo file denoted by F, and record all its information.  */
end_comment

begin_function
specifier|static
name|void
name|read_repo_file
parameter_list|(
name|f
parameter_list|)
name|file
modifier|*
name|f
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|FILE
modifier|*
name|stream
init|=
name|fopen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|root
operator|.
name|key
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|tlink_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"collect: reading %s\n"
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|root
operator|.
name|key
argument_list|)
expr_stmt|;
while|while
condition|(
name|fscanf
argument_list|(
name|stream
argument_list|,
literal|"%c "
argument_list|,
operator|&
name|c
argument_list|)
operator|==
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'A'
case|:
name|f
operator|->
name|args
operator|=
name|pfgets
argument_list|(
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|f
operator|->
name|dir
operator|=
name|pfgets
argument_list|(
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|f
operator|->
expr|main
operator|=
name|pfgets
argument_list|(
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|freadsym
argument_list|(
name|stream
argument_list|,
name|f
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|freadsym
argument_list|(
name|stream
argument_list|,
name|f
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|freadsym
argument_list|(
name|stream
argument_list|,
name|f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|obstack_free
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|temporary_firstobj
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|args
operator|==
name|NULL
condition|)
name|f
operator|->
name|args
operator|=
name|getenv
argument_list|(
literal|"COLLECT_GCC_OPTIONS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|dir
operator|==
name|NULL
condition|)
name|f
operator|->
name|dir
operator|=
literal|"."
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We might want to modify LINE, which is a symbol line from file F.  We do    this if either we saw an error message referring to the symbol in    question, or we have already allocated the symbol to another file and    this one wants to emit it as well.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_tweak
parameter_list|(
name|line
parameter_list|,
name|f
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|file
modifier|*
name|f
decl_stmt|;
block|{
name|symbol
modifier|*
name|sym
init|=
name|symbol_hash_lookup
argument_list|(
name|line
operator|+
literal|2
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|sym
operator|->
name|file
operator|==
name|f
operator|&&
name|sym
operator|->
name|tweaking
operator|)
operator|||
operator|(
name|sym
operator|->
name|file
operator|!=
name|f
operator|&&
name|line
index|[
literal|0
index|]
operator|==
literal|'C'
operator|)
condition|)
block|{
name|sym
operator|->
name|tweaking
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|tweaked
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'O'
condition|)
name|line
index|[
literal|0
index|]
operator|=
literal|'C'
expr_stmt|;
else|else
name|line
index|[
literal|0
index|]
operator|=
literal|'O'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Update the repo files for each of the object files we have adjusted and    recompile.     XXX Should this use collect_execute instead of system?  */
end_comment

begin_function
specifier|static
name|int
name|recompile_files
parameter_list|()
block|{
name|file
modifier|*
name|f
decl_stmt|;
name|putenv
argument_list|(
name|xstrdup
argument_list|(
literal|"COMPILER_PATH"
argument_list|)
argument_list|)
expr_stmt|;
name|putenv
argument_list|(
name|xstrdup
argument_list|(
literal|"LIBRARY_PATH"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|f
operator|=
name|file_pop
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|command
decl_stmt|;
name|FILE
modifier|*
name|stream
init|=
name|fopen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|root
operator|.
name|key
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|outname
init|=
name|frob_extension
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|root
operator|.
name|key
argument_list|,
literal|".rnw"
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|output
init|=
name|fopen
argument_list|(
name|outname
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|tfgets
argument_list|(
name|stream
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|line
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'C'
case|:
case|case
literal|'O'
case|:
name|maybe_tweak
argument_list|(
name|line
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output
argument_list|,
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|outname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|root
operator|.
name|key
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|"cd "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|f
operator|->
name|dir
argument_list|,
name|strlen
argument_list|(
name|f
operator|->
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|"; "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|c_file_name
argument_list|,
name|strlen
argument_list|(
name|c_file_name
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|f
operator|->
name|args
argument_list|,
name|strlen
argument_list|(
name|f
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|command
operator|=
name|obstack_copy0
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|f
operator|->
expr|main
argument_list|,
name|strlen
argument_list|(
name|f
operator|->
expr|main
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlink_verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"collect: recompiling %s\n"
argument_list|)
argument_list|,
name|f
operator|->
expr|main
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlink_verbose
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|command
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|read_repo_file
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|temporary_firstobj
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The first phase of processing: determine which object files have    .rpo files associated with them, and read in the information.  */
end_comment

begin_function
specifier|static
name|int
name|read_repo_files
parameter_list|(
name|object_lst
parameter_list|)
name|char
modifier|*
modifier|*
name|object_lst
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|object
init|=
name|object_lst
decl_stmt|;
for|for
control|(
init|;
operator|*
name|object
condition|;
name|object
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|file
modifier|*
name|f
decl_stmt|;
comment|/* Don't bother trying for ld flags.  */
if|if
condition|(
operator|*
name|object
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
continue|continue;
name|p
operator|=
name|frob_extension
argument_list|(
operator|*
name|object
argument_list|,
literal|".rpo"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_exists
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
name|f
operator|=
name|file_hash_lookup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|read_repo_file
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file_stack
operator|!=
name|NULL
operator|&&
operator|!
name|recompile_files
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|symbol_stack
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add the demangled forms of any new symbols to the hash table.  */
end_comment

begin_function
specifier|static
name|void
name|demangle_new_symbols
parameter_list|()
block|{
name|symbol
modifier|*
name|sym
decl_stmt|;
while|while
condition|(
operator|(
name|sym
operator|=
name|symbol_pop
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|demangled
modifier|*
name|dem
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|cplus_demangle
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sym
operator|->
name|root
operator|.
name|key
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
continue|continue;
name|dem
operator|=
name|demangled_hash_lookup
argument_list|(
name|p
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|dem
operator|->
name|mangled
operator|=
operator|(
name|char
operator|*
operator|)
name|sym
operator|->
name|root
operator|.
name|key
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Step through the output of the linker, in the file named FNAME, and    adjust the settings for each symbol encountered.  */
end_comment

begin_function
specifier|static
name|int
name|scan_linker_output
parameter_list|(
name|fname
parameter_list|)
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
init|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|tfgets
argument_list|(
name|stream
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|line
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|end
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
continue|continue;
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|q
argument_list|)
condition|;
operator|++
name|q
control|)
empty_stmt|;
comment|/* Try the first word on the line.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'_'
operator|&&
name|prepends_underscore
condition|)
operator|++
name|p
expr_stmt|;
name|end
operator|=
operator|!
operator|*
name|q
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|sym
operator|=
name|symbol_hash_lookup
argument_list|(
name|p
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Some SVR4 linkers produce messages like 	 ld: 0711-317 ERROR: Undefined symbol: .g__t3foo1Zi 	 */
if|if
condition|(
operator|!
name|sym
operator|&&
operator|!
name|end
operator|&&
name|strstr
argument_list|(
name|q
operator|+
literal|1
argument_list|,
literal|"Undefined symbol: "
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|strrchr
argument_list|(
name|q
operator|+
literal|1
argument_list|,
literal|' '
argument_list|)
decl_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'_'
operator|&&
name|prepends_underscore
condition|)
name|p
operator|++
expr_stmt|;
name|sym
operator|=
name|symbol_hash_lookup
argument_list|(
name|p
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sym
operator|&&
operator|!
name|end
condition|)
comment|/* Try a mangled name in quotes.  */
block|{
specifier|const
name|char
modifier|*
name|oldq
init|=
name|q
operator|+
literal|1
decl_stmt|;
name|demangled
modifier|*
name|dem
init|=
literal|0
decl_stmt|;
name|q
operator|=
literal|0
expr_stmt|;
comment|/* First try `GNU style'.  */
name|p
operator|=
name|strchr
argument_list|(
name|oldq
argument_list|,
literal|'`'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|p
operator|++
operator|,
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
comment|/* Then try "double quotes".  */
elseif|else
if|if
condition|(
name|p
operator|=
name|strchr
argument_list|(
name|oldq
argument_list|,
literal|'"'
argument_list|)
operator|,
name|p
condition|)
name|p
operator|++
operator|,
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
comment|/* Don't let the strstr's below see the demangled name; we 	     might get spurious matches.  */
if|if
condition|(
name|p
condition|)
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* We need to check for certain error keywords here, or we would 	     mistakenly use GNU ld's "In function `foo':" message.  */
if|if
condition|(
name|q
operator|&&
operator|(
name|strstr
argument_list|(
name|oldq
argument_list|,
literal|"ndefined"
argument_list|)
operator|||
name|strstr
argument_list|(
name|oldq
argument_list|,
literal|"nresolved"
argument_list|)
operator|||
name|strstr
argument_list|(
name|oldq
argument_list|,
literal|"nsatisfied"
argument_list|)
operator|||
name|strstr
argument_list|(
name|oldq
argument_list|,
literal|"ultiple"
argument_list|)
operator|)
condition|)
block|{
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|dem
operator|=
name|demangled_hash_lookup
argument_list|(
name|p
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|dem
condition|)
name|sym
operator|=
name|symbol_hash_lookup
argument_list|(
name|dem
operator|->
name|mangled
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'_'
operator|&&
name|prepends_underscore
condition|)
operator|++
name|p
expr_stmt|;
name|sym
operator|=
name|symbol_hash_lookup
argument_list|(
name|p
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|sym
operator|&&
name|sym
operator|->
name|tweaked
condition|)
block|{
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sym
operator|&&
operator|!
name|sym
operator|->
name|tweaking
condition|)
block|{
if|if
condition|(
name|tlink_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"collect: tweaking %s in %s\n"
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sym
operator|->
name|root
operator|.
name|key
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sym
operator|->
name|file
operator|->
name|root
operator|.
name|key
argument_list|)
expr_stmt|;
name|sym
operator|->
name|tweaking
operator|=
literal|1
expr_stmt|;
name|file_push
argument_list|(
name|sym
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
name|obstack_free
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|temporary_firstobj
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
operator|(
name|file_stack
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Entry point for tlink.  Called from main in collect2.c.     Iteratively try to provide definitions for all the unresolved symbols    mentioned in the linker error messages.     LD_ARGV is an array of arguments for the linker.    OBJECT_LST is an array of object files that we may be able to recompile      to provide missing definitions.  Currently ignored.  */
end_comment

begin_function
name|void
name|do_tlink
parameter_list|(
name|ld_argv
parameter_list|,
name|object_lst
parameter_list|)
name|char
modifier|*
modifier|*
name|ld_argv
decl_stmt|,
decl|*
modifier|*
name|object_lst
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_function

begin_block
block|{
name|int
name|exit
init|=
name|tlink_execute
argument_list|(
literal|"ld"
argument_list|,
name|ld_argv
argument_list|,
name|ldout
argument_list|)
decl_stmt|;
name|tlink_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|exit
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Until collect does a better job of figuring out which are object 	 files, assume that everything on the command line could be.  */
if|if
condition|(
name|read_repo_files
argument_list|(
name|ld_argv
argument_list|)
condition|)
while|while
condition|(
name|exit
operator|&&
name|i
operator|++
operator|<
name|MAX_ITERATIONS
condition|)
block|{
if|if
condition|(
name|tlink_verbose
operator|>=
literal|3
condition|)
name|dump_file
argument_list|(
name|ldout
argument_list|)
expr_stmt|;
name|demangle_new_symbols
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scan_linker_output
argument_list|(
name|ldout
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|recompile_files
argument_list|()
condition|)
break|break;
if|if
condition|(
name|tlink_verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"collect: relinking\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
operator|=
name|tlink_execute
argument_list|(
literal|"ld"
argument_list|,
name|ld_argv
argument_list|,
name|ldout
argument_list|)
expr_stmt|;
block|}
block|}
name|dump_file
argument_list|(
name|ldout
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|ldout
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit
condition|)
block|{
name|error
argument_list|(
literal|"ld returned %d exit status"
argument_list|,
name|exit
argument_list|)
expr_stmt|;
name|collect_exit
argument_list|(
name|exit
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

