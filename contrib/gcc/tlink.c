begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Scan linker error messages for missing template instantiations and provide    them.     Copyright (C) 1995, 1998, 1999, 2000, 2001, 2003    Free Software Foundation, Inc.    Contributed by Jason Merrill (jason@cygnus.com).  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"collect2.h"
end_include

begin_define
define|#
directive|define
name|MAX_ITERATIONS
value|17
end_define

begin_comment
comment|/* Defined in the automatically-generated underscore.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|prepends_underscore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tlink_verbose
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Hash table boilerplate for working with htab_t.  We have hash tables    for symbol names, file names, and demangled symbols.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|symbol_hash_entry
block|{
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|struct
name|file_hash_entry
modifier|*
name|file
decl_stmt|;
name|int
name|chosen
decl_stmt|;
name|int
name|tweaking
decl_stmt|;
name|int
name|tweaked
decl_stmt|;
block|}
name|symbol
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|file_hash_entry
block|{
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|main
decl_stmt|;
name|int
name|tweaking
decl_stmt|;
block|}
name|file
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|demangled_hash_entry
block|{
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|mangled
decl_stmt|;
block|}
name|demangled
typedef|;
end_typedef

begin_comment
comment|/* Hash and comparison functions for these hash tables.  */
end_comment

begin_function_decl
specifier|static
name|int
name|hash_string_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|hash_string_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|hash_string_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|s1_p
parameter_list|,
specifier|const
name|void
modifier|*
name|s2_p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|s1
init|=
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|s1_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s2
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|s2_p
decl_stmt|;
return|return
name|strcmp
argument_list|(
operator|*
name|s1
argument_list|,
name|s2
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|hash_string_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|s_p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|s
init|=
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|s_p
decl_stmt|;
return|return
call|(
modifier|*
name|htab_hash_string
call|)
argument_list|(
operator|*
name|s
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|htab_t
name|symbol_table
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|symbol_hash_entry
modifier|*
name|symbol_hash_lookup
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|file_hash_entry
modifier|*
name|file_hash_lookup
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|demangled_hash_entry
modifier|*
name|demangled_hash_lookup
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|symbol_push
parameter_list|(
name|symbol
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|symbol
modifier|*
name|symbol_pop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|file_push
parameter_list|(
name|file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|file
modifier|*
name|file_pop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tlink_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tlink_execute
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|frob_extension
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|obstack_fgets
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|struct
name|obstack
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|tfgets
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pfgets
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|freadsym
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|file
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_repo_file
parameter_list|(
name|file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_tweak
parameter_list|(
name|char
modifier|*
parameter_list|,
name|file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|recompile_files
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_repo_files
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|demangle_new_symbols
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scan_linker_output
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Look up an entry in the symbol hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|symbol_hash_entry
modifier|*
name|symbol_hash_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|symbol_table
argument_list|,
name|string
argument_list|,
call|(
modifier|*
name|htab_hash_string
call|)
argument_list|(
name|string
argument_list|)
argument_list|,
name|create
condition|?
name|INSERT
else|:
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|e
operator|==
name|NULL
condition|)
block|{
name|struct
name|symbol_hash_entry
modifier|*
name|v
decl_stmt|;
operator|*
name|e
operator|=
name|v
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|e
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|htab_t
name|file_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Look up an entry in the file hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|file_hash_entry
modifier|*
name|file_hash_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|file_table
argument_list|,
name|string
argument_list|,
call|(
modifier|*
name|htab_hash_string
call|)
argument_list|(
name|string
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|e
operator|==
name|NULL
condition|)
block|{
name|struct
name|file_hash_entry
modifier|*
name|v
decl_stmt|;
operator|*
name|e
operator|=
name|v
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|e
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|htab_t
name|demangled_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Look up an entry in the demangled name hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|demangled_hash_entry
modifier|*
name|demangled_hash_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|demangled_table
argument_list|,
name|string
argument_list|,
call|(
modifier|*
name|htab_hash_string
call|)
argument_list|(
name|string
argument_list|)
argument_list|,
name|create
condition|?
name|INSERT
else|:
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|e
operator|==
name|NULL
condition|)
block|{
name|struct
name|demangled_hash_entry
modifier|*
name|v
decl_stmt|;
operator|*
name|e
operator|=
name|v
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|e
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stack code.  */
end_comment

begin_struct
struct|struct
name|symbol_stack_entry
block|{
name|symbol
modifier|*
name|value
decl_stmt|;
name|struct
name|symbol_stack_entry
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|obstack
name|symbol_stack_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symbol_stack_entry
modifier|*
name|symbol_stack
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|file_stack_entry
block|{
name|file
modifier|*
name|value
decl_stmt|;
name|struct
name|file_stack_entry
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|obstack
name|file_stack_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|file_stack_entry
modifier|*
name|file_stack
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|symbol_push
parameter_list|(
name|symbol
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|symbol_stack_entry
modifier|*
name|ep
init|=
name|obstack_alloc
argument_list|(
operator|&
name|symbol_stack_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_stack_entry
argument_list|)
argument_list|)
decl_stmt|;
name|ep
operator|->
name|value
operator|=
name|p
expr_stmt|;
name|ep
operator|->
name|next
operator|=
name|symbol_stack
expr_stmt|;
name|symbol_stack
operator|=
name|ep
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|symbol
modifier|*
name|symbol_pop
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|symbol_stack_entry
modifier|*
name|ep
init|=
name|symbol_stack
decl_stmt|;
name|symbol
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|p
operator|=
name|ep
operator|->
name|value
expr_stmt|;
name|symbol_stack
operator|=
name|ep
operator|->
name|next
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|symbol_stack_obstack
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|file_push
parameter_list|(
name|file
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|file_stack_entry
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tweaking
condition|)
return|return;
name|ep
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|file_stack_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|file_stack_entry
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|value
operator|=
name|p
expr_stmt|;
name|ep
operator|->
name|next
operator|=
name|file_stack
expr_stmt|;
name|file_stack
operator|=
name|ep
expr_stmt|;
name|p
operator|->
name|tweaking
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|file
modifier|*
name|file_pop
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|file_stack_entry
modifier|*
name|ep
init|=
name|file_stack
decl_stmt|;
name|file
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|p
operator|=
name|ep
operator|->
name|value
expr_stmt|;
name|file_stack
operator|=
name|ep
operator|->
name|next
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|file_stack_obstack
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|p
operator|->
name|tweaking
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Other machinery.  */
end_comment

begin_comment
comment|/* Initialize the tlink machinery.  Called from do_tlink.  */
end_comment

begin_function
specifier|static
name|void
name|tlink_init
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|symbol_table
operator|=
name|htab_create
argument_list|(
literal|500
argument_list|,
name|hash_string_hash
argument_list|,
name|hash_string_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|file_table
operator|=
name|htab_create
argument_list|(
literal|500
argument_list|,
name|hash_string_hash
argument_list|,
name|hash_string_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|demangled_table
operator|=
name|htab_create
argument_list|(
literal|500
argument_list|,
name|hash_string_hash
argument_list|,
name|hash_string_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|symbol_stack_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|file_stack_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|getenv
argument_list|(
literal|"TLINK_VERBOSE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|tlink_verbose
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
block|{
name|tlink_verbose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
name|tlink_verbose
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|tlink_verbose
operator|=
literal|3
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|tlink_execute
parameter_list|(
specifier|const
name|char
modifier|*
name|prog
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|redir
parameter_list|)
block|{
name|collect_execute
argument_list|(
name|prog
argument_list|,
name|argv
argument_list|,
name|redir
argument_list|)
expr_stmt|;
return|return
name|collect_wait
argument_list|(
name|prog
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|frob_extension
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|ext
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|strrchr
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|s
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|s
argument_list|,
name|p
operator|-
name|s
argument_list|)
expr_stmt|;
return|return
name|obstack_copy0
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|ext
argument_list|,
name|strlen
argument_list|(
name|ext
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|obstack_fgets
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|struct
name|obstack
modifier|*
name|ob
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|obstack_1grow
argument_list|(
name|ob
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|obstack_object_size
argument_list|(
name|ob
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|obstack_1grow
argument_list|(
name|ob
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
return|return
name|obstack_finish
argument_list|(
name|ob
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|tfgets
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
return|return
name|obstack_fgets
argument_list|(
name|stream
argument_list|,
operator|&
name|temporary_obstack
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pfgets
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
return|return
name|xstrdup
argument_list|(
name|tfgets
argument_list|(
name|stream
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Real tlink code.  */
end_comment

begin_comment
comment|/* Subroutine of read_repo_file.  We are reading the repo file for file F,    which is coming in on STREAM, and the symbol that comes next in STREAM    is offered, chosen or provided if CHOSEN is 0, 1 or 2, respectively.     XXX "provided" is unimplemented, both here and in the compiler.  */
end_comment

begin_function
specifier|static
name|void
name|freadsym
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|file
modifier|*
name|f
parameter_list|,
name|int
name|chosen
parameter_list|)
block|{
name|symbol
modifier|*
name|sym
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|tfgets
argument_list|(
name|stream
argument_list|)
decl_stmt|;
name|sym
operator|=
name|symbol_hash_lookup
argument_list|(
name|name
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sym
operator|->
name|file
operator|==
name|NULL
condition|)
block|{
comment|/* We didn't have this symbol already, so we choose this file.  */
name|symbol_push
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|sym
operator|->
name|file
operator|=
name|f
expr_stmt|;
name|sym
operator|->
name|chosen
operator|=
name|chosen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chosen
condition|)
block|{
comment|/* We want this file; cast aside any pretender.  */
if|if
condition|(
name|sym
operator|->
name|chosen
operator|&&
name|sym
operator|->
name|file
operator|!=
name|f
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|chosen
operator|==
literal|1
condition|)
name|file_push
argument_list|(
name|sym
operator|->
name|file
argument_list|)
expr_stmt|;
else|else
block|{
name|file_push
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|=
name|sym
operator|->
name|file
expr_stmt|;
name|chosen
operator|=
name|sym
operator|->
name|chosen
expr_stmt|;
block|}
block|}
name|sym
operator|->
name|file
operator|=
name|f
expr_stmt|;
name|sym
operator|->
name|chosen
operator|=
name|chosen
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read in the repo file denoted by F, and record all its information.  */
end_comment

begin_function
specifier|static
name|void
name|read_repo_file
parameter_list|(
name|file
modifier|*
name|f
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|FILE
modifier|*
name|stream
init|=
name|fopen
argument_list|(
name|f
operator|->
name|key
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|tlink_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"collect: reading %s\n"
argument_list|)
argument_list|,
name|f
operator|->
name|key
argument_list|)
expr_stmt|;
while|while
condition|(
name|fscanf
argument_list|(
name|stream
argument_list|,
literal|"%c "
argument_list|,
operator|&
name|c
argument_list|)
operator|==
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'A'
case|:
name|f
operator|->
name|args
operator|=
name|pfgets
argument_list|(
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|f
operator|->
name|dir
operator|=
name|pfgets
argument_list|(
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|f
operator|->
expr|main
operator|=
name|pfgets
argument_list|(
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|freadsym
argument_list|(
name|stream
argument_list|,
name|f
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|freadsym
argument_list|(
name|stream
argument_list|,
name|f
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|freadsym
argument_list|(
name|stream
argument_list|,
name|f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|obstack_free
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|temporary_firstobj
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|args
operator|==
name|NULL
condition|)
name|f
operator|->
name|args
operator|=
name|getenv
argument_list|(
literal|"COLLECT_GCC_OPTIONS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|dir
operator|==
name|NULL
condition|)
name|f
operator|->
name|dir
operator|=
literal|"."
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We might want to modify LINE, which is a symbol line from file F.  We do    this if either we saw an error message referring to the symbol in    question, or we have already allocated the symbol to another file and    this one wants to emit it as well.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_tweak
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|file
modifier|*
name|f
parameter_list|)
block|{
name|symbol
modifier|*
name|sym
init|=
name|symbol_hash_lookup
argument_list|(
name|line
operator|+
literal|2
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|sym
operator|->
name|file
operator|==
name|f
operator|&&
name|sym
operator|->
name|tweaking
operator|)
operator|||
operator|(
name|sym
operator|->
name|file
operator|!=
name|f
operator|&&
name|line
index|[
literal|0
index|]
operator|==
literal|'C'
operator|)
condition|)
block|{
name|sym
operator|->
name|tweaking
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|tweaked
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'O'
condition|)
name|line
index|[
literal|0
index|]
operator|=
literal|'C'
expr_stmt|;
else|else
name|line
index|[
literal|0
index|]
operator|=
literal|'O'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Update the repo files for each of the object files we have adjusted and    recompile.     XXX Should this use collect_execute instead of system?  */
end_comment

begin_function
specifier|static
name|int
name|recompile_files
parameter_list|(
name|void
parameter_list|)
block|{
name|file
modifier|*
name|f
decl_stmt|;
name|putenv
argument_list|(
name|xstrdup
argument_list|(
literal|"COMPILER_PATH="
argument_list|)
argument_list|)
expr_stmt|;
name|putenv
argument_list|(
name|xstrdup
argument_list|(
literal|"LIBRARY_PATH="
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|f
operator|=
name|file_pop
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|command
decl_stmt|;
name|FILE
modifier|*
name|stream
init|=
name|fopen
argument_list|(
name|f
operator|->
name|key
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|outname
init|=
name|frob_extension
argument_list|(
name|f
operator|->
name|key
argument_list|,
literal|".rnw"
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|output
init|=
name|fopen
argument_list|(
name|outname
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|tfgets
argument_list|(
name|stream
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|line
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'C'
case|:
case|case
literal|'O'
case|:
name|maybe_tweak
argument_list|(
name|line
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output
argument_list|,
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|outname
argument_list|,
name|f
operator|->
name|key
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|"cd "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|f
operator|->
name|dir
argument_list|,
name|strlen
argument_list|(
name|f
operator|->
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|"; "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|c_file_name
argument_list|,
name|strlen
argument_list|(
name|c_file_name
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|f
operator|->
name|args
argument_list|,
name|strlen
argument_list|(
name|f
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|command
operator|=
name|obstack_copy0
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|f
operator|->
expr|main
argument_list|,
name|strlen
argument_list|(
name|f
operator|->
expr|main
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlink_verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"collect: recompiling %s\n"
argument_list|)
argument_list|,
name|f
operator|->
expr|main
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlink_verbose
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|command
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|read_repo_file
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|temporary_firstobj
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The first phase of processing: determine which object files have    .rpo files associated with them, and read in the information.  */
end_comment

begin_function
specifier|static
name|int
name|read_repo_files
parameter_list|(
name|char
modifier|*
modifier|*
name|object_lst
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|object
init|=
name|object_lst
decl_stmt|;
for|for
control|(
init|;
operator|*
name|object
condition|;
name|object
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|file
modifier|*
name|f
decl_stmt|;
comment|/* Don't bother trying for ld flags.  */
if|if
condition|(
operator|*
name|object
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
continue|continue;
name|p
operator|=
name|frob_extension
argument_list|(
operator|*
name|object
argument_list|,
literal|".rpo"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_exists
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
name|f
operator|=
name|file_hash_lookup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|read_repo_file
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file_stack
operator|!=
name|NULL
operator|&&
operator|!
name|recompile_files
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|symbol_stack
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add the demangled forms of any new symbols to the hash table.  */
end_comment

begin_function
specifier|static
name|void
name|demangle_new_symbols
parameter_list|(
name|void
parameter_list|)
block|{
name|symbol
modifier|*
name|sym
decl_stmt|;
while|while
condition|(
operator|(
name|sym
operator|=
name|symbol_pop
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|demangled
modifier|*
name|dem
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|cplus_demangle
argument_list|(
name|sym
operator|->
name|key
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
continue|continue;
name|dem
operator|=
name|demangled_hash_lookup
argument_list|(
name|p
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|dem
operator|->
name|mangled
operator|=
name|sym
operator|->
name|key
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Step through the output of the linker, in the file named FNAME, and    adjust the settings for each symbol encountered.  */
end_comment

begin_function
specifier|static
name|int
name|scan_linker_output
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|FILE
modifier|*
name|stream
init|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|tfgets
argument_list|(
name|stream
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|line
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|end
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
continue|continue;
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|q
argument_list|)
condition|;
operator|++
name|q
control|)
empty_stmt|;
comment|/* Try the first word on the line.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
name|USER_LABEL_PREFIX
argument_list|,
name|strlen
argument_list|(
name|USER_LABEL_PREFIX
argument_list|)
argument_list|)
condition|)
name|p
operator|+=
name|strlen
argument_list|(
name|USER_LABEL_PREFIX
argument_list|)
expr_stmt|;
name|end
operator|=
operator|!
operator|*
name|q
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|sym
operator|=
name|symbol_hash_lookup
argument_list|(
name|p
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Some SVR4 linkers produce messages like 	 ld: 0711-317 ERROR: Undefined symbol: .g__t3foo1Zi 	 */
if|if
condition|(
operator|!
name|sym
operator|&&
operator|!
name|end
operator|&&
name|strstr
argument_list|(
name|q
operator|+
literal|1
argument_list|,
literal|"Undefined symbol: "
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|strrchr
argument_list|(
name|q
operator|+
literal|1
argument_list|,
literal|' '
argument_list|)
decl_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
name|USER_LABEL_PREFIX
argument_list|,
name|strlen
argument_list|(
name|USER_LABEL_PREFIX
argument_list|)
argument_list|)
condition|)
name|p
operator|+=
name|strlen
argument_list|(
name|USER_LABEL_PREFIX
argument_list|)
expr_stmt|;
name|sym
operator|=
name|symbol_hash_lookup
argument_list|(
name|p
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sym
operator|&&
operator|!
name|end
condition|)
comment|/* Try a mangled name in quotes.  */
block|{
specifier|const
name|char
modifier|*
name|oldq
init|=
name|q
operator|+
literal|1
decl_stmt|;
name|demangled
modifier|*
name|dem
init|=
literal|0
decl_stmt|;
name|q
operator|=
literal|0
expr_stmt|;
comment|/* First try `GNU style'.  */
name|p
operator|=
name|strchr
argument_list|(
name|oldq
argument_list|,
literal|'`'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|p
operator|++
operator|,
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
comment|/* Then try "double quotes".  */
elseif|else
if|if
condition|(
name|p
operator|=
name|strchr
argument_list|(
name|oldq
argument_list|,
literal|'"'
argument_list|)
operator|,
name|p
condition|)
name|p
operator|++
operator|,
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Then try entire line.  */
name|q
operator|=
name|strchr
argument_list|(
name|oldq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|oldq
condition|)
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|oldq
expr_stmt|;
block|}
if|if
condition|(
name|p
condition|)
block|{
comment|/* Don't let the strstr's below see the demangled name; we 		 might get spurious matches.  */
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* powerpc64-linux references .foo when calling function foo.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
name|p
operator|++
expr_stmt|;
block|}
comment|/* We need to check for certain error keywords here, or we would 	     mistakenly use GNU ld's "In function `foo':" message.  */
if|if
condition|(
name|q
operator|&&
operator|(
name|strstr
argument_list|(
name|oldq
argument_list|,
literal|"ndefined"
argument_list|)
operator|||
name|strstr
argument_list|(
name|oldq
argument_list|,
literal|"nresolved"
argument_list|)
operator|||
name|strstr
argument_list|(
name|oldq
argument_list|,
literal|"nsatisfied"
argument_list|)
operator|||
name|strstr
argument_list|(
name|oldq
argument_list|,
literal|"ultiple"
argument_list|)
operator|)
condition|)
block|{
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|dem
operator|=
name|demangled_hash_lookup
argument_list|(
name|p
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|dem
condition|)
name|sym
operator|=
name|symbol_hash_lookup
argument_list|(
name|dem
operator|->
name|mangled
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
name|USER_LABEL_PREFIX
argument_list|,
name|strlen
argument_list|(
name|USER_LABEL_PREFIX
argument_list|)
argument_list|)
condition|)
name|p
operator|+=
name|strlen
argument_list|(
name|USER_LABEL_PREFIX
argument_list|)
expr_stmt|;
name|sym
operator|=
name|symbol_hash_lookup
argument_list|(
name|p
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|sym
operator|&&
name|sym
operator|->
name|tweaked
condition|)
block|{
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sym
operator|&&
operator|!
name|sym
operator|->
name|tweaking
condition|)
block|{
if|if
condition|(
name|tlink_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"collect: tweaking %s in %s\n"
argument_list|)
argument_list|,
name|sym
operator|->
name|key
argument_list|,
name|sym
operator|->
name|file
operator|->
name|key
argument_list|)
expr_stmt|;
name|sym
operator|->
name|tweaking
operator|=
literal|1
expr_stmt|;
name|file_push
argument_list|(
name|sym
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
name|obstack_free
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|temporary_firstobj
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
operator|(
name|file_stack
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Entry point for tlink.  Called from main in collect2.c.     Iteratively try to provide definitions for all the unresolved symbols    mentioned in the linker error messages.     LD_ARGV is an array of arguments for the linker.    OBJECT_LST is an array of object files that we may be able to recompile      to provide missing definitions.  Currently ignored.  */
end_comment

begin_function
name|void
name|do_tlink
parameter_list|(
name|char
modifier|*
modifier|*
name|ld_argv
parameter_list|,
name|char
modifier|*
modifier|*
name|object_lst
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|exit
init|=
name|tlink_execute
argument_list|(
literal|"ld"
argument_list|,
name|ld_argv
argument_list|,
name|ldout
argument_list|)
decl_stmt|;
name|tlink_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|exit
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Until collect does a better job of figuring out which are object 	 files, assume that everything on the command line could be.  */
if|if
condition|(
name|read_repo_files
argument_list|(
name|ld_argv
argument_list|)
condition|)
while|while
condition|(
name|exit
operator|&&
name|i
operator|++
operator|<
name|MAX_ITERATIONS
condition|)
block|{
if|if
condition|(
name|tlink_verbose
operator|>=
literal|3
condition|)
name|dump_file
argument_list|(
name|ldout
argument_list|)
expr_stmt|;
name|demangle_new_symbols
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scan_linker_output
argument_list|(
name|ldout
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|recompile_files
argument_list|()
condition|)
break|break;
if|if
condition|(
name|tlink_verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"collect: relinking\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
operator|=
name|tlink_execute
argument_list|(
literal|"ld"
argument_list|,
name|ld_argv
argument_list|,
name|ldout
argument_list|)
expr_stmt|;
block|}
block|}
name|dump_file
argument_list|(
name|ldout
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|ldout
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit
condition|)
block|{
name|error
argument_list|(
literal|"ld returned %d exit status"
argument_list|,
name|exit
argument_list|)
expr_stmt|;
name|collect_exit
argument_list|(
name|exit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

