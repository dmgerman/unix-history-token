begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used by or related to instruction recognition.    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998    1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_PUSH_CODE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
end_ifdef

begin_define
define|#
directive|define
name|STACK_PUSH_CODE
value|PRE_DEC
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STACK_PUSH_CODE
value|PRE_INC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_POP_CODE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
end_ifdef

begin_define
define|#
directive|define
name|STACK_POP_CODE
value|POST_INC
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STACK_POP_CODE
value|POST_DEC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|validate_replace_rtx_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|find_single_use_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|validate_replace_src_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|split_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means allow operands to be volatile.    This should be 0 if you are generating rtl, such as if you are calling    the functions in optabs.c and expmed.c (most of the time).    This should be 1 if all valid insns need to be recognized,    such as in regclass.c and final.c and reload.c.     init_recog and init_recog_no_volatile are responsible for setting this.  */
end_comment

begin_decl_stmt
name|int
name|volatile_ok
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|recog_data
name|recog_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Contains a vector of operand_alternative structures for every operand.    Set up by preprocess_constraints.  */
end_comment

begin_decl_stmt
name|struct
name|operand_alternative
name|recog_op_alt
index|[
name|MAX_RECOG_OPERANDS
index|]
index|[
name|MAX_RECOG_ALTERNATIVES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On return from `constrain_operands', indicate which alternative    was satisfied.  */
end_comment

begin_decl_stmt
name|int
name|which_alternative
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero after end of reload pass.    Set to 1 or 0 by toplev.c.    Controls the significance of (SUBREG (MEM)).  */
end_comment

begin_decl_stmt
name|int
name|reload_completed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize data used by the function `recog'.    This must be called once in the compilation of a function    before any insn recognition may be done in the function.  */
end_comment

begin_function
name|void
name|init_recog_no_volatile
parameter_list|()
block|{
name|volatile_ok
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_recog
parameter_list|()
block|{
name|volatile_ok
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try recognizing the instruction INSN,    and return the code number that results.    Remember the code so that repeated calls do not    need to spend the time for actual rerecognition.     This function is the normal interface to instruction recognition.    The automatically-generated function `recog' is normally called    through this one.  (The only exception is in combine.c.)  */
end_comment

begin_function
name|int
name|recog_memoized_1
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check that X is an insn-body for an `asm' with operands    and that the operands mentioned in it are legitimate.  */
end_comment

begin_function
name|int
name|check_asm_operands
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|noperands
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|constraints
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Post-reload, be more strict with things.  */
if|if
condition|(
name|reload_completed
condition|)
block|{
comment|/* ??? Doh!  We've not got the wrapping insn.  Cook one up.  */
name|extract_insn
argument_list|(
name|make_insn_raw
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|constrain_operands
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|which_alternative
operator|>=
literal|0
return|;
block|}
name|noperands
operator|=
name|asm_noperands
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|noperands
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|noperands
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|operands
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|noperands
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|constraints
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|noperands
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|decode_asm_operands
argument_list|(
name|x
argument_list|,
name|operands
argument_list|,
name|NULL
argument_list|,
name|constraints
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|constraints
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
name|c
operator|++
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
index|[
literal|0
index|]
argument_list|)
operator|&&
name|c
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|c
operator|=
name|constraints
index|[
name|c
index|[
literal|0
index|]
operator|-
literal|'0'
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|asm_operand_ok
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|,
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Static data for the next two routines.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|change_t
block|{
name|rtx
name|object
decl_stmt|;
name|int
name|old_code
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|old
decl_stmt|;
block|}
name|change_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|change_t
modifier|*
name|changes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|changes_allocated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_changes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Validate a proposed change to OBJECT.  LOC is the location in the rtl    at which NEW will be placed.  If OBJECT is zero, no validation is done,    the change is simply made.     Two types of objects are supported:  If OBJECT is a MEM, memory_address_p    will be called with the address and mode as parameters.  If OBJECT is    an INSN, CALL_INSN, or JUMP_INSN, the insn will be re-recognized with    the change in place.     IN_GROUP is non-zero if this is part of a group of changes that must be    performed as a group.  In that case, the changes will be stored.  The    function `apply_change_group' will validate and apply the changes.     If IN_GROUP is zero, this is a single change.  Try to recognize the insn    or validate the memory reference with the change applied.  If the result    is not valid for the machine, suppress the change and return zero.    Otherwise, perform the change and return 1.  */
end_comment

begin_function
name|int
name|validate_change
parameter_list|(
name|object
parameter_list|,
name|loc
parameter_list|,
name|new
parameter_list|,
name|in_group
parameter_list|)
name|rtx
name|object
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|new
decl_stmt|;
name|int
name|in_group
decl_stmt|;
block|{
name|rtx
name|old
init|=
operator|*
name|loc
decl_stmt|;
if|if
condition|(
name|old
operator|==
name|new
operator|||
name|rtx_equal_p
argument_list|(
name|old
argument_list|,
name|new
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|in_group
operator|==
literal|0
operator|&&
name|num_changes
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|loc
operator|=
name|new
expr_stmt|;
comment|/* Save the information describing this change.  */
if|if
condition|(
name|num_changes
operator|>=
name|changes_allocated
condition|)
block|{
if|if
condition|(
name|changes_allocated
operator|==
literal|0
condition|)
comment|/* This value allows for repeated substitutions inside complex 	   indexed addresses, or changes in up to 5 insns.  */
name|changes_allocated
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|5
expr_stmt|;
else|else
name|changes_allocated
operator|*=
literal|2
expr_stmt|;
name|changes
operator|=
operator|(
name|change_t
operator|*
operator|)
name|xrealloc
argument_list|(
name|changes
argument_list|,
sizeof|sizeof
argument_list|(
name|change_t
argument_list|)
operator|*
name|changes_allocated
argument_list|)
expr_stmt|;
block|}
name|changes
index|[
name|num_changes
index|]
operator|.
name|object
operator|=
name|object
expr_stmt|;
name|changes
index|[
name|num_changes
index|]
operator|.
name|loc
operator|=
name|loc
expr_stmt|;
name|changes
index|[
name|num_changes
index|]
operator|.
name|old
operator|=
name|old
expr_stmt|;
if|if
condition|(
name|object
operator|&&
name|GET_CODE
argument_list|(
name|object
argument_list|)
operator|!=
name|MEM
condition|)
block|{
comment|/* Set INSN_CODE to force rerecognition of insn.  Save old code in 	 case invalid.  */
name|changes
index|[
name|num_changes
index|]
operator|.
name|old_code
operator|=
name|INSN_CODE
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|object
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|num_changes
operator|++
expr_stmt|;
comment|/* If we are making a group of changes, return 1.  Otherwise, validate the      change group we made.  */
if|if
condition|(
name|in_group
condition|)
return|return
literal|1
return|;
else|else
return|return
name|apply_change_group
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* This subroutine of apply_change_group verifies whether the changes to INSN    were valid; i.e. whether INSN can still be recognized.  */
end_comment

begin_function
name|int
name|insn_invalid_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|num_clobbers
init|=
literal|0
decl_stmt|;
comment|/* If we are before reload and the pattern is a SET, see if we can add      clobbers.  */
name|int
name|icode
init|=
name|recog
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
operator|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
operator|!
name|reload_completed
operator|&&
operator|!
name|reload_in_progress
operator|)
condition|?
operator|&
name|num_clobbers
else|:
literal|0
argument_list|)
decl_stmt|;
name|int
name|is_asm
init|=
name|icode
operator|<
literal|0
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
decl_stmt|;
comment|/* If this is an asm and the operand aren't legal, then fail.  Likewise if      this is not an asm and the insn wasn't recognized.  */
if|if
condition|(
operator|(
name|is_asm
operator|&&
operator|!
name|check_asm_operands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|is_asm
operator|&&
name|icode
operator|<
literal|0
operator|)
condition|)
return|return
literal|1
return|;
comment|/* If we have to add CLOBBERs, fail if we have to add ones that reference      hard registers since our callers can't know if they are live or not.      Otherwise, add them.  */
if|if
condition|(
name|num_clobbers
operator|>
literal|0
condition|)
block|{
name|rtx
name|newpat
decl_stmt|;
if|if
condition|(
name|added_clobbers_hard_reg_p
argument_list|(
name|icode
argument_list|)
condition|)
return|return
literal|1
return|;
name|newpat
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|num_clobbers
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|pat
expr_stmt|;
name|add_clobbers
argument_list|(
name|newpat
argument_list|,
name|icode
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pat
operator|=
name|newpat
expr_stmt|;
block|}
comment|/* After reload, verify that all constraints are satisfied.  */
if|if
condition|(
name|reload_completed
condition|)
block|{
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
name|icode
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Apply a group of changes previously issued with `validate_change'.    Return 1 if all changes are valid, zero otherwise.  */
end_comment

begin_function
name|int
name|apply_change_group
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|last_validated
init|=
name|NULL_RTX
decl_stmt|;
comment|/* The changes have been applied and all INSN_CODEs have been reset to force      rerecognition.       The changes are valid if we aren't given an object, or if we are      given a MEM and it still is a valid address, or if this is in insn      and it is recognized.  In the latter case, if reload has completed,      we also require that the operands meet the constraints for      the insn.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_changes
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|object
init|=
name|changes
index|[
name|i
index|]
operator|.
name|object
decl_stmt|;
comment|/* if there is no object to test or if it is the same as the one we          already tested, ignore it.  */
if|if
condition|(
name|object
operator|==
literal|0
operator|||
name|object
operator|==
name|last_validated
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|object
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|object
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|object
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|insn_invalid_p
argument_list|(
name|object
argument_list|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|object
argument_list|)
decl_stmt|;
comment|/* Perhaps we couldn't recognize the insn because there were 	     extra CLOBBERs at the end.  If so, try to re-recognize 	     without the last CLOBBER (later iterations will cause each of 	     them to be eliminated, in turn).  But don't do this if we 	     have an ASM_OPERAND.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|object
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rtx
name|newpat
decl_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
condition|)
name|newpat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|j
decl_stmt|;
name|newpat
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* Add a new change to this group to replace the pattern 		 with this new pattern.  Then consider this change 		 as having succeeded.  The change we added will 		 cause the entire call to fail if things remain invalid.  		 Note that this can lose if a later change than the one 		 we are processing specified&XVECEXP (PATTERN (object), 0, X) 		 but this shouldn't occur.  */
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|object
argument_list|)
argument_list|,
name|newpat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
comment|/* If this insn is a CLOBBER or USE, it is always valid, but is 	       never recognized.  */
continue|continue;
else|else
break|break;
block|}
name|last_validated
operator|=
name|object
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|num_changes
condition|)
block|{
name|num_changes
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|cancel_changes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the number of changes so far in the current group.  */
end_comment

begin_function
name|int
name|num_validated_changes
parameter_list|()
block|{
return|return
name|num_changes
return|;
block|}
end_function

begin_comment
comment|/* Retract the changes numbered NUM and up.  */
end_comment

begin_function
name|void
name|cancel_changes
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Back out all the changes.  Do this in the opposite order in which      they were made.  */
for|for
control|(
name|i
operator|=
name|num_changes
operator|-
literal|1
init|;
name|i
operator|>=
name|num
condition|;
name|i
operator|--
control|)
block|{
operator|*
name|changes
index|[
name|i
index|]
operator|.
name|loc
operator|=
name|changes
index|[
name|i
index|]
operator|.
name|old
expr_stmt|;
if|if
condition|(
name|changes
index|[
name|i
index|]
operator|.
name|object
operator|&&
name|GET_CODE
argument_list|(
name|changes
index|[
name|i
index|]
operator|.
name|object
argument_list|)
operator|!=
name|MEM
condition|)
name|INSN_CODE
argument_list|(
name|changes
index|[
name|i
index|]
operator|.
name|object
argument_list|)
operator|=
name|changes
index|[
name|i
index|]
operator|.
name|old_code
expr_stmt|;
block|}
name|num_changes
operator|=
name|num
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Replace every occurrence of FROM in X with TO.  Mark each change with    validate_change passing OBJECT.  */
end_comment

begin_function
specifier|static
name|void
name|validate_replace_rtx_1
parameter_list|(
name|loc
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|,
name|object
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|,
name|object
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|op0_mode
init|=
name|VOIDmode
decl_stmt|;
name|int
name|prev_changes
init|=
name|num_changes
decl_stmt|;
name|rtx
name|new
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
literal|0
index|]
operator|==
literal|'e'
condition|)
name|op0_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* X matches FROM if it is the same rtx or they are both referring to the      same register in the same mode.  Avoid calling rtx_equal_p unless the      operands look similar.  */
if|if
condition|(
name|x
operator|==
name|from
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|from
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|from
argument_list|)
operator|)
condition|)
block|{
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Call ourself recursively to perform the replacements.  */
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|validate_replace_rtx_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|object
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|validate_replace_rtx_1
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
comment|/* If we didn't substitute, there is nothing more to do.  */
if|if
condition|(
name|num_changes
operator|==
name|prev_changes
condition|)
return|return;
comment|/* Allow substituted expression to have different mode.  This is used by      regmove to change mode of pseudo register.  */
if|if
condition|(
name|fmt
index|[
literal|0
index|]
operator|==
literal|'e'
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|op0_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do changes needed to keep rtx consistent.  Don't do any other      simplifications, as it is not our job.  */
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|)
operator|&&
name|swap_commutative_operands_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
condition|?
name|code
else|:
name|swap_condition
argument_list|(
name|code
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|x
operator|=
operator|*
name|loc
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
comment|/* If we have a PLUS whose second operand is now a CONST_INT, use          plus_constant to try to simplify it.          ??? We may want later to remove this, once simplification is          separated from this function.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|new
operator|=
name|simplify_gen_unary
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0_mode
argument_list|)
expr_stmt|;
comment|/* If any of the above failed, substitute in something that 	     we know won't be recognized.  */
if|if
condition|(
operator|!
name|new
condition|)
name|new
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SUBREG
case|:
comment|/* All subregs possible to simplify should be simplified.  */
name|new
operator|=
name|simplify_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|op0_mode
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Subregs of VOIDmode operands are incorrect.  */
if|if
condition|(
operator|!
name|new
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
name|new
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTRACT
case|:
case|case
name|SIGN_EXTRACT
case|:
comment|/* If we are replacing a register with memory, try to change the memory          to be the mode required for memory in extract operations (this isn't          likely to be an insertion operation; if it was, nothing bad will          happen, we might just fail in some cases).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|wanted_mode
init|=
name|VOIDmode
decl_stmt|;
name|enum
name|machine_mode
name|is_mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
name|enum
name|machine_mode
name|new_mode
init|=
name|mode_for_extraction
argument_list|(
name|EP_extzv
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_mode
operator|!=
name|MAX_MACHINE_MODE
condition|)
name|wanted_mode
operator|=
name|new_mode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
block|{
name|enum
name|machine_mode
name|new_mode
init|=
name|mode_for_extraction
argument_list|(
name|EP_extv
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_mode
operator|!=
name|MAX_MACHINE_MODE
condition|)
name|wanted_mode
operator|=
name|new_mode
expr_stmt|;
block|}
comment|/* If we have a narrower mode, we can do something.  */
if|if
condition|(
name|wanted_mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
condition|)
block|{
name|int
name|offset
init|=
name|pos
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|newmem
decl_stmt|;
comment|/* If the bytes and bits are counted differently, we 	         must adjust the offset.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|!=
name|BITS_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|-
name|offset
operator|)
expr_stmt|;
name|pos
operator|%=
name|GET_MODE_BITSIZE
argument_list|(
name|wanted_mode
argument_list|)
expr_stmt|;
name|newmem
operator|=
name|adjust_address_nv
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|wanted_mode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|pos
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|newmem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Try replacing every occurrence of FROM in subexpression LOC of INSN    with TO.  After all changes have been made, validate by seeing    if INSN is still valid.  */
end_comment

begin_function
name|int
name|validate_replace_rtx_subexp
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|insn
parameter_list|,
name|loc
parameter_list|)
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|,
name|insn
decl_stmt|,
decl|*
name|loc
decl_stmt|;
end_function

begin_block
block|{
name|validate_replace_rtx_1
argument_list|(
name|loc
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|apply_change_group
argument_list|()
return|;
block|}
end_block

begin_comment
comment|/* Try replacing every occurrence of FROM in INSN with TO.  After all    changes have been made, validate by seeing if INSN is still valid.  */
end_comment

begin_function
name|int
name|validate_replace_rtx
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|validate_replace_rtx_1
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|apply_change_group
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Try replacing every occurrence of FROM in INSN with TO.  */
end_comment

begin_function
name|void
name|validate_replace_rtx_group
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|validate_replace_rtx_1
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function called by note_uses to replace used subexpressions.  */
end_comment

begin_struct
struct|struct
name|validate_replace_src_data
block|{
name|rtx
name|from
decl_stmt|;
comment|/* Old RTX */
name|rtx
name|to
decl_stmt|;
comment|/* New RTX */
name|rtx
name|insn
decl_stmt|;
comment|/* Insn in which substitution is occurring.  */
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|validate_replace_src_1
parameter_list|(
name|x
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|x
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|validate_replace_src_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|validate_replace_src_data
operator|*
operator|)
name|data
decl_stmt|;
name|validate_replace_rtx_1
argument_list|(
name|x
argument_list|,
name|d
operator|->
name|from
argument_list|,
name|d
operator|->
name|to
argument_list|,
name|d
operator|->
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try replacing every occurrence of FROM in INSN with TO, avoiding    SET_DESTs.  After all changes have been made, validate by seeing if    INSN is still valid.  */
end_comment

begin_function
name|int
name|validate_replace_src
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|struct
name|validate_replace_src_data
name|d
decl_stmt|;
name|d
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|d
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|d
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|note_uses
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|validate_replace_src_1
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
return|return
name|apply_change_group
argument_list|()
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_comment
comment|/* Return 1 if the insn using CC0 set by INSN does not contain    any ordered tests applied to the condition codes.    EQ and NE tests do not count.  */
end_comment

begin_function
name|int
name|next_insn_tests_no_inequality
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|next
init|=
name|next_cc0_user
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If there is no next insn, we have to take the conservative choice.  */
if|if
condition|(
name|next
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CALL_INSN
operator|)
operator|&&
operator|!
name|inequality_comparisons_p
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This is useless since the insn that sets the cc's 	  must be followed immediately by the use of them.  */
end_comment

begin_comment
comment|/* Return 1 if the CC value set up by INSN is not used.  */
end_comment

begin_endif
unit|int next_insns_test_no_inequality (insn)      rtx insn; {   rtx next = NEXT_INSN (insn);    for (; next != 0; next = NEXT_INSN (next))     {       if (GET_CODE (next) == CODE_LABEL 	  || GET_CODE (next) == BARRIER) 	return 1;       if (GET_CODE (next) == NOTE) 	continue;       if (inequality_comparisons_p (PATTERN (next))) 	return 0;       if (sets_cc0_p (PATTERN (next)) == 1) 	return 1;       if (! reg_mentioned_p (cc0_rtx, PATTERN (next))) 	return 1;     }   return 1; }
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* This is used by find_single_use to locate an rtx that contains exactly one    use of DEST, which is typically either a REG or CC0.  It returns a    pointer to the innermost rtx expression containing DEST.  Appearances of    DEST that are being used to totally replace it are not counted.  */
end_comment

begin_function
specifier|static
name|rtx
modifier|*
name|find_single_use_1
parameter_list|(
name|dest
parameter_list|,
name|loc
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|result
init|=
literal|0
decl_stmt|;
name|rtx
modifier|*
name|this_result
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CLOBBER
case|:
return|return
literal|0
return|;
case|case
name|SET
case|:
comment|/* If the destination is anything other than CC0, PC, a REG or a SUBREG 	 of a REG that occupies all of the REG, the insn uses DEST if 	 it is mentioned in the destination or the source.  Otherwise, we 	 need just check the source.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|CC0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
operator|)
condition|)
break|break;
return|return
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
case|case
name|MEM
case|:
case|case
name|SUBREG
case|:
return|return
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* If it wasn't one of the common cases above, check each expression and      vector of this code.  Look for a unique usage of DEST.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|dest
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|)
name|this_result
operator|=
name|loc
expr_stmt|;
else|else
name|this_result
operator|=
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|result
operator|=
name|this_result
expr_stmt|;
elseif|else
if|if
condition|(
name|this_result
condition|)
comment|/* Duplicate usage.  */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|==
name|dest
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|)
condition|)
name|this_result
operator|=
name|loc
expr_stmt|;
else|else
name|this_result
operator|=
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|result
operator|=
name|this_result
expr_stmt|;
elseif|else
if|if
condition|(
name|this_result
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if DEST, produced in INSN, is used only a single time in the    sequel.  If so, return a pointer to the innermost rtx expression in which    it is used.     If PLOC is non-zero, *PLOC is set to the insn containing the single use.     This routine will return usually zero either before flow is called (because    there will be no LOG_LINKS notes) or after reload (because the REG_DEAD    note can't be trusted).     If DEST is cc0_rtx, we look only at the next insn.  In that case, we don't    care about REG_DEAD notes or LOG_LINKS.     Otherwise, we find the single use by finding an insn that has a    LOG_LINKS pointing at INSN and has a REG_DEAD note for DEST.  If DEST is    only referenced once in that insn, we know that it must be the first    and last insn referencing DEST.  */
end_comment

begin_function
name|rtx
modifier|*
name|find_single_use
parameter_list|(
name|dest
parameter_list|,
name|insn
parameter_list|,
name|ploc
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|ploc
decl_stmt|;
block|{
name|rtx
name|next
decl_stmt|;
name|rtx
modifier|*
name|result
decl_stmt|;
name|rtx
name|link
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|dest
operator|==
name|cc0_rtx
condition|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
literal|0
operator|||
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|!=
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|!=
name|JUMP_INSN
operator|)
condition|)
return|return
literal|0
return|;
name|result
operator|=
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|&&
name|ploc
condition|)
operator|*
name|ploc
operator|=
name|next
expr_stmt|;
return|return
name|result
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|reload_completed
operator|||
name|reload_in_progress
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
for|for
control|(
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|next
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|next
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|next
argument_list|)
operator|&&
name|dead_or_set_p
argument_list|(
name|next
argument_list|,
name|dest
argument_list|)
condition|)
block|{
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|next
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|insn
condition|)
break|break;
if|if
condition|(
name|link
condition|)
block|{
name|result
operator|=
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ploc
condition|)
operator|*
name|ploc
operator|=
name|next
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a valid general operand for machine mode MODE.    This is either a register reference, a memory reference,    or a constant.  In the case of a memory reference, the address    is checked for general validity for the target machine.     Register and memory references must have mode MODE in order to be valid,    but some constants have no machine mode and are valid for any mode.     If MODE is VOIDmode, OP is checked for validity for whatever mode    it has.     The main use of this function is as a predicate in match_operand    expressions in the machine description.     For an explanation of this function's behavior for registers of    class NO_REGS, see the comment for `register_operand'.  */
end_comment

begin_function
name|int
name|general_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* Don't accept CONST_INT or anything similar      if the caller wants something floating.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|!=
name|INTVAL
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
comment|/* Except for certain constants with VOIDmode, already checked for,      OP's mode must match MODE if MODE specifies a mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
block|{
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
comment|/* On machines that have insn scheduling, we want all memory 	 reference to be explicit, so outlaw paradoxical SUBREGs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* Avoid memories with nonzero SUBREG_BYTE, as offsetting the memory          may result in incorrect reference.  We should simplify all valid          subregs of MEM anyway.  But allow this after reload because we 	 might be called from cleanup_subreg_operands.   	 ??? This is a kludge.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|SUBREG_BYTE
argument_list|(
name|op
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|REG
condition|)
comment|/* A register whose class is NO_REGS is not a general operand.  */
return|return
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|NO_REGS
operator|)
return|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
name|rtx
name|y
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|volatile_ok
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
literal|1
return|;
comment|/* Use the mem's mode, since it will be reloaded thus.  */
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|GO_IF_LEGITIMATE_ADDRESS
argument_list|(
name|mode
argument_list|,
name|y
argument_list|,
name|win
argument_list|)
expr_stmt|;
block|}
comment|/* Pretend this is an operand for now; we'll run force_operand      on its replacement in fixup_var_refs_1.  */
if|if
condition|(
name|code
operator|==
name|ADDRESSOF
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
name|win
label|:
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a valid memory address for a memory reference    of mode MODE.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|address_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register reference of mode MODE.    If MODE is VOIDmode, accept a register in any mode.     The main use of this function is as a predicate in match_operand    expressions in the machine description.     As a special exception, registers whose class is NO_REGS are    not accepted by `register_operand'.  The reason for this change    is to allow the representation of special architecture artifacts    (such as a condition code register) without extending the rtl    definitions.  Since registers of class NO_REGS cannot be used    as registers in any case where register classes are examined,    it is most consistent to keep this function from accepting them.  */
end_comment

begin_function
name|int
name|register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* Before reload, we can allow (SUBREG (MEM...)) as a register operand 	 because it is guaranteed to be reloaded into one. 	 Just make sure the MEM is valid in itself. 	 (Ideally, (SUBREG (MEM)...) should not exist after reload, 	 but currently it does result from (SUBREG (REG)...) where the 	 reg went on the stack.)  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
ifdef|#
directive|ifdef
name|CLASS_CANNOT_CHANGE_MODE
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|CLASS_CANNOT_CHANGE_MODE
index|]
argument_list|,
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|CLASS_CANNOT_CHANGE_MODE_P
argument_list|(
name|mode
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MODE_COMPLEX_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MODE_COMPLEX_FLOAT
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* If we have an ADDRESSOF, consider it valid since it will be      converted into something that will not be a MEM.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
literal|1
return|;
comment|/* We don't consider registers whose class is NO_REGS      to be a register operand.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|NO_REGS
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 for a register in Pmode; ignore the tested mode.  */
end_comment

begin_function
name|int
name|pmode_register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|Pmode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP should match a MATCH_SCRATCH, i.e., if it is a SCRATCH    or a hard register.  */
end_comment

begin_function
name|int
name|scratch_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SCRATCH
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid immediate operand for mode MODE.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|immediate_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* Don't accept CONST_INT or anything similar      if the caller wants something floating.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|!=
name|INTVAL
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Accept CONSTANT_P_RTX, since it will be gone by CSE1 and      result in 0/1.  It seems a safe assumption that this is      in range for everyone.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is an operand that is a CONST_INT.  */
end_comment

begin_function
name|int
name|const_int_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|!=
name|INTVAL
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is an operand that is a constant integer or constant    floating-point number.  */
end_comment

begin_function
name|int
name|const_double_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* Don't accept CONST_INT or anything similar      if the caller wants something floating.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a general operand that is not an immediate operand.  */
end_comment

begin_function
name|int
name|nonimmediate_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register reference or immediate value of mode MODE.  */
end_comment

begin_function
name|int
name|nonmemory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
comment|/* Don't accept CONST_INT or anything similar 	 if the caller wants something floating.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|!=
name|INTVAL
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* Before reload, we can allow (SUBREG (MEM...)) as a register operand 	 because it is guaranteed to be reloaded into one. 	 Just make sure the MEM is valid in itself. 	 (Ideally, (SUBREG (MEM)...) should not exist after reload, 	 but currently it does result from (SUBREG (REG)...) where the 	 reg went on the stack.)  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* We don't consider registers whose class is NO_REGS      to be a register operand.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|NO_REGS
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand that stands for pushing a    value of mode MODE onto the stack.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|push_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|unsigned
name|int
name|rounded_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
name|rounded_size
operator|=
name|PUSH_ROUNDING
argument_list|(
name|rounded_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rounded_size
operator|==
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|STACK_PUSH_CODE
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|PRE_MODIFY
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
operator|-
operator|(
name|int
operator|)
name|rounded_size
else|#
directive|else
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|rounded_size
endif|#
directive|endif
condition|)
return|return
literal|0
return|;
block|}
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand that stands for popping a    value of mode MODE off the stack.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|pop_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|STACK_POP_CODE
condition|)
return|return
literal|0
return|;
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if ADDR is a valid memory address for mode MODE.  */
end_comment

begin_function
name|int
name|memory_address_p
parameter_list|(
name|mode
parameter_list|,
name|addr
parameter_list|)
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
literal|1
return|;
name|GO_IF_LEGITIMATE_ADDRESS
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|win
label|:
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid memory reference with mode MODE,    including a valid address.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|inner
decl_stmt|;
if|if
condition|(
operator|!
name|reload_completed
condition|)
comment|/* Note that no SUBREG is a memory operand before end of reload pass,        because (SUBREG (MEM...)) forces reloading into a register.  */
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|inner
operator|=
name|op
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|SUBREG
condition|)
name|inner
operator|=
name|SUBREG_REG
argument_list|(
name|inner
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|MEM
operator|&&
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid indirect memory reference with mode MODE;    that is, a memory reference whose address is a general_operand.  */
end_comment

begin_function
name|int
name|indirect_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* Before reload, a SUBREG isn't in memory (see memory_operand, above).  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|int
name|offset
init|=
name|SUBREG_BYTE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|rtx
name|inner
init|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
comment|/* The only way that we can have a general_operand as the resulting 	 address is if OFFSET is zero and the address already is an operand 	 or if the address is (plus Y (const_int -OFFSET)) and Y is an 	 operand.  */
return|return
operator|(
operator|(
name|offset
operator|==
literal|0
operator|&&
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
name|offset
operator|&&
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|)
operator|)
return|;
block|}
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a comparison operator.  This allows the use of    MATCH_OPERATOR to recognize all the branch insns.  */
end_comment

begin_function
name|int
name|comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If BODY is an insn body that uses ASM_OPERANDS,    return the number of operands (both input and output) in the insn.    Otherwise return -1.  */
end_comment

begin_function
name|int
name|asm_noperands
parameter_list|(
name|body
parameter_list|)
name|rtx
name|body
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
condition|)
block|{
case|case
name|ASM_OPERANDS
case|:
comment|/* No output operands: return number of input operands.  */
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|body
argument_list|)
return|;
case|case
name|SET
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
comment|/* Single output operand: BODY is (set OUTPUT (asm_operands ...)).  */
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|+
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|PARALLEL
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
comment|/* Multiple output operands, or 1 output plus some clobbers: 	     body is [(set OUTPUT (asm_operands ...))... (clobber (reg ...))...].  */
name|int
name|i
decl_stmt|;
name|int
name|n_sets
decl_stmt|;
comment|/* Count backwards through CLOBBERs to determine number of SETs.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* N_SETS is now number of output operands.  */
name|n_sets
operator|=
name|i
expr_stmt|;
comment|/* Verify that all the SETs we have 	     came from a single original asm_operands insn 	     (so that invalid combinations are blocked).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|ASM_OPERANDS
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If these ASM_OPERANDS rtx's came from different original insns 	         then they aren't allowed together.  */
if|if
condition|(
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|+
name|n_sets
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
comment|/* 0 outputs, but some clobbers: 	     body is [(asm_operands ...) (clobber (reg ...))...].  */
name|int
name|i
decl_stmt|;
comment|/* Make sure all the other parallel things really are clobbers.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Assuming BODY is an insn body that uses ASM_OPERANDS,    copy its operands (both input and output) into the vector OPERANDS,    the locations of the operands within the insn into the vector OPERAND_LOCS,    and the constraints for the operands into CONSTRAINTS.    Write the modes of the operands into MODES.    Return the assembler-template.     If MODES, OPERAND_LOCS, CONSTRAINTS or OPERANDS is 0,    we don't store that info.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|decode_asm_operands
parameter_list|(
name|body
parameter_list|,
name|operands
parameter_list|,
name|operand_locs
parameter_list|,
name|constraints
parameter_list|,
name|modes
parameter_list|)
name|rtx
name|body
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
name|rtx
modifier|*
modifier|*
name|operand_locs
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|constraints
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|modes
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|noperands
decl_stmt|;
specifier|const
name|char
modifier|*
name|template
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
name|rtx
name|asmop
init|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
decl_stmt|;
comment|/* Single output operand: BODY is (set OUTPUT (asm_operands ....)).  */
name|noperands
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|asmop
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_MODE
argument_list|(
name|asmop
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* The output is in the SET. 	 Its constraint is in the ASM_OPERANDS itself.  */
if|if
condition|(
name|operands
condition|)
name|operands
index|[
literal|0
index|]
operator|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
literal|0
index|]
operator|=
operator|&
name|SET_DEST
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
literal|0
index|]
operator|=
name|ASM_OPERANDS_OUTPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
literal|0
index|]
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
name|template
operator|=
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
name|rtx
name|asmop
init|=
name|body
decl_stmt|;
comment|/* No output operands: BODY is (asm_operands ....).  */
name|noperands
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
comment|/* The input operands are found in the 1st element vector.  */
comment|/* Constraints for inputs are in the 2nd element vector.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_MODE
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|template
operator|=
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
name|rtx
name|asmop
init|=
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|nparallel
init|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Includes CLOBBERs.  */
name|int
name|nin
init|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|asmop
argument_list|)
decl_stmt|;
name|int
name|nout
init|=
literal|0
decl_stmt|;
comment|/* Does not include CLOBBERs.  */
comment|/* At least one output, plus some CLOBBERs.  */
comment|/* The outputs are in the SETs. 	 Their constraints are in the ASM_OPERANDS itself.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparallel
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
break|break;
comment|/* Past last SET */
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|XSTR
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nout
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nin
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
operator|+
name|nout
index|]
operator|=
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
operator|+
name|nout
index|]
operator|=
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
operator|+
name|nout
index|]
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
operator|+
name|nout
index|]
operator|=
name|ASM_OPERANDS_INPUT_MODE
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|template
operator|=
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
comment|/* No outputs, but some CLOBBERs.  */
name|rtx
name|asmop
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|nin
init|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|asmop
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nin
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_MODE
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|template
operator|=
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
block|}
return|return
name|template
return|;
block|}
end_function

begin_comment
comment|/* Check if an asm_operand matches it's constraints.     Return> 0 if ok, = 0 if bad,< 0 if inconclusive.  */
end_comment

begin_function
name|int
name|asm_operand_ok
parameter_list|(
name|op
parameter_list|,
name|constraint
parameter_list|)
name|rtx
name|op
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|/* Use constrain_operands after reload.  */
if|if
condition|(
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|constraint
condition|)
block|{
name|char
name|c
init|=
operator|*
name|constraint
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
case|case
literal|'#'
case|:
case|case
literal|'&'
case|:
case|case
literal|','
case|:
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* For best results, our caller should have given us the 	     proper matching constraint, but we can't actually fail 	     the check if they didn't.  Indicate that results are 	     inconclusive.  */
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|constraint
argument_list|)
condition|)
name|constraint
operator|++
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|address_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'m'
case|:
case|case
literal|'V'
case|:
comment|/* non-offsettable */
if|if
condition|(
name|memory_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'o'
case|:
comment|/* offsettable */
if|if
condition|(
name|offsettable_nonstrict_memref_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'<'
case|:
comment|/* ??? Before flow, auto inc/dec insns are not supposed to exist, 	     excepting those that expand_call created.  Further, on some 	     machines which do not have generalized auto inc/dec, an inc/dec 	     is not a memory_operand.  	     Match any memory and hope things are resolved after reload.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_DEC
operator|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'E'
case|:
ifndef|#
directive|ifndef
name|REAL_ARITHMETIC
comment|/* Match any floating double constant, but only if 	     we can examine the bits of it reliably.  */
if|if
condition|(
operator|(
name|HOST_FLOAT_FORMAT
operator|!=
name|TARGET_FLOAT_FORMAT
operator|||
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|BITS_PER_WORD
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|!
name|flag_pretend_float
condition|)
break|break;
endif|#
directive|endif
comment|/* FALLTHRU */
case|case
literal|'F'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'G'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_LETTER_P
argument_list|(
name|op
argument_list|,
literal|'G'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_LETTER_P
argument_list|(
name|op
argument_list|,
literal|'H'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
break|break;
comment|/* FALLTHRU */
case|case
literal|'i'
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
endif|#
directive|endif
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'I'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'J'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'J'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'K'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'K'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'L'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'L'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'M'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'N'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'O'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'O'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'P'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'X'
case|:
return|return
literal|1
return|;
case|case
literal|'g'
case|:
if|if
condition|(
name|general_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
default|default:
comment|/* For all other letters, we first check for a register class, 	     otherwise it is an EXTRA_CONSTRAINT.  */
if|if
condition|(
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
operator|!=
name|NO_REGS
condition|)
block|{
case|case
literal|'r'
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|BLKmode
condition|)
break|break;
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
if|if
condition|(
name|EXTRA_CONSTRAINT
argument_list|(
name|op
argument_list|,
name|c
argument_list|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an rtx *P, if it is a sum containing an integer constant term,    return the location (type rtx *) of the pointer to that constant term.    Otherwise, return a null pointer.  */
end_comment

begin_function
name|rtx
modifier|*
name|find_constant_term_loc
parameter_list|(
name|p
parameter_list|)
name|rtx
modifier|*
name|p
decl_stmt|;
block|{
name|rtx
modifier|*
name|tem
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
comment|/* If *P IS such a constant term, P is its location.  */
if|if
condition|(
name|code
operator|==
name|CONST_INT
operator|||
name|code
operator|==
name|SYMBOL_REF
operator|||
name|code
operator|==
name|LABEL_REF
operator|||
name|code
operator|==
name|CONST
condition|)
return|return
name|p
return|;
comment|/* Otherwise, if not a sum, it has no constant term.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|p
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
literal|0
return|;
comment|/* If one of the summands is constant, return its location.  */
if|if
condition|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|p
return|;
comment|/* Otherwise, check each summand for containing a constant term.  */
if|if
condition|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|find_constant_term_loc
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
block|}
if|if
condition|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|find_constant_term_loc
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a memory reference    whose address contains no side effects    and remains valid after the addition    of a positive integer less than the    size of the object being referenced.     We assume that the original address is valid and do not check it.     This uses strict_memory_address_p as a subroutine, so    don't use it before reload.  */
end_comment

begin_function
name|int
name|offsettable_memref_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
name|offsettable_address_p
argument_list|(
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but don't require a strictly valid mem ref:    consider pseudo-regs valid as index or base regs.  */
end_comment

begin_function
name|int
name|offsettable_nonstrict_memref_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
name|offsettable_address_p
argument_list|(
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if Y is a memory address which contains no side effects    and would remain valid after the addition of a positive integer    less than the size of that mode.     We assume that the original address is valid and do not check it.    We do check that it is valid for narrower modes.     If STRICTP is nonzero, we require a strictly valid address,    for the sake of use in reload.c.  */
end_comment

begin_function
name|int
name|offsettable_address_p
parameter_list|(
name|strictp
parameter_list|,
name|mode
parameter_list|,
name|y
parameter_list|)
name|int
name|strictp
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|y
decl_stmt|;
block|{
name|enum
name|rtx_code
name|ycode
init|=
name|GET_CODE
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|rtx
name|z
decl_stmt|;
name|rtx
name|y1
init|=
name|y
decl_stmt|;
name|rtx
modifier|*
name|y2
decl_stmt|;
name|int
argument_list|(
argument|*addressp
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|)
argument_list|)
operator|=
operator|(
name|strictp
condition|?
name|strict_memory_address_p
else|:
name|memory_address_p
operator|)
expr_stmt|;
name|unsigned
name|int
name|mode_sz
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Adjusting an offsettable address involves changing to a narrower mode.      Make sure that's OK.  */
if|if
condition|(
name|mode_dependent_address_p
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* ??? How much offset does an offsettable BLKmode reference need?      Clearly that depends on the situation in which it's being used.      However, the current situation in which we test 0xffffffff is      less than ideal.  Caveat user.  */
if|if
condition|(
name|mode_sz
operator|==
literal|0
condition|)
name|mode_sz
operator|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* If the expression contains a constant term,      see if it remains valid when max possible offset is added.  */
if|if
condition|(
operator|(
name|ycode
operator|==
name|PLUS
operator|)
operator|&&
operator|(
name|y2
operator|=
name|find_constant_term_loc
argument_list|(
operator|&
name|y1
argument_list|)
operator|)
condition|)
block|{
name|int
name|good
decl_stmt|;
name|y1
operator|=
operator|*
name|y2
expr_stmt|;
operator|*
name|y2
operator|=
name|plus_constant
argument_list|(
operator|*
name|y2
argument_list|,
name|mode_sz
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Use QImode because an odd displacement may be automatically invalid 	 for any wider mode.  But it should be valid for a single byte.  */
name|good
operator|=
call|(
modifier|*
name|addressp
call|)
argument_list|(
name|QImode
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* In any case, restore old contents of memory.  */
operator|*
name|y2
operator|=
name|y1
expr_stmt|;
return|return
name|good
return|;
block|}
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|ycode
argument_list|)
operator|==
literal|'a'
condition|)
return|return
literal|0
return|;
comment|/* The offset added here is chosen as the maximum offset that      any instruction could need to add when operating on something      of the specified mode.  We assume that if Y and Y+c are      valid addresses then so is Y+d for all 0<d<c.  adjust_address will      go inside a LO_SUM here, so we do so as well.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|LO_SUM
condition|)
name|z
operator|=
name|gen_rtx_LO_SUM
argument_list|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode_sz
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|z
operator|=
name|plus_constant
argument_list|(
name|y
argument_list|,
name|mode_sz
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Use QImode because an odd displacement may be automatically invalid      for any wider mode.  But it should be valid for a single byte.  */
return|return
call|(
modifier|*
name|addressp
call|)
argument_list|(
name|QImode
argument_list|,
name|z
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if ADDR is an address-expression whose effect depends    on the mode of the memory reference it is used in.     Autoincrement addressing is a typical example of mode-dependence    because the amount of the increment depends on the mode.  */
end_comment

begin_function
name|int
name|mode_dependent_address_p
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
name|ATTRIBUTE_UNUSED
decl_stmt|;
comment|/* Maybe used in GO_IF_MODE_DEPENDENT_ADDRESS.  */
block|{
name|GO_IF_MODE_DEPENDENT_ADDRESS
argument_list|(
name|addr
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Label `win' might (not) be used via GO_IF_MODE_DEPENDENT_ADDRESS.  */
name|win
label|:
name|ATTRIBUTE_UNUSED_LABEL
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a general operand    other than a memory ref with a mode dependent address.  */
end_comment

begin_function
name|int
name|mode_independent_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|1
return|;
name|addr
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GO_IF_MODE_DEPENDENT_ADDRESS
argument_list|(
name|addr
argument_list|,
name|lose
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* Label `lose' might (not) be used via GO_IF_MODE_DEPENDENT_ADDRESS.  */
name|lose
label|:
name|ATTRIBUTE_UNUSED_LABEL
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like extract_insn, but save insn extracted and don't extract again, when    called again for the same insn expecting that recog_data still contain the    valid information.  This is used primary by gen_attr infrastructure that    often does extract insn again and again.  */
end_comment

begin_function
name|void
name|extract_insn_cached
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|recog_data
operator|.
name|insn
operator|==
name|insn
operator|&&
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|recog_data
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do cached extract_insn, constrain_operand and complain about failures.    Used by insn_attrtab.  */
end_comment

begin_function
name|void
name|extract_constrain_insn_cached
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|extract_insn_cached
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|which_alternative
operator|==
operator|-
literal|1
operator|&&
operator|!
name|constrain_operands
argument_list|(
name|reload_completed
argument_list|)
condition|)
name|fatal_insn_not_found
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do cached constrain_operand and complain about failures.  */
end_comment

begin_function
name|int
name|constrain_operands_cached
parameter_list|(
name|strict
parameter_list|)
name|int
name|strict
decl_stmt|;
block|{
if|if
condition|(
name|which_alternative
operator|==
operator|-
literal|1
condition|)
return|return
name|constrain_operands
argument_list|(
name|strict
argument_list|)
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Analyze INSN and fill in recog_data.  */
end_comment

begin_function
name|void
name|extract_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|icode
decl_stmt|;
name|int
name|noperands
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|recog_data
operator|.
name|insn
operator|=
name|NULL
expr_stmt|;
name|recog_data
operator|.
name|n_operands
operator|=
literal|0
expr_stmt|;
name|recog_data
operator|.
name|n_alternatives
operator|=
literal|0
expr_stmt|;
name|recog_data
operator|.
name|n_dups
operator|=
literal|0
expr_stmt|;
name|which_alternative
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
condition|)
block|{
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return;
case|case
name|SET
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
goto|goto
name|asm_insn
goto|;
else|else
goto|goto
name|normal_insn
goto|;
case|case
name|PARALLEL
case|:
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
operator|)
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
goto|goto
name|asm_insn
goto|;
else|else
goto|goto
name|normal_insn
goto|;
case|case
name|ASM_OPERANDS
case|:
name|asm_insn
label|:
name|recog_data
operator|.
name|n_operands
operator|=
name|noperands
operator|=
name|asm_noperands
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|noperands
operator|>=
literal|0
condition|)
block|{
comment|/* This insn is an `asm' with operands.  */
comment|/* expand_asm_operands makes sure there aren't too many operands.  */
if|if
condition|(
name|noperands
operator|>
name|MAX_RECOG_OPERANDS
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Now get the operand values and constraints out of the insn.  */
name|decode_asm_operands
argument_list|(
name|body
argument_list|,
name|recog_data
operator|.
name|operand
argument_list|,
name|recog_data
operator|.
name|operand_loc
argument_list|,
name|recog_data
operator|.
name|constraints
argument_list|,
name|recog_data
operator|.
name|operand_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|noperands
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|recog_data
operator|.
name|constraints
index|[
literal|0
index|]
decl_stmt|;
name|recog_data
operator|.
name|n_alternatives
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|recog_data
operator|.
name|n_alternatives
operator|+=
operator|(
operator|*
name|p
operator|++
operator|==
literal|','
operator|)
expr_stmt|;
block|}
break|break;
block|}
name|fatal_insn_not_found
argument_list|(
name|insn
argument_list|)
expr_stmt|;
default|default:
name|normal_insn
label|:
comment|/* Ordinary insn: recognize it, get the operands via insn_extract 	 and get the constraints.  */
name|icode
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|icode
operator|<
literal|0
condition|)
name|fatal_insn_not_found
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|recog_data
operator|.
name|n_operands
operator|=
name|noperands
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|n_operands
expr_stmt|;
name|recog_data
operator|.
name|n_alternatives
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|n_alternatives
expr_stmt|;
name|recog_data
operator|.
name|n_dups
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|n_dups
expr_stmt|;
name|insn_extract
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
name|recog_data
operator|.
name|constraints
index|[
name|i
index|]
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|i
index|]
operator|.
name|constraint
expr_stmt|;
name|recog_data
operator|.
name|operand_mode
index|[
name|i
index|]
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|i
index|]
operator|.
name|mode
expr_stmt|;
comment|/* VOIDmode match_operands gets mode from their real operand.  */
if|if
condition|(
name|recog_data
operator|.
name|operand_mode
index|[
name|i
index|]
operator|==
name|VOIDmode
condition|)
name|recog_data
operator|.
name|operand_mode
index|[
name|i
index|]
operator|=
name|GET_MODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|=
operator|(
name|recog_data
operator|.
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'='
condition|?
name|OP_OUT
else|:
name|recog_data
operator|.
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|?
name|OP_INOUT
else|:
name|OP_IN
operator|)
expr_stmt|;
if|if
condition|(
name|recog_data
operator|.
name|n_alternatives
operator|>
name|MAX_RECOG_ALTERNATIVES
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After calling extract_insn, you can use this function to extract some    information from the constraint strings into a more usable form.    The collected data is stored in recog_op_alt.  */
end_comment

begin_function
name|void
name|preprocess_constraints
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|recog_op_alt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|recog_op_alt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|struct
name|operand_alternative
modifier|*
name|op_alt
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|recog_data
operator|.
name|constraints
index|[
name|i
index|]
decl_stmt|;
name|op_alt
operator|=
name|recog_op_alt
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|recog_data
operator|.
name|n_alternatives
condition|;
name|j
operator|++
control|)
block|{
name|op_alt
index|[
name|j
index|]
operator|.
name|class
operator|=
name|NO_REGS
expr_stmt|;
name|op_alt
index|[
name|j
index|]
operator|.
name|constraint
operator|=
name|p
expr_stmt|;
name|op_alt
index|[
name|j
index|]
operator|.
name|matches
operator|=
operator|-
literal|1
expr_stmt|;
name|op_alt
index|[
name|j
index|]
operator|.
name|matched
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
block|{
name|op_alt
index|[
name|j
index|]
operator|.
name|anything_ok
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
do|do
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
do|while
condition|(
name|c
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
do|;
if|if
condition|(
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|'\0'
condition|)
break|break;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
comment|/* These don't say anything we care about.  */
break|break;
case|case
literal|'?'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|reject
operator|+=
literal|6
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|reject
operator|+=
literal|600
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|earlyclobber
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|op_alt
index|[
name|j
index|]
operator|.
name|matches
operator|=
name|strtoul
argument_list|(
name|p
operator|-
literal|1
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|recog_op_alt
index|[
name|op_alt
index|[
name|j
index|]
operator|.
name|matches
index|]
index|[
name|j
index|]
operator|.
name|matched
operator|=
name|i
expr_stmt|;
name|p
operator|=
name|end
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|memory_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|decmem_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|incmem_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|nonoffmem_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|offmem_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|anything_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|is_address
operator|=
literal|1
expr_stmt|;
name|op_alt
index|[
name|j
index|]
operator|.
name|class
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|op_alt
index|[
name|j
index|]
operator|.
name|class
index|]
index|[
operator|(
name|int
operator|)
name|MODE_BASE_REG_CLASS
argument_list|(
name|VOIDmode
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'r'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|class
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|op_alt
index|[
name|j
index|]
operator|.
name|class
index|]
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
expr_stmt|;
break|break;
default|default:
name|op_alt
index|[
name|j
index|]
operator|.
name|class
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|op_alt
index|[
name|j
index|]
operator|.
name|class
index|]
index|[
operator|(
name|int
operator|)
name|REG_CLASS_FROM_LETTER
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check the operands of an insn against the insn's operand constraints    and return 1 if they are valid.    The information about the insn's operands, constraints, operand modes    etc. is obtained from the global variables set up by extract_insn.     WHICH_ALTERNATIVE is set to a number which indicates which    alternative of constraints was matched: 0 for the first alternative,    1 for the next, etc.     In addition, when two operands are match    and it happens that the output operand is (reg) while the    input operand is --(reg) or ++(reg) (a pre-inc or pre-dec),    make the output operand look like the input.    This is because the output operand is the one the template will print.     This is used in final, just before printing the assembler code and by    the routines that determine an insn's attribute.     If STRICT is a positive non-zero value, it means that we have been    called after reload has been completed.  In that case, we must    do all checks strictly.  If it is zero, it means that we have been called    before reload has completed.  In that case, we first try to see if we can    find an alternative that matches strictly.  If not, we try again, this    time assuming that reload will fix up the insn.  This provides a "best    guess" for the alternative and is used to compute attributes of insns prior    to reload.  A negative value of STRICT is used for this internal call.  */
end_comment

begin_struct
struct|struct
name|funny_match
block|{
name|int
name|this
decl_stmt|,
name|other
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|constrain_operands
parameter_list|(
name|strict
parameter_list|)
name|int
name|strict
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|constraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|matching_operands
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|earlyclobber
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|funny_match
name|funny_match
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|funny_match_index
decl_stmt|;
name|which_alternative
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|recog_data
operator|.
name|n_operands
operator|==
literal|0
operator|||
name|recog_data
operator|.
name|n_alternatives
operator|==
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|c
operator|++
control|)
block|{
name|constraints
index|[
name|c
index|]
operator|=
name|recog_data
operator|.
name|constraints
index|[
name|c
index|]
expr_stmt|;
name|matching_operands
index|[
name|c
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
do|do
block|{
name|int
name|opno
decl_stmt|;
name|int
name|lose
init|=
literal|0
decl_stmt|;
name|funny_match_index
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|opno
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|opno
operator|++
control|)
block|{
name|rtx
name|op
init|=
name|recog_data
operator|.
name|operand
index|[
name|opno
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|constraints
index|[
name|opno
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|win
init|=
literal|0
decl_stmt|;
name|int
name|val
decl_stmt|;
name|earlyclobber
index|[
name|opno
index|]
operator|=
literal|0
expr_stmt|;
comment|/* A unary operator may be accepted by the predicate, but it 	     is irrelevant for matching constraints.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
literal|'1'
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|offset
operator|=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|op
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* An empty constraint or empty alternative 	     allows anything which matched the pattern.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|win
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|','
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
break|break;
case|case
literal|'#'
case|:
comment|/* Ignore rest of this alternative as far as 		   constraint checking is concerned.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|earlyclobber
index|[
name|opno
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
comment|/* This operand must be the same as a previous one. 		     This kind of constraint is used for instructions such 		     as add when they take only two operands.  		     Note that the lower-numbered operand is passed first.  		     If we are not testing strictly, assume that this 		     constraint will be satisfied.  */
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|match
decl_stmt|;
name|match
operator|=
name|strtoul
argument_list|(
name|p
operator|-
literal|1
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|=
name|end
expr_stmt|;
if|if
condition|(
name|strict
operator|<
literal|0
condition|)
name|val
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|rtx
name|op1
init|=
name|recog_data
operator|.
name|operand
index|[
name|match
index|]
decl_stmt|;
name|rtx
name|op2
init|=
name|recog_data
operator|.
name|operand
index|[
name|opno
index|]
decl_stmt|;
comment|/* A unary operator may be accepted by the predicate, 			 but it is irrelevant for matching constraints.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|==
literal|'1'
condition|)
name|op1
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
argument_list|)
operator|==
literal|'1'
condition|)
name|op2
operator|=
name|XEXP
argument_list|(
name|op2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|operands_match_p
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
block|}
name|matching_operands
index|[
name|opno
index|]
operator|=
name|match
expr_stmt|;
name|matching_operands
index|[
name|match
index|]
operator|=
name|opno
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|win
operator|=
literal|1
expr_stmt|;
comment|/* If output is *x and input is *--x, arrange later 		     to change the output to *--x as well, since the 		     output op is the one that will be printed.  */
if|if
condition|(
name|val
operator|==
literal|2
operator|&&
name|strict
operator|>
literal|0
condition|)
block|{
name|funny_match
index|[
name|funny_match_index
index|]
operator|.
name|this
operator|=
name|opno
expr_stmt|;
name|funny_match
index|[
name|funny_match_index
operator|++
index|]
operator|.
name|other
operator|=
name|match
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'p'
case|:
comment|/* p is used for address_operands.  When we are called by 		   gen_reload, no one will have checked that the address is 		   strictly valid, i.e., that all pseudos requiring hard regs 		   have gotten them.  */
if|if
condition|(
name|strict
operator|<=
literal|0
operator|||
operator|(
name|strict_memory_address_p
argument_list|(
name|recog_data
operator|.
name|operand_mode
index|[
name|opno
index|]
argument_list|,
name|op
argument_list|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* No need to check general_operand again; 		   it was done in insn-recog.c.  */
case|case
literal|'g'
case|:
comment|/* Anything goes unless it is a REG and really has a hard reg 		   but the hard reg is not in the class GENERAL_REGS.  */
if|if
condition|(
name|strict
operator|<
literal|0
operator|||
name|GENERAL_REGS
operator|==
name|ALL_REGS
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|reload_in_progress
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|reg_fits_class_p
argument_list|(
name|op
argument_list|,
name|GENERAL_REGS
argument_list|,
name|offset
argument_list|,
name|mode
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* This is used for a MATCH_SCRATCH in the cases when 		   we don't actually need anything.  So anything goes 		   any time.  */
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
comment|/* Before reload, accept what reload can turn into mem.  */
operator|||
operator|(
name|strict
operator|<
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
comment|/* During reload, accept a pseudo  */
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_DEC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
ifndef|#
directive|ifndef
name|REAL_ARITHMETIC
comment|/* Match any CONST_DOUBLE, but only if 		   we can examine the bits of it reliably.  */
if|if
condition|(
operator|(
name|HOST_FLOAT_FORMAT
operator|!=
name|TARGET_FLOAT_FORMAT
operator|||
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|BITS_PER_WORD
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|!
name|flag_pretend_float
condition|)
break|break;
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_LETTER_P
argument_list|(
name|op
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
operator|(
name|strict
operator|>
literal|0
operator|&&
operator|!
name|offsettable_memref_p
argument_list|(
name|op
argument_list|)
operator|)
operator|||
operator|(
name|strict
operator|<
literal|0
operator|&&
operator|!
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|)
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
operator|(
name|strict
operator|>
literal|0
operator|&&
name|offsettable_memref_p
argument_list|(
name|op
argument_list|)
operator|)
operator|||
operator|(
name|strict
operator|==
literal|0
operator|&&
name|offsettable_nonstrict_memref_p
argument_list|(
name|op
argument_list|)
operator|)
comment|/* Before reload, accept what reload can handle.  */
operator|||
operator|(
name|strict
operator|<
literal|0
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|)
operator|)
comment|/* During reload, accept a pseudo  */
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
block|{
name|enum
name|reg_class
name|class
decl_stmt|;
name|class
operator|=
operator|(
name|c
operator|==
literal|'r'
condition|?
name|GENERAL_REGS
else|:
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|NO_REGS
condition|)
block|{
if|if
condition|(
name|strict
operator|<
literal|0
operator|||
operator|(
name|strict
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|strict
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SCRATCH
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|reg_fits_class_p
argument_list|(
name|op
argument_list|,
name|class
argument_list|,
name|offset
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
elseif|else
if|if
condition|(
name|EXTRA_CONSTRAINT
argument_list|(
name|op
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
name|constraints
index|[
name|opno
index|]
operator|=
name|p
expr_stmt|;
comment|/* If this operand did not win somehow, 	     this alternative loses.  */
if|if
condition|(
operator|!
name|win
condition|)
name|lose
operator|=
literal|1
expr_stmt|;
block|}
comment|/* This alternative won; the operands are ok. 	 Change whichever operands this alternative says to change.  */
if|if
condition|(
operator|!
name|lose
condition|)
block|{
name|int
name|opno
decl_stmt|,
name|eopno
decl_stmt|;
comment|/* See if any earlyclobber operand conflicts with some other 	     operand.  */
if|if
condition|(
name|strict
operator|>
literal|0
condition|)
for|for
control|(
name|eopno
operator|=
literal|0
init|;
name|eopno
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|eopno
operator|++
control|)
comment|/* Ignore earlyclobber operands now in memory, 		 because we would often report failure when we have 		 two memory operands, one of which was formerly a REG.  */
if|if
condition|(
name|earlyclobber
index|[
name|eopno
index|]
operator|&&
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|eopno
index|]
argument_list|)
operator|==
name|REG
condition|)
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|opno
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|opno
operator|++
control|)
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|opno
index|]
argument_list|)
operator|==
name|MEM
operator|||
name|recog_data
operator|.
name|operand_type
index|[
name|opno
index|]
operator|!=
name|OP_OUT
operator|)
operator|&&
name|opno
operator|!=
name|eopno
comment|/* Ignore things like match_operator operands.  */
operator|&&
operator|*
name|recog_data
operator|.
name|constraints
index|[
name|opno
index|]
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|matching_operands
index|[
name|opno
index|]
operator|==
name|eopno
operator|&&
name|operands_match_p
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|opno
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|eopno
index|]
argument_list|)
operator|)
operator|&&
operator|!
name|safe_from_earlyclobber
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|opno
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|eopno
index|]
argument_list|)
condition|)
name|lose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|lose
condition|)
block|{
while|while
condition|(
operator|--
name|funny_match_index
operator|>=
literal|0
condition|)
block|{
name|recog_data
operator|.
name|operand
index|[
name|funny_match
index|[
name|funny_match_index
index|]
operator|.
name|other
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
name|funny_match
index|[
name|funny_match_index
index|]
operator|.
name|this
index|]
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
name|which_alternative
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|which_alternative
operator|<
name|recog_data
operator|.
name|n_alternatives
condition|)
do|;
name|which_alternative
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If we are about to reject this, but we are not to test strictly,      try a very loose test.  Only return failure if it fails also.  */
if|if
condition|(
name|strict
operator|==
literal|0
condition|)
return|return
name|constrain_operands
argument_list|(
operator|-
literal|1
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 iff OPERAND (assumed to be a REG rtx)    is a hard reg in class CLASS when its regno is offset by OFFSET    and changed to mode MODE.    If REG occupies multiple hard regs, all of them must be in CLASS.  */
end_comment

begin_function
name|int
name|reg_fits_class_p
parameter_list|(
name|operand
parameter_list|,
name|class
parameter_list|,
name|offset
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|operand
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
operator|+
name|offset
argument_list|)
condition|)
block|{
name|int
name|sr
decl_stmt|;
name|regno
operator|+=
name|offset
expr_stmt|;
for|for
control|(
name|sr
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|-
literal|1
init|;
name|sr
operator|>
literal|0
condition|;
name|sr
operator|--
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
operator|+
name|sr
argument_list|)
condition|)
break|break;
return|return
name|sr
operator|==
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split single instruction.  Helper function for split_all_insns.    Return last insn in the sequence if successful, or NULL if unsuccessful.  */
end_comment

begin_function
specifier|static
name|rtx
name|split_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|set
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
empty_stmt|;
comment|/* Don't split no-op move insns.  These should silently      disappear later in final.  Splitting such insns would      break the code that handles REG_NO_CONFLICT blocks.  */
elseif|else
if|if
condition|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|set_noop_p
argument_list|(
name|set
argument_list|)
condition|)
block|{
comment|/* Nops get in the way while scheduling, so delete them          now if register allocation has already been done.  It          is too risky to try to do this before register          allocation, and there are unlikely to be very many          nops then anyways.  */
if|if
condition|(
name|reload_completed
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Split insns here to get max fine-grain parallelism.  */
name|rtx
name|first
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|last
init|=
name|try_split
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|last
operator|!=
name|insn
condition|)
block|{
comment|/* try_split returns the NOTE that INSN became.  */
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
comment|/* ??? Coddle to md files that generate subregs in post- 	     reload splitters instead of computing the proper  	     hard register.  */
if|if
condition|(
name|reload_completed
operator|&&
name|first
operator|!=
name|last
condition|)
block|{
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|first
argument_list|)
condition|)
name|cleanup_subreg_operands
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|last
condition|)
break|break;
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|last
return|;
block|}
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Split all insns in the function.  If UPD_LIFE, update life info after.  */
end_comment

begin_function
name|void
name|split_all_insns
parameter_list|(
name|upd_life
parameter_list|)
name|int
name|upd_life
decl_stmt|;
block|{
name|sbitmap
name|blocks
decl_stmt|;
name|int
name|changed
decl_stmt|;
name|int
name|i
decl_stmt|;
name|blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|head
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|rtx
name|last
decl_stmt|;
comment|/* Can't use `next_real_insn' because that might go across 	     CODE_LABELS and short-out basic blocks.  */
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|last
operator|=
name|split_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
block|{
comment|/* The split sequence may include barrier, but the 		 BB boundary we are interested in will be set to previous 		 one.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|BARRIER
condition|)
name|last
operator|=
name|PREV_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|last
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|end
condition|)
break|break;
block|}
if|if
condition|(
name|insn
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|changed
condition|)
block|{
name|find_many_sub_basic_blocks
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changed
operator|&&
name|upd_life
condition|)
block|{
name|count_or_remove_death_notes
argument_list|(
name|blocks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|update_life_info
argument_list|(
name|blocks
argument_list|,
name|UPDATE_LIFE_LOCAL
argument_list|,
name|PROP_DEATH_NOTES
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sbitmap_free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as split_all_insns, but do not expect CFG to be available.     Used by machine depedent reorg passes.  */
end_comment

begin_function
name|void
name|split_all_insns_noflow
parameter_list|()
block|{
name|rtx
name|next
decl_stmt|,
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|split_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_peephole2
end_ifdef

begin_struct
struct|struct
name|peep2_insn_data
block|{
name|rtx
name|insn
decl_stmt|;
name|regset
name|live_before
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|peep2_insn_data
name|peep2_insn_data
index|[
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|peep2_current
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A non-insn marker indicating the last insn of the block.    The live_before regset for this element is correct, indicating    global_live_at_end for the block.  */
end_comment

begin_define
define|#
directive|define
name|PEEP2_EOB
value|pc_rtx
end_define

begin_comment
comment|/* Return the Nth non-note insn after `current', or return NULL_RTX if it    does not exist.  Used by the recognizer to find the next insn to match    in a multi-insn pattern.  */
end_comment

begin_function
name|rtx
name|peep2_next_insn
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|n
operator|+=
name|peep2_current
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|n
operator|-=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|peep2_insn_data
index|[
name|n
index|]
operator|.
name|insn
operator|==
name|PEEP2_EOB
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|peep2_insn_data
index|[
name|n
index|]
operator|.
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return true if REGNO is dead before the Nth non-note insn    after `current'.  */
end_comment

begin_function
name|int
name|peep2_regno_dead_p
parameter_list|(
name|ofs
parameter_list|,
name|regno
parameter_list|)
name|int
name|ofs
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|ofs
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ofs
operator|+=
name|peep2_current
expr_stmt|;
if|if
condition|(
name|ofs
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|ofs
operator|-=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|peep2_insn_data
index|[
name|ofs
index|]
operator|.
name|insn
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|peep2_insn_data
index|[
name|ofs
index|]
operator|.
name|live_before
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similarly for a REG.  */
end_comment

begin_function
name|int
name|peep2_reg_dead_p
parameter_list|(
name|ofs
parameter_list|,
name|reg
parameter_list|)
name|int
name|ofs
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|ofs
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ofs
operator|+=
name|peep2_current
expr_stmt|;
if|if
condition|(
name|ofs
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|ofs
operator|-=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|peep2_insn_data
index|[
name|ofs
index|]
operator|.
name|insn
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|n
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|peep2_insn_data
index|[
name|ofs
index|]
operator|.
name|live_before
argument_list|,
name|regno
operator|+
name|n
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Try to find a hard register of mode MODE, matching the register class in    CLASS_STR, which is available at the beginning of insn CURRENT_INSN and    remains available until the end of LAST_INSN.  LAST_INSN may be NULL_RTX,    in which case the only condition is that the register must be available    before CURRENT_INSN.    Registers that already have bits set in REG_SET will not be considered.     If an appropriate register is available, it will be returned and the    corresponding bit(s) in REG_SET will be set; otherwise, NULL_RTX is    returned.  */
end_comment

begin_function
name|rtx
name|peep2_find_free_register
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|class_str
parameter_list|,
name|mode
parameter_list|,
name|reg_set
parameter_list|)
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
specifier|const
name|char
modifier|*
name|class_str
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HARD_REG_SET
modifier|*
name|reg_set
decl_stmt|;
block|{
specifier|static
name|int
name|search_ofs
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|HARD_REG_SET
name|live
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|from
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
operator|||
name|to
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|from
operator|+=
name|peep2_current
expr_stmt|;
if|if
condition|(
name|from
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|from
operator|-=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
expr_stmt|;
name|to
operator|+=
name|peep2_current
expr_stmt|;
if|if
condition|(
name|to
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|to
operator|-=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|peep2_insn_data
index|[
name|from
index|]
operator|.
name|insn
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|live
argument_list|,
name|peep2_insn_data
index|[
name|from
index|]
operator|.
name|live_before
argument_list|)
expr_stmt|;
while|while
condition|(
name|from
operator|!=
name|to
condition|)
block|{
name|HARD_REG_SET
name|this_live
decl_stmt|;
if|if
condition|(
operator|++
name|from
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|from
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|peep2_insn_data
index|[
name|from
index|]
operator|.
name|insn
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|this_live
argument_list|,
name|peep2_insn_data
index|[
name|from
index|]
operator|.
name|live_before
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|live
argument_list|,
name|this_live
argument_list|)
expr_stmt|;
block|}
name|class
operator|=
operator|(
name|class_str
index|[
literal|0
index|]
operator|==
literal|'r'
condition|?
name|GENERAL_REGS
else|:
name|REG_CLASS_FROM_LETTER
argument_list|(
name|class_str
index|[
literal|0
index|]
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|int
name|raw_regno
decl_stmt|,
name|regno
decl_stmt|,
name|success
decl_stmt|,
name|j
decl_stmt|;
comment|/* Distribute the free registers as much as possible.  */
name|raw_regno
operator|=
name|search_ofs
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|raw_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|raw_regno
operator|-=
name|FIRST_PSEUDO_REGISTER
expr_stmt|;
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
name|regno
operator|=
name|reg_alloc_order
index|[
name|raw_regno
index|]
expr_stmt|;
else|#
directive|else
name|regno
operator|=
name|raw_regno
expr_stmt|;
endif|#
directive|endif
comment|/* Don't allocate fixed registers.  */
if|if
condition|(
name|fixed_regs
index|[
name|regno
index|]
condition|)
continue|continue;
comment|/* Make sure the register is of the right class.  */
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|regno
argument_list|)
condition|)
continue|continue;
comment|/* And can support the mode we need.  */
if|if
condition|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
continue|continue;
comment|/* And that we don't create an extra save/restore.  */
if|if
condition|(
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|regs_ever_live
index|[
name|regno
index|]
condition|)
continue|continue;
comment|/* And we don't clobber traceback for noreturn functions.  */
if|if
condition|(
operator|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|)
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
condition|)
continue|continue;
name|success
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
operator|*
name|reg_set
argument_list|,
name|regno
operator|+
name|j
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|live
argument_list|,
name|regno
operator|+
name|j
argument_list|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|success
condition|)
block|{
for|for
control|(
name|j
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|SET_HARD_REG_BIT
argument_list|(
operator|*
name|reg_set
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
comment|/* Start the next search with the next register.  */
if|if
condition|(
operator|++
name|raw_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|raw_regno
operator|=
literal|0
expr_stmt|;
name|search_ofs
operator|=
name|raw_regno
expr_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
block|}
block|}
name|search_ofs
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Perform the peephole2 optimization pass.  */
end_comment

begin_function
name|void
name|peephole2_optimize
parameter_list|(
name|dump_file
parameter_list|)
name|FILE
modifier|*
name|dump_file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|regset_head
name|rs_heads
index|[
name|MAX_INSNS_PER_PEEP2
operator|+
literal|2
index|]
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|prev
decl_stmt|;
name|regset
name|live
decl_stmt|;
name|int
name|i
decl_stmt|,
name|b
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
name|sbitmap
name|blocks
decl_stmt|;
name|int
name|changed
decl_stmt|;
endif|#
directive|endif
comment|/* Initialize the regsets we're going to use.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|;
operator|++
name|i
control|)
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|live_before
operator|=
name|INITIALIZE_REG_SET
argument_list|(
name|rs_heads
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|live
operator|=
name|INITIALIZE_REG_SET
argument_list|(
name|rs_heads
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
name|blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|count_or_remove_death_notes
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|b
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|b
operator|>=
literal|0
condition|;
operator|--
name|b
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|struct
name|propagate_block_info
modifier|*
name|pbi
decl_stmt|;
comment|/* Indicate that all slots except the last holds invalid data.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_INSNS_PER_PEEP2
condition|;
operator|++
name|i
control|)
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|insn
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Indicate that the last slot contains live_after data.  */
name|peep2_insn_data
index|[
name|MAX_INSNS_PER_PEEP2
index|]
operator|.
name|insn
operator|=
name|PEEP2_EOB
expr_stmt|;
name|peep2_current
operator|=
name|MAX_INSNS_PER_PEEP2
expr_stmt|;
comment|/* Start up propagation.  */
name|COPY_REG_SET
argument_list|(
name|live
argument_list|,
name|bb
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|peep2_insn_data
index|[
name|MAX_INSNS_PER_PEEP2
index|]
operator|.
name|live_before
argument_list|,
name|live
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
name|pbi
operator|=
name|init_propagate_block_info
argument_list|(
name|bb
argument_list|,
name|live
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|pbi
operator|=
name|init_propagate_block_info
argument_list|(
name|bb
argument_list|,
name|live
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|PROP_DEATH_NOTES
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|end
init|;
condition|;
name|insn
operator|=
name|prev
control|)
block|{
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|try
decl_stmt|;
name|int
name|match_len
decl_stmt|;
comment|/* Record this insn.  */
if|if
condition|(
operator|--
name|peep2_current
operator|<
literal|0
condition|)
name|peep2_current
operator|=
name|MAX_INSNS_PER_PEEP2
expr_stmt|;
name|peep2_insn_data
index|[
name|peep2_current
index|]
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|propagate_one_insn
argument_list|(
name|pbi
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|peep2_insn_data
index|[
name|peep2_current
index|]
operator|.
name|live_before
argument_list|,
name|live
argument_list|)
expr_stmt|;
comment|/* Match the peephole.  */
name|try
operator|=
name|peephole2_insns
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
operator|&
name|match_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|try
operator|!=
name|NULL
condition|)
block|{
comment|/* If we are splitting a CALL_INSN, look for the CALL_INSN 		     in SEQ and copy our CALL_INSN_FUNCTION_USAGE and other 		     cfg-related call notes.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|match_len
condition|;
operator|++
name|i
control|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|rtx
name|old_insn
decl_stmt|,
name|new_insn
decl_stmt|,
name|note
decl_stmt|;
name|j
operator|=
name|i
operator|+
name|peep2_current
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|j
operator|-=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
expr_stmt|;
name|old_insn
operator|=
name|peep2_insn_data
index|[
name|j
index|]
operator|.
name|insn
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|old_insn
argument_list|)
operator|!=
name|CALL_INSN
condition|)
continue|continue;
name|new_insn
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|try
argument_list|)
operator|==
name|SEQUENCE
condition|)
for|for
control|(
name|k
operator|=
name|XVECLEN
argument_list|(
name|try
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|k
operator|>=
literal|0
condition|;
name|k
operator|--
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|try
argument_list|,
literal|0
argument_list|,
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|new_insn
operator|=
name|x
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|try
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|new_insn
operator|=
name|try
expr_stmt|;
if|if
condition|(
operator|!
name|new_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|new_insn
argument_list|)
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|old_insn
argument_list|)
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|old_insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
switch|switch
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
condition|)
block|{
case|case
name|REG_EH_REGION
case|:
case|case
name|REG_NORETURN
case|:
case|case
name|REG_SETJMP
case|:
case|case
name|REG_ALWAYS_RETURN
case|:
name|REG_NOTES
argument_list|(
name|new_insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|new_insn
argument_list|)
argument_list|)
expr_stmt|;
default|default:
comment|/* Discard all other reg notes.  */
break|break;
block|}
comment|/* Croak if there is another call in the sequence.  */
while|while
condition|(
operator|++
name|i
operator|<=
name|match_len
condition|)
block|{
name|j
operator|=
name|i
operator|+
name|peep2_current
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|j
operator|-=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
expr_stmt|;
name|old_insn
operator|=
name|peep2_insn_data
index|[
name|j
index|]
operator|.
name|insn
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|old_insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
name|i
operator|=
name|match_len
operator|+
name|peep2_current
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|i
operator|-=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
expr_stmt|;
comment|/* Replace the old sequence with the new.  */
name|try
operator|=
name|emit_insn_after
argument_list|(
name|try
argument_list|,
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|insn
argument_list|)
expr_stmt|;
name|delete_insn_chain
argument_list|(
name|insn
argument_list|,
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
comment|/* With conditional execution, we cannot back up the 		     live information so easily, since the conditional 		     death data structures are not so self-contained. 		     So record that we've made a modification to this 		     block and update life information at the end.  */
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|;
operator|++
name|i
control|)
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|insn
operator|=
name|NULL_RTX
expr_stmt|;
name|peep2_insn_data
index|[
name|peep2_current
index|]
operator|.
name|insn
operator|=
name|PEEP2_EOB
expr_stmt|;
else|#
directive|else
comment|/* Back up lifetime information past the end of the 		     newly created sequence.  */
if|if
condition|(
operator|++
name|i
operator|>=
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|live
argument_list|,
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|live_before
argument_list|)
expr_stmt|;
comment|/* Update life information for the new sequence.  */
do|do
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|try
argument_list|)
condition|)
block|{
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
name|i
operator|=
name|MAX_INSNS_PER_PEEP2
expr_stmt|;
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|insn
operator|=
name|try
expr_stmt|;
name|propagate_one_insn
argument_list|(
name|pbi
argument_list|,
name|try
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|live_before
argument_list|,
name|live
argument_list|)
expr_stmt|;
block|}
name|try
operator|=
name|PREV_INSN
argument_list|(
name|try
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|try
operator|!=
name|prev
condition|)
do|;
comment|/* ??? Should verify that LIVE now matches what we 		     had before the new sequence.  */
name|peep2_current
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|head
condition|)
break|break;
block|}
name|free_propagate_block_info
argument_list|(
name|pbi
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_INSNS_PER_PEEP2
operator|+
literal|1
condition|;
operator|++
name|i
control|)
name|FREE_REG_SET
argument_list|(
name|peep2_insn_data
index|[
name|i
index|]
operator|.
name|live_before
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|live
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
name|count_or_remove_death_notes
argument_list|(
name|blocks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|update_life_info
argument_list|(
name|blocks
argument_list|,
name|UPDATE_LIFE_LOCAL
argument_list|,
name|PROP_DEATH_NOTES
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_peephole2 */
end_comment

end_unit

