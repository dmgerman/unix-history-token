begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used by or related to instruction recognition.    Copyright (C) 1987, 1988, 91-98, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_PUSH_CODE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
end_ifdef

begin_define
define|#
directive|define
name|STACK_PUSH_CODE
value|PRE_DEC
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STACK_PUSH_CODE
value|PRE_INC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_POP_CODE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
end_ifdef

begin_define
define|#
directive|define
name|STACK_POP_CODE
value|POST_INC
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STACK_POP_CODE
value|POST_DEC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|validate_replace_rtx_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|find_single_use_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|find_constant_term_loc
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_invalid_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means allow operands to be volatile.    This should be 0 if you are generating rtl, such as if you are calling    the functions in optabs.c and expmed.c (most of the time).    This should be 1 if all valid insns need to be recognized,    such as in regclass.c and final.c and reload.c.     init_recog and init_recog_no_volatile are responsible for setting this.  */
end_comment

begin_decl_stmt
name|int
name|volatile_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The next variables are set up by extract_insn.  The first four of them    are also set up during insn_extract.  */
end_comment

begin_comment
comment|/* Indexed by N, gives value of operand N.  */
end_comment

begin_decl_stmt
name|rtx
name|recog_operand
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by N, gives location where operand N was found.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|recog_operand_loc
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by N, gives location where the Nth duplicate-appearance of    an operand was found.  This is something that matched MATCH_DUP.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|recog_dup_loc
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by N, gives the operand number that was duplicated in the    Nth duplicate-appearance of an operand.  */
end_comment

begin_decl_stmt
name|char
name|recog_dup_num
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of operands of the insn.  */
end_comment

begin_decl_stmt
name|int
name|recog_n_operands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of MATCH_DUPs in the insn.  */
end_comment

begin_decl_stmt
name|int
name|recog_n_dups
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of alternatives in the constraints for the insn.  */
end_comment

begin_decl_stmt
name|int
name|recog_n_alternatives
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by N, gives the mode of operand N.  */
end_comment

begin_decl_stmt
name|enum
name|machine_mode
name|recog_operand_mode
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by N, gives the constraint string for operand N.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|recog_constraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by N, gives the type (in, out, inout) for operand N.  */
end_comment

begin_decl_stmt
name|enum
name|op_type
name|recog_op_type
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTER_CONSTRAINTS
end_ifndef

begin_comment
comment|/* Indexed by N, nonzero if operand N should be an address.  */
end_comment

begin_decl_stmt
name|char
name|recog_operand_address_p
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Contains a vector of operand_alternative structures for every operand.    Set up by preprocess_constraints.  */
end_comment

begin_decl_stmt
name|struct
name|operand_alternative
name|recog_op_alt
index|[
name|MAX_RECOG_OPERANDS
index|]
index|[
name|MAX_RECOG_ALTERNATIVES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On return from `constrain_operands', indicate which alternative    was satisfied.  */
end_comment

begin_decl_stmt
name|int
name|which_alternative
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero after end of reload pass.    Set to 1 or 0 by toplev.c.    Controls the significance of (SUBREG (MEM)).  */
end_comment

begin_decl_stmt
name|int
name|reload_completed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize data used by the function `recog'.    This must be called once in the compilation of a function    before any insn recognition may be done in the function.  */
end_comment

begin_function
name|void
name|init_recog_no_volatile
parameter_list|()
block|{
name|volatile_ok
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_recog
parameter_list|()
block|{
name|volatile_ok
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try recognizing the instruction INSN,    and return the code number that results.    Remember the code so that repeated calls do not    need to spend the time for actual rerecognition.     This function is the normal interface to instruction recognition.    The automatically-generated function `recog' is normally called    through this one.  (The only exception is in combine.c.)  */
end_comment

begin_function
name|int
name|recog_memoized
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
return|return
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check that X is an insn-body for an `asm' with operands    and that the operands mentioned in it are legitimate.  */
end_comment

begin_function
name|int
name|check_asm_operands
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|noperands
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|constraints
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Post-reload, be more strict with things.  */
if|if
condition|(
name|reload_completed
condition|)
block|{
comment|/* ??? Doh!  We've not got the wrapping insn.  Cook one up.  */
name|extract_insn
argument_list|(
name|make_insn_raw
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|constrain_operands
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|which_alternative
operator|>=
literal|0
return|;
block|}
name|noperands
operator|=
name|asm_noperands
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|noperands
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|noperands
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|operands
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|noperands
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|constraints
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|noperands
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|decode_asm_operands
argument_list|(
name|x
argument_list|,
name|operands
argument_list|,
name|NULL_PTR
argument_list|,
name|constraints
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|constraints
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
name|c
operator|++
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
index|[
literal|0
index|]
argument_list|)
operator|&&
name|c
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|c
operator|=
name|constraints
index|[
name|c
index|[
literal|0
index|]
operator|-
literal|'0'
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|asm_operand_ok
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|,
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Static data for the next two routines.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|change_t
block|{
name|rtx
name|object
decl_stmt|;
name|int
name|old_code
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|old
decl_stmt|;
block|}
name|change_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|change_t
modifier|*
name|changes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|changes_allocated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_changes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Validate a proposed change to OBJECT.  LOC is the location in the rtl for    at which NEW will be placed.  If OBJECT is zero, no validation is done,    the change is simply made.     Two types of objects are supported:  If OBJECT is a MEM, memory_address_p    will be called with the address and mode as parameters.  If OBJECT is    an INSN, CALL_INSN, or JUMP_INSN, the insn will be re-recognized with    the change in place.     IN_GROUP is non-zero if this is part of a group of changes that must be    performed as a group.  In that case, the changes will be stored.  The    function `apply_change_group' will validate and apply the changes.     If IN_GROUP is zero, this is a single change.  Try to recognize the insn    or validate the memory reference with the change applied.  If the result    is not valid for the machine, suppress the change and return zero.    Otherwise, perform the change and return 1.  */
end_comment

begin_function
name|int
name|validate_change
parameter_list|(
name|object
parameter_list|,
name|loc
parameter_list|,
name|new
parameter_list|,
name|in_group
parameter_list|)
name|rtx
name|object
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|new
decl_stmt|;
name|int
name|in_group
decl_stmt|;
block|{
name|rtx
name|old
init|=
operator|*
name|loc
decl_stmt|;
if|if
condition|(
name|old
operator|==
name|new
operator|||
name|rtx_equal_p
argument_list|(
name|old
argument_list|,
name|new
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|in_group
operator|==
literal|0
operator|&&
name|num_changes
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|loc
operator|=
name|new
expr_stmt|;
comment|/* Save the information describing this change.  */
if|if
condition|(
name|num_changes
operator|>=
name|changes_allocated
condition|)
block|{
if|if
condition|(
name|changes_allocated
operator|==
literal|0
condition|)
comment|/* This value allows for repeated substitutions inside complex 	   indexed addresses, or changes in up to 5 insns.  */
name|changes_allocated
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|5
expr_stmt|;
else|else
name|changes_allocated
operator|*=
literal|2
expr_stmt|;
name|changes
operator|=
operator|(
name|change_t
operator|*
operator|)
name|xrealloc
argument_list|(
name|changes
argument_list|,
sizeof|sizeof
argument_list|(
name|change_t
argument_list|)
operator|*
name|changes_allocated
argument_list|)
expr_stmt|;
block|}
name|changes
index|[
name|num_changes
index|]
operator|.
name|object
operator|=
name|object
expr_stmt|;
name|changes
index|[
name|num_changes
index|]
operator|.
name|loc
operator|=
name|loc
expr_stmt|;
name|changes
index|[
name|num_changes
index|]
operator|.
name|old
operator|=
name|old
expr_stmt|;
if|if
condition|(
name|object
operator|&&
name|GET_CODE
argument_list|(
name|object
argument_list|)
operator|!=
name|MEM
condition|)
block|{
comment|/* Set INSN_CODE to force rerecognition of insn.  Save old code in 	 case invalid.  */
name|changes
index|[
name|num_changes
index|]
operator|.
name|old_code
operator|=
name|INSN_CODE
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|object
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|num_changes
operator|++
expr_stmt|;
comment|/* If we are making a group of changes, return 1.  Otherwise, validate the      change group we made.  */
if|if
condition|(
name|in_group
condition|)
return|return
literal|1
return|;
else|else
return|return
name|apply_change_group
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* This subroutine of apply_change_group verifies whether the changes to INSN    were valid; i.e. whether INSN can still be recognized.  */
end_comment

begin_function
specifier|static
name|int
name|insn_invalid_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|icode
init|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|is_asm
init|=
name|icode
operator|<
literal|0
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
decl_stmt|;
if|if
condition|(
name|is_asm
operator|&&
operator|!
name|check_asm_operands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|is_asm
operator|&&
name|icode
operator|<
literal|0
condition|)
return|return
literal|1
return|;
comment|/* After reload, verify that all constraints are satisfied.  */
if|if
condition|(
name|reload_completed
condition|)
block|{
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Apply a group of changes previously issued with `validate_change'.    Return 1 if all changes are valid, zero otherwise.  */
end_comment

begin_function
name|int
name|apply_change_group
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* The changes have been applied and all INSN_CODEs have been reset to force      rerecognition.       The changes are valid if we aren't given an object, or if we are      given a MEM and it still is a valid address, or if this is in insn      and it is recognized.  In the latter case, if reload has completed,      we also require that the operands meet the constraints for      the insn.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_changes
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|object
init|=
name|changes
index|[
name|i
index|]
operator|.
name|object
decl_stmt|;
if|if
condition|(
name|object
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|object
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|object
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|object
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|insn_invalid_p
argument_list|(
name|object
argument_list|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|object
argument_list|)
decl_stmt|;
comment|/* Perhaps we couldn't recognize the insn because there were 	     extra CLOBBERs at the end.  If so, try to re-recognize 	     without the last CLOBBER (later iterations will cause each of 	     them to be eliminated, in turn).  But don't do this if we 	     have an ASM_OPERAND.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|object
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rtx
name|newpat
decl_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
condition|)
name|newpat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|j
decl_stmt|;
name|newpat
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* Add a new change to this group to replace the pattern 		  with this new pattern.  Then consider this change 		  as having succeeded.  The change we added will 		  cause the entire call to fail if things remain invalid.  		  Note that this can lose if a later change than the one 		  we are processing specified&XVECEXP (PATTERN (object), 0, X) 		  but this shouldn't occur.  */
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|object
argument_list|)
argument_list|,
name|newpat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
comment|/* If this insn is a CLOBBER or USE, it is always valid, but is 	       never recognized.  */
continue|continue;
else|else
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|num_changes
condition|)
block|{
name|num_changes
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|cancel_changes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the number of changes so far in the current group.   */
end_comment

begin_function
name|int
name|num_validated_changes
parameter_list|()
block|{
return|return
name|num_changes
return|;
block|}
end_function

begin_comment
comment|/* Retract the changes numbered NUM and up.  */
end_comment

begin_function
name|void
name|cancel_changes
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Back out all the changes.  Do this in the opposite order in which      they were made.  */
for|for
control|(
name|i
operator|=
name|num_changes
operator|-
literal|1
init|;
name|i
operator|>=
name|num
condition|;
name|i
operator|--
control|)
block|{
operator|*
name|changes
index|[
name|i
index|]
operator|.
name|loc
operator|=
name|changes
index|[
name|i
index|]
operator|.
name|old
expr_stmt|;
if|if
condition|(
name|changes
index|[
name|i
index|]
operator|.
name|object
operator|&&
name|GET_CODE
argument_list|(
name|changes
index|[
name|i
index|]
operator|.
name|object
argument_list|)
operator|!=
name|MEM
condition|)
name|INSN_CODE
argument_list|(
name|changes
index|[
name|i
index|]
operator|.
name|object
argument_list|)
operator|=
name|changes
index|[
name|i
index|]
operator|.
name|old_code
expr_stmt|;
block|}
name|num_changes
operator|=
name|num
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Replace every occurrence of FROM in X with TO.  Mark each change with    validate_change passing OBJECT.  */
end_comment

begin_function
specifier|static
name|void
name|validate_replace_rtx_1
parameter_list|(
name|loc
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|,
name|object
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|,
name|object
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* X matches FROM if it is the same rtx or they are both referring to the      same register in the same mode.  Avoid calling rtx_equal_p unless the      operands look similar.  */
if|if
condition|(
name|x
operator|==
name|from
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|from
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|from
argument_list|)
operator|)
condition|)
block|{
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* For commutative or comparison operations, try replacing each argument      separately and seeing if we made any changes.  If so, put a constant      argument last.*/
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
condition|)
block|{
name|int
name|prev_changes
init|=
name|num_changes
decl_stmt|;
name|validate_replace_rtx_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|validate_replace_rtx_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_changes
operator|!=
name|num_changes
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
condition|?
name|code
else|:
name|swap_condition
argument_list|(
name|code
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|x
operator|=
operator|*
name|loc
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Note that if CODE's RTX_CLASS is "c" or "<" we will have already      done the substitution, otherwise we won't.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
comment|/* If we have a PLUS whose second operand is now a CONST_INT, use 	 plus_constant to try to simplify it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|to
condition|)
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|MINUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|from
condition|)
block|{
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
comment|/* In these cases, the operation to be performed depends on the mode 	 of the operand.  If we are replacing the operand with a VOIDmode 	 constant, we lose the information.  So try to simplify the operation 	 in that case.  If it fails, substitute in something that we know 	 won't be recognized.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|from
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|from
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|new
init|=
name|simplify_unary_operation
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|to
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
name|new
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|SUBREG
case|:
comment|/* If we have a SUBREG of a register that we are replacing and we are 	 replacing it with a MEM, make a new MEM and try replacing the 	 SUBREG with it.  Don't do this if the MEM has a mode-dependent address 	 or if we would be widening it.  */
if|if
condition|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
operator|==
name|from
operator|&&
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|to
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|offset
init|=
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|*
name|UNITS_PER_WORD
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|new
decl_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|+=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|new
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|ZERO_EXTRACT
case|:
case|case
name|SIGN_EXTRACT
case|:
comment|/* If we are replacing a register with memory, try to change the memory 	 to be the mode required for memory in extract operations (this isn't 	 likely to be an insertion operation; if it was, nothing bad will 	 happen, we might just fail in some cases).  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|from
operator|&&
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|to
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|wanted_mode
init|=
name|VOIDmode
decl_stmt|;
name|enum
name|machine_mode
name|is_mode
init|=
name|GET_MODE
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_extzv
if|if
condition|(
name|code
operator|==
name|ZERO_EXTRACT
condition|)
block|{
name|wanted_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|wanted_mode
operator|==
name|VOIDmode
condition|)
name|wanted_mode
operator|=
name|word_mode
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extv
if|if
condition|(
name|code
operator|==
name|SIGN_EXTRACT
condition|)
block|{
name|wanted_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extv
index|]
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|wanted_mode
operator|==
name|VOIDmode
condition|)
name|wanted_mode
operator|=
name|word_mode
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If we have a narrower mode, we can do something.  */
if|if
condition|(
name|wanted_mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
condition|)
block|{
name|int
name|offset
init|=
name|pos
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|newmem
decl_stmt|;
comment|/* If the bytes and bits are counted differently, we 		     must adjust the offset.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|!=
name|BITS_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|-
name|offset
operator|)
expr_stmt|;
name|pos
operator|%=
name|GET_MODE_BITSIZE
argument_list|(
name|wanted_mode
argument_list|)
expr_stmt|;
name|newmem
operator|=
name|gen_rtx_MEM
argument_list|(
name|wanted_mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|newmem
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|newmem
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|pos
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|newmem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
comment|/* For commutative or comparison operations we've already performed      replacements.  Don't try to perform them again.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'c'
condition|)
block|{
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|validate_replace_rtx_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|object
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|validate_replace_rtx_1
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Try replacing every occurrence of FROM in INSN with TO.  After all    changes have been made, validate by seeing if INSN is still valid.  */
end_comment

begin_function
name|int
name|validate_replace_rtx
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|validate_replace_rtx_1
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|apply_change_group
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Try replacing every occurrence of FROM in INSN with TO.  After all    changes have been made, validate by seeing if INSN is still valid.  */
end_comment

begin_function
name|void
name|validate_replace_rtx_group
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|validate_replace_rtx_1
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try replacing every occurrence of FROM in INSN with TO, avoiding    SET_DESTs.  After all changes have been made, validate by seeing if    INSN is still valid.  */
end_comment

begin_function
name|int
name|validate_replace_src
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|,
name|insn
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
name|abort
argument_list|()
expr_stmt|;
name|validate_replace_rtx_1
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|validate_replace_rtx_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|apply_change_group
argument_list|()
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_comment
comment|/* Return 1 if the insn using CC0 set by INSN does not contain    any ordered tests applied to the condition codes.    EQ and NE tests do not count.  */
end_comment

begin_function
name|int
name|next_insn_tests_no_inequality
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|next
init|=
name|next_cc0_user
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If there is no next insn, we have to take the conservative choice.  */
if|if
condition|(
name|next
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CALL_INSN
operator|)
operator|&&
operator|!
name|inequality_comparisons_p
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This is useless since the insn that sets the cc's 	  must be followed immediately by the use of them.  */
end_comment

begin_comment
comment|/* Return 1 if the CC value set up by INSN is not used.  */
end_comment

begin_endif
unit|int next_insns_test_no_inequality (insn)      rtx insn; {   register rtx next = NEXT_INSN (insn);    for (; next != 0; next = NEXT_INSN (next))     {       if (GET_CODE (next) == CODE_LABEL 	  || GET_CODE (next) == BARRIER) 	return 1;       if (GET_CODE (next) == NOTE) 	continue;       if (inequality_comparisons_p (PATTERN (next))) 	return 0;       if (sets_cc0_p (PATTERN (next)) == 1) 	return 1;       if (! reg_mentioned_p (cc0_rtx, PATTERN (next))) 	return 1;     }   return 1; }
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* This is used by find_single_use to locate an rtx that contains exactly one    use of DEST, which is typically either a REG or CC0.  It returns a    pointer to the innermost rtx expression containing DEST.  Appearances of    DEST that are being used to totally replace it are not counted.  */
end_comment

begin_function
specifier|static
name|rtx
modifier|*
name|find_single_use_1
parameter_list|(
name|dest
parameter_list|,
name|loc
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|result
init|=
literal|0
decl_stmt|;
name|rtx
modifier|*
name|this_result
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CLOBBER
case|:
return|return
literal|0
return|;
case|case
name|SET
case|:
comment|/* If the destination is anything other than CC0, PC, a REG or a SUBREG 	 of a REG that occupies all of the REG, the insn uses DEST if 	 it is mentioned in the destination or the source.  Otherwise, we 	 need just check the source.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|CC0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
operator|)
condition|)
break|break;
return|return
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
case|case
name|MEM
case|:
case|case
name|SUBREG
case|:
return|return
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* If it wasn't one of the common cases above, check each expression and      vector of this code.  Look for a unique usage of DEST.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|dest
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|)
name|this_result
operator|=
name|loc
expr_stmt|;
else|else
name|this_result
operator|=
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|result
operator|=
name|this_result
expr_stmt|;
elseif|else
if|if
condition|(
name|this_result
condition|)
comment|/* Duplicate usage.  */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|==
name|dest
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|)
condition|)
name|this_result
operator|=
name|loc
expr_stmt|;
else|else
name|this_result
operator|=
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|result
operator|=
name|this_result
expr_stmt|;
elseif|else
if|if
condition|(
name|this_result
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if DEST, produced in INSN, is used only a single time in the    sequel.  If so, return a pointer to the innermost rtx expression in which    it is used.     If PLOC is non-zero, *PLOC is set to the insn containing the single use.     This routine will return usually zero either before flow is called (because    there will be no LOG_LINKS notes) or after reload (because the REG_DEAD    note can't be trusted).     If DEST is cc0_rtx, we look only at the next insn.  In that case, we don't    care about REG_DEAD notes or LOG_LINKS.     Otherwise, we find the single use by finding an insn that has a    LOG_LINKS pointing at INSN and has a REG_DEAD note for DEST.  If DEST is    only referenced once in that insn, we know that it must be the first    and last insn referencing DEST.  */
end_comment

begin_function
name|rtx
modifier|*
name|find_single_use
parameter_list|(
name|dest
parameter_list|,
name|insn
parameter_list|,
name|ploc
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|ploc
decl_stmt|;
block|{
name|rtx
name|next
decl_stmt|;
name|rtx
modifier|*
name|result
decl_stmt|;
name|rtx
name|link
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|dest
operator|==
name|cc0_rtx
condition|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
literal|0
operator|||
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|!=
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|!=
name|JUMP_INSN
operator|)
condition|)
return|return
literal|0
return|;
name|result
operator|=
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|&&
name|ploc
condition|)
operator|*
name|ploc
operator|=
name|next
expr_stmt|;
return|return
name|result
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|reload_completed
operator|||
name|reload_in_progress
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
for|for
control|(
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|next
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|next
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|dead_or_set_p
argument_list|(
name|next
argument_list|,
name|dest
argument_list|)
condition|)
block|{
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|next
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|insn
condition|)
break|break;
if|if
condition|(
name|link
condition|)
block|{
name|result
operator|=
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ploc
condition|)
operator|*
name|ploc
operator|=
name|next
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a valid general operand for machine mode MODE.    This is either a register reference, a memory reference,    or a constant.  In the case of a memory reference, the address    is checked for general validity for the target machine.     Register and memory references must have mode MODE in order to be valid,    but some constants have no machine mode and are valid for any mode.     If MODE is VOIDmode, OP is checked for validity for whatever mode    it has.     The main use of this function is as a predicate in match_operand    expressions in the machine description.     For an explanation of this function's behavior for registers of    class NO_REGS, see the comment for `register_operand'.  */
end_comment

begin_function
name|int
name|general_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|int
name|mode_altering_drug
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* Don't accept CONST_INT or anything similar      if the caller wants something floating.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|)
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
comment|/* Except for certain constants with VOIDmode, already checked for,      OP's mode must match MODE if MODE specifies a mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
block|{
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
comment|/* On machines that have insn scheduling, we want all memory 	 reference to be explicit, so outlaw paradoxical SUBREGs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* No longer needed, since (SUBREG (MEM...)) 	 will load the MEM into a reload reg in the MEM's own mode.  */
block|mode_altering_drug = 1;
endif|#
directive|endif
block|}
if|if
condition|(
name|code
operator|==
name|REG
condition|)
comment|/* A register whose class is NO_REGS is not a general operand.  */
return|return
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|NO_REGS
operator|)
return|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
specifier|register
name|rtx
name|y
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|volatile_ok
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
literal|1
return|;
comment|/* Use the mem's mode, since it will be reloaded thus.  */
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|GO_IF_LEGITIMATE_ADDRESS
argument_list|(
name|mode
argument_list|,
name|y
argument_list|,
name|win
argument_list|)
expr_stmt|;
block|}
comment|/* Pretend this is an operand for now; we'll run force_operand      on its replacement in fixup_var_refs_1.  */
if|if
condition|(
name|code
operator|==
name|ADDRESSOF
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
name|win
label|:
if|if
condition|(
name|mode_altering_drug
condition|)
return|return
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a valid memory address for a memory reference    of mode MODE.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|address_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register reference of mode MODE.    If MODE is VOIDmode, accept a register in any mode.     The main use of this function is as a predicate in match_operand    expressions in the machine description.     As a special exception, registers whose class is NO_REGS are    not accepted by `register_operand'.  The reason for this change    is to allow the representation of special architecture artifacts    (such as a condition code register) without extending the rtl    definitions.  Since registers of class NO_REGS cannot be used    as registers in any case where register classes are examined,    it is most consistent to keep this function from accepting them.  */
end_comment

begin_function
name|int
name|register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* Before reload, we can allow (SUBREG (MEM...)) as a register operand 	 because it is guaranteed to be reloaded into one. 	 Just make sure the MEM is valid in itself. 	 (Ideally, (SUBREG (MEM)...) should not exist after reload, 	 but currently it does result from (SUBREG (REG)...) where the 	 reg went on the stack.)  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
ifdef|#
directive|ifdef
name|CLASS_CANNOT_CHANGE_SIZE
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|CLASS_CANNOT_CHANGE_SIZE
index|]
argument_list|,
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MODE_COMPLEX_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MODE_COMPLEX_FLOAT
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* We don't consider registers whose class is NO_REGS      to be a register operand.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|NO_REGS
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP should match a MATCH_SCRATCH, i.e., if it is a SCRATCH    or a hard register.  */
end_comment

begin_function
name|int
name|scratch_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SCRATCH
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid immediate operand for mode MODE.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|immediate_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* Don't accept CONST_INT or anything similar      if the caller wants something floating.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
comment|/* Accept CONSTANT_P_RTX, since it will be gone by CSE1 and      result in 0/1.  It seems a safe assumption that this is      in range for everyone.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is an operand that is a CONST_INT.  */
end_comment

begin_function
name|int
name|const_int_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is an operand that is a constant integer or constant    floating-point number.  */
end_comment

begin_function
name|int
name|const_double_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* Don't accept CONST_INT or anything similar      if the caller wants something floating.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a general operand that is not an immediate operand.  */
end_comment

begin_function
name|int
name|nonimmediate_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register reference or immediate value of mode MODE.  */
end_comment

begin_function
name|int
name|nonmemory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
comment|/* Don't accept CONST_INT or anything similar 	 if the caller wants something floating.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|)
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* Before reload, we can allow (SUBREG (MEM...)) as a register operand 	 because it is guaranteed to be reloaded into one. 	 Just make sure the MEM is valid in itself. 	 (Ideally, (SUBREG (MEM)...) should not exist after reload, 	 but currently it does result from (SUBREG (REG)...) where the 	 reg went on the stack.)  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* We don't consider registers whose class is NO_REGS      to be a register operand.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|NO_REGS
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand that stands for pushing a    value of mode MODE onto the stack.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|push_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|STACK_PUSH_CODE
condition|)
return|return
literal|0
return|;
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand that stands for popping a    value of mode MODE off the stack.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|pop_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|STACK_POP_CODE
condition|)
return|return
literal|0
return|;
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if ADDR is a valid memory address for mode MODE.  */
end_comment

begin_function
name|int
name|memory_address_p
parameter_list|(
name|mode
parameter_list|,
name|addr
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
literal|1
return|;
name|GO_IF_LEGITIMATE_ADDRESS
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|win
label|:
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid memory reference with mode MODE,    including a valid address.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|inner
decl_stmt|;
if|if
condition|(
operator|!
name|reload_completed
condition|)
comment|/* Note that no SUBREG is a memory operand before end of reload pass,        because (SUBREG (MEM...)) forces reloading into a register.  */
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|inner
operator|=
name|op
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|SUBREG
condition|)
name|inner
operator|=
name|SUBREG_REG
argument_list|(
name|inner
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|MEM
operator|&&
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid indirect memory reference with mode MODE;    that is, a memory reference whose address is a general_operand.  */
end_comment

begin_function
name|int
name|indirect_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* Before reload, a SUBREG isn't in memory (see memory_operand, above).  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
specifier|register
name|int
name|offset
init|=
name|SUBREG_WORD
argument_list|(
name|op
argument_list|)
operator|*
name|UNITS_PER_WORD
decl_stmt|;
name|rtx
name|inner
init|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|-=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
comment|/* The only way that we can have a general_operand as the resulting 	 address is if OFFSET is zero and the address already is an operand 	 or if the address is (plus Y (const_int -OFFSET)) and Y is an 	 operand.  */
return|return
operator|(
operator|(
name|offset
operator|==
literal|0
operator|&&
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
name|offset
operator|&&
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|)
operator|)
return|;
block|}
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a comparison operator.  This allows the use of    MATCH_OPERATOR to recognize all the branch insns.  */
end_comment

begin_function
name|int
name|comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If BODY is an insn body that uses ASM_OPERANDS,    return the number of operands (both input and output) in the insn.    Otherwise return -1.  */
end_comment

begin_function
name|int
name|asm_noperands
parameter_list|(
name|body
parameter_list|)
name|rtx
name|body
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
comment|/* No output operands: return number of input operands.  */
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|body
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
comment|/* Single output operand: BODY is (set OUTPUT (asm_operands ...)).  */
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|+
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
comment|/* Multiple output operands, or 1 output plus some clobbers: 	 body is [(set OUTPUT (asm_operands ...))... (clobber (reg ...))...].  */
name|int
name|i
decl_stmt|;
name|int
name|n_sets
decl_stmt|;
comment|/* Count backwards through CLOBBERs to determine number of SETs.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* N_SETS is now number of output operands.  */
name|n_sets
operator|=
name|i
expr_stmt|;
comment|/* Verify that all the SETs we have 	 came from a single original asm_operands insn 	 (so that invalid combinations are blocked).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|ASM_OPERANDS
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If these ASM_OPERANDS rtx's came from different original insns 	     then they aren't allowed together.  */
if|if
condition|(
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|+
name|n_sets
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
comment|/* 0 outputs, but some clobbers: 	 body is [(asm_operands ...) (clobber (reg ...))...].  */
name|int
name|i
decl_stmt|;
comment|/* Make sure all the other parallel things really are clobbers.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Assuming BODY is an insn body that uses ASM_OPERANDS,    copy its operands (both input and output) into the vector OPERANDS,    the locations of the operands within the insn into the vector OPERAND_LOCS,    and the constraints for the operands into CONSTRAINTS.    Write the modes of the operands into MODES.    Return the assembler-template.     If MODES, OPERAND_LOCS, CONSTRAINTS or OPERANDS is 0,    we don't store that info.  */
end_comment

begin_function
name|char
modifier|*
name|decode_asm_operands
parameter_list|(
name|body
parameter_list|,
name|operands
parameter_list|,
name|operand_locs
parameter_list|,
name|constraints
parameter_list|,
name|modes
parameter_list|)
name|rtx
name|body
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
name|rtx
modifier|*
modifier|*
name|operand_locs
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|constraints
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|modes
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|noperands
decl_stmt|;
name|char
modifier|*
name|template
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
name|rtx
name|asmop
init|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
decl_stmt|;
comment|/* Single output operand: BODY is (set OUTPUT (asm_operands ....)).  */
name|noperands
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|asmop
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_MODE
argument_list|(
name|asmop
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* The output is in the SET. 	 Its constraint is in the ASM_OPERANDS itself.  */
if|if
condition|(
name|operands
condition|)
name|operands
index|[
literal|0
index|]
operator|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
literal|0
index|]
operator|=
operator|&
name|SET_DEST
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
literal|0
index|]
operator|=
name|ASM_OPERANDS_OUTPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
literal|0
index|]
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
name|template
operator|=
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
name|rtx
name|asmop
init|=
name|body
decl_stmt|;
comment|/* No output operands: BODY is (asm_operands ....).  */
name|noperands
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
comment|/* The input operands are found in the 1st element vector.  */
comment|/* Constraints for inputs are in the 2nd element vector.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_MODE
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|template
operator|=
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|asmop
init|=
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|nparallel
init|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Includes CLOBBERs.  */
name|int
name|nin
init|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|asmop
argument_list|)
decl_stmt|;
name|int
name|nout
init|=
literal|0
decl_stmt|;
comment|/* Does not include CLOBBERs.  */
comment|/* At least one output, plus some CLOBBERs.  */
comment|/* The outputs are in the SETs. 	 Their constraints are in the ASM_OPERANDS itself.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparallel
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
break|break;
comment|/* Past last SET */
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|XSTR
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nout
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nin
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
operator|+
name|nout
index|]
operator|=
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
operator|+
name|nout
index|]
operator|=
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
operator|+
name|nout
index|]
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
operator|+
name|nout
index|]
operator|=
name|ASM_OPERANDS_INPUT_MODE
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|template
operator|=
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
comment|/* No outputs, but some CLOBBERs.  */
name|rtx
name|asmop
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|nin
init|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|asmop
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nin
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_MODE
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|template
operator|=
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
block|}
return|return
name|template
return|;
block|}
end_function

begin_comment
comment|/* Check if an asm_operand matches it's constraints.     Return> 0 if ok, = 0 if bad,< 0 if inconclusive.  */
end_comment

begin_function
name|int
name|asm_operand_ok
parameter_list|(
name|op
parameter_list|,
name|constraint
parameter_list|)
name|rtx
name|op
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|/* Use constrain_operands after reload.  */
if|if
condition|(
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|constraint
condition|)
block|{
switch|switch
condition|(
operator|*
name|constraint
operator|++
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
case|case
literal|'#'
case|:
case|case
literal|'&'
case|:
case|case
literal|','
case|:
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* For best results, our caller should have given us the 	     proper matching constraint, but we can't actually fail 	     the check if they didn't.  Indicate that results are 	     inconclusive.  */
name|result
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|address_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'m'
case|:
case|case
literal|'V'
case|:
comment|/* non-offsettable */
if|if
condition|(
name|memory_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'o'
case|:
comment|/* offsettable */
if|if
condition|(
name|offsettable_nonstrict_memref_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'<'
case|:
comment|/* ??? Before flow, auto inc/dec insns are not supposed to exist, 	     excepting those that expand_call created.  Further, on some 	     machines which do not have generalized auto inc/dec, an inc/dec 	     is not a memory_operand.  	     Match any memory and hope things are resolved after reload.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_DEC
operator|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'E'
case|:
ifndef|#
directive|ifndef
name|REAL_ARITHMETIC
comment|/* Match any floating double constant, but only if 	     we can examine the bits of it reliably.  */
if|if
condition|(
operator|(
name|HOST_FLOAT_FORMAT
operator|!=
name|TARGET_FLOAT_FORMAT
operator|||
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|BITS_PER_WORD
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|!
name|flag_pretend_float
condition|)
break|break;
endif|#
directive|endif
comment|/* FALLTHRU */
case|case
literal|'F'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'G'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_LETTER_P
argument_list|(
name|op
argument_list|,
literal|'G'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_LETTER_P
argument_list|(
name|op
argument_list|,
literal|'H'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
break|break;
comment|/* FALLTHRU */
case|case
literal|'i'
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
endif|#
directive|endif
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'I'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'J'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'J'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'K'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'K'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'L'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'L'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'M'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'N'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'O'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'O'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'P'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'X'
case|:
return|return
literal|1
return|;
case|case
literal|'g'
case|:
if|if
condition|(
name|general_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
case|case
literal|'Q'
case|:
if|if
condition|(
name|EXTRA_CONSTRAINT
argument_list|(
name|op
argument_list|,
literal|'Q'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
name|EXTRA_CONSTRAINT
argument_list|(
name|op
argument_list|,
literal|'R'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|EXTRA_CONSTRAINT
argument_list|(
name|op
argument_list|,
literal|'S'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|EXTRA_CONSTRAINT
argument_list|(
name|op
argument_list|,
literal|'T'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'U'
case|:
if|if
condition|(
name|EXTRA_CONSTRAINT
argument_list|(
name|op
argument_list|,
literal|'U'
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
endif|#
directive|endif
case|case
literal|'r'
case|:
default|default:
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|BLKmode
condition|)
break|break;
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an rtx *P, if it is a sum containing an integer constant term,    return the location (type rtx *) of the pointer to that constant term.    Otherwise, return a null pointer.  */
end_comment

begin_function
specifier|static
name|rtx
modifier|*
name|find_constant_term_loc
parameter_list|(
name|p
parameter_list|)
name|rtx
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|rtx
modifier|*
name|tem
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
comment|/* If *P IS such a constant term, P is its location.  */
if|if
condition|(
name|code
operator|==
name|CONST_INT
operator|||
name|code
operator|==
name|SYMBOL_REF
operator|||
name|code
operator|==
name|LABEL_REF
operator|||
name|code
operator|==
name|CONST
condition|)
return|return
name|p
return|;
comment|/* Otherwise, if not a sum, it has no constant term.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|p
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
literal|0
return|;
comment|/* If one of the summands is constant, return its location.  */
if|if
condition|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|p
return|;
comment|/* Otherwise, check each summand for containing a constant term.  */
if|if
condition|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|find_constant_term_loc
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
block|}
if|if
condition|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|find_constant_term_loc
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a memory reference    whose address contains no side effects    and remains valid after the addition    of a positive integer less than the    size of the object being referenced.     We assume that the original address is valid and do not check it.     This uses strict_memory_address_p as a subroutine, so    don't use it before reload.  */
end_comment

begin_function
name|int
name|offsettable_memref_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
name|offsettable_address_p
argument_list|(
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but don't require a strictly valid mem ref:    consider pseudo-regs valid as index or base regs.  */
end_comment

begin_function
name|int
name|offsettable_nonstrict_memref_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
name|offsettable_address_p
argument_list|(
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if Y is a memory address which contains no side effects    and would remain valid after the addition of a positive integer    less than the size of that mode.     We assume that the original address is valid and do not check it.    We do check that it is valid for narrower modes.     If STRICTP is nonzero, we require a strictly valid address,    for the sake of use in reload.c.  */
end_comment

begin_function
name|int
name|offsettable_address_p
parameter_list|(
name|strictp
parameter_list|,
name|mode
parameter_list|,
name|y
parameter_list|)
name|int
name|strictp
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|y
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|ycode
init|=
name|GET_CODE
argument_list|(
name|y
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|z
decl_stmt|;
name|rtx
name|y1
init|=
name|y
decl_stmt|;
name|rtx
modifier|*
name|y2
decl_stmt|;
name|int
function_decl|(
modifier|*
name|addressp
function_decl|)
parameter_list|()
init|=
operator|(
name|strictp
condition|?
name|strict_memory_address_p
operator|:
name|memory_address_p
init|)
function_decl|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Adjusting an offsettable address involves changing to a narrower mode.      Make sure that's OK.  */
if|if
condition|(
name|mode_dependent_address_p
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If the expression contains a constant term,      see if it remains valid when max possible offset is added.  */
if|if
condition|(
operator|(
name|ycode
operator|==
name|PLUS
operator|)
operator|&&
operator|(
name|y2
operator|=
name|find_constant_term_loc
argument_list|(
operator|&
name|y1
argument_list|)
operator|)
condition|)
block|{
name|int
name|good
decl_stmt|;
name|y1
operator|=
operator|*
name|y2
expr_stmt|;
operator|*
name|y2
operator|=
name|plus_constant
argument_list|(
operator|*
name|y2
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Use QImode because an odd displacement may be automatically invalid 	 for any wider mode.  But it should be valid for a single byte.  */
name|good
operator|=
call|(
modifier|*
name|addressp
call|)
argument_list|(
name|QImode
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* In any case, restore old contents of memory.  */
operator|*
name|y2
operator|=
name|y1
expr_stmt|;
return|return
name|good
return|;
block|}
if|if
condition|(
name|ycode
operator|==
name|PRE_DEC
operator|||
name|ycode
operator|==
name|PRE_INC
operator|||
name|ycode
operator|==
name|POST_DEC
operator|||
name|ycode
operator|==
name|POST_INC
condition|)
return|return
literal|0
return|;
comment|/* The offset added here is chosen as the maximum offset that      any instruction could need to add when operating on something      of the specified mode.  We assume that if Y and Y+c are      valid addresses then so is Y+d for all 0<d<c.  */
name|z
operator|=
name|plus_constant_for_output
argument_list|(
name|y
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Use QImode because an odd displacement may be automatically invalid      for any wider mode.  But it should be valid for a single byte.  */
return|return
call|(
modifier|*
name|addressp
call|)
argument_list|(
name|QImode
argument_list|,
name|z
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if ADDR is an address-expression whose effect depends    on the mode of the memory reference it is used in.     Autoincrement addressing is a typical example of mode-dependence    because the amount of the increment depends on the mode.  */
end_comment

begin_function
name|int
name|mode_dependent_address_p
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
name|ATTRIBUTE_UNUSED
decl_stmt|;
comment|/* Maybe used in GO_IF_MODE_DEPENDENT_ADDRESS. */
block|{
name|GO_IF_MODE_DEPENDENT_ADDRESS
argument_list|(
name|addr
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Label `win' might (not) be used via GO_IF_MODE_DEPENDENT_ADDRESS. */
name|win
label|:
name|ATTRIBUTE_UNUSED_LABEL
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a general operand    other than a memory ref with a mode dependent address.  */
end_comment

begin_function
name|int
name|mode_independent_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|1
return|;
name|addr
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GO_IF_MODE_DEPENDENT_ADDRESS
argument_list|(
name|addr
argument_list|,
name|lose
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* Label `lose' might (not) be used via GO_IF_MODE_DEPENDENT_ADDRESS. */
name|lose
label|:
name|ATTRIBUTE_UNUSED_LABEL
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given an operand OP that is a valid memory reference    which satisfies offsettable_memref_p,    return a new memory reference whose address has been adjusted by OFFSET.    OFFSET should be positive and less than the size of the object referenced. */
end_comment

begin_function
name|rtx
name|adj_offsettable_operand
parameter_list|(
name|op
parameter_list|,
name|offset
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
specifier|register
name|rtx
name|y
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|new
decl_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|plus_constant_for_output
argument_list|(
name|y
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|z
init|=
name|y
decl_stmt|;
specifier|register
name|rtx
modifier|*
name|const_loc
decl_stmt|;
name|op
operator|=
name|copy_rtx
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|z
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|const_loc
operator|=
name|find_constant_term_loc
argument_list|(
operator|&
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|const_loc
condition|)
block|{
operator|*
name|const_loc
operator|=
name|plus_constant_for_output
argument_list|(
operator|*
name|const_loc
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
block|}
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|plus_constant_for_output
argument_list|(
name|y
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Analyze INSN and compute the variables recog_n_operands, recog_n_dups,    recog_n_alternatives, recog_operand, recog_operand_loc, recog_constraints,    recog_operand_mode, recog_dup_loc and recog_dup_num.    If REGISTER_CONSTRAINTS is not defined, also compute    recog_operand_address_p.  */
end_comment

begin_function
name|void
name|extract_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|icode
decl_stmt|;
name|int
name|noperands
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|recog_n_operands
operator|=
literal|0
expr_stmt|;
name|recog_n_alternatives
operator|=
literal|0
expr_stmt|;
name|recog_n_dups
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
condition|)
block|{
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return;
case|case
name|SET
case|:
case|case
name|PARALLEL
case|:
case|case
name|ASM_OPERANDS
case|:
name|recog_n_operands
operator|=
name|noperands
operator|=
name|asm_noperands
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|noperands
operator|>=
literal|0
condition|)
block|{
comment|/* This insn is an `asm' with operands.  */
comment|/* expand_asm_operands makes sure there aren't too many operands.  */
if|if
condition|(
name|noperands
operator|>
name|MAX_RECOG_OPERANDS
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Now get the operand values and constraints out of the insn.  */
name|decode_asm_operands
argument_list|(
name|body
argument_list|,
name|recog_operand
argument_list|,
name|recog_operand_loc
argument_list|,
name|recog_constraints
argument_list|,
name|recog_operand_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|noperands
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|recog_constraints
index|[
literal|0
index|]
decl_stmt|;
name|recog_n_alternatives
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|recog_n_alternatives
operator|+=
operator|(
operator|*
name|p
operator|++
operator|==
literal|','
operator|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|REGISTER_CONSTRAINTS
name|bzero
argument_list|(
name|recog_operand_address_p
argument_list|,
sizeof|sizeof
name|recog_operand_address_p
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
comment|/* Ordinary insn: recognize it, get the operands via insn_extract 	 and get the constraints.  */
name|icode
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|icode
operator|<
literal|0
condition|)
name|fatal_insn_not_found
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|recog_n_operands
operator|=
name|noperands
operator|=
name|insn_n_operands
index|[
name|icode
index|]
expr_stmt|;
name|recog_n_alternatives
operator|=
name|insn_n_alternatives
index|[
name|icode
index|]
expr_stmt|;
name|recog_n_dups
operator|=
name|insn_n_dups
index|[
name|icode
index|]
expr_stmt|;
name|insn_extract
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
name|recog_constraints
index|[
name|i
index|]
operator|=
name|insn_operand_constraint
index|[
name|icode
index|]
index|[
name|i
index|]
expr_stmt|;
else|#
directive|else
name|recog_operand_address_p
index|[
name|i
index|]
operator|=
name|insn_operand_address_p
index|[
name|icode
index|]
index|[
name|i
index|]
expr_stmt|;
endif|#
directive|endif
name|recog_operand_mode
index|[
name|i
index|]
operator|=
name|insn_operand_mode
index|[
name|icode
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
name|recog_op_type
index|[
name|i
index|]
operator|=
operator|(
name|recog_constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'='
condition|?
name|OP_OUT
else|:
name|recog_constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|?
name|OP_INOUT
else|:
name|OP_IN
operator|)
expr_stmt|;
if|if
condition|(
name|recog_n_alternatives
operator|>
name|MAX_RECOG_ALTERNATIVES
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After calling extract_insn, you can use this function to extract some    information from the constraint strings into a more usable form.    The collected data is stored in recog_op_alt.  */
end_comment

begin_function
name|void
name|preprocess_constraints
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_n_operands
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|struct
name|operand_alternative
modifier|*
name|op_alt
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|recog_constraints
index|[
name|i
index|]
decl_stmt|;
name|op_alt
operator|=
name|recog_op_alt
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|recog_n_alternatives
condition|;
name|j
operator|++
control|)
block|{
name|op_alt
index|[
name|j
index|]
operator|.
name|class
operator|=
name|NO_REGS
expr_stmt|;
name|op_alt
index|[
name|j
index|]
operator|.
name|constraint
operator|=
name|p
expr_stmt|;
name|op_alt
index|[
name|j
index|]
operator|.
name|matches
operator|=
operator|-
literal|1
expr_stmt|;
name|op_alt
index|[
name|j
index|]
operator|.
name|matched
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
block|{
name|op_alt
index|[
name|j
index|]
operator|.
name|anything_ok
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
do|do
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
do|while
condition|(
name|c
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
do|;
if|if
condition|(
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|'\0'
condition|)
break|break;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
endif|#
directive|endif
comment|/* These don't say anything we care about.  */
break|break;
case|case
literal|'?'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|reject
operator|+=
literal|6
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|reject
operator|+=
literal|600
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|earlyclobber
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|matches
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|op_alt
index|[
name|op_alt
index|[
name|j
index|]
operator|.
name|matches
index|]
operator|.
name|matched
operator|=
name|i
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|memory_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|decmem_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|incmem_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|nonoffmem_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|offmem_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|anything_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|class
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|op_alt
index|[
name|j
index|]
operator|.
name|class
index|]
index|[
operator|(
name|int
operator|)
name|BASE_REG_CLASS
index|]
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'r'
case|:
name|op_alt
index|[
name|j
index|]
operator|.
name|class
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|op_alt
index|[
name|j
index|]
operator|.
name|class
index|]
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
expr_stmt|;
break|break;
default|default:
name|op_alt
index|[
name|j
index|]
operator|.
name|class
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|op_alt
index|[
name|j
index|]
operator|.
name|class
index|]
index|[
operator|(
name|int
operator|)
name|REG_CLASS_FROM_LETTER
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
end_ifdef

begin_comment
comment|/* Check the operands of an insn against the insn's operand constraints    and return 1 if they are valid.    The information about the insn's operands, constraints, operand modes    etc. is obtained from the global variables set up by extract_insn.     WHICH_ALTERNATIVE is set to a number which indicates which    alternative of constraints was matched: 0 for the first alternative,    1 for the next, etc.     In addition, when two operands are match    and it happens that the output operand is (reg) while the    input operand is --(reg) or ++(reg) (a pre-inc or pre-dec),    make the output operand look like the input.    This is because the output operand is the one the template will print.     This is used in final, just before printing the assembler code and by    the routines that determine an insn's attribute.     If STRICT is a positive non-zero value, it means that we have been    called after reload has been completed.  In that case, we must    do all checks strictly.  If it is zero, it means that we have been called    before reload has completed.  In that case, we first try to see if we can    find an alternative that matches strictly.  If not, we try again, this    time assuming that reload will fix up the insn.  This provides a "best    guess" for the alternative and is used to compute attributes of insns prior    to reload.  A negative value of STRICT is used for this internal call.  */
end_comment

begin_struct
struct|struct
name|funny_match
block|{
name|int
name|this
decl_stmt|,
name|other
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|constrain_operands
parameter_list|(
name|strict
parameter_list|)
name|int
name|strict
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|constraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|matching_operands
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|earlyclobber
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|struct
name|funny_match
name|funny_match
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|funny_match_index
decl_stmt|;
if|if
condition|(
name|recog_n_operands
operator|==
literal|0
operator|||
name|recog_n_alternatives
operator|==
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|recog_n_operands
condition|;
name|c
operator|++
control|)
block|{
name|constraints
index|[
name|c
index|]
operator|=
name|recog_constraints
index|[
name|c
index|]
expr_stmt|;
name|matching_operands
index|[
name|c
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|which_alternative
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|which_alternative
operator|<
name|recog_n_alternatives
condition|)
block|{
specifier|register
name|int
name|opno
decl_stmt|;
name|int
name|lose
init|=
literal|0
decl_stmt|;
name|funny_match_index
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|opno
operator|<
name|recog_n_operands
condition|;
name|opno
operator|++
control|)
block|{
specifier|register
name|rtx
name|op
init|=
name|recog_operand
index|[
name|opno
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|p
init|=
name|constraints
index|[
name|opno
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|win
init|=
literal|0
decl_stmt|;
name|int
name|val
decl_stmt|;
name|earlyclobber
index|[
name|opno
index|]
operator|=
literal|0
expr_stmt|;
comment|/* A unary operator may be accepted by the predicate, but it 	     is irrelevant for matching constraints.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
literal|'1'
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|offset
operator|=
name|SUBREG_WORD
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* An empty constraint or empty alternative 	     allows anything which matched the pattern.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|win
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|','
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
break|break;
case|case
literal|'#'
case|:
comment|/* Ignore rest of this alternative as far as 		   constraint checking is concerned.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|earlyclobber
index|[
name|opno
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* This operand must be the same as a previous one. 		   This kind of constraint is used for instructions such 		   as add when they take only two operands.  		   Note that the lower-numbered operand is passed first.  		   If we are not testing strictly, assume that this constraint 		   will be satisfied.  */
if|if
condition|(
name|strict
operator|<
literal|0
condition|)
name|val
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|rtx
name|op1
init|=
name|recog_operand
index|[
name|c
operator|-
literal|'0'
index|]
decl_stmt|;
name|rtx
name|op2
init|=
name|recog_operand
index|[
name|opno
index|]
decl_stmt|;
comment|/* A unary operator may be accepted by the predicate, 		       but it is irrelevant for matching constraints.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|==
literal|'1'
condition|)
name|op1
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
argument_list|)
operator|==
literal|'1'
condition|)
name|op2
operator|=
name|XEXP
argument_list|(
name|op2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|operands_match_p
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
block|}
name|matching_operands
index|[
name|opno
index|]
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|matching_operands
index|[
name|c
operator|-
literal|'0'
index|]
operator|=
name|opno
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|win
operator|=
literal|1
expr_stmt|;
comment|/* If output is *x and input is *--x, 		   arrange later to change the output to *--x as well, 		   since the output op is the one that will be printed.  */
if|if
condition|(
name|val
operator|==
literal|2
operator|&&
name|strict
operator|>
literal|0
condition|)
block|{
name|funny_match
index|[
name|funny_match_index
index|]
operator|.
name|this
operator|=
name|opno
expr_stmt|;
name|funny_match
index|[
name|funny_match_index
operator|++
index|]
operator|.
name|other
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
comment|/* p is used for address_operands.  When we are called by 		   gen_reload, no one will have checked that the address is 		   strictly valid, i.e., that all pseudos requiring hard regs 		   have gotten them.  */
if|if
condition|(
name|strict
operator|<=
literal|0
operator|||
operator|(
name|strict_memory_address_p
argument_list|(
name|recog_operand_mode
index|[
name|opno
index|]
argument_list|,
name|op
argument_list|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* No need to check general_operand again; 		   it was done in insn-recog.c.  */
case|case
literal|'g'
case|:
comment|/* Anything goes unless it is a REG and really has a hard reg 		   but the hard reg is not in the class GENERAL_REGS.  */
if|if
condition|(
name|strict
operator|<
literal|0
operator|||
name|GENERAL_REGS
operator|==
name|ALL_REGS
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|reload_in_progress
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|reg_fits_class_p
argument_list|(
name|op
argument_list|,
name|GENERAL_REGS
argument_list|,
name|offset
argument_list|,
name|mode
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|strict
operator|<
literal|0
operator|||
operator|(
name|strict
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|strict
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SCRATCH
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
name|GENERAL_REGS
operator|==
name|ALL_REGS
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|reg_fits_class_p
argument_list|(
name|op
argument_list|,
name|GENERAL_REGS
argument_list|,
name|offset
argument_list|,
name|mode
argument_list|)
operator|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* This is used for a MATCH_SCRATCH in the cases when 		   we don't actually need anything.  So anything goes 		   any time.  */
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
comment|/* Before reload, accept what reload can turn into mem.  */
operator|||
operator|(
name|strict
operator|<
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
comment|/* During reload, accept a pseudo  */
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_DEC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
ifndef|#
directive|ifndef
name|REAL_ARITHMETIC
comment|/* Match any CONST_DOUBLE, but only if 		   we can examine the bits of it reliably.  */
if|if
condition|(
operator|(
name|HOST_FLOAT_FORMAT
operator|!=
name|TARGET_FLOAT_FORMAT
operator|||
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|BITS_PER_WORD
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|!
name|flag_pretend_float
condition|)
break|break;
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_LETTER_P
argument_list|(
name|op
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
if|if
condition|(
name|EXTRA_CONSTRAINT
argument_list|(
name|op
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'V'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
operator|(
name|strict
operator|>
literal|0
operator|&&
operator|!
name|offsettable_memref_p
argument_list|(
name|op
argument_list|)
operator|)
operator|||
operator|(
name|strict
operator|<
literal|0
operator|&&
operator|!
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|)
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
operator|(
name|strict
operator|>
literal|0
operator|&&
name|offsettable_memref_p
argument_list|(
name|op
argument_list|)
operator|)
operator|||
operator|(
name|strict
operator|==
literal|0
operator|&&
name|offsettable_nonstrict_memref_p
argument_list|(
name|op
argument_list|)
operator|)
comment|/* Before reload, accept what reload can handle.  */
operator|||
operator|(
name|strict
operator|<
literal|0
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|)
operator|)
comment|/* During reload, accept a pseudo  */
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|strict
operator|<
literal|0
operator|||
operator|(
name|strict
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|strict
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SCRATCH
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|reg_fits_class_p
argument_list|(
name|op
argument_list|,
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
argument_list|,
name|offset
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
block|}
name|constraints
index|[
name|opno
index|]
operator|=
name|p
expr_stmt|;
comment|/* If this operand did not win somehow, 	     this alternative loses.  */
if|if
condition|(
operator|!
name|win
condition|)
name|lose
operator|=
literal|1
expr_stmt|;
block|}
comment|/* This alternative won; the operands are ok. 	 Change whichever operands this alternative says to change.  */
if|if
condition|(
operator|!
name|lose
condition|)
block|{
name|int
name|opno
decl_stmt|,
name|eopno
decl_stmt|;
comment|/* See if any earlyclobber operand conflicts with some other 	     operand.  */
if|if
condition|(
name|strict
operator|>
literal|0
condition|)
for|for
control|(
name|eopno
operator|=
literal|0
init|;
name|eopno
operator|<
name|recog_n_operands
condition|;
name|eopno
operator|++
control|)
comment|/* Ignore earlyclobber operands now in memory, 		 because we would often report failure when we have 		 two memory operands, one of which was formerly a REG.  */
if|if
condition|(
name|earlyclobber
index|[
name|eopno
index|]
operator|&&
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|eopno
index|]
argument_list|)
operator|==
name|REG
condition|)
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|opno
operator|<
name|recog_n_operands
condition|;
name|opno
operator|++
control|)
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|opno
index|]
argument_list|)
operator|==
name|MEM
operator|||
name|recog_op_type
index|[
name|opno
index|]
operator|!=
name|OP_OUT
operator|)
operator|&&
name|opno
operator|!=
name|eopno
comment|/* Ignore things like match_operator operands.  */
operator|&&
operator|*
name|recog_constraints
index|[
name|opno
index|]
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|matching_operands
index|[
name|opno
index|]
operator|==
name|eopno
operator|&&
name|operands_match_p
argument_list|(
name|recog_operand
index|[
name|opno
index|]
argument_list|,
name|recog_operand
index|[
name|eopno
index|]
argument_list|)
operator|)
operator|&&
operator|!
name|safe_from_earlyclobber
argument_list|(
name|recog_operand
index|[
name|opno
index|]
argument_list|,
name|recog_operand
index|[
name|eopno
index|]
argument_list|)
condition|)
name|lose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|lose
condition|)
block|{
while|while
condition|(
operator|--
name|funny_match_index
operator|>=
literal|0
condition|)
block|{
name|recog_operand
index|[
name|funny_match
index|[
name|funny_match_index
index|]
operator|.
name|other
index|]
operator|=
name|recog_operand
index|[
name|funny_match
index|[
name|funny_match_index
index|]
operator|.
name|this
index|]
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
name|which_alternative
operator|++
expr_stmt|;
block|}
comment|/* If we are about to reject this, but we are not to test strictly,      try a very loose test.  Only return failure if it fails also.  */
if|if
condition|(
name|strict
operator|==
literal|0
condition|)
return|return
name|constrain_operands
argument_list|(
operator|-
literal|1
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 iff OPERAND (assumed to be a REG rtx)    is a hard reg in class CLASS when its regno is offset by OFFSET    and changed to mode MODE.    If REG occupies multiple hard regs, all of them must be in CLASS.  */
end_comment

begin_function
name|int
name|reg_fits_class_p
parameter_list|(
name|operand
parameter_list|,
name|class
parameter_list|,
name|offset
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|operand
decl_stmt|;
specifier|register
name|enum
name|reg_class
name|class
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
operator|+
name|offset
argument_list|)
condition|)
block|{
specifier|register
name|int
name|sr
decl_stmt|;
name|regno
operator|+=
name|offset
expr_stmt|;
for|for
control|(
name|sr
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|-
literal|1
init|;
name|sr
operator|>
literal|0
condition|;
name|sr
operator|--
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
operator|+
name|sr
argument_list|)
condition|)
break|break;
return|return
name|sr
operator|==
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REGISTER_CONSTRAINTS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Do the splitting of insns in the block B. Only try to actually split if    DO_SPLIT is true; otherwise, just remove nops. */
end_comment

begin_function
name|void
name|split_block_insns
parameter_list|(
name|b
parameter_list|,
name|do_split
parameter_list|)
name|int
name|b
decl_stmt|;
name|int
name|do_split
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
init|;
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|rtx
name|set
decl_stmt|;
comment|/* Can't use `next_real_insn' because that          might go across CODE_LABELS and short-out basic blocks.  */
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
condition|)
block|{
if|if
condition|(
name|insn
operator|==
name|BLOCK_END
argument_list|(
name|b
argument_list|)
condition|)
break|break;
continue|continue;
block|}
comment|/* Don't split no-op move insns.  These should silently disappear          later in final.  Splitting such insns would break the code          that handles REG_NO_CONFLICT blocks.  */
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|insn
operator|==
name|BLOCK_END
argument_list|(
name|b
argument_list|)
condition|)
break|break;
comment|/* Nops get in the way while scheduling, so delete them now if 	     register allocation has already been done.  It is too risky 	     to try to do this before register allocation, and there are 	     unlikely to be very many nops then anyways.  */
if|if
condition|(
name|reload_completed
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|do_split
condition|)
block|{
comment|/* Split insns here to get max fine-grain parallelism.  */
name|rtx
name|first
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|notes
init|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|last
init|=
name|try_split
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|last
operator|!=
name|insn
condition|)
block|{
comment|/* try_split returns the NOTE that INSN became.  */
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
name|update_flow_info
argument_list|(
name|notes
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
condition|)
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
operator|=
name|first
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|BLOCK_END
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|=
name|last
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|insn
operator|==
name|BLOCK_END
argument_list|(
name|b
argument_list|)
condition|)
break|break;
block|}
block|}
end_function

end_unit

