begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* List management for the GCC expander.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_function_decl
specifier|static
name|void
name|free_list
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_DEPS_LIST_node
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Functions for maintaining cache-able lists of EXPR_LIST and INSN_LISTs.  */
end_comment

begin_comment
comment|/* An INSN_LIST containing all INSN_LISTs allocated but currently unused.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(deletable)
argument_list|)
name|rtx
name|unused_insn_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* An EXPR_LIST containing all EXPR_LISTs allocated but currently unused.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(deletable)
argument_list|)
name|rtx
name|unused_expr_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* An DEPS_LIST containing all DEPS_LISTs allocated but currently unused.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(deletable)
argument_list|)
name|rtx
name|unused_deps_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This function will free an entire list of either EXPR_LIST, INSN_LIST    or DEPS_LIST nodes.  This is to be used only on lists that consist    exclusively of nodes of one type only.  This is only called by    free_EXPR_LIST_list, free_INSN_LIST_list and free_DEPS_LIST_list.  */
end_comment

begin_function
specifier|static
name|void
name|free_list
parameter_list|(
name|rtx
modifier|*
name|listp
parameter_list|,
name|rtx
modifier|*
name|unused_listp
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|,
name|prev_link
decl_stmt|;
name|prev_link
operator|=
operator|*
name|listp
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|unused_listp
operator|!=
operator|&
name|unused_insn_list
operator|||
name|GET_CODE
argument_list|(
name|prev_link
argument_list|)
operator|==
name|INSN_LIST
operator|)
operator|&&
operator|(
name|unused_listp
operator|!=
operator|&
name|unused_deps_list
operator|||
name|GET_CODE
argument_list|(
name|prev_link
argument_list|)
operator|==
name|DEPS_LIST
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
name|gcc_assert
argument_list|(
operator|(
name|unused_listp
operator|!=
operator|&
name|unused_insn_list
operator|||
name|GET_CODE
argument_list|(
name|prev_link
argument_list|)
operator|==
name|INSN_LIST
operator|)
operator|&&
operator|(
name|unused_listp
operator|!=
operator|&
name|unused_deps_list
operator|||
name|GET_CODE
argument_list|(
name|prev_link
argument_list|)
operator|==
name|DEPS_LIST
operator|)
argument_list|)
expr_stmt|;
name|prev_link
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
operator|=
operator|*
name|unused_listp
expr_stmt|;
operator|*
name|unused_listp
operator|=
operator|*
name|listp
expr_stmt|;
operator|*
name|listp
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find corresponding to ELEM node in the list pointed to by LISTP.    This node must exist in the list.  Returns pointer to that node.  */
end_comment

begin_function
specifier|static
name|rtx
modifier|*
name|find_list_elem
parameter_list|(
name|rtx
name|elem
parameter_list|,
name|rtx
modifier|*
name|listp
parameter_list|)
block|{
while|while
condition|(
name|XEXP
argument_list|(
operator|*
name|listp
argument_list|,
literal|0
argument_list|)
operator|!=
name|elem
condition|)
name|listp
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|listp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|listp
return|;
block|}
end_function

begin_comment
comment|/* Remove the node pointed to by LISTP from the list.  */
end_comment

begin_function
specifier|static
name|void
name|remove_list_node
parameter_list|(
name|rtx
modifier|*
name|listp
parameter_list|)
block|{
name|rtx
name|node
decl_stmt|;
name|node
operator|=
operator|*
name|listp
expr_stmt|;
operator|*
name|listp
operator|=
name|XEXP
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Removes corresponding to ELEM node from the list pointed to by LISTP.    Returns that node.  */
end_comment

begin_function
name|rtx
name|remove_list_elem
parameter_list|(
name|rtx
name|elem
parameter_list|,
name|rtx
modifier|*
name|listp
parameter_list|)
block|{
name|rtx
name|node
decl_stmt|;
name|listp
operator|=
name|find_list_elem
argument_list|(
name|elem
argument_list|,
name|listp
argument_list|)
expr_stmt|;
name|node
operator|=
operator|*
name|listp
expr_stmt|;
name|remove_list_node
argument_list|(
name|listp
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* This call is used in place of a gen_rtx_INSN_LIST. If there is a cached    node available, we'll use it, otherwise a call to gen_rtx_INSN_LIST    is made.  */
end_comment

begin_function
name|rtx
name|alloc_INSN_LIST
parameter_list|(
name|rtx
name|val
parameter_list|,
name|rtx
name|next
parameter_list|)
block|{
name|rtx
name|r
decl_stmt|;
if|if
condition|(
name|unused_insn_list
condition|)
block|{
name|r
operator|=
name|unused_insn_list
expr_stmt|;
name|unused_insn_list
operator|=
name|XEXP
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|=
name|val
expr_stmt|;
name|XEXP
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
operator|=
name|next
expr_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|r
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|INSN_LIST
argument_list|)
expr_stmt|;
block|}
else|else
name|r
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|val
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* This call is used in place of a gen_rtx_EXPR_LIST. If there is a cached    node available, we'll use it, otherwise a call to gen_rtx_EXPR_LIST    is made.  */
end_comment

begin_function
name|rtx
name|alloc_EXPR_LIST
parameter_list|(
name|int
name|kind
parameter_list|,
name|rtx
name|val
parameter_list|,
name|rtx
name|next
parameter_list|)
block|{
name|rtx
name|r
decl_stmt|;
if|if
condition|(
name|unused_expr_list
condition|)
block|{
name|r
operator|=
name|unused_expr_list
expr_stmt|;
name|unused_expr_list
operator|=
name|XEXP
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|=
name|val
expr_stmt|;
name|XEXP
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
operator|=
name|next
expr_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|r
argument_list|,
name|kind
argument_list|)
expr_stmt|;
block|}
else|else
name|r
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|kind
argument_list|,
name|val
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* This call is used in place of a gen_rtx_DEPS_LIST.  If there is a cached    node available, we'll use it, otherwise a call to gen_rtx_DEPS_LIST    is made.  */
end_comment

begin_function
name|rtx
name|alloc_DEPS_LIST
parameter_list|(
name|rtx
name|val
parameter_list|,
name|rtx
name|next
parameter_list|,
name|int
name|ds
parameter_list|)
block|{
name|rtx
name|r
decl_stmt|;
if|if
condition|(
name|unused_deps_list
condition|)
block|{
name|r
operator|=
name|unused_deps_list
expr_stmt|;
name|unused_deps_list
operator|=
name|XEXP
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|=
name|val
expr_stmt|;
name|XEXP
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
operator|=
name|next
expr_stmt|;
name|XINT
argument_list|(
name|r
argument_list|,
literal|2
argument_list|)
operator|=
name|ds
expr_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|r
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|DEPS_LIST
argument_list|)
expr_stmt|;
block|}
else|else
name|r
operator|=
name|gen_rtx_DEPS_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|val
argument_list|,
name|next
argument_list|,
name|ds
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* This function will free up an entire list of EXPR_LIST nodes.  */
end_comment

begin_function
name|void
name|free_EXPR_LIST_list
parameter_list|(
name|rtx
modifier|*
name|listp
parameter_list|)
block|{
if|if
condition|(
operator|*
name|listp
operator|==
literal|0
condition|)
return|return;
name|free_list
argument_list|(
name|listp
argument_list|,
operator|&
name|unused_expr_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function will free up an entire list of INSN_LIST nodes.  */
end_comment

begin_function
name|void
name|free_INSN_LIST_list
parameter_list|(
name|rtx
modifier|*
name|listp
parameter_list|)
block|{
if|if
condition|(
operator|*
name|listp
operator|==
literal|0
condition|)
return|return;
name|free_list
argument_list|(
name|listp
argument_list|,
operator|&
name|unused_insn_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function will free up an entire list of DEPS_LIST nodes.  */
end_comment

begin_function
name|void
name|free_DEPS_LIST_list
parameter_list|(
name|rtx
modifier|*
name|listp
parameter_list|)
block|{
if|if
condition|(
operator|*
name|listp
operator|==
literal|0
condition|)
return|return;
name|free_list
argument_list|(
name|listp
argument_list|,
operator|&
name|unused_deps_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function will free up an individual EXPR_LIST node.  */
end_comment

begin_function
name|void
name|free_EXPR_LIST_node
parameter_list|(
name|rtx
name|ptr
parameter_list|)
block|{
name|XEXP
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_expr_list
expr_stmt|;
name|unused_expr_list
operator|=
name|ptr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function will free up an individual INSN_LIST node.  */
end_comment

begin_function
name|void
name|free_INSN_LIST_node
parameter_list|(
name|rtx
name|ptr
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|ptr
argument_list|)
operator|==
name|INSN_LIST
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_insn_list
expr_stmt|;
name|unused_insn_list
operator|=
name|ptr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function will free up an individual DEPS_LIST node.  */
end_comment

begin_function
specifier|static
name|void
name|free_DEPS_LIST_node
parameter_list|(
name|rtx
name|ptr
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|ptr
argument_list|)
operator|==
name|DEPS_LIST
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_deps_list
expr_stmt|;
name|unused_deps_list
operator|=
name|ptr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove and free corresponding to ELEM node in the DEPS_LIST pointed to    by LISTP.  */
end_comment

begin_function
name|void
name|remove_free_DEPS_LIST_elem
parameter_list|(
name|rtx
name|elem
parameter_list|,
name|rtx
modifier|*
name|listp
parameter_list|)
block|{
name|free_DEPS_LIST_node
argument_list|(
name|remove_list_elem
argument_list|(
name|elem
argument_list|,
name|listp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove and free corresponding to ELEM node in the INSN_LIST pointed to    by LISTP.  */
end_comment

begin_function
name|void
name|remove_free_INSN_LIST_elem
parameter_list|(
name|rtx
name|elem
parameter_list|,
name|rtx
modifier|*
name|listp
parameter_list|)
block|{
name|free_INSN_LIST_node
argument_list|(
name|remove_list_elem
argument_list|(
name|elem
argument_list|,
name|listp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create and return a copy of the DEPS_LIST LIST.  */
end_comment

begin_function
name|rtx
name|copy_DEPS_LIST_list
parameter_list|(
name|rtx
name|list
parameter_list|)
block|{
name|rtx
name|res
init|=
name|NULL_RTX
decl_stmt|,
modifier|*
name|resp
init|=
operator|&
name|res
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
operator|*
name|resp
operator|=
name|alloc_DEPS_LIST
argument_list|(
name|XEXP
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XINT
argument_list|(
name|list
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
operator|*
name|resp
argument_list|,
name|REG_NOTE_KIND
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
name|resp
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|resp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|list
operator|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-lists.h"
end_include

end_unit

