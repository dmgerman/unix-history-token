begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Parse C expressions for CCCP.    Copyright (C) 1987, 92, 94, 95, 97, 98, 1999 Free Software Foundation.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  Written by Per Bothner 1994.  */
end_comment

begin_comment
comment|/* Parse a C expression from text in a string  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
end_ifdef

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|CHAR_TYPE_SIZE
value|BITS_PER_UNIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|INT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|WCHAR_TYPE_SIZE
value|INT_TYPE_SIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_CHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|MAX_CHAR_TYPE_SIZE
value|CHAR_TYPE_SIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_INT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|MAX_INT_TYPE_SIZE
value|INT_TYPE_SIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|MAX_LONG_TYPE_SIZE
value|LONG_TYPE_SIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_WCHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|MAX_WCHAR_TYPE_SIZE
value|WCHAR_TYPE_SIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_CHAR_TYPE_MASK
value|(MAX_CHAR_TYPE_SIZE< HOST_BITS_PER_WIDEST_INT \ 			    ? (~ (~ (HOST_WIDEST_INT) 0<< MAX_CHAR_TYPE_SIZE)) \ 			    : ~ (HOST_WIDEST_INT) 0)
end_define

begin_define
define|#
directive|define
name|MAX_WCHAR_TYPE_MASK
value|(MAX_WCHAR_TYPE_SIZE< HOST_BITS_PER_WIDEST_INT \ 			     ? ~ (~ (HOST_WIDEST_INT) 0<< MAX_WCHAR_TYPE_SIZE) \ 			     : ~ (HOST_WIDEST_INT) 0)
end_define

begin_comment
comment|/* Yield nonzero if adding two numbers with A's and B's signs can yield a    number with SUM's sign, where A, B, and SUM are all C integers.  */
end_comment

begin_define
define|#
directive|define
name|possible_sum_sign
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|sum
parameter_list|)
value|((((a) ^ (b)) | ~ ((a) ^ (sum)))< 0)
end_define

begin_decl_stmt
specifier|static
name|void
name|integer_overflow
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST_WIDEST_INT
name|left_shift
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|HOST_WIDEST_INT
operator|,
name|int
operator|,
name|unsigned
name|HOST_WIDEST_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST_WIDEST_INT
name|right_shift
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|HOST_WIDEST_INT
operator|,
name|int
operator|,
name|unsigned
name|HOST_WIDEST_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ERROR
value|299
end_define

begin_define
define|#
directive|define
name|OROR
value|300
end_define

begin_define
define|#
directive|define
name|ANDAND
value|301
end_define

begin_define
define|#
directive|define
name|EQUAL
value|302
end_define

begin_define
define|#
directive|define
name|NOTEQUAL
value|303
end_define

begin_define
define|#
directive|define
name|LEQ
value|304
end_define

begin_define
define|#
directive|define
name|GEQ
value|305
end_define

begin_define
define|#
directive|define
name|LSH
value|306
end_define

begin_define
define|#
directive|define
name|RSH
value|307
end_define

begin_define
define|#
directive|define
name|NAME
value|308
end_define

begin_define
define|#
directive|define
name|INT
value|309
end_define

begin_define
define|#
directive|define
name|CHAR
value|310
end_define

begin_define
define|#
directive|define
name|LEFT_OPERAND_REQUIRED
value|1
end_define

begin_define
define|#
directive|define
name|RIGHT_OPERAND_REQUIRED
value|2
end_define

begin_define
define|#
directive|define
name|HAVE_VALUE
value|4
end_define

begin_comment
comment|/* SKIP_OPERAND is set for '&&' '||' '?' and ':' when the    following operand should be short-circuited instead of evaluated.  */
end_comment

begin_define
define|#
directive|define
name|SKIP_OPERAND
value|8
end_define

begin_comment
comment|/*#define UNSIGNEDP 16*/
end_comment

begin_struct
struct|struct
name|operation
block|{
name|short
name|op
decl_stmt|;
name|char
name|rprio
decl_stmt|;
comment|/* Priority of op (relative to it right operand).  */
name|char
name|flags
decl_stmt|;
name|char
name|unsignedp
decl_stmt|;
comment|/* true if value should be treated as unsigned */
name|HOST_WIDEST_INT
name|value
decl_stmt|;
comment|/* The value logically "right" of op.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Parse and convert an integer for #if.  Accepts decimal, hex, or octal    with or without size suffixes.  */
end_comment

begin_function
specifier|static
name|struct
name|operation
name|parse_number
parameter_list|(
name|pfile
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|U_CHAR
modifier|*
name|start
decl_stmt|;
name|U_CHAR
modifier|*
name|end
decl_stmt|;
block|{
name|struct
name|operation
name|op
decl_stmt|;
name|U_CHAR
modifier|*
name|p
init|=
name|start
decl_stmt|;
name|int
name|c
decl_stmt|;
name|unsigned
name|HOST_WIDEST_INT
name|n
init|=
literal|0
decl_stmt|,
name|nd
decl_stmt|,
name|MAX_over_base
decl_stmt|;
name|int
name|base
init|=
literal|10
decl_stmt|;
name|int
name|overflow
init|=
literal|0
decl_stmt|;
name|int
name|digit
decl_stmt|,
name|largest_digit
init|=
literal|0
decl_stmt|;
name|int
name|spec_long
init|=
literal|0
decl_stmt|;
name|op
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
name|end
operator|-
name|start
operator|>=
literal|3
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|p
operator|+=
literal|1
expr_stmt|;
name|base
operator|=
literal|8
expr_stmt|;
block|}
block|}
comment|/* Some buggy compilers (e.g. MPW C) seem to need both casts.  */
name|MAX_over_base
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
operator|-
literal|1
operator|)
operator|/
operator|(
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
name|base
operator|)
operator|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|digit
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|==
literal|16
operator|&&
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
comment|/* FIXME: assumes ASCII */
name|digit
operator|=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|==
literal|16
operator|&&
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
name|digit
operator|=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
comment|/* It's a float since it contains a point.  */
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"floating point numbers are not allowed in #if expressions"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
else|else
block|{
comment|/* `l' means long, and `u' means unsigned.  */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'l'
operator|||
name|c
operator|==
literal|'L'
condition|)
name|spec_long
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'u'
operator|||
name|c
operator|==
literal|'U'
condition|)
name|op
operator|.
name|unsignedp
operator|++
expr_stmt|;
else|else
block|{
comment|/* Decrement p here so that the error for an invalid number 		     will be generated below in the case where this is the 		     last character in the buffer.  */
name|p
operator|--
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|==
name|end
condition|)
break|break;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
comment|/* Don't look for any more digits after the suffixes.  */
break|break;
block|}
if|if
condition|(
name|largest_digit
operator|<
name|digit
condition|)
name|largest_digit
operator|=
name|digit
expr_stmt|;
name|nd
operator|=
name|n
operator|*
name|base
operator|+
name|digit
expr_stmt|;
name|overflow
operator||=
name|MAX_over_base
operator|<
name|n
operator|||
name|nd
operator|<
name|n
expr_stmt|;
name|n
operator|=
name|nd
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|end
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"invalid number in #if expression"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|spec_long
operator|>
operator|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|c89
condition|?
literal|1
else|:
literal|2
operator|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"too many `l' suffixes in integer constant"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|op
operator|.
name|unsignedp
operator|>
literal|1
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"too many `u' suffixes in integer constant"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|base
operator|<=
name|largest_digit
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"integer constant contains digits beyond the radix"
argument_list|)
expr_stmt|;
if|if
condition|(
name|overflow
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"integer constant out of range"
argument_list|)
expr_stmt|;
comment|/* If too big to be signed, consider it unsigned.  */
elseif|else
if|if
condition|(
operator|(
name|HOST_WIDEST_INT
operator|)
name|n
operator|<
literal|0
operator|&&
operator|!
name|op
operator|.
name|unsignedp
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|10
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"integer constant is so large that it is unsigned"
argument_list|)
expr_stmt|;
name|op
operator|.
name|unsignedp
operator|=
literal|1
expr_stmt|;
block|}
name|op
operator|.
name|value
operator|=
name|n
expr_stmt|;
name|op
operator|.
name|op
operator|=
name|INT
expr_stmt|;
return|return
name|op
return|;
name|error
label|:
name|op
operator|.
name|op
operator|=
name|ERROR
expr_stmt|;
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/* Parse and convert a character constant for #if.  Understands backslash    escapes (\n, \031) and multibyte characters (if so configured).  */
end_comment

begin_function
specifier|static
name|struct
name|operation
name|parse_charconst
parameter_list|(
name|pfile
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|U_CHAR
modifier|*
name|start
decl_stmt|;
name|U_CHAR
modifier|*
name|end
decl_stmt|;
block|{
name|struct
name|operation
name|op
decl_stmt|;
name|HOST_WIDEST_INT
name|result
init|=
literal|0
decl_stmt|;
name|int
name|num_chars
init|=
literal|0
decl_stmt|;
name|int
name|num_bits
decl_stmt|;
name|unsigned
name|int
name|width
init|=
name|MAX_CHAR_TYPE_SIZE
decl_stmt|,
name|mask
init|=
name|MAX_CHAR_TYPE_MASK
decl_stmt|;
name|int
name|max_chars
decl_stmt|;
name|U_CHAR
modifier|*
name|ptr
init|=
name|start
decl_stmt|;
comment|/* FIXME: Should use reentrant multibyte functions.  */
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|wchar_t
name|c
init|=
operator|(
name|wchar_t
operator|)
operator|-
literal|1
decl_stmt|;
operator|(
name|void
operator|)
name|mbtowc
argument_list|(
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|c
init|=
operator|-
literal|1
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'L'
condition|)
block|{
operator|++
name|ptr
expr_stmt|;
name|width
operator|=
name|MAX_WCHAR_TYPE_SIZE
operator|,
name|mask
operator|=
name|MAX_WCHAR_TYPE_MASK
expr_stmt|;
block|}
name|max_chars
operator|=
name|MAX_LONG_TYPE_SIZE
operator|/
name|width
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
comment|/* skip initial quote */
while|while
condition|(
name|ptr
operator|<
name|end
condition|)
block|{
ifndef|#
directive|ifndef
name|MULTIBYTE_CHARS
name|c
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
else|#
directive|else
name|ptr
operator|+=
name|mbtowc
argument_list|(
operator|&
name|c
argument_list|,
name|ptr
argument_list|,
name|end
operator|-
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'\0'
condition|)
break|break;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* Hopefully valid assumption: if mbtowc returns a backslash, 	     we are in initial shift state.  No valid escape-sequence 	     character can take us out of initial shift state or begin 	     an unshifted multibyte char, so cpp_parse_escape doesn't 	     need to know about multibyte chars.  */
name|c
operator|=
name|cpp_parse_escape
argument_list|(
name|pfile
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|ptr
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
operator|&&
operator|(
name|unsigned
name|int
operator|)
name|c
operator|>=
call|(
name|unsigned
name|int
call|)
argument_list|(
literal|1
operator|<<
name|width
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"escape sequence out of range for character"
argument_list|)
expr_stmt|;
block|}
comment|/* Merge character into result; ignore excess chars.  */
if|if
condition|(
operator|++
name|num_chars
operator|<=
name|max_chars
condition|)
block|{
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
condition|)
name|result
operator|=
operator|(
name|result
operator|<<
name|width
operator|)
operator||
operator|(
name|c
operator|&
operator|(
operator|(
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|result
operator|=
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|num_chars
operator|==
literal|0
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"empty character constant"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\''
condition|)
block|{
comment|/* cpp_get_token has already emitted an error if !traditional. */
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"malformatted character constant"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|num_chars
operator|>
name|max_chars
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"character constant too long"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|num_chars
operator|!=
literal|1
operator|&&
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"multi-character character constant"
argument_list|)
expr_stmt|;
comment|/* If char type is signed, sign-extend the constant.  */
name|num_bits
operator|=
name|num_chars
operator|*
name|width
expr_stmt|;
if|if
condition|(
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__CHAR_UNSIGNED__"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"__CHAR_UNSIGNED__"
argument_list|)
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|||
operator|(
operator|(
name|result
operator|>>
operator|(
name|num_bits
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|op
operator|.
name|value
operator|=
name|result
operator|&
operator|(
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
operator|~
literal|0
operator|>>
operator|(
name|HOST_BITS_PER_WIDEST_INT
operator|-
name|num_bits
operator|)
operator|)
expr_stmt|;
else|else
name|op
operator|.
name|value
operator|=
name|result
operator||
operator|~
operator|(
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
operator|~
literal|0
operator|>>
operator|(
name|HOST_BITS_PER_WIDEST_INT
operator|-
name|num_bits
operator|)
operator|)
expr_stmt|;
comment|/* This is always a signed type.  */
name|op
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
name|op
operator|.
name|op
operator|=
name|CHAR
expr_stmt|;
return|return
name|op
return|;
name|error
label|:
name|op
operator|.
name|op
operator|=
name|ERROR
expr_stmt|;
return|return
name|op
return|;
block|}
end_function

begin_struct
struct|struct
name|token
block|{
name|char
modifier|*
name|operator
decl_stmt|;
name|int
name|token
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|token
name|tokentab2
index|[]
init|=
block|{
block|{
literal|"&&"
block|,
name|ANDAND
block|}
block|,
block|{
literal|"||"
block|,
name|OROR
block|}
block|,
block|{
literal|"<<"
block|,
name|LSH
block|}
block|,
block|{
literal|">>"
block|,
name|RSH
block|}
block|,
block|{
literal|"=="
block|,
name|EQUAL
block|}
block|,
block|{
literal|"!="
block|,
name|NOTEQUAL
block|}
block|,
block|{
literal|"<="
block|,
name|LEQ
block|}
block|,
block|{
literal|">="
block|,
name|GEQ
block|}
block|,
block|{
literal|"++"
block|,
name|ERROR
block|}
block|,
block|{
literal|"--"
block|,
name|ERROR
block|}
block|,
block|{
name|NULL
block|,
name|ERROR
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read one token.  */
end_comment

begin_function
specifier|static
name|struct
name|operation
name|cpp_lex
parameter_list|(
name|pfile
parameter_list|,
name|skip_evaluation
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|skip_evaluation
decl_stmt|;
block|{
name|U_CHAR
name|c
decl_stmt|;
name|struct
name|token
modifier|*
name|toktab
decl_stmt|;
name|enum
name|cpp_token
name|token
decl_stmt|;
name|struct
name|operation
name|op
decl_stmt|;
name|U_CHAR
modifier|*
name|tok_start
decl_stmt|,
modifier|*
name|tok_end
decl_stmt|;
name|int
name|old_written
decl_stmt|;
name|retry
label|:
name|old_written
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|CPP_BUF_PEEK
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
name|op
operator|.
name|op
operator|=
name|INT
expr_stmt|;
name|op
operator|.
name|value
operator|=
name|cpp_read_check_assertion
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|op
operator|.
name|op
operator|=
literal|0
expr_stmt|;
return|return
name|op
return|;
block|}
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|tok_start
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|old_written
expr_stmt|;
name|tok_end
operator|=
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|limit
operator|=
name|tok_start
expr_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|CPP_EOF
case|:
comment|/* Should not happen ...  */
case|case
name|CPP_VSPACE
case|:
name|op
operator|.
name|op
operator|=
literal|0
expr_stmt|;
return|return
name|op
return|;
case|case
name|CPP_POP
case|:
if|if
condition|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|fname
operator|!=
name|NULL
condition|)
block|{
name|op
operator|.
name|op
operator|=
literal|0
expr_stmt|;
return|return
name|op
return|;
block|}
name|cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
name|CPP_HSPACE
case|:
case|case
name|CPP_COMMENT
case|:
goto|goto
name|retry
goto|;
case|case
name|CPP_NUMBER
case|:
return|return
name|parse_number
argument_list|(
name|pfile
argument_list|,
name|tok_start
argument_list|,
name|tok_end
argument_list|)
return|;
case|case
name|CPP_STRING
case|:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"string constants not allowed in #if expressions"
argument_list|)
expr_stmt|;
name|op
operator|.
name|op
operator|=
name|ERROR
expr_stmt|;
return|return
name|op
return|;
case|case
name|CPP_CHAR
case|:
return|return
name|parse_charconst
argument_list|(
name|pfile
argument_list|,
name|tok_start
argument_list|,
name|tok_end
argument_list|)
return|;
case|case
name|CPP_NAME
case|:
name|op
operator|.
name|op
operator|=
name|INT
expr_stmt|;
name|op
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
name|op
operator|.
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|tok_start
argument_list|,
literal|"defined"
argument_list|)
condition|)
block|{
if|if
condition|(
name|CPP_WARN_UNDEF
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|skip_evaluation
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"`%.*s' is not defined"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|tok_end
operator|-
name|tok_start
argument_list|)
argument_list|,
name|tok_start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|paren
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
name|cpp_buffer
modifier|*
name|ip
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|U_CHAR
modifier|*
name|tok
decl_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ip
operator|->
name|cur
operator|==
literal|'('
condition|)
block|{
name|paren
operator|++
expr_stmt|;
name|ip
operator|->
name|cur
operator|++
expr_stmt|;
comment|/* Skip over the paren */
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|ip
operator|->
name|cur
index|]
condition|)
goto|goto
name|oops
goto|;
if|if
condition|(
name|ip
operator|->
name|cur
index|[
literal|0
index|]
operator|==
literal|'L'
operator|&&
operator|(
name|ip
operator|->
name|cur
index|[
literal|1
index|]
operator|==
literal|'\''
operator|||
name|ip
operator|->
name|cur
index|[
literal|1
index|]
operator|==
literal|'"'
operator|)
condition|)
goto|goto
name|oops
goto|;
name|tok
operator|=
name|ip
operator|->
name|cur
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|ip
operator|->
name|cur
index|]
condition|)
operator|++
name|ip
operator|->
name|cur
expr_stmt|;
name|len
operator|=
name|ip
operator|->
name|cur
operator|-
name|tok
expr_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
operator|*
name|ip
operator|->
name|cur
operator|!=
literal|')'
condition|)
goto|goto
name|oops
goto|;
operator|++
name|ip
operator|->
name|cur
expr_stmt|;
block|}
if|if
condition|(
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|tok
argument_list|,
name|len
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|op
operator|.
name|value
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|op
return|;
name|oops
label|:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`defined' without an identifier"
argument_list|)
expr_stmt|;
return|return
name|op
return|;
case|case
name|CPP_OTHER
case|:
comment|/* See if it is a special token of length 2.  */
if|if
condition|(
name|tok_start
operator|+
literal|2
operator|==
name|tok_end
condition|)
block|{
for|for
control|(
name|toktab
operator|=
name|tokentab2
init|;
name|toktab
operator|->
name|operator
operator|!=
name|NULL
condition|;
name|toktab
operator|++
control|)
if|if
condition|(
name|tok_start
index|[
literal|0
index|]
operator|==
name|toktab
operator|->
name|operator
index|[
literal|0
index|]
operator|&&
name|tok_start
index|[
literal|1
index|]
operator|==
name|toktab
operator|->
name|operator
index|[
literal|1
index|]
condition|)
break|break;
if|if
condition|(
name|toktab
operator|->
name|token
operator|==
name|ERROR
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`%s' not allowed in operand of `#if'"
argument_list|,
name|tok_start
argument_list|)
expr_stmt|;
name|op
operator|.
name|op
operator|=
name|toktab
operator|->
name|token
expr_stmt|;
return|return
name|op
return|;
block|}
comment|/* fall through */
default|default:
name|op
operator|.
name|op
operator|=
operator|*
name|tok_start
expr_stmt|;
return|return
name|op
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a C escape sequence.  STRING_PTR points to a variable    containing a pointer to the string to parse.  That pointer    is updated past the characters we use.  The value of the    escape sequence is returned.     A negative value means the sequence \ newline was seen,    which is supposed to be equivalent to nothing at all.     If \ is followed by a null character, we return a negative    value and leave the string pointer pointing at the null character.     If \ is followed by 000, we return 0 and leave the string pointer    after the zeros.  A value of 0 does not mean end of string.  */
end_comment

begin_function
name|HOST_WIDEST_INT
name|cpp_parse_escape
parameter_list|(
name|pfile
parameter_list|,
name|string_ptr
parameter_list|,
name|result_mask
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
modifier|*
name|string_ptr
decl_stmt|;
name|HOST_WIDEST_INT
name|result_mask
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
return|return
name|TARGET_BELL
return|;
case|case
literal|'b'
case|:
return|return
name|TARGET_BS
return|;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|pedantic
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"non-ANSI-standard escape sequence, `\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
literal|033
return|;
case|case
literal|'f'
case|:
return|return
name|TARGET_FF
return|;
case|case
literal|'n'
case|:
return|return
name|TARGET_NEWLINE
return|;
case|case
literal|'r'
case|:
return|return
name|TARGET_CR
return|;
case|case
literal|'t'
case|:
return|return
name|TARGET_TAB
return|;
case|case
literal|'v'
case|:
return|return
name|TARGET_VT
return|;
case|case
literal|'\n'
case|:
return|return
operator|-
literal|2
return|;
case|case
literal|0
case|:
operator|(
operator|*
name|string_ptr
operator|)
operator|--
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
specifier|register
name|HOST_WIDEST_INT
name|i
init|=
name|c
operator|-
literal|'0'
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|++
name|count
operator|<
literal|3
condition|)
block|{
name|c
operator|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'7'
condition|)
name|i
operator|=
operator|(
name|i
operator|<<
literal|3
operator|)
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
else|else
block|{
operator|(
operator|*
name|string_ptr
operator|)
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|!=
operator|(
name|i
operator|&
name|result_mask
operator|)
condition|)
block|{
name|i
operator|&=
name|result_mask
expr_stmt|;
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"octal escape sequence out of range"
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
case|case
literal|'x'
case|:
block|{
specifier|register
name|unsigned
name|HOST_WIDEST_INT
name|i
init|=
literal|0
decl_stmt|,
name|overflow
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|digits_found
init|=
literal|0
decl_stmt|,
name|digit
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|digit
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
name|digit
operator|=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
name|digit
operator|=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
block|{
operator|(
operator|*
name|string_ptr
operator|)
operator|--
expr_stmt|;
break|break;
block|}
name|overflow
operator||=
name|i
operator|^
operator|(
name|i
operator|<<
literal|4
operator|>>
literal|4
operator|)
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|<<
literal|4
operator|)
operator|+
name|digit
expr_stmt|;
name|digits_found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|digits_found
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"\\x used with no following hex digits"
argument_list|)
expr_stmt|;
if|if
condition|(
name|overflow
operator||
operator|(
name|i
operator|!=
operator|(
name|i
operator|&
name|result_mask
operator|)
operator|)
condition|)
block|{
name|i
operator|&=
name|result_mask
expr_stmt|;
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"hex escape sequence out of range"
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
default|default:
return|return
name|c
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|integer_overflow
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"integer overflow in preprocessor expression"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|HOST_WIDEST_INT
name|left_shift
parameter_list|(
name|pfile
parameter_list|,
name|a
parameter_list|,
name|unsignedp
parameter_list|,
name|b
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|HOST_WIDEST_INT
name|a
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|unsigned
name|HOST_WIDEST_INT
name|b
decl_stmt|;
block|{
if|if
condition|(
name|b
operator|>=
name|HOST_BITS_PER_WIDEST_INT
condition|)
block|{
if|if
condition|(
operator|!
name|unsignedp
operator|&&
name|a
operator|!=
literal|0
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|unsignedp
condition|)
return|return
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
name|a
operator|<<
name|b
return|;
else|else
block|{
name|HOST_WIDEST_INT
name|l
init|=
name|a
operator|<<
name|b
decl_stmt|;
if|if
condition|(
name|l
operator|>>
name|b
operator|!=
name|a
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|HOST_WIDEST_INT
name|right_shift
parameter_list|(
name|pfile
parameter_list|,
name|a
parameter_list|,
name|unsignedp
parameter_list|,
name|b
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|HOST_WIDEST_INT
name|a
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|unsigned
name|HOST_WIDEST_INT
name|b
decl_stmt|;
block|{
if|if
condition|(
name|b
operator|>=
name|HOST_BITS_PER_WIDEST_INT
condition|)
return|return
name|unsignedp
condition|?
literal|0
else|:
name|a
operator|>>
operator|(
name|HOST_BITS_PER_WIDEST_INT
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|unsignedp
condition|)
return|return
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
name|a
operator|>>
name|b
return|;
else|else
return|return
name|a
operator|>>
name|b
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These priorities are all even, so we can handle associatively.  */
end_comment

begin_define
define|#
directive|define
name|PAREN_INNER_PRIO
value|0
end_define

begin_define
define|#
directive|define
name|COMMA_PRIO
value|4
end_define

begin_define
define|#
directive|define
name|COND_PRIO
value|(COMMA_PRIO+2)
end_define

begin_define
define|#
directive|define
name|OROR_PRIO
value|(COND_PRIO+2)
end_define

begin_define
define|#
directive|define
name|ANDAND_PRIO
value|(OROR_PRIO+2)
end_define

begin_define
define|#
directive|define
name|OR_PRIO
value|(ANDAND_PRIO+2)
end_define

begin_define
define|#
directive|define
name|XOR_PRIO
value|(OR_PRIO+2)
end_define

begin_define
define|#
directive|define
name|AND_PRIO
value|(XOR_PRIO+2)
end_define

begin_define
define|#
directive|define
name|EQUAL_PRIO
value|(AND_PRIO+2)
end_define

begin_define
define|#
directive|define
name|LESS_PRIO
value|(EQUAL_PRIO+2)
end_define

begin_define
define|#
directive|define
name|SHIFT_PRIO
value|(LESS_PRIO+2)
end_define

begin_define
define|#
directive|define
name|PLUS_PRIO
value|(SHIFT_PRIO+2)
end_define

begin_define
define|#
directive|define
name|MUL_PRIO
value|(PLUS_PRIO+2)
end_define

begin_define
define|#
directive|define
name|UNARY_PRIO
value|(MUL_PRIO+2)
end_define

begin_define
define|#
directive|define
name|PAREN_OUTER_PRIO
value|(UNARY_PRIO+2)
end_define

begin_define
define|#
directive|define
name|COMPARE
parameter_list|(
name|OP
parameter_list|)
define|\
value|top->unsignedp = 0;\   top->value = (unsigned1 || unsigned2) \   ? (unsigned HOST_WIDEST_INT) v1 OP (unsigned HOST_WIDEST_INT) v2 : (v1 OP v2)
end_define

begin_comment
comment|/* Parse and evaluate a C expression, reading from PFILE.    Returns the value of the expression.  */
end_comment

begin_function
name|HOST_WIDEST_INT
name|cpp_parse_expr
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
comment|/* The implementation is an operator precedence parser,      i.e. a bottom-up parser, using a stack for not-yet-reduced tokens.       The stack base is 'stack', and the current stack pointer is 'top'.      There is a stack element for each operator (only),      and the most recently pushed operator is 'top->op'.      An operand (value) is stored in the 'value' field of the stack      element of the operator that precedes it.      In that case the 'flags' field has the HAVE_VALUE flag set.  */
define|#
directive|define
name|INIT_STACK_SIZE
value|20
name|struct
name|operation
name|init_stack
index|[
name|INIT_STACK_SIZE
index|]
decl_stmt|;
name|struct
name|operation
modifier|*
name|stack
init|=
name|init_stack
decl_stmt|;
name|struct
name|operation
modifier|*
name|limit
init|=
name|stack
operator|+
name|INIT_STACK_SIZE
decl_stmt|;
specifier|register
name|struct
name|operation
modifier|*
name|top
init|=
name|stack
decl_stmt|;
name|int
name|lprio
decl_stmt|,
name|rprio
init|=
literal|0
decl_stmt|;
name|int
name|skip_evaluation
init|=
literal|0
decl_stmt|;
name|top
operator|->
name|rprio
operator|=
literal|0
expr_stmt|;
name|top
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|operation
name|op
decl_stmt|;
name|char
name|flags
init|=
literal|0
decl_stmt|;
comment|/* Read a token */
name|op
operator|=
name|cpp_lex
argument_list|(
name|pfile
argument_list|,
name|skip_evaluation
argument_list|)
expr_stmt|;
comment|/* See if the token is an operand, in which case go to set_value. 	 If the token is an operator, figure out its left and right 	 priorities, and then goto maybe_reduce.  */
switch|switch
condition|(
name|op
operator|.
name|op
condition|)
block|{
case|case
name|NAME
case|:
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"internal error: cpp_lex returns a NAME"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
case|case
name|INT
case|:
case|case
name|CHAR
case|:
name|top
operator|->
name|value
operator|=
name|op
operator|.
name|value
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|op
operator|.
name|unsignedp
expr_stmt|;
goto|goto
name|set_value
goto|;
case|case
literal|0
case|:
name|lprio
operator|=
literal|0
expr_stmt|;
goto|goto
name|maybe_reduce
goto|;
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
comment|/* Is this correct if unary ? FIXME */
name|flags
operator|=
name|RIGHT_OPERAND_REQUIRED
expr_stmt|;
name|lprio
operator|=
name|PLUS_PRIO
expr_stmt|;
name|rprio
operator|=
name|lprio
operator|+
literal|1
expr_stmt|;
goto|goto
name|maybe_reduce
goto|;
case|case
literal|'!'
case|:
case|case
literal|'~'
case|:
name|flags
operator|=
name|RIGHT_OPERAND_REQUIRED
expr_stmt|;
name|rprio
operator|=
name|UNARY_PRIO
expr_stmt|;
name|lprio
operator|=
name|rprio
operator|+
literal|1
expr_stmt|;
goto|goto
name|maybe_reduce
goto|;
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
case|case
literal|'%'
case|:
name|lprio
operator|=
name|MUL_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
name|LEQ
case|:
case|case
name|GEQ
case|:
name|lprio
operator|=
name|LESS_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|EQUAL
case|:
case|case
name|NOTEQUAL
case|:
name|lprio
operator|=
name|EQUAL_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|LSH
case|:
case|case
name|RSH
case|:
name|lprio
operator|=
name|SHIFT_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
literal|'&'
case|:
name|lprio
operator|=
name|AND_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
literal|'^'
case|:
name|lprio
operator|=
name|XOR_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
literal|'|'
case|:
name|lprio
operator|=
name|OR_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|ANDAND
case|:
name|lprio
operator|=
name|ANDAND_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|OROR
case|:
name|lprio
operator|=
name|OROR_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
literal|','
case|:
name|lprio
operator|=
name|COMMA_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
literal|'('
case|:
name|lprio
operator|=
name|PAREN_OUTER_PRIO
expr_stmt|;
name|rprio
operator|=
name|PAREN_INNER_PRIO
expr_stmt|;
goto|goto
name|maybe_reduce
goto|;
case|case
literal|')'
case|:
name|lprio
operator|=
name|PAREN_INNER_PRIO
expr_stmt|;
name|rprio
operator|=
name|PAREN_OUTER_PRIO
expr_stmt|;
goto|goto
name|maybe_reduce
goto|;
case|case
literal|':'
case|:
name|lprio
operator|=
name|COND_PRIO
expr_stmt|;
name|rprio
operator|=
name|COND_PRIO
expr_stmt|;
goto|goto
name|maybe_reduce
goto|;
case|case
literal|'?'
case|:
name|lprio
operator|=
name|COND_PRIO
operator|+
literal|1
expr_stmt|;
name|rprio
operator|=
name|COND_PRIO
expr_stmt|;
goto|goto
name|maybe_reduce
goto|;
case|case
name|ERROR
case|:
goto|goto
name|syntax_error
goto|;
name|binop
label|:
name|flags
operator|=
name|LEFT_OPERAND_REQUIRED
operator||
name|RIGHT_OPERAND_REQUIRED
expr_stmt|;
name|rprio
operator|=
name|lprio
operator|+
literal|1
expr_stmt|;
goto|goto
name|maybe_reduce
goto|;
default|default:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"invalid character in #if"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
block|}
name|set_value
label|:
comment|/* Push a value onto the stack.  */
if|if
condition|(
name|top
operator|->
name|flags
operator|&
name|HAVE_VALUE
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"syntax error in #if"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
block|}
name|top
operator|->
name|flags
operator||=
name|HAVE_VALUE
expr_stmt|;
continue|continue;
name|maybe_reduce
label|:
comment|/* Push an operator, and check if we can reduce now.  */
while|while
condition|(
name|top
operator|->
name|rprio
operator|>
name|lprio
condition|)
block|{
name|HOST_WIDEST_INT
name|v1
init|=
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
decl_stmt|,
name|v2
init|=
name|top
index|[
literal|0
index|]
operator|.
name|value
decl_stmt|;
name|int
name|unsigned1
init|=
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|unsignedp
decl_stmt|,
name|unsigned2
init|=
name|top
index|[
literal|0
index|]
operator|.
name|unsignedp
decl_stmt|;
name|top
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|top
index|[
literal|1
index|]
operator|.
name|flags
operator|&
name|LEFT_OPERAND_REQUIRED
operator|)
operator|&&
operator|!
operator|(
name|top
index|[
literal|0
index|]
operator|.
name|flags
operator|&
name|HAVE_VALUE
operator|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"syntax error - missing left operand"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
block|}
if|if
condition|(
operator|(
name|top
index|[
literal|1
index|]
operator|.
name|flags
operator|&
name|RIGHT_OPERAND_REQUIRED
operator|)
operator|&&
operator|!
operator|(
name|top
index|[
literal|1
index|]
operator|.
name|flags
operator|&
name|HAVE_VALUE
operator|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"syntax error - missing right operand"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
block|}
comment|/* top[0].value = (top[1].op)(v1, v2);*/
switch|switch
condition|(
name|top
index|[
literal|1
index|]
operator|.
name|op
condition|)
block|{
case|case
literal|'+'
case|:
if|if
condition|(
operator|!
operator|(
name|top
operator|->
name|flags
operator|&
name|HAVE_VALUE
operator|)
condition|)
block|{
comment|/* Unary '+' */
name|top
operator|->
name|value
operator|=
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned2
expr_stmt|;
name|top
operator|->
name|flags
operator||=
name|HAVE_VALUE
expr_stmt|;
block|}
else|else
block|{
name|top
operator|->
name|value
operator|=
name|v1
operator|+
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
operator|||
name|unsigned2
expr_stmt|;
if|if
condition|(
operator|!
name|top
operator|->
name|unsignedp
operator|&&
operator|!
name|skip_evaluation
operator|&&
operator|!
name|possible_sum_sign
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
name|top
operator|->
name|value
argument_list|)
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
operator|!
operator|(
name|top
operator|->
name|flags
operator|&
name|HAVE_VALUE
operator|)
condition|)
block|{
comment|/* Unary '-' */
name|top
operator|->
name|value
operator|=
operator|-
name|v2
expr_stmt|;
if|if
condition|(
operator|!
name|skip_evaluation
operator|&&
operator|(
name|top
operator|->
name|value
operator|&
name|v2
operator|)
operator|<
literal|0
operator|&&
operator|!
name|unsigned2
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned2
expr_stmt|;
name|top
operator|->
name|flags
operator||=
name|HAVE_VALUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Binary '-' */
name|top
operator|->
name|value
operator|=
name|v1
operator|-
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
operator|||
name|unsigned2
expr_stmt|;
if|if
condition|(
operator|!
name|top
operator|->
name|unsignedp
operator|&&
operator|!
name|skip_evaluation
operator|&&
operator|!
name|possible_sum_sign
argument_list|(
name|top
operator|->
name|value
argument_list|,
name|v2
argument_list|,
name|v1
argument_list|)
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'*'
case|:
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
operator|||
name|unsigned2
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|unsignedp
condition|)
name|top
operator|->
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
name|v1
operator|*
name|v2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|skip_evaluation
condition|)
block|{
name|top
operator|->
name|value
operator|=
name|v1
operator|*
name|v2
expr_stmt|;
if|if
condition|(
name|v1
operator|&&
operator|(
name|top
operator|->
name|value
operator|/
name|v1
operator|!=
name|v2
operator|||
operator|(
name|top
operator|->
name|value
operator|&
name|v1
operator|&
name|v2
operator|)
operator|<
literal|0
operator|)
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|skip_evaluation
condition|)
break|break;
if|if
condition|(
name|v2
operator|==
literal|0
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"division by zero in #if"
argument_list|)
expr_stmt|;
name|v2
operator|=
literal|1
expr_stmt|;
block|}
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
operator|||
name|unsigned2
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|unsignedp
condition|)
name|top
operator|->
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
name|v1
operator|/
name|v2
expr_stmt|;
else|else
block|{
name|top
operator|->
name|value
operator|=
name|v1
operator|/
name|v2
expr_stmt|;
if|if
condition|(
operator|(
name|top
operator|->
name|value
operator|&
name|v1
operator|&
name|v2
operator|)
operator|<
literal|0
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
name|skip_evaluation
condition|)
break|break;
if|if
condition|(
name|v2
operator|==
literal|0
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"division by zero in #if"
argument_list|)
expr_stmt|;
name|v2
operator|=
literal|1
expr_stmt|;
block|}
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
operator|||
name|unsigned2
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|unsignedp
condition|)
name|top
operator|->
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
name|v1
operator|%
name|v2
expr_stmt|;
else|else
name|top
operator|->
name|value
operator|=
name|v1
operator|%
name|v2
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
if|if
condition|(
name|top
operator|->
name|flags
operator|&
name|HAVE_VALUE
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"syntax error"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
block|}
name|top
operator|->
name|value
operator|=
operator|!
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
literal|0
expr_stmt|;
name|top
operator|->
name|flags
operator||=
name|HAVE_VALUE
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
if|if
condition|(
name|top
operator|->
name|flags
operator|&
name|HAVE_VALUE
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"syntax error"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
block|}
name|top
operator|->
name|value
operator|=
operator|~
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned2
expr_stmt|;
name|top
operator|->
name|flags
operator||=
name|HAVE_VALUE
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|COMPARE
argument_list|(
operator|<
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|COMPARE
argument_list|(
operator|>
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEQ
case|:
name|COMPARE
argument_list|(
operator|<=
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEQ
case|:
name|COMPARE
argument_list|(
operator|>=
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQUAL
case|:
name|top
operator|->
name|value
operator|=
operator|(
name|v1
operator|==
name|v2
operator|)
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NOTEQUAL
case|:
name|top
operator|->
name|value
operator|=
operator|(
name|v1
operator|!=
name|v2
operator|)
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LSH
case|:
if|if
condition|(
name|skip_evaluation
condition|)
break|break;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
expr_stmt|;
if|if
condition|(
name|v2
operator|<
literal|0
operator|&&
operator|!
name|unsigned2
condition|)
name|top
operator|->
name|value
operator|=
name|right_shift
argument_list|(
name|pfile
argument_list|,
name|v1
argument_list|,
name|unsigned1
argument_list|,
operator|-
name|v2
argument_list|)
expr_stmt|;
else|else
name|top
operator|->
name|value
operator|=
name|left_shift
argument_list|(
name|pfile
argument_list|,
name|v1
argument_list|,
name|unsigned1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSH
case|:
if|if
condition|(
name|skip_evaluation
condition|)
break|break;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
expr_stmt|;
if|if
condition|(
name|v2
operator|<
literal|0
operator|&&
operator|!
name|unsigned2
condition|)
name|top
operator|->
name|value
operator|=
name|left_shift
argument_list|(
name|pfile
argument_list|,
name|v1
argument_list|,
name|unsigned1
argument_list|,
operator|-
name|v2
argument_list|)
expr_stmt|;
else|else
name|top
operator|->
name|value
operator|=
name|right_shift
argument_list|(
name|pfile
argument_list|,
name|v1
argument_list|,
name|unsigned1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
break|break;
define|#
directive|define
name|LOGICAL
parameter_list|(
name|OP
parameter_list|)
define|\
value|top->value = v1 OP v2;\ 	      top->unsignedp = unsigned1 || unsigned2;
case|case
literal|'&'
case|:
name|LOGICAL
argument_list|(
operator|&
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|LOGICAL
argument_list|(
operator|^
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|LOGICAL
argument_list|(
operator||
argument_list|)
expr_stmt|;
break|break;
case|case
name|ANDAND
case|:
name|top
operator|->
name|value
operator|=
name|v1
operator|&&
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|v1
condition|)
name|skip_evaluation
operator|--
expr_stmt|;
break|break;
case|case
name|OROR
case|:
name|top
operator|->
name|value
operator|=
name|v1
operator|||
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v1
condition|)
name|skip_evaluation
operator|--
expr_stmt|;
break|break;
case|case
literal|','
case|:
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"comma operator in operand of `#if'"
argument_list|)
expr_stmt|;
name|top
operator|->
name|value
operator|=
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned2
expr_stmt|;
break|break;
case|case
literal|'('
case|:
case|case
literal|'?'
case|:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"syntax error in #if"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
case|case
literal|':'
case|:
if|if
condition|(
name|top
index|[
literal|0
index|]
operator|.
name|op
operator|!=
literal|'?'
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"syntax error ':' without preceding '?'"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|top
index|[
literal|1
index|]
operator|.
name|flags
operator|&
name|HAVE_VALUE
operator|)
operator|||
operator|!
operator|(
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|flags
operator|&
name|HAVE_VALUE
operator|)
operator|||
operator|!
operator|(
name|top
index|[
literal|0
index|]
operator|.
name|flags
operator|&
name|HAVE_VALUE
operator|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"bad syntax for ?: operator"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
block|}
else|else
block|{
name|top
operator|--
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|value
condition|)
name|skip_evaluation
operator|--
expr_stmt|;
name|top
operator|->
name|value
operator|=
name|top
operator|->
name|value
condition|?
name|v1
else|:
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
operator|||
name|unsigned2
expr_stmt|;
block|}
break|break;
case|case
literal|')'
case|:
if|if
condition|(
operator|(
name|top
index|[
literal|1
index|]
operator|.
name|flags
operator|&
name|HAVE_VALUE
operator|)
operator|||
operator|!
operator|(
name|top
index|[
literal|0
index|]
operator|.
name|flags
operator|&
name|HAVE_VALUE
operator|)
operator|||
name|top
index|[
literal|0
index|]
operator|.
name|op
operator|!=
literal|'('
operator|||
operator|(
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|flags
operator|&
name|HAVE_VALUE
operator|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"mismatched parentheses in #if"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
block|}
else|else
block|{
name|top
operator|--
expr_stmt|;
name|top
operator|->
name|value
operator|=
name|v1
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
expr_stmt|;
name|top
operator|->
name|flags
operator||=
name|HAVE_VALUE
expr_stmt|;
block|}
break|break;
default|default:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
operator|(
name|top
index|[
literal|1
index|]
operator|.
name|op
operator|>=
literal|' '
operator|&&
name|top
index|[
literal|1
index|]
operator|.
name|op
operator|<=
literal|'~'
condition|?
literal|"unimplemented operator '%c'\n"
else|:
literal|"unimplemented operator '\\%03o'\n"
operator|)
argument_list|,
name|top
index|[
literal|1
index|]
operator|.
name|op
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op
operator|.
name|op
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|top
operator|!=
name|stack
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"internal error in #if expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|!=
name|init_stack
condition|)
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
return|return
name|top
operator|->
name|value
return|;
block|}
name|top
operator|++
expr_stmt|;
comment|/* Check for and handle stack overflow.  */
if|if
condition|(
name|top
operator|==
name|limit
condition|)
block|{
name|struct
name|operation
modifier|*
name|new_stack
decl_stmt|;
name|int
name|old_size
init|=
operator|(
name|char
operator|*
operator|)
name|limit
operator|-
operator|(
name|char
operator|*
operator|)
name|stack
decl_stmt|;
name|int
name|new_size
init|=
literal|2
operator|*
name|old_size
decl_stmt|;
if|if
condition|(
name|stack
operator|!=
name|init_stack
condition|)
name|new_stack
operator|=
operator|(
expr|struct
name|operation
operator|*
operator|)
name|xrealloc
argument_list|(
name|stack
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
else|else
block|{
name|new_stack
operator|=
operator|(
expr|struct
name|operation
operator|*
operator|)
name|xmalloc
argument_list|(
name|new_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|stack
argument_list|,
operator|(
name|char
operator|*
operator|)
name|new_stack
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
block|}
name|stack
operator|=
name|new_stack
expr_stmt|;
name|top
operator|=
operator|(
expr|struct
name|operation
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|new_stack
operator|+
name|old_size
operator|)
expr_stmt|;
name|limit
operator|=
operator|(
expr|struct
name|operation
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|new_stack
operator|+
name|new_size
operator|)
expr_stmt|;
block|}
name|top
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|top
operator|->
name|rprio
operator|=
name|rprio
expr_stmt|;
name|top
operator|->
name|op
operator|=
name|op
operator|.
name|op
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|.
name|op
operator|==
name|OROR
operator|&&
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|)
operator|||
operator|(
name|op
operator|.
name|op
operator|==
name|ANDAND
operator|&&
operator|!
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|)
operator|||
operator|(
name|op
operator|.
name|op
operator|==
literal|'?'
operator|&&
operator|!
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|)
condition|)
block|{
name|skip_evaluation
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|.
name|op
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|top
index|[
operator|-
literal|2
index|]
operator|.
name|value
condition|)
comment|/* Was condition true? */
name|skip_evaluation
operator|++
expr_stmt|;
else|else
name|skip_evaluation
operator|--
expr_stmt|;
block|}
block|}
name|syntax_error
label|:
if|if
condition|(
name|stack
operator|!=
name|init_stack
condition|)
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

