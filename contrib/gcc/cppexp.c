begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Parse C expressions for cpplib.    Copyright (C) 1987, 1992, 1994, 1995, 1997, 1998, 1999, 2000, 2001,    2002 Free Software Foundation.    Contributed by Per Bothner, 1994.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"cpphash.h"
end_include

begin_comment
comment|/* Yield nonzero if adding two numbers with A's and B's signs can yield a    number with SUM's sign, where A, B, and SUM are all C integers.  */
end_comment

begin_define
define|#
directive|define
name|possible_sum_sign
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|sum
parameter_list|)
value|((((a) ^ (b)) | ~ ((a) ^ (sum)))< 0)
end_define

begin_decl_stmt
specifier|static
name|void
name|integer_overflow
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST_WIDEST_INT
name|left_shift
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|HOST_WIDEST_INT
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|HOST_WIDEST_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST_WIDEST_INT
name|right_shift
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|HOST_WIDEST_INT
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|HOST_WIDEST_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|op
name|parse_number
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|cpp_token
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|op
name|parse_defined
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|op
name|lex
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|op_as_text
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|enum
name|cpp_ttype
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|op
block|{
name|enum
name|cpp_ttype
name|op
decl_stmt|;
name|U_CHAR
name|prio
decl_stmt|;
comment|/* Priority of op.  */
name|U_CHAR
name|flags
decl_stmt|;
name|U_CHAR
name|unsignedp
decl_stmt|;
comment|/* True if value should be treated as unsigned.  */
name|HOST_WIDEST_INT
name|value
decl_stmt|;
comment|/* The value logically "right" of op.  */
block|}
struct|;
end_struct

begin_comment
comment|/* There is no "error" token, but we can't get comments in #if, so we can    abuse that token type.  */
end_comment

begin_define
define|#
directive|define
name|CPP_ERROR
value|CPP_COMMENT
end_define

begin_comment
comment|/* With -O2, gcc appears to produce nice code, moving the error    message load and subsequent jump completely out of the main path.  */
end_comment

begin_define
define|#
directive|define
name|CPP_ICE
parameter_list|(
name|msgid
parameter_list|)
define|\
value|do { cpp_ice (pfile, msgid); goto syntax_error; } while(0)
end_define

begin_define
define|#
directive|define
name|SYNTAX_ERROR
parameter_list|(
name|msgid
parameter_list|)
define|\
value|do { cpp_error (pfile, msgid); goto syntax_error; } while(0)
end_define

begin_define
define|#
directive|define
name|SYNTAX_ERROR2
parameter_list|(
name|msgid
parameter_list|,
name|arg
parameter_list|)
define|\
value|do { cpp_error (pfile, msgid, arg); goto syntax_error; } while(0)
end_define

begin_struct
struct|struct
name|suffix
block|{
specifier|const
name|unsigned
name|char
name|s
index|[
literal|4
index|]
decl_stmt|;
specifier|const
name|unsigned
name|char
name|u
decl_stmt|;
specifier|const
name|unsigned
name|char
name|l
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|suffix
name|vsuf_1
index|[]
init|=
block|{
block|{
literal|"u"
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"U"
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"l"
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"L"
block|,
literal|0
block|,
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|suffix
name|vsuf_2
index|[]
init|=
block|{
block|{
literal|"ul"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"UL"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"uL"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"Ul"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"lu"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"LU"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"Lu"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"lU"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"ll"
block|,
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|"LL"
block|,
literal|0
block|,
literal|2
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|suffix
name|vsuf_3
index|[]
init|=
block|{
block|{
literal|"ull"
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|"ULL"
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|"uLL"
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|"Ull"
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|"llu"
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|"LLU"
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|"LLu"
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|"llU"
block|,
literal|1
block|,
literal|2
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|Nsuff
parameter_list|(
name|tab
parameter_list|)
value|(sizeof tab / sizeof (struct suffix))
end_define

begin_comment
comment|/* Parse and convert what is presumably an integer in TOK.  Accepts    decimal, hex, or octal with or without size suffixes.  Returned op    is CPP_ERROR on error, otherwise it is a CPP_NUMBER.  */
end_comment

begin_function
specifier|static
name|struct
name|op
name|parse_number
parameter_list|(
name|pfile
parameter_list|,
name|tok
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|tok
decl_stmt|;
block|{
name|struct
name|op
name|op
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|start
init|=
name|tok
operator|->
name|val
operator|.
name|str
operator|.
name|text
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|end
init|=
name|start
operator|+
name|tok
operator|->
name|val
operator|.
name|str
operator|.
name|len
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|p
init|=
name|start
decl_stmt|;
name|int
name|c
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|nsuff
decl_stmt|;
name|unsigned
name|HOST_WIDEST_INT
name|n
init|=
literal|0
decl_stmt|,
name|nd
decl_stmt|,
name|MAX_over_base
decl_stmt|;
name|int
name|base
init|=
literal|10
decl_stmt|;
name|int
name|overflow
init|=
literal|0
decl_stmt|;
name|int
name|digit
decl_stmt|,
name|largest_digit
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|suffix
modifier|*
name|sufftab
decl_stmt|;
name|op
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
name|end
operator|-
name|start
operator|>=
literal|3
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|p
operator|+=
literal|1
expr_stmt|;
name|base
operator|=
literal|8
expr_stmt|;
block|}
block|}
comment|/* Some buggy compilers (e.g. MPW C) seem to need both casts.  */
name|MAX_over_base
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
operator|-
literal|1
operator|)
operator|/
operator|(
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
name|base
operator|)
operator|)
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|base
operator|==
literal|16
operator|&&
name|ISXDIGIT
argument_list|(
name|c
argument_list|)
operator|)
condition|)
name|digit
operator|=
name|hex_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|largest_digit
operator|<
name|digit
condition|)
name|largest_digit
operator|=
name|digit
expr_stmt|;
name|nd
operator|=
name|n
operator|*
name|base
operator|+
name|digit
expr_stmt|;
name|overflow
operator||=
name|MAX_over_base
operator|<
name|n
operator|||
name|nd
operator|<
name|n
expr_stmt|;
name|n
operator|=
name|nd
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|<
name|end
condition|)
block|{
comment|/* Check for a floating point constant.  Note that float constants 	 with an exponent or suffix but no decimal point are technically 	 invalid (C99 6.4.4.2) but accepted elsewhere.  */
if|if
condition|(
operator|(
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'F'
operator|||
name|c
operator|==
literal|'f'
operator|)
operator|||
operator|(
name|base
operator|==
literal|10
operator|&&
operator|(
name|c
operator|==
literal|'E'
operator|||
name|c
operator|==
literal|'e'
operator|)
operator|&&
name|p
operator|+
literal|1
operator|<
name|end
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'+'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'-'
operator|)
operator|)
operator|||
operator|(
name|base
operator|==
literal|16
operator|&&
operator|(
name|c
operator|==
literal|'P'
operator|||
name|c
operator|==
literal|'p'
operator|)
operator|&&
name|p
operator|+
literal|1
operator|<
name|end
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'+'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'-'
operator|)
operator|)
condition|)
name|SYNTAX_ERROR
argument_list|(
literal|"floating point numbers are not valid in #if"
argument_list|)
expr_stmt|;
comment|/* Determine the suffix. l means long, and u means unsigned. 	 See the suffix tables, above.  */
switch|switch
condition|(
name|end
operator|-
name|p
condition|)
block|{
case|case
literal|1
case|:
name|sufftab
operator|=
name|vsuf_1
expr_stmt|;
name|nsuff
operator|=
name|Nsuff
argument_list|(
name|vsuf_1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sufftab
operator|=
name|vsuf_2
expr_stmt|;
name|nsuff
operator|=
name|Nsuff
argument_list|(
name|vsuf_2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|sufftab
operator|=
name|vsuf_3
expr_stmt|;
name|nsuff
operator|=
name|Nsuff
argument_list|(
name|vsuf_3
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|invalid_suffix
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsuff
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
name|sufftab
index|[
name|i
index|]
operator|.
name|s
argument_list|,
name|end
operator|-
name|p
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|nsuff
condition|)
goto|goto
name|invalid_suffix
goto|;
name|op
operator|.
name|unsignedp
operator|=
name|sufftab
index|[
name|i
index|]
operator|.
name|u
expr_stmt|;
if|if
condition|(
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|&&
name|sufftab
index|[
name|i
index|]
operator|.
name|u
operator|&&
operator|!
name|cpp_sys_macro_p
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"traditional C rejects the `U' suffix"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sufftab
index|[
name|i
index|]
operator|.
name|l
operator|==
literal|2
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pedantic
argument_list|)
operator|&&
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"too many 'l' suffixes in integer constant"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|<=
name|largest_digit
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"integer constant contains digits beyond the radix"
argument_list|)
expr_stmt|;
if|if
condition|(
name|overflow
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"integer constant out of range"
argument_list|)
expr_stmt|;
comment|/* If too big to be signed, consider it unsigned.  */
elseif|else
if|if
condition|(
operator|(
name|HOST_WIDEST_INT
operator|)
name|n
operator|<
literal|0
operator|&&
operator|!
name|op
operator|.
name|unsignedp
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|10
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"integer constant is so large that it is unsigned"
argument_list|)
expr_stmt|;
name|op
operator|.
name|unsignedp
operator|=
literal|1
expr_stmt|;
block|}
name|op
operator|.
name|value
operator|=
name|n
expr_stmt|;
name|op
operator|.
name|op
operator|=
name|CPP_NUMBER
expr_stmt|;
return|return
name|op
return|;
name|invalid_suffix
label|:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"invalid suffix '%.*s' on integer constant"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|end
operator|-
name|p
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|syntax_error
label|:
name|op
operator|.
name|op
operator|=
name|CPP_ERROR
expr_stmt|;
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/* Handle meeting "defined" in a preprocessor expression.  */
end_comment

begin_function
specifier|static
name|struct
name|op
name|parse_defined
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|int
name|paren
init|=
literal|0
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
init|=
literal|0
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|struct
name|op
name|op
decl_stmt|;
name|cpp_context
modifier|*
name|initial_context
init|=
name|pfile
operator|->
name|context
decl_stmt|;
comment|/* Don't expand macros.  */
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|++
expr_stmt|;
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
condition|)
block|{
name|paren
operator|=
literal|1
expr_stmt|;
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
block|{
name|node
operator|=
name|token
operator|->
name|val
operator|.
name|node
expr_stmt|;
if|if
condition|(
name|paren
operator|&&
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
operator|->
name|type
operator|!=
name|CPP_CLOSE_PAREN
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"missing ')' after \"defined\""
argument_list|)
expr_stmt|;
name|node
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"operator \"defined\" requires an identifier"
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|NAMED_OP
condition|)
block|{
name|cpp_token
name|op
decl_stmt|;
name|op
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|op
operator|.
name|type
operator|=
name|token
operator|->
name|type
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"(\"%s\" is an alternative token for \"%s\" in C++)"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|)
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
operator|&
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|node
condition|)
name|op
operator|.
name|op
operator|=
name|CPP_ERROR
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pfile
operator|->
name|context
operator|!=
name|initial_context
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"this use of \"defined\" may not be portable"
argument_list|)
expr_stmt|;
name|op
operator|.
name|value
operator|=
name|node
operator|->
name|type
operator|==
name|NT_MACRO
expr_stmt|;
name|op
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
name|op
operator|.
name|op
operator|=
name|CPP_NUMBER
expr_stmt|;
comment|/* A possible controlling macro of the form #if !defined (). 	 _cpp_parse_expr checks there was no other junk on the line.  */
name|pfile
operator|->
name|mi_ind_cmacro
operator|=
name|node
expr_stmt|;
block|}
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|--
expr_stmt|;
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/* Read a token.  The returned type is CPP_NUMBER for a valid number    (an interpreted preprocessing number or character constant, or the    result of the "defined" or "#" operators), CPP_ERROR on error,    CPP_EOF, or the type of an operator token.  */
end_comment

begin_function
specifier|static
name|struct
name|op
name|lex
parameter_list|(
name|pfile
parameter_list|,
name|skip_evaluation
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|skip_evaluation
decl_stmt|;
block|{
name|struct
name|op
name|op
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
init|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_NUMBER
case|:
return|return
name|parse_number
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|)
return|;
case|case
name|CPP_CHAR
case|:
case|case
name|CPP_WCHAR
case|:
block|{
name|unsigned
name|int
name|chars_seen
decl_stmt|;
comment|/* This is always a signed type.  */
name|op
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
name|op
operator|.
name|op
operator|=
name|CPP_NUMBER
expr_stmt|;
name|op
operator|.
name|value
operator|=
name|cpp_interpret_charconst
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|chars_seen
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
case|case
name|CPP_STRING
case|:
case|case
name|CPP_WSTRING
case|:
name|SYNTAX_ERROR
argument_list|(
literal|"string constants are not valid in #if"
argument_list|)
expr_stmt|;
case|case
name|CPP_OTHER
case|:
if|if
condition|(
name|ISGRAPH
argument_list|(
name|token
operator|->
name|val
operator|.
name|c
argument_list|)
condition|)
name|SYNTAX_ERROR2
argument_list|(
literal|"invalid character '%c' in #if"
argument_list|,
name|token
operator|->
name|val
operator|.
name|c
argument_list|)
expr_stmt|;
else|else
name|SYNTAX_ERROR2
argument_list|(
literal|"invalid character '\\%03o' in #if"
argument_list|,
name|token
operator|->
name|val
operator|.
name|c
argument_list|)
expr_stmt|;
case|case
name|CPP_NAME
case|:
if|if
condition|(
name|token
operator|->
name|val
operator|.
name|node
operator|==
name|pfile
operator|->
name|spec_nodes
operator|.
name|n_defined
condition|)
return|return
name|parse_defined
argument_list|(
name|pfile
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
operator|&&
operator|(
name|token
operator|->
name|val
operator|.
name|node
operator|==
name|pfile
operator|->
name|spec_nodes
operator|.
name|n_true
operator|||
name|token
operator|->
name|val
operator|.
name|node
operator|==
name|pfile
operator|->
name|spec_nodes
operator|.
name|n_false
operator|)
condition|)
block|{
name|op
operator|.
name|op
operator|=
name|CPP_NUMBER
expr_stmt|;
name|op
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
name|op
operator|.
name|value
operator|=
operator|(
name|token
operator|->
name|val
operator|.
name|node
operator|==
name|pfile
operator|->
name|spec_nodes
operator|.
name|n_true
operator|)
expr_stmt|;
comment|/* Warn about use of true or false in #if when pedantic 	     and stdbool.h has not been included.  */
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|cpp_defined
argument_list|(
name|pfile
argument_list|,
name|DSC
argument_list|(
literal|"__bool_true_false_are_defined"
argument_list|)
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"ISO C++ does not permit \"%s\" in #if"
argument_list|,
name|NODE_NAME
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
else|else
block|{
name|op
operator|.
name|op
operator|=
name|CPP_NUMBER
expr_stmt|;
name|op
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
name|op
operator|.
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_undef
argument_list|)
operator|&&
operator|!
name|skip_evaluation
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"\"%s\" is not defined"
argument_list|,
name|NODE_NAME
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
case|case
name|CPP_HASH
case|:
block|{
name|int
name|temp
decl_stmt|;
name|op
operator|.
name|op
operator|=
name|CPP_NUMBER
expr_stmt|;
if|if
condition|(
name|_cpp_test_assertion
argument_list|(
name|pfile
argument_list|,
operator|&
name|temp
argument_list|)
condition|)
name|op
operator|.
name|op
operator|=
name|CPP_ERROR
expr_stmt|;
name|op
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
name|op
operator|.
name|value
operator|=
name|temp
expr_stmt|;
return|return
name|op
return|;
block|}
default|default:
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|token
operator|->
name|type
operator|>
operator|(
name|int
operator|)
name|CPP_EQ
operator|&&
operator|(
name|int
operator|)
name|token
operator|->
name|type
operator|<
operator|(
name|int
operator|)
name|CPP_PLUS_EQ
operator|)
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
block|{
name|op
operator|.
name|op
operator|=
name|token
operator|->
name|type
expr_stmt|;
return|return
name|op
return|;
block|}
name|SYNTAX_ERROR2
argument_list|(
literal|"\"%s\" is not valid in #if expressions"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|syntax_error
label|:
name|op
operator|.
name|op
operator|=
name|CPP_ERROR
expr_stmt|;
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/* Warn if appropriate on overflow.  */
end_comment

begin_function
specifier|static
name|void
name|integer_overflow
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"integer overflow in preprocessor expression"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle shifting A left by B bits.  UNSIGNEDP is non-zero if A is    unsigned.  */
end_comment

begin_function
specifier|static
name|HOST_WIDEST_INT
name|left_shift
parameter_list|(
name|pfile
parameter_list|,
name|a
parameter_list|,
name|unsignedp
parameter_list|,
name|b
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|HOST_WIDEST_INT
name|a
decl_stmt|;
name|unsigned
name|int
name|unsignedp
decl_stmt|;
name|unsigned
name|HOST_WIDEST_INT
name|b
decl_stmt|;
block|{
if|if
condition|(
name|b
operator|>=
name|HOST_BITS_PER_WIDEST_INT
condition|)
block|{
if|if
condition|(
operator|!
name|unsignedp
operator|&&
name|a
operator|!=
literal|0
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|unsignedp
condition|)
return|return
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
name|a
operator|<<
name|b
return|;
else|else
block|{
name|HOST_WIDEST_INT
name|l
init|=
name|a
operator|<<
name|b
decl_stmt|;
if|if
condition|(
name|l
operator|>>
name|b
operator|!=
name|a
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
block|}
end_function

begin_comment
comment|/* Handle shifting A right by B bits.  UNSIGNEDP is non-zero if A is    unsigned.  */
end_comment

begin_function
specifier|static
name|HOST_WIDEST_INT
name|right_shift
parameter_list|(
name|pfile
parameter_list|,
name|a
parameter_list|,
name|unsignedp
parameter_list|,
name|b
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|HOST_WIDEST_INT
name|a
decl_stmt|;
name|unsigned
name|int
name|unsignedp
decl_stmt|;
name|unsigned
name|HOST_WIDEST_INT
name|b
decl_stmt|;
block|{
if|if
condition|(
name|b
operator|>=
name|HOST_BITS_PER_WIDEST_INT
condition|)
return|return
name|unsignedp
condition|?
literal|0
else|:
name|a
operator|>>
operator|(
name|HOST_BITS_PER_WIDEST_INT
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|unsignedp
condition|)
return|return
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
name|a
operator|>>
name|b
return|;
else|else
return|return
name|a
operator|>>
name|b
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Operator precedence and flags table.  After an operator is returned from the lexer, if it has priority less than or equal to the operator on the top of the stack, we reduce the stack by one operator and repeat the test.  Since equal priorities reduce, this is naturally left-associative.  We handle right-associative operators by clearing the lower bit of all left-associative operators, and setting it for right-associative ones. After the reduction phase of a new operator, just before it is pushed onto the stack, its RIGHT_ASSOC bit is cleared.  The effect is that during the reduction phase, the current right-associative operator has a priority one greater than any other operator of otherwise equal precedence that has been pushed on the top of the stack.  This avoids a reduction pass, and effectively makes the logic right-associative.  The remaining cases are '(' and ')'.  We handle '(' by skipping the reduction phase completely.  ')' is given lower priority than everything else, including '(', effectively forcing a reduction of the parenthesised expression.  If there is no matching '(', the stack will be reduced all the way to the beginning, exiting the parser in the same way as the ultra-low priority end-of-expression dummy operator. The exit code checks to see if the operator that caused it is ')', and if so outputs an appropriate error message.  The parser assumes all shifted operators require a right operand unless the flag NO_R_OPERAND is set, and similarly for NO_L_OPERAND. These semantics are automatically checked, any extra semantics need to be handled with operator-specific code.  */
end_comment

begin_define
define|#
directive|define
name|FLAG_BITS
value|8
end_define

begin_define
define|#
directive|define
name|FLAG_MASK
value|((1<< FLAG_BITS) - 1)
end_define

begin_define
define|#
directive|define
name|PRIO_SHIFT
value|(FLAG_BITS + 1)
end_define

begin_define
define|#
directive|define
name|EXTRACT_PRIO
parameter_list|(
name|CNST
parameter_list|)
value|((CNST)>> FLAG_BITS)
end_define

begin_define
define|#
directive|define
name|EXTRACT_FLAGS
parameter_list|(
name|CNST
parameter_list|)
value|((CNST)& FLAG_MASK)
end_define

begin_comment
comment|/* Flags.  */
end_comment

begin_define
define|#
directive|define
name|HAVE_VALUE
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|NO_L_OPERAND
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|NO_R_OPERAND
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|SHORT_CIRCUIT
value|(1<< 3)
end_define

begin_comment
comment|/* Priority and flag combinations.  */
end_comment

begin_define
define|#
directive|define
name|RIGHT_ASSOC
value|(1<< FLAG_BITS)
end_define

begin_define
define|#
directive|define
name|FORCE_REDUCE_PRIO
value|(0<< PRIO_SHIFT)
end_define

begin_define
define|#
directive|define
name|CLOSE_PAREN_PRIO
value|(1<< PRIO_SHIFT)
end_define

begin_define
define|#
directive|define
name|OPEN_PAREN_PRIO
value|((2<< PRIO_SHIFT) | NO_L_OPERAND)
end_define

begin_define
define|#
directive|define
name|COMMA_PRIO
value|(3<< PRIO_SHIFT)
end_define

begin_define
define|#
directive|define
name|COND_PRIO
value|((4<< PRIO_SHIFT) | RIGHT_ASSOC | SHORT_CIRCUIT)
end_define

begin_define
define|#
directive|define
name|COLON_PRIO
value|((5<< PRIO_SHIFT) | SHORT_CIRCUIT)
end_define

begin_define
define|#
directive|define
name|OROR_PRIO
value|((6<< PRIO_SHIFT) | SHORT_CIRCUIT)
end_define

begin_define
define|#
directive|define
name|ANDAND_PRIO
value|((7<< PRIO_SHIFT) | SHORT_CIRCUIT)
end_define

begin_define
define|#
directive|define
name|OR_PRIO
value|(8<< PRIO_SHIFT)
end_define

begin_define
define|#
directive|define
name|XOR_PRIO
value|(9<< PRIO_SHIFT)
end_define

begin_define
define|#
directive|define
name|AND_PRIO
value|(10<< PRIO_SHIFT)
end_define

begin_define
define|#
directive|define
name|MINMAX_PRIO
value|(11<< PRIO_SHIFT)
end_define

begin_define
define|#
directive|define
name|EQUAL_PRIO
value|(12<< PRIO_SHIFT)
end_define

begin_define
define|#
directive|define
name|LESS_PRIO
value|(13<< PRIO_SHIFT)
end_define

begin_define
define|#
directive|define
name|SHIFT_PRIO
value|(14<< PRIO_SHIFT)
end_define

begin_define
define|#
directive|define
name|PLUS_PRIO
value|(15<< PRIO_SHIFT)
end_define

begin_define
define|#
directive|define
name|MUL_PRIO
value|(16<< PRIO_SHIFT)
end_define

begin_define
define|#
directive|define
name|UNARY_PRIO
value|((17<< PRIO_SHIFT) | RIGHT_ASSOC | NO_L_OPERAND)
end_define

begin_comment
comment|/* Operator to priority map.  Must be in the same order as the first    N entries of enum cpp_ttype.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|short
name|op_to_prio
index|[]
init|=
block|{
comment|/* EQ */
literal|0
block|,
comment|/* dummy entry - can't happen */
comment|/* NOT */
name|UNARY_PRIO
block|,
comment|/* GREATER */
name|LESS_PRIO
block|,
comment|/* LESS */
name|LESS_PRIO
block|,
comment|/* PLUS */
name|UNARY_PRIO
block|,
comment|/* note these two can be unary */
comment|/* MINUS */
name|UNARY_PRIO
block|,
comment|/* or binary */
comment|/* MULT */
name|MUL_PRIO
block|,
comment|/* DIV */
name|MUL_PRIO
block|,
comment|/* MOD */
name|MUL_PRIO
block|,
comment|/* AND */
name|AND_PRIO
block|,
comment|/* OR */
name|OR_PRIO
block|,
comment|/* XOR */
name|XOR_PRIO
block|,
comment|/* RSHIFT */
name|SHIFT_PRIO
block|,
comment|/* LSHIFT */
name|SHIFT_PRIO
block|,
comment|/* MIN */
name|MINMAX_PRIO
block|,
comment|/* C++ specific */
comment|/* MAX */
name|MINMAX_PRIO
block|,
comment|/* extensions */
comment|/* COMPL */
name|UNARY_PRIO
block|,
comment|/* AND_AND */
name|ANDAND_PRIO
block|,
comment|/* OR_OR */
name|OROR_PRIO
block|,
comment|/* QUERY */
name|COND_PRIO
block|,
comment|/* COLON */
name|COLON_PRIO
block|,
comment|/* COMMA */
name|COMMA_PRIO
block|,
comment|/* OPEN_PAREN */
name|OPEN_PAREN_PRIO
block|,
comment|/* CLOSE_PAREN */
name|CLOSE_PAREN_PRIO
block|,
comment|/* EQ_EQ */
name|EQUAL_PRIO
block|,
comment|/* NOT_EQ */
name|EQUAL_PRIO
block|,
comment|/* GREATER_EQ */
name|LESS_PRIO
block|,
comment|/* LESS_EQ */
name|LESS_PRIO
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|COMPARE
parameter_list|(
name|OP
parameter_list|)
define|\
value|top->unsignedp = 0; \   top->value = (unsigned1 | unsigned2) \   ? (unsigned HOST_WIDEST_INT) v1 OP (unsigned HOST_WIDEST_INT) v2 \   : (v1 OP v2)
end_define

begin_define
define|#
directive|define
name|EQUALITY
parameter_list|(
name|OP
parameter_list|)
define|\
value|top->value = v1 OP v2; \   top->unsignedp = 0;
end_define

begin_define
define|#
directive|define
name|BITWISE
parameter_list|(
name|OP
parameter_list|)
define|\
value|top->value = v1 OP v2; \   top->unsignedp = unsigned1 | unsigned2;
end_define

begin_define
define|#
directive|define
name|MINMAX
parameter_list|(
name|OP
parameter_list|)
define|\
value|top->value = (v1 OP v2) ? v1 : v2; \   top->unsignedp = unsigned1 | unsigned2;
end_define

begin_define
define|#
directive|define
name|UNARY
parameter_list|(
name|OP
parameter_list|)
define|\
value|top->value = OP v2; \   top->unsignedp = unsigned2; \   top->flags |= HAVE_VALUE;
end_define

begin_define
define|#
directive|define
name|SHIFT
parameter_list|(
name|PSH
parameter_list|,
name|MSH
parameter_list|)
define|\
value|if (skip_evaluation)  \     break;		\   top->unsignedp = unsigned1; \   if (v2< 0&& ! unsigned2)  \     top->value = MSH (pfile, v1, unsigned1, -v2); \   else \     top->value = PSH (pfile, v1, unsigned1, v2);
end_define

begin_comment
comment|/* Parse and evaluate a C expression, reading from PFILE.    Returns the truth value of the expression.  */
end_comment

begin_function
name|int
name|_cpp_parse_expr
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
comment|/* The implementation is an operator precedence parser, i.e. a      bottom-up parser, using a stack for not-yet-reduced tokens.       The stack base is 'stack', and the current stack pointer is 'top'.      There is a stack element for each operator (only),      and the most recently pushed operator is 'top->op'.      An operand (value) is stored in the 'value' field of the stack      element of the operator that precedes it.      In that case the 'flags' field has the HAVE_VALUE flag set.  */
define|#
directive|define
name|INIT_STACK_SIZE
value|20
name|struct
name|op
name|init_stack
index|[
name|INIT_STACK_SIZE
index|]
decl_stmt|;
name|struct
name|op
modifier|*
name|stack
init|=
name|init_stack
decl_stmt|;
name|struct
name|op
modifier|*
name|limit
init|=
name|stack
operator|+
name|INIT_STACK_SIZE
decl_stmt|;
name|struct
name|op
modifier|*
name|top
init|=
name|stack
operator|+
literal|1
decl_stmt|;
name|int
name|skip_evaluation
init|=
literal|0
decl_stmt|;
name|int
name|result
decl_stmt|;
name|unsigned
name|int
name|lex_count
decl_stmt|,
name|saw_leading_not
decl_stmt|;
comment|/* Set up detection of #if ! defined().  */
name|pfile
operator|->
name|mi_ind_cmacro
operator|=
literal|0
expr_stmt|;
name|saw_leading_not
operator|=
literal|0
expr_stmt|;
name|lex_count
operator|=
literal|0
expr_stmt|;
comment|/* We've finished when we try to reduce this.  */
name|top
operator|->
name|op
operator|=
name|CPP_EOF
expr_stmt|;
comment|/* Nifty way to catch missing '('.  */
name|top
operator|->
name|prio
operator|=
name|EXTRACT_PRIO
argument_list|(
name|CLOSE_PAREN_PRIO
argument_list|)
expr_stmt|;
comment|/* Avoid missing right operand checks.  */
name|top
operator|->
name|flags
operator|=
name|NO_R_OPERAND
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|int
name|prio
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|struct
name|op
name|op
decl_stmt|;
comment|/* Read a token */
name|op
operator|=
name|lex
argument_list|(
name|pfile
argument_list|,
name|skip_evaluation
argument_list|)
expr_stmt|;
name|lex_count
operator|++
expr_stmt|;
comment|/* If the token is an operand, push its value and get next 	 token.  If it is an operator, get its priority and flags, and 	 try to reduce the expression on the stack.  */
switch|switch
condition|(
name|op
operator|.
name|op
condition|)
block|{
case|case
name|CPP_ERROR
case|:
goto|goto
name|syntax_error
goto|;
name|push_immediate
label|:
case|case
name|CPP_NUMBER
case|:
comment|/* Push a value onto the stack.  */
if|if
condition|(
name|top
operator|->
name|flags
operator|&
name|HAVE_VALUE
condition|)
name|SYNTAX_ERROR
argument_list|(
literal|"missing binary operator"
argument_list|)
expr_stmt|;
name|top
operator|->
name|value
operator|=
name|op
operator|.
name|value
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|op
operator|.
name|unsignedp
expr_stmt|;
name|top
operator|->
name|flags
operator||=
name|HAVE_VALUE
expr_stmt|;
continue|continue;
case|case
name|CPP_EOF
case|:
name|prio
operator|=
name|FORCE_REDUCE_PRIO
expr_stmt|;
break|break;
case|case
name|CPP_NOT
case|:
name|saw_leading_not
operator|=
name|lex_count
operator|==
literal|1
expr_stmt|;
name|prio
operator|=
name|op_to_prio
index|[
name|op
operator|.
name|op
index|]
expr_stmt|;
break|break;
case|case
name|CPP_PLUS
case|:
case|case
name|CPP_MINUS
case|:
name|prio
operator|=
name|PLUS_PRIO
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|flags
operator|&
name|HAVE_VALUE
condition|)
break|break;
comment|/* else unary; fall through */
default|default:
name|prio
operator|=
name|op_to_prio
index|[
name|op
operator|.
name|op
index|]
expr_stmt|;
break|break;
block|}
comment|/* Separate the operator's code into priority and flags.  */
name|flags
operator|=
name|EXTRACT_FLAGS
argument_list|(
name|prio
argument_list|)
expr_stmt|;
name|prio
operator|=
name|EXTRACT_PRIO
argument_list|(
name|prio
argument_list|)
expr_stmt|;
if|if
condition|(
name|prio
operator|==
name|EXTRACT_PRIO
argument_list|(
name|OPEN_PAREN_PRIO
argument_list|)
condition|)
goto|goto
name|skip_reduction
goto|;
comment|/* Check for reductions.  Then push the operator.  */
while|while
condition|(
name|prio
operator|<=
name|top
operator|->
name|prio
condition|)
block|{
name|HOST_WIDEST_INT
name|v1
decl_stmt|,
name|v2
decl_stmt|;
name|unsigned
name|int
name|unsigned1
decl_stmt|,
name|unsigned2
decl_stmt|;
comment|/* Most operators that can appear on the stack require a 	     right operand.  Check this before trying to reduce.  */
if|if
condition|(
operator|(
name|top
operator|->
name|flags
operator|&
operator|(
name|HAVE_VALUE
operator||
name|NO_R_OPERAND
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|top
operator|->
name|op
operator|==
name|CPP_OPEN_PAREN
condition|)
name|SYNTAX_ERROR
argument_list|(
literal|"void expression between '(' and ')'"
argument_list|)
expr_stmt|;
else|else
name|SYNTAX_ERROR2
argument_list|(
literal|"operator '%s' has no right operand"
argument_list|,
name|op_as_text
argument_list|(
name|pfile
argument_list|,
name|top
operator|->
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|unsigned2
operator|=
name|top
operator|->
name|unsignedp
operator|,
name|v2
operator|=
name|top
operator|->
name|value
expr_stmt|;
name|top
operator|--
expr_stmt|;
name|unsigned1
operator|=
name|top
operator|->
name|unsignedp
operator|,
name|v1
operator|=
name|top
operator|->
name|value
expr_stmt|;
comment|/* Now set top->value = (top[1].op)(v1, v2); */
switch|switch
condition|(
name|top
index|[
literal|1
index|]
operator|.
name|op
condition|)
block|{
default|default:
name|cpp_ice
argument_list|(
name|pfile
argument_list|,
literal|"impossible operator '%s'"
argument_list|,
name|op_as_text
argument_list|(
name|pfile
argument_list|,
name|top
index|[
literal|1
index|]
operator|.
name|op
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
case|case
name|CPP_NOT
case|:
name|UNARY
argument_list|(
operator|!
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_COMPL
case|:
name|UNARY
argument_list|(
operator|~
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_LESS
case|:
name|COMPARE
argument_list|(
operator|<
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_GREATER
case|:
name|COMPARE
argument_list|(
operator|>
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_LESS_EQ
case|:
name|COMPARE
argument_list|(
operator|<=
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_GREATER_EQ
case|:
name|COMPARE
argument_list|(
operator|>=
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_EQ_EQ
case|:
name|EQUALITY
argument_list|(
operator|==
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_NOT_EQ
case|:
name|EQUALITY
argument_list|(
operator|!=
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_AND
case|:
name|BITWISE
argument_list|(
operator|&
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_XOR
case|:
name|BITWISE
argument_list|(
operator|^
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_OR
case|:
name|BITWISE
argument_list|(
operator||
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_LSHIFT
case|:
name|SHIFT
argument_list|(
name|left_shift
argument_list|,
name|right_shift
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_RSHIFT
case|:
name|SHIFT
argument_list|(
name|right_shift
argument_list|,
name|left_shift
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MIN
case|:
name|MINMAX
argument_list|(
operator|<
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MAX
case|:
name|MINMAX
argument_list|(
operator|>
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_PLUS
case|:
if|if
condition|(
operator|!
operator|(
name|top
operator|->
name|flags
operator|&
name|HAVE_VALUE
operator|)
condition|)
block|{
comment|/* Can't use UNARY(+) because K+R C did not have unary 		     plus.  Can't use UNARY() because some compilers object 		     to the empty argument.  */
name|top
operator|->
name|value
operator|=
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned2
expr_stmt|;
name|top
operator|->
name|flags
operator||=
name|HAVE_VALUE
expr_stmt|;
if|if
condition|(
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"traditional C rejects the unary plus operator"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|top
operator|->
name|value
operator|=
name|v1
operator|+
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
operator||
name|unsigned2
expr_stmt|;
if|if
condition|(
operator|!
name|top
operator|->
name|unsignedp
operator|&&
operator|!
name|skip_evaluation
operator|&&
operator|!
name|possible_sum_sign
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
name|top
operator|->
name|value
argument_list|)
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CPP_MINUS
case|:
if|if
condition|(
operator|!
operator|(
name|top
operator|->
name|flags
operator|&
name|HAVE_VALUE
operator|)
condition|)
block|{
name|UNARY
argument_list|(
operator|-
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip_evaluation
operator|&&
operator|(
name|top
operator|->
name|value
operator|&
name|v2
operator|)
operator|<
literal|0
operator|&&
operator|!
name|unsigned2
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Binary '-' */
name|top
operator|->
name|value
operator|=
name|v1
operator|-
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
operator||
name|unsigned2
expr_stmt|;
if|if
condition|(
operator|!
name|top
operator|->
name|unsignedp
operator|&&
operator|!
name|skip_evaluation
operator|&&
operator|!
name|possible_sum_sign
argument_list|(
name|top
operator|->
name|value
argument_list|,
name|v2
argument_list|,
name|v1
argument_list|)
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CPP_MULT
case|:
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
operator||
name|unsigned2
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|unsignedp
condition|)
name|top
operator|->
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
name|v1
operator|*
name|v2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|skip_evaluation
condition|)
block|{
name|top
operator|->
name|value
operator|=
name|v1
operator|*
name|v2
expr_stmt|;
if|if
condition|(
name|v1
operator|&&
operator|(
name|top
operator|->
name|value
operator|/
name|v1
operator|!=
name|v2
operator|||
operator|(
name|top
operator|->
name|value
operator|&
name|v1
operator|&
name|v2
operator|)
operator|<
literal|0
operator|)
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CPP_DIV
case|:
case|case
name|CPP_MOD
case|:
if|if
condition|(
name|skip_evaluation
condition|)
break|break;
if|if
condition|(
name|v2
operator|==
literal|0
condition|)
name|SYNTAX_ERROR
argument_list|(
literal|"division by zero in #if"
argument_list|)
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
operator||
name|unsigned2
expr_stmt|;
if|if
condition|(
name|top
index|[
literal|1
index|]
operator|.
name|op
operator|==
name|CPP_DIV
condition|)
block|{
if|if
condition|(
name|top
operator|->
name|unsignedp
condition|)
name|top
operator|->
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
name|v1
operator|/
name|v2
expr_stmt|;
else|else
block|{
name|top
operator|->
name|value
operator|=
name|v1
operator|/
name|v2
expr_stmt|;
if|if
condition|(
operator|(
name|top
operator|->
name|value
operator|&
name|v1
operator|&
name|v2
operator|)
operator|<
literal|0
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|top
operator|->
name|unsignedp
condition|)
name|top
operator|->
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
name|v1
operator|%
name|v2
expr_stmt|;
else|else
name|top
operator|->
name|value
operator|=
name|v1
operator|%
name|v2
expr_stmt|;
block|}
break|break;
case|case
name|CPP_OR_OR
case|:
name|top
operator|->
name|value
operator|=
name|v1
operator|||
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v1
condition|)
name|skip_evaluation
operator|--
expr_stmt|;
break|break;
case|case
name|CPP_AND_AND
case|:
name|top
operator|->
name|value
operator|=
name|v1
operator|&&
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|v1
condition|)
name|skip_evaluation
operator|--
expr_stmt|;
break|break;
case|case
name|CPP_COMMA
case|:
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"comma operator in operand of #if"
argument_list|)
expr_stmt|;
name|top
operator|->
name|value
operator|=
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned2
expr_stmt|;
break|break;
case|case
name|CPP_QUERY
case|:
name|SYNTAX_ERROR
argument_list|(
literal|"syntax error '?' without following ':'"
argument_list|)
expr_stmt|;
case|case
name|CPP_COLON
case|:
if|if
condition|(
name|top
index|[
literal|0
index|]
operator|.
name|op
operator|!=
name|CPP_QUERY
condition|)
name|SYNTAX_ERROR
argument_list|(
literal|"syntax error ':' without preceding '?'"
argument_list|)
expr_stmt|;
name|top
operator|--
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|value
condition|)
name|skip_evaluation
operator|--
expr_stmt|;
name|top
operator|->
name|value
operator|=
name|top
operator|->
name|value
condition|?
name|v1
else|:
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
operator||
name|unsigned2
expr_stmt|;
break|break;
case|case
name|CPP_OPEN_PAREN
case|:
if|if
condition|(
name|op
operator|.
name|op
operator|!=
name|CPP_CLOSE_PAREN
condition|)
name|SYNTAX_ERROR
argument_list|(
literal|"missing ')' in expression"
argument_list|)
expr_stmt|;
name|op
operator|.
name|value
operator|=
name|v2
expr_stmt|;
name|op
operator|.
name|unsignedp
operator|=
name|unsigned2
expr_stmt|;
goto|goto
name|push_immediate
goto|;
case|case
name|CPP_EOF
case|:
comment|/* Reducing this dummy operator indicates we've finished.  */
if|if
condition|(
name|op
operator|.
name|op
operator|==
name|CPP_CLOSE_PAREN
condition|)
name|SYNTAX_ERROR
argument_list|(
literal|"missing '(' in expression"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* Handle short-circuit evaluations.  */
if|if
condition|(
name|flags
operator|&
name|SHORT_CIRCUIT
condition|)
switch|switch
condition|(
name|op
operator|.
name|op
condition|)
block|{
case|case
name|CPP_OR_OR
case|:
if|if
condition|(
name|top
operator|->
name|value
condition|)
name|skip_evaluation
operator|++
expr_stmt|;
break|break;
case|case
name|CPP_AND_AND
case|:
case|case
name|CPP_QUERY
case|:
if|if
condition|(
operator|!
name|top
operator|->
name|value
condition|)
name|skip_evaluation
operator|++
expr_stmt|;
break|break;
case|case
name|CPP_COLON
case|:
if|if
condition|(
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
condition|)
comment|/* Was '?' condition true?  */
name|skip_evaluation
operator|++
expr_stmt|;
else|else
name|skip_evaluation
operator|--
expr_stmt|;
default|default:
break|break;
block|}
name|skip_reduction
label|:
comment|/* Check we have a left operand iff we need one.  */
if|if
condition|(
name|flags
operator|&
name|NO_L_OPERAND
condition|)
block|{
if|if
condition|(
name|top
operator|->
name|flags
operator|&
name|HAVE_VALUE
condition|)
name|SYNTAX_ERROR2
argument_list|(
literal|"missing binary operator before '%s'"
argument_list|,
name|op_as_text
argument_list|(
name|pfile
argument_list|,
name|op
operator|.
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|top
operator|->
name|flags
operator|&
name|HAVE_VALUE
operator|)
condition|)
name|SYNTAX_ERROR2
argument_list|(
literal|"operator '%s' has no left operand"
argument_list|,
name|op_as_text
argument_list|(
name|pfile
argument_list|,
name|op
operator|.
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check for and handle stack overflow.  */
name|top
operator|++
expr_stmt|;
if|if
condition|(
name|top
operator|==
name|limit
condition|)
block|{
name|struct
name|op
modifier|*
name|new_stack
decl_stmt|;
name|int
name|old_size
init|=
operator|(
name|char
operator|*
operator|)
name|limit
operator|-
operator|(
name|char
operator|*
operator|)
name|stack
decl_stmt|;
name|int
name|new_size
init|=
literal|2
operator|*
name|old_size
decl_stmt|;
if|if
condition|(
name|stack
operator|!=
name|init_stack
condition|)
name|new_stack
operator|=
operator|(
expr|struct
name|op
operator|*
operator|)
name|xrealloc
argument_list|(
name|stack
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
else|else
block|{
name|new_stack
operator|=
operator|(
expr|struct
name|op
operator|*
operator|)
name|xmalloc
argument_list|(
name|new_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_stack
argument_list|,
name|stack
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
block|}
name|stack
operator|=
name|new_stack
expr_stmt|;
name|top
operator|=
operator|(
expr|struct
name|op
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|new_stack
operator|+
name|old_size
operator|)
expr_stmt|;
name|limit
operator|=
operator|(
expr|struct
name|op
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|new_stack
operator|+
name|new_size
operator|)
expr_stmt|;
block|}
name|top
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|top
operator|->
name|prio
operator|=
name|prio
operator|&
operator|~
name|EXTRACT_PRIO
argument_list|(
name|RIGHT_ASSOC
argument_list|)
expr_stmt|;
name|top
operator|->
name|op
operator|=
name|op
operator|.
name|op
expr_stmt|;
block|}
name|done
label|:
comment|/* The controlling macro expression is only valid if we called lex 3      times:<!><defined expression> and<EOF>.  push_conditional ()      checks that we are at top-of-file.  */
if|if
condition|(
name|pfile
operator|->
name|mi_ind_cmacro
operator|&&
operator|!
operator|(
name|saw_leading_not
operator|&&
name|lex_count
operator|==
literal|3
operator|)
condition|)
name|pfile
operator|->
name|mi_ind_cmacro
operator|=
literal|0
expr_stmt|;
name|result
operator|=
operator|(
name|top
index|[
literal|1
index|]
operator|.
name|value
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|top
operator|!=
name|stack
condition|)
name|CPP_ICE
argument_list|(
literal|"unbalanced stack in #if"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|top
index|[
literal|1
index|]
operator|.
name|flags
operator|&
name|HAVE_VALUE
operator|)
condition|)
block|{
name|SYNTAX_ERROR
argument_list|(
literal|"#if with no expression"
argument_list|)
expr_stmt|;
name|syntax_error
label|:
name|result
operator|=
literal|0
expr_stmt|;
comment|/* Return 0 on syntax error.  */
block|}
comment|/* Free dynamic stack if we allocated one.  */
if|if
condition|(
name|stack
operator|!=
name|init_stack
condition|)
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Output OP as text for diagnostics.  */
end_comment

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|op_as_text
parameter_list|(
name|pfile
parameter_list|,
name|op
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|enum
name|cpp_ttype
name|op
decl_stmt|;
block|{
name|cpp_token
name|token
decl_stmt|;
name|token
operator|.
name|type
operator|=
name|op
expr_stmt|;
name|token
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
return|return
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
operator|&
name|token
argument_list|)
return|;
block|}
end_function

end_unit

