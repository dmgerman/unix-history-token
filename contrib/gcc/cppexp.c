begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Parse C expressions for CCCP.    Copyright (C) 1987, 1992, 1994, 1995, 1997, 1998 Free Software Foundation.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  Written by Per Bothner 1994.  */
end_comment

begin_comment
comment|/* Parse a C expression from text in a string  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"gansidecl.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xmalloc
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xrealloc
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
end_ifdef

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is used for communicating lists of keywords with cccp.c.  */
end_comment

begin_struct
struct|struct
name|arglist
block|{
name|struct
name|arglist
modifier|*
name|next
decl_stmt|;
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|argno
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|CHAR_TYPE_SIZE
value|BITS_PER_UNIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|INT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|WCHAR_TYPE_SIZE
value|INT_TYPE_SIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_CHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|MAX_CHAR_TYPE_SIZE
value|CHAR_TYPE_SIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_INT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|MAX_INT_TYPE_SIZE
value|INT_TYPE_SIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|MAX_LONG_TYPE_SIZE
value|LONG_TYPE_SIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_WCHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|MAX_WCHAR_TYPE_SIZE
value|WCHAR_TYPE_SIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Yield nonzero if adding two numbers with A's and B's signs can yield a    number with SUM's sign, where A, B, and SUM are all C integers.  */
end_comment

begin_define
define|#
directive|define
name|possible_sum_sign
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|sum
parameter_list|)
value|((((a) ^ (b)) | ~ ((a) ^ (sum)))< 0)
end_define

begin_decl_stmt
specifier|static
name|void
name|integer_overflow
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|left_shift
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|long
operator|,
name|int
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|right_shift
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|long
operator|,
name|int
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ERROR
value|299
end_define

begin_define
define|#
directive|define
name|OROR
value|300
end_define

begin_define
define|#
directive|define
name|ANDAND
value|301
end_define

begin_define
define|#
directive|define
name|EQUAL
value|302
end_define

begin_define
define|#
directive|define
name|NOTEQUAL
value|303
end_define

begin_define
define|#
directive|define
name|LEQ
value|304
end_define

begin_define
define|#
directive|define
name|GEQ
value|305
end_define

begin_define
define|#
directive|define
name|LSH
value|306
end_define

begin_define
define|#
directive|define
name|RSH
value|307
end_define

begin_define
define|#
directive|define
name|NAME
value|308
end_define

begin_define
define|#
directive|define
name|INT
value|309
end_define

begin_define
define|#
directive|define
name|CHAR
value|310
end_define

begin_define
define|#
directive|define
name|LEFT_OPERAND_REQUIRED
value|1
end_define

begin_define
define|#
directive|define
name|RIGHT_OPERAND_REQUIRED
value|2
end_define

begin_define
define|#
directive|define
name|HAVE_VALUE
value|4
end_define

begin_comment
comment|/* SKIP_OPERAND is set for '&&' '||' '?' and ':' when the    following operand should be short-circuited instead of evaluated.  */
end_comment

begin_define
define|#
directive|define
name|SKIP_OPERAND
value|8
end_define

begin_comment
comment|/*#define UNSIGNEDP 16*/
end_comment

begin_comment
comment|/* Find the largest host integer type and set its size and type.    Watch out: on some crazy hosts `long' is shorter than `int'.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_WIDE_INT
end_ifndef

begin_if
if|#
directive|if
name|HAVE_INTTYPES_H
end_if

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_define
define|#
directive|define
name|HOST_WIDE_INT
value|intmax_t
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|(
name|HOST_BITS_PER_LONG
operator|<=
name|HOST_BITS_PER_INT
expr|\
operator|&&
name|HOST_BITS_PER_LONGLONG
operator|<=
name|HOST_BITS_PER_INT
operator|)
end_if

begin_define
define|#
directive|define
name|HOST_WIDE_INT
value|int
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|(
name|HOST_BITS_PER_LONGLONG
operator|<=
name|HOST_BITS_PER_LONG
expr|\
operator|||
operator|!
operator|(
name|defined
name|LONG_LONG_MAX
operator|||
name|defined
name|LLONG_MAX
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|HOST_WIDE_INT
value|long
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HOST_WIDE_INT
value|long long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_BIT
end_ifndef

begin_define
define|#
directive|define
name|CHAR_BIT
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_BITS_PER_WIDE_INT
end_ifndef

begin_define
define|#
directive|define
name|HOST_BITS_PER_WIDE_INT
value|(CHAR_BIT * sizeof (HOST_WIDE_INT))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|operation
block|{
name|short
name|op
decl_stmt|;
name|char
name|rprio
decl_stmt|;
comment|/* Priority of op (relative to it right operand).  */
name|char
name|flags
decl_stmt|;
name|char
name|unsignedp
decl_stmt|;
comment|/* true if value should be treated as unsigned */
name|HOST_WIDE_INT
name|value
decl_stmt|;
comment|/* The value logically "right" of op.  */
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Take care of parsing a number (anything that starts with a digit).    LEN is the number of characters in it.  */
end_comment

begin_comment
comment|/* maybe needs to actually deal with floating point numbers */
end_comment

begin_function
name|struct
name|operation
name|parse_number
parameter_list|(
name|pfile
parameter_list|,
name|start
parameter_list|,
name|olen
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|olen
decl_stmt|;
block|{
name|struct
name|operation
name|op
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|start
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|unsigned
name|long
name|n
init|=
literal|0
decl_stmt|,
name|nd
decl_stmt|,
name|ULONG_MAX_over_base
decl_stmt|;
specifier|register
name|int
name|base
init|=
literal|10
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|olen
decl_stmt|;
specifier|register
name|int
name|overflow
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|digit
decl_stmt|,
name|largest_digit
init|=
literal|0
decl_stmt|;
name|int
name|spec_long
init|=
literal|0
decl_stmt|;
name|op
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|len
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|p
index|[
name|c
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* It's a float since it contains a point.  */
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"floating point numbers not allowed in #if expressions"
argument_list|)
expr_stmt|;
name|op
operator|.
name|op
operator|=
name|ERROR
expr_stmt|;
return|return
name|op
return|;
block|}
if|if
condition|(
name|len
operator|>=
literal|3
operator|&&
operator|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"0x"
argument_list|,
literal|2
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"0X"
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
condition|)
name|base
operator|=
literal|8
expr_stmt|;
comment|/* Some buggy compilers (e.g. MPW C) seem to need both casts.  */
name|ULONG_MAX_over_base
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
operator|)
operator|/
operator|(
operator|(
name|unsigned
name|long
operator|)
name|base
operator|)
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|--
control|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|digit
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|==
literal|16
operator|&&
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
name|digit
operator|=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|==
literal|16
operator|&&
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
name|digit
operator|=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
block|{
comment|/* `l' means long, and `u' means unsigned.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'l'
operator|||
name|c
operator|==
literal|'L'
condition|)
block|{
if|if
condition|(
name|spec_long
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"two `l's in integer constant"
argument_list|)
expr_stmt|;
name|spec_long
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'u'
operator|||
name|c
operator|==
literal|'U'
condition|)
block|{
if|if
condition|(
name|op
operator|.
name|unsignedp
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"two `u's in integer constant"
argument_list|)
expr_stmt|;
name|op
operator|.
name|unsignedp
operator|=
literal|1
expr_stmt|;
block|}
else|else
break|break;
if|if
condition|(
operator|--
name|len
operator|==
literal|0
condition|)
break|break;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
comment|/* Don't look for any more digits after the suffixes.  */
break|break;
block|}
if|if
condition|(
name|largest_digit
operator|<
name|digit
condition|)
name|largest_digit
operator|=
name|digit
expr_stmt|;
name|nd
operator|=
name|n
operator|*
name|base
operator|+
name|digit
expr_stmt|;
name|overflow
operator||=
name|ULONG_MAX_over_base
operator|<
name|n
operator|||
name|nd
operator|<
name|n
expr_stmt|;
name|n
operator|=
name|nd
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"Invalid number in #if expression"
argument_list|)
expr_stmt|;
name|op
operator|.
name|op
operator|=
name|ERROR
expr_stmt|;
return|return
name|op
return|;
block|}
if|if
condition|(
name|base
operator|<=
name|largest_digit
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"integer constant contains digits beyond the radix"
argument_list|)
expr_stmt|;
if|if
condition|(
name|overflow
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"integer constant out of range"
argument_list|)
expr_stmt|;
comment|/* If too big to be signed, consider it unsigned.  */
if|if
condition|(
operator|(
name|long
operator|)
name|n
operator|<
literal|0
operator|&&
operator|!
name|op
operator|.
name|unsignedp
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|10
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"integer constant is so large that it is unsigned"
argument_list|)
expr_stmt|;
name|op
operator|.
name|unsignedp
operator|=
literal|1
expr_stmt|;
block|}
name|op
operator|.
name|value
operator|=
name|n
expr_stmt|;
name|op
operator|.
name|op
operator|=
name|INT
expr_stmt|;
return|return
name|op
return|;
block|}
end_function

begin_struct
struct|struct
name|token
block|{
name|char
modifier|*
name|operator
decl_stmt|;
name|int
name|token
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|token
name|tokentab2
index|[]
init|=
block|{
block|{
literal|"&&"
block|,
name|ANDAND
block|}
block|,
block|{
literal|"||"
block|,
name|OROR
block|}
block|,
block|{
literal|"<<"
block|,
name|LSH
block|}
block|,
block|{
literal|">>"
block|,
name|RSH
block|}
block|,
block|{
literal|"=="
block|,
name|EQUAL
block|}
block|,
block|{
literal|"!="
block|,
name|NOTEQUAL
block|}
block|,
block|{
literal|"<="
block|,
name|LEQ
block|}
block|,
block|{
literal|">="
block|,
name|GEQ
block|}
block|,
block|{
literal|"++"
block|,
name|ERROR
block|}
block|,
block|{
literal|"--"
block|,
name|ERROR
block|}
block|,
block|{
name|NULL
block|,
name|ERROR
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read one token.  */
end_comment

begin_function
name|struct
name|operation
name|cpp_lex
parameter_list|(
name|pfile
parameter_list|,
name|skip_evaluation
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|skip_evaluation
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|token
modifier|*
name|toktab
decl_stmt|;
name|enum
name|cpp_token
name|token
decl_stmt|;
name|struct
name|operation
name|op
decl_stmt|;
name|U_CHAR
modifier|*
name|tok_start
decl_stmt|,
modifier|*
name|tok_end
decl_stmt|;
name|int
name|old_written
decl_stmt|;
name|retry
label|:
name|old_written
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|CPP_BUF_PEEK
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
return|return
name|parse_number
argument_list|(
name|pfile
argument_list|,
name|cpp_read_check_assertion
argument_list|(
name|pfile
argument_list|)
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
literal|1
argument_list|)
return|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|op
operator|.
name|op
operator|=
literal|0
expr_stmt|;
return|return
name|op
return|;
block|}
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|tok_start
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|old_written
expr_stmt|;
name|tok_end
operator|=
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|limit
operator|=
name|tok_start
expr_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|CPP_EOF
case|:
comment|/* Should not happen ...  */
case|case
name|CPP_VSPACE
case|:
name|op
operator|.
name|op
operator|=
literal|0
expr_stmt|;
return|return
name|op
return|;
case|case
name|CPP_POP
case|:
if|if
condition|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|fname
operator|!=
name|NULL
condition|)
block|{
name|op
operator|.
name|op
operator|=
literal|0
expr_stmt|;
return|return
name|op
return|;
block|}
name|cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
name|CPP_HSPACE
case|:
case|case
name|CPP_COMMENT
case|:
goto|goto
name|retry
goto|;
case|case
name|CPP_NUMBER
case|:
return|return
name|parse_number
argument_list|(
name|pfile
argument_list|,
name|tok_start
argument_list|,
name|tok_end
operator|-
name|tok_start
argument_list|)
return|;
case|case
name|CPP_STRING
case|:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"string constants not allowed in #if expressions"
argument_list|)
expr_stmt|;
name|op
operator|.
name|op
operator|=
name|ERROR
expr_stmt|;
return|return
name|op
return|;
case|case
name|CPP_CHAR
case|:
comment|/* This code for reading a character constant 	 handles multicharacter constants and wide characters. 	 It is mostly copied from c-lex.c.  */
block|{
specifier|register
name|int
name|result
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|num_chars
init|=
literal|0
decl_stmt|;
name|unsigned
name|width
init|=
name|MAX_CHAR_TYPE_SIZE
decl_stmt|;
name|int
name|wide_flag
init|=
literal|0
decl_stmt|;
name|int
name|max_chars
decl_stmt|;
name|U_CHAR
modifier|*
name|ptr
init|=
name|tok_start
decl_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|char
name|token_buffer
index|[
name|MAX_LONG_TYPE_SIZE
operator|/
name|MAX_CHAR_TYPE_SIZE
operator|+
name|MB_CUR_MAX
index|]
decl_stmt|;
else|#
directive|else
name|char
name|token_buffer
index|[
name|MAX_LONG_TYPE_SIZE
operator|/
name|MAX_CHAR_TYPE_SIZE
operator|+
literal|1
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'L'
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
name|wide_flag
operator|=
literal|1
expr_stmt|;
name|width
operator|=
name|MAX_WCHAR_TYPE_SIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|max_chars
operator|=
name|MB_CUR_MAX
expr_stmt|;
else|#
directive|else
name|max_chars
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|max_chars
operator|=
name|MAX_LONG_TYPE_SIZE
operator|/
name|width
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|tok_end
operator|&&
operator|(
operator|(
name|c
operator|=
operator|*
name|ptr
operator|++
operator|)
operator|!=
literal|'\''
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|cpp_parse_escape
argument_list|(
name|pfile
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
operator|&&
operator|(
name|unsigned
operator|)
name|c
operator|>=
operator|(
literal|1
operator|<<
name|width
operator|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"escape sequence out of range for character"
argument_list|)
expr_stmt|;
block|}
name|num_chars
operator|++
expr_stmt|;
comment|/* Merge character into result; ignore excess chars.  */
if|if
condition|(
name|num_chars
operator|<
name|max_chars
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
condition|)
name|result
operator|=
operator|(
name|result
operator|<<
name|width
operator|)
operator||
operator|(
name|c
operator|&
operator|(
operator|(
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|result
operator|=
name|c
expr_stmt|;
name|token_buffer
index|[
name|num_chars
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
name|token_buffer
index|[
name|num_chars
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\''
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"malformatted character constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num_chars
operator|==
literal|0
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"empty character constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num_chars
operator|>
name|max_chars
condition|)
block|{
name|num_chars
operator|=
name|max_chars
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"character constant too long"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num_chars
operator|!=
literal|1
operator|&&
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"multi-character character constant"
argument_list|)
expr_stmt|;
comment|/* If char type is signed, sign-extend the constant.  */
if|if
condition|(
operator|!
name|wide_flag
condition|)
block|{
name|int
name|num_bits
init|=
name|num_chars
operator|*
name|width
decl_stmt|;
if|if
condition|(
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__CHAR_UNSIGNED__"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"__CHAR_UNSIGNED__"
argument_list|)
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|||
operator|(
operator|(
name|result
operator|>>
operator|(
name|num_bits
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|op
operator|.
name|value
operator|=
name|result
operator|&
operator|(
operator|(
name|unsigned
name|long
operator|)
operator|~
literal|0
operator|>>
operator|(
name|HOST_BITS_PER_LONG
operator|-
name|num_bits
operator|)
operator|)
expr_stmt|;
else|else
name|op
operator|.
name|value
operator|=
name|result
operator||
operator|~
operator|(
operator|(
name|unsigned
name|long
operator|)
operator|~
literal|0
operator|>>
operator|(
name|HOST_BITS_PER_LONG
operator|-
name|num_bits
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
comment|/* Set the initial shift state and convert the next sequence.  */
name|result
operator|=
literal|0
expr_stmt|;
comment|/* In all locales L'\0' is zero and mbtowc will return zero, 		 so don't use it.  */
if|if
condition|(
name|num_chars
operator|>
literal|1
operator|||
operator|(
name|num_chars
operator|==
literal|1
operator|&&
name|token_buffer
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|wchar_t
name|wc
decl_stmt|;
operator|(
name|void
operator|)
name|mbtowc
argument_list|(
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|token_buffer
argument_list|,
name|num_chars
argument_list|)
operator|==
name|num_chars
condition|)
name|result
operator|=
name|wc
expr_stmt|;
else|else
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"Ignoring invalid multibyte character"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|op
operator|.
name|value
operator|=
name|result
expr_stmt|;
block|}
block|}
comment|/* This is always a signed type.  */
name|op
operator|.
name|unsignedp
operator|=
literal|0
expr_stmt|;
name|op
operator|.
name|op
operator|=
name|CHAR
expr_stmt|;
return|return
name|op
return|;
case|case
name|CPP_NAME
case|:
if|if
condition|(
name|CPP_WARN_UNDEF
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|skip_evaluation
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"`%.*s' is not defined"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|tok_end
operator|-
name|tok_start
argument_list|)
argument_list|,
name|tok_start
argument_list|)
expr_stmt|;
return|return
name|parse_number
argument_list|(
name|pfile
argument_list|,
literal|"0"
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CPP_OTHER
case|:
comment|/* See if it is a special token of length 2.  */
if|if
condition|(
name|tok_start
operator|+
literal|2
operator|==
name|tok_end
condition|)
block|{
for|for
control|(
name|toktab
operator|=
name|tokentab2
init|;
name|toktab
operator|->
name|operator
operator|!=
name|NULL
condition|;
name|toktab
operator|++
control|)
if|if
condition|(
name|tok_start
index|[
literal|0
index|]
operator|==
name|toktab
operator|->
name|operator
index|[
literal|0
index|]
operator|&&
name|tok_start
index|[
literal|1
index|]
operator|==
name|toktab
operator|->
name|operator
index|[
literal|1
index|]
condition|)
break|break;
if|if
condition|(
name|toktab
operator|->
name|token
operator|==
name|ERROR
condition|)
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|40
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"`%s' not allowed in operand of `#if'"
argument_list|,
name|tok_start
argument_list|)
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|op
operator|.
name|op
operator|=
name|toktab
operator|->
name|token
expr_stmt|;
return|return
name|op
return|;
block|}
comment|/* fall through */
default|default:
name|op
operator|.
name|op
operator|=
operator|*
name|tok_start
expr_stmt|;
return|return
name|op
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a C escape sequence.  STRING_PTR points to a variable    containing a pointer to the string to parse.  That pointer    is updated past the characters we use.  The value of the    escape sequence is returned.     A negative value means the sequence \ newline was seen,    which is supposed to be equivalent to nothing at all.     If \ is followed by a null character, we return a negative    value and leave the string pointer pointing at the null character.     If \ is followed by 000, we return 0 and leave the string pointer    after the zeros.  A value of 0 does not mean end of string.  */
end_comment

begin_function
name|int
name|cpp_parse_escape
parameter_list|(
name|pfile
parameter_list|,
name|string_ptr
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
modifier|*
name|string_ptr
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
return|return
name|TARGET_BELL
return|;
case|case
literal|'b'
case|:
return|return
name|TARGET_BS
return|;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"non-ANSI-standard escape sequence, `\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
literal|033
return|;
case|case
literal|'f'
case|:
return|return
name|TARGET_FF
return|;
case|case
literal|'n'
case|:
return|return
name|TARGET_NEWLINE
return|;
case|case
literal|'r'
case|:
return|return
name|TARGET_CR
return|;
case|case
literal|'t'
case|:
return|return
name|TARGET_TAB
return|;
case|case
literal|'v'
case|:
return|return
name|TARGET_VT
return|;
case|case
literal|'\n'
case|:
return|return
operator|-
literal|2
return|;
case|case
literal|0
case|:
operator|(
operator|*
name|string_ptr
operator|)
operator|--
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
specifier|register
name|int
name|i
init|=
name|c
operator|-
literal|'0'
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|++
name|count
operator|<
literal|3
condition|)
block|{
name|c
operator|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'7'
condition|)
name|i
operator|=
operator|(
name|i
operator|<<
literal|3
operator|)
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
else|else
block|{
operator|(
operator|*
name|string_ptr
operator|)
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|MAX_CHAR_TYPE_SIZE
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|i
operator|&=
operator|(
literal|1
operator|<<
name|MAX_CHAR_TYPE_SIZE
operator|)
operator|-
literal|1
expr_stmt|;
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"octal character constant does not fit in a byte"
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
case|case
literal|'x'
case|:
block|{
specifier|register
name|unsigned
name|i
init|=
literal|0
decl_stmt|,
name|overflow
init|=
literal|0
decl_stmt|,
name|digits_found
init|=
literal|0
decl_stmt|,
name|digit
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|digit
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
name|digit
operator|=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
name|digit
operator|=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
block|{
operator|(
operator|*
name|string_ptr
operator|)
operator|--
expr_stmt|;
break|break;
block|}
name|overflow
operator||=
name|i
operator|^
operator|(
name|i
operator|<<
literal|4
operator|>>
literal|4
operator|)
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|<<
literal|4
operator|)
operator|+
name|digit
expr_stmt|;
name|digits_found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|digits_found
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"\\x used with no following hex digits"
argument_list|)
expr_stmt|;
if|if
condition|(
name|overflow
operator||
operator|(
name|i
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|i
operator|&=
operator|(
literal|1
operator|<<
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
expr_stmt|;
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"hex character constant does not fit in a byte"
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
default|default:
return|return
name|c
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|integer_overflow
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"integer overflow in preprocessor expression"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|long
name|left_shift
parameter_list|(
name|pfile
parameter_list|,
name|a
parameter_list|,
name|unsignedp
parameter_list|,
name|b
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|long
name|a
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|unsigned
name|long
name|b
decl_stmt|;
block|{
if|if
condition|(
name|b
operator|>=
name|HOST_BITS_PER_LONG
condition|)
block|{
if|if
condition|(
operator|!
name|unsignedp
operator|&&
name|a
operator|!=
literal|0
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|unsignedp
condition|)
return|return
operator|(
name|unsigned
name|long
operator|)
name|a
operator|<<
name|b
return|;
else|else
block|{
name|long
name|l
init|=
name|a
operator|<<
name|b
decl_stmt|;
if|if
condition|(
name|l
operator|>>
name|b
operator|!=
name|a
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|long
name|right_shift
parameter_list|(
name|pfile
parameter_list|,
name|a
parameter_list|,
name|unsignedp
parameter_list|,
name|b
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|long
name|a
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|unsigned
name|long
name|b
decl_stmt|;
block|{
if|if
condition|(
name|b
operator|>=
name|HOST_BITS_PER_LONG
condition|)
return|return
name|unsignedp
condition|?
literal|0
else|:
name|a
operator|>>
operator|(
name|HOST_BITS_PER_LONG
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|unsignedp
condition|)
return|return
operator|(
name|unsigned
name|long
operator|)
name|a
operator|>>
name|b
return|;
else|else
return|return
name|a
operator|>>
name|b
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These priorities are all even, so we can handle associatively.  */
end_comment

begin_define
define|#
directive|define
name|PAREN_INNER_PRIO
value|0
end_define

begin_define
define|#
directive|define
name|COMMA_PRIO
value|4
end_define

begin_define
define|#
directive|define
name|COND_PRIO
value|(COMMA_PRIO+2)
end_define

begin_define
define|#
directive|define
name|OROR_PRIO
value|(COND_PRIO+2)
end_define

begin_define
define|#
directive|define
name|ANDAND_PRIO
value|(OROR_PRIO+2)
end_define

begin_define
define|#
directive|define
name|OR_PRIO
value|(ANDAND_PRIO+2)
end_define

begin_define
define|#
directive|define
name|XOR_PRIO
value|(OR_PRIO+2)
end_define

begin_define
define|#
directive|define
name|AND_PRIO
value|(XOR_PRIO+2)
end_define

begin_define
define|#
directive|define
name|EQUAL_PRIO
value|(AND_PRIO+2)
end_define

begin_define
define|#
directive|define
name|LESS_PRIO
value|(EQUAL_PRIO+2)
end_define

begin_define
define|#
directive|define
name|SHIFT_PRIO
value|(LESS_PRIO+2)
end_define

begin_define
define|#
directive|define
name|PLUS_PRIO
value|(SHIFT_PRIO+2)
end_define

begin_define
define|#
directive|define
name|MUL_PRIO
value|(PLUS_PRIO+2)
end_define

begin_define
define|#
directive|define
name|UNARY_PRIO
value|(MUL_PRIO+2)
end_define

begin_define
define|#
directive|define
name|PAREN_OUTER_PRIO
value|(UNARY_PRIO+2)
end_define

begin_define
define|#
directive|define
name|COMPARE
parameter_list|(
name|OP
parameter_list|)
define|\
value|top->unsignedp = 0;\   top->value = (unsigned1 || unsigned2) ? (unsigned long) v1 OP v2 : (v1 OP v2)
end_define

begin_comment
comment|/* Parse and evaluate a C expression, reading from PFILE.    Returns the value of the expression.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|cpp_parse_expr
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
comment|/* The implementation is an operator precedence parser,      i.e. a bottom-up parser, using a stack for not-yet-reduced tokens.       The stack base is 'stack', and the current stack pointer is 'top'.      There is a stack element for each operator (only),      and the most recently pushed operator is 'top->op'.      An operand (value) is stored in the 'value' field of the stack      element of the operator that precedes it.      In that case the 'flags' field has the HAVE_VALUE flag set.  */
define|#
directive|define
name|INIT_STACK_SIZE
value|20
name|struct
name|operation
name|init_stack
index|[
name|INIT_STACK_SIZE
index|]
decl_stmt|;
name|struct
name|operation
modifier|*
name|stack
init|=
name|init_stack
decl_stmt|;
name|struct
name|operation
modifier|*
name|limit
init|=
name|stack
operator|+
name|INIT_STACK_SIZE
decl_stmt|;
specifier|register
name|struct
name|operation
modifier|*
name|top
init|=
name|stack
decl_stmt|;
name|int
name|lprio
decl_stmt|,
name|rprio
decl_stmt|;
name|int
name|skip_evaluation
init|=
literal|0
decl_stmt|;
name|top
operator|->
name|rprio
operator|=
literal|0
expr_stmt|;
name|top
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|operation
name|op
decl_stmt|;
name|char
name|flags
init|=
literal|0
decl_stmt|;
comment|/* Read a token */
name|op
operator|=
name|cpp_lex
argument_list|(
name|pfile
argument_list|,
name|skip_evaluation
argument_list|)
expr_stmt|;
comment|/* See if the token is an operand, in which case go to set_value. 	 If the token is an operator, figure out its left and right 	 priorities, and then goto maybe_reduce.  */
switch|switch
condition|(
name|op
operator|.
name|op
condition|)
block|{
case|case
name|NAME
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|INT
case|:
case|case
name|CHAR
case|:
name|top
operator|->
name|value
operator|=
name|op
operator|.
name|value
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|op
operator|.
name|unsignedp
expr_stmt|;
goto|goto
name|set_value
goto|;
case|case
literal|0
case|:
name|lprio
operator|=
literal|0
expr_stmt|;
goto|goto
name|maybe_reduce
goto|;
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
comment|/* Is this correct if unary ? FIXME */
name|flags
operator|=
name|RIGHT_OPERAND_REQUIRED
expr_stmt|;
name|lprio
operator|=
name|PLUS_PRIO
expr_stmt|;
name|rprio
operator|=
name|lprio
operator|+
literal|1
expr_stmt|;
goto|goto
name|maybe_reduce
goto|;
case|case
literal|'!'
case|:
case|case
literal|'~'
case|:
name|flags
operator|=
name|RIGHT_OPERAND_REQUIRED
expr_stmt|;
name|rprio
operator|=
name|UNARY_PRIO
expr_stmt|;
name|lprio
operator|=
name|rprio
operator|+
literal|1
expr_stmt|;
goto|goto
name|maybe_reduce
goto|;
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
case|case
literal|'%'
case|:
name|lprio
operator|=
name|MUL_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
name|LEQ
case|:
case|case
name|GEQ
case|:
name|lprio
operator|=
name|LESS_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|EQUAL
case|:
case|case
name|NOTEQUAL
case|:
name|lprio
operator|=
name|EQUAL_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|LSH
case|:
case|case
name|RSH
case|:
name|lprio
operator|=
name|SHIFT_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
literal|'&'
case|:
name|lprio
operator|=
name|AND_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
literal|'^'
case|:
name|lprio
operator|=
name|XOR_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
literal|'|'
case|:
name|lprio
operator|=
name|OR_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|ANDAND
case|:
name|lprio
operator|=
name|ANDAND_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|OROR
case|:
name|lprio
operator|=
name|OROR_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
literal|','
case|:
name|lprio
operator|=
name|COMMA_PRIO
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
literal|'('
case|:
name|lprio
operator|=
name|PAREN_OUTER_PRIO
expr_stmt|;
name|rprio
operator|=
name|PAREN_INNER_PRIO
expr_stmt|;
goto|goto
name|maybe_reduce
goto|;
case|case
literal|')'
case|:
name|lprio
operator|=
name|PAREN_INNER_PRIO
expr_stmt|;
name|rprio
operator|=
name|PAREN_OUTER_PRIO
expr_stmt|;
goto|goto
name|maybe_reduce
goto|;
case|case
literal|':'
case|:
name|lprio
operator|=
name|COND_PRIO
expr_stmt|;
name|rprio
operator|=
name|COND_PRIO
expr_stmt|;
goto|goto
name|maybe_reduce
goto|;
case|case
literal|'?'
case|:
name|lprio
operator|=
name|COND_PRIO
operator|+
literal|1
expr_stmt|;
name|rprio
operator|=
name|COND_PRIO
expr_stmt|;
goto|goto
name|maybe_reduce
goto|;
name|binop
label|:
name|flags
operator|=
name|LEFT_OPERAND_REQUIRED
operator||
name|RIGHT_OPERAND_REQUIRED
expr_stmt|;
name|rprio
operator|=
name|lprio
operator|+
literal|1
expr_stmt|;
goto|goto
name|maybe_reduce
goto|;
default|default:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"invalid character in #if"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
block|}
name|set_value
label|:
comment|/* Push a value onto the stack.  */
if|if
condition|(
name|top
operator|->
name|flags
operator|&
name|HAVE_VALUE
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"syntax error in #if"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
block|}
name|top
operator|->
name|flags
operator||=
name|HAVE_VALUE
expr_stmt|;
continue|continue;
name|maybe_reduce
label|:
comment|/* Push an operator, and check if we can reduce now.  */
while|while
condition|(
name|top
operator|->
name|rprio
operator|>
name|lprio
condition|)
block|{
name|long
name|v1
init|=
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
decl_stmt|,
name|v2
init|=
name|top
index|[
literal|0
index|]
operator|.
name|value
decl_stmt|;
name|int
name|unsigned1
init|=
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|unsignedp
decl_stmt|,
name|unsigned2
init|=
name|top
index|[
literal|0
index|]
operator|.
name|unsignedp
decl_stmt|;
name|top
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|top
index|[
literal|1
index|]
operator|.
name|flags
operator|&
name|LEFT_OPERAND_REQUIRED
operator|)
operator|&&
operator|!
operator|(
name|top
index|[
literal|0
index|]
operator|.
name|flags
operator|&
name|HAVE_VALUE
operator|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"syntax error - missing left operand"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
block|}
if|if
condition|(
operator|(
name|top
index|[
literal|1
index|]
operator|.
name|flags
operator|&
name|RIGHT_OPERAND_REQUIRED
operator|)
operator|&&
operator|!
operator|(
name|top
index|[
literal|1
index|]
operator|.
name|flags
operator|&
name|HAVE_VALUE
operator|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"syntax error - missing right operand"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
block|}
comment|/* top[0].value = (top[1].op)(v1, v2);*/
switch|switch
condition|(
name|top
index|[
literal|1
index|]
operator|.
name|op
condition|)
block|{
case|case
literal|'+'
case|:
if|if
condition|(
operator|!
operator|(
name|top
operator|->
name|flags
operator|&
name|HAVE_VALUE
operator|)
condition|)
block|{
comment|/* Unary '+' */
name|top
operator|->
name|value
operator|=
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned2
expr_stmt|;
name|top
operator|->
name|flags
operator||=
name|HAVE_VALUE
expr_stmt|;
block|}
else|else
block|{
name|top
operator|->
name|value
operator|=
name|v1
operator|+
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
operator|||
name|unsigned2
expr_stmt|;
if|if
condition|(
operator|!
name|top
operator|->
name|unsignedp
operator|&&
operator|!
name|skip_evaluation
operator|&&
operator|!
name|possible_sum_sign
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
name|top
operator|->
name|value
argument_list|)
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
operator|!
operator|(
name|top
operator|->
name|flags
operator|&
name|HAVE_VALUE
operator|)
condition|)
block|{
comment|/* Unary '-' */
name|top
operator|->
name|value
operator|=
operator|-
name|v2
expr_stmt|;
if|if
condition|(
operator|!
name|skip_evaluation
operator|&&
operator|(
name|top
operator|->
name|value
operator|&
name|v2
operator|)
operator|<
literal|0
operator|&&
operator|!
name|unsigned2
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned2
expr_stmt|;
name|top
operator|->
name|flags
operator||=
name|HAVE_VALUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Binary '-' */
name|top
operator|->
name|value
operator|=
name|v1
operator|-
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
operator|||
name|unsigned2
expr_stmt|;
if|if
condition|(
operator|!
name|top
operator|->
name|unsignedp
operator|&&
operator|!
name|skip_evaluation
operator|&&
operator|!
name|possible_sum_sign
argument_list|(
name|top
operator|->
name|value
argument_list|,
name|v2
argument_list|,
name|v1
argument_list|)
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'*'
case|:
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
operator|||
name|unsigned2
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|unsignedp
condition|)
name|top
operator|->
name|value
operator|=
operator|(
name|unsigned
name|long
operator|)
name|v1
operator|*
name|v2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|skip_evaluation
condition|)
block|{
name|top
operator|->
name|value
operator|=
name|v1
operator|*
name|v2
expr_stmt|;
if|if
condition|(
name|v1
operator|&&
operator|(
name|top
operator|->
name|value
operator|/
name|v1
operator|!=
name|v2
operator|||
operator|(
name|top
operator|->
name|value
operator|&
name|v1
operator|&
name|v2
operator|)
operator|<
literal|0
operator|)
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|skip_evaluation
condition|)
break|break;
if|if
condition|(
name|v2
operator|==
literal|0
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"division by zero in #if"
argument_list|)
expr_stmt|;
name|v2
operator|=
literal|1
expr_stmt|;
block|}
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
operator|||
name|unsigned2
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|unsignedp
condition|)
name|top
operator|->
name|value
operator|=
operator|(
name|unsigned
name|long
operator|)
name|v1
operator|/
name|v2
expr_stmt|;
else|else
block|{
name|top
operator|->
name|value
operator|=
name|v1
operator|/
name|v2
expr_stmt|;
if|if
condition|(
operator|(
name|top
operator|->
name|value
operator|&
name|v1
operator|&
name|v2
operator|)
operator|<
literal|0
condition|)
name|integer_overflow
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
name|skip_evaluation
condition|)
break|break;
if|if
condition|(
name|v2
operator|==
literal|0
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"division by zero in #if"
argument_list|)
expr_stmt|;
name|v2
operator|=
literal|1
expr_stmt|;
block|}
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
operator|||
name|unsigned2
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|unsignedp
condition|)
name|top
operator|->
name|value
operator|=
operator|(
name|unsigned
name|long
operator|)
name|v1
operator|%
name|v2
expr_stmt|;
else|else
name|top
operator|->
name|value
operator|=
name|v1
operator|%
name|v2
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
if|if
condition|(
name|top
operator|->
name|flags
operator|&
name|HAVE_VALUE
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"syntax error"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
block|}
name|top
operator|->
name|value
operator|=
operator|!
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
literal|0
expr_stmt|;
name|top
operator|->
name|flags
operator||=
name|HAVE_VALUE
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
if|if
condition|(
name|top
operator|->
name|flags
operator|&
name|HAVE_VALUE
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"syntax error"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
block|}
name|top
operator|->
name|value
operator|=
operator|~
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned2
expr_stmt|;
name|top
operator|->
name|flags
operator||=
name|HAVE_VALUE
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|COMPARE
argument_list|(
operator|<
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|COMPARE
argument_list|(
operator|>
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEQ
case|:
name|COMPARE
argument_list|(
operator|<=
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEQ
case|:
name|COMPARE
argument_list|(
operator|>=
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQUAL
case|:
name|top
operator|->
name|value
operator|=
operator|(
name|v1
operator|==
name|v2
operator|)
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NOTEQUAL
case|:
name|top
operator|->
name|value
operator|=
operator|(
name|v1
operator|!=
name|v2
operator|)
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LSH
case|:
if|if
condition|(
name|skip_evaluation
condition|)
break|break;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
expr_stmt|;
if|if
condition|(
name|v2
operator|<
literal|0
operator|&&
operator|!
name|unsigned2
condition|)
name|top
operator|->
name|value
operator|=
name|right_shift
argument_list|(
name|pfile
argument_list|,
name|v1
argument_list|,
name|unsigned1
argument_list|,
operator|-
name|v2
argument_list|)
expr_stmt|;
else|else
name|top
operator|->
name|value
operator|=
name|left_shift
argument_list|(
name|pfile
argument_list|,
name|v1
argument_list|,
name|unsigned1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSH
case|:
if|if
condition|(
name|skip_evaluation
condition|)
break|break;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
expr_stmt|;
if|if
condition|(
name|v2
operator|<
literal|0
operator|&&
operator|!
name|unsigned2
condition|)
name|top
operator|->
name|value
operator|=
name|left_shift
argument_list|(
name|pfile
argument_list|,
name|v1
argument_list|,
name|unsigned1
argument_list|,
operator|-
name|v2
argument_list|)
expr_stmt|;
else|else
name|top
operator|->
name|value
operator|=
name|right_shift
argument_list|(
name|pfile
argument_list|,
name|v1
argument_list|,
name|unsigned1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
break|break;
define|#
directive|define
name|LOGICAL
parameter_list|(
name|OP
parameter_list|)
define|\
value|top->value = v1 OP v2;\ 	      top->unsignedp = unsigned1 || unsigned2;
case|case
literal|'&'
case|:
name|LOGICAL
argument_list|(
operator|&
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|LOGICAL
argument_list|(
operator|^
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|LOGICAL
argument_list|(
operator||
argument_list|)
expr_stmt|;
break|break;
case|case
name|ANDAND
case|:
name|top
operator|->
name|value
operator|=
name|v1
operator|&&
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|v1
condition|)
name|skip_evaluation
operator|--
expr_stmt|;
break|break;
case|case
name|OROR
case|:
name|top
operator|->
name|value
operator|=
name|v1
operator|||
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v1
condition|)
name|skip_evaluation
operator|--
expr_stmt|;
break|break;
case|case
literal|','
case|:
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"comma operator in operand of `#if'"
argument_list|)
expr_stmt|;
name|top
operator|->
name|value
operator|=
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned2
expr_stmt|;
break|break;
case|case
literal|'('
case|:
case|case
literal|'?'
case|:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"syntax error in #if"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
case|case
literal|':'
case|:
if|if
condition|(
name|top
index|[
literal|0
index|]
operator|.
name|op
operator|!=
literal|'?'
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"syntax error ':' without preceding '?'"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|top
index|[
literal|1
index|]
operator|.
name|flags
operator|&
name|HAVE_VALUE
operator|)
operator|||
operator|!
operator|(
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|flags
operator|&
name|HAVE_VALUE
operator|)
operator|||
operator|!
operator|(
name|top
index|[
literal|0
index|]
operator|.
name|flags
operator|&
name|HAVE_VALUE
operator|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"bad syntax for ?: operator"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
block|}
else|else
block|{
name|top
operator|--
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|value
condition|)
name|skip_evaluation
operator|--
expr_stmt|;
name|top
operator|->
name|value
operator|=
name|top
operator|->
name|value
condition|?
name|v1
else|:
name|v2
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
operator|||
name|unsigned2
expr_stmt|;
block|}
break|break;
case|case
literal|')'
case|:
if|if
condition|(
operator|(
name|top
index|[
literal|1
index|]
operator|.
name|flags
operator|&
name|HAVE_VALUE
operator|)
operator|||
operator|!
operator|(
name|top
index|[
literal|0
index|]
operator|.
name|flags
operator|&
name|HAVE_VALUE
operator|)
operator|||
name|top
index|[
literal|0
index|]
operator|.
name|op
operator|!=
literal|'('
operator|||
operator|(
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|flags
operator|&
name|HAVE_VALUE
operator|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"mismatched parentheses in #if"
argument_list|)
expr_stmt|;
goto|goto
name|syntax_error
goto|;
block|}
else|else
block|{
name|top
operator|--
expr_stmt|;
name|top
operator|->
name|value
operator|=
name|v1
expr_stmt|;
name|top
operator|->
name|unsignedp
operator|=
name|unsigned1
expr_stmt|;
name|top
operator|->
name|flags
operator||=
name|HAVE_VALUE
expr_stmt|;
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|top
index|[
literal|1
index|]
operator|.
name|op
operator|>=
literal|' '
operator|&&
name|top
index|[
literal|1
index|]
operator|.
name|op
operator|<=
literal|'~'
condition|?
literal|"unimplemented operator '%c'\n"
else|:
literal|"unimplemented operator '\\%03o'\n"
argument_list|,
name|top
index|[
literal|1
index|]
operator|.
name|op
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op
operator|.
name|op
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|top
operator|!=
name|stack
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"internal error in #if expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|!=
name|init_stack
condition|)
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
return|return
name|top
operator|->
name|value
return|;
block|}
name|top
operator|++
expr_stmt|;
comment|/* Check for and handle stack overflow.  */
if|if
condition|(
name|top
operator|==
name|limit
condition|)
block|{
name|struct
name|operation
modifier|*
name|new_stack
decl_stmt|;
name|int
name|old_size
init|=
operator|(
name|char
operator|*
operator|)
name|limit
operator|-
operator|(
name|char
operator|*
operator|)
name|stack
decl_stmt|;
name|int
name|new_size
init|=
literal|2
operator|*
name|old_size
decl_stmt|;
if|if
condition|(
name|stack
operator|!=
name|init_stack
condition|)
name|new_stack
operator|=
operator|(
expr|struct
name|operation
operator|*
operator|)
name|xrealloc
argument_list|(
name|stack
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
else|else
block|{
name|new_stack
operator|=
operator|(
expr|struct
name|operation
operator|*
operator|)
name|xmalloc
argument_list|(
name|new_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|stack
argument_list|,
operator|(
name|char
operator|*
operator|)
name|new_stack
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
block|}
name|stack
operator|=
name|new_stack
expr_stmt|;
name|top
operator|=
operator|(
expr|struct
name|operation
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|new_stack
operator|+
name|old_size
operator|)
expr_stmt|;
name|limit
operator|=
operator|(
expr|struct
name|operation
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|new_stack
operator|+
name|new_size
operator|)
expr_stmt|;
block|}
name|top
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|top
operator|->
name|rprio
operator|=
name|rprio
expr_stmt|;
name|top
operator|->
name|op
operator|=
name|op
operator|.
name|op
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|.
name|op
operator|==
name|OROR
operator|&&
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|)
operator|||
operator|(
name|op
operator|.
name|op
operator|==
name|ANDAND
operator|&&
operator|!
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|)
operator|||
operator|(
name|op
operator|.
name|op
operator|==
literal|'?'
operator|&&
operator|!
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|)
condition|)
block|{
name|skip_evaluation
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|.
name|op
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|top
index|[
operator|-
literal|2
index|]
operator|.
name|value
condition|)
comment|/* Was condition true? */
name|skip_evaluation
operator|++
expr_stmt|;
else|else
name|skip_evaluation
operator|--
expr_stmt|;
block|}
block|}
name|syntax_error
label|:
if|if
condition|(
name|stack
operator|!=
name|init_stack
condition|)
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

