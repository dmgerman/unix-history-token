begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Parse C expressions for cpplib.    Copyright (C) 1987, 1992, 1994, 1995, 1997, 1998, 1999, 2000, 2001,    2002 Free Software Foundation.    Contributed by Per Bothner, 1994.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"cpphash.h"
end_include

begin_define
define|#
directive|define
name|PART_PRECISION
value|(sizeof (cpp_num_part) * CHAR_BIT)
end_define

begin_define
define|#
directive|define
name|HALF_MASK
value|(~(cpp_num_part) 0>> (PART_PRECISION / 2))
end_define

begin_define
define|#
directive|define
name|LOW_PART
parameter_list|(
name|num_part
parameter_list|)
value|(num_part& HALF_MASK)
end_define

begin_define
define|#
directive|define
name|HIGH_PART
parameter_list|(
name|num_part
parameter_list|)
value|(num_part>> (PART_PRECISION / 2))
end_define

begin_struct
struct|struct
name|op
block|{
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
comment|/* The token forming op (for diagnostics).  */
name|cpp_num
name|value
decl_stmt|;
comment|/* The value logically "right" of op.  */
name|enum
name|cpp_ttype
name|op
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Some simple utility routines on double integers.  */
end_comment

begin_define
define|#
directive|define
name|num_zerop
parameter_list|(
name|num
parameter_list|)
value|((num.low | num.high) == 0)
end_define

begin_define
define|#
directive|define
name|num_eq
parameter_list|(
name|num1
parameter_list|,
name|num2
parameter_list|)
value|(num1.low == num2.low&& num1.high == num2.high)
end_define

begin_decl_stmt
specifier|static
name|bool
name|num_positive
name|PARAMS
argument_list|(
operator|(
name|cpp_num
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|num_greater_eq
name|PARAMS
argument_list|(
operator|(
name|cpp_num
operator|,
name|cpp_num
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_num
name|num_trim
name|PARAMS
argument_list|(
operator|(
name|cpp_num
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_num
name|num_part_mul
name|PARAMS
argument_list|(
operator|(
name|cpp_num_part
operator|,
name|cpp_num_part
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_num
name|num_unary_op
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_num
operator|,
expr|enum
name|cpp_ttype
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_num
name|num_binary_op
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_num
operator|,
name|cpp_num
operator|,
expr|enum
name|cpp_ttype
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_num
name|num_negate
name|PARAMS
argument_list|(
operator|(
name|cpp_num
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_num
name|num_bitwise_op
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_num
operator|,
name|cpp_num
operator|,
expr|enum
name|cpp_ttype
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_num
name|num_inequality_op
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_num
operator|,
name|cpp_num
operator|,
expr|enum
name|cpp_ttype
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_num
name|num_equality_op
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_num
operator|,
name|cpp_num
operator|,
expr|enum
name|cpp_ttype
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_num
name|num_mul
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_num
operator|,
name|cpp_num
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_num
name|num_div_op
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_num
operator|,
name|cpp_num
operator|,
expr|enum
name|cpp_ttype
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_num
name|num_lshift
name|PARAMS
argument_list|(
operator|(
name|cpp_num
operator|,
name|size_t
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_num
name|num_rshift
name|PARAMS
argument_list|(
operator|(
name|cpp_num
operator|,
name|size_t
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_num
name|append_digit
name|PARAMS
argument_list|(
operator|(
name|cpp_num
operator|,
name|int
operator|,
name|int
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_num
name|parse_defined
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_num
name|eval_token
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|cpp_token
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|op
modifier|*
name|reduce
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|op
operator|*
operator|,
expr|enum
name|cpp_ttype
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|interpret_float_suffix
name|PARAMS
argument_list|(
operator|(
specifier|const
name|uchar
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|interpret_int_suffix
name|PARAMS
argument_list|(
operator|(
specifier|const
name|uchar
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_promotion
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
expr|struct
name|op
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Token type abuse to create unary plus and minus operators.  */
end_comment

begin_define
define|#
directive|define
name|CPP_UPLUS
value|(CPP_LAST_CPP_OP + 1)
end_define

begin_define
define|#
directive|define
name|CPP_UMINUS
value|(CPP_LAST_CPP_OP + 2)
end_define

begin_comment
comment|/* With -O2, gcc appears to produce nice code, moving the error    message load and subsequent jump completely out of the main path.  */
end_comment

begin_define
define|#
directive|define
name|SYNTAX_ERROR
parameter_list|(
name|msgid
parameter_list|)
define|\
value|do { cpp_error (pfile, DL_ERROR, msgid); goto syntax_error; } while(0)
end_define

begin_define
define|#
directive|define
name|SYNTAX_ERROR2
parameter_list|(
name|msgid
parameter_list|,
name|arg
parameter_list|)
define|\
value|do { cpp_error (pfile, DL_ERROR, msgid, arg); goto syntax_error; } while(0)
end_define

begin_comment
comment|/* Subroutine of cpp_classify_number.  S points to a float suffix of    length LEN, possibly zero.  Returns 0 for an invalid suffix, or a    flag vector describing the suffix.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|interpret_float_suffix
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
specifier|const
name|uchar
modifier|*
name|s
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|size_t
name|f
init|=
literal|0
decl_stmt|,
name|l
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
switch|switch
condition|(
name|s
index|[
name|len
index|]
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|f
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
name|l
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
case|case
literal|'j'
case|:
case|case
literal|'J'
case|:
name|i
operator|++
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
if|if
condition|(
name|f
operator|+
name|l
operator|>
literal|1
operator|||
name|i
operator|>
literal|1
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|i
condition|?
name|CPP_N_IMAGINARY
else|:
literal|0
operator|)
operator||
operator|(
name|f
condition|?
name|CPP_N_SMALL
else|:
name|l
condition|?
name|CPP_N_LARGE
else|:
name|CPP_N_MEDIUM
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of cpp_classify_number.  S points to an integer suffix    of length LEN, possibly zero. Returns 0 for an invalid suffix, or a    flag vector describing the suffix.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|interpret_int_suffix
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
specifier|const
name|uchar
modifier|*
name|s
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|size_t
name|u
decl_stmt|,
name|l
decl_stmt|,
name|i
decl_stmt|;
name|u
operator|=
name|l
operator|=
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
switch|switch
condition|(
name|s
index|[
name|len
index|]
condition|)
block|{
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
name|u
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
case|case
literal|'j'
case|:
case|case
literal|'J'
case|:
name|i
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
name|l
operator|++
expr_stmt|;
comment|/* If there are two Ls, they must be adjacent and the same case.  */
if|if
condition|(
name|l
operator|==
literal|2
operator|&&
name|s
index|[
name|len
index|]
operator|!=
name|s
index|[
name|len
operator|+
literal|1
index|]
condition|)
return|return
literal|0
return|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
if|if
condition|(
name|l
operator|>
literal|2
operator|||
name|u
operator|>
literal|1
operator|||
name|i
operator|>
literal|1
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|i
condition|?
name|CPP_N_IMAGINARY
else|:
literal|0
operator|)
operator||
operator|(
name|u
condition|?
name|CPP_N_UNSIGNED
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|l
operator|==
literal|0
operator|)
condition|?
name|CPP_N_SMALL
else|:
operator|(
name|l
operator|==
literal|1
operator|)
condition|?
name|CPP_N_MEDIUM
else|:
name|CPP_N_LARGE
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Categorize numeric constants according to their field (integer,    floating point, or invalid), radix (decimal, octal, hexadecimal),    and type suffixes.  */
end_comment

begin_function
name|unsigned
name|int
name|cpp_classify_number
parameter_list|(
name|pfile
parameter_list|,
name|token
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
block|{
specifier|const
name|uchar
modifier|*
name|str
init|=
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|limit
decl_stmt|;
name|unsigned
name|int
name|max_digit
decl_stmt|,
name|result
decl_stmt|,
name|radix
decl_stmt|;
enum|enum
block|{
name|NOT_FLOAT
init|=
literal|0
block|,
name|AFTER_POINT
block|,
name|AFTER_EXPON
block|}
name|float_flag
enum|;
comment|/* If the lexer has done its job, length one can only be a single      digit.  Fast-path this very common case.  */
if|if
condition|(
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|==
literal|1
condition|)
return|return
name|CPP_N_INTEGER
operator||
name|CPP_N_SMALL
operator||
name|CPP_N_DECIMAL
return|;
name|limit
operator|=
name|str
operator|+
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
expr_stmt|;
name|float_flag
operator|=
name|NOT_FLOAT
expr_stmt|;
name|max_digit
operator|=
literal|0
expr_stmt|;
name|radix
operator|=
literal|10
expr_stmt|;
comment|/* First, interpret the radix.  */
if|if
condition|(
operator|*
name|str
operator|==
literal|'0'
condition|)
block|{
name|radix
operator|=
literal|8
expr_stmt|;
name|str
operator|++
expr_stmt|;
comment|/* Require at least one hex digit to classify it as hex.  */
if|if
condition|(
operator|(
operator|*
name|str
operator|==
literal|'x'
operator|||
operator|*
name|str
operator|==
literal|'X'
operator|)
operator|&&
name|ISXDIGIT
argument_list|(
name|str
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|radix
operator|=
literal|16
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
block|}
comment|/* Now scan for a well-formed integer or float.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|int
name|c
init|=
operator|*
name|str
operator|++
decl_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|ISXDIGIT
argument_list|(
name|c
argument_list|)
operator|&&
name|radix
operator|==
literal|16
operator|)
condition|)
block|{
name|c
operator|=
name|hex_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
name|max_digit
condition|)
name|max_digit
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|float_flag
operator|==
name|NOT_FLOAT
condition|)
name|float_flag
operator|=
name|AFTER_POINT
expr_stmt|;
else|else
name|SYNTAX_ERROR
argument_list|(
literal|"too many decimal points in number"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|radix
operator|<=
literal|10
operator|&&
operator|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
operator|)
operator|)
operator|||
operator|(
name|radix
operator|==
literal|16
operator|&&
operator|(
name|c
operator|==
literal|'p'
operator|||
name|c
operator|==
literal|'P'
operator|)
operator|)
condition|)
block|{
name|float_flag
operator|=
name|AFTER_EXPON
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* Start of suffix.  */
name|str
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|float_flag
operator|!=
name|NOT_FLOAT
operator|&&
name|radix
operator|==
literal|8
condition|)
name|radix
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|max_digit
operator|>=
name|radix
condition|)
name|SYNTAX_ERROR2
argument_list|(
literal|"invalid digit \"%c\" in octal constant"
argument_list|,
literal|'0'
operator|+
name|max_digit
argument_list|)
expr_stmt|;
if|if
condition|(
name|float_flag
operator|!=
name|NOT_FLOAT
condition|)
block|{
if|if
condition|(
name|radix
operator|==
literal|16
operator|&&
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_PEDWARN
argument_list|,
literal|"use of C99 hexadecimal floating constant"
argument_list|)
expr_stmt|;
if|if
condition|(
name|float_flag
operator|==
name|AFTER_EXPON
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'+'
operator|||
operator|*
name|str
operator|==
literal|'-'
condition|)
name|str
operator|++
expr_stmt|;
comment|/* Exponent is decimal, even if string is a hex float.  */
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|SYNTAX_ERROR
argument_list|(
literal|"exponent has no digits"
argument_list|)
expr_stmt|;
do|do
name|str
operator|++
expr_stmt|;
do|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|str
argument_list|)
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|radix
operator|==
literal|16
condition|)
name|SYNTAX_ERROR
argument_list|(
literal|"hexadecimal floating constants require an exponent"
argument_list|)
expr_stmt|;
name|result
operator|=
name|interpret_float_suffix
argument_list|(
name|str
argument_list|,
name|limit
operator|-
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ERROR
argument_list|,
literal|"invalid suffix \"%.*s\" on floating constant"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|limit
operator|-
name|str
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|CPP_N_INVALID
return|;
block|}
comment|/* Traditional C didn't accept any floating suffixes.  */
if|if
condition|(
name|limit
operator|!=
name|str
operator|&&
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|cpp_sys_macro_p
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_WARNING
argument_list|,
literal|"traditional C rejects the \"%.*s\" suffix"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|limit
operator|-
name|str
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|result
operator||=
name|CPP_N_FLOATING
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|interpret_int_suffix
argument_list|(
name|str
argument_list|,
name|limit
operator|-
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ERROR
argument_list|,
literal|"invalid suffix \"%.*s\" on integer constant"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|limit
operator|-
name|str
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|CPP_N_INVALID
return|;
block|}
comment|/* Traditional C only accepted the 'L' suffix.          Suppress warning about 'LL' with -Wno-long-long.  */
if|if
condition|(
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|cpp_sys_macro_p
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|int
name|u_or_i
init|=
operator|(
name|result
operator|&
operator|(
name|CPP_N_UNSIGNED
operator||
name|CPP_N_IMAGINARY
operator|)
operator|)
decl_stmt|;
name|int
name|large
init|=
operator|(
name|result
operator|&
name|CPP_N_WIDTH
operator|)
operator|==
name|CPP_N_LARGE
decl_stmt|;
if|if
condition|(
name|u_or_i
operator|||
operator|(
name|large
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_long_long
argument_list|)
operator|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_WARNING
argument_list|,
literal|"traditional C rejects the \"%.*s\" suffix"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|limit
operator|-
name|str
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|result
operator|&
name|CPP_N_WIDTH
operator|)
operator|==
name|CPP_N_LARGE
operator|&&
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_long_long
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_PEDWARN
argument_list|,
literal|"use of C99 long long integer constant"
argument_list|)
expr_stmt|;
name|result
operator||=
name|CPP_N_INTEGER
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|result
operator|&
name|CPP_N_IMAGINARY
operator|)
operator|&&
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_PEDWARN
argument_list|,
literal|"imaginary constants are a GCC extension"
argument_list|)
expr_stmt|;
if|if
condition|(
name|radix
operator|==
literal|10
condition|)
name|result
operator||=
name|CPP_N_DECIMAL
expr_stmt|;
elseif|else
if|if
condition|(
name|radix
operator|==
literal|16
condition|)
name|result
operator||=
name|CPP_N_HEX
expr_stmt|;
else|else
name|result
operator||=
name|CPP_N_OCTAL
expr_stmt|;
return|return
name|result
return|;
name|syntax_error
label|:
return|return
name|CPP_N_INVALID
return|;
block|}
end_function

begin_comment
comment|/* cpp_interpret_integer converts an integer constant into a cpp_num,    of precision options->precision.     We do not provide any interface for decimal->float conversion,    because the preprocessor doesn't need it and the floating point    handling in GCC proper is too ugly to speak of.  */
end_comment

begin_function
name|cpp_num
name|cpp_interpret_integer
parameter_list|(
name|pfile
parameter_list|,
name|token
parameter_list|,
name|type
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
block|{
specifier|const
name|uchar
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|cpp_num
name|result
decl_stmt|;
name|result
operator|.
name|low
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|unsignedp
operator|=
operator|!
operator|!
operator|(
name|type
operator|&
name|CPP_N_UNSIGNED
operator|)
expr_stmt|;
name|result
operator|.
name|overflow
operator|=
name|false
expr_stmt|;
name|p
operator|=
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
expr_stmt|;
comment|/* Common case of a single digit.  */
if|if
condition|(
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|==
literal|1
condition|)
name|result
operator|.
name|low
operator|=
name|p
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
else|else
block|{
name|cpp_num_part
name|max
decl_stmt|;
name|size_t
name|precision
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|precision
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|base
init|=
literal|10
decl_stmt|,
name|c
init|=
literal|0
decl_stmt|;
name|bool
name|overflow
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|CPP_N_RADIX
operator|)
operator|==
name|CPP_N_OCTAL
condition|)
block|{
name|base
operator|=
literal|8
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|type
operator|&
name|CPP_N_RADIX
operator|)
operator|==
name|CPP_N_HEX
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* We can add a digit to numbers strictly less than this without 	 needing the precision and slowness of double integers.  */
name|max
operator|=
operator|~
operator|(
name|cpp_num_part
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|precision
operator|<
name|PART_PRECISION
condition|)
name|max
operator|>>=
name|PART_PRECISION
operator|-
name|precision
expr_stmt|;
name|max
operator|=
operator|(
name|max
operator|-
name|base
operator|+
literal|1
operator|)
operator|/
name|base
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|base
operator|==
literal|16
operator|&&
name|ISXDIGIT
argument_list|(
name|c
argument_list|)
operator|)
condition|)
name|c
operator|=
name|hex_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
break|break;
comment|/* Strict inequality for when max is set to zero.  */
if|if
condition|(
name|result
operator|.
name|low
operator|<
name|max
condition|)
name|result
operator|.
name|low
operator|=
name|result
operator|.
name|low
operator|*
name|base
operator|+
name|c
expr_stmt|;
else|else
block|{
name|result
operator|=
name|append_digit
argument_list|(
name|result
argument_list|,
name|c
argument_list|,
name|base
argument_list|,
name|precision
argument_list|)
expr_stmt|;
name|overflow
operator||=
name|result
operator|.
name|overflow
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|overflow
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_PEDWARN
argument_list|,
literal|"integer constant is too large for its type"
argument_list|)
expr_stmt|;
comment|/* If too big to be signed, consider it unsigned.  Only warn for 	 decimal numbers.  Traditional numbers were always signed (but 	 we still honor an explicit U suffix); but we only have 	 traditional semantics in directives.  */
elseif|else
if|if
condition|(
operator|!
name|result
operator|.
name|unsignedp
operator|&&
operator|!
operator|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
operator|&&
name|pfile
operator|->
name|state
operator|.
name|in_directive
operator|)
operator|&&
operator|!
name|num_positive
argument_list|(
name|result
argument_list|,
name|precision
argument_list|)
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|10
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_WARNING
argument_list|,
literal|"integer constant is so large that it is unsigned"
argument_list|)
expr_stmt|;
name|result
operator|.
name|unsignedp
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Append DIGIT to NUM, a number of PRECISION bits being read in base    BASE.  */
end_comment

begin_function
specifier|static
name|cpp_num
name|append_digit
parameter_list|(
name|num
parameter_list|,
name|digit
parameter_list|,
name|base
parameter_list|,
name|precision
parameter_list|)
name|cpp_num
name|num
decl_stmt|;
name|int
name|digit
decl_stmt|,
name|base
decl_stmt|;
name|size_t
name|precision
decl_stmt|;
block|{
name|cpp_num
name|result
decl_stmt|;
name|unsigned
name|int
name|shift
init|=
literal|3
operator|+
operator|(
name|base
operator|==
literal|16
operator|)
decl_stmt|;
name|bool
name|overflow
decl_stmt|;
name|cpp_num_part
name|add_high
decl_stmt|,
name|add_low
decl_stmt|;
comment|/* Multiply by 8 or 16.  Catching this overflow here means we don't      need to worry about add_high overflowing.  */
name|overflow
operator|=
operator|!
operator|!
operator|(
name|num
operator|.
name|high
operator|>>
operator|(
name|PART_PRECISION
operator|-
name|shift
operator|)
operator|)
expr_stmt|;
name|result
operator|.
name|high
operator|=
name|num
operator|.
name|high
operator|<<
name|shift
expr_stmt|;
name|result
operator|.
name|low
operator|=
name|num
operator|.
name|low
operator|<<
name|shift
expr_stmt|;
name|result
operator|.
name|high
operator||=
name|num
operator|.
name|low
operator|>>
operator|(
name|PART_PRECISION
operator|-
name|shift
operator|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|10
condition|)
block|{
name|add_low
operator|=
name|num
operator|.
name|low
operator|<<
literal|1
expr_stmt|;
name|add_high
operator|=
operator|(
name|num
operator|.
name|high
operator|<<
literal|1
operator|)
operator|+
operator|(
name|num
operator|.
name|low
operator|>>
operator|(
name|PART_PRECISION
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|add_high
operator|=
name|add_low
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|add_low
operator|+
name|digit
operator|<
name|add_low
condition|)
name|add_high
operator|++
expr_stmt|;
name|add_low
operator|+=
name|digit
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|low
operator|+
name|add_low
operator|<
name|result
operator|.
name|low
condition|)
name|add_high
operator|++
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|high
operator|+
name|add_high
operator|<
name|result
operator|.
name|high
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|result
operator|.
name|low
operator|+=
name|add_low
expr_stmt|;
name|result
operator|.
name|high
operator|+=
name|add_high
expr_stmt|;
comment|/* The above code catches overflow of a cpp_num type.  This catches      overflow of the (possibly shorter) target precision.  */
name|num
operator|.
name|low
operator|=
name|result
operator|.
name|low
expr_stmt|;
name|num
operator|.
name|high
operator|=
name|result
operator|.
name|high
expr_stmt|;
name|result
operator|=
name|num_trim
argument_list|(
name|result
argument_list|,
name|precision
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num_eq
argument_list|(
name|result
argument_list|,
name|num
argument_list|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|result
operator|.
name|unsignedp
operator|=
name|num
operator|.
name|unsignedp
expr_stmt|;
name|result
operator|.
name|overflow
operator|=
name|overflow
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Handle meeting "defined" in a preprocessor expression.  */
end_comment

begin_function
specifier|static
name|cpp_num
name|parse_defined
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_num
name|result
decl_stmt|;
name|int
name|paren
init|=
literal|0
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
init|=
literal|0
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|cpp_context
modifier|*
name|initial_context
init|=
name|pfile
operator|->
name|context
decl_stmt|;
comment|/* Don't expand macros.  */
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|++
expr_stmt|;
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
condition|)
block|{
name|paren
operator|=
literal|1
expr_stmt|;
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
block|{
name|node
operator|=
name|token
operator|->
name|val
operator|.
name|node
expr_stmt|;
if|if
condition|(
name|paren
operator|&&
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
operator|->
name|type
operator|!=
name|CPP_CLOSE_PAREN
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ERROR
argument_list|,
literal|"missing ')' after \"defined\""
argument_list|)
expr_stmt|;
name|node
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ERROR
argument_list|,
literal|"operator \"defined\" requires an identifier"
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|NAMED_OP
condition|)
block|{
name|cpp_token
name|op
decl_stmt|;
name|op
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|op
operator|.
name|type
operator|=
name|token
operator|->
name|type
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ERROR
argument_list|,
literal|"(\"%s\" is an alternative token for \"%s\" in C++)"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|)
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
operator|&
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|pfile
operator|->
name|context
operator|!=
name|initial_context
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_WARNING
argument_list|,
literal|"this use of \"defined\" may not be portable"
argument_list|)
expr_stmt|;
name|_cpp_mark_macro_used
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* A possible controlling macro of the form #if !defined (). 	 _cpp_parse_expr checks there was no other junk on the line.  */
name|pfile
operator|->
name|mi_ind_cmacro
operator|=
name|node
expr_stmt|;
block|}
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|--
expr_stmt|;
name|result
operator|.
name|unsignedp
operator|=
name|false
expr_stmt|;
name|result
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|overflow
operator|=
name|false
expr_stmt|;
name|result
operator|.
name|low
operator|=
name|node
operator|&&
name|node
operator|->
name|type
operator|==
name|NT_MACRO
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Convert a token into a CPP_NUMBER (an interpreted preprocessing    number or character constant, or the result of the "defined" or "#"    operators).  */
end_comment

begin_function
specifier|static
name|cpp_num
name|eval_token
parameter_list|(
name|pfile
parameter_list|,
name|token
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
block|{
name|cpp_num
name|result
decl_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|;
name|int
name|unsignedp
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_NUMBER
case|:
name|temp
operator|=
name|cpp_classify_number
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|temp
operator|&
name|CPP_N_CATEGORY
condition|)
block|{
case|case
name|CPP_N_FLOATING
case|:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ERROR
argument_list|,
literal|"floating constant in preprocessor expression"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_N_INTEGER
case|:
if|if
condition|(
operator|!
operator|(
name|temp
operator|&
name|CPP_N_IMAGINARY
operator|)
condition|)
return|return
name|cpp_interpret_integer
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|,
name|temp
argument_list|)
return|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ERROR
argument_list|,
literal|"imaginary number in preprocessor expression"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_N_INVALID
case|:
comment|/* Error already issued.  */
break|break;
block|}
name|result
operator|.
name|high
operator|=
name|result
operator|.
name|low
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CPP_WCHAR
case|:
case|case
name|CPP_CHAR
case|:
block|{
name|cppchar_t
name|cc
init|=
name|cpp_interpret_charconst
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|,
operator|&
name|temp
argument_list|,
operator|&
name|unsignedp
argument_list|)
decl_stmt|;
name|result
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|low
operator|=
name|cc
expr_stmt|;
comment|/* Sign-extend the result if necessary.  */
if|if
condition|(
operator|!
name|unsignedp
operator|&&
operator|(
name|cppchar_signed_t
operator|)
name|cc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|PART_PRECISION
operator|>
name|BITS_PER_CPPCHAR_T
condition|)
name|result
operator|.
name|low
operator||=
operator|~
operator|(
operator|~
operator|(
name|cpp_num_part
operator|)
literal|0
operator|>>
operator|(
name|PART_PRECISION
operator|-
name|BITS_PER_CPPCHAR_T
operator|)
operator|)
expr_stmt|;
name|result
operator|.
name|high
operator|=
operator|~
operator|(
name|cpp_num_part
operator|)
literal|0
expr_stmt|;
name|result
operator|=
name|num_trim
argument_list|(
name|result
argument_list|,
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|precision
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CPP_NAME
case|:
if|if
condition|(
name|token
operator|->
name|val
operator|.
name|node
operator|==
name|pfile
operator|->
name|spec_nodes
operator|.
name|n_defined
condition|)
return|return
name|parse_defined
argument_list|(
name|pfile
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
operator|&&
operator|(
name|token
operator|->
name|val
operator|.
name|node
operator|==
name|pfile
operator|->
name|spec_nodes
operator|.
name|n_true
operator|||
name|token
operator|->
name|val
operator|.
name|node
operator|==
name|pfile
operator|->
name|spec_nodes
operator|.
name|n_false
operator|)
condition|)
block|{
name|result
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|low
operator|=
operator|(
name|token
operator|->
name|val
operator|.
name|node
operator|==
name|pfile
operator|->
name|spec_nodes
operator|.
name|n_true
operator|)
expr_stmt|;
comment|/* Warn about use of true or false in #if when pedantic 	     and stdbool.h has not been included.  */
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|cpp_defined
argument_list|(
name|pfile
argument_list|,
name|DSC
argument_list|(
literal|"__bool_true_false_are_defined"
argument_list|)
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_PEDWARN
argument_list|,
literal|"ISO C++ does not permit \"%s\" in #if"
argument_list|,
name|NODE_NAME
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|low
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_undef
argument_list|)
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|skip_eval
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_WARNING
argument_list|,
literal|"\"%s\" is not defined"
argument_list|,
name|NODE_NAME
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* CPP_HASH */
name|_cpp_test_assertion
argument_list|(
name|pfile
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|result
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|low
operator|=
name|temp
expr_stmt|;
block|}
name|result
operator|.
name|unsignedp
operator|=
operator|!
operator|!
name|unsignedp
expr_stmt|;
name|result
operator|.
name|overflow
operator|=
name|false
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Operator precedence and flags table.  After an operator is returned from the lexer, if it has priority less than the operator on the top of the stack, we reduce the stack by one operator and repeat the test.  Since equal priorities do not reduce, this is naturally right-associative.  We handle left-associative operators by decrementing the priority of just-lexed operators by one, but retaining the priority of operators already on the stack.  The remaining cases are '(' and ')'.  We handle '(' by skipping the reduction phase completely.  ')' is given lower priority than everything else, including '(', effectively forcing a reduction of the parenthesised expression.  If there is a matching '(', the routine reduce() exits immediately.  If the normal exit route sees a ')', then there cannot have been a matching '(' and an error message is output.  The parser assumes all shifted operators require a left operand unless the flag NO_L_OPERAND is set.  These semantics are automatic; any extra semantics need to be handled with operator-specific code.  */
end_comment

begin_comment
comment|/* Flags.  If CHECK_PROMOTION, we warn if the effective sign of an    operand changes because of integer promotions.  */
end_comment

begin_define
define|#
directive|define
name|NO_L_OPERAND
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|LEFT_ASSOC
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|CHECK_PROMOTION
value|(1<< 2)
end_define

begin_comment
comment|/* Operator to priority map.  Must be in the same order as the first    N entries of enum cpp_ttype.  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|operator
block|{
name|uchar
name|prio
decl_stmt|;
name|uchar
name|flags
decl_stmt|;
block|}
name|optab
index|[]
init|=
block|{
comment|/* EQ */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* Shouldn't happen.  */
comment|/* NOT */
block|{
literal|16
block|,
name|NO_L_OPERAND
block|}
block|,
comment|/* GREATER */
block|{
literal|12
block|,
name|LEFT_ASSOC
operator||
name|CHECK_PROMOTION
block|}
block|,
comment|/* LESS */
block|{
literal|12
block|,
name|LEFT_ASSOC
operator||
name|CHECK_PROMOTION
block|}
block|,
comment|/* PLUS */
block|{
literal|14
block|,
name|LEFT_ASSOC
operator||
name|CHECK_PROMOTION
block|}
block|,
comment|/* MINUS */
block|{
literal|14
block|,
name|LEFT_ASSOC
operator||
name|CHECK_PROMOTION
block|}
block|,
comment|/* MULT */
block|{
literal|15
block|,
name|LEFT_ASSOC
operator||
name|CHECK_PROMOTION
block|}
block|,
comment|/* DIV */
block|{
literal|15
block|,
name|LEFT_ASSOC
operator||
name|CHECK_PROMOTION
block|}
block|,
comment|/* MOD */
block|{
literal|15
block|,
name|LEFT_ASSOC
operator||
name|CHECK_PROMOTION
block|}
block|,
comment|/* AND */
block|{
literal|9
block|,
name|LEFT_ASSOC
operator||
name|CHECK_PROMOTION
block|}
block|,
comment|/* OR */
block|{
literal|7
block|,
name|LEFT_ASSOC
operator||
name|CHECK_PROMOTION
block|}
block|,
comment|/* XOR */
block|{
literal|8
block|,
name|LEFT_ASSOC
operator||
name|CHECK_PROMOTION
block|}
block|,
comment|/* RSHIFT */
block|{
literal|13
block|,
name|LEFT_ASSOC
block|}
block|,
comment|/* LSHIFT */
block|{
literal|13
block|,
name|LEFT_ASSOC
block|}
block|,
comment|/* MIN */
block|{
literal|10
block|,
name|LEFT_ASSOC
operator||
name|CHECK_PROMOTION
block|}
block|,
comment|/* MAX */
block|{
literal|10
block|,
name|LEFT_ASSOC
operator||
name|CHECK_PROMOTION
block|}
block|,
comment|/* COMPL */
block|{
literal|16
block|,
name|NO_L_OPERAND
block|}
block|,
comment|/* AND_AND */
block|{
literal|6
block|,
name|LEFT_ASSOC
block|}
block|,
comment|/* OR_OR */
block|{
literal|5
block|,
name|LEFT_ASSOC
block|}
block|,
comment|/* QUERY */
block|{
literal|3
block|,
literal|0
block|}
block|,
comment|/* COLON */
block|{
literal|4
block|,
name|LEFT_ASSOC
operator||
name|CHECK_PROMOTION
block|}
block|,
comment|/* COMMA */
block|{
literal|2
block|,
name|LEFT_ASSOC
block|}
block|,
comment|/* OPEN_PAREN */
block|{
literal|1
block|,
name|NO_L_OPERAND
block|}
block|,
comment|/* CLOSE_PAREN */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* EOF */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* EQ_EQ */
block|{
literal|11
block|,
name|LEFT_ASSOC
block|}
block|,
comment|/* NOT_EQ */
block|{
literal|11
block|,
name|LEFT_ASSOC
block|}
block|,
comment|/* GREATER_EQ */
block|{
literal|12
block|,
name|LEFT_ASSOC
operator||
name|CHECK_PROMOTION
block|}
block|,
comment|/* LESS_EQ */
block|{
literal|12
block|,
name|LEFT_ASSOC
operator||
name|CHECK_PROMOTION
block|}
block|,
comment|/* UPLUS */
block|{
literal|16
block|,
name|NO_L_OPERAND
block|}
block|,
comment|/* UMINUS */
block|{
literal|16
block|,
name|NO_L_OPERAND
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Parse and evaluate a C expression, reading from PFILE.    Returns the truth value of the expression.     The implementation is an operator precedence parser, i.e. a    bottom-up parser, using a stack for not-yet-reduced tokens.     The stack base is op_stack, and the current stack pointer is 'top'.    There is a stack element for each operator (only), and the most    recently pushed operator is 'top->op'.  An operand (value) is    stored in the 'value' field of the stack element of the operator    that precedes it.  */
end_comment

begin_function
name|bool
name|_cpp_parse_expr
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|struct
name|op
modifier|*
name|top
init|=
name|pfile
operator|->
name|op_stack
decl_stmt|;
name|unsigned
name|int
name|lex_count
decl_stmt|;
name|bool
name|saw_leading_not
decl_stmt|,
name|want_value
init|=
name|true
decl_stmt|;
name|pfile
operator|->
name|state
operator|.
name|skip_eval
operator|=
literal|0
expr_stmt|;
comment|/* Set up detection of #if ! defined().  */
name|pfile
operator|->
name|mi_ind_cmacro
operator|=
literal|0
expr_stmt|;
name|saw_leading_not
operator|=
name|false
expr_stmt|;
name|lex_count
operator|=
literal|0
expr_stmt|;
comment|/* Lowest priority operator prevents further reductions.  */
name|top
operator|->
name|op
operator|=
name|CPP_EOF
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|op
name|op
decl_stmt|;
name|lex_count
operator|++
expr_stmt|;
name|op
operator|.
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|op
operator|.
name|op
operator|=
name|op
operator|.
name|token
operator|->
name|type
expr_stmt|;
switch|switch
condition|(
name|op
operator|.
name|op
condition|)
block|{
comment|/* These tokens convert into values.  */
case|case
name|CPP_NUMBER
case|:
case|case
name|CPP_CHAR
case|:
case|case
name|CPP_WCHAR
case|:
case|case
name|CPP_NAME
case|:
case|case
name|CPP_HASH
case|:
if|if
condition|(
operator|!
name|want_value
condition|)
name|SYNTAX_ERROR2
argument_list|(
literal|"missing binary operator before token \"%s\""
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|op
operator|.
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|want_value
operator|=
name|false
expr_stmt|;
name|top
operator|->
name|value
operator|=
name|eval_token
argument_list|(
name|pfile
argument_list|,
name|op
operator|.
name|token
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|CPP_NOT
case|:
name|saw_leading_not
operator|=
name|lex_count
operator|==
literal|1
expr_stmt|;
break|break;
case|case
name|CPP_PLUS
case|:
if|if
condition|(
name|want_value
condition|)
name|op
operator|.
name|op
operator|=
name|CPP_UPLUS
expr_stmt|;
break|break;
case|case
name|CPP_MINUS
case|:
if|if
condition|(
name|want_value
condition|)
name|op
operator|.
name|op
operator|=
name|CPP_UMINUS
expr_stmt|;
break|break;
case|case
name|CPP_OTHER
case|:
if|if
condition|(
name|ISGRAPH
argument_list|(
name|op
operator|.
name|token
operator|->
name|val
operator|.
name|c
argument_list|)
condition|)
name|SYNTAX_ERROR2
argument_list|(
literal|"invalid character '%c' in #if"
argument_list|,
name|op
operator|.
name|token
operator|->
name|val
operator|.
name|c
argument_list|)
expr_stmt|;
else|else
name|SYNTAX_ERROR2
argument_list|(
literal|"invalid character '\\%03o' in #if"
argument_list|,
name|op
operator|.
name|token
operator|->
name|val
operator|.
name|c
argument_list|)
expr_stmt|;
default|default:
if|if
condition|(
operator|(
name|int
operator|)
name|op
operator|.
name|op
operator|<=
operator|(
name|int
operator|)
name|CPP_EQ
operator|||
operator|(
name|int
operator|)
name|op
operator|.
name|op
operator|>=
operator|(
name|int
operator|)
name|CPP_PLUS_EQ
condition|)
name|SYNTAX_ERROR2
argument_list|(
literal|"token \"%s\" is not valid in preprocessor expressions"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|op
operator|.
name|token
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Check we have a value or operator as appropriate.  */
if|if
condition|(
name|optab
index|[
name|op
operator|.
name|op
index|]
operator|.
name|flags
operator|&
name|NO_L_OPERAND
condition|)
block|{
if|if
condition|(
operator|!
name|want_value
condition|)
name|SYNTAX_ERROR2
argument_list|(
literal|"missing binary operator before token \"%s\""
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|op
operator|.
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|want_value
condition|)
block|{
comment|/* Ordering here is subtle and intended to favor the 	     missing parenthesis diagnostics over alternatives.  */
if|if
condition|(
name|op
operator|.
name|op
operator|==
name|CPP_CLOSE_PAREN
condition|)
block|{
if|if
condition|(
name|top
operator|->
name|op
operator|==
name|CPP_OPEN_PAREN
condition|)
name|SYNTAX_ERROR
argument_list|(
literal|"void expression between '(' and ')'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|top
operator|->
name|op
operator|==
name|CPP_EOF
condition|)
name|SYNTAX_ERROR
argument_list|(
literal|"#if with no expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|op
operator|!=
name|CPP_EOF
operator|&&
name|top
operator|->
name|op
operator|!=
name|CPP_OPEN_PAREN
condition|)
name|SYNTAX_ERROR2
argument_list|(
literal|"operator '%s' has no right operand"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|top
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|top
operator|=
name|reduce
argument_list|(
name|pfile
argument_list|,
name|top
argument_list|,
name|op
operator|.
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
goto|goto
name|syntax_error
goto|;
if|if
condition|(
name|op
operator|.
name|op
operator|==
name|CPP_EOF
condition|)
break|break;
switch|switch
condition|(
name|op
operator|.
name|op
condition|)
block|{
case|case
name|CPP_CLOSE_PAREN
case|:
continue|continue;
case|case
name|CPP_OR_OR
case|:
if|if
condition|(
operator|!
name|num_zerop
argument_list|(
name|top
operator|->
name|value
argument_list|)
condition|)
name|pfile
operator|->
name|state
operator|.
name|skip_eval
operator|++
expr_stmt|;
break|break;
case|case
name|CPP_AND_AND
case|:
case|case
name|CPP_QUERY
case|:
if|if
condition|(
name|num_zerop
argument_list|(
name|top
operator|->
name|value
argument_list|)
condition|)
name|pfile
operator|->
name|state
operator|.
name|skip_eval
operator|++
expr_stmt|;
break|break;
case|case
name|CPP_COLON
case|:
if|if
condition|(
name|top
operator|->
name|op
operator|!=
name|CPP_QUERY
condition|)
name|SYNTAX_ERROR
argument_list|(
literal|" ':' without preceding '?'"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num_zerop
argument_list|(
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
argument_list|)
condition|)
comment|/* Was '?' condition true?  */
name|pfile
operator|->
name|state
operator|.
name|skip_eval
operator|++
expr_stmt|;
else|else
name|pfile
operator|->
name|state
operator|.
name|skip_eval
operator|--
expr_stmt|;
default|default:
break|break;
block|}
name|want_value
operator|=
name|true
expr_stmt|;
comment|/* Check for and handle stack overflow.  */
if|if
condition|(
operator|++
name|top
operator|==
name|pfile
operator|->
name|op_limit
condition|)
name|top
operator|=
name|_cpp_expand_op_stack
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|top
operator|->
name|op
operator|=
name|op
operator|.
name|op
expr_stmt|;
name|top
operator|->
name|token
operator|=
name|op
operator|.
name|token
expr_stmt|;
block|}
comment|/* The controlling macro expression is only valid if we called lex 3      times:<!><defined expression> and<EOF>.  push_conditional ()      checks that we are at top-of-file.  */
if|if
condition|(
name|pfile
operator|->
name|mi_ind_cmacro
operator|&&
operator|!
operator|(
name|saw_leading_not
operator|&&
name|lex_count
operator|==
literal|3
operator|)
condition|)
name|pfile
operator|->
name|mi_ind_cmacro
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|top
operator|!=
name|pfile
operator|->
name|op_stack
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ICE
argument_list|,
literal|"unbalanced stack in #if"
argument_list|)
expr_stmt|;
name|syntax_error
label|:
return|return
name|false
return|;
comment|/* Return false on syntax error.  */
block|}
return|return
operator|!
name|num_zerop
argument_list|(
name|top
operator|->
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Reduce the operator / value stack if possible, in preparation for    pushing operator OP.  Returns NULL on error, otherwise the top of    the stack.  */
end_comment

begin_function
specifier|static
name|struct
name|op
modifier|*
name|reduce
parameter_list|(
name|pfile
parameter_list|,
name|top
parameter_list|,
name|op
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|op
modifier|*
name|top
decl_stmt|;
name|enum
name|cpp_ttype
name|op
decl_stmt|;
block|{
name|unsigned
name|int
name|prio
decl_stmt|;
if|if
condition|(
name|top
operator|->
name|op
operator|<=
name|CPP_EQ
operator|||
name|top
operator|->
name|op
operator|>
name|CPP_LAST_CPP_OP
operator|+
literal|2
condition|)
block|{
name|bad_op
label|:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ICE
argument_list|,
literal|"impossible operator '%u'"
argument_list|,
name|top
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|op
operator|==
name|CPP_OPEN_PAREN
condition|)
return|return
name|top
return|;
comment|/* Decrement the priority of left-associative operators to force a      reduction with operators of otherwise equal priority.  */
name|prio
operator|=
name|optab
index|[
name|op
index|]
operator|.
name|prio
operator|-
operator|(
operator|(
name|optab
index|[
name|op
index|]
operator|.
name|flags
operator|&
name|LEFT_ASSOC
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
while|while
condition|(
name|prio
operator|<
name|optab
index|[
name|top
operator|->
name|op
index|]
operator|.
name|prio
condition|)
block|{
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_num_sign_change
argument_list|)
operator|&&
name|optab
index|[
name|top
operator|->
name|op
index|]
operator|.
name|flags
operator|&
name|CHECK_PROMOTION
condition|)
name|check_promotion
argument_list|(
name|pfile
argument_list|,
name|top
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|top
operator|->
name|op
condition|)
block|{
case|case
name|CPP_UPLUS
case|:
case|case
name|CPP_UMINUS
case|:
case|case
name|CPP_NOT
case|:
case|case
name|CPP_COMPL
case|:
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|=
name|num_unary_op
argument_list|(
name|pfile
argument_list|,
name|top
operator|->
name|value
argument_list|,
name|top
operator|->
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_PLUS
case|:
case|case
name|CPP_MINUS
case|:
case|case
name|CPP_RSHIFT
case|:
case|case
name|CPP_LSHIFT
case|:
case|case
name|CPP_MIN
case|:
case|case
name|CPP_MAX
case|:
case|case
name|CPP_COMMA
case|:
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|=
name|num_binary_op
argument_list|(
name|pfile
argument_list|,
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
argument_list|,
name|top
operator|->
name|value
argument_list|,
name|top
operator|->
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_GREATER
case|:
case|case
name|CPP_LESS
case|:
case|case
name|CPP_GREATER_EQ
case|:
case|case
name|CPP_LESS_EQ
case|:
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|=
name|num_inequality_op
argument_list|(
name|pfile
argument_list|,
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
argument_list|,
name|top
operator|->
name|value
argument_list|,
name|top
operator|->
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_EQ_EQ
case|:
case|case
name|CPP_NOT_EQ
case|:
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|=
name|num_equality_op
argument_list|(
name|pfile
argument_list|,
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
argument_list|,
name|top
operator|->
name|value
argument_list|,
name|top
operator|->
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_AND
case|:
case|case
name|CPP_OR
case|:
case|case
name|CPP_XOR
case|:
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|=
name|num_bitwise_op
argument_list|(
name|pfile
argument_list|,
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
argument_list|,
name|top
operator|->
name|value
argument_list|,
name|top
operator|->
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_MULT
case|:
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|=
name|num_mul
argument_list|(
name|pfile
argument_list|,
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
argument_list|,
name|top
operator|->
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_DIV
case|:
case|case
name|CPP_MOD
case|:
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|=
name|num_div_op
argument_list|(
name|pfile
argument_list|,
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|value
argument_list|,
name|top
operator|->
name|value
argument_list|,
name|top
operator|->
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_OR_OR
case|:
name|top
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|num_zerop
argument_list|(
name|top
operator|->
name|value
argument_list|)
condition|)
name|pfile
operator|->
name|state
operator|.
name|skip_eval
operator|--
expr_stmt|;
name|top
operator|->
name|value
operator|.
name|low
operator|=
operator|(
operator|!
name|num_zerop
argument_list|(
name|top
operator|->
name|value
argument_list|)
operator|||
operator|!
name|num_zerop
argument_list|(
name|top
index|[
literal|1
index|]
operator|.
name|value
argument_list|)
operator|)
expr_stmt|;
name|top
operator|->
name|value
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|top
operator|->
name|value
operator|.
name|unsignedp
operator|=
name|false
expr_stmt|;
name|top
operator|->
name|value
operator|.
name|overflow
operator|=
name|false
expr_stmt|;
continue|continue;
case|case
name|CPP_AND_AND
case|:
name|top
operator|--
expr_stmt|;
if|if
condition|(
name|num_zerop
argument_list|(
name|top
operator|->
name|value
argument_list|)
condition|)
name|pfile
operator|->
name|state
operator|.
name|skip_eval
operator|--
expr_stmt|;
name|top
operator|->
name|value
operator|.
name|low
operator|=
operator|(
operator|!
name|num_zerop
argument_list|(
name|top
operator|->
name|value
argument_list|)
operator|&&
operator|!
name|num_zerop
argument_list|(
name|top
index|[
literal|1
index|]
operator|.
name|value
argument_list|)
operator|)
expr_stmt|;
name|top
operator|->
name|value
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|top
operator|->
name|value
operator|.
name|unsignedp
operator|=
name|false
expr_stmt|;
name|top
operator|->
name|value
operator|.
name|overflow
operator|=
name|false
expr_stmt|;
continue|continue;
case|case
name|CPP_OPEN_PAREN
case|:
if|if
condition|(
name|op
operator|!=
name|CPP_CLOSE_PAREN
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ERROR
argument_list|,
literal|"missing ')' in expression"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|top
operator|--
expr_stmt|;
name|top
operator|->
name|value
operator|=
name|top
index|[
literal|1
index|]
operator|.
name|value
expr_stmt|;
return|return
name|top
return|;
case|case
name|CPP_COLON
case|:
name|top
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|num_zerop
argument_list|(
name|top
operator|->
name|value
argument_list|)
condition|)
block|{
name|pfile
operator|->
name|state
operator|.
name|skip_eval
operator|--
expr_stmt|;
name|top
operator|->
name|value
operator|=
name|top
index|[
literal|1
index|]
operator|.
name|value
expr_stmt|;
block|}
else|else
name|top
operator|->
name|value
operator|=
name|top
index|[
literal|2
index|]
operator|.
name|value
expr_stmt|;
name|top
operator|->
name|value
operator|.
name|unsignedp
operator|=
operator|(
name|top
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|unsignedp
operator|||
name|top
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|unsignedp
operator|)
expr_stmt|;
continue|continue;
case|case
name|CPP_QUERY
case|:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ERROR
argument_list|,
literal|"'?' without following ':'"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
goto|goto
name|bad_op
goto|;
block|}
name|top
operator|--
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|value
operator|.
name|overflow
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|skip_eval
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_PEDWARN
argument_list|,
literal|"integer overflow in preprocessor expression"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
name|CPP_CLOSE_PAREN
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ERROR
argument_list|,
literal|"missing '(' in expression"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|top
return|;
block|}
end_function

begin_comment
comment|/* Returns the position of the old top of stack after expansion.  */
end_comment

begin_function
name|struct
name|op
modifier|*
name|_cpp_expand_op_stack
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|size_t
name|old_size
init|=
call|(
name|size_t
call|)
argument_list|(
name|pfile
operator|->
name|op_limit
operator|-
name|pfile
operator|->
name|op_stack
argument_list|)
decl_stmt|;
name|size_t
name|new_size
init|=
name|old_size
operator|*
literal|2
operator|+
literal|20
decl_stmt|;
name|pfile
operator|->
name|op_stack
operator|=
operator|(
expr|struct
name|op
operator|*
operator|)
name|xrealloc
argument_list|(
name|pfile
operator|->
name|op_stack
argument_list|,
name|new_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|op_limit
operator|=
name|pfile
operator|->
name|op_stack
operator|+
name|new_size
expr_stmt|;
return|return
name|pfile
operator|->
name|op_stack
operator|+
name|old_size
return|;
block|}
end_function

begin_comment
comment|/* Emits a warning if the effective sign of either operand of OP    changes because of integer promotions.  */
end_comment

begin_function
specifier|static
name|void
name|check_promotion
parameter_list|(
name|pfile
parameter_list|,
name|op
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|struct
name|op
modifier|*
name|op
decl_stmt|;
block|{
if|if
condition|(
name|op
operator|->
name|value
operator|.
name|unsignedp
operator|==
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|unsignedp
condition|)
return|return;
if|if
condition|(
name|op
operator|->
name|value
operator|.
name|unsignedp
condition|)
block|{
if|if
condition|(
operator|!
name|num_positive
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
argument_list|,
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|precision
argument_list|)
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_WARNING
argument_list|,
literal|"the left operand of \"%s\" changes sign when promoted"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|num_positive
argument_list|(
name|op
operator|->
name|value
argument_list|,
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|precision
argument_list|)
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_WARNING
argument_list|,
literal|"the right operand of \"%s\" changes sign when promoted"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|op
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clears the unused high order bits of the number pointed to by PNUM.  */
end_comment

begin_function
specifier|static
name|cpp_num
name|num_trim
parameter_list|(
name|num
parameter_list|,
name|precision
parameter_list|)
name|cpp_num
name|num
decl_stmt|;
name|size_t
name|precision
decl_stmt|;
block|{
if|if
condition|(
name|precision
operator|>
name|PART_PRECISION
condition|)
block|{
name|precision
operator|-=
name|PART_PRECISION
expr_stmt|;
if|if
condition|(
name|precision
operator|<
name|PART_PRECISION
condition|)
name|num
operator|.
name|high
operator|&=
operator|(
operator|(
name|cpp_num_part
operator|)
literal|1
operator|<<
name|precision
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|precision
operator|<
name|PART_PRECISION
condition|)
name|num
operator|.
name|low
operator|&=
operator|(
operator|(
name|cpp_num_part
operator|)
literal|1
operator|<<
name|precision
operator|)
operator|-
literal|1
expr_stmt|;
name|num
operator|.
name|high
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|num
return|;
block|}
end_function

begin_comment
comment|/* True iff A (presumed signed)>= 0.  */
end_comment

begin_function
specifier|static
name|bool
name|num_positive
parameter_list|(
name|num
parameter_list|,
name|precision
parameter_list|)
name|cpp_num
name|num
decl_stmt|;
name|size_t
name|precision
decl_stmt|;
block|{
if|if
condition|(
name|precision
operator|>
name|PART_PRECISION
condition|)
block|{
name|precision
operator|-=
name|PART_PRECISION
expr_stmt|;
return|return
operator|(
name|num
operator|.
name|high
operator|&
operator|(
name|cpp_num_part
operator|)
literal|1
operator|<<
operator|(
name|precision
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
return|;
block|}
return|return
operator|(
name|num
operator|.
name|low
operator|&
operator|(
name|cpp_num_part
operator|)
literal|1
operator|<<
operator|(
name|precision
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Sign extend a number, with PRECISION significant bits and all    others assumed clear, to fill out a cpp_num structure.  */
end_comment

begin_function
name|cpp_num
name|cpp_num_sign_extend
parameter_list|(
name|num
parameter_list|,
name|precision
parameter_list|)
name|cpp_num
name|num
decl_stmt|;
name|size_t
name|precision
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|num
operator|.
name|unsignedp
condition|)
block|{
if|if
condition|(
name|precision
operator|>
name|PART_PRECISION
condition|)
block|{
name|precision
operator|-=
name|PART_PRECISION
expr_stmt|;
if|if
condition|(
name|precision
operator|<
name|PART_PRECISION
operator|&&
operator|(
name|num
operator|.
name|high
operator|&
operator|(
name|cpp_num_part
operator|)
literal|1
operator|<<
operator|(
name|precision
operator|-
literal|1
operator|)
operator|)
condition|)
name|num
operator|.
name|high
operator||=
operator|~
operator|(
operator|~
operator|(
name|cpp_num_part
operator|)
literal|0
operator|>>
operator|(
name|PART_PRECISION
operator|-
name|precision
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num
operator|.
name|low
operator|&
operator|(
name|cpp_num_part
operator|)
literal|1
operator|<<
operator|(
name|precision
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|precision
operator|<
name|PART_PRECISION
condition|)
name|num
operator|.
name|low
operator||=
operator|~
operator|(
operator|~
operator|(
name|cpp_num_part
operator|)
literal|0
operator|>>
operator|(
name|PART_PRECISION
operator|-
name|precision
operator|)
operator|)
expr_stmt|;
name|num
operator|.
name|high
operator|=
operator|~
operator|(
name|cpp_num_part
operator|)
literal|0
expr_stmt|;
block|}
block|}
return|return
name|num
return|;
block|}
end_function

begin_comment
comment|/* Returns the negative of NUM.  */
end_comment

begin_function
specifier|static
name|cpp_num
name|num_negate
parameter_list|(
name|num
parameter_list|,
name|precision
parameter_list|)
name|cpp_num
name|num
decl_stmt|;
name|size_t
name|precision
decl_stmt|;
block|{
name|cpp_num
name|copy
decl_stmt|;
name|copy
operator|=
name|num
expr_stmt|;
name|num
operator|.
name|high
operator|=
operator|~
name|num
operator|.
name|high
expr_stmt|;
name|num
operator|.
name|low
operator|=
operator|~
name|num
operator|.
name|low
expr_stmt|;
if|if
condition|(
operator|++
name|num
operator|.
name|low
operator|==
literal|0
condition|)
name|num
operator|.
name|high
operator|++
expr_stmt|;
name|num
operator|=
name|num_trim
argument_list|(
name|num
argument_list|,
name|precision
argument_list|)
expr_stmt|;
name|num
operator|.
name|overflow
operator|=
operator|(
operator|!
name|num
operator|.
name|unsignedp
operator|&&
name|num_eq
argument_list|(
name|num
argument_list|,
name|copy
argument_list|)
operator|&&
operator|!
name|num_zerop
argument_list|(
name|num
argument_list|)
operator|)
expr_stmt|;
return|return
name|num
return|;
block|}
end_function

begin_comment
comment|/* Returns true if A>= B.  */
end_comment

begin_function
specifier|static
name|bool
name|num_greater_eq
parameter_list|(
name|pa
parameter_list|,
name|pb
parameter_list|,
name|precision
parameter_list|)
name|cpp_num
name|pa
decl_stmt|,
name|pb
decl_stmt|;
name|size_t
name|precision
decl_stmt|;
block|{
name|bool
name|unsignedp
decl_stmt|;
name|unsignedp
operator|=
name|pa
operator|.
name|unsignedp
operator|||
name|pb
operator|.
name|unsignedp
expr_stmt|;
if|if
condition|(
operator|!
name|unsignedp
condition|)
block|{
comment|/* Both numbers have signed type.  If they are of different        sign, the answer is the sign of A.  */
name|unsignedp
operator|=
name|num_positive
argument_list|(
name|pa
argument_list|,
name|precision
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsignedp
operator|!=
name|num_positive
argument_list|(
name|pb
argument_list|,
name|precision
argument_list|)
condition|)
return|return
name|unsignedp
return|;
comment|/* Otherwise we can do an unsigned comparison.  */
block|}
return|return
operator|(
name|pa
operator|.
name|high
operator|>
name|pb
operator|.
name|high
operator|)
operator|||
operator|(
name|pa
operator|.
name|high
operator|==
name|pb
operator|.
name|high
operator|&&
name|pa
operator|.
name|low
operator|>=
name|pb
operator|.
name|low
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns LHS OP RHS, where OP is a bit-wise operation.  */
end_comment

begin_function
specifier|static
name|cpp_num
name|num_bitwise_op
parameter_list|(
name|pfile
parameter_list|,
name|lhs
parameter_list|,
name|rhs
parameter_list|,
name|op
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|cpp_num
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|enum
name|cpp_ttype
name|op
decl_stmt|;
block|{
name|lhs
operator|.
name|overflow
operator|=
name|false
expr_stmt|;
name|lhs
operator|.
name|unsignedp
operator|=
name|lhs
operator|.
name|unsignedp
operator|||
name|rhs
operator|.
name|unsignedp
expr_stmt|;
comment|/* As excess precision is zeroed, there is no need to num_trim () as      these operations cannot introduce a set bit there.  */
if|if
condition|(
name|op
operator|==
name|CPP_AND
condition|)
block|{
name|lhs
operator|.
name|low
operator|&=
name|rhs
operator|.
name|low
expr_stmt|;
name|lhs
operator|.
name|high
operator|&=
name|rhs
operator|.
name|high
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|CPP_OR
condition|)
block|{
name|lhs
operator|.
name|low
operator||=
name|rhs
operator|.
name|low
expr_stmt|;
name|lhs
operator|.
name|high
operator||=
name|rhs
operator|.
name|high
expr_stmt|;
block|}
else|else
block|{
name|lhs
operator|.
name|low
operator|^=
name|rhs
operator|.
name|low
expr_stmt|;
name|lhs
operator|.
name|high
operator|^=
name|rhs
operator|.
name|high
expr_stmt|;
block|}
return|return
name|lhs
return|;
block|}
end_function

begin_comment
comment|/* Returns LHS OP RHS, where OP is an inequality.  */
end_comment

begin_function
specifier|static
name|cpp_num
name|num_inequality_op
parameter_list|(
name|pfile
parameter_list|,
name|lhs
parameter_list|,
name|rhs
parameter_list|,
name|op
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_num
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|enum
name|cpp_ttype
name|op
decl_stmt|;
block|{
name|bool
name|gte
init|=
name|num_greater_eq
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|precision
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|CPP_GREATER_EQ
condition|)
name|lhs
operator|.
name|low
operator|=
name|gte
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|CPP_LESS
condition|)
name|lhs
operator|.
name|low
operator|=
operator|!
name|gte
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|CPP_GREATER
condition|)
name|lhs
operator|.
name|low
operator|=
name|gte
operator|&&
operator|!
name|num_eq
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
else|else
comment|/* CPP_LESS_EQ.  */
name|lhs
operator|.
name|low
operator|=
operator|!
name|gte
operator|||
name|num_eq
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|lhs
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|lhs
operator|.
name|overflow
operator|=
name|false
expr_stmt|;
name|lhs
operator|.
name|unsignedp
operator|=
name|false
expr_stmt|;
return|return
name|lhs
return|;
block|}
end_function

begin_comment
comment|/* Returns LHS OP RHS, where OP is == or !=.  */
end_comment

begin_function
specifier|static
name|cpp_num
name|num_equality_op
parameter_list|(
name|pfile
parameter_list|,
name|lhs
parameter_list|,
name|rhs
parameter_list|,
name|op
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|cpp_num
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|enum
name|cpp_ttype
name|op
decl_stmt|;
block|{
comment|/* Work around a 3.0.4 bug; see PR 6950.  */
name|bool
name|eq
init|=
name|num_eq
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|CPP_NOT_EQ
condition|)
name|eq
operator|=
operator|!
name|eq
expr_stmt|;
name|lhs
operator|.
name|low
operator|=
name|eq
expr_stmt|;
name|lhs
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|lhs
operator|.
name|overflow
operator|=
name|false
expr_stmt|;
name|lhs
operator|.
name|unsignedp
operator|=
name|false
expr_stmt|;
return|return
name|lhs
return|;
block|}
end_function

begin_comment
comment|/* Shift NUM, of width PRECISION, right by N bits.  */
end_comment

begin_function
specifier|static
name|cpp_num
name|num_rshift
parameter_list|(
name|num
parameter_list|,
name|precision
parameter_list|,
name|n
parameter_list|)
name|cpp_num
name|num
decl_stmt|;
name|size_t
name|precision
decl_stmt|,
name|n
decl_stmt|;
block|{
name|cpp_num_part
name|sign_mask
decl_stmt|;
if|if
condition|(
name|num
operator|.
name|unsignedp
operator|||
name|num_positive
argument_list|(
name|num
argument_list|,
name|precision
argument_list|)
condition|)
name|sign_mask
operator|=
literal|0
expr_stmt|;
else|else
name|sign_mask
operator|=
operator|~
operator|(
name|cpp_num_part
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|precision
condition|)
name|num
operator|.
name|high
operator|=
name|num
operator|.
name|low
operator|=
name|sign_mask
expr_stmt|;
else|else
block|{
comment|/* Sign-extend.  */
if|if
condition|(
name|precision
operator|<
name|PART_PRECISION
condition|)
name|num
operator|.
name|high
operator|=
name|sign_mask
operator|,
name|num
operator|.
name|low
operator||=
name|sign_mask
operator|<<
name|precision
expr_stmt|;
elseif|else
if|if
condition|(
name|precision
operator|<
literal|2
operator|*
name|PART_PRECISION
condition|)
name|num
operator|.
name|high
operator||=
name|sign_mask
operator|<<
operator|(
name|precision
operator|-
name|PART_PRECISION
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|PART_PRECISION
condition|)
block|{
name|n
operator|-=
name|PART_PRECISION
expr_stmt|;
name|num
operator|.
name|low
operator|=
name|num
operator|.
name|high
expr_stmt|;
name|num
operator|.
name|high
operator|=
name|sign_mask
expr_stmt|;
block|}
if|if
condition|(
name|n
condition|)
block|{
name|num
operator|.
name|low
operator|=
operator|(
name|num
operator|.
name|low
operator|>>
name|n
operator|)
operator||
operator|(
name|num
operator|.
name|high
operator|<<
operator|(
name|PART_PRECISION
operator|-
name|n
operator|)
operator|)
expr_stmt|;
name|num
operator|.
name|high
operator|=
operator|(
name|num
operator|.
name|high
operator|>>
name|n
operator|)
operator||
operator|(
name|sign_mask
operator|<<
operator|(
name|PART_PRECISION
operator|-
name|n
operator|)
operator|)
expr_stmt|;
block|}
block|}
name|num
operator|=
name|num_trim
argument_list|(
name|num
argument_list|,
name|precision
argument_list|)
expr_stmt|;
name|num
operator|.
name|overflow
operator|=
name|false
expr_stmt|;
return|return
name|num
return|;
block|}
end_function

begin_comment
comment|/* Shift NUM, of width PRECISION, left by N bits.  */
end_comment

begin_function
specifier|static
name|cpp_num
name|num_lshift
parameter_list|(
name|num
parameter_list|,
name|precision
parameter_list|,
name|n
parameter_list|)
name|cpp_num
name|num
decl_stmt|;
name|size_t
name|precision
decl_stmt|,
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|>=
name|precision
condition|)
block|{
name|num
operator|.
name|overflow
operator|=
operator|!
name|num
operator|.
name|unsignedp
operator|&&
operator|!
name|num_zerop
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|num
operator|.
name|high
operator|=
name|num
operator|.
name|low
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cpp_num
name|orig
decl_stmt|,
name|maybe_orig
decl_stmt|;
name|size_t
name|m
init|=
name|n
decl_stmt|;
name|orig
operator|=
name|num
expr_stmt|;
if|if
condition|(
name|m
operator|>=
name|PART_PRECISION
condition|)
block|{
name|m
operator|-=
name|PART_PRECISION
expr_stmt|;
name|num
operator|.
name|high
operator|=
name|num
operator|.
name|low
expr_stmt|;
name|num
operator|.
name|low
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
block|{
name|num
operator|.
name|high
operator|=
operator|(
name|num
operator|.
name|high
operator|<<
name|m
operator|)
operator||
operator|(
name|num
operator|.
name|low
operator|>>
operator|(
name|PART_PRECISION
operator|-
name|m
operator|)
operator|)
expr_stmt|;
name|num
operator|.
name|low
operator|<<=
name|m
expr_stmt|;
block|}
name|num
operator|=
name|num_trim
argument_list|(
name|num
argument_list|,
name|precision
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|.
name|unsignedp
condition|)
name|num
operator|.
name|overflow
operator|=
name|false
expr_stmt|;
else|else
block|{
name|maybe_orig
operator|=
name|num_rshift
argument_list|(
name|num
argument_list|,
name|precision
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|num
operator|.
name|overflow
operator|=
operator|!
name|num_eq
argument_list|(
name|orig
argument_list|,
name|maybe_orig
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|num
return|;
block|}
end_function

begin_comment
comment|/* The four unary operators: +, -, ! and ~.  */
end_comment

begin_function
specifier|static
name|cpp_num
name|num_unary_op
parameter_list|(
name|pfile
parameter_list|,
name|num
parameter_list|,
name|op
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_num
name|num
decl_stmt|;
name|enum
name|cpp_ttype
name|op
decl_stmt|;
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|CPP_UPLUS
case|:
if|if
condition|(
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|skip_eval
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_WARNING
argument_list|,
literal|"traditional C rejects the unary plus operator"
argument_list|)
expr_stmt|;
name|num
operator|.
name|overflow
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|CPP_UMINUS
case|:
name|num
operator|=
name|num_negate
argument_list|(
name|num
argument_list|,
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|precision
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_COMPL
case|:
name|num
operator|.
name|high
operator|=
operator|~
name|num
operator|.
name|high
expr_stmt|;
name|num
operator|.
name|low
operator|=
operator|~
name|num
operator|.
name|low
expr_stmt|;
name|num
operator|=
name|num_trim
argument_list|(
name|num
argument_list|,
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|precision
argument_list|)
argument_list|)
expr_stmt|;
name|num
operator|.
name|overflow
operator|=
name|false
expr_stmt|;
break|break;
default|default:
comment|/* case CPP_NOT: */
name|num
operator|.
name|low
operator|=
name|num_zerop
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|num
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|num
operator|.
name|overflow
operator|=
name|false
expr_stmt|;
name|num
operator|.
name|unsignedp
operator|=
name|false
expr_stmt|;
break|break;
block|}
return|return
name|num
return|;
block|}
end_function

begin_comment
comment|/* The various binary operators.  */
end_comment

begin_function
specifier|static
name|cpp_num
name|num_binary_op
parameter_list|(
name|pfile
parameter_list|,
name|lhs
parameter_list|,
name|rhs
parameter_list|,
name|op
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_num
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|enum
name|cpp_ttype
name|op
decl_stmt|;
block|{
name|cpp_num
name|result
decl_stmt|;
name|size_t
name|precision
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|precision
argument_list|)
decl_stmt|;
name|bool
name|gte
decl_stmt|;
name|size_t
name|n
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
comment|/* Shifts.  */
case|case
name|CPP_LSHIFT
case|:
case|case
name|CPP_RSHIFT
case|:
if|if
condition|(
operator|!
name|rhs
operator|.
name|unsignedp
operator|&&
operator|!
name|num_positive
argument_list|(
name|rhs
argument_list|,
name|precision
argument_list|)
condition|)
block|{
comment|/* A negative shift is a positive shift the other way.  */
if|if
condition|(
name|op
operator|==
name|CPP_LSHIFT
condition|)
name|op
operator|=
name|CPP_RSHIFT
expr_stmt|;
else|else
name|op
operator|=
name|CPP_LSHIFT
expr_stmt|;
name|rhs
operator|=
name|num_negate
argument_list|(
name|rhs
argument_list|,
name|precision
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rhs
operator|.
name|high
condition|)
name|n
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* Maximal.  */
else|else
name|n
operator|=
name|rhs
operator|.
name|low
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|CPP_LSHIFT
condition|)
name|lhs
operator|=
name|num_lshift
argument_list|(
name|lhs
argument_list|,
name|precision
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|lhs
operator|=
name|num_rshift
argument_list|(
name|lhs
argument_list|,
name|precision
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
comment|/* Min / Max.  */
case|case
name|CPP_MIN
case|:
case|case
name|CPP_MAX
case|:
block|{
name|bool
name|unsignedp
init|=
name|lhs
operator|.
name|unsignedp
operator|||
name|rhs
operator|.
name|unsignedp
decl_stmt|;
name|gte
operator|=
name|num_greater_eq
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
name|precision
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|CPP_MIN
condition|)
name|gte
operator|=
operator|!
name|gte
expr_stmt|;
if|if
condition|(
operator|!
name|gte
condition|)
name|lhs
operator|=
name|rhs
expr_stmt|;
name|lhs
operator|.
name|unsignedp
operator|=
name|unsignedp
expr_stmt|;
block|}
break|break;
comment|/* Arithmetic.  */
case|case
name|CPP_MINUS
case|:
name|rhs
operator|=
name|num_negate
argument_list|(
name|rhs
argument_list|,
name|precision
argument_list|)
expr_stmt|;
case|case
name|CPP_PLUS
case|:
name|result
operator|.
name|low
operator|=
name|lhs
operator|.
name|low
operator|+
name|rhs
operator|.
name|low
expr_stmt|;
name|result
operator|.
name|high
operator|=
name|lhs
operator|.
name|high
operator|+
name|rhs
operator|.
name|high
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|low
operator|<
name|lhs
operator|.
name|low
condition|)
name|result
operator|.
name|high
operator|++
expr_stmt|;
name|result
operator|=
name|num_trim
argument_list|(
name|result
argument_list|,
name|precision
argument_list|)
expr_stmt|;
name|result
operator|.
name|unsignedp
operator|=
name|lhs
operator|.
name|unsignedp
operator|||
name|rhs
operator|.
name|unsignedp
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|unsignedp
condition|)
name|result
operator|.
name|overflow
operator|=
name|false
expr_stmt|;
else|else
block|{
name|bool
name|lhsp
init|=
name|num_positive
argument_list|(
name|lhs
argument_list|,
name|precision
argument_list|)
decl_stmt|;
name|result
operator|.
name|overflow
operator|=
operator|(
name|lhsp
operator|==
name|num_positive
argument_list|(
name|rhs
argument_list|,
name|precision
argument_list|)
operator|&&
name|lhsp
operator|!=
name|num_positive
argument_list|(
name|result
argument_list|,
name|precision
argument_list|)
operator|)
expr_stmt|;
block|}
return|return
name|result
return|;
comment|/* Comma.  */
default|default:
comment|/* case CPP_COMMA: */
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|skip_eval
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_PEDWARN
argument_list|,
literal|"comma operator in operand of #if"
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|rhs
expr_stmt|;
break|break;
block|}
return|return
name|lhs
return|;
block|}
end_function

begin_comment
comment|/* Multiplies two unsigned cpp_num_parts to give a cpp_num.  This    cannot overflow.  */
end_comment

begin_function
specifier|static
name|cpp_num
name|num_part_mul
parameter_list|(
name|lhs
parameter_list|,
name|rhs
parameter_list|)
name|cpp_num_part
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
block|{
name|cpp_num
name|result
decl_stmt|;
name|cpp_num_part
name|middle
index|[
literal|2
index|]
decl_stmt|,
name|temp
decl_stmt|;
name|result
operator|.
name|low
operator|=
name|LOW_PART
argument_list|(
name|lhs
argument_list|)
operator|*
name|LOW_PART
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|result
operator|.
name|high
operator|=
name|HIGH_PART
argument_list|(
name|lhs
argument_list|)
operator|*
name|HIGH_PART
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|middle
index|[
literal|0
index|]
operator|=
name|LOW_PART
argument_list|(
name|lhs
argument_list|)
operator|*
name|HIGH_PART
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|middle
index|[
literal|1
index|]
operator|=
name|HIGH_PART
argument_list|(
name|lhs
argument_list|)
operator|*
name|LOW_PART
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|temp
operator|=
name|result
operator|.
name|low
expr_stmt|;
name|result
operator|.
name|low
operator|+=
name|LOW_PART
argument_list|(
name|middle
index|[
literal|0
index|]
argument_list|)
operator|<<
operator|(
name|PART_PRECISION
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|low
operator|<
name|temp
condition|)
name|result
operator|.
name|high
operator|++
expr_stmt|;
name|temp
operator|=
name|result
operator|.
name|low
expr_stmt|;
name|result
operator|.
name|low
operator|+=
name|LOW_PART
argument_list|(
name|middle
index|[
literal|1
index|]
argument_list|)
operator|<<
operator|(
name|PART_PRECISION
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|low
operator|<
name|temp
condition|)
name|result
operator|.
name|high
operator|++
expr_stmt|;
name|result
operator|.
name|high
operator|+=
name|HIGH_PART
argument_list|(
name|middle
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|result
operator|.
name|high
operator|+=
name|HIGH_PART
argument_list|(
name|middle
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|result
operator|.
name|unsignedp
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Multiply two preprocessing numbers.  */
end_comment

begin_function
specifier|static
name|cpp_num
name|num_mul
parameter_list|(
name|pfile
parameter_list|,
name|lhs
parameter_list|,
name|rhs
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_num
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
block|{
name|cpp_num
name|result
decl_stmt|,
name|temp
decl_stmt|;
name|bool
name|unsignedp
init|=
name|lhs
operator|.
name|unsignedp
operator|||
name|rhs
operator|.
name|unsignedp
decl_stmt|;
name|bool
name|overflow
decl_stmt|,
name|negate
init|=
name|false
decl_stmt|;
name|size_t
name|precision
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|precision
argument_list|)
decl_stmt|;
comment|/* Prepare for unsigned multiplication.  */
if|if
condition|(
operator|!
name|unsignedp
condition|)
block|{
if|if
condition|(
operator|!
name|num_positive
argument_list|(
name|lhs
argument_list|,
name|precision
argument_list|)
condition|)
name|negate
operator|=
operator|!
name|negate
operator|,
name|lhs
operator|=
name|num_negate
argument_list|(
name|lhs
argument_list|,
name|precision
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num_positive
argument_list|(
name|rhs
argument_list|,
name|precision
argument_list|)
condition|)
name|negate
operator|=
operator|!
name|negate
operator|,
name|rhs
operator|=
name|num_negate
argument_list|(
name|rhs
argument_list|,
name|precision
argument_list|)
expr_stmt|;
block|}
name|overflow
operator|=
name|lhs
operator|.
name|high
operator|&&
name|rhs
operator|.
name|high
expr_stmt|;
name|result
operator|=
name|num_part_mul
argument_list|(
name|lhs
operator|.
name|low
argument_list|,
name|rhs
operator|.
name|low
argument_list|)
expr_stmt|;
name|temp
operator|=
name|num_part_mul
argument_list|(
name|lhs
operator|.
name|high
argument_list|,
name|rhs
operator|.
name|low
argument_list|)
expr_stmt|;
name|result
operator|.
name|high
operator|+=
name|temp
operator|.
name|low
expr_stmt|;
if|if
condition|(
name|temp
operator|.
name|high
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|temp
operator|=
name|num_part_mul
argument_list|(
name|lhs
operator|.
name|low
argument_list|,
name|rhs
operator|.
name|high
argument_list|)
expr_stmt|;
name|result
operator|.
name|high
operator|+=
name|temp
operator|.
name|low
expr_stmt|;
if|if
condition|(
name|temp
operator|.
name|high
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|temp
operator|.
name|low
operator|=
name|result
operator|.
name|low
operator|,
name|temp
operator|.
name|high
operator|=
name|result
operator|.
name|high
expr_stmt|;
name|result
operator|=
name|num_trim
argument_list|(
name|result
argument_list|,
name|precision
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num_eq
argument_list|(
name|result
argument_list|,
name|temp
argument_list|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|negate
condition|)
name|result
operator|=
name|num_negate
argument_list|(
name|result
argument_list|,
name|precision
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsignedp
condition|)
name|result
operator|.
name|overflow
operator|=
name|false
expr_stmt|;
else|else
name|result
operator|.
name|overflow
operator|=
name|overflow
operator|||
operator|(
name|num_positive
argument_list|(
name|result
argument_list|,
name|precision
argument_list|)
operator|^
operator|!
name|negate
operator|&&
operator|!
name|num_zerop
argument_list|(
name|result
argument_list|)
operator|)
expr_stmt|;
name|result
operator|.
name|unsignedp
operator|=
name|unsignedp
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Divide two preprocessing numbers, returning the answer or the    remainder depending upon OP.  */
end_comment

begin_function
specifier|static
name|cpp_num
name|num_div_op
parameter_list|(
name|pfile
parameter_list|,
name|lhs
parameter_list|,
name|rhs
parameter_list|,
name|op
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_num
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|enum
name|cpp_ttype
name|op
decl_stmt|;
block|{
name|cpp_num
name|result
decl_stmt|,
name|sub
decl_stmt|;
name|cpp_num_part
name|mask
decl_stmt|;
name|bool
name|unsignedp
init|=
name|lhs
operator|.
name|unsignedp
operator|||
name|rhs
operator|.
name|unsignedp
decl_stmt|;
name|bool
name|negate
init|=
name|false
decl_stmt|,
name|lhs_neg
init|=
name|false
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|precision
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|precision
argument_list|)
decl_stmt|;
comment|/* Prepare for unsigned division.  */
if|if
condition|(
operator|!
name|unsignedp
condition|)
block|{
if|if
condition|(
operator|!
name|num_positive
argument_list|(
name|lhs
argument_list|,
name|precision
argument_list|)
condition|)
name|negate
operator|=
operator|!
name|negate
operator|,
name|lhs_neg
operator|=
name|true
operator|,
name|lhs
operator|=
name|num_negate
argument_list|(
name|lhs
argument_list|,
name|precision
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num_positive
argument_list|(
name|rhs
argument_list|,
name|precision
argument_list|)
condition|)
name|negate
operator|=
operator|!
name|negate
operator|,
name|rhs
operator|=
name|num_negate
argument_list|(
name|rhs
argument_list|,
name|precision
argument_list|)
expr_stmt|;
block|}
comment|/* Find the high bit.  */
if|if
condition|(
name|rhs
operator|.
name|high
condition|)
block|{
name|i
operator|=
name|precision
operator|-
literal|1
expr_stmt|;
name|mask
operator|=
operator|(
name|cpp_num_part
operator|)
literal|1
operator|<<
operator|(
name|i
operator|-
name|PART_PRECISION
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
name|i
operator|--
operator|,
name|mask
operator|>>=
literal|1
control|)
if|if
condition|(
name|rhs
operator|.
name|high
operator|&
name|mask
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|rhs
operator|.
name|low
condition|)
block|{
if|if
condition|(
name|precision
operator|>
name|PART_PRECISION
condition|)
name|i
operator|=
name|precision
operator|-
name|PART_PRECISION
operator|-
literal|1
expr_stmt|;
else|else
name|i
operator|=
name|precision
operator|-
literal|1
expr_stmt|;
name|mask
operator|=
operator|(
name|cpp_num_part
operator|)
literal|1
operator|<<
name|i
expr_stmt|;
for|for
control|(
init|;
condition|;
name|i
operator|--
operator|,
name|mask
operator|>>=
literal|1
control|)
if|if
condition|(
name|rhs
operator|.
name|low
operator|&
name|mask
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|skip_eval
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|DL_ERROR
argument_list|,
literal|"division by zero in #if"
argument_list|)
expr_stmt|;
return|return
name|lhs
return|;
block|}
comment|/* First nonzero bit of RHS is bit I.  Do naive division by      shifting the RHS fully left, and subtracting from LHS if LHS is      at least as big, and then repeating but with one less shift.      This is not very efficient, but is easy to understand.  */
name|rhs
operator|.
name|unsignedp
operator|=
name|true
expr_stmt|;
name|lhs
operator|.
name|unsignedp
operator|=
name|true
expr_stmt|;
name|i
operator|=
name|precision
operator|-
name|i
operator|-
literal|1
expr_stmt|;
name|sub
operator|=
name|num_lshift
argument_list|(
name|rhs
argument_list|,
name|precision
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|result
operator|.
name|high
operator|=
name|result
operator|.
name|low
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|num_greater_eq
argument_list|(
name|lhs
argument_list|,
name|sub
argument_list|,
name|precision
argument_list|)
condition|)
block|{
name|lhs
operator|=
name|num_binary_op
argument_list|(
name|pfile
argument_list|,
name|lhs
argument_list|,
name|sub
argument_list|,
name|CPP_MINUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|PART_PRECISION
condition|)
name|result
operator|.
name|high
operator||=
operator|(
name|cpp_num_part
operator|)
literal|1
operator|<<
operator|(
name|i
operator|-
name|PART_PRECISION
operator|)
expr_stmt|;
else|else
name|result
operator|.
name|low
operator||=
operator|(
name|cpp_num_part
operator|)
literal|1
operator|<<
name|i
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|--
operator|==
literal|0
condition|)
break|break;
name|sub
operator|.
name|low
operator|=
operator|(
name|sub
operator|.
name|low
operator|>>
literal|1
operator|)
operator||
operator|(
name|sub
operator|.
name|high
operator|<<
operator|(
name|PART_PRECISION
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|sub
operator|.
name|high
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* We divide so that the remainder has the sign of the LHS.  */
if|if
condition|(
name|op
operator|==
name|CPP_DIV
condition|)
block|{
name|result
operator|.
name|unsignedp
operator|=
name|unsignedp
expr_stmt|;
if|if
condition|(
name|unsignedp
condition|)
name|result
operator|.
name|overflow
operator|=
name|false
expr_stmt|;
else|else
block|{
if|if
condition|(
name|negate
condition|)
name|result
operator|=
name|num_negate
argument_list|(
name|result
argument_list|,
name|precision
argument_list|)
expr_stmt|;
name|result
operator|.
name|overflow
operator|=
name|num_positive
argument_list|(
name|result
argument_list|,
name|precision
argument_list|)
operator|^
operator|!
name|negate
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/* CPP_MOD.  */
name|lhs
operator|.
name|unsignedp
operator|=
name|unsignedp
expr_stmt|;
name|lhs
operator|.
name|overflow
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|lhs_neg
condition|)
name|lhs
operator|=
name|num_negate
argument_list|(
name|lhs
argument_list|,
name|precision
argument_list|)
expr_stmt|;
return|return
name|lhs
return|;
block|}
end_function

end_unit

