begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Operations with long integers.    Copyright (C) 2006 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/* Returns mask for PREC bits.  */
end_comment

begin_function
specifier|static
specifier|inline
name|double_int
name|double_int_mask
parameter_list|(
name|unsigned
name|prec
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|m
decl_stmt|;
name|double_int
name|mask
decl_stmt|;
if|if
condition|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|prec
operator|-=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
name|m
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
operator|(
name|prec
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|mask
operator|.
name|high
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|m
expr_stmt|;
name|mask
operator|.
name|low
operator|=
name|ALL_ONES
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|mask
operator|.
name|low
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
operator|(
name|prec
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|mask
return|;
block|}
end_function

begin_comment
comment|/* Clears the bits of CST over the precision PREC.  If UNS is false, the bits    outside of the precision are set to the sign bit (i.e., the PREC-th one),    otherwise they are set to zero.      This corresponds to returning the value represented by PREC lowermost bits    of CST, with the given signedness.  */
end_comment

begin_function
name|double_int
name|double_int_ext
parameter_list|(
name|double_int
name|cst
parameter_list|,
name|unsigned
name|prec
parameter_list|,
name|bool
name|uns
parameter_list|)
block|{
if|if
condition|(
name|uns
condition|)
return|return
name|double_int_zext
argument_list|(
name|cst
argument_list|,
name|prec
argument_list|)
return|;
else|else
return|return
name|double_int_sext
argument_list|(
name|cst
argument_list|,
name|prec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The same as double_int_ext with UNS = true.  */
end_comment

begin_function
name|double_int
name|double_int_zext
parameter_list|(
name|double_int
name|cst
parameter_list|,
name|unsigned
name|prec
parameter_list|)
block|{
name|double_int
name|mask
init|=
name|double_int_mask
argument_list|(
name|prec
argument_list|)
decl_stmt|;
name|double_int
name|r
decl_stmt|;
name|r
operator|.
name|low
operator|=
name|cst
operator|.
name|low
operator|&
name|mask
operator|.
name|low
expr_stmt|;
name|r
operator|.
name|high
operator|=
name|cst
operator|.
name|high
operator|&
name|mask
operator|.
name|high
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* The same as double_int_ext with UNS = false.  */
end_comment

begin_function
name|double_int
name|double_int_sext
parameter_list|(
name|double_int
name|cst
parameter_list|,
name|unsigned
name|prec
parameter_list|)
block|{
name|double_int
name|mask
init|=
name|double_int_mask
argument_list|(
name|prec
argument_list|)
decl_stmt|;
name|double_int
name|r
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|snum
decl_stmt|;
if|if
condition|(
name|prec
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|snum
operator|=
name|cst
operator|.
name|low
expr_stmt|;
else|else
block|{
name|prec
operator|-=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
name|snum
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|cst
operator|.
name|high
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|snum
operator|>>
operator|(
name|prec
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
block|{
name|r
operator|.
name|low
operator|=
name|cst
operator|.
name|low
operator||
operator|~
name|mask
operator|.
name|low
expr_stmt|;
name|r
operator|.
name|high
operator|=
name|cst
operator|.
name|high
operator||
operator|~
name|mask
operator|.
name|high
expr_stmt|;
block|}
else|else
block|{
name|r
operator|.
name|low
operator|=
name|cst
operator|.
name|low
operator|&
name|mask
operator|.
name|low
expr_stmt|;
name|r
operator|.
name|high
operator|=
name|cst
operator|.
name|high
operator|&
name|mask
operator|.
name|high
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Constructs long integer from tree CST.  The extra bits over the precision of    the number are filled with sign bit if CST is signed, and with zeros if it    is unsigned.  */
end_comment

begin_function
name|double_int
name|tree_to_double_int
parameter_list|(
name|tree
name|cst
parameter_list|)
block|{
comment|/* We do not need to call double_int_restrict here to ensure the semantics as      described, as this is the default one for trees.  */
return|return
name|TREE_INT_CST
argument_list|(
name|cst
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if CST fits in unsigned HOST_WIDE_INT.  */
end_comment

begin_function
name|bool
name|double_int_fits_in_uhwi_p
parameter_list|(
name|double_int
name|cst
parameter_list|)
block|{
return|return
name|cst
operator|.
name|high
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns true if CST fits in signed HOST_WIDE_INT.  */
end_comment

begin_function
name|bool
name|double_int_fits_in_shwi_p
parameter_list|(
name|double_int
name|cst
parameter_list|)
block|{
if|if
condition|(
name|cst
operator|.
name|high
operator|==
literal|0
condition|)
return|return
operator|(
name|HOST_WIDE_INT
operator|)
name|cst
operator|.
name|low
operator|>=
literal|0
return|;
elseif|else
if|if
condition|(
name|cst
operator|.
name|high
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|HOST_WIDE_INT
operator|)
name|cst
operator|.
name|low
operator|<
literal|0
return|;
else|else
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Returns true if CST fits in HOST_WIDE_INT if UNS is false, or in    unsigned HOST_WIDE_INT if UNS is true.  */
end_comment

begin_function
name|bool
name|double_int_fits_in_hwi_p
parameter_list|(
name|double_int
name|cst
parameter_list|,
name|bool
name|uns
parameter_list|)
block|{
if|if
condition|(
name|uns
condition|)
return|return
name|double_int_fits_in_uhwi_p
argument_list|(
name|cst
argument_list|)
return|;
else|else
return|return
name|double_int_fits_in_shwi_p
argument_list|(
name|cst
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns value of CST as a signed number.  CST must satisfy    double_int_fits_in_shwi_p.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|double_int_to_shwi
parameter_list|(
name|double_int
name|cst
parameter_list|)
block|{
return|return
operator|(
name|HOST_WIDE_INT
operator|)
name|cst
operator|.
name|low
return|;
block|}
end_function

begin_comment
comment|/* Returns value of CST as an unsigned number.  CST must satisfy    double_int_fits_in_uhwi_p.  */
end_comment

begin_function
name|unsigned
name|HOST_WIDE_INT
name|double_int_to_uhwi
parameter_list|(
name|double_int
name|cst
parameter_list|)
block|{
return|return
name|cst
operator|.
name|low
return|;
block|}
end_function

begin_comment
comment|/* Returns A * B.  */
end_comment

begin_function
name|double_int
name|double_int_mul
parameter_list|(
name|double_int
name|a
parameter_list|,
name|double_int
name|b
parameter_list|)
block|{
name|double_int
name|ret
decl_stmt|;
name|mul_double
argument_list|(
name|a
operator|.
name|low
argument_list|,
name|a
operator|.
name|high
argument_list|,
name|b
operator|.
name|low
argument_list|,
name|b
operator|.
name|high
argument_list|,
operator|&
name|ret
operator|.
name|low
argument_list|,
operator|&
name|ret
operator|.
name|high
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Returns A + B.  */
end_comment

begin_function
name|double_int
name|double_int_add
parameter_list|(
name|double_int
name|a
parameter_list|,
name|double_int
name|b
parameter_list|)
block|{
name|double_int
name|ret
decl_stmt|;
name|add_double
argument_list|(
name|a
operator|.
name|low
argument_list|,
name|a
operator|.
name|high
argument_list|,
name|b
operator|.
name|low
argument_list|,
name|b
operator|.
name|high
argument_list|,
operator|&
name|ret
operator|.
name|low
argument_list|,
operator|&
name|ret
operator|.
name|high
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Returns -A.  */
end_comment

begin_function
name|double_int
name|double_int_neg
parameter_list|(
name|double_int
name|a
parameter_list|)
block|{
name|double_int
name|ret
decl_stmt|;
name|neg_double
argument_list|(
name|a
operator|.
name|low
argument_list|,
name|a
operator|.
name|high
argument_list|,
operator|&
name|ret
operator|.
name|low
argument_list|,
operator|&
name|ret
operator|.
name|high
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Returns A / B (computed as unsigned depending on UNS, and rounded as    specified by CODE).  CODE is enum tree_code in fact, but double_int.h    must be included before tree.h.  The remainder after the division is    stored to MOD.  */
end_comment

begin_function
name|double_int
name|double_int_divmod
parameter_list|(
name|double_int
name|a
parameter_list|,
name|double_int
name|b
parameter_list|,
name|bool
name|uns
parameter_list|,
name|unsigned
name|code
parameter_list|,
name|double_int
modifier|*
name|mod
parameter_list|)
block|{
name|double_int
name|ret
decl_stmt|;
name|div_and_round_double
argument_list|(
name|code
argument_list|,
name|uns
argument_list|,
name|a
operator|.
name|low
argument_list|,
name|a
operator|.
name|high
argument_list|,
name|b
operator|.
name|low
argument_list|,
name|b
operator|.
name|high
argument_list|,
operator|&
name|ret
operator|.
name|low
argument_list|,
operator|&
name|ret
operator|.
name|high
argument_list|,
operator|&
name|mod
operator|->
name|low
argument_list|,
operator|&
name|mod
operator|->
name|high
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* The same as double_int_divmod with UNS = false.  */
end_comment

begin_function
name|double_int
name|double_int_sdivmod
parameter_list|(
name|double_int
name|a
parameter_list|,
name|double_int
name|b
parameter_list|,
name|unsigned
name|code
parameter_list|,
name|double_int
modifier|*
name|mod
parameter_list|)
block|{
return|return
name|double_int_divmod
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|false
argument_list|,
name|code
argument_list|,
name|mod
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The same as double_int_divmod with UNS = true.  */
end_comment

begin_function
name|double_int
name|double_int_udivmod
parameter_list|(
name|double_int
name|a
parameter_list|,
name|double_int
name|b
parameter_list|,
name|unsigned
name|code
parameter_list|,
name|double_int
modifier|*
name|mod
parameter_list|)
block|{
return|return
name|double_int_divmod
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|true
argument_list|,
name|code
argument_list|,
name|mod
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns A / B (computed as unsigned depending on UNS, and rounded as    specified by CODE).  CODE is enum tree_code in fact, but double_int.h    must be included before tree.h.  */
end_comment

begin_function
name|double_int
name|double_int_div
parameter_list|(
name|double_int
name|a
parameter_list|,
name|double_int
name|b
parameter_list|,
name|bool
name|uns
parameter_list|,
name|unsigned
name|code
parameter_list|)
block|{
name|double_int
name|mod
decl_stmt|;
return|return
name|double_int_divmod
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|uns
argument_list|,
name|code
argument_list|,
operator|&
name|mod
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The same as double_int_div with UNS = false.  */
end_comment

begin_function
name|double_int
name|double_int_sdiv
parameter_list|(
name|double_int
name|a
parameter_list|,
name|double_int
name|b
parameter_list|,
name|unsigned
name|code
parameter_list|)
block|{
return|return
name|double_int_div
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|false
argument_list|,
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The same as double_int_div with UNS = true.  */
end_comment

begin_function
name|double_int
name|double_int_udiv
parameter_list|(
name|double_int
name|a
parameter_list|,
name|double_int
name|b
parameter_list|,
name|unsigned
name|code
parameter_list|)
block|{
return|return
name|double_int_div
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|true
argument_list|,
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns A % B (computed as unsigned depending on UNS, and rounded as    specified by CODE).  CODE is enum tree_code in fact, but double_int.h    must be included before tree.h.  */
end_comment

begin_function
name|double_int
name|double_int_mod
parameter_list|(
name|double_int
name|a
parameter_list|,
name|double_int
name|b
parameter_list|,
name|bool
name|uns
parameter_list|,
name|unsigned
name|code
parameter_list|)
block|{
name|double_int
name|mod
decl_stmt|;
name|double_int_divmod
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|uns
argument_list|,
name|code
argument_list|,
operator|&
name|mod
argument_list|)
expr_stmt|;
return|return
name|mod
return|;
block|}
end_function

begin_comment
comment|/* The same as double_int_mod with UNS = false.  */
end_comment

begin_function
name|double_int
name|double_int_smod
parameter_list|(
name|double_int
name|a
parameter_list|,
name|double_int
name|b
parameter_list|,
name|unsigned
name|code
parameter_list|)
block|{
return|return
name|double_int_mod
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|false
argument_list|,
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The same as double_int_mod with UNS = true.  */
end_comment

begin_function
name|double_int
name|double_int_umod
parameter_list|(
name|double_int
name|a
parameter_list|,
name|double_int
name|b
parameter_list|,
name|unsigned
name|code
parameter_list|)
block|{
return|return
name|double_int_mod
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|true
argument_list|,
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Constructs tree in type TYPE from with value given by CST.  */
end_comment

begin_function
name|tree
name|double_int_to_tree
parameter_list|(
name|tree
name|type
parameter_list|,
name|double_int
name|cst
parameter_list|)
block|{
name|cst
operator|=
name|double_int_ext
argument_list|(
name|cst
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
name|cst
operator|.
name|low
argument_list|,
name|cst
operator|.
name|high
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if CST is negative.  Of course, CST is considered to    be signed.  */
end_comment

begin_function
name|bool
name|double_int_negative_p
parameter_list|(
name|double_int
name|cst
parameter_list|)
block|{
return|return
name|cst
operator|.
name|high
operator|<
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns -1 if A< B, 0 if A == B and 1 if A> B.  Signedness of the    comparison is given by UNS.  */
end_comment

begin_function
name|int
name|double_int_cmp
parameter_list|(
name|double_int
name|a
parameter_list|,
name|double_int
name|b
parameter_list|,
name|bool
name|uns
parameter_list|)
block|{
if|if
condition|(
name|uns
condition|)
return|return
name|double_int_ucmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
else|else
return|return
name|double_int_scmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compares two unsigned values A and B.  Returns -1 if A< B, 0 if A == B,    and 1 if A> B.  */
end_comment

begin_function
name|int
name|double_int_ucmp
parameter_list|(
name|double_int
name|a
parameter_list|,
name|double_int
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|a
operator|.
name|high
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|b
operator|.
name|high
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|a
operator|.
name|high
operator|>
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|b
operator|.
name|high
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|.
name|low
operator|<
name|b
operator|.
name|low
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|.
name|low
operator|>
name|b
operator|.
name|low
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compares two signed values A and B.  Returns -1 if A< B, 0 if A == B,    and 1 if A> B.  */
end_comment

begin_function
name|int
name|double_int_scmp
parameter_list|(
name|double_int
name|a
parameter_list|,
name|double_int
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|high
operator|<
name|b
operator|.
name|high
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|.
name|high
operator|>
name|b
operator|.
name|high
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|HOST_WIDE_INT
operator|)
name|a
operator|.
name|low
operator|<
operator|(
name|HOST_WIDE_INT
operator|)
name|b
operator|.
name|low
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|HOST_WIDE_INT
operator|)
name|a
operator|.
name|low
operator|>
operator|(
name|HOST_WIDE_INT
operator|)
name|b
operator|.
name|low
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Splits last digit of *CST (taken as unsigned) in BASE and returns it.  */
end_comment

begin_function
specifier|static
name|unsigned
name|double_int_split_digit
parameter_list|(
name|double_int
modifier|*
name|cst
parameter_list|,
name|unsigned
name|base
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|resl
decl_stmt|,
name|reml
decl_stmt|;
name|HOST_WIDE_INT
name|resh
decl_stmt|,
name|remh
decl_stmt|;
name|div_and_round_double
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|true
argument_list|,
name|cst
operator|->
name|low
argument_list|,
name|cst
operator|->
name|high
argument_list|,
name|base
argument_list|,
literal|0
argument_list|,
operator|&
name|resl
argument_list|,
operator|&
name|resh
argument_list|,
operator|&
name|reml
argument_list|,
operator|&
name|remh
argument_list|)
expr_stmt|;
name|cst
operator|->
name|high
operator|=
name|resh
expr_stmt|;
name|cst
operator|->
name|low
operator|=
name|resl
expr_stmt|;
return|return
name|reml
return|;
block|}
end_function

begin_comment
comment|/* Dumps CST to FILE.  If UNS is true, CST is considered to be unsigned,    otherwise it is signed.  */
end_comment

begin_function
name|void
name|dump_double_int
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|double_int
name|cst
parameter_list|,
name|bool
name|uns
parameter_list|)
block|{
name|unsigned
name|digits
index|[
literal|100
index|]
decl_stmt|,
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|double_int_zero_p
argument_list|(
name|cst
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|uns
operator|&&
name|double_int_negative_p
argument_list|(
name|cst
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|cst
operator|=
name|double_int_neg
argument_list|(
name|cst
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|!
name|double_int_zero_p
argument_list|(
name|cst
argument_list|)
condition|;
name|n
operator|++
control|)
name|digits
index|[
name|n
index|]
operator|=
name|double_int_split_digit
argument_list|(
operator|&
name|cst
argument_list|,
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%u"
argument_list|,
name|digits
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

