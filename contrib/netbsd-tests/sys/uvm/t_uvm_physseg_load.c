begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $NetBSD: t_uvm_physseg_load.c,v 1.2 2016/12/22 08:15:20 cherry Exp $ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2015, 2016 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Santhosh N. Raju<santhosh.raju@gmail.com> and  * by Cherry G. Mathew  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: t_uvm_physseg_load.c,v 1.2 2016/12/22 08:15:20 cherry Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * If this line is commented out tests related touvm_physseg_get_pmseg()  * wont run.  *  * Have a look at machine/uvm_physseg.h for more details.  */
end_comment

begin_define
define|#
directive|define
name|__HAVE_PMAP_PHYSSEG
end_define

begin_comment
comment|/*  * This is a dummy struct used for testing purposes  *  * In reality this struct would exist in the MD part of the code residing in  * machines/vmparam.h  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__HAVE_PMAP_PHYSSEG
end_ifdef

begin_struct
struct|struct
name|pmap_physseg
block|{
name|int
name|dummy_variable
decl_stmt|;
comment|/* Dummy variable use for testing */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Testing API - assumes userland */
end_comment

begin_comment
comment|/* Provide Kernel API equivalents */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memset(3) et. al */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* printf(3) */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* malloc(3) */
end_comment

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_define
define|#
directive|define
name|PRIxPADDR
value|"lx"
end_define

begin_define
define|#
directive|define
name|PRIxPSIZE
value|"lx"
end_define

begin_define
define|#
directive|define
name|PRIuPSIZE
value|"lu"
end_define

begin_define
define|#
directive|define
name|PRIxVADDR
value|"lx"
end_define

begin_define
define|#
directive|define
name|PRIxVSIZE
value|"lx"
end_define

begin_define
define|#
directive|define
name|PRIuVSIZE
value|"lu"
end_define

begin_define
define|#
directive|define
name|UVM_HOTPLUG
end_define

begin_comment
comment|/* Enable hotplug with rbtree. */
end_comment

begin_define
define|#
directive|define
name|PMAP_STEAL_MEMORY
end_define

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_comment
comment|/* Enable debug functionality. */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|long
name|vaddr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|paddr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|psize_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|vsize_t
typedef|;
end_typedef

begin_include
include|#
directive|include
file|<uvm/uvm_physseg.h>
end_include

begin_include
include|#
directive|include
file|<uvm/uvm_page.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DIAGNOSTIC
end_ifndef

begin_define
define|#
directive|define
name|KASSERTMSG
parameter_list|(
name|e
parameter_list|,
name|msg
parameter_list|,
modifier|...
parameter_list|)
end_define

begin_comment
comment|/* NOTHING */
end_comment

begin_define
define|#
directive|define
name|KASSERT
parameter_list|(
name|e
parameter_list|)
end_define

begin_comment
comment|/* NOTHING */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|KASSERT
parameter_list|(
name|a
parameter_list|)
value|assert(a)
end_define

begin_define
define|#
directive|define
name|KASSERTMSG
parameter_list|(
name|exp
parameter_list|,
modifier|...
parameter_list|)
value|printf(__VA_ARGS__); assert((exp))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|VM_PHYSSEG_STRAT
value|VM_PSTRAT_BSEARCH
end_define

begin_define
define|#
directive|define
name|VM_NFREELIST
value|4
end_define

begin_define
define|#
directive|define
name|VM_FREELIST_DEFAULT
value|0
end_define

begin_define
define|#
directive|define
name|VM_FREELIST_FIRST16
value|3
end_define

begin_define
define|#
directive|define
name|VM_FREELIST_FIRST1G
value|2
end_define

begin_define
define|#
directive|define
name|VM_FREELIST_FIRST4G
value|1
end_define

begin_comment
comment|/*  * Used in tests when Array implementation is tested  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VM_PHYSSEG_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|VM_PHYSSEG_MAX
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PAGE_SIZE
value|4096
end_define

begin_define
define|#
directive|define
name|PAGE_SHIFT
value|12
end_define

begin_define
define|#
directive|define
name|atop
parameter_list|(
name|x
parameter_list|)
value|(((paddr_t)(x))>> PAGE_SHIFT)
end_define

begin_define
define|#
directive|define
name|mutex_enter
parameter_list|(
name|l
parameter_list|)
end_define

begin_define
define|#
directive|define
name|mutex_exit
parameter_list|(
name|l
parameter_list|)
end_define

begin_define
define|#
directive|define
name|_SYS_KMEM_H_
end_define

begin_comment
comment|/* Disallow the real kmem API (see below) */
end_comment

begin_comment
comment|/* free(p) XXX: pgs management need more thought */
end_comment

begin_define
define|#
directive|define
name|kmem_alloc
parameter_list|(
name|size
parameter_list|,
name|flags
parameter_list|)
value|malloc(size)
end_define

begin_define
define|#
directive|define
name|kmem_zalloc
parameter_list|(
name|size
parameter_list|,
name|flags
parameter_list|)
value|malloc(size)
end_define

begin_define
define|#
directive|define
name|kmem_free
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|)
value|free(p)
end_define

begin_decl_stmt
name|psize_t
name|physmem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uvmexp
name|uvmexp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* decl */
end_comment

begin_comment
comment|/*  * uvm structure borrowed from uvm.h  *  * Remember this is a dummy structure used within the ATF Tests and  * uses only necessary fields from the original uvm struct.  * See uvm/uvm.h for the full struct.  */
end_comment

begin_struct
struct|struct
name|uvm
block|{
comment|/* vm_page related parameters */
name|bool
name|page_init_done
decl_stmt|;
comment|/* TRUE if uvm_page_init() finished */
block|}
name|uvm
struct|;
end_struct

begin_function
specifier|static
name|void
name|panic
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|false
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
specifier|static
name|void
name|uvm_pagefree
parameter_list|(
name|struct
name|vm_page
modifier|*
name|pg
parameter_list|)
block|{
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|UVM_HOTPLUG
argument_list|)
end_if

begin_function
specifier|static
name|void
name|uvmpdpol_reinit
parameter_list|(
name|void
parameter_list|)
block|{
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UVM_HOTPLUG */
end_comment

begin_comment
comment|/* end - Provide Kernel API equivalents */
end_comment

begin_include
include|#
directive|include
file|"uvm/uvm_physseg.c"
end_include

begin_include
include|#
directive|include
file|<atf-c.h>
end_include

begin_define
define|#
directive|define
name|ONE_MEGABYTE
value|1024 * 1024
end_define

begin_comment
comment|/* Sample Page Frame Numbers */
end_comment

begin_define
define|#
directive|define
name|VALID_START_PFN_1
value|atop(0)
end_define

begin_define
define|#
directive|define
name|VALID_END_PFN_1
value|atop(ONE_MEGABYTE)
end_define

begin_define
define|#
directive|define
name|VALID_AVAIL_START_PFN_1
value|atop(0)
end_define

begin_define
define|#
directive|define
name|VALID_AVAIL_END_PFN_1
value|atop(ONE_MEGABYTE)
end_define

begin_define
define|#
directive|define
name|VALID_START_PFN_2
value|atop(ONE_MEGABYTE + 1)
end_define

begin_define
define|#
directive|define
name|VALID_END_PFN_2
value|atop(ONE_MEGABYTE * 2)
end_define

begin_define
define|#
directive|define
name|VALID_AVAIL_START_PFN_2
value|atop(ONE_MEGABYTE + 1)
end_define

begin_define
define|#
directive|define
name|VALID_AVAIL_END_PFN_2
value|atop(ONE_MEGABYTE * 2)
end_define

begin_define
define|#
directive|define
name|VALID_START_PFN_3
value|atop((ONE_MEGABYTE * 2) + 1)
end_define

begin_define
define|#
directive|define
name|VALID_END_PFN_3
value|atop(ONE_MEGABYTE * 3)
end_define

begin_define
define|#
directive|define
name|VALID_AVAIL_START_PFN_3
value|atop((ONE_MEGABYTE * 2) + 1)
end_define

begin_define
define|#
directive|define
name|VALID_AVAIL_END_PFN_3
value|atop(ONE_MEGABYTE * 3)
end_define

begin_define
define|#
directive|define
name|VALID_START_PFN_4
value|atop(ONE_MEGABYTE + 1)
end_define

begin_define
define|#
directive|define
name|VALID_END_PFN_4
value|atop(ONE_MEGABYTE * 128)
end_define

begin_define
define|#
directive|define
name|VALID_AVAIL_START_PFN_4
value|atop(ONE_MEGABYTE + 1)
end_define

begin_define
define|#
directive|define
name|VALID_AVAIL_END_PFN_4
value|atop(ONE_MEGABYTE * 128)
end_define

begin_define
define|#
directive|define
name|VALID_START_PFN_5
value|atop(ONE_MEGABYTE + 1)
end_define

begin_define
define|#
directive|define
name|VALID_END_PFN_5
value|atop(ONE_MEGABYTE * 256)
end_define

begin_define
define|#
directive|define
name|VALID_AVAIL_START_PFN_5
value|atop(ONE_MEGABYTE + 1)
end_define

begin_define
define|#
directive|define
name|VALID_AVAIL_END_PFN_5
value|atop(ONE_MEGABYTE * 256)
end_define

begin_comment
comment|/*  * Total number of pages (of 4K size each) should be 256 for 1MB of memory.  */
end_comment

begin_define
define|#
directive|define
name|PAGE_COUNT_1M
value|256
end_define

begin_comment
comment|/*  * The number of Page Frames to allot per segment  */
end_comment

begin_define
define|#
directive|define
name|PF_STEP
value|8
end_define

begin_comment
comment|/*  * A debug fucntion to print the content of upm.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|uvm_physseg_dump_seg
parameter_list|(
name|uvm_physseg_t
name|upm
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|printf
argument_list|(
literal|"%s: seg->start == %ld\n"
argument_list|,
name|__func__
argument_list|,
name|uvm_physseg_get_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: seg->end == %ld\n"
argument_list|,
name|__func__
argument_list|,
name|uvm_physseg_get_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: seg->avail_start == %ld\n"
argument_list|,
name|__func__
argument_list|,
name|uvm_physseg_get_avail_start
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: seg->avail_end == %ld\n"
argument_list|,
name|__func__
argument_list|,
name|uvm_physseg_get_avail_end
argument_list|(
name|upm
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"====\n\n"
argument_list|)
expr_stmt|;
else|#
directive|else
return|return;
endif|#
directive|endif
comment|/* DEBUG */
block|}
end_function

begin_comment
comment|/*  * Private accessor that gets the value of vm_physmem.nentries  */
end_comment

begin_function
specifier|static
name|int
name|uvm_physseg_get_entries
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|UVM_HOTPLUG
argument_list|)
return|return
name|uvm_physseg_graph
operator|.
name|nentries
return|;
else|#
directive|else
return|return
name|vm_nphysmem
return|;
endif|#
directive|endif
comment|/* UVM_HOTPLUG */
block|}
end_function

begin_comment
comment|/*  * Note: This function replicates verbatim what happens in  * uvm_page.c:uvm_page_init().  *  * Please track any changes that happen there.  */
end_comment

begin_function
specifier|static
name|void
name|uvm_page_init_fake
parameter_list|(
name|struct
name|vm_page
modifier|*
name|pagearray
parameter_list|,
name|psize_t
name|pagecount
parameter_list|)
block|{
name|uvm_physseg_t
name|bank
decl_stmt|;
name|size_t
name|n
decl_stmt|;
for|for
control|(
name|bank
operator|=
name|uvm_physseg_get_first
argument_list|()
operator|,
name|uvm_physseg_seg_chomp_slab
argument_list|(
name|bank
argument_list|,
name|pagearray
argument_list|,
name|pagecount
argument_list|)
init|;
name|uvm_physseg_valid_p
argument_list|(
name|bank
argument_list|)
condition|;
name|bank
operator|=
name|uvm_physseg_get_next
argument_list|(
name|bank
argument_list|)
control|)
block|{
name|n
operator|=
name|uvm_physseg_get_end
argument_list|(
name|bank
argument_list|)
operator|-
name|uvm_physseg_get_start
argument_list|(
name|bank
argument_list|)
expr_stmt|;
name|uvm_physseg_seg_alloc_from_slab
argument_list|(
name|bank
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|uvm_physseg_init_seg
argument_list|(
name|bank
argument_list|,
name|pagearray
argument_list|)
expr_stmt|;
comment|/* set up page array pointers */
name|pagearray
operator|+=
name|n
expr_stmt|;
name|pagecount
operator|-=
name|n
expr_stmt|;
block|}
name|uvm
operator|.
name|page_init_done
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * PHYS_TO_VM_PAGE: find vm_page for a PA.   used by MI code to get vm_pages  * back from an I/O mapping (ugh!).   used in some MD code as well.  */
end_comment

begin_function
specifier|static
name|struct
name|vm_page
modifier|*
name|uvm_phys_to_vm_page
parameter_list|(
name|paddr_t
name|pa
parameter_list|)
block|{
name|paddr_t
name|pf
init|=
name|atop
argument_list|(
name|pa
argument_list|)
decl_stmt|;
name|paddr_t
name|off
decl_stmt|;
name|uvm_physseg_t
name|psi
decl_stmt|;
name|psi
operator|=
name|uvm_physseg_find
argument_list|(
name|pf
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|psi
operator|!=
name|UVM_PHYSSEG_TYPE_INVALID
condition|)
return|return
name|uvm_physseg_get_pg
argument_list|(
name|psi
argument_list|,
name|off
argument_list|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|//static paddr_t
end_comment

begin_comment
comment|//uvm_vm_page_to_phys(const struct vm_page *pg)
end_comment

begin_comment
comment|//{
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//	return pg->phys_addr;
end_comment

begin_comment
comment|//}
end_comment

begin_comment
comment|/*  * XXX: To do, write control test cases for uvm_vm_page_to_phys().  */
end_comment

begin_comment
comment|/* #define VM_PAGE_TO_PHYS(entry)  uvm_vm_page_to_phys(entry) */
end_comment

begin_define
define|#
directive|define
name|PHYS_TO_VM_PAGE
parameter_list|(
name|pa
parameter_list|)
value|uvm_phys_to_vm_page(pa)
end_define

begin_comment
comment|/*  * Test Fixture SetUp().  */
end_comment

begin_function
specifier|static
name|void
name|setup
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Prerequisites for running certain calls in uvm_physseg */
name|uvmexp
operator|.
name|pagesize
operator|=
name|PAGE_SIZE
expr_stmt|;
name|uvmexp
operator|.
name|npages
operator|=
literal|0
expr_stmt|;
name|uvm
operator|.
name|page_init_done
operator|=
name|false
expr_stmt|;
name|uvm_physseg_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_100
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_100
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Load test uvm_phys_to_vm_page() with \ 	    100 calls, VM_PHYSSEG_MAX is 32."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_100
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|paddr_t
name|pa
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
for|for
control|(
name|paddr_t
name|i
init|=
name|VALID_START_PFN_1
init|;
name|i
operator|<
name|VALID_END_PFN_1
condition|;
name|i
operator|+=
name|PF_STEP
control|)
block|{
name|uvm_page_physload
argument_list|(
name|i
argument_list|,
name|i
operator|+
name|PF_STEP
argument_list|,
name|i
argument_list|,
name|i
operator|+
name|PF_STEP
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
block|}
name|ATF_REQUIRE_EQ
argument_list|(
name|VM_PHYSSEG_MAX
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
operator|(
name|unsigned
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
operator|(
name|paddr_t
operator|)
name|random
argument_list|()
operator|%
operator|(
name|paddr_t
operator|)
name|ctob
argument_list|(
name|VALID_END_PFN_1
argument_list|)
expr_stmt|;
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_1K
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_1K
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Load test uvm_phys_to_vm_page() with \ 	    1000 calls, VM_PHYSSEG_MAX is 32."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_1K
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|paddr_t
name|pa
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
for|for
control|(
name|paddr_t
name|i
init|=
name|VALID_START_PFN_1
init|;
name|i
operator|<
name|VALID_END_PFN_1
condition|;
name|i
operator|+=
name|PF_STEP
control|)
block|{
name|uvm_page_physload
argument_list|(
name|i
argument_list|,
name|i
operator|+
name|PF_STEP
argument_list|,
name|i
argument_list|,
name|i
operator|+
name|PF_STEP
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
block|}
name|ATF_REQUIRE_EQ
argument_list|(
name|VM_PHYSSEG_MAX
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
operator|(
name|unsigned
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
operator|(
name|paddr_t
operator|)
name|random
argument_list|()
operator|%
operator|(
name|paddr_t
operator|)
name|ctob
argument_list|(
name|VALID_END_PFN_1
argument_list|)
expr_stmt|;
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_10K
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_10K
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Load test uvm_phys_to_vm_page() with \ 	    10,000 calls, VM_PHYSSEG_MAX is 32."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_10K
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|paddr_t
name|pa
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
for|for
control|(
name|paddr_t
name|i
init|=
name|VALID_START_PFN_1
init|;
name|i
operator|<
name|VALID_END_PFN_1
condition|;
name|i
operator|+=
name|PF_STEP
control|)
block|{
name|uvm_page_physload
argument_list|(
name|i
argument_list|,
name|i
operator|+
name|PF_STEP
argument_list|,
name|i
argument_list|,
name|i
operator|+
name|PF_STEP
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
block|}
name|ATF_REQUIRE_EQ
argument_list|(
name|VM_PHYSSEG_MAX
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
operator|(
name|unsigned
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10000
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
operator|(
name|paddr_t
operator|)
name|random
argument_list|()
operator|%
operator|(
name|paddr_t
operator|)
name|ctob
argument_list|(
name|VALID_END_PFN_1
argument_list|)
expr_stmt|;
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_100K
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_100K
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Load test uvm_phys_to_vm_page() with \ 	    100,000 calls, VM_PHYSSEG_MAX is 32."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_100K
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|paddr_t
name|pa
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
for|for
control|(
name|paddr_t
name|i
init|=
name|VALID_START_PFN_1
init|;
name|i
operator|<
name|VALID_END_PFN_1
condition|;
name|i
operator|+=
name|PF_STEP
control|)
block|{
name|uvm_page_physload
argument_list|(
name|i
argument_list|,
name|i
operator|+
name|PF_STEP
argument_list|,
name|i
argument_list|,
name|i
operator|+
name|PF_STEP
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
block|}
name|ATF_REQUIRE_EQ
argument_list|(
name|VM_PHYSSEG_MAX
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
operator|(
name|unsigned
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|100000
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
operator|(
name|paddr_t
operator|)
name|random
argument_list|()
operator|%
operator|(
name|paddr_t
operator|)
name|ctob
argument_list|(
name|VALID_END_PFN_1
argument_list|)
expr_stmt|;
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_1M
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_1M
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Load test uvm_phys_to_vm_page() with \ 	    1,000,000 calls, VM_PHYSSEG_MAX is 32."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_1M
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|paddr_t
name|pa
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
for|for
control|(
name|paddr_t
name|i
init|=
name|VALID_START_PFN_1
init|;
name|i
operator|<
name|VALID_END_PFN_1
condition|;
name|i
operator|+=
name|PF_STEP
control|)
block|{
name|uvm_page_physload
argument_list|(
name|i
argument_list|,
name|i
operator|+
name|PF_STEP
argument_list|,
name|i
argument_list|,
name|i
operator|+
name|PF_STEP
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
block|}
name|ATF_REQUIRE_EQ
argument_list|(
name|VM_PHYSSEG_MAX
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
operator|(
name|unsigned
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|1000000
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
operator|(
name|paddr_t
operator|)
name|random
argument_list|()
operator|%
operator|(
name|paddr_t
operator|)
name|ctob
argument_list|(
name|VALID_END_PFN_1
argument_list|)
expr_stmt|;
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_10M
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_10M
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Load test uvm_phys_to_vm_page() with \ 	    10,000,000 calls, VM_PHYSSEG_MAX is 32."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_10M
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|paddr_t
name|pa
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
for|for
control|(
name|paddr_t
name|i
init|=
name|VALID_START_PFN_1
init|;
name|i
operator|<
name|VALID_END_PFN_1
condition|;
name|i
operator|+=
name|PF_STEP
control|)
block|{
name|uvm_page_physload
argument_list|(
name|i
argument_list|,
name|i
operator|+
name|PF_STEP
argument_list|,
name|i
argument_list|,
name|i
operator|+
name|PF_STEP
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
block|}
name|ATF_REQUIRE_EQ
argument_list|(
name|VM_PHYSSEG_MAX
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
operator|(
name|unsigned
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10000000
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
operator|(
name|paddr_t
operator|)
name|random
argument_list|()
operator|%
operator|(
name|paddr_t
operator|)
name|ctob
argument_list|(
name|VALID_END_PFN_1
argument_list|)
expr_stmt|;
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_100M
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_100M
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Load test uvm_phys_to_vm_page() with \ 	    100,000,000 calls, VM_PHYSSEG_MAX is 32."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_100M
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|paddr_t
name|pa
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
for|for
control|(
name|paddr_t
name|i
init|=
name|VALID_START_PFN_1
init|;
name|i
operator|<
name|VALID_END_PFN_1
condition|;
name|i
operator|+=
name|PF_STEP
control|)
block|{
name|uvm_page_physload
argument_list|(
name|i
argument_list|,
name|i
operator|+
name|PF_STEP
argument_list|,
name|i
argument_list|,
name|i
operator|+
name|PF_STEP
argument_list|,
name|VM_FREELIST_DEFAULT
argument_list|)
expr_stmt|;
block|}
name|ATF_REQUIRE_EQ
argument_list|(
name|VM_PHYSSEG_MAX
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
operator|(
name|unsigned
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|100000000
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
operator|(
name|paddr_t
operator|)
name|random
argument_list|()
operator|%
operator|(
name|paddr_t
operator|)
name|ctob
argument_list|(
name|VALID_END_PFN_1
argument_list|)
expr_stmt|;
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_1MB
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_1MB
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Load test uvm_phys_to_vm_page() with \ 	    10,000,000 calls, VM_PHYSSEG_MAX is 32 on 1 MB Segment."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_1MB
argument_list|,
argument|t
argument_list|)
end_macro

begin_block
block|{
name|paddr_t
name|pa
init|=
literal|0
decl_stmt|;
name|paddr_t
name|pf
init|=
literal|0
decl_stmt|;
name|psize_t
name|pf_chunk_size
init|=
literal|0
decl_stmt|;
name|psize_t
name|npages1
init|=
operator|(
name|VALID_END_PFN_1
operator|-
name|VALID_START_PFN_1
operator|)
decl_stmt|;
name|psize_t
name|npages2
init|=
operator|(
name|VALID_END_PFN_2
operator|-
name|VALID_START_PFN_2
operator|)
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|slab
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|*
operator|(
name|npages1
operator|+
name|npages2
operator|)
argument_list|)
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
comment|/* We start with zero segments */
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm_physseg_plug
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|npages1
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Post boot: Fake all segments and pages accounted for. */
name|uvm_page_init_fake
argument_list|(
name|slab
argument_list|,
name|npages1
operator|+
name|npages2
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm_physseg_plug
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|npages2
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
operator|(
name|unsigned
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pf
operator|=
name|VALID_START_PFN_2
init|;
name|pf
operator|<
name|VALID_END_PFN_2
condition|;
name|pf
operator|+=
name|PF_STEP
control|)
block|{
name|pf_chunk_size
operator|=
operator|(
name|psize_t
operator|)
name|random
argument_list|()
operator|%
call|(
name|psize_t
call|)
argument_list|(
name|PF_STEP
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|uvm_physseg_unplug
argument_list|(
name|pf
argument_list|,
name|pf_chunk_size
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10000000
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
operator|(
name|paddr_t
operator|)
name|random
argument_list|()
operator|%
operator|(
name|paddr_t
operator|)
name|ctob
argument_list|(
name|VALID_END_PFN_2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|<
name|ctob
argument_list|(
name|VALID_START_PFN_2
argument_list|)
condition|)
name|pa
operator|+=
name|ctob
argument_list|(
name|VALID_START_PFN_2
argument_list|)
expr_stmt|;
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_64MB
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_64MB
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Load test uvm_phys_to_vm_page() with \ 	    10,000,000 calls, VM_PHYSSEG_MAX is 32 on 64 MB Segment."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_64MB
argument_list|,
argument|t
argument_list|)
end_macro

begin_block
block|{
name|paddr_t
name|pa
init|=
literal|0
decl_stmt|;
name|paddr_t
name|pf
init|=
literal|0
decl_stmt|;
name|psize_t
name|pf_chunk_size
init|=
literal|0
decl_stmt|;
name|psize_t
name|npages1
init|=
operator|(
name|VALID_END_PFN_1
operator|-
name|VALID_START_PFN_1
operator|)
decl_stmt|;
name|psize_t
name|npages2
init|=
operator|(
name|VALID_END_PFN_3
operator|-
name|VALID_START_PFN_3
operator|)
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|slab
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|*
operator|(
name|npages1
operator|+
name|npages2
operator|)
argument_list|)
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
comment|/* We start with zero segments */
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm_physseg_plug
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|npages1
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Post boot: Fake all segments and pages accounted for. */
name|uvm_page_init_fake
argument_list|(
name|slab
argument_list|,
name|npages1
operator|+
name|npages2
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm_physseg_plug
argument_list|(
name|VALID_START_PFN_3
argument_list|,
name|npages2
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
operator|(
name|unsigned
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pf
operator|=
name|VALID_START_PFN_3
init|;
name|pf
operator|<
name|VALID_END_PFN_3
condition|;
name|pf
operator|+=
name|PF_STEP
control|)
block|{
name|pf_chunk_size
operator|=
operator|(
name|psize_t
operator|)
name|random
argument_list|()
operator|%
call|(
name|psize_t
call|)
argument_list|(
name|PF_STEP
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|uvm_physseg_unplug
argument_list|(
name|pf
argument_list|,
name|pf_chunk_size
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10000000
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
operator|(
name|paddr_t
operator|)
name|random
argument_list|()
operator|%
operator|(
name|paddr_t
operator|)
name|ctob
argument_list|(
name|VALID_END_PFN_3
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|<
name|ctob
argument_list|(
name|VALID_START_PFN_3
argument_list|)
condition|)
name|pa
operator|+=
name|ctob
argument_list|(
name|VALID_START_PFN_3
argument_list|)
expr_stmt|;
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_128MB
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_128MB
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Load test uvm_phys_to_vm_page() with \ 	    10,000,000 calls, VM_PHYSSEG_MAX is 32 on 128 MB Segment."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_128MB
argument_list|,
argument|t
argument_list|)
end_macro

begin_block
block|{
name|paddr_t
name|pa
init|=
literal|0
decl_stmt|;
name|paddr_t
name|pf
init|=
literal|0
decl_stmt|;
name|psize_t
name|pf_chunk_size
init|=
literal|0
decl_stmt|;
name|psize_t
name|npages1
init|=
operator|(
name|VALID_END_PFN_1
operator|-
name|VALID_START_PFN_1
operator|)
decl_stmt|;
name|psize_t
name|npages2
init|=
operator|(
name|VALID_END_PFN_4
operator|-
name|VALID_START_PFN_4
operator|)
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|slab
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|*
operator|(
name|npages1
operator|+
name|npages2
operator|)
argument_list|)
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
comment|/* We start with zero segments */
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm_physseg_plug
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|npages1
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Post boot: Fake all segments and pages accounted for. */
name|uvm_page_init_fake
argument_list|(
name|slab
argument_list|,
name|npages1
operator|+
name|npages2
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm_physseg_plug
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|npages2
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
operator|(
name|unsigned
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pf
operator|=
name|VALID_START_PFN_4
init|;
name|pf
operator|<
name|VALID_END_PFN_4
condition|;
name|pf
operator|+=
name|PF_STEP
control|)
block|{
name|pf_chunk_size
operator|=
operator|(
name|psize_t
operator|)
name|random
argument_list|()
operator|%
call|(
name|psize_t
call|)
argument_list|(
name|PF_STEP
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|uvm_physseg_unplug
argument_list|(
name|pf
argument_list|,
name|pf_chunk_size
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10000000
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
operator|(
name|paddr_t
operator|)
name|random
argument_list|()
operator|%
operator|(
name|paddr_t
operator|)
name|ctob
argument_list|(
name|VALID_END_PFN_4
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|<
name|ctob
argument_list|(
name|VALID_START_PFN_4
argument_list|)
condition|)
name|pa
operator|+=
name|ctob
argument_list|(
name|VALID_START_PFN_4
argument_list|)
expr_stmt|;
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|uvm_physseg_256MB
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|uvm_physseg_256MB
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Load test uvm_phys_to_vm_page() with \ 	    10,000,000 calls, VM_PHYSSEG_MAX is 32 on 256 MB Segment."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|uvm_physseg_256MB
argument_list|,
argument|t
argument_list|)
end_macro

begin_block
block|{
name|paddr_t
name|pa
init|=
literal|0
decl_stmt|;
name|paddr_t
name|pf
init|=
literal|0
decl_stmt|;
name|psize_t
name|pf_chunk_size
init|=
literal|0
decl_stmt|;
name|psize_t
name|npages1
init|=
operator|(
name|VALID_END_PFN_1
operator|-
name|VALID_START_PFN_1
operator|)
decl_stmt|;
name|psize_t
name|npages2
init|=
operator|(
name|VALID_END_PFN_5
operator|-
name|VALID_START_PFN_5
operator|)
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|slab
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|*
operator|(
name|npages1
operator|+
name|npages2
operator|)
argument_list|)
decl_stmt|;
name|setup
argument_list|()
expr_stmt|;
comment|/* We start with zero segments */
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm_physseg_plug
argument_list|(
name|VALID_START_PFN_1
argument_list|,
name|npages1
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|1
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Post boot: Fake all segments and pages accounted for. */
name|uvm_page_init_fake
argument_list|(
name|slab
argument_list|,
name|npages1
operator|+
name|npages2
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|true
argument_list|,
name|uvm_physseg_plug
argument_list|(
name|VALID_START_PFN_2
argument_list|,
name|npages2
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
literal|2
argument_list|,
name|uvm_physseg_get_entries
argument_list|()
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
operator|(
name|unsigned
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pf
operator|=
name|VALID_START_PFN_5
init|;
name|pf
operator|<
name|VALID_END_PFN_5
condition|;
name|pf
operator|+=
name|PF_STEP
control|)
block|{
name|pf_chunk_size
operator|=
operator|(
name|psize_t
operator|)
name|random
argument_list|()
operator|%
call|(
name|psize_t
call|)
argument_list|(
name|PF_STEP
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|uvm_physseg_unplug
argument_list|(
name|pf
argument_list|,
name|pf_chunk_size
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10000000
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
operator|(
name|paddr_t
operator|)
name|random
argument_list|()
operator|%
operator|(
name|paddr_t
operator|)
name|ctob
argument_list|(
name|VALID_END_PFN_5
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|<
name|ctob
argument_list|(
name|VALID_END_PFN_5
argument_list|)
condition|)
name|pa
operator|+=
name|ctob
argument_list|(
name|VALID_START_PFN_5
argument_list|)
expr_stmt|;
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
name|ATF_CHECK_EQ
argument_list|(
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TP_ADD_TCS
argument_list|(
argument|tp
argument_list|)
end_macro

begin_block
block|{
comment|/* Fixed memory size tests. */
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_100
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_1K
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_10K
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_100K
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_1M
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_10M
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_100M
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|UVM_HOTPLUG
argument_list|)
comment|/* Variable memory size tests. */
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_1MB
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_64MB
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_128MB
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|uvm_physseg_256MB
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UVM_HOTPLUG */
return|return
name|atf_no_error
argument_list|()
return|;
block|}
end_block

end_unit

