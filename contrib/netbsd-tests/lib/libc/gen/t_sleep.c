begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $NetBSD: t_sleep.c,v 1.9 2016/08/11 21:34:11 kre Exp $ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2006 Frank Kardel  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<atf-c.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|"isqemu.h"
end_include

begin_define
define|#
directive|define
name|BILLION
value|1000000000LL
end_define

begin_comment
comment|/* nano-seconds per second */
end_comment

begin_define
define|#
directive|define
name|MILLION
value|1000000LL
end_define

begin_comment
comment|/* nano-seconds per milli-second */
end_comment

begin_define
define|#
directive|define
name|ALARM
value|6
end_define

begin_comment
comment|/* SIGALRM after this many seconds */
end_comment

begin_define
define|#
directive|define
name|MAXSLEEP
value|22
end_define

begin_comment
comment|/* Maximum delay in seconds */
end_comment

begin_define
define|#
directive|define
name|KEVNT_TIMEOUT
value|10300
end_define

begin_comment
comment|/* measured in milli-seconds */
end_comment

begin_define
define|#
directive|define
name|FUZZ
value|(40 * MILLION)
end_define

begin_comment
comment|/* scheduling fuzz accepted - 40 ms */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Timer notes  *  * Most tests use FUZZ as their initial delay value, but 'sleep'  * starts at 1sec (since it cannot handle sub-second intervals).  * Subsequent passes double the previous interval, up to MAXSLEEP.  *  * The current values result in 5 passes for the 'sleep' test (at 1,  * 2, 4, 8, and 16 seconds) and 10 passes for the other tests (at  * 0.04, 0.08, 0.16, 0.32, 0.64, 1.28, 2.56, 5.12, 10.24, and 20.48  * seconds).  *  * The ALARM is only set if the current pass's delay is longer, and  * only if the ALARM has not already been triggered.  *  * The 'kevent' test needs the ALARM to be set on a different pass  * from when the KEVNT_TIMEOUT fires.  So set ALARM to fire on the  * penultimate pass, and the KEVNT_TIMEOUT on the final pass.  We  * set KEVNT_TIMEOUT just barely long enough to put it into the  * last test pass, and set MAXSLEEP a couple seconds longer than  * necessary, in order to avoid a QEMU bug which nearly doubles  * some timers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|sig
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|sleeptest
parameter_list|(
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|struct
name|timespec
modifier|*
parameter_list|,
name|struct
name|timespec
modifier|*
parameter_list|)
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|do_nanosleep
parameter_list|(
name|struct
name|timespec
modifier|*
parameter_list|,
name|struct
name|timespec
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|do_select
parameter_list|(
name|struct
name|timespec
modifier|*
parameter_list|,
name|struct
name|timespec
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_function_decl
name|int
name|do_poll
parameter_list|(
name|struct
name|timespec
modifier|*
parameter_list|,
name|struct
name|timespec
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|do_sleep
parameter_list|(
name|struct
name|timespec
modifier|*
parameter_list|,
name|struct
name|timespec
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|do_kevent
parameter_list|(
name|struct
name|timespec
modifier|*
parameter_list|,
name|struct
name|timespec
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sigalrm
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|sigalrm
parameter_list|(
name|int
name|s
parameter_list|)
block|{
name|sig
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|int
name|do_nanosleep
parameter_list|(
name|struct
name|timespec
modifier|*
name|delay
parameter_list|,
name|struct
name|timespec
modifier|*
name|remain
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|nanosleep
argument_list|(
name|delay
argument_list|,
name|remain
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ret
operator|=
operator|(
name|errno
operator|==
name|EINTR
condition|?
literal|0
else|:
name|errno
operator|)
expr_stmt|;
else|else
name|ret
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|do_select
parameter_list|(
name|struct
name|timespec
modifier|*
name|delay
parameter_list|,
name|struct
name|timespec
modifier|*
name|remain
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tv
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ret
operator|=
operator|(
name|errno
operator|==
name|EINTR
condition|?
literal|0
else|:
name|errno
operator|)
expr_stmt|;
else|else
name|ret
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_function
name|int
name|do_poll
parameter_list|(
name|struct
name|timespec
modifier|*
name|delay
parameter_list|,
name|struct
name|timespec
modifier|*
name|remain
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|pollts
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|delay
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ret
operator|=
operator|(
name|errno
operator|==
name|EINTR
condition|?
literal|0
else|:
name|errno
operator|)
expr_stmt|;
else|else
name|ret
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|do_sleep
parameter_list|(
name|struct
name|timespec
modifier|*
name|delay
parameter_list|,
name|struct
name|timespec
modifier|*
name|remain
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
name|delay
argument_list|)
expr_stmt|;
name|remain
operator|->
name|tv_sec
operator|=
name|sleep
argument_list|(
name|delay
operator|->
name|tv_sec
argument_list|)
expr_stmt|;
name|remain
operator|->
name|tv_nsec
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|do_kevent
parameter_list|(
name|struct
name|timespec
modifier|*
name|delay
parameter_list|,
name|struct
name|timespec
modifier|*
name|remain
parameter_list|)
block|{
name|struct
name|kevent
name|ktimer
decl_stmt|;
name|struct
name|kevent
name|kresult
decl_stmt|;
name|int
name|rtc
decl_stmt|,
name|kq
decl_stmt|,
name|kerrno
decl_stmt|;
name|int
name|tmo
decl_stmt|;
name|ATF_REQUIRE_MSG
argument_list|(
operator|(
name|kq
operator|=
name|kqueue
argument_list|()
operator|)
operator|!=
operator|-
literal|1
argument_list|,
literal|"kqueue: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|tmo
operator|=
name|KEVNT_TIMEOUT
expr_stmt|;
comment|/* 	 * If we expect the KEVNT_TIMEOUT to fire, and we're running 	 * under QEMU, make sure the delay is long enough to account 	 * for the effects of PR kern/43997 ! 	 */
if|if
condition|(
name|isQEMU
argument_list|()
operator|&&
name|tmo
operator|/
literal|1000
operator|<
name|delay
operator|->
name|tv_sec
operator|&&
name|tmo
operator|/
literal|500
operator|>
name|delay
operator|->
name|tv_sec
condition|)
name|delay
operator|->
name|tv_sec
operator|=
name|MAXSLEEP
expr_stmt|;
name|EV_SET
argument_list|(
operator|&
name|ktimer
argument_list|,
literal|1
argument_list|,
name|EVFILT_TIMER
argument_list|,
name|EV_ADD
argument_list|,
literal|0
argument_list|,
name|tmo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rtc
operator|=
name|kevent
argument_list|(
name|kq
argument_list|,
operator|&
name|ktimer
argument_list|,
literal|1
argument_list|,
operator|&
name|kresult
argument_list|,
literal|1
argument_list|,
name|delay
argument_list|)
expr_stmt|;
name|kerrno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtc
operator|==
operator|-
literal|1
condition|)
block|{
name|ATF_REQUIRE_MSG
argument_list|(
name|kerrno
operator|==
name|EINTR
argument_list|,
literal|"kevent: %s"
argument_list|,
name|strerror
argument_list|(
name|kerrno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|delay
operator|->
name|tv_sec
operator|*
name|BILLION
operator|+
name|delay
operator|->
name|tv_nsec
operator|>
name|tmo
operator|*
name|MILLION
condition|)
name|ATF_REQUIRE_MSG
argument_list|(
name|rtc
operator|>
literal|0
argument_list|,
literal|"kevent: KEVNT_TIMEOUT did not cause EVFILT_TIMER event"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|ATF_TC
argument_list|(
name|nanosleep
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|nanosleep
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Test nanosleep(2) timing"
argument_list|)
expr_stmt|;
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"timeout"
argument_list|,
literal|"65"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|nanosleep
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|sleeptest
argument_list|(
name|do_nanosleep
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|select
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|select
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Test select(2) timing"
argument_list|)
expr_stmt|;
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"timeout"
argument_list|,
literal|"65"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|select
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|sleeptest
argument_list|(
name|do_select
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_expr_stmt
name|ATF_TC
argument_list|(
name|poll
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|poll
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Test poll(2) timing"
argument_list|)
expr_stmt|;
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"timeout"
argument_list|,
literal|"65"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|poll
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|sleeptest
argument_list|(
name|do_poll
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|ATF_TC
argument_list|(
name|sleep
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|sleep
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Test sleep(3) timing"
argument_list|)
expr_stmt|;
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"timeout"
argument_list|,
literal|"65"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|sleep
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|sleeptest
argument_list|(
name|do_sleep
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|kevent
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|kevent
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Test kevent(2) timing"
argument_list|)
expr_stmt|;
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"timeout"
argument_list|,
literal|"65"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|kevent
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|sleeptest
argument_list|(
name|do_kevent
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|sleeptest
parameter_list|(
name|int
function_decl|(
modifier|*
name|test
function_decl|)
parameter_list|(
name|struct
name|timespec
modifier|*
parameter_list|,
name|struct
name|timespec
modifier|*
parameter_list|)
parameter_list|,
name|bool
name|subsec
parameter_list|,
name|bool
name|sim_remain
parameter_list|)
block|{
name|struct
name|timespec
name|tsa
decl_stmt|,
name|tsb
decl_stmt|,
name|tslp
decl_stmt|,
name|tremain
decl_stmt|;
name|int64_t
name|delta1
decl_stmt|,
name|delta2
decl_stmt|,
name|delta3
decl_stmt|,
name|round
decl_stmt|;
name|sig
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|sigalrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|subsec
condition|)
block|{
name|round
operator|=
literal|1
expr_stmt|;
name|delta3
operator|=
name|FUZZ
expr_stmt|;
block|}
else|else
block|{
name|round
operator|=
literal|1000000000
expr_stmt|;
name|delta3
operator|=
name|round
expr_stmt|;
block|}
name|tslp
operator|.
name|tv_sec
operator|=
name|delta3
operator|/
literal|1000000000
expr_stmt|;
name|tslp
operator|.
name|tv_nsec
operator|=
name|delta3
operator|%
literal|1000000000
expr_stmt|;
while|while
condition|(
name|tslp
operator|.
name|tv_sec
operator|<=
name|MAXSLEEP
condition|)
block|{
comment|/* 		 * disturb sleep by signal on purpose 		 */
if|if
condition|(
name|tslp
operator|.
name|tv_sec
operator|>
name|ALARM
operator|&&
name|sig
operator|==
literal|0
condition|)
name|alarm
argument_list|(
name|ALARM
argument_list|)
expr_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|tsa
argument_list|)
expr_stmt|;
call|(
modifier|*
name|test
call|)
argument_list|(
operator|&
name|tslp
argument_list|,
operator|&
name|tremain
argument_list|)
expr_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|tsb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sim_remain
condition|)
block|{
name|timespecsub
argument_list|(
operator|&
name|tsb
argument_list|,
operator|&
name|tsa
argument_list|,
operator|&
name|tremain
argument_list|)
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|tslp
argument_list|,
operator|&
name|tremain
argument_list|,
operator|&
name|tremain
argument_list|)
expr_stmt|;
block|}
name|delta1
operator|=
operator|(
name|int64_t
operator|)
name|tsb
operator|.
name|tv_sec
operator|-
operator|(
name|int64_t
operator|)
name|tsa
operator|.
name|tv_sec
expr_stmt|;
name|delta1
operator|*=
name|BILLION
expr_stmt|;
name|delta1
operator|+=
operator|(
name|int64_t
operator|)
name|tsb
operator|.
name|tv_nsec
operator|-
operator|(
name|int64_t
operator|)
name|tsa
operator|.
name|tv_nsec
expr_stmt|;
name|delta2
operator|=
operator|(
name|int64_t
operator|)
name|tremain
operator|.
name|tv_sec
operator|*
name|BILLION
expr_stmt|;
name|delta2
operator|+=
operator|(
name|int64_t
operator|)
name|tremain
operator|.
name|tv_nsec
expr_stmt|;
name|delta3
operator|=
operator|(
name|int64_t
operator|)
name|tslp
operator|.
name|tv_sec
operator|*
name|BILLION
expr_stmt|;
name|delta3
operator|+=
operator|(
name|int64_t
operator|)
name|tslp
operator|.
name|tv_nsec
operator|-
name|delta1
operator|-
name|delta2
expr_stmt|;
name|delta3
operator|/=
name|round
expr_stmt|;
name|delta3
operator|*=
name|round
expr_stmt|;
if|if
condition|(
name|delta3
operator|>
name|FUZZ
operator|||
name|delta3
operator|<
operator|-
name|FUZZ
condition|)
block|{
if|if
condition|(
operator|!
name|sim_remain
condition|)
name|atf_tc_expect_fail
argument_list|(
literal|"Long reschedule latency "
literal|"due to PR kern/43997"
argument_list|)
expr_stmt|;
name|atf_tc_fail
argument_list|(
literal|"Reschedule latency %"
name|PRId64
literal|" exceeds "
literal|"allowable fuzz %lld"
argument_list|,
name|delta3
argument_list|,
name|FUZZ
argument_list|)
expr_stmt|;
block|}
name|delta3
operator|=
operator|(
name|int64_t
operator|)
name|tslp
operator|.
name|tv_sec
operator|*
literal|2
operator|*
name|BILLION
expr_stmt|;
name|delta3
operator|+=
operator|(
name|int64_t
operator|)
name|tslp
operator|.
name|tv_nsec
operator|*
literal|2
expr_stmt|;
name|delta3
operator|/=
name|round
expr_stmt|;
name|delta3
operator|*=
name|round
expr_stmt|;
if|if
condition|(
name|delta3
operator|<
name|FUZZ
condition|)
break|break;
name|tslp
operator|.
name|tv_sec
operator|=
name|delta3
operator|/
name|BILLION
expr_stmt|;
name|tslp
operator|.
name|tv_nsec
operator|=
name|delta3
operator|%
name|BILLION
expr_stmt|;
block|}
name|ATF_REQUIRE_MSG
argument_list|(
name|sig
operator|==
literal|1
argument_list|,
literal|"Alarm did not fire!"
argument_list|)
expr_stmt|;
name|atf_tc_pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|ATF_TP_ADD_TCS
argument_list|(
argument|tp
argument_list|)
end_macro

begin_block
block|{
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|nanosleep
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|select
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__NetBSD__
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|poll
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|sleep
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|kevent
argument_list|)
expr_stmt|;
return|return
name|atf_no_error
argument_list|()
return|;
block|}
end_block

end_unit

