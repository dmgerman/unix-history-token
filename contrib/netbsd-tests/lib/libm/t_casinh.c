begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $NetBSD: t_casinh.c,v 1.2 2016/09/20 17:19:28 christos Exp $ */
end_comment

begin_comment
comment|/*  * Written by Maya Rashish  * Public domain.  *  * Testing special values of casinh  * Values from ISO/IEC 9899:201x G.6.2.2  */
end_comment

begin_include
include|#
directive|include
file|<atf-c.h>
end_include

begin_include
include|#
directive|include
file|<complex.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_define
define|#
directive|define
name|RE
parameter_list|(
name|z
parameter_list|)
value|(((double *)(&z))[0])
end_define

begin_define
define|#
directive|define
name|IM
parameter_list|(
name|z
parameter_list|)
value|(((double *)(&z))[1])
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|double
name|input_re
decl_stmt|;
name|double
name|input_im
decl_stmt|;
name|double
name|result_re
decl_stmt|;
name|double
name|result_im
decl_stmt|;
block|}
name|values
index|[]
init|=
block|{
block|{
operator|+
literal|0
block|,
operator|+
literal|0
block|,
operator|+
literal|0
block|,
operator|+
literal|0
block|}
block|,
block|{
operator|+
literal|5.032E3
block|,
operator|+
name|INFINITY
block|,
operator|+
name|INFINITY
block|,
operator|+
name|M_PI
operator|/
literal|2
block|}
block|,
block|{
operator|+
name|INFINITY
block|,
operator|+
literal|5.023E3
block|,
operator|+
name|INFINITY
block|,
operator|+
literal|0
block|}
block|,
block|{
operator|+
name|INFINITY
block|,
operator|+
name|INFINITY
block|,
operator|+
name|INFINITY
block|,
operator|+
name|M_PI
operator|/
literal|4
block|}
block|,
ifdef|#
directive|ifdef
name|__HAVE_NANF
block|{
operator|+
name|INFINITY
block|,
operator|+
name|NAN
block|,
operator|+
name|INFINITY
block|,
operator|+
name|NAN
block|}
block|,
block|{
operator|+
literal|5.032E3
block|,
operator|+
name|NAN
block|,
operator|+
name|NAN
block|,
operator|+
name|NAN
block|}
block|,
comment|/* + FE_INVALID optionally raised */
block|{
operator|+
name|NAN
block|,
operator|+
literal|0
block|,
operator|+
name|NAN
block|,
operator|+
literal|0
block|}
block|,
block|{
operator|+
name|NAN
block|,
operator|-
literal|5.023E3
block|,
operator|+
name|NAN
block|,
operator|+
name|NAN
block|}
block|,
comment|/* + FE_INVALID optionally raised */
block|{
operator|+
name|NAN
block|,
operator|+
name|INFINITY
block|,
operator|+
name|INFINITY
block|,
operator|+
name|NAN
block|}
block|,
comment|/* sign of real part of result unspecified */
block|{
operator|+
name|NAN
block|,
operator|+
name|NAN
block|,
operator|+
name|NAN
block|,
operator|+
name|NAN
block|}
block|,
endif|#
directive|endif
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|__HAVE_NANF
end_ifdef

begin_define
define|#
directive|define
name|both_nan
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(isnan(a)&& isnan(b))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|both_nan
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|crude_equality
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a == b) || both_nan(a,b))
end_define

begin_define
define|#
directive|define
name|ATF_COMPLEX_EQUAL
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|do { \ 	complex double ci = casinh(a); \ 	ATF_CHECK_MSG(crude_equality(creal(ci),creal(b))&& \ 	    crude_equality(cimag(ci), cimag(b)), \ 	    "for casinh([%g,%g]) = [%g,%g] != [%g,%g]", \ 	    creal(a), cimag(a), creal(ci), cimag(ci), creal(b), cimag(b)); \ } while (0
comment|/*CONSTCOND*/
value|)
end_define

begin_expr_stmt
name|ATF_TC
argument_list|(
name|casinh
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|casinh
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Check casinh family - special values"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|casinh
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|complex
name|double
name|input
decl_stmt|;
name|complex
name|double
name|result
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|__arraycount
argument_list|(
name|values
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|RE
argument_list|(
name|input
argument_list|)
operator|=
name|values
index|[
name|i
index|]
operator|.
name|input_re
expr_stmt|;
name|IM
argument_list|(
name|input
argument_list|)
operator|=
name|values
index|[
name|i
index|]
operator|.
name|input_im
expr_stmt|;
name|RE
argument_list|(
name|result
argument_list|)
operator|=
name|values
index|[
name|i
index|]
operator|.
name|result_re
expr_stmt|;
name|IM
argument_list|(
name|result
argument_list|)
operator|=
name|values
index|[
name|i
index|]
operator|.
name|result_im
expr_stmt|;
name|ATF_COMPLEX_EQUAL
argument_list|(
name|input
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|ATF_TP_ADD_TCS
argument_list|(
argument|tp
argument_list|)
end_macro

begin_block
block|{
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|casinh
argument_list|)
expr_stmt|;
return|return
name|atf_no_error
argument_list|()
return|;
block|}
end_block

end_unit

