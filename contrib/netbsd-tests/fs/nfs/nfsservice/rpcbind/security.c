begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: security.c,v 1.1 2010/07/26 15:53:01 pooka Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpcb_prot.h>
end_include

begin_include
include|#
directive|include
file|<rpc/pmap_prot.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_comment
comment|/*  * XXX for special case checks in check_callit.  */
end_comment

begin_include
include|#
directive|include
file|<rpcsvc/mount.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/rquota.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/nfs_prot.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/yp.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/ypclnt.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/yppasswd.h>
end_include

begin_include
include|#
directive|include
file|"rpcbind.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|LIBWRAP
end_ifdef

begin_include
include|#
directive|include
file|<tcpd.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|LIBWRAP_ALLOW_FACILITY
end_ifndef

begin_define
define|#
directive|define
name|LIBWRAP_ALLOW_FACILITY
value|LOG_AUTH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LIBWRAP_ALLOW_SEVERITY
end_ifndef

begin_define
define|#
directive|define
name|LIBWRAP_ALLOW_SEVERITY
value|LOG_INFO
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LIBWRAP_DENY_FACILITY
end_ifndef

begin_define
define|#
directive|define
name|LIBWRAP_DENY_FACILITY
value|LOG_AUTH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LIBWRAP_DENY_SEVERITY
end_ifndef

begin_define
define|#
directive|define
name|LIBWRAP_DENY_SEVERITY
value|LOG_WARNING
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|allow_severity
init|=
name|LIBWRAP_ALLOW_FACILITY
operator||
name|LIBWRAP_ALLOW_SEVERITY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|deny_severity
init|=
name|LIBWRAP_DENY_FACILITY
operator||
name|LIBWRAP_DENY_SEVERITY
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PORTMAP_LOG_FACILITY
end_ifndef

begin_define
define|#
directive|define
name|PORTMAP_LOG_FACILITY
value|LOG_AUTH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PORTMAP_LOG_SEVERITY
end_ifndef

begin_define
define|#
directive|define
name|PORTMAP_LOG_SEVERITY
value|LOG_INFO
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|log_severity
init|=
name|PORTMAP_LOG_FACILITY
operator||
name|PORTMAP_LOG_SEVERITY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|verboselog
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|check_access
parameter_list|(
name|SVCXPRT
modifier|*
name|xprt
parameter_list|,
name|rpcproc_t
name|proc
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
name|rpcbvers
parameter_list|)
block|{
name|struct
name|netbuf
modifier|*
name|caller
init|=
name|svc_getrpccaller
argument_list|(
name|xprt
argument_list|)
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr
init|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|caller
operator|->
name|buf
decl_stmt|;
ifdef|#
directive|ifdef
name|LIBWRAP
name|struct
name|request_info
name|req
decl_stmt|;
endif|#
directive|endif
name|rpcprog_t
name|prog
init|=
literal|0
decl_stmt|;
name|rpcb
modifier|*
name|rpcbp
decl_stmt|;
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
comment|/* 	 * The older PMAP_* equivalents have the same numbers, so 	 * they are accounted for here as well. 	 */
switch|switch
condition|(
name|proc
condition|)
block|{
case|case
name|RPCBPROC_GETADDR
case|:
case|case
name|RPCBPROC_SET
case|:
case|case
name|RPCBPROC_UNSET
case|:
if|if
condition|(
name|rpcbvers
operator|>
name|PMAPVERS
condition|)
block|{
name|rpcbp
operator|=
operator|(
name|rpcb
operator|*
operator|)
name|args
expr_stmt|;
name|prog
operator|=
name|rpcbp
operator|->
name|r_prog
expr_stmt|;
block|}
else|else
block|{
name|pmap
operator|=
operator|(
expr|struct
name|pmap
operator|*
operator|)
name|args
expr_stmt|;
name|prog
operator|=
name|pmap
operator|->
name|pm_prog
expr_stmt|;
block|}
if|if
condition|(
name|proc
operator|==
name|RPCBPROC_GETADDR
condition|)
break|break;
if|if
condition|(
operator|!
name|insecure
operator|&&
operator|!
name|is_loopback
argument_list|(
name|caller
argument_list|)
condition|)
block|{
if|if
condition|(
name|verboselog
condition|)
name|logit
argument_list|(
name|log_severity
argument_list|,
name|addr
argument_list|,
name|proc
argument_list|,
name|prog
argument_list|,
literal|" declined (non-loopback sender)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|RPCBPROC_CALLIT
case|:
case|case
name|RPCBPROC_INDIRECT
case|:
case|case
name|RPCBPROC_DUMP
case|:
case|case
name|RPCBPROC_GETTIME
case|:
case|case
name|RPCBPROC_UADDR2TADDR
case|:
case|case
name|RPCBPROC_TADDR2UADDR
case|:
case|case
name|RPCBPROC_GETVERSADDR
case|:
case|case
name|RPCBPROC_GETADDRLIST
case|:
case|case
name|RPCBPROC_GETSTAT
case|:
default|default:
break|break;
block|}
ifdef|#
directive|ifdef
name|LIBWRAP
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_LOCAL
condition|)
return|return
literal|1
return|;
name|request_init
argument_list|(
operator|&
name|req
argument_list|,
name|RQ_DAEMON
argument_list|,
literal|"rpcbind"
argument_list|,
name|RQ_CLIENT_SIN
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sock_methods
argument_list|(
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hosts_access
argument_list|(
operator|&
name|req
argument_list|)
condition|)
block|{
name|logit
argument_list|(
name|deny_severity
argument_list|,
name|addr
argument_list|,
name|proc
argument_list|,
name|prog
argument_list|,
literal|": request from unauthorized host"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|verboselog
condition|)
name|logit
argument_list|(
name|log_severity
argument_list|,
name|addr
argument_list|,
name|proc
argument_list|,
name|prog
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|is_loopback
parameter_list|(
name|struct
name|netbuf
modifier|*
name|nbuf
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|addr
init|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|nbuf
operator|->
name|buf
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|addr
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
operator|!
name|oldstyle_local
condition|)
return|return
literal|0
return|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
expr_stmt|;
return|return
operator|(
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|htonl
argument_list|(
name|INADDR_LOOPBACK
argument_list|)
operator|)
operator|&&
operator|(
name|ntohs
argument_list|(
name|sin
operator|->
name|sin_port
argument_list|)
operator|<
name|IPPORT_RESERVED
operator|)
operator|)
return|;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
operator|!
name|oldstyle_local
condition|)
return|return
literal|0
return|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
expr_stmt|;
return|return
operator|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|&&
operator|(
name|ntohs
argument_list|(
name|sin6
operator|->
name|sin6_port
argument_list|)
operator|<
name|IPV6PORT_RESERVED
operator|)
operator|)
return|;
endif|#
directive|endif
case|case
name|AF_LOCAL
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* logit - report events of interest via the syslog daemon */
end_comment

begin_function
name|void
name|logit
parameter_list|(
name|int
name|severity
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|rpcproc_t
name|procnum
parameter_list|,
name|rpcprog_t
name|prognum
parameter_list|,
specifier|const
name|char
modifier|*
name|text
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|procname
decl_stmt|;
name|char
name|procbuf
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|progname
decl_stmt|;
name|char
name|progbuf
index|[
literal|32
index|]
decl_stmt|;
name|char
name|fromname
index|[
name|NI_MAXHOST
index|]
decl_stmt|;
name|struct
name|rpcent
modifier|*
name|rpc
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|procmap
index|[]
init|=
block|{
comment|/* RPCBPROC_NULL */
literal|"null"
block|,
comment|/* RPCBPROC_SET */
literal|"set"
block|,
comment|/* RPCBPROC_UNSET */
literal|"unset"
block|,
comment|/* RPCBPROC_GETADDR */
literal|"getport/addr"
block|,
comment|/* RPCBPROC_DUMP */
literal|"dump"
block|,
comment|/* RPCBPROC_CALLIT */
literal|"callit"
block|,
comment|/* RPCBPROC_GETTIME */
literal|"gettime"
block|,
comment|/* RPCBPROC_UADDR2TADDR */
literal|"uaddr2taddr"
block|,
comment|/* RPCBPROC_TADDR2UADDR */
literal|"taddr2uaddr"
block|,
comment|/* RPCBPROC_GETVERSADDR */
literal|"getversaddr"
block|,
comment|/* RPCBPROC_INDIRECT */
literal|"indirect"
block|,
comment|/* RPCBPROC_GETADDRLIST */
literal|"getaddrlist"
block|,
comment|/* RPCBPROC_GETSTAT */
literal|"getstat"
block|}
decl_stmt|;
comment|/* 	 * Fork off a process or the portmap daemon might hang while 	 * getrpcbynumber() or syslog() does its thing. 	 */
if|if
condition|(
name|fork
argument_list|()
operator|==
literal|0
condition|)
block|{
name|setproctitle
argument_list|(
literal|"logit"
argument_list|)
expr_stmt|;
comment|/* Try to map program number to name. */
if|if
condition|(
name|prognum
operator|==
literal|0
condition|)
block|{
name|progname
operator|=
name|__UNCONST
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rpc
operator|=
name|getrpcbynumber
argument_list|(
operator|(
name|int
operator|)
name|prognum
argument_list|)
operator|)
condition|)
block|{
name|progname
operator|=
name|rpc
operator|->
name|r_name
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|progname
operator|=
name|progbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|progbuf
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|unsigned
operator|)
name|prognum
argument_list|)
expr_stmt|;
block|}
comment|/* Try to map procedure number to name. */
if|if
condition|(
name|procnum
operator|>=
operator|(
sizeof|sizeof
name|procmap
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|procbuf
argument_list|,
sizeof|sizeof
name|procbuf
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|unsigned
operator|)
name|procnum
argument_list|)
expr_stmt|;
name|procname
operator|=
name|procbuf
expr_stmt|;
block|}
else|else
name|procname
operator|=
name|procmap
index|[
name|procnum
index|]
expr_stmt|;
comment|/* Write syslog record. */
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_LOCAL
condition|)
name|strlcpy
argument_list|(
name|fromname
argument_list|,
literal|"local"
argument_list|,
sizeof|sizeof
argument_list|(
name|fromname
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|getnameinfo
argument_list|(
name|addr
argument_list|,
name|addr
operator|->
name|sa_len
argument_list|,
name|fromname
argument_list|,
sizeof|sizeof
name|fromname
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|severity
argument_list|,
literal|"connect from %s to %s(%s)%s"
argument_list|,
name|fromname
argument_list|,
name|procname
argument_list|,
name|progname
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|check_callit
parameter_list|(
name|SVCXPRT
modifier|*
name|xprt
parameter_list|,
name|struct
name|r_rmtcall_args
modifier|*
name|args
parameter_list|,
name|int
name|versnum
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|sa
init|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|svc_getrpccaller
argument_list|(
name|xprt
argument_list|)
operator|->
name|buf
decl_stmt|;
comment|/* 	 * Always allow calling NULLPROC 	 */
if|if
condition|(
name|args
operator|->
name|rmt_proc
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* 	 * XXX - this special casing sucks. 	 */
switch|switch
condition|(
name|args
operator|->
name|rmt_prog
condition|)
block|{
case|case
name|RPCBPROG
case|:
comment|/* 		 * Allow indirect calls to ourselves in insecure mode. 		 * The is_loopback checks aren't useful then anyway. 		 */
if|if
condition|(
operator|!
name|insecure
condition|)
goto|goto
name|deny
goto|;
break|break;
case|case
name|MOUNTPROG
case|:
if|if
condition|(
name|args
operator|->
name|rmt_proc
operator|!=
name|MOUNTPROC_MNT
operator|&&
name|args
operator|->
name|rmt_proc
operator|!=
name|MOUNTPROC_UMNT
condition|)
break|break;
goto|goto
name|deny
goto|;
case|case
name|YPBINDPROG
case|:
if|if
condition|(
name|args
operator|->
name|rmt_proc
operator|!=
name|YPBINDPROC_SETDOM
condition|)
break|break;
comment|/* FALLTHROUGH */
case|case
name|YPPASSWDPROG
case|:
case|case
name|NFS_PROGRAM
case|:
case|case
name|RQUOTAPROG
case|:
goto|goto
name|deny
goto|;
case|case
name|YPPROG
case|:
switch|switch
condition|(
name|args
operator|->
name|rmt_proc
condition|)
block|{
case|case
name|YPPROC_ALL
case|:
case|case
name|YPPROC_MATCH
case|:
case|case
name|YPPROC_FIRST
case|:
case|case
name|YPPROC_NEXT
case|:
goto|goto
name|deny
goto|;
default|default:
break|break;
block|}
default|default:
break|break;
block|}
return|return
literal|1
return|;
name|deny
label|:
name|logit
argument_list|(
name|deny_severity
argument_list|,
name|sa
argument_list|,
name|args
operator|->
name|rmt_proc
argument_list|,
name|args
operator|->
name|rmt_prog
argument_list|,
literal|": indirect call not allowed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

