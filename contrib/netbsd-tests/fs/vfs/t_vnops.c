begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: t_vnops.c,v 1.43 2014/09/09 06:51:00 gson Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 2010 The NetBSD Foundation, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/statvfs.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<atf-c.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<rump/rump_syscalls.h>
end_include

begin_include
include|#
directive|include
file|<rump/rump.h>
end_include

begin_include
include|#
directive|include
file|"../common/h_fsmacros.h"
end_include

begin_include
include|#
directive|include
file|"../../h_macros.h"
end_include

begin_define
define|#
directive|define
name|TESTFILE
value|"afile"
end_define

begin_define
define|#
directive|define
name|USES_DIRS
define|\
value|if (FSTYPE_SYSVBFS(tc))				\ 	atf_tc_skip("directories not supported by file system")
end_define

begin_define
define|#
directive|define
name|USES_SYMLINKS
define|\
value|if (FSTYPE_SYSVBFS(tc) || FSTYPE_MSDOS(tc))		\ 	atf_tc_skip("symlinks not supported by file system")
end_define

begin_function
specifier|static
name|char
modifier|*
name|md
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|tail
parameter_list|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|base
argument_list|,
name|tail
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lookup_simple
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mountpath
parameter_list|)
block|{
name|char
name|pb
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|final
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|stat
name|sb1
decl_stmt|,
name|sb2
decl_stmt|;
name|strcpy
argument_list|(
name|final
argument_list|,
name|mountpath
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pb
argument_list|,
literal|"%s/../%s"
argument_list|,
name|mountpath
argument_list|,
name|basename
argument_list|(
name|final
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_stat
argument_list|(
name|pb
argument_list|,
operator|&
name|sb1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"stat 1"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pb
argument_list|,
literal|"%s/./../%s"
argument_list|,
name|mountpath
argument_list|,
name|basename
argument_list|(
name|final
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_stat
argument_list|(
name|pb
argument_list|,
operator|&
name|sb2
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"stat 2"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|memcmp
argument_list|(
operator|&
name|sb1
argument_list|,
operator|&
name|sb2
argument_list|,
sizeof|sizeof
argument_list|(
name|sb1
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lookup_complex
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mountpath
parameter_list|)
block|{
name|char
name|pb
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|stat
name|sb1
decl_stmt|,
name|sb2
decl_stmt|;
name|USES_DIRS
expr_stmt|;
if|if
condition|(
name|FSTYPE_UDF
argument_list|(
name|tc
argument_list|)
condition|)
name|atf_tc_expect_fail
argument_list|(
literal|"PR kern/49033"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pb
argument_list|,
literal|"%s/dir"
argument_list|,
name|mountpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_mkdir
argument_list|(
name|pb
argument_list|,
literal|0777
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"mkdir"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_stat
argument_list|(
name|pb
argument_list|,
operator|&
name|sb1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"stat 1"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pb
argument_list|,
literal|"%s/./dir/../././dir/."
argument_list|,
name|mountpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_stat
argument_list|(
name|pb
argument_list|,
operator|&
name|sb2
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"stat 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|sb1
argument_list|,
operator|&
name|sb2
argument_list|,
sizeof|sizeof
argument_list|(
name|sb1
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"what\tsb1\t\tsb2\n"
argument_list|)
expr_stmt|;
define|#
directive|define
name|FIELD
parameter_list|(
name|FN
parameter_list|)
define|\
value|printf(#FN "\t%lld\t%lld\n", \ 		(long long)sb1.FN, (long long)sb2.FN)
define|#
directive|define
name|TIME
parameter_list|(
name|FN
parameter_list|)
define|\
value|printf(#FN "\t%lld.%ld\t%lld.%ld\n", \ 		(long long)sb1.FN.tv_sec, sb1.FN.tv_nsec, \ 		(long long)sb2.FN.tv_sec, sb2.FN.tv_nsec)
name|FIELD
argument_list|(
name|st_dev
argument_list|)
expr_stmt|;
name|FIELD
argument_list|(
name|st_mode
argument_list|)
expr_stmt|;
name|FIELD
argument_list|(
name|st_ino
argument_list|)
expr_stmt|;
name|FIELD
argument_list|(
name|st_nlink
argument_list|)
expr_stmt|;
name|FIELD
argument_list|(
name|st_uid
argument_list|)
expr_stmt|;
name|FIELD
argument_list|(
name|st_gid
argument_list|)
expr_stmt|;
name|FIELD
argument_list|(
name|st_rdev
argument_list|)
expr_stmt|;
name|TIME
argument_list|(
name|st_atim
argument_list|)
expr_stmt|;
name|TIME
argument_list|(
name|st_mtim
argument_list|)
expr_stmt|;
name|TIME
argument_list|(
name|st_ctim
argument_list|)
expr_stmt|;
name|TIME
argument_list|(
name|st_birthtim
argument_list|)
expr_stmt|;
name|FIELD
argument_list|(
name|st_size
argument_list|)
expr_stmt|;
name|FIELD
argument_list|(
name|st_blocks
argument_list|)
expr_stmt|;
name|FIELD
argument_list|(
name|st_flags
argument_list|)
expr_stmt|;
name|FIELD
argument_list|(
name|st_gen
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|FIELD
undef|#
directive|undef
name|TIME
name|atf_tc_fail
argument_list|(
literal|"stat results differ, see ouput for more details"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FSTYPE_UDF
argument_list|(
name|tc
argument_list|)
condition|)
name|atf_tc_fail
argument_list|(
literal|"random failure of PR kern/49033 "
literal|"did not happen this time"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dir_simple
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mountpath
parameter_list|)
block|{
name|char
name|pb
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|USES_DIRS
expr_stmt|;
comment|/* check we can create directories */
name|sprintf
argument_list|(
name|pb
argument_list|,
literal|"%s/dir"
argument_list|,
name|mountpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_mkdir
argument_list|(
name|pb
argument_list|,
literal|0777
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"mkdir"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_stat
argument_list|(
name|pb
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"stat new directory"
argument_list|)
expr_stmt|;
comment|/* check we can remove then and that it makes them unreachable */
if|if
condition|(
name|rump_sys_rmdir
argument_list|(
name|pb
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"rmdir"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_stat
argument_list|(
name|pb
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|ENOENT
condition|)
name|atf_tc_fail
argument_list|(
literal|"ENOENT expected from stat"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dir_notempty
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mountpath
parameter_list|)
block|{
name|char
name|pb
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|pb2
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|rv
decl_stmt|;
name|USES_DIRS
expr_stmt|;
comment|/* check we can create directories */
name|sprintf
argument_list|(
name|pb
argument_list|,
literal|"%s/dir"
argument_list|,
name|mountpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_mkdir
argument_list|(
name|pb
argument_list|,
literal|0777
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"mkdir"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pb2
argument_list|,
literal|"%s/dir/file"
argument_list|,
name|mountpath
argument_list|)
expr_stmt|;
name|fd
operator|=
name|rump_sys_open
argument_list|(
name|pb2
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"create file"
argument_list|)
expr_stmt|;
name|rump_sys_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|rv
operator|=
name|rump_sys_rmdir
argument_list|(
name|pb
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSTYPE_ZFS
argument_list|(
name|tc
argument_list|)
condition|)
name|atf_tc_expect_fail
argument_list|(
literal|"PR kern/47656: Test known to be broken"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|ENOTEMPTY
condition|)
name|atf_tc_fail
argument_list|(
literal|"non-empty directory removed succesfully"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_unlink
argument_list|(
name|pb2
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"cannot remove dir/file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_rmdir
argument_list|(
name|pb
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"remove directory"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dir_rmdirdotdot
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mp
parameter_list|)
block|{
name|char
name|pb
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|xerrno
decl_stmt|;
name|USES_DIRS
expr_stmt|;
name|FSTEST_ENTER
argument_list|()
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_mkdir
argument_list|(
literal|"test"
argument_list|,
literal|0777
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_chdir
argument_list|(
literal|"test"
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_mkdir
argument_list|(
literal|"subtest"
argument_list|,
literal|0777
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_chdir
argument_list|(
literal|"subtest"
argument_list|)
argument_list|)
expr_stmt|;
name|md
argument_list|(
name|pb
argument_list|,
name|mp
argument_list|,
literal|"test/subtest"
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_rmdir
argument_list|(
name|pb
argument_list|)
argument_list|)
expr_stmt|;
name|md
argument_list|(
name|pb
argument_list|,
name|mp
argument_list|,
literal|"test"
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_rmdir
argument_list|(
name|pb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSTYPE_NFS
argument_list|(
name|tc
argument_list|)
condition|)
name|xerrno
operator|=
name|ESTALE
expr_stmt|;
else|else
name|xerrno
operator|=
name|ENOENT
expr_stmt|;
name|ATF_REQUIRE_ERRNO
argument_list|(
name|xerrno
argument_list|,
name|rump_sys_chdir
argument_list|(
literal|".."
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|FSTEST_EXIT
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|checkfile
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|stat
modifier|*
name|refp
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
specifier|static
name|int
name|n
init|=
literal|1
decl_stmt|;
name|md
argument_list|(
name|buf
argument_list|,
name|path
argument_list|,
literal|"file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_stat
argument_list|(
name|buf
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"cannot stat file %d (%s)"
argument_list|,
name|n
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|sb
argument_list|,
name|refp
argument_list|,
sizeof|sizeof
argument_list|(
name|sb
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|atf_tc_fail
argument_list|(
literal|"stat mismatch %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rename_dir
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mp
parameter_list|)
block|{
name|char
name|pb1
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|pb2
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|pb3
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|stat
name|ref
decl_stmt|,
name|sb
decl_stmt|;
if|if
condition|(
name|FSTYPE_RUMPFS
argument_list|(
name|tc
argument_list|)
condition|)
name|atf_tc_skip
argument_list|(
literal|"rename not supported by file system"
argument_list|)
expr_stmt|;
name|USES_DIRS
expr_stmt|;
name|md
argument_list|(
name|pb1
argument_list|,
name|mp
argument_list|,
literal|"dir1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_mkdir
argument_list|(
name|pb1
argument_list|,
literal|0777
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"mkdir 1"
argument_list|)
expr_stmt|;
name|md
argument_list|(
name|pb2
argument_list|,
name|mp
argument_list|,
literal|"dir2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_mkdir
argument_list|(
name|pb2
argument_list|,
literal|0777
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"mkdir 2"
argument_list|)
expr_stmt|;
name|md
argument_list|(
name|pb2
argument_list|,
name|mp
argument_list|,
literal|"dir2/subdir"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_mkdir
argument_list|(
name|pb2
argument_list|,
literal|0777
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"mkdir 3"
argument_list|)
expr_stmt|;
name|md
argument_list|(
name|pb3
argument_list|,
name|mp
argument_list|,
literal|"dir1/file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_mknod
argument_list|(
name|pb3
argument_list|,
name|S_IFREG
operator||
literal|0777
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"create file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_stat
argument_list|(
name|pb3
argument_list|,
operator|&
name|ref
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"stat of file"
argument_list|)
expr_stmt|;
comment|/* 	 * First try ops which should succeed. 	 */
comment|/* rename within directory */
name|md
argument_list|(
name|pb3
argument_list|,
name|mp
argument_list|,
literal|"dir3"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_rename
argument_list|(
name|pb1
argument_list|,
name|pb3
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"rename 1"
argument_list|)
expr_stmt|;
name|checkfile
argument_list|(
name|pb3
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
comment|/* rename directory onto itself (two ways, should fail) */
name|md
argument_list|(
name|pb1
argument_list|,
name|mp
argument_list|,
literal|"dir3/."
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_rename
argument_list|(
name|pb1
argument_list|,
name|pb3
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|EINVAL
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"rename 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSTYPE_ZFS
argument_list|(
name|tc
argument_list|)
condition|)
name|atf_tc_expect_fail
argument_list|(
literal|"PR kern/47656: Test known to be broken"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_rename
argument_list|(
name|pb3
argument_list|,
name|pb1
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|EISDIR
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"rename 3"
argument_list|)
expr_stmt|;
name|checkfile
argument_list|(
name|pb3
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
comment|/* rename father of directory into directory */
name|md
argument_list|(
name|pb1
argument_list|,
name|mp
argument_list|,
literal|"dir2/dir"
argument_list|)
expr_stmt|;
name|md
argument_list|(
name|pb2
argument_list|,
name|mp
argument_list|,
literal|"dir2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_rename
argument_list|(
name|pb2
argument_list|,
name|pb1
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|EINVAL
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"rename 4"
argument_list|)
expr_stmt|;
comment|/* same for grandfather */
name|md
argument_list|(
name|pb1
argument_list|,
name|mp
argument_list|,
literal|"dir2/subdir/dir2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_rename
argument_list|(
name|pb2
argument_list|,
name|pb1
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|EINVAL
condition|)
name|atf_tc_fail
argument_list|(
literal|"rename 5"
argument_list|)
expr_stmt|;
name|checkfile
argument_list|(
name|pb3
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
comment|/* rename directory over a non-empty directory */
if|if
condition|(
name|rump_sys_rename
argument_list|(
name|pb2
argument_list|,
name|pb3
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|ENOTEMPTY
condition|)
name|atf_tc_fail
argument_list|(
literal|"rename 6"
argument_list|)
expr_stmt|;
comment|/* cross-directory rename */
name|md
argument_list|(
name|pb1
argument_list|,
name|mp
argument_list|,
literal|"dir3"
argument_list|)
expr_stmt|;
name|md
argument_list|(
name|pb2
argument_list|,
name|mp
argument_list|,
literal|"dir2/somedir"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_rename
argument_list|(
name|pb1
argument_list|,
name|pb2
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"rename 7"
argument_list|)
expr_stmt|;
name|checkfile
argument_list|(
name|pb2
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
comment|/* move to parent directory */
name|md
argument_list|(
name|pb1
argument_list|,
name|mp
argument_list|,
literal|"dir2/somedir/../../dir3"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_rename
argument_list|(
name|pb2
argument_list|,
name|pb1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"rename 8"
argument_list|)
expr_stmt|;
name|md
argument_list|(
name|pb1
argument_list|,
name|mp
argument_list|,
literal|"dir2/../dir3"
argument_list|)
expr_stmt|;
name|checkfile
argument_list|(
name|pb1
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
comment|/* atomic cross-directory rename */
name|md
argument_list|(
name|pb3
argument_list|,
name|mp
argument_list|,
literal|"dir2/subdir"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_rename
argument_list|(
name|pb1
argument_list|,
name|pb3
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"rename 9"
argument_list|)
expr_stmt|;
name|checkfile
argument_list|(
name|pb3
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
comment|/* rename directory over an empty directory */
name|md
argument_list|(
name|pb1
argument_list|,
name|mp
argument_list|,
literal|"parent"
argument_list|)
expr_stmt|;
name|md
argument_list|(
name|pb2
argument_list|,
name|mp
argument_list|,
literal|"parent/dir1"
argument_list|)
expr_stmt|;
name|md
argument_list|(
name|pb3
argument_list|,
name|mp
argument_list|,
literal|"parent/dir2"
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_mkdir
argument_list|(
name|pb1
argument_list|,
literal|0777
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_mkdir
argument_list|(
name|pb2
argument_list|,
literal|0777
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_mkdir
argument_list|(
name|pb3
argument_list|,
literal|0777
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_rename
argument_list|(
name|pb2
argument_list|,
name|pb3
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_stat
argument_list|(
name|pb1
argument_list|,
operator|&
name|sb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FSTYPE_MSDOS
argument_list|(
name|tc
argument_list|)
condition|)
name|ATF_CHECK_EQ
argument_list|(
name|sb
operator|.
name|st_nlink
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_rmdir
argument_list|(
name|pb3
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_rmdir
argument_list|(
name|pb1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rename_dotdot
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mp
parameter_list|)
block|{
if|if
condition|(
name|FSTYPE_RUMPFS
argument_list|(
name|tc
argument_list|)
condition|)
name|atf_tc_skip
argument_list|(
literal|"rename not supported by file system"
argument_list|)
expr_stmt|;
name|USES_DIRS
expr_stmt|;
if|if
condition|(
name|rump_sys_chdir
argument_list|(
name|mp
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"chdir mountpoint"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_mkdir
argument_list|(
literal|"dir1"
argument_list|,
literal|0777
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"mkdir 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_mkdir
argument_list|(
literal|"dir2"
argument_list|,
literal|0777
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"mkdir 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_rename
argument_list|(
literal|"dir1"
argument_list|,
literal|"dir1/.."
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|EINVAL
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"self-dotdot to"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_rename
argument_list|(
literal|"dir1/.."
argument_list|,
literal|"sometarget"
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|EINVAL
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"self-dotdot from"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_rename
argument_list|(
literal|"dir1"
argument_list|,
literal|"dir2/.."
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|EINVAL
condition|)
name|atf_tc_fail
argument_list|(
literal|"other-dotdot"
argument_list|)
expr_stmt|;
name|rump_sys_chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rename_reg_nodir
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mp
parameter_list|)
block|{
name|bool
name|haslinks
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|ino_t
name|f1ino
decl_stmt|;
if|if
condition|(
name|FSTYPE_RUMPFS
argument_list|(
name|tc
argument_list|)
condition|)
name|atf_tc_skip
argument_list|(
literal|"rename not supported by file system"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_chdir
argument_list|(
name|mp
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"chdir mountpoint"
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSTYPE_MSDOS
argument_list|(
name|tc
argument_list|)
operator|||
name|FSTYPE_SYSVBFS
argument_list|(
name|tc
argument_list|)
condition|)
name|haslinks
operator|=
name|false
expr_stmt|;
else|else
name|haslinks
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|rump_sys_mknod
argument_list|(
literal|"file1"
argument_list|,
name|S_IFREG
operator||
literal|0777
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"create file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_mknod
argument_list|(
literal|"file2"
argument_list|,
name|S_IFREG
operator||
literal|0777
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"create file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_stat
argument_list|(
literal|"file1"
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"stat"
argument_list|)
expr_stmt|;
name|f1ino
operator|=
name|sb
operator|.
name|st_ino
expr_stmt|;
if|if
condition|(
name|haslinks
condition|)
block|{
if|if
condition|(
name|rump_sys_link
argument_list|(
literal|"file1"
argument_list|,
literal|"file_link"
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"link"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_stat
argument_list|(
literal|"file_link"
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"stat"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|sb
operator|.
name|st_ino
argument_list|,
name|f1ino
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|sb
operator|.
name|st_nlink
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rump_sys_stat
argument_list|(
literal|"file2"
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"stat"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_rename
argument_list|(
literal|"file1"
argument_list|,
literal|"file3"
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"rename 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_stat
argument_list|(
literal|"file3"
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"stat 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|haslinks
condition|)
block|{
name|ATF_REQUIRE_EQ
argument_list|(
name|sb
operator|.
name|st_ino
argument_list|,
name|f1ino
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rump_sys_stat
argument_list|(
literal|"file1"
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|ENOENT
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"source 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_rename
argument_list|(
literal|"file3"
argument_list|,
literal|"file2"
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"rename 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_stat
argument_list|(
literal|"file2"
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"stat 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|haslinks
condition|)
block|{
name|ATF_REQUIRE_EQ
argument_list|(
name|sb
operator|.
name|st_ino
argument_list|,
name|f1ino
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rump_sys_stat
argument_list|(
literal|"file3"
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|ENOENT
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"source 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|haslinks
condition|)
block|{
if|if
condition|(
name|rump_sys_rename
argument_list|(
literal|"file2"
argument_list|,
literal|"file_link"
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"rename hardlink"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_stat
argument_list|(
literal|"file2"
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|ENOENT
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"source 3"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_stat
argument_list|(
literal|"file_link"
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"stat 2"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|sb
operator|.
name|st_ino
argument_list|,
name|f1ino
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|sb
operator|.
name|st_nlink
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ATF_CHECK_ERRNO
argument_list|(
name|EFAULT
argument_list|,
name|rump_sys_rename
argument_list|(
literal|"file2"
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK_ERRNO
argument_list|(
name|EFAULT
argument_list|,
name|rump_sys_rename
argument_list|(
name|NULL
argument_list|,
literal|"file2"
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rump_sys_chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_nametoolong
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mp
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|long
name|val
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|rump_sys_chdir
argument_list|(
name|mp
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"chdir mountpoint"
argument_list|)
expr_stmt|;
name|val
operator|=
name|rump_sys_pathconf
argument_list|(
literal|"."
argument_list|,
name|_PC_NAME_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"pathconf"
argument_list|)
expr_stmt|;
name|len
operator|=
name|val
operator|+
literal|1
expr_stmt|;
name|name
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|name
argument_list|,
literal|'a'
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|name
operator|+
name|len
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|val
operator|=
name|rump_sys_pathconf
argument_list|(
literal|"."
argument_list|,
name|_PC_NO_TRUNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"pathconf"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|rump_sys_open
argument_list|(
name|name
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
operator|&&
operator|(
name|fd
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|ENAMETOOLONG
operator|)
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"open"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
operator|&&
name|rump_sys_close
argument_list|(
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
operator|&&
name|rump_sys_unlink
argument_list|(
name|name
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"unlink"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|rump_sys_chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_exist
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
literal|"hoge"
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|RL
argument_list|(
name|rump_sys_chdir
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|fd
operator|=
name|rump_sys_open
argument_list|(
name|name
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0666
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_close
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_unlink
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|fd
operator|=
name|rump_sys_open
argument_list|(
name|name
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_close
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|fd
operator|=
name|rump_sys_open
argument_list|(
name|name
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_close
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_ERRNO
argument_list|(
name|EEXIST
argument_list|,
operator|(
name|fd
operator|=
name|rump_sys_open
argument_list|(
name|name
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0666
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_unlink
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_chdir
argument_list|(
literal|"/"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rename_nametoolong
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mp
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|res
decl_stmt|,
name|fd
decl_stmt|;
name|long
name|val
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|FSTYPE_RUMPFS
argument_list|(
name|tc
argument_list|)
condition|)
name|atf_tc_skip
argument_list|(
literal|"rename not supported by file system"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_chdir
argument_list|(
name|mp
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"chdir mountpoint"
argument_list|)
expr_stmt|;
name|val
operator|=
name|rump_sys_pathconf
argument_list|(
literal|"."
argument_list|,
name|_PC_NAME_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"pathconf"
argument_list|)
expr_stmt|;
name|len
operator|=
name|val
operator|+
literal|1
expr_stmt|;
name|name
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|name
argument_list|,
literal|'a'
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|name
operator|+
name|len
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|fd
operator|=
name|rump_sys_open
argument_list|(
literal|"dummy"
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"open"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_close
argument_list|(
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
name|val
operator|=
name|rump_sys_pathconf
argument_list|(
literal|"."
argument_list|,
name|_PC_NO_TRUNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"pathconf"
argument_list|)
expr_stmt|;
name|res
operator|=
name|rump_sys_rename
argument_list|(
literal|"dummy"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
operator|&&
operator|(
name|res
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|ENAMETOOLONG
operator|)
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"rename"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
operator|&&
name|rump_sys_unlink
argument_list|(
name|name
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|atf_tc_fail_errno
argument_list|(
literal|"unlink"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|rump_sys_chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Test creating a symlink whose length is "len" bytes, not including  * the terminating NUL.  */
end_comment

begin_function
specifier|static
name|void
name|symlink_len
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mp
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|r
decl_stmt|;
name|USES_SYMLINKS
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_chdir
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|'a'
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|=
name|rump_sys_symlink
argument_list|(
name|buf
argument_list|,
literal|"afile"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
name|ATF_REQUIRE_ERRNO
argument_list|(
name|ENAMETOOLONG
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RL
argument_list|(
name|rump_sys_unlink
argument_list|(
literal|"afile"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_chdir
argument_list|(
literal|"/"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|symlink_zerolen
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mp
parameter_list|)
block|{
name|symlink_len
argument_list|(
name|tc
argument_list|,
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|symlink_long
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mp
parameter_list|)
block|{
comment|/* 	 * Test lengths close to powers of two, as those are likely 	 * to be edge cases. 	 */
name|size_t
name|len
decl_stmt|;
name|int
name|fuzz
decl_stmt|;
for|for
control|(
name|len
operator|=
literal|2
init|;
name|len
operator|<=
literal|65536
condition|;
name|len
operator|*=
literal|2
control|)
block|{
for|for
control|(
name|fuzz
operator|=
operator|-
literal|1
init|;
name|fuzz
operator|<=
literal|1
condition|;
name|fuzz
operator|++
control|)
block|{
name|symlink_len
argument_list|(
name|tc
argument_list|,
name|mp
argument_list|,
name|len
operator|+
name|fuzz
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|symlink_root
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mp
parameter_list|)
block|{
name|USES_SYMLINKS
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_chdir
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_symlink
argument_list|(
literal|"/"
argument_list|,
literal|"foo"
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_chdir
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|attrs
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|,
name|sb2
decl_stmt|;
name|struct
name|timeval
name|tv
index|[
literal|2
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|FSTEST_ENTER
argument_list|()
expr_stmt|;
name|RL
argument_list|(
name|fd
operator|=
name|rump_sys_open
argument_list|(
name|TESTFILE
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0755
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_close
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_stat
argument_list|(
name|TESTFILE
argument_list|,
operator|&
name|sb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|FSTYPE_MSDOS
argument_list|(
name|tc
argument_list|)
operator|||
name|FSTYPE_SYSVBFS
argument_list|(
name|tc
argument_list|)
operator|)
condition|)
block|{
name|RL
argument_list|(
name|rump_sys_chown
argument_list|(
name|TESTFILE
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|st_uid
operator|=
literal|1
expr_stmt|;
name|sb
operator|.
name|st_gid
operator|=
literal|2
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_chmod
argument_list|(
name|TESTFILE
argument_list|,
literal|0123
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|st_mode
operator|=
operator|(
name|sb
operator|.
name|st_mode
operator|&
operator|~
name|ACCESSPERMS
operator|)
operator||
literal|0123
expr_stmt|;
block|}
name|tv
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
literal|1000000000
expr_stmt|;
comment|/* need something>1980 for msdosfs */
name|tv
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
literal|1
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
literal|1000000002
expr_stmt|;
comment|/* need even seconds for msdosfs */
name|tv
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|3
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_utimes
argument_list|(
name|TESTFILE
argument_list|,
name|tv
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_utimes
argument_list|(
name|TESTFILE
argument_list|,
name|tv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX: utimes& birthtime */
name|sb
operator|.
name|st_atimespec
operator|.
name|tv_sec
operator|=
literal|1000000000
expr_stmt|;
name|sb
operator|.
name|st_atimespec
operator|.
name|tv_nsec
operator|=
literal|1000
expr_stmt|;
name|sb
operator|.
name|st_mtimespec
operator|.
name|tv_sec
operator|=
literal|1000000002
expr_stmt|;
name|sb
operator|.
name|st_mtimespec
operator|.
name|tv_nsec
operator|=
literal|3000
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_stat
argument_list|(
name|TESTFILE
argument_list|,
operator|&
name|sb2
argument_list|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|CHECK
parameter_list|(
name|a
parameter_list|)
value|ATF_REQUIRE_EQ(sb.a, sb2.a)
if|if
condition|(
name|FSTYPE_ZFS
argument_list|(
name|tc
argument_list|)
condition|)
name|atf_tc_expect_fail
argument_list|(
literal|"PR kern/47656: Test known to be broken"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|FSTYPE_MSDOS
argument_list|(
name|tc
argument_list|)
operator|||
name|FSTYPE_SYSVBFS
argument_list|(
name|tc
argument_list|)
operator|)
condition|)
block|{
name|CHECK
argument_list|(
name|st_uid
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|st_gid
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|st_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|FSTYPE_MSDOS
argument_list|(
name|tc
argument_list|)
condition|)
block|{
comment|/* msdosfs has only access date, not time */
name|CHECK
argument_list|(
name|st_atimespec
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
block|}
name|CHECK
argument_list|(
name|st_mtimespec
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|FSTYPE_EXT2FS
argument_list|(
name|tc
argument_list|)
operator|||
name|FSTYPE_MSDOS
argument_list|(
name|tc
argument_list|)
operator|||
name|FSTYPE_SYSVBFS
argument_list|(
name|tc
argument_list|)
operator|||
name|FSTYPE_V7FS
argument_list|(
name|tc
argument_list|)
operator|)
condition|)
block|{
name|CHECK
argument_list|(
name|st_atimespec
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|st_mtimespec
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|CHECK
name|FSTEST_EXIT
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fcntl_lock
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|fd2
decl_stmt|;
name|struct
name|flock
name|l
decl_stmt|;
name|struct
name|lwp
modifier|*
name|lwp1
decl_stmt|,
modifier|*
name|lwp2
decl_stmt|;
name|FSTEST_ENTER
argument_list|()
expr_stmt|;
name|l
operator|.
name|l_pid
operator|=
literal|0
expr_stmt|;
name|l
operator|.
name|l_start
operator|=
name|l
operator|.
name|l_len
operator|=
literal|1024
expr_stmt|;
name|l
operator|.
name|l_type
operator|=
name|F_RDLCK
operator||
name|F_WRLCK
expr_stmt|;
name|l
operator|.
name|l_whence
operator|=
name|SEEK_END
expr_stmt|;
name|lwp1
operator|=
name|rump_pub_lwproc_curlwp
argument_list|()
expr_stmt|;
name|RL
argument_list|(
name|fd
operator|=
name|rump_sys_open
argument_list|(
name|TESTFILE
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0755
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_ftruncate
argument_list|(
name|fd
argument_list|,
literal|8192
argument_list|)
argument_list|)
expr_stmt|;
comment|/* PR kern/43321 */
if|if
condition|(
name|FSTYPE_ZFS
argument_list|(
name|tc
argument_list|)
condition|)
name|atf_tc_expect_fail
argument_list|(
literal|"PR kern/47656: Test known to be broken"
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETLK
argument_list|,
operator|&
name|l
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Next, we fork and try to lock the same area */
name|RZ
argument_list|(
name|rump_pub_lwproc_rfork
argument_list|(
name|RUMP_RFCFDG
argument_list|)
argument_list|)
expr_stmt|;
name|lwp2
operator|=
name|rump_pub_lwproc_curlwp
argument_list|()
expr_stmt|;
name|RL
argument_list|(
name|fd2
operator|=
name|rump_sys_open
argument_list|(
name|TESTFILE
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_ERRNO
argument_list|(
name|EAGAIN
argument_list|,
name|rump_sys_fcntl
argument_list|(
name|fd2
argument_list|,
name|F_SETLK
argument_list|,
operator|&
name|l
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Switch back and unlock... */
name|rump_pub_lwproc_switch
argument_list|(
name|lwp1
argument_list|)
expr_stmt|;
name|l
operator|.
name|l_type
operator|=
name|F_UNLCK
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETLK
argument_list|,
operator|&
name|l
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... and try to lock again */
name|rump_pub_lwproc_switch
argument_list|(
name|lwp2
argument_list|)
expr_stmt|;
name|l
operator|.
name|l_type
operator|=
name|F_RDLCK
operator||
name|F_WRLCK
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_fcntl
argument_list|(
name|fd2
argument_list|,
name|F_SETLK
argument_list|,
operator|&
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_close
argument_list|(
name|fd2
argument_list|)
argument_list|)
expr_stmt|;
name|rump_pub_lwproc_releaselwp
argument_list|()
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_close
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
name|FSTEST_EXIT
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|flock_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|q
parameter_list|)
block|{
name|int
name|a
init|=
operator|(
operator|(
specifier|const
expr|struct
name|flock
operator|*
operator|)
name|p
operator|)
operator|->
name|l_start
decl_stmt|;
name|int
name|b
init|=
operator|(
operator|(
specifier|const
expr|struct
name|flock
operator|*
operator|)
name|q
operator|)
operator|->
name|l_start
decl_stmt|;
return|return
name|a
operator|<
name|b
condition|?
operator|-
literal|1
else|:
operator|(
name|a
operator|>
name|b
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find all locks set by fcntl_getlock_pids test  * using GETLK for a range [start, start+end], and,  * if there is a blocking lock, recursively find  * all locks to the left (toward the beginning of  * a file) and to the right of the lock.  * The function also understands "until end of file"  * convention when len==0.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|fcntl_getlocks
parameter_list|(
name|int
name|fildes
parameter_list|,
name|off_t
name|start
parameter_list|,
name|off_t
name|len
parameter_list|,
name|struct
name|flock
modifier|*
name|lock
parameter_list|,
name|struct
name|flock
modifier|*
name|end
parameter_list|)
block|{
name|unsigned
name|int
name|rv
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|flock
name|l
init|=
block|{
name|start
block|,
name|len
block|,
literal|0
block|,
name|F_RDLCK
block|,
name|SEEK_SET
block|}
decl_stmt|;
if|if
condition|(
name|lock
operator|==
name|end
condition|)
return|return
name|rv
return|;
name|RL
argument_list|(
name|rump_sys_fcntl
argument_list|(
name|fildes
argument_list|,
name|F_GETLK
argument_list|,
operator|&
name|l
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|.
name|l_type
operator|==
name|F_UNLCK
condition|)
return|return
name|rv
return|;
operator|*
name|lock
operator|++
operator|=
name|l
expr_stmt|;
name|rv
operator|+=
literal|1
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|l
operator|.
name|l_whence
operator|==
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|.
name|l_start
operator|>
name|start
condition|)
block|{
name|unsigned
name|int
name|n
init|=
name|fcntl_getlocks
argument_list|(
name|fildes
argument_list|,
name|start
argument_list|,
name|l
operator|.
name|l_start
operator|-
name|start
argument_list|,
name|lock
argument_list|,
name|end
argument_list|)
decl_stmt|;
name|rv
operator|+=
name|n
expr_stmt|;
name|lock
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|lock
operator|==
name|end
condition|)
return|return
name|rv
return|;
block|}
if|if
condition|(
name|l
operator|.
name|l_len
operator|==
literal|0
condition|)
comment|/* does l spans until the end? */
return|return
name|rv
return|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
comment|/* are we looking for locks until the end? */
block|{
name|rv
operator|+=
name|fcntl_getlocks
argument_list|(
name|fildes
argument_list|,
name|l
operator|.
name|l_start
operator|+
name|l
operator|.
name|l_len
argument_list|,
name|len
argument_list|,
name|lock
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|.
name|l_start
operator|+
name|l
operator|.
name|l_len
operator|<
name|start
operator|+
name|len
condition|)
block|{
name|len
operator|-=
name|l
operator|.
name|l_start
operator|+
name|l
operator|.
name|l_len
operator|-
name|start
expr_stmt|;
name|rv
operator|+=
name|fcntl_getlocks
argument_list|(
name|fildes
argument_list|,
name|l
operator|.
name|l_start
operator|+
name|l
operator|.
name|l_len
argument_list|,
name|len
argument_list|,
name|lock
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fcntl_getlock_pids
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mp
parameter_list|)
block|{
comment|/* test non-overlaping ranges */
name|struct
name|flock
name|expect
index|[
literal|4
index|]
decl_stmt|;
specifier|const
name|struct
name|flock
name|lock
index|[
literal|4
index|]
init|=
block|{
block|{
literal|0
block|,
literal|2
block|,
literal|0
block|,
name|F_WRLCK
block|,
name|SEEK_SET
block|}
block|,
block|{
literal|2
block|,
literal|1
block|,
literal|0
block|,
name|F_WRLCK
block|,
name|SEEK_SET
block|}
block|,
block|{
literal|7
block|,
literal|5
block|,
literal|0
block|,
name|F_WRLCK
block|,
name|SEEK_SET
block|}
block|,
block|{
literal|4
block|,
literal|3
block|,
literal|0
block|,
name|F_WRLCK
block|,
name|SEEK_SET
block|}
block|, 	}
decl_stmt|;
comment|/* Add extra element to make sure recursion does't stop at array end */
name|struct
name|flock
name|result
index|[
literal|5
index|]
decl_stmt|;
comment|/* Add 5th process */
name|int
name|fd
index|[
literal|5
index|]
decl_stmt|;
name|pid_t
name|pid
index|[
literal|5
index|]
decl_stmt|;
name|struct
name|lwp
modifier|*
name|lwp
index|[
literal|5
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|off_t
name|sz
init|=
literal|8192
decl_stmt|;
name|int
name|omode
init|=
literal|0755
decl_stmt|;
name|int
name|oflags
init|=
name|O_RDWR
operator||
name|O_CREAT
decl_stmt|;
name|memcpy
argument_list|(
name|expect
argument_list|,
name|lock
argument_list|,
sizeof|sizeof
argument_list|(
name|lock
argument_list|)
argument_list|)
expr_stmt|;
name|FSTEST_ENTER
argument_list|()
expr_stmt|;
comment|/* 	 * First, we create 4 processes and let each lock a range of the 	 * file.  Note that the third and fourth processes lock in 	 * "reverse" order, i.e. the greater pid locks a range before 	 * the lesser pid. 	 * Then, we create 5th process which doesn't lock anything. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|__arraycount
argument_list|(
name|lwp
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|RZ
argument_list|(
name|rump_pub_lwproc_rfork
argument_list|(
name|RUMP_RFCFDG
argument_list|)
argument_list|)
expr_stmt|;
name|lwp
index|[
name|i
index|]
operator|=
name|rump_pub_lwproc_curlwp
argument_list|()
expr_stmt|;
name|pid
index|[
name|i
index|]
operator|=
name|rump_sys_getpid
argument_list|()
expr_stmt|;
name|RL
argument_list|(
name|fd
index|[
name|i
index|]
operator|=
name|rump_sys_open
argument_list|(
name|TESTFILE
argument_list|,
name|oflags
argument_list|,
name|omode
argument_list|)
argument_list|)
expr_stmt|;
name|oflags
operator|=
name|O_RDWR
expr_stmt|;
name|omode
operator|=
literal|0
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_ftruncate
argument_list|(
name|fd
index|[
name|i
index|]
argument_list|,
name|sz
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSTYPE_ZFS
argument_list|(
name|tc
argument_list|)
condition|)
name|atf_tc_expect_fail
argument_list|(
literal|"PR kern/47656: Test known to be "
literal|"broken"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|__arraycount
argument_list|(
name|lock
argument_list|)
condition|)
block|{
name|RL
argument_list|(
name|rump_sys_fcntl
argument_list|(
name|fd
index|[
name|i
index|]
argument_list|,
name|F_SETLK
argument_list|,
operator|&
name|lock
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|expect
index|[
name|i
index|]
operator|.
name|l_pid
operator|=
name|pid
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|qsort
argument_list|(
name|expect
argument_list|,
name|__arraycount
argument_list|(
name|expect
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|expect
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|&
name|flock_compare
argument_list|)
expr_stmt|;
comment|/* 	 * In the context of each process, recursively find all locks 	 * that would block the current process. Processes 1-4 don't 	 * see their own lock, we insert it to simplify checks. 	 * Process 5 sees all 4 locks. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|__arraycount
argument_list|(
name|lwp
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|nlocks
decl_stmt|;
name|rump_pub_lwproc_switch
argument_list|(
name|lwp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|nlocks
operator|=
name|fcntl_getlocks
argument_list|(
name|fd
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|,
name|result
argument_list|,
name|result
operator|+
name|__arraycount
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|__arraycount
argument_list|(
name|lock
argument_list|)
condition|)
block|{
name|ATF_REQUIRE
argument_list|(
name|nlocks
operator|<
name|__arraycount
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|result
index|[
name|nlocks
index|]
operator|=
name|lock
index|[
name|i
index|]
expr_stmt|;
name|result
index|[
name|nlocks
index|]
operator|.
name|l_pid
operator|=
name|pid
index|[
name|i
index|]
expr_stmt|;
name|nlocks
operator|++
expr_stmt|;
block|}
name|ATF_CHECK_EQ
argument_list|(
name|nlocks
argument_list|,
name|__arraycount
argument_list|(
name|expect
argument_list|)
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|result
argument_list|,
name|nlocks
argument_list|,
sizeof|sizeof
argument_list|(
name|result
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|&
name|flock_compare
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nlocks
condition|;
name|j
operator|++
control|)
block|{
name|ATF_CHECK_EQ
argument_list|(
name|result
index|[
name|j
index|]
operator|.
name|l_start
argument_list|,
name|expect
index|[
name|j
index|]
operator|.
name|l_start
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|result
index|[
name|j
index|]
operator|.
name|l_len
argument_list|,
name|expect
index|[
name|j
index|]
operator|.
name|l_len
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|result
index|[
name|j
index|]
operator|.
name|l_pid
argument_list|,
name|expect
index|[
name|j
index|]
operator|.
name|l_pid
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|result
index|[
name|j
index|]
operator|.
name|l_type
argument_list|,
name|expect
index|[
name|j
index|]
operator|.
name|l_type
argument_list|)
expr_stmt|;
name|ATF_CHECK_EQ
argument_list|(
name|result
index|[
name|j
index|]
operator|.
name|l_whence
argument_list|,
name|expect
index|[
name|j
index|]
operator|.
name|l_whence
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Release processes.  This also releases the fds and locks 	 * making fs unmount possible 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|__arraycount
argument_list|(
name|lwp
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rump_pub_lwproc_switch
argument_list|(
name|lwp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rump_pub_lwproc_releaselwp
argument_list|()
expr_stmt|;
block|}
name|FSTEST_EXIT
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|access_simple
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|int
name|tmode
decl_stmt|;
name|FSTEST_ENTER
argument_list|()
expr_stmt|;
name|RL
argument_list|(
name|fd
operator|=
name|rump_sys_open
argument_list|(
literal|"tfile"
argument_list|,
name|O_CREAT
operator||
name|O_RDWR
argument_list|,
literal|0777
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_close
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|ALLACC
value|(F_OK | X_OK | W_OK | R_OK)
if|if
condition|(
name|FSTYPE_SYSVBFS
argument_list|(
name|tc
argument_list|)
operator|||
name|FSTYPE_MSDOS
argument_list|(
name|tc
argument_list|)
condition|)
name|tmode
operator|=
name|F_OK
expr_stmt|;
else|else
name|tmode
operator|=
name|ALLACC
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_access
argument_list|(
literal|"tfile"
argument_list|,
name|tmode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* PR kern/44648 */
name|ATF_REQUIRE_ERRNO
argument_list|(
name|EINVAL
argument_list|,
name|rump_sys_access
argument_list|(
literal|"tfile"
argument_list|,
name|ALLACC
operator|+
literal|1
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ALLACC
name|FSTEST_EXIT
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_directory
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mp
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|res
decl_stmt|;
name|ssize_t
name|size
decl_stmt|;
name|FSTEST_ENTER
argument_list|()
expr_stmt|;
name|fd
operator|=
name|rump_sys_open
argument_list|(
literal|"."
argument_list|,
name|O_DIRECTORY
operator||
name|O_RDONLY
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|fd
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
name|rump_sys_pread
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|size
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|==
name|EISDIR
argument_list|)
expr_stmt|;
name|size
operator|=
name|rump_sys_read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|size
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|==
name|EISDIR
argument_list|)
expr_stmt|;
name|res
operator|=
name|rump_sys_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|res
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|FSTEST_EXIT
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lstat_symlink
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|mp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|int
name|res
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|USES_SYMLINKS
expr_stmt|;
if|if
condition|(
name|FSTYPE_V7FS
argument_list|(
name|tc
argument_list|)
condition|)
name|atf_tc_expect_fail
argument_list|(
literal|"PR kern/48864"
argument_list|)
expr_stmt|;
name|FSTEST_ENTER
argument_list|()
expr_stmt|;
name|src
operator|=
literal|"source"
expr_stmt|;
name|dst
operator|=
literal|"destination"
expr_stmt|;
name|res
operator|=
name|rump_sys_symlink
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|res
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|res
operator|=
name|rump_sys_lstat
argument_list|(
name|dst
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|res
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|S_ISLNK
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|st
operator|.
name|st_size
operator|==
operator|(
name|off_t
operator|)
name|strlen
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|FSTEST_EXIT
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|lookup_simple
argument_list|,
literal|"simple lookup (./.. on root)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|lookup_complex
argument_list|,
literal|"lookup of non-dot entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|dir_simple
argument_list|,
literal|"mkdir/rmdir"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|dir_notempty
argument_list|,
literal|"non-empty directories cannot be removed"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|dir_rmdirdotdot
argument_list|,
literal|"remove .. and try to cd out (PR kern/44657)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|rename_dir
argument_list|,
literal|"exercise various directory renaming ops "
literal|"(PR kern/44288)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|rename_dotdot
argument_list|,
literal|"rename dir .. (PR kern/43617)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|rename_reg_nodir
argument_list|,
literal|"rename regular files, no subdirectories"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|create_nametoolong
argument_list|,
literal|"create file with name too long"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|create_exist
argument_list|,
literal|"create with O_EXCL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|rename_nametoolong
argument_list|,
literal|"rename to file with name too long"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|symlink_zerolen
argument_list|,
literal|"symlink with target of length 0"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|symlink_long
argument_list|,
literal|"symlink with target of length> 0"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|symlink_root
argument_list|,
literal|"symlink to root directory"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|attrs
argument_list|,
literal|"check setting attributes works"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|fcntl_lock
argument_list|,
literal|"check fcntl F_SETLK"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|fcntl_getlock_pids
argument_list|,
literal|"fcntl F_GETLK w/ many procs, PR kern/44494"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|access_simple
argument_list|,
literal|"access(2)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|read_directory
argument_list|,
literal|"read(2) on directories"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ATF_TC_FSAPPLY
argument_list|(
name|lstat_symlink
argument_list|,
literal|"lstat(2) values for symbolic links"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TP_ADD_TCS
argument_list|(
argument|tp
argument_list|)
end_macro

begin_block
block|{
name|ATF_TP_FSAPPLY
argument_list|(
name|lookup_simple
argument_list|)
expr_stmt|;
name|ATF_TP_FSAPPLY
argument_list|(
name|lookup_complex
argument_list|)
expr_stmt|;
name|ATF_TP_FSAPPLY
argument_list|(
name|dir_simple
argument_list|)
expr_stmt|;
name|ATF_TP_FSAPPLY
argument_list|(
name|dir_notempty
argument_list|)
expr_stmt|;
name|ATF_TP_FSAPPLY
argument_list|(
name|dir_rmdirdotdot
argument_list|)
expr_stmt|;
name|ATF_TP_FSAPPLY
argument_list|(
name|rename_dir
argument_list|)
expr_stmt|;
name|ATF_TP_FSAPPLY
argument_list|(
name|rename_dotdot
argument_list|)
expr_stmt|;
name|ATF_TP_FSAPPLY
argument_list|(
name|rename_reg_nodir
argument_list|)
expr_stmt|;
name|ATF_TP_FSAPPLY
argument_list|(
name|create_nametoolong
argument_list|)
expr_stmt|;
name|ATF_TP_FSAPPLY
argument_list|(
name|create_exist
argument_list|)
expr_stmt|;
name|ATF_TP_FSAPPLY
argument_list|(
name|rename_nametoolong
argument_list|)
expr_stmt|;
name|ATF_TP_FSAPPLY
argument_list|(
name|symlink_zerolen
argument_list|)
expr_stmt|;
name|ATF_TP_FSAPPLY
argument_list|(
name|symlink_long
argument_list|)
expr_stmt|;
name|ATF_TP_FSAPPLY
argument_list|(
name|symlink_root
argument_list|)
expr_stmt|;
name|ATF_TP_FSAPPLY
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
name|ATF_TP_FSAPPLY
argument_list|(
name|fcntl_lock
argument_list|)
expr_stmt|;
name|ATF_TP_FSAPPLY
argument_list|(
name|fcntl_getlock_pids
argument_list|)
expr_stmt|;
name|ATF_TP_FSAPPLY
argument_list|(
name|access_simple
argument_list|)
expr_stmt|;
name|ATF_TP_FSAPPLY
argument_list|(
name|read_directory
argument_list|)
expr_stmt|;
name|ATF_TP_FSAPPLY
argument_list|(
name|lstat_symlink
argument_list|)
expr_stmt|;
return|return
name|atf_no_error
argument_list|()
return|;
block|}
end_block

end_unit

