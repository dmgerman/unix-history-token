begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: t_lwproc.c,v 1.5 2011/01/02 12:58:17 pooka Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2010 The NetBSD Foundation, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE  * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<rump/rump.h>
end_include

begin_include
include|#
directive|include
file|<rump/rump_syscalls.h>
end_include

begin_include
include|#
directive|include
file|<atf-c.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_include
include|#
directive|include
file|"../../h_macros.h"
end_include

begin_expr_stmt
name|ATF_TC
argument_list|(
name|makelwp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|makelwp
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"tests that lwps can be attached to "
literal|"processes"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|makelwp
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|lwp
modifier|*
name|l
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|rump_init
argument_list|()
expr_stmt|;
name|RZ
argument_list|(
name|rump_pub_lwproc_newlwp
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|rump_pub_lwproc_newlwp
argument_list|(
literal|37
argument_list|)
argument_list|,
name|ESRCH
argument_list|)
expr_stmt|;
name|l
operator|=
name|rump_pub_lwproc_curlwp
argument_list|()
expr_stmt|;
name|RZ
argument_list|(
name|rump_pub_lwproc_rfork
argument_list|(
name|RUMP_RFCFDG
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|rump_pub_lwproc_curlwp
argument_list|()
operator|!=
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|rump_pub_lwproc_curlwp
argument_list|()
expr_stmt|;
name|RZ
argument_list|(
name|rump_pub_lwproc_newlwp
argument_list|(
name|rump_sys_getpid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|rump_pub_lwproc_curlwp
argument_list|()
operator|!=
name|l
argument_list|)
expr_stmt|;
name|pid
operator|=
name|rump_sys_getpid
argument_list|()
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|pid
operator|!=
operator|-
literal|1
operator|&&
name|pid
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|proccreds
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|proccreds
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"check that procs have different creds"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|proccreds
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|lwp
modifier|*
name|l1
decl_stmt|,
modifier|*
name|l2
decl_stmt|;
name|rump_init
argument_list|()
expr_stmt|;
name|RZ
argument_list|(
name|rump_pub_lwproc_rfork
argument_list|(
name|RUMP_RFCFDG
argument_list|)
argument_list|)
expr_stmt|;
name|l1
operator|=
name|rump_pub_lwproc_curlwp
argument_list|()
expr_stmt|;
name|RZ
argument_list|(
name|rump_pub_lwproc_rfork
argument_list|(
name|RUMP_RFCFDG
argument_list|)
argument_list|)
expr_stmt|;
name|l2
operator|=
name|rump_pub_lwproc_curlwp
argument_list|()
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_setuid
argument_list|(
literal|22
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|rump_sys_getuid
argument_list|()
argument_list|,
literal|22
argument_list|)
expr_stmt|;
name|rump_pub_lwproc_switch
argument_list|(
name|l1
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|rump_sys_getuid
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* from parent, proc0 */
name|RL
argument_list|(
name|rump_sys_setuid
argument_list|(
literal|11
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|rump_sys_getuid
argument_list|()
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|rump_pub_lwproc_switch
argument_list|(
name|l2
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|rump_sys_getuid
argument_list|()
argument_list|,
literal|22
argument_list|)
expr_stmt|;
name|rump_pub_lwproc_newlwp
argument_list|(
name|rump_sys_getpid
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|rump_sys_getuid
argument_list|()
argument_list|,
literal|22
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|inherit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|inherit
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"new processes inherit creds from "
literal|"parents"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|inherit
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|rump_init
argument_list|()
expr_stmt|;
name|RZ
argument_list|(
name|rump_pub_lwproc_rfork
argument_list|(
name|RUMP_RFCFDG
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_setuid
argument_list|(
literal|66
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|rump_sys_getuid
argument_list|()
argument_list|,
literal|66
argument_list|)
expr_stmt|;
name|RZ
argument_list|(
name|rump_pub_lwproc_rfork
argument_list|(
name|RUMP_RFCFDG
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|rump_sys_getuid
argument_list|()
argument_list|,
literal|66
argument_list|)
expr_stmt|;
comment|/* release lwp and proc */
name|rump_pub_lwproc_releaselwp
argument_list|()
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|rump_sys_getuid
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|lwps
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|lwps
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"proc can hold many lwps and is "
literal|"automatically g/c'd when the last one exits"
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|LOOPS
value|128
end_define

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|lwps
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|lwp
modifier|*
name|l
index|[
name|LOOPS
index|]
decl_stmt|;
name|pid_t
name|mypid
decl_stmt|;
name|struct
name|lwp
modifier|*
name|l_orig
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rump_init
argument_list|()
expr_stmt|;
name|RZ
argument_list|(
name|rump_pub_lwproc_rfork
argument_list|(
name|RUMP_RFCFDG
argument_list|)
argument_list|)
expr_stmt|;
name|mypid
operator|=
name|rump_sys_getpid
argument_list|()
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_setuid
argument_list|(
literal|375
argument_list|)
argument_list|)
expr_stmt|;
name|l_orig
operator|=
name|rump_pub_lwproc_curlwp
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LOOPS
condition|;
name|i
operator|++
control|)
block|{
name|mypid
operator|=
name|rump_sys_getpid
argument_list|()
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|mypid
operator|!=
operator|-
literal|1
operator|&&
name|mypid
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|RZ
argument_list|(
name|rump_pub_lwproc_newlwp
argument_list|(
name|mypid
argument_list|)
argument_list|)
expr_stmt|;
name|l
index|[
name|i
index|]
operator|=
name|rump_pub_lwproc_curlwp
argument_list|()
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|rump_sys_getuid
argument_list|()
argument_list|,
literal|375
argument_list|)
expr_stmt|;
block|}
name|rump_pub_lwproc_switch
argument_list|(
name|l_orig
argument_list|)
expr_stmt|;
name|rump_pub_lwproc_releaselwp
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LOOPS
condition|;
name|i
operator|++
control|)
block|{
name|rump_pub_lwproc_switch
argument_list|(
name|l
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|rump_sys_getpid
argument_list|()
argument_list|,
name|mypid
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|rump_sys_getuid
argument_list|()
argument_list|,
literal|375
argument_list|)
expr_stmt|;
name|rump_pub_lwproc_releaselwp
argument_list|()
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|rump_sys_getpid
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|rump_sys_getuid
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ATF_REQUIRE_EQ
argument_list|(
name|rump_pub_lwproc_newlwp
argument_list|(
name|mypid
argument_list|)
argument_list|,
name|ESRCH
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|nolwprelease
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|nolwprelease
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"check that lwp context is required "
literal|"for lwproc_releaselwp()"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|nolwprelease
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|int
name|status
decl_stmt|;
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
name|rump_init
argument_list|()
expr_stmt|;
name|rump_pub_lwproc_releaselwp
argument_list|()
expr_stmt|;
name|atf_tc_fail
argument_list|(
literal|"survived"
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|atf_tc_fail_errno
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
name|ATF_REQUIRE
argument_list|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|,
name|SIGABRT
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|nolwp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|nolwp
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"check that curlwp for an implicit "
literal|"context is NULL"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|nolwp
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|rump_init
argument_list|()
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|rump_pub_lwproc_curlwp
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|nullswitch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|nullswitch
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"check that switching to NULL marks "
literal|"current lwp as not running"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|nullswitch
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|lwp
modifier|*
name|l
decl_stmt|;
name|rump_init
argument_list|()
expr_stmt|;
name|RZ
argument_list|(
name|rump_pub_lwproc_newlwp
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|=
name|rump_pub_lwproc_curlwp
argument_list|()
expr_stmt|;
name|rump_pub_lwproc_switch
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* if remains LP_RUNNING, next call will panic */
name|rump_pub_lwproc_switch
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|rfork
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|rfork
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"check that fork shares fd's"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|rfork
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|lwp
modifier|*
name|l
decl_stmt|,
modifier|*
name|l2
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|RZ
argument_list|(
name|rump_init
argument_list|()
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|rump_pub_lwproc_rfork
argument_list|(
name|RUMP_RFFDG
operator||
name|RUMP_RFCFDG
argument_list|)
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|RZ
argument_list|(
name|rump_pub_lwproc_rfork
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|=
name|rump_pub_lwproc_curlwp
argument_list|()
expr_stmt|;
name|RL
argument_list|(
name|fd
operator|=
name|rump_sys_open
argument_list|(
literal|"/file"
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0777
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ok, first check rfork(RUMP_RFCFDG) does *not* preserve fd's */
name|RZ
argument_list|(
name|rump_pub_lwproc_rfork
argument_list|(
name|RUMP_RFCFDG
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_ERRNO
argument_list|(
name|EBADF
argument_list|,
name|rump_sys_write
argument_list|(
name|fd
argument_list|,
operator|&
name|fd
argument_list|,
sizeof|sizeof
argument_list|(
name|fd
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* then check that rfork(0) does */
name|rump_pub_lwproc_switch
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|RZ
argument_list|(
name|rump_pub_lwproc_rfork
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|rump_sys_write
argument_list|(
name|fd
argument_list|,
operator|&
name|fd
argument_list|,
sizeof|sizeof
argument_list|(
name|fd
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
argument_list|)
expr_stmt|;
name|l2
operator|=
name|rump_pub_lwproc_curlwp
argument_list|()
expr_stmt|;
comment|/* 	 * check that the shared fd table is really shared by 	 * closing fd in parent 	 */
name|rump_pub_lwproc_switch
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_close
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
name|rump_pub_lwproc_switch
argument_list|(
name|l2
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_ERRNO
argument_list|(
name|EBADF
argument_list|,
name|rump_sys_fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* redo, this time copying the fd table instead of sharing it */
name|rump_pub_lwproc_releaselwp
argument_list|()
expr_stmt|;
name|rump_pub_lwproc_switch
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|fd
operator|=
name|rump_sys_open
argument_list|(
literal|"/file"
argument_list|,
name|O_RDWR
argument_list|,
literal|0777
argument_list|)
argument_list|)
expr_stmt|;
name|RZ
argument_list|(
name|rump_pub_lwproc_rfork
argument_list|(
name|RUMP_RFFDG
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|rump_sys_write
argument_list|(
name|fd
argument_list|,
operator|&
name|fd
argument_list|,
sizeof|sizeof
argument_list|(
name|fd
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
argument_list|)
expr_stmt|;
name|l2
operator|=
name|rump_pub_lwproc_curlwp
argument_list|()
expr_stmt|;
comment|/* check that the fd table is copied */
name|rump_pub_lwproc_switch
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_close
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
name|rump_pub_lwproc_switch
argument_list|(
name|l2
argument_list|)
expr_stmt|;
name|RL
argument_list|(
name|rump_sys_fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ
argument_list|(
name|sb
operator|.
name|st_size
argument_list|,
sizeof|sizeof
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TP_ADD_TCS
argument_list|(
argument|tp
argument_list|)
end_macro

begin_block
block|{
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|makelwp
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|proccreds
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|inherit
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|lwps
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|nolwprelease
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|nolwp
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|nullswitch
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|rfork
argument_list|)
expr_stmt|;
return|return
name|atf_no_error
argument_list|()
return|;
block|}
end_block

end_unit

