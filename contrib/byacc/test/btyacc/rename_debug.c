begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* original parser id follows */
end_comment

begin_comment
comment|/* yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93" */
end_comment

begin_comment
comment|/* (use YYMAJOR/YYMINOR for ifdefs dependent on parser version) */
end_comment

begin_define
define|#
directive|define
name|YYBYACC
value|1
end_define

begin_define
define|#
directive|define
name|YYMAJOR
value|1
end_define

begin_define
define|#
directive|define
name|YYMINOR
value|9
end_define

begin_define
define|#
directive|define
name|YYCHECK
value|"yyyymmdd"
end_define

begin_define
define|#
directive|define
name|YYEMPTY
value|(-1)
end_define

begin_define
define|#
directive|define
name|yyclearin
value|(yychar = YYEMPTY)
end_define

begin_define
define|#
directive|define
name|yyerrok
value|(yyerrflag = 0)
end_define

begin_define
define|#
directive|define
name|YYRECOVERING
parameter_list|()
value|(yyerrflag != 0)
end_define

begin_define
define|#
directive|define
name|YYENOMEM
value|(-2)
end_define

begin_define
define|#
directive|define
name|YYEOF
value|0
end_define

begin_undef
undef|#
directive|undef
name|YYBTYACC
end_undef

begin_define
define|#
directive|define
name|YYBTYACC
value|0
end_define

begin_define
define|#
directive|define
name|YYDEBUGSTR
value|YYPREFIX "debug"
end_define

begin_line
line|#
directive|line
number|20
file|"rename_debug.c"
end_line

begin_include
include|#
directive|include
file|"rename_debug.i"
end_include

begin_include
include|#
directive|include
file|"rename_debug.h"
end_include

begin_typedef
typedef|typedef
name|short
name|YYINT
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yylhs
index|[]
init|=
block|{
operator|-
literal|1
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yylen
index|[]
init|=
block|{
literal|2
block|,
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yydefred
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yystos
index|[]
init|=
block|{
literal|0
block|,
literal|256
block|,
literal|258
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yydgoto
index|[]
init|=
block|{
literal|2
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yysindex
index|[]
init|=
block|{
operator|-
literal|256
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yyrindex
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|YYBTYACC
end_if

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yycindex
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yygindex
index|[]
init|=
block|{
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYTABLESIZE
value|0
end_define

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yytable
index|[]
init|=
block|{
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yycheck
index|[]
init|=
block|{
literal|256
block|, }
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|YYBTYACC
end_if

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yyctable
index|[]
init|=
block|{
operator|-
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|YYFINAL
value|2
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|YYDEBUG
end_ifndef

begin_define
define|#
directive|define
name|YYDEBUG
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|YYMAXTOKEN
value|256
end_define

begin_define
define|#
directive|define
name|YYUNDFTOKEN
value|259
end_define

begin_define
define|#
directive|define
name|YYTRANSLATE
parameter_list|(
name|a
parameter_list|)
value|((a)> YYMAXTOKEN ? YYUNDFTOKEN : (a))
end_define

begin_if
if|#
directive|if
name|YYDEBUG
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|yyname
index|[]
init|=
block|{
literal|"$end"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"error"
block|,
literal|"$accept"
block|,
literal|"S"
block|,
literal|"illegal-symbol"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|yyrule
index|[]
init|=
block|{
literal|"$accept : S"
block|,
literal|"S : error"
block|,  }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|yydebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yynerrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yyerrflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YYSTYPE
name|yyval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YYSTYPE
name|yylval
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
end_if

begin_decl_stmt
name|YYLTYPE
name|yyloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* position returned by actions */
end_comment

begin_decl_stmt
name|YYLTYPE
name|yylloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* position from the lexer */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|YYLLOC_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|YYLLOC_DEFAULT
parameter_list|(
name|loc
parameter_list|,
name|rhs
parameter_list|,
name|n
parameter_list|)
define|\
value|do \ { \     if (n == 0) \     { \         (loc).first_line   = ((rhs)[-1]).last_line; \         (loc).first_column = ((rhs)[-1]).last_column; \         (loc).last_line    = ((rhs)[-1]).last_line; \         (loc).last_column  = ((rhs)[-1]).last_column; \     } \     else \     { \         (loc).first_line   = ((rhs)[ 0 ]).first_line; \         (loc).first_column = ((rhs)[ 0 ]).first_column; \         (loc).last_line    = ((rhs)[n-1]).last_line; \         (loc).last_column  = ((rhs)[n-1]).last_column; \     } \ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYLLOC_DEFAULT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED) */
end_comment

begin_if
if|#
directive|if
name|YYBTYACC
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|YYLVQUEUEGROWTH
end_ifndef

begin_define
define|#
directive|define
name|YYLVQUEUEGROWTH
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYBTYACC */
end_comment

begin_comment
comment|/* define the initial stack-sizes */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYSTACKSIZE
end_ifdef

begin_undef
undef|#
directive|undef
name|YYMAXDEPTH
end_undef

begin_define
define|#
directive|define
name|YYMAXDEPTH
value|YYSTACKSIZE
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|YYMAXDEPTH
end_ifdef

begin_define
define|#
directive|define
name|YYSTACKSIZE
value|YYMAXDEPTH
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYSTACKSIZE
value|10000
end_define

begin_define
define|#
directive|define
name|YYMAXDEPTH
value|10000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|YYINITSTACKSIZE
end_ifndef

begin_define
define|#
directive|define
name|YYINITSTACKSIZE
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|stacksize
decl_stmt|;
name|YYINT
modifier|*
name|s_base
decl_stmt|;
name|YYINT
modifier|*
name|s_mark
decl_stmt|;
name|YYINT
modifier|*
name|s_last
decl_stmt|;
name|YYSTYPE
modifier|*
name|l_base
decl_stmt|;
name|YYSTYPE
modifier|*
name|l_mark
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|YYLTYPE
modifier|*
name|p_base
decl_stmt|;
name|YYLTYPE
modifier|*
name|p_mark
decl_stmt|;
endif|#
directive|endif
block|}
name|YYSTACKDATA
typedef|;
end_typedef

begin_if
if|#
directive|if
name|YYBTYACC
end_if

begin_struct
struct|struct
name|YYParseState_s
block|{
name|struct
name|YYParseState_s
modifier|*
name|save
decl_stmt|;
comment|/* Previously saved parser state */
name|YYSTACKDATA
name|yystack
decl_stmt|;
comment|/* saved parser stack */
name|int
name|state
decl_stmt|;
comment|/* saved parser state */
name|int
name|errflag
decl_stmt|;
comment|/* saved error recovery status */
name|int
name|lexeme
decl_stmt|;
comment|/* saved index of the conflict lexeme in the lexical queue */
name|YYINT
name|ctry
decl_stmt|;
comment|/* saved index in yyctable[] for this conflict */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|YYParseState_s
name|YYParseState
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYBTYACC */
end_comment

begin_comment
comment|/* variables for the parser stack */
end_comment

begin_decl_stmt
specifier|static
name|YYSTACKDATA
name|yystack
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|YYBTYACC
end_if

begin_comment
comment|/* Current parser state */
end_comment

begin_decl_stmt
specifier|static
name|YYParseState
modifier|*
name|yyps
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* yypath != NULL: do the full parse, starting at *yypath parser state. */
end_comment

begin_decl_stmt
specifier|static
name|YYParseState
modifier|*
name|yypath
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base of the lexical value queue */
end_comment

begin_decl_stmt
specifier|static
name|YYSTYPE
modifier|*
name|yylvals
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current position at lexical value queue */
end_comment

begin_decl_stmt
specifier|static
name|YYSTYPE
modifier|*
name|yylvp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* End position of lexical value queue */
end_comment

begin_decl_stmt
specifier|static
name|YYSTYPE
modifier|*
name|yylve
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last allocated position at the lexical value queue */
end_comment

begin_decl_stmt
specifier|static
name|YYSTYPE
modifier|*
name|yylvlim
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
end_if

begin_comment
comment|/* Base of the lexical position queue */
end_comment

begin_decl_stmt
specifier|static
name|YYLTYPE
modifier|*
name|yylpsns
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current position at lexical position queue */
end_comment

begin_decl_stmt
specifier|static
name|YYLTYPE
modifier|*
name|yylpp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* End position of lexical position queue */
end_comment

begin_decl_stmt
specifier|static
name|YYLTYPE
modifier|*
name|yylpe
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last allocated position at the lexical position queue */
end_comment

begin_decl_stmt
specifier|static
name|YYLTYPE
modifier|*
name|yylplim
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Current position at lexical token queue */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|yylexp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|yylexemes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYBTYACC */
end_comment

begin_line
line|#
directive|line
number|12
file|"code_debug.y"
end_line

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|YYBYACC
end_ifdef

begin_function_decl
specifier|extern
name|int
name|YYLEX_DECL
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"yyparse() = %d\n"
argument_list|,
name|yyparse
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|yylex
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|yyerror
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_line
line|#
directive|line
number|236
file|"rename_debug.c"
end_line

begin_comment
comment|/* For use in generated program */
end_comment

begin_define
define|#
directive|define
name|yydepth
value|(int)(yystack.s_mark - yystack.s_base)
end_define

begin_if
if|#
directive|if
name|YYBTYACC
end_if

begin_define
define|#
directive|define
name|yytrial
value|(yyps->save)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYBTYACC */
end_comment

begin_if
if|#
directive|if
name|YYDEBUG
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* needed for printf */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* needed for malloc, etc */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* needed for memset */
end_comment

begin_comment
comment|/* allocate initial stack or double stack size, up to YYMAXDEPTH */
end_comment

begin_function
specifier|static
name|int
name|yygrowstack
parameter_list|(
name|YYSTACKDATA
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|newsize
decl_stmt|;
name|YYINT
modifier|*
name|newss
decl_stmt|;
name|YYSTYPE
modifier|*
name|newvs
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|YYLTYPE
modifier|*
name|newps
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|newsize
operator|=
name|data
operator|->
name|stacksize
operator|)
operator|==
literal|0
condition|)
name|newsize
operator|=
name|YYINITSTACKSIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|newsize
operator|>=
name|YYMAXDEPTH
condition|)
return|return
name|YYENOMEM
return|;
elseif|else
if|if
condition|(
operator|(
name|newsize
operator|*=
literal|2
operator|)
operator|>
name|YYMAXDEPTH
condition|)
name|newsize
operator|=
name|YYMAXDEPTH
expr_stmt|;
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|data
operator|->
name|s_mark
operator|-
name|data
operator|->
name|s_base
argument_list|)
expr_stmt|;
name|newss
operator|=
operator|(
name|YYINT
operator|*
operator|)
name|realloc
argument_list|(
name|data
operator|->
name|s_base
argument_list|,
name|newsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newss
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newss
operator|==
literal|0
condition|)
return|return
name|YYENOMEM
return|;
name|data
operator|->
name|s_base
operator|=
name|newss
expr_stmt|;
name|data
operator|->
name|s_mark
operator|=
name|newss
operator|+
name|i
expr_stmt|;
name|newvs
operator|=
operator|(
name|YYSTYPE
operator|*
operator|)
name|realloc
argument_list|(
name|data
operator|->
name|l_base
argument_list|,
name|newsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newvs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvs
operator|==
literal|0
condition|)
return|return
name|YYENOMEM
return|;
name|data
operator|->
name|l_base
operator|=
name|newvs
expr_stmt|;
name|data
operator|->
name|l_mark
operator|=
name|newvs
operator|+
name|i
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|newps
operator|=
operator|(
name|YYLTYPE
operator|*
operator|)
name|realloc
argument_list|(
name|data
operator|->
name|p_base
argument_list|,
name|newsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newps
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newps
operator|==
literal|0
condition|)
return|return
name|YYENOMEM
return|;
name|data
operator|->
name|p_base
operator|=
name|newps
expr_stmt|;
name|data
operator|->
name|p_mark
operator|=
name|newps
operator|+
name|i
expr_stmt|;
endif|#
directive|endif
name|data
operator|->
name|stacksize
operator|=
name|newsize
expr_stmt|;
name|data
operator|->
name|s_last
operator|=
name|data
operator|->
name|s_base
operator|+
name|newsize
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%sdebug: stack size increased to %d\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|YYPURE
operator|||
name|defined
argument_list|(
name|YY_NO_LEAKS
argument_list|)
end_if

begin_function
specifier|static
name|void
name|yyfreestack
parameter_list|(
name|YYSTACKDATA
modifier|*
name|data
parameter_list|)
block|{
name|free
argument_list|(
name|data
operator|->
name|s_base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
operator|->
name|l_base
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|free
argument_list|(
name|data
operator|->
name|p_base
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|yyfreestack
parameter_list|(
name|data
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYPURE || defined(YY_NO_LEAKS) */
end_comment

begin_if
if|#
directive|if
name|YYBTYACC
end_if

begin_function
specifier|static
name|YYParseState
modifier|*
name|yyNewState
parameter_list|(
name|unsigned
name|size
parameter_list|)
block|{
name|YYParseState
modifier|*
name|p
init|=
operator|(
name|YYParseState
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|YYParseState
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|p
operator|->
name|yystack
operator|.
name|stacksize
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|yystack
operator|.
name|s_base
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|yystack
operator|.
name|l_base
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|p
operator|->
name|yystack
operator|.
name|p_base
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
return|return
name|p
return|;
block|}
name|p
operator|->
name|yystack
operator|.
name|s_base
operator|=
operator|(
name|YYINT
operator|*
operator|)
name|malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|YYINT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|yystack
operator|.
name|s_base
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|p
operator|->
name|yystack
operator|.
name|l_base
operator|=
operator|(
name|YYSTYPE
operator|*
operator|)
name|malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|YYSTYPE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|yystack
operator|.
name|l_base
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p
operator|->
name|yystack
operator|.
name|l_base
argument_list|,
literal|0
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|YYSTYPE
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|p
operator|->
name|yystack
operator|.
name|p_base
operator|=
operator|(
name|YYLTYPE
operator|*
operator|)
name|malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|YYLTYPE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|yystack
operator|.
name|p_base
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p
operator|->
name|yystack
operator|.
name|p_base
argument_list|,
literal|0
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|YYLTYPE
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|yyFreeState
parameter_list|(
name|YYParseState
modifier|*
name|p
parameter_list|)
block|{
name|yyfreestack
argument_list|(
operator|&
name|p
operator|->
name|yystack
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYBTYACC */
end_comment

begin_define
define|#
directive|define
name|YYABORT
value|goto yyabort
end_define

begin_define
define|#
directive|define
name|YYREJECT
value|goto yyabort
end_define

begin_define
define|#
directive|define
name|YYACCEPT
value|goto yyaccept
end_define

begin_define
define|#
directive|define
name|YYERROR
value|goto yyerrlab
end_define

begin_if
if|#
directive|if
name|YYBTYACC
end_if

begin_define
define|#
directive|define
name|YYVALID
value|do { if (yyps->save)            goto yyvalid; } while(0)
end_define

begin_define
define|#
directive|define
name|YYVALID_NESTED
value|do { if (yyps->save&& \                                 yyps->save->save == 0) goto yyvalid; } while(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYBTYACC */
end_comment

begin_function
name|int
name|YYPARSE_DECL
parameter_list|()
block|{
name|int
name|yym
decl_stmt|,
name|yyn
decl_stmt|,
name|yystate
decl_stmt|,
name|yyresult
decl_stmt|;
if|#
directive|if
name|YYBTYACC
name|int
name|yynewerrflag
decl_stmt|;
name|YYParseState
modifier|*
name|yyerrctx
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* YYBTYACC */
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|YYLTYPE
name|yyerror_loc_range
index|[
literal|2
index|]
decl_stmt|;
comment|/* position of error start& end */
endif|#
directive|endif
if|#
directive|if
name|YYDEBUG
specifier|const
name|char
modifier|*
name|yys
decl_stmt|;
if|if
condition|(
operator|(
name|yys
operator|=
name|getenv
argument_list|(
literal|"YYDEBUG"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|yyn
operator|=
operator|*
name|yys
expr_stmt|;
if|if
condition|(
name|yyn
operator|>=
literal|'0'
operator|&&
name|yyn
operator|<=
literal|'9'
condition|)
name|yydebug
operator|=
name|yyn
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|yydebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%sdebug[<# of symbols on state stack>]\n"
argument_list|,
name|YYPREFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|YYBTYACC
name|yyps
operator|=
name|yyNewState
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyps
operator|==
literal|0
condition|)
goto|goto
name|yyenomem
goto|;
name|yyps
operator|->
name|save
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* YYBTYACC */
name|yym
operator|=
literal|0
expr_stmt|;
name|yyn
operator|=
literal|0
expr_stmt|;
name|yynerrs
operator|=
literal|0
expr_stmt|;
name|yyerrflag
operator|=
literal|0
expr_stmt|;
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
name|yystate
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|YYPURE
name|memset
argument_list|(
operator|&
name|yystack
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|yystack
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yystack
operator|.
name|s_base
operator|==
name|NULL
operator|&&
name|yygrowstack
argument_list|(
operator|&
name|yystack
argument_list|)
operator|==
name|YYENOMEM
condition|)
goto|goto
name|yyoverflow
goto|;
name|yystack
operator|.
name|s_mark
operator|=
name|yystack
operator|.
name|s_base
expr_stmt|;
name|yystack
operator|.
name|l_mark
operator|=
name|yystack
operator|.
name|l_base
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yystack
operator|.
name|p_mark
operator|=
name|yystack
operator|.
name|p_base
expr_stmt|;
endif|#
directive|endif
name|yystate
operator|=
literal|0
expr_stmt|;
operator|*
name|yystack
operator|.
name|s_mark
operator|=
literal|0
expr_stmt|;
name|yyloop
label|:
if|if
condition|(
operator|(
name|yyn
operator|=
name|yydefred
index|[
name|yystate
index|]
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|yyreduce
goto|;
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|YYBTYACC
do|do
block|{
if|if
condition|(
name|yylvp
operator|<
name|yylve
condition|)
block|{
comment|/* we're currently re-reading tokens */
name|yylval
operator|=
operator|*
name|yylvp
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yylloc
operator|=
operator|*
name|yylpp
operator|++
expr_stmt|;
endif|#
directive|endif
name|yychar
operator|=
operator|*
name|yylexp
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|yyps
operator|->
name|save
condition|)
block|{
comment|/* in trial mode; save scanner results for future parse attempts */
if|if
condition|(
name|yylvp
operator|==
name|yylvlim
condition|)
block|{
comment|/* Enlarge lexical value queue */
name|size_t
name|p
init|=
call|(
name|size_t
call|)
argument_list|(
name|yylvp
operator|-
name|yylvals
argument_list|)
decl_stmt|;
name|size_t
name|s
init|=
call|(
name|size_t
call|)
argument_list|(
name|yylvlim
operator|-
name|yylvals
argument_list|)
decl_stmt|;
name|s
operator|+=
name|YYLVQUEUEGROWTH
expr_stmt|;
if|if
condition|(
operator|(
name|yylexemes
operator|=
operator|(
name|short
operator|*
operator|)
name|realloc
argument_list|(
name|yylexemes
argument_list|,
name|s
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|yyenomem
goto|;
if|if
condition|(
operator|(
name|yylvals
operator|=
operator|(
name|YYSTYPE
operator|*
operator|)
name|realloc
argument_list|(
name|yylvals
argument_list|,
name|s
operator|*
sizeof|sizeof
argument_list|(
name|YYSTYPE
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|yyenomem
goto|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
if|if
condition|(
operator|(
name|yylpsns
operator|=
operator|(
name|YYLTYPE
operator|*
operator|)
name|realloc
argument_list|(
name|yylpsns
argument_list|,
name|s
operator|*
sizeof|sizeof
argument_list|(
name|YYLTYPE
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|yyenomem
goto|;
endif|#
directive|endif
name|yylvp
operator|=
name|yylve
operator|=
name|yylvals
operator|+
name|p
expr_stmt|;
name|yylvlim
operator|=
name|yylvals
operator|+
name|s
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yylpp
operator|=
name|yylpe
operator|=
name|yylpsns
operator|+
name|p
expr_stmt|;
name|yylplim
operator|=
name|yylpsns
operator|+
name|s
expr_stmt|;
endif|#
directive|endif
name|yylexp
operator|=
name|yylexemes
operator|+
name|p
expr_stmt|;
block|}
operator|*
name|yylexp
operator|=
operator|(
name|short
operator|)
name|YYLEX
expr_stmt|;
operator|*
name|yylvp
operator|++
operator|=
name|yylval
expr_stmt|;
name|yylve
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
operator|*
name|yylpp
operator|++
operator|=
name|yylloc
expr_stmt|;
name|yylpe
operator|++
expr_stmt|;
endif|#
directive|endif
name|yychar
operator|=
operator|*
name|yylexp
operator|++
expr_stmt|;
break|break;
block|}
comment|/* normal operation, no conflict encountered */
endif|#
directive|endif
comment|/* YYBTYACC */
name|yychar
operator|=
name|YYLEX
expr_stmt|;
if|#
directive|if
name|YYBTYACC
block|}
do|while
condition|(
literal|0
condition|)
do|;
endif|#
directive|endif
comment|/* YYBTYACC */
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
name|yychar
operator|=
name|YYEOF
expr_stmt|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
if|if
condition|(
operator|(
name|yys
operator|=
name|yyname
index|[
name|YYTRANSLATE
argument_list|(
name|yychar
argument_list|)
index|]
operator|)
operator|==
name|NULL
condition|)
name|yys
operator|=
name|yyname
index|[
name|YYUNDFTOKEN
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s[%d]: state %d, reading token %d (%s)"
argument_list|,
name|YYDEBUGSTR
argument_list|,
name|yydepth
argument_list|,
name|yystate
argument_list|,
name|yychar
argument_list|,
name|yys
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|YYSTYPE_TOSTRING
if|#
directive|if
name|YYBTYACC
if|if
condition|(
operator|!
name|yytrial
condition|)
endif|#
directive|endif
comment|/* YYBTYACC */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<%s>"
argument_list|,
name|YYSTYPE_TOSTRING
argument_list|(
name|yychar
argument_list|,
name|yylval
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|#
directive|if
name|YYBTYACC
comment|/* Do we have a conflict? */
if|if
condition|(
operator|(
operator|(
name|yyn
operator|=
name|yycindex
index|[
name|yystate
index|]
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|yyn
operator|+=
name|yychar
operator|)
operator|>=
literal|0
operator|&&
name|yyn
operator|<=
name|YYTABLESIZE
operator|&&
name|yycheck
index|[
name|yyn
index|]
operator|==
operator|(
name|YYINT
operator|)
name|yychar
condition|)
block|{
name|YYINT
name|ctry
decl_stmt|;
if|if
condition|(
name|yypath
condition|)
block|{
name|YYParseState
modifier|*
name|save
decl_stmt|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s[%d]: CONFLICT in state %d: following successful trial parse\n"
argument_list|,
name|YYDEBUGSTR
argument_list|,
name|yydepth
argument_list|,
name|yystate
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Switch to the next conflict context */
name|save
operator|=
name|yypath
expr_stmt|;
name|yypath
operator|=
name|save
operator|->
name|save
expr_stmt|;
name|save
operator|->
name|save
operator|=
name|NULL
expr_stmt|;
name|ctry
operator|=
name|save
operator|->
name|ctry
expr_stmt|;
if|if
condition|(
name|save
operator|->
name|state
operator|!=
name|yystate
condition|)
name|YYABORT
expr_stmt|;
name|yyFreeState
argument_list|(
name|save
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Unresolved conflict - start/continue trial parse */
name|YYParseState
modifier|*
name|save
decl_stmt|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s[%d]: CONFLICT in state %d. "
argument_list|,
name|YYDEBUGSTR
argument_list|,
name|yydepth
argument_list|,
name|yystate
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyps
operator|->
name|save
condition|)
name|fputs
argument_list|(
literal|"ALREADY in conflict, continuing trial parse.\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"Starting trial parse.\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|save
operator|=
name|yyNewState
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|yystack
operator|.
name|s_mark
operator|-
name|yystack
operator|.
name|s_base
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|save
operator|==
name|NULL
condition|)
goto|goto
name|yyenomem
goto|;
name|save
operator|->
name|save
operator|=
name|yyps
operator|->
name|save
expr_stmt|;
name|save
operator|->
name|state
operator|=
name|yystate
expr_stmt|;
name|save
operator|->
name|errflag
operator|=
name|yyerrflag
expr_stmt|;
name|save
operator|->
name|yystack
operator|.
name|s_mark
operator|=
name|save
operator|->
name|yystack
operator|.
name|s_base
operator|+
operator|(
name|yystack
operator|.
name|s_mark
operator|-
name|yystack
operator|.
name|s_base
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|save
operator|->
name|yystack
operator|.
name|s_base
argument_list|,
name|yystack
operator|.
name|s_base
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|yystack
operator|.
name|s_mark
operator|-
name|yystack
operator|.
name|s_base
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|YYINT
argument_list|)
argument_list|)
expr_stmt|;
name|save
operator|->
name|yystack
operator|.
name|l_mark
operator|=
name|save
operator|->
name|yystack
operator|.
name|l_base
operator|+
operator|(
name|yystack
operator|.
name|l_mark
operator|-
name|yystack
operator|.
name|l_base
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|save
operator|->
name|yystack
operator|.
name|l_base
argument_list|,
name|yystack
operator|.
name|l_base
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|yystack
operator|.
name|l_mark
operator|-
name|yystack
operator|.
name|l_base
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|YYSTYPE
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|save
operator|->
name|yystack
operator|.
name|p_mark
operator|=
name|save
operator|->
name|yystack
operator|.
name|p_base
operator|+
operator|(
name|yystack
operator|.
name|p_mark
operator|-
name|yystack
operator|.
name|p_base
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|save
operator|->
name|yystack
operator|.
name|p_base
argument_list|,
name|yystack
operator|.
name|p_base
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|yystack
operator|.
name|p_mark
operator|-
name|yystack
operator|.
name|p_base
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|YYLTYPE
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctry
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
if|if
condition|(
name|yyctable
index|[
name|ctry
index|]
operator|==
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
operator|&&
name|yychar
operator|>=
name|YYEOF
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s[%d]: backtracking 1 token\n"
argument_list|,
name|YYDEBUGSTR
argument_list|,
name|yydepth
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctry
operator|++
expr_stmt|;
block|}
name|save
operator|->
name|ctry
operator|=
name|ctry
expr_stmt|;
if|if
condition|(
name|yyps
operator|->
name|save
operator|==
name|NULL
condition|)
block|{
comment|/* If this is a first conflict in the stack, start saving lexemes */
if|if
condition|(
operator|!
name|yylexemes
condition|)
block|{
name|yylexemes
operator|=
operator|(
name|short
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|YYLVQUEUEGROWTH
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yylexemes
operator|==
name|NULL
condition|)
goto|goto
name|yyenomem
goto|;
name|yylvals
operator|=
operator|(
name|YYSTYPE
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|YYLVQUEUEGROWTH
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|YYSTYPE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yylvals
operator|==
name|NULL
condition|)
goto|goto
name|yyenomem
goto|;
name|yylvlim
operator|=
name|yylvals
operator|+
name|YYLVQUEUEGROWTH
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yylpsns
operator|=
operator|(
name|YYLTYPE
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|YYLVQUEUEGROWTH
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|YYLTYPE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yylpsns
operator|==
name|NULL
condition|)
goto|goto
name|yyenomem
goto|;
name|yylplim
operator|=
name|yylpsns
operator|+
name|YYLVQUEUEGROWTH
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|yylvp
operator|==
name|yylve
condition|)
block|{
name|yylvp
operator|=
name|yylve
operator|=
name|yylvals
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yylpp
operator|=
name|yylpe
operator|=
name|yylpsns
expr_stmt|;
endif|#
directive|endif
name|yylexp
operator|=
name|yylexemes
expr_stmt|;
if|if
condition|(
name|yychar
operator|>=
name|YYEOF
condition|)
block|{
operator|*
name|yylve
operator|++
operator|=
name|yylval
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
operator|*
name|yylpe
operator|++
operator|=
name|yylloc
expr_stmt|;
endif|#
directive|endif
operator|*
name|yylexp
operator|=
operator|(
name|short
operator|)
name|yychar
expr_stmt|;
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|yychar
operator|>=
name|YYEOF
condition|)
block|{
name|yylvp
operator|--
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yylpp
operator|--
expr_stmt|;
endif|#
directive|endif
name|yylexp
operator|--
expr_stmt|;
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
block|}
name|save
operator|->
name|lexeme
operator|=
call|(
name|int
call|)
argument_list|(
name|yylvp
operator|-
name|yylvals
argument_list|)
expr_stmt|;
name|yyps
operator|->
name|save
operator|=
name|save
expr_stmt|;
block|}
if|if
condition|(
name|yytable
index|[
name|yyn
index|]
operator|==
name|ctry
condition|)
block|{
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s[%d]: state %d, shifting to state %d\n"
argument_list|,
name|YYDEBUGSTR
argument_list|,
name|yydepth
argument_list|,
name|yystate
argument_list|,
name|yyctable
index|[
name|ctry
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
block|{
name|yylvp
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yylpp
operator|++
expr_stmt|;
endif|#
directive|endif
name|yylexp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|yystack
operator|.
name|s_mark
operator|>=
name|yystack
operator|.
name|s_last
operator|&&
name|yygrowstack
argument_list|(
operator|&
name|yystack
argument_list|)
operator|==
name|YYENOMEM
condition|)
goto|goto
name|yyoverflow
goto|;
name|yystate
operator|=
name|yyctable
index|[
name|ctry
index|]
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|s_mark
operator|=
operator|(
name|YYINT
operator|)
name|yystate
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|l_mark
operator|=
name|yylval
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
operator|*
operator|++
name|yystack
operator|.
name|p_mark
operator|=
name|yylloc
expr_stmt|;
endif|#
directive|endif
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
if|if
condition|(
name|yyerrflag
operator|>
literal|0
condition|)
operator|--
name|yyerrflag
expr_stmt|;
goto|goto
name|yyloop
goto|;
block|}
else|else
block|{
name|yyn
operator|=
name|yyctable
index|[
name|ctry
index|]
expr_stmt|;
goto|goto
name|yyreduce
goto|;
block|}
block|}
comment|/* End of code dealing with conflicts */
endif|#
directive|endif
comment|/* YYBTYACC */
if|if
condition|(
operator|(
operator|(
name|yyn
operator|=
name|yysindex
index|[
name|yystate
index|]
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|yyn
operator|+=
name|yychar
operator|)
operator|>=
literal|0
operator|&&
name|yyn
operator|<=
name|YYTABLESIZE
operator|&&
name|yycheck
index|[
name|yyn
index|]
operator|==
operator|(
name|YYINT
operator|)
name|yychar
condition|)
block|{
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s[%d]: state %d, shifting to state %d\n"
argument_list|,
name|YYDEBUGSTR
argument_list|,
name|yydepth
argument_list|,
name|yystate
argument_list|,
name|yytable
index|[
name|yyn
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yystack
operator|.
name|s_mark
operator|>=
name|yystack
operator|.
name|s_last
operator|&&
name|yygrowstack
argument_list|(
operator|&
name|yystack
argument_list|)
operator|==
name|YYENOMEM
condition|)
goto|goto
name|yyoverflow
goto|;
name|yystate
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|s_mark
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|l_mark
operator|=
name|yylval
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
operator|*
operator|++
name|yystack
operator|.
name|p_mark
operator|=
name|yylloc
expr_stmt|;
endif|#
directive|endif
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
if|if
condition|(
name|yyerrflag
operator|>
literal|0
condition|)
operator|--
name|yyerrflag
expr_stmt|;
goto|goto
name|yyloop
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|yyn
operator|=
name|yyrindex
index|[
name|yystate
index|]
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|yyn
operator|+=
name|yychar
operator|)
operator|>=
literal|0
operator|&&
name|yyn
operator|<=
name|YYTABLESIZE
operator|&&
name|yycheck
index|[
name|yyn
index|]
operator|==
operator|(
name|YYINT
operator|)
name|yychar
condition|)
block|{
name|yyn
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
goto|goto
name|yyreduce
goto|;
block|}
if|if
condition|(
name|yyerrflag
operator|!=
literal|0
condition|)
goto|goto
name|yyinrecovery
goto|;
if|#
directive|if
name|YYBTYACC
name|yynewerrflag
operator|=
literal|1
expr_stmt|;
goto|goto
name|yyerrhandler
goto|;
goto|goto
name|yyerrlab
goto|;
comment|/* redundant goto avoids 'unused label' warning */
name|yyerrlab
label|:
comment|/* explicit YYERROR from an action -- pop the rhs of the rule reduced      * before looking for error recovery */
name|yystack
operator|.
name|s_mark
operator|-=
name|yym
expr_stmt|;
name|yystate
operator|=
operator|*
name|yystack
operator|.
name|s_mark
expr_stmt|;
name|yystack
operator|.
name|l_mark
operator|-=
name|yym
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yystack
operator|.
name|p_mark
operator|-=
name|yym
expr_stmt|;
endif|#
directive|endif
name|yynewerrflag
operator|=
literal|0
expr_stmt|;
name|yyerrhandler
label|:
while|while
condition|(
name|yyps
operator|->
name|save
condition|)
block|{
name|int
name|ctry
decl_stmt|;
name|YYParseState
modifier|*
name|save
init|=
name|yyps
operator|->
name|save
decl_stmt|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s[%d]: ERROR in state %d, CONFLICT BACKTRACKING to state %d, %d tokens\n"
argument_list|,
name|YYDEBUGSTR
argument_list|,
name|yydepth
argument_list|,
name|yystate
argument_list|,
name|yyps
operator|->
name|save
operator|->
name|state
argument_list|,
call|(
name|int
call|)
argument_list|(
name|yylvp
operator|-
name|yylvals
operator|-
name|yyps
operator|->
name|save
operator|->
name|lexeme
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Memorize most forward-looking error state in case it's really an error. */
if|if
condition|(
name|yyerrctx
operator|==
name|NULL
operator|||
name|yyerrctx
operator|->
name|lexeme
operator|<
name|yylvp
operator|-
name|yylvals
condition|)
block|{
comment|/* Free old saved error context state */
if|if
condition|(
name|yyerrctx
condition|)
name|yyFreeState
argument_list|(
name|yyerrctx
argument_list|)
expr_stmt|;
comment|/* Create and fill out new saved error context state */
name|yyerrctx
operator|=
name|yyNewState
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|yystack
operator|.
name|s_mark
operator|-
name|yystack
operator|.
name|s_base
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyerrctx
operator|==
name|NULL
condition|)
goto|goto
name|yyenomem
goto|;
name|yyerrctx
operator|->
name|save
operator|=
name|yyps
operator|->
name|save
expr_stmt|;
name|yyerrctx
operator|->
name|state
operator|=
name|yystate
expr_stmt|;
name|yyerrctx
operator|->
name|errflag
operator|=
name|yyerrflag
expr_stmt|;
name|yyerrctx
operator|->
name|yystack
operator|.
name|s_mark
operator|=
name|yyerrctx
operator|->
name|yystack
operator|.
name|s_base
operator|+
operator|(
name|yystack
operator|.
name|s_mark
operator|-
name|yystack
operator|.
name|s_base
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|yyerrctx
operator|->
name|yystack
operator|.
name|s_base
argument_list|,
name|yystack
operator|.
name|s_base
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|yystack
operator|.
name|s_mark
operator|-
name|yystack
operator|.
name|s_base
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|YYINT
argument_list|)
argument_list|)
expr_stmt|;
name|yyerrctx
operator|->
name|yystack
operator|.
name|l_mark
operator|=
name|yyerrctx
operator|->
name|yystack
operator|.
name|l_base
operator|+
operator|(
name|yystack
operator|.
name|l_mark
operator|-
name|yystack
operator|.
name|l_base
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|yyerrctx
operator|->
name|yystack
operator|.
name|l_base
argument_list|,
name|yystack
operator|.
name|l_base
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|yystack
operator|.
name|l_mark
operator|-
name|yystack
operator|.
name|l_base
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|YYSTYPE
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yyerrctx
operator|->
name|yystack
operator|.
name|p_mark
operator|=
name|yyerrctx
operator|->
name|yystack
operator|.
name|p_base
operator|+
operator|(
name|yystack
operator|.
name|p_mark
operator|-
name|yystack
operator|.
name|p_base
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|yyerrctx
operator|->
name|yystack
operator|.
name|p_base
argument_list|,
name|yystack
operator|.
name|p_base
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|yystack
operator|.
name|p_mark
operator|-
name|yystack
operator|.
name|p_base
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|YYLTYPE
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yyerrctx
operator|->
name|lexeme
operator|=
call|(
name|int
call|)
argument_list|(
name|yylvp
operator|-
name|yylvals
argument_list|)
expr_stmt|;
block|}
name|yylvp
operator|=
name|yylvals
operator|+
name|save
operator|->
name|lexeme
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yylpp
operator|=
name|yylpsns
operator|+
name|save
operator|->
name|lexeme
expr_stmt|;
endif|#
directive|endif
name|yylexp
operator|=
name|yylexemes
operator|+
name|save
operator|->
name|lexeme
expr_stmt|;
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
name|yystack
operator|.
name|s_mark
operator|=
name|yystack
operator|.
name|s_base
operator|+
operator|(
name|save
operator|->
name|yystack
operator|.
name|s_mark
operator|-
name|save
operator|->
name|yystack
operator|.
name|s_base
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|yystack
operator|.
name|s_base
argument_list|,
name|save
operator|->
name|yystack
operator|.
name|s_base
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|yystack
operator|.
name|s_mark
operator|-
name|yystack
operator|.
name|s_base
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|YYINT
argument_list|)
argument_list|)
expr_stmt|;
name|yystack
operator|.
name|l_mark
operator|=
name|yystack
operator|.
name|l_base
operator|+
operator|(
name|save
operator|->
name|yystack
operator|.
name|l_mark
operator|-
name|save
operator|->
name|yystack
operator|.
name|l_base
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|yystack
operator|.
name|l_base
argument_list|,
name|save
operator|->
name|yystack
operator|.
name|l_base
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|yystack
operator|.
name|l_mark
operator|-
name|yystack
operator|.
name|l_base
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|YYSTYPE
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yystack
operator|.
name|p_mark
operator|=
name|yystack
operator|.
name|p_base
operator|+
operator|(
name|save
operator|->
name|yystack
operator|.
name|p_mark
operator|-
name|save
operator|->
name|yystack
operator|.
name|p_base
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|yystack
operator|.
name|p_base
argument_list|,
name|save
operator|->
name|yystack
operator|.
name|p_base
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|yystack
operator|.
name|p_mark
operator|-
name|yystack
operator|.
name|p_base
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|YYLTYPE
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctry
operator|=
operator|++
name|save
operator|->
name|ctry
expr_stmt|;
name|yystate
operator|=
name|save
operator|->
name|state
expr_stmt|;
comment|/* We tried shift, try reduce now */
if|if
condition|(
operator|(
name|yyn
operator|=
name|yyctable
index|[
name|ctry
index|]
operator|)
operator|>=
literal|0
condition|)
goto|goto
name|yyreduce
goto|;
name|yyps
operator|->
name|save
operator|=
name|save
operator|->
name|save
expr_stmt|;
name|save
operator|->
name|save
operator|=
name|NULL
expr_stmt|;
name|yyFreeState
argument_list|(
name|save
argument_list|)
expr_stmt|;
comment|/* Nothing left on the stack -- error */
if|if
condition|(
operator|!
name|yyps
operator|->
name|save
condition|)
block|{
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%sdebug[%d,trial]: trial parse FAILED, entering ERROR mode\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|yydepth
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Restore state as it was in the most forward-advanced error */
name|yylvp
operator|=
name|yylvals
operator|+
name|yyerrctx
operator|->
name|lexeme
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yylpp
operator|=
name|yylpsns
operator|+
name|yyerrctx
operator|->
name|lexeme
expr_stmt|;
endif|#
directive|endif
name|yylexp
operator|=
name|yylexemes
operator|+
name|yyerrctx
operator|->
name|lexeme
expr_stmt|;
name|yychar
operator|=
name|yylexp
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|yylval
operator|=
name|yylvp
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yylloc
operator|=
name|yylpp
index|[
operator|-
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
name|yystack
operator|.
name|s_mark
operator|=
name|yystack
operator|.
name|s_base
operator|+
operator|(
name|yyerrctx
operator|->
name|yystack
operator|.
name|s_mark
operator|-
name|yyerrctx
operator|->
name|yystack
operator|.
name|s_base
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|yystack
operator|.
name|s_base
argument_list|,
name|yyerrctx
operator|->
name|yystack
operator|.
name|s_base
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|yystack
operator|.
name|s_mark
operator|-
name|yystack
operator|.
name|s_base
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|YYINT
argument_list|)
argument_list|)
expr_stmt|;
name|yystack
operator|.
name|l_mark
operator|=
name|yystack
operator|.
name|l_base
operator|+
operator|(
name|yyerrctx
operator|->
name|yystack
operator|.
name|l_mark
operator|-
name|yyerrctx
operator|->
name|yystack
operator|.
name|l_base
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|yystack
operator|.
name|l_base
argument_list|,
name|yyerrctx
operator|->
name|yystack
operator|.
name|l_base
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|yystack
operator|.
name|l_mark
operator|-
name|yystack
operator|.
name|l_base
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|YYSTYPE
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yystack
operator|.
name|p_mark
operator|=
name|yystack
operator|.
name|p_base
operator|+
operator|(
name|yyerrctx
operator|->
name|yystack
operator|.
name|p_mark
operator|-
name|yyerrctx
operator|->
name|yystack
operator|.
name|p_base
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|yystack
operator|.
name|p_base
argument_list|,
name|yyerrctx
operator|->
name|yystack
operator|.
name|p_base
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|yystack
operator|.
name|p_mark
operator|-
name|yystack
operator|.
name|p_base
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|YYLTYPE
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yystate
operator|=
name|yyerrctx
operator|->
name|state
expr_stmt|;
name|yyFreeState
argument_list|(
name|yyerrctx
argument_list|)
expr_stmt|;
name|yyerrctx
operator|=
name|NULL
expr_stmt|;
block|}
name|yynewerrflag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|yynewerrflag
operator|==
literal|0
condition|)
goto|goto
name|yyinrecovery
goto|;
endif|#
directive|endif
comment|/* YYBTYACC */
name|YYERROR_CALL
argument_list|(
literal|"syntax error"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yyerror_loc_range
index|[
literal|0
index|]
operator|=
name|yylloc
expr_stmt|;
comment|/* lookahead position is error start position */
endif|#
directive|endif
if|#
directive|if
operator|!
name|YYBTYACC
goto|goto
name|yyerrlab
goto|;
comment|/* redundant goto avoids 'unused label' warning */
name|yyerrlab
label|:
endif|#
directive|endif
operator|++
name|yynerrs
expr_stmt|;
name|yyinrecovery
label|:
if|if
condition|(
name|yyerrflag
operator|<
literal|3
condition|)
block|{
name|yyerrflag
operator|=
literal|3
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|yyn
operator|=
name|yysindex
index|[
operator|*
name|yystack
operator|.
name|s_mark
index|]
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|yyn
operator|+=
name|YYERRCODE
operator|)
operator|>=
literal|0
operator|&&
name|yyn
operator|<=
name|YYTABLESIZE
operator|&&
name|yycheck
index|[
name|yyn
index|]
operator|==
operator|(
name|YYINT
operator|)
name|YYERRCODE
condition|)
block|{
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s[%d]: state %d, error recovery shifting to state %d\n"
argument_list|,
name|YYDEBUGSTR
argument_list|,
name|yydepth
argument_list|,
operator|*
name|yystack
operator|.
name|s_mark
argument_list|,
name|yytable
index|[
name|yyn
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yystack
operator|.
name|s_mark
operator|>=
name|yystack
operator|.
name|s_last
operator|&&
name|yygrowstack
argument_list|(
operator|&
name|yystack
argument_list|)
operator|==
name|YYENOMEM
condition|)
goto|goto
name|yyoverflow
goto|;
name|yystate
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|s_mark
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|l_mark
operator|=
name|yylval
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
comment|/* lookahead position is error end position */
name|yyerror_loc_range
index|[
literal|1
index|]
operator|=
name|yylloc
expr_stmt|;
name|YYLLOC_DEFAULT
argument_list|(
name|yyloc
argument_list|,
name|yyerror_loc_range
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* position of error span */
operator|*
operator|++
name|yystack
operator|.
name|p_mark
operator|=
name|yyloc
expr_stmt|;
endif|#
directive|endif
goto|goto
name|yyloop
goto|;
block|}
else|else
block|{
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s[%d]: error recovery discarding state %d\n"
argument_list|,
name|YYDEBUGSTR
argument_list|,
name|yydepth
argument_list|,
operator|*
name|yystack
operator|.
name|s_mark
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yystack
operator|.
name|s_mark
operator|<=
name|yystack
operator|.
name|s_base
condition|)
goto|goto
name|yyabort
goto|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
comment|/* the current TOS position is the error start position */
name|yyerror_loc_range
index|[
literal|0
index|]
operator|=
operator|*
name|yystack
operator|.
name|p_mark
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|YYDESTRUCT_CALL
argument_list|)
if|#
directive|if
name|YYBTYACC
if|if
condition|(
operator|!
name|yytrial
condition|)
endif|#
directive|endif
comment|/* YYBTYACC */
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|YYDESTRUCT_CALL
argument_list|(
literal|"error: discarding state"
argument_list|,
name|yystos
index|[
operator|*
name|yystack
operator|.
name|s_mark
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
argument_list|,
name|yystack
operator|.
name|p_mark
argument_list|)
expr_stmt|;
else|#
directive|else
name|YYDESTRUCT_CALL
argument_list|(
literal|"error: discarding state"
argument_list|,
name|yystos
index|[
operator|*
name|yystack
operator|.
name|s_mark
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED) */
endif|#
directive|endif
comment|/* defined(YYDESTRUCT_CALL) */
operator|--
name|yystack
operator|.
name|s_mark
expr_stmt|;
operator|--
name|yystack
operator|.
name|l_mark
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
operator|--
name|yystack
operator|.
name|p_mark
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|yychar
operator|==
name|YYEOF
condition|)
goto|goto
name|yyabort
goto|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
if|if
condition|(
operator|(
name|yys
operator|=
name|yyname
index|[
name|YYTRANSLATE
argument_list|(
name|yychar
argument_list|)
index|]
operator|)
operator|==
name|NULL
condition|)
name|yys
operator|=
name|yyname
index|[
name|YYUNDFTOKEN
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s[%d]: state %d, error recovery discarding token %d (%s)\n"
argument_list|,
name|YYDEBUGSTR
argument_list|,
name|yydepth
argument_list|,
name|yystate
argument_list|,
name|yychar
argument_list|,
name|yys
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|YYDESTRUCT_CALL
argument_list|)
if|#
directive|if
name|YYBTYACC
if|if
condition|(
operator|!
name|yytrial
condition|)
endif|#
directive|endif
comment|/* YYBTYACC */
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|YYDESTRUCT_CALL
argument_list|(
literal|"error: discarding token"
argument_list|,
name|yychar
argument_list|,
operator|&
name|yylval
argument_list|,
operator|&
name|yylloc
argument_list|)
expr_stmt|;
else|#
directive|else
name|YYDESTRUCT_CALL
argument_list|(
literal|"error: discarding token"
argument_list|,
name|yychar
argument_list|,
operator|&
name|yylval
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED) */
endif|#
directive|endif
comment|/* defined(YYDESTRUCT_CALL) */
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
goto|goto
name|yyloop
goto|;
block|}
name|yyreduce
label|:
name|yym
operator|=
name|yylen
index|[
name|yyn
index|]
expr_stmt|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s[%d]: state %d, reducing by rule %d (%s)"
argument_list|,
name|YYDEBUGSTR
argument_list|,
name|yydepth
argument_list|,
name|yystate
argument_list|,
name|yyn
argument_list|,
name|yyrule
index|[
name|yyn
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|YYSTYPE_TOSTRING
if|#
directive|if
name|YYBTYACC
if|if
condition|(
operator|!
name|yytrial
condition|)
endif|#
directive|endif
comment|/* YYBTYACC */
if|if
condition|(
name|yym
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fputc
argument_list|(
literal|'<'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|yym
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|yym
condition|)
name|fputs
argument_list|(
literal|", "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|YYSTYPE_TOSTRING
argument_list|(
name|yystos
index|[
name|yystack
operator|.
name|s_mark
index|[
literal|1
operator|-
name|i
index|]
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
literal|1
operator|-
name|i
index|]
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'>'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|yym
operator|>
literal|0
condition|)
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
literal|1
operator|-
name|yym
index|]
expr_stmt|;
else|else
name|memset
argument_list|(
operator|&
name|yyval
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|yyval
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
comment|/* Perform position reduction */
name|memset
argument_list|(
operator|&
name|yyloc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|yyloc
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|YYBTYACC
if|if
condition|(
operator|!
name|yytrial
condition|)
endif|#
directive|endif
comment|/* YYBTYACC */
block|{
name|YYLLOC_DEFAULT
argument_list|(
name|yyloc
argument_list|,
operator|&
name|yystack
operator|.
name|p_mark
index|[
literal|1
operator|-
name|yym
index|]
argument_list|,
name|yym
argument_list|)
expr_stmt|;
comment|/* just in case YYERROR is invoked within the action, save            the start of the rhs as the error start position */
name|yyerror_loc_range
index|[
literal|0
index|]
operator|=
name|yystack
operator|.
name|p_mark
index|[
literal|1
operator|-
name|yym
index|]
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|yyn
condition|)
block|{
default|default:
break|break;
block|}
name|yystack
operator|.
name|s_mark
operator|-=
name|yym
expr_stmt|;
name|yystate
operator|=
operator|*
name|yystack
operator|.
name|s_mark
expr_stmt|;
name|yystack
operator|.
name|l_mark
operator|-=
name|yym
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yystack
operator|.
name|p_mark
operator|-=
name|yym
expr_stmt|;
endif|#
directive|endif
name|yym
operator|=
name|yylhs
index|[
name|yyn
index|]
expr_stmt|;
if|if
condition|(
name|yystate
operator|==
literal|0
operator|&&
name|yym
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s[%d]: after reduction, "
argument_list|,
name|YYDEBUGSTR
argument_list|,
name|yydepth
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|YYSTYPE_TOSTRING
if|#
directive|if
name|YYBTYACC
if|if
condition|(
operator|!
name|yytrial
condition|)
endif|#
directive|endif
comment|/* YYBTYACC */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"result is<%s>, "
argument_list|,
name|YYSTYPE_TOSTRING
argument_list|(
name|yystos
index|[
name|YYFINAL
index|]
argument_list|,
name|yyval
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"shifting from state 0 to final state %d\n"
argument_list|,
name|YYFINAL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|yystate
operator|=
name|YYFINAL
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|s_mark
operator|=
name|YYFINAL
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|l_mark
operator|=
name|yyval
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
operator|*
operator|++
name|yystack
operator|.
name|p_mark
operator|=
name|yyloc
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|YYBTYACC
do|do
block|{
if|if
condition|(
name|yylvp
operator|<
name|yylve
condition|)
block|{
comment|/* we're currently re-reading tokens */
name|yylval
operator|=
operator|*
name|yylvp
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yylloc
operator|=
operator|*
name|yylpp
operator|++
expr_stmt|;
endif|#
directive|endif
name|yychar
operator|=
operator|*
name|yylexp
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|yyps
operator|->
name|save
condition|)
block|{
comment|/* in trial mode; save scanner results for future parse attempts */
if|if
condition|(
name|yylvp
operator|==
name|yylvlim
condition|)
block|{
comment|/* Enlarge lexical value queue */
name|size_t
name|p
init|=
call|(
name|size_t
call|)
argument_list|(
name|yylvp
operator|-
name|yylvals
argument_list|)
decl_stmt|;
name|size_t
name|s
init|=
call|(
name|size_t
call|)
argument_list|(
name|yylvlim
operator|-
name|yylvals
argument_list|)
decl_stmt|;
name|s
operator|+=
name|YYLVQUEUEGROWTH
expr_stmt|;
if|if
condition|(
operator|(
name|yylexemes
operator|=
operator|(
name|short
operator|*
operator|)
name|realloc
argument_list|(
name|yylexemes
argument_list|,
name|s
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|yyenomem
goto|;
if|if
condition|(
operator|(
name|yylvals
operator|=
operator|(
name|YYSTYPE
operator|*
operator|)
name|realloc
argument_list|(
name|yylvals
argument_list|,
name|s
operator|*
sizeof|sizeof
argument_list|(
name|YYSTYPE
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|yyenomem
goto|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
if|if
condition|(
operator|(
name|yylpsns
operator|=
operator|(
name|YYLTYPE
operator|*
operator|)
name|realloc
argument_list|(
name|yylpsns
argument_list|,
name|s
operator|*
sizeof|sizeof
argument_list|(
name|YYLTYPE
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|yyenomem
goto|;
endif|#
directive|endif
name|yylvp
operator|=
name|yylve
operator|=
name|yylvals
operator|+
name|p
expr_stmt|;
name|yylvlim
operator|=
name|yylvals
operator|+
name|s
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yylpp
operator|=
name|yylpe
operator|=
name|yylpsns
operator|+
name|p
expr_stmt|;
name|yylplim
operator|=
name|yylpsns
operator|+
name|s
expr_stmt|;
endif|#
directive|endif
name|yylexp
operator|=
name|yylexemes
operator|+
name|p
expr_stmt|;
block|}
operator|*
name|yylexp
operator|=
operator|(
name|short
operator|)
name|YYLEX
expr_stmt|;
operator|*
name|yylvp
operator|++
operator|=
name|yylval
expr_stmt|;
name|yylve
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
operator|*
name|yylpp
operator|++
operator|=
name|yylloc
expr_stmt|;
name|yylpe
operator|++
expr_stmt|;
endif|#
directive|endif
name|yychar
operator|=
operator|*
name|yylexp
operator|++
expr_stmt|;
break|break;
block|}
comment|/* normal operation, no conflict encountered */
endif|#
directive|endif
comment|/* YYBTYACC */
name|yychar
operator|=
name|YYLEX
expr_stmt|;
if|#
directive|if
name|YYBTYACC
block|}
do|while
condition|(
literal|0
condition|)
do|;
endif|#
directive|endif
comment|/* YYBTYACC */
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
name|yychar
operator|=
name|YYEOF
expr_stmt|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
if|if
condition|(
operator|(
name|yys
operator|=
name|yyname
index|[
name|YYTRANSLATE
argument_list|(
name|yychar
argument_list|)
index|]
operator|)
operator|==
name|NULL
condition|)
name|yys
operator|=
name|yyname
index|[
name|YYUNDFTOKEN
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s[%d]: state %d, reading token %d (%s)\n"
argument_list|,
name|YYDEBUGSTR
argument_list|,
name|yydepth
argument_list|,
name|YYFINAL
argument_list|,
name|yychar
argument_list|,
name|yys
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|yychar
operator|==
name|YYEOF
condition|)
goto|goto
name|yyaccept
goto|;
goto|goto
name|yyloop
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|yyn
operator|=
name|yygindex
index|[
name|yym
index|]
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|yyn
operator|+=
name|yystate
operator|)
operator|>=
literal|0
operator|&&
name|yyn
operator|<=
name|YYTABLESIZE
operator|&&
name|yycheck
index|[
name|yyn
index|]
operator|==
operator|(
name|YYINT
operator|)
name|yystate
condition|)
name|yystate
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
else|else
name|yystate
operator|=
name|yydgoto
index|[
name|yym
index|]
expr_stmt|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s[%d]: after reduction, "
argument_list|,
name|YYDEBUGSTR
argument_list|,
name|yydepth
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|YYSTYPE_TOSTRING
if|#
directive|if
name|YYBTYACC
if|if
condition|(
operator|!
name|yytrial
condition|)
endif|#
directive|endif
comment|/* YYBTYACC */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"result is<%s>, "
argument_list|,
name|YYSTYPE_TOSTRING
argument_list|(
name|yystos
index|[
name|yystate
index|]
argument_list|,
name|yyval
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"shifting from state %d to state %d\n"
argument_list|,
operator|*
name|yystack
operator|.
name|s_mark
argument_list|,
name|yystate
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|yystack
operator|.
name|s_mark
operator|>=
name|yystack
operator|.
name|s_last
operator|&&
name|yygrowstack
argument_list|(
operator|&
name|yystack
argument_list|)
operator|==
name|YYENOMEM
condition|)
goto|goto
name|yyoverflow
goto|;
operator|*
operator|++
name|yystack
operator|.
name|s_mark
operator|=
operator|(
name|YYINT
operator|)
name|yystate
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|l_mark
operator|=
name|yyval
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
operator|*
operator|++
name|yystack
operator|.
name|p_mark
operator|=
name|yyloc
expr_stmt|;
endif|#
directive|endif
goto|goto
name|yyloop
goto|;
if|#
directive|if
name|YYBTYACC
comment|/* Reduction declares that this path is valid. Set yypath and do a full parse */
name|yyvalid
label|:
if|if
condition|(
name|yypath
condition|)
name|YYABORT
expr_stmt|;
while|while
condition|(
name|yyps
operator|->
name|save
condition|)
block|{
name|YYParseState
modifier|*
name|save
init|=
name|yyps
operator|->
name|save
decl_stmt|;
name|yyps
operator|->
name|save
operator|=
name|save
operator|->
name|save
expr_stmt|;
name|save
operator|->
name|save
operator|=
name|yypath
expr_stmt|;
name|yypath
operator|=
name|save
expr_stmt|;
block|}
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s[%d]: state %d, CONFLICT trial successful, backtracking to state %d, %d tokens\n"
argument_list|,
name|YYDEBUGSTR
argument_list|,
name|yydepth
argument_list|,
name|yystate
argument_list|,
name|yypath
operator|->
name|state
argument_list|,
call|(
name|int
call|)
argument_list|(
name|yylvp
operator|-
name|yylvals
operator|-
name|yypath
operator|->
name|lexeme
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yyerrctx
condition|)
block|{
name|yyFreeState
argument_list|(
name|yyerrctx
argument_list|)
expr_stmt|;
name|yyerrctx
operator|=
name|NULL
expr_stmt|;
block|}
name|yylvp
operator|=
name|yylvals
operator|+
name|yypath
operator|->
name|lexeme
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yylpp
operator|=
name|yylpsns
operator|+
name|yypath
operator|->
name|lexeme
expr_stmt|;
endif|#
directive|endif
name|yylexp
operator|=
name|yylexemes
operator|+
name|yypath
operator|->
name|lexeme
expr_stmt|;
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
name|yystack
operator|.
name|s_mark
operator|=
name|yystack
operator|.
name|s_base
operator|+
operator|(
name|yypath
operator|->
name|yystack
operator|.
name|s_mark
operator|-
name|yypath
operator|->
name|yystack
operator|.
name|s_base
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|yystack
operator|.
name|s_base
argument_list|,
name|yypath
operator|->
name|yystack
operator|.
name|s_base
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|yystack
operator|.
name|s_mark
operator|-
name|yystack
operator|.
name|s_base
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|YYINT
argument_list|)
argument_list|)
expr_stmt|;
name|yystack
operator|.
name|l_mark
operator|=
name|yystack
operator|.
name|l_base
operator|+
operator|(
name|yypath
operator|->
name|yystack
operator|.
name|l_mark
operator|-
name|yypath
operator|->
name|yystack
operator|.
name|l_base
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|yystack
operator|.
name|l_base
argument_list|,
name|yypath
operator|->
name|yystack
operator|.
name|l_base
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|yystack
operator|.
name|l_mark
operator|-
name|yystack
operator|.
name|l_base
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|YYSTYPE
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|yystack
operator|.
name|p_mark
operator|=
name|yystack
operator|.
name|p_base
operator|+
operator|(
name|yypath
operator|->
name|yystack
operator|.
name|p_mark
operator|-
name|yypath
operator|->
name|yystack
operator|.
name|p_base
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|yystack
operator|.
name|p_base
argument_list|,
name|yypath
operator|->
name|yystack
operator|.
name|p_base
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|yystack
operator|.
name|p_mark
operator|-
name|yystack
operator|.
name|p_base
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|YYLTYPE
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yystate
operator|=
name|yypath
operator|->
name|state
expr_stmt|;
goto|goto
name|yyloop
goto|;
endif|#
directive|endif
comment|/* YYBTYACC */
name|yyoverflow
label|:
name|YYERROR_CALL
argument_list|(
literal|"yacc stack overflow"
argument_list|)
expr_stmt|;
if|#
directive|if
name|YYBTYACC
goto|goto
name|yyabort_nomem
goto|;
name|yyenomem
label|:
name|YYERROR_CALL
argument_list|(
literal|"memory exhausted"
argument_list|)
expr_stmt|;
name|yyabort_nomem
label|:
endif|#
directive|endif
comment|/* YYBTYACC */
name|yyresult
operator|=
literal|2
expr_stmt|;
goto|goto
name|yyreturn
goto|;
name|yyabort
label|:
name|yyresult
operator|=
literal|1
expr_stmt|;
goto|goto
name|yyreturn
goto|;
name|yyaccept
label|:
if|#
directive|if
name|YYBTYACC
if|if
condition|(
name|yyps
operator|->
name|save
condition|)
goto|goto
name|yyvalid
goto|;
endif|#
directive|endif
comment|/* YYBTYACC */
name|yyresult
operator|=
literal|0
expr_stmt|;
name|yyreturn
label|:
if|#
directive|if
name|defined
argument_list|(
name|YYDESTRUCT_CALL
argument_list|)
if|if
condition|(
name|yychar
operator|!=
name|YYEOF
operator|&&
name|yychar
operator|!=
name|YYEMPTY
condition|)
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|YYDESTRUCT_CALL
argument_list|(
literal|"cleanup: discarding token"
argument_list|,
name|yychar
argument_list|,
operator|&
name|yylval
argument_list|,
operator|&
name|yylloc
argument_list|)
expr_stmt|;
else|#
directive|else
name|YYDESTRUCT_CALL
argument_list|(
literal|"cleanup: discarding token"
argument_list|,
name|yychar
argument_list|,
operator|&
name|yylval
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED) */
block|{
name|YYSTYPE
modifier|*
name|pv
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYLTYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|YYLTYPE_IS_DECLARED
argument_list|)
name|YYLTYPE
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pv
operator|=
name|yystack
operator|.
name|l_base
operator|,
name|pp
operator|=
name|yystack
operator|.
name|p_base
init|;
name|pv
operator|<=
name|yystack
operator|.
name|l_mark
condition|;
operator|++
name|pv
operator|,
operator|++
name|pp
control|)
name|YYDESTRUCT_CALL
argument_list|(
literal|"cleanup: discarding state"
argument_list|,
name|yystos
index|[
operator|*
operator|(
name|yystack
operator|.
name|s_base
operator|+
operator|(
name|pv
operator|-
name|yystack
operator|.
name|l_base
operator|)
operator|)
index|]
argument_list|,
name|pv
argument_list|,
name|pp
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|pv
operator|=
name|yystack
operator|.
name|l_base
init|;
name|pv
operator|<=
name|yystack
operator|.
name|l_mark
condition|;
operator|++
name|pv
control|)
name|YYDESTRUCT_CALL
argument_list|(
literal|"cleanup: discarding state"
argument_list|,
name|yystos
index|[
operator|*
operator|(
name|yystack
operator|.
name|s_base
operator|+
operator|(
name|pv
operator|-
name|yystack
operator|.
name|l_base
operator|)
operator|)
index|]
argument_list|,
name|pv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED) */
block|}
endif|#
directive|endif
comment|/* defined(YYDESTRUCT_CALL) */
if|#
directive|if
name|YYBTYACC
if|if
condition|(
name|yyerrctx
condition|)
block|{
name|yyFreeState
argument_list|(
name|yyerrctx
argument_list|)
expr_stmt|;
name|yyerrctx
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|yyps
condition|)
block|{
name|YYParseState
modifier|*
name|save
init|=
name|yyps
decl_stmt|;
name|yyps
operator|=
name|save
operator|->
name|save
expr_stmt|;
name|save
operator|->
name|save
operator|=
name|NULL
expr_stmt|;
name|yyFreeState
argument_list|(
name|save
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|yypath
condition|)
block|{
name|YYParseState
modifier|*
name|save
init|=
name|yypath
decl_stmt|;
name|yypath
operator|=
name|save
operator|->
name|save
expr_stmt|;
name|save
operator|->
name|save
operator|=
name|NULL
expr_stmt|;
name|yyFreeState
argument_list|(
name|save
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* YYBTYACC */
name|yyfreestack
argument_list|(
operator|&
name|yystack
argument_list|)
expr_stmt|;
return|return
operator|(
name|yyresult
operator|)
return|;
block|}
end_function

end_unit

