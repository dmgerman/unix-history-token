begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* original parser id follows */
end_comment

begin_comment
comment|/* yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93" */
end_comment

begin_comment
comment|/* (use YYMAJOR/YYMINOR for ifdefs dependent on parser version) */
end_comment

begin_define
define|#
directive|define
name|YYBYACC
value|1
end_define

begin_define
define|#
directive|define
name|YYMAJOR
value|1
end_define

begin_define
define|#
directive|define
name|YYMINOR
value|9
end_define

begin_define
define|#
directive|define
name|YYCHECK
value|"yyyymmdd"
end_define

begin_define
define|#
directive|define
name|YYEMPTY
value|(-1)
end_define

begin_define
define|#
directive|define
name|yyclearin
value|(yychar = YYEMPTY)
end_define

begin_define
define|#
directive|define
name|yyerrok
value|(yyerrflag = 0)
end_define

begin_define
define|#
directive|define
name|YYRECOVERING
parameter_list|()
value|(yyerrflag != 0)
end_define

begin_define
define|#
directive|define
name|YYENOMEM
value|(-2)
end_define

begin_define
define|#
directive|define
name|YYEOF
value|0
end_define

begin_line
line|#
directive|line
number|17
file|"rename_debug.c"
end_line

begin_include
include|#
directive|include
file|"rename_debug.i"
end_include

begin_include
include|#
directive|include
file|"rename_debug.h"
end_include

begin_typedef
typedef|typedef
name|int
name|YYINT
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yylhs
index|[]
init|=
block|{
operator|-
literal|1
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yylen
index|[]
init|=
block|{
literal|2
block|,
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yydefred
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yydgoto
index|[]
init|=
block|{
literal|2
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yysindex
index|[]
init|=
block|{
operator|-
literal|256
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yyrindex
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yygindex
index|[]
init|=
block|{
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYTABLESIZE
value|0
end_define

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yytable
index|[]
init|=
block|{
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|YYINT
name|yycheck
index|[]
init|=
block|{
literal|256
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYFINAL
value|2
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|YYDEBUG
end_ifndef

begin_define
define|#
directive|define
name|YYDEBUG
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|YYMAXTOKEN
value|256
end_define

begin_define
define|#
directive|define
name|YYUNDFTOKEN
value|259
end_define

begin_define
define|#
directive|define
name|YYTRANSLATE
parameter_list|(
name|a
parameter_list|)
value|((a)> YYMAXTOKEN ? YYUNDFTOKEN : (a))
end_define

begin_if
if|#
directive|if
name|YYDEBUG
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|yyname
index|[]
init|=
block|{
literal|"end-of-file"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"illegal-symbol"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|yyrule
index|[]
init|=
block|{
literal|"$accept : S"
block|,
literal|"S : error"
block|,  }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|yydebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yynerrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yyerrflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YYSTYPE
name|yyval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YYSTYPE
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* define the initial stack-sizes */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYSTACKSIZE
end_ifdef

begin_undef
undef|#
directive|undef
name|YYMAXDEPTH
end_undef

begin_define
define|#
directive|define
name|YYMAXDEPTH
value|YYSTACKSIZE
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|YYMAXDEPTH
end_ifdef

begin_define
define|#
directive|define
name|YYSTACKSIZE
value|YYMAXDEPTH
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYSTACKSIZE
value|10000
end_define

begin_define
define|#
directive|define
name|YYMAXDEPTH
value|10000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|YYINITSTACKSIZE
value|200
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|stacksize
decl_stmt|;
name|YYINT
modifier|*
name|s_base
decl_stmt|;
name|YYINT
modifier|*
name|s_mark
decl_stmt|;
name|YYINT
modifier|*
name|s_last
decl_stmt|;
name|YYSTYPE
modifier|*
name|l_base
decl_stmt|;
name|YYSTYPE
modifier|*
name|l_mark
decl_stmt|;
block|}
name|YYSTACKDATA
typedef|;
end_typedef

begin_comment
comment|/* variables for the parser stack */
end_comment

begin_decl_stmt
specifier|static
name|YYSTACKDATA
name|yystack
decl_stmt|;
end_decl_stmt

begin_line
line|#
directive|line
number|12
file|"code_debug.y"
end_line

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|YYBYACC
end_ifdef

begin_function_decl
specifier|extern
name|int
name|YYLEX_DECL
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"yyparse() = %d\n"
argument_list|,
name|yyparse
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|yylex
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|yyerror
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_line
line|#
directive|line
number|130
file|"rename_debug.c"
end_line

begin_if
if|#
directive|if
name|YYDEBUG
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* needed for printf */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* needed for malloc, etc */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* needed for memset */
end_comment

begin_comment
comment|/* allocate initial stack or double stack size, up to YYMAXDEPTH */
end_comment

begin_function
specifier|static
name|int
name|yygrowstack
parameter_list|(
name|YYSTACKDATA
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|newsize
decl_stmt|;
name|YYINT
modifier|*
name|newss
decl_stmt|;
name|YYSTYPE
modifier|*
name|newvs
decl_stmt|;
if|if
condition|(
operator|(
name|newsize
operator|=
name|data
operator|->
name|stacksize
operator|)
operator|==
literal|0
condition|)
name|newsize
operator|=
name|YYINITSTACKSIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|newsize
operator|>=
name|YYMAXDEPTH
condition|)
return|return
name|YYENOMEM
return|;
elseif|else
if|if
condition|(
operator|(
name|newsize
operator|*=
literal|2
operator|)
operator|>
name|YYMAXDEPTH
condition|)
name|newsize
operator|=
name|YYMAXDEPTH
expr_stmt|;
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|data
operator|->
name|s_mark
operator|-
name|data
operator|->
name|s_base
argument_list|)
expr_stmt|;
name|newss
operator|=
operator|(
name|YYINT
operator|*
operator|)
name|realloc
argument_list|(
name|data
operator|->
name|s_base
argument_list|,
name|newsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newss
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newss
operator|==
literal|0
condition|)
return|return
name|YYENOMEM
return|;
name|data
operator|->
name|s_base
operator|=
name|newss
expr_stmt|;
name|data
operator|->
name|s_mark
operator|=
name|newss
operator|+
name|i
expr_stmt|;
name|newvs
operator|=
operator|(
name|YYSTYPE
operator|*
operator|)
name|realloc
argument_list|(
name|data
operator|->
name|l_base
argument_list|,
name|newsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newvs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvs
operator|==
literal|0
condition|)
return|return
name|YYENOMEM
return|;
name|data
operator|->
name|l_base
operator|=
name|newvs
expr_stmt|;
name|data
operator|->
name|l_mark
operator|=
name|newvs
operator|+
name|i
expr_stmt|;
name|data
operator|->
name|stacksize
operator|=
name|newsize
expr_stmt|;
name|data
operator|->
name|s_last
operator|=
name|data
operator|->
name|s_base
operator|+
name|newsize
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|YYPURE
operator|||
name|defined
argument_list|(
name|YY_NO_LEAKS
argument_list|)
end_if

begin_function
specifier|static
name|void
name|yyfreestack
parameter_list|(
name|YYSTACKDATA
modifier|*
name|data
parameter_list|)
block|{
name|free
argument_list|(
name|data
operator|->
name|s_base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
operator|->
name|l_base
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|yyfreestack
parameter_list|(
name|data
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|YYABORT
value|goto yyabort
end_define

begin_define
define|#
directive|define
name|YYREJECT
value|goto yyabort
end_define

begin_define
define|#
directive|define
name|YYACCEPT
value|goto yyaccept
end_define

begin_define
define|#
directive|define
name|YYERROR
value|goto yyerrlab
end_define

begin_function
name|int
name|YYPARSE_DECL
parameter_list|()
block|{
name|int
name|yym
decl_stmt|,
name|yyn
decl_stmt|,
name|yystate
decl_stmt|;
if|#
directive|if
name|YYDEBUG
specifier|const
name|char
modifier|*
name|yys
decl_stmt|;
if|if
condition|(
operator|(
name|yys
operator|=
name|getenv
argument_list|(
literal|"YYDEBUG"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|yyn
operator|=
operator|*
name|yys
expr_stmt|;
if|if
condition|(
name|yyn
operator|>=
literal|'0'
operator|&&
name|yyn
operator|<=
literal|'9'
condition|)
name|yydebug
operator|=
name|yyn
operator|-
literal|'0'
expr_stmt|;
block|}
endif|#
directive|endif
name|yym
operator|=
literal|0
expr_stmt|;
name|yyn
operator|=
literal|0
expr_stmt|;
name|yynerrs
operator|=
literal|0
expr_stmt|;
name|yyerrflag
operator|=
literal|0
expr_stmt|;
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
name|yystate
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|YYPURE
name|memset
argument_list|(
operator|&
name|yystack
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|yystack
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yystack
operator|.
name|s_base
operator|==
name|NULL
operator|&&
name|yygrowstack
argument_list|(
operator|&
name|yystack
argument_list|)
operator|==
name|YYENOMEM
condition|)
goto|goto
name|yyoverflow
goto|;
name|yystack
operator|.
name|s_mark
operator|=
name|yystack
operator|.
name|s_base
expr_stmt|;
name|yystack
operator|.
name|l_mark
operator|=
name|yystack
operator|.
name|l_base
expr_stmt|;
name|yystate
operator|=
literal|0
expr_stmt|;
operator|*
name|yystack
operator|.
name|s_mark
operator|=
literal|0
expr_stmt|;
name|yyloop
label|:
if|if
condition|(
operator|(
name|yyn
operator|=
name|yydefred
index|[
name|yystate
index|]
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|yyreduce
goto|;
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
block|{
name|yychar
operator|=
name|YYLEX
expr_stmt|;
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
name|yychar
operator|=
name|YYEOF
expr_stmt|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
if|if
condition|(
operator|(
name|yys
operator|=
name|yyname
index|[
name|YYTRANSLATE
argument_list|(
name|yychar
argument_list|)
index|]
operator|)
operator|==
name|NULL
condition|)
name|yys
operator|=
name|yyname
index|[
name|YYUNDFTOKEN
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%sdebug: state %d, reading %d (%s)\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|yystate
argument_list|,
name|yychar
argument_list|,
name|yys
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
operator|(
name|yyn
operator|=
name|yysindex
index|[
name|yystate
index|]
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|yyn
operator|+=
name|yychar
operator|)
operator|>=
literal|0
operator|&&
name|yyn
operator|<=
name|YYTABLESIZE
operator|&&
name|yycheck
index|[
name|yyn
index|]
operator|==
operator|(
name|YYINT
operator|)
name|yychar
condition|)
block|{
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"%sdebug: state %d, shifting to state %d\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|yystate
argument_list|,
name|yytable
index|[
name|yyn
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yystack
operator|.
name|s_mark
operator|>=
name|yystack
operator|.
name|s_last
operator|&&
name|yygrowstack
argument_list|(
operator|&
name|yystack
argument_list|)
operator|==
name|YYENOMEM
condition|)
goto|goto
name|yyoverflow
goto|;
name|yystate
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|s_mark
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|l_mark
operator|=
name|yylval
expr_stmt|;
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
if|if
condition|(
name|yyerrflag
operator|>
literal|0
condition|)
operator|--
name|yyerrflag
expr_stmt|;
goto|goto
name|yyloop
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|yyn
operator|=
name|yyrindex
index|[
name|yystate
index|]
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|yyn
operator|+=
name|yychar
operator|)
operator|>=
literal|0
operator|&&
name|yyn
operator|<=
name|YYTABLESIZE
operator|&&
name|yycheck
index|[
name|yyn
index|]
operator|==
operator|(
name|YYINT
operator|)
name|yychar
condition|)
block|{
name|yyn
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
goto|goto
name|yyreduce
goto|;
block|}
if|if
condition|(
name|yyerrflag
operator|!=
literal|0
condition|)
goto|goto
name|yyinrecovery
goto|;
name|YYERROR_CALL
argument_list|(
literal|"syntax error"
argument_list|)
expr_stmt|;
goto|goto
name|yyerrlab
goto|;
comment|/* redundant goto avoids 'unused label' warning */
name|yyerrlab
label|:
operator|++
name|yynerrs
expr_stmt|;
name|yyinrecovery
label|:
if|if
condition|(
name|yyerrflag
operator|<
literal|3
condition|)
block|{
name|yyerrflag
operator|=
literal|3
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|yyn
operator|=
name|yysindex
index|[
operator|*
name|yystack
operator|.
name|s_mark
index|]
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|yyn
operator|+=
name|YYERRCODE
operator|)
operator|>=
literal|0
operator|&&
name|yyn
operator|<=
name|YYTABLESIZE
operator|&&
name|yycheck
index|[
name|yyn
index|]
operator|==
operator|(
name|YYINT
operator|)
name|YYERRCODE
condition|)
block|{
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"%sdebug: state %d, error recovery shifting\  to state %d\n"
argument_list|,
name|YYPREFIX
argument_list|,
operator|*
name|yystack
operator|.
name|s_mark
argument_list|,
name|yytable
index|[
name|yyn
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yystack
operator|.
name|s_mark
operator|>=
name|yystack
operator|.
name|s_last
operator|&&
name|yygrowstack
argument_list|(
operator|&
name|yystack
argument_list|)
operator|==
name|YYENOMEM
condition|)
goto|goto
name|yyoverflow
goto|;
name|yystate
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|s_mark
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|l_mark
operator|=
name|yylval
expr_stmt|;
goto|goto
name|yyloop
goto|;
block|}
else|else
block|{
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"%sdebug: error recovery discarding state %d\n"
argument_list|,
name|YYPREFIX
argument_list|,
operator|*
name|yystack
operator|.
name|s_mark
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yystack
operator|.
name|s_mark
operator|<=
name|yystack
operator|.
name|s_base
condition|)
goto|goto
name|yyabort
goto|;
operator|--
name|yystack
operator|.
name|s_mark
expr_stmt|;
operator|--
name|yystack
operator|.
name|l_mark
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|yychar
operator|==
name|YYEOF
condition|)
goto|goto
name|yyabort
goto|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
if|if
condition|(
operator|(
name|yys
operator|=
name|yyname
index|[
name|YYTRANSLATE
argument_list|(
name|yychar
argument_list|)
index|]
operator|)
operator|==
name|NULL
condition|)
name|yys
operator|=
name|yyname
index|[
name|YYUNDFTOKEN
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%sdebug: state %d, error recovery discards token %d (%s)\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|yystate
argument_list|,
name|yychar
argument_list|,
name|yys
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
goto|goto
name|yyloop
goto|;
block|}
name|yyreduce
label|:
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"%sdebug: state %d, reducing by rule %d (%s)\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|yystate
argument_list|,
name|yyn
argument_list|,
name|yyrule
index|[
name|yyn
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yym
operator|=
name|yylen
index|[
name|yyn
index|]
expr_stmt|;
if|if
condition|(
name|yym
operator|>
literal|0
condition|)
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
literal|1
operator|-
name|yym
index|]
expr_stmt|;
else|else
name|memset
argument_list|(
operator|&
name|yyval
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|yyval
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yyn
condition|)
block|{     }
name|yystack
operator|.
name|s_mark
operator|-=
name|yym
expr_stmt|;
name|yystate
operator|=
operator|*
name|yystack
operator|.
name|s_mark
expr_stmt|;
name|yystack
operator|.
name|l_mark
operator|-=
name|yym
expr_stmt|;
name|yym
operator|=
name|yylhs
index|[
name|yyn
index|]
expr_stmt|;
if|if
condition|(
name|yystate
operator|==
literal|0
operator|&&
name|yym
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"%sdebug: after reduction, shifting from state 0 to\  state %d\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|YYFINAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yystate
operator|=
name|YYFINAL
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|s_mark
operator|=
name|YYFINAL
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|l_mark
operator|=
name|yyval
expr_stmt|;
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
block|{
name|yychar
operator|=
name|YYLEX
expr_stmt|;
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
name|yychar
operator|=
name|YYEOF
expr_stmt|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
if|if
condition|(
operator|(
name|yys
operator|=
name|yyname
index|[
name|YYTRANSLATE
argument_list|(
name|yychar
argument_list|)
index|]
operator|)
operator|==
name|NULL
condition|)
name|yys
operator|=
name|yyname
index|[
name|YYUNDFTOKEN
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%sdebug: state %d, reading %d (%s)\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|YYFINAL
argument_list|,
name|yychar
argument_list|,
name|yys
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|yychar
operator|==
name|YYEOF
condition|)
goto|goto
name|yyaccept
goto|;
goto|goto
name|yyloop
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|yyn
operator|=
name|yygindex
index|[
name|yym
index|]
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|yyn
operator|+=
name|yystate
operator|)
operator|>=
literal|0
operator|&&
name|yyn
operator|<=
name|YYTABLESIZE
operator|&&
name|yycheck
index|[
name|yyn
index|]
operator|==
operator|(
name|YYINT
operator|)
name|yystate
condition|)
name|yystate
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
else|else
name|yystate
operator|=
name|yydgoto
index|[
name|yym
index|]
expr_stmt|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"%sdebug: after reduction, shifting from state %d \ to state %d\n"
argument_list|,
name|YYPREFIX
argument_list|,
operator|*
name|yystack
operator|.
name|s_mark
argument_list|,
name|yystate
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yystack
operator|.
name|s_mark
operator|>=
name|yystack
operator|.
name|s_last
operator|&&
name|yygrowstack
argument_list|(
operator|&
name|yystack
argument_list|)
operator|==
name|YYENOMEM
condition|)
goto|goto
name|yyoverflow
goto|;
operator|*
operator|++
name|yystack
operator|.
name|s_mark
operator|=
operator|(
name|YYINT
operator|)
name|yystate
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|l_mark
operator|=
name|yyval
expr_stmt|;
goto|goto
name|yyloop
goto|;
name|yyoverflow
label|:
name|YYERROR_CALL
argument_list|(
literal|"yacc stack overflow"
argument_list|)
expr_stmt|;
name|yyabort
label|:
name|yyfreestack
argument_list|(
operator|&
name|yystack
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|yyaccept
label|:
name|yyfreestack
argument_list|(
operator|&
name|yystack
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

