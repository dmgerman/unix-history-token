begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: reader.c,v 1.38 2014/01/01 14:23:27 Christos.Zoulas Exp $ */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/*  The line size must be a positive integer.  One hundred was chosen	*/
end_comment

begin_comment
comment|/*  because few lines in Yacc input grammars exceed 100 characters.	*/
end_comment

begin_comment
comment|/*  Note that if a line exceeds LINESIZE characters, the line buffer	*/
end_comment

begin_comment
comment|/*  will be expanded to accomodate it.					*/
end_comment

begin_define
define|#
directive|define
name|LINESIZE
value|100
end_define

begin_define
define|#
directive|define
name|L_CURL
value|'{'
end_define

begin_define
define|#
directive|define
name|R_CURL
value|'}'
end_define

begin_function_decl
specifier|static
name|void
name|start_rule
parameter_list|(
name|bucket
modifier|*
name|bp
parameter_list|,
name|int
name|s_lineno
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cinc
decl_stmt|,
name|cache_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ntags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tagmax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|tag_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|saw_eof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|unionized
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cptr
decl_stmt|,
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|linesize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bucket
modifier|*
name|goal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Value_t
name|prec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gensym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|last_was_action
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maxitems
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bucket
modifier|*
modifier|*
name|pitem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maxrules
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bucket
modifier|*
modifier|*
name|plhs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|name_pool_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|name_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|line_format
index|[]
init|=
literal|"#line %d \"%s\"\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|param
modifier|*
name|lex_param
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|param
modifier|*
name|parse_param
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|cachec
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|assert
argument_list|(
name|cinc
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinc
operator|>=
name|cache_size
condition|)
block|{
name|cache_size
operator|+=
literal|256
expr_stmt|;
name|cache
operator|=
name|TREALLOC
argument_list|(
name|char
argument_list|,
name|cache
argument_list|,
name|cache_size
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
name|cache
index|[
name|cinc
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
operator|++
name|cinc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_line
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|input_file
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|saw_eof
operator|||
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|line
condition|)
block|{
name|FREE
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
literal|0
expr_stmt|;
block|}
name|cptr
operator|=
literal|0
expr_stmt|;
name|saw_eof
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|line
operator|==
literal|0
operator|||
name|linesize
operator|!=
operator|(
name|LINESIZE
operator|+
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|line
condition|)
name|FREE
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|linesize
operator|=
name|LINESIZE
operator|+
literal|1
expr_stmt|;
name|line
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|linesize
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
operator|++
name|lineno
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|line
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|cptr
operator|=
name|line
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|++
name|i
operator|>=
name|linesize
condition|)
block|{
name|linesize
operator|+=
name|LINESIZE
expr_stmt|;
name|line
operator|=
name|TREALLOC
argument_list|(
name|char
argument_list|,
name|line
argument_list|,
name|linesize
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|line
index|[
name|i
index|]
operator|=
literal|'\n'
expr_stmt|;
name|saw_eof
operator|=
literal|1
expr_stmt|;
name|cptr
operator|=
name|line
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|dup_line
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\n'
condition|)
operator|++
name|s
expr_stmt|;
name|p
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|s
operator|-
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|s
operator|=
name|line
expr_stmt|;
name|t
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
continue|continue;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|skip_comment
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|st_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|st_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|st_cptr
init|=
name|st_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|)
decl_stmt|;
name|s
operator|=
name|cptr
operator|+
literal|2
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|cptr
operator|=
name|s
operator|+
literal|2
expr_stmt|;
name|FREE
argument_list|(
name|st_line
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_comment
argument_list|(
name|st_lineno
argument_list|,
name|st_line
argument_list|,
name|st_cptr
argument_list|)
expr_stmt|;
name|s
operator|=
name|cptr
expr_stmt|;
block|}
else|else
operator|++
name|s
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nextc
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
block|}
name|s
operator|=
name|cptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\n'
case|:
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
name|s
operator|=
name|cptr
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\v'
case|:
case|case
literal|','
case|:
case|case
literal|';'
case|:
operator|++
name|s
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|cptr
operator|=
name|s
expr_stmt|;
return|return
operator|(
literal|'%'
operator|)
return|;
case|case
literal|'/'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|cptr
operator|=
name|s
expr_stmt|;
name|skip_comment
argument_list|()
expr_stmt|;
name|s
operator|=
name|cptr
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
name|s
operator|=
name|cptr
expr_stmt|;
break|break;
block|}
comment|/* FALLTHRU */
default|default:
name|cptr
operator|=
name|s
expr_stmt|;
return|return
operator|(
operator|*
name|s
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Compare keyword to cached token, treating '_' and '-' the same.  Some  * grammars rely upon this misfeature.  */
end_comment

begin_function
specifier|static
name|int
name|matchec
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|cache
decl_stmt|;
specifier|const
name|char
modifier|*
name|q
init|=
name|name
decl_stmt|;
name|int
name|code
init|=
literal|0
decl_stmt|;
comment|/* assume mismatch */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|q
operator|!=
literal|'\0'
condition|)
block|{
name|char
name|a
init|=
operator|*
name|p
operator|++
decl_stmt|;
name|char
name|b
init|=
operator|*
name|q
operator|++
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|'_'
condition|)
name|a
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|'_'
condition|)
name|b
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|a
operator|!=
name|b
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|&&
operator|*
name|q
operator|==
literal|'\0'
condition|)
block|{
name|code
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
name|code
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|keyword
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|t_cptr
init|=
name|cptr
decl_stmt|;
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|cinc
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'$'
condition|)
block|{
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
block|}
name|cachec
argument_list|(
name|NUL
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchec
argument_list|(
literal|"token"
argument_list|)
operator|||
name|matchec
argument_list|(
literal|"term"
argument_list|)
condition|)
return|return
operator|(
name|TOKEN
operator|)
return|;
if|if
condition|(
name|matchec
argument_list|(
literal|"type"
argument_list|)
condition|)
return|return
operator|(
name|TYPE
operator|)
return|;
if|if
condition|(
name|matchec
argument_list|(
literal|"left"
argument_list|)
condition|)
return|return
operator|(
name|LEFT
operator|)
return|;
if|if
condition|(
name|matchec
argument_list|(
literal|"right"
argument_list|)
condition|)
return|return
operator|(
name|RIGHT
operator|)
return|;
if|if
condition|(
name|matchec
argument_list|(
literal|"nonassoc"
argument_list|)
operator|||
name|matchec
argument_list|(
literal|"binary"
argument_list|)
condition|)
return|return
operator|(
name|NONASSOC
operator|)
return|;
if|if
condition|(
name|matchec
argument_list|(
literal|"start"
argument_list|)
condition|)
return|return
operator|(
name|START
operator|)
return|;
if|if
condition|(
name|matchec
argument_list|(
literal|"union"
argument_list|)
condition|)
return|return
operator|(
name|UNION
operator|)
return|;
if|if
condition|(
name|matchec
argument_list|(
literal|"ident"
argument_list|)
condition|)
return|return
operator|(
name|IDENT
operator|)
return|;
if|if
condition|(
name|matchec
argument_list|(
literal|"expect"
argument_list|)
condition|)
return|return
operator|(
name|EXPECT
operator|)
return|;
if|if
condition|(
name|matchec
argument_list|(
literal|"expect-rr"
argument_list|)
condition|)
return|return
operator|(
name|EXPECT_RR
operator|)
return|;
if|if
condition|(
name|matchec
argument_list|(
literal|"pure-parser"
argument_list|)
condition|)
return|return
operator|(
name|PURE_PARSER
operator|)
return|;
if|if
condition|(
name|matchec
argument_list|(
literal|"parse-param"
argument_list|)
condition|)
return|return
operator|(
name|PARSE_PARAM
operator|)
return|;
if|if
condition|(
name|matchec
argument_list|(
literal|"lex-param"
argument_list|)
condition|)
return|return
operator|(
name|LEX_PARAM
operator|)
return|;
if|if
condition|(
name|matchec
argument_list|(
literal|"token-table"
argument_list|)
condition|)
return|return
operator|(
name|TOKEN_TABLE
operator|)
return|;
if|if
condition|(
name|matchec
argument_list|(
literal|"yacc"
argument_list|)
condition|)
return|return
operator|(
name|POSIX_YACC
operator|)
return|;
block|}
else|else
block|{
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|L_CURL
condition|)
return|return
operator|(
name|TEXT
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'%'
operator|||
name|c
operator|==
literal|'\\'
condition|)
return|return
operator|(
name|MARK
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
return|return
operator|(
name|LEFT
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
return|return
operator|(
name|RIGHT
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
return|return
operator|(
name|TOKEN
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'2'
condition|)
return|return
operator|(
name|NONASSOC
operator|)
return|;
block|}
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|t_cptr
argument_list|)
expr_stmt|;
comment|/*NOTREACHED */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_ident
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|output_file
decl_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'"'
condition|)
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"#ident \""
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|copy_text
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|quote
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|text_file
decl_stmt|;
name|int
name|need_newline
init|=
literal|0
decl_stmt|;
name|int
name|t_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|t_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|t_cptr
init|=
name|t_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|2
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|cptr
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_text
argument_list|(
name|t_lineno
argument_list|,
name|t_line
argument_list|,
name|t_cptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lflag
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
name|line_format
argument_list|,
name|lineno
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
name|loop
label|:
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|next_line
label|:
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|need_newline
operator|=
literal|0
expr_stmt|;
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
condition|)
goto|goto
name|loop
goto|;
name|unterminated_text
argument_list|(
name|t_lineno
argument_list|,
name|t_line
argument_list|,
name|t_cptr
argument_list|)
expr_stmt|;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
block|{
name|int
name|s_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|s_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|s_cptr
init|=
name|s_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|1
operator|)
decl_stmt|;
name|quote
operator|=
name|c
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quote
condition|)
block|{
name|need_newline
operator|=
literal|1
expr_stmt|;
name|FREE
argument_list|(
name|s_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|unterminated_string
argument_list|(
name|s_lineno
argument_list|,
name|s_line
argument_list|,
name|s_cptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_string
argument_list|(
name|s_lineno
argument_list|,
name|s_line
argument_list|,
name|s_cptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
case|case
literal|'/'
case|:
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|need_newline
operator|=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
name|putc
argument_list|(
literal|'*'
argument_list|,
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|cptr
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
name|cptr
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"* "
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*/"
argument_list|)
expr_stmt|;
goto|goto
name|next_line
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
name|int
name|c_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|c_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|c_cptr
init|=
name|c_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|1
operator|)
decl_stmt|;
name|putc
argument_list|(
literal|'*'
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
operator|*
name|cptr
operator|==
literal|'/'
condition|)
block|{
name|putc
argument_list|(
literal|'/'
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
name|FREE
argument_list|(
name|c_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_comment
argument_list|(
name|c_lineno
argument_list|,
name|c_line
argument_list|,
name|c_cptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|need_newline
operator|=
literal|1
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'%'
case|:
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|cptr
operator|==
name|R_CURL
condition|)
block|{
if|if
condition|(
name|need_newline
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
name|FREE
argument_list|(
name|t_line
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FALLTHRU */
default|default:
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|need_newline
operator|=
literal|1
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|puts_both
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|fputs
argument_list|(
name|s
argument_list|,
name|text_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|fputs
argument_list|(
name|s
argument_list|,
name|union_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|putc_both
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|text_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|union_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_union
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|quote
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|int
name|u_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|u_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|u_cptr
init|=
name|u_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|6
operator|)
decl_stmt|;
if|if
condition|(
name|unionized
condition|)
name|over_unionized
argument_list|(
name|cptr
operator|-
literal|6
argument_list|)
expr_stmt|;
name|unionized
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|lflag
condition|)
name|fprintf
argument_list|(
name|text_file
argument_list|,
name|line_format
argument_list|,
name|lineno
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
name|puts_both
argument_list|(
literal|"#ifdef YYSTYPE\n"
argument_list|)
expr_stmt|;
name|puts_both
argument_list|(
literal|"#undef  YYSTYPE_IS_DECLARED\n"
argument_list|)
expr_stmt|;
name|puts_both
argument_list|(
literal|"#define YYSTYPE_IS_DECLARED 1\n"
argument_list|)
expr_stmt|;
name|puts_both
argument_list|(
literal|"#endif\n"
argument_list|)
expr_stmt|;
name|puts_both
argument_list|(
literal|"#ifndef YYSTYPE_IS_DECLARED\n"
argument_list|)
expr_stmt|;
name|puts_both
argument_list|(
literal|"#define YYSTYPE_IS_DECLARED 1\n"
argument_list|)
expr_stmt|;
name|puts_both
argument_list|(
literal|"typedef union"
argument_list|)
expr_stmt|;
name|depth
operator|=
literal|0
expr_stmt|;
name|loop
label|:
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc_both
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|next_line
label|:
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_union
argument_list|(
name|u_lineno
argument_list|,
name|u_line
argument_list|,
name|u_cptr
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|L_CURL
case|:
operator|++
name|depth
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|R_CURL
case|:
if|if
condition|(
operator|--
name|depth
operator|==
literal|0
condition|)
block|{
name|puts_both
argument_list|(
literal|" YYSTYPE;\n"
argument_list|)
expr_stmt|;
name|puts_both
argument_list|(
literal|"#endif /* !YYSTYPE_IS_DECLARED */\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|u_line
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|loop
goto|;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
block|{
name|int
name|s_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|s_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|s_cptr
init|=
name|s_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|1
operator|)
decl_stmt|;
name|quote
operator|=
name|c
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc_both
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quote
condition|)
block|{
name|FREE
argument_list|(
name|s_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|unterminated_string
argument_list|(
name|s_lineno
argument_list|,
name|s_line
argument_list|,
name|s_cptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc_both
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_string
argument_list|(
name|s_lineno
argument_list|,
name|s_line
argument_list|,
name|s_cptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
case|case
literal|'/'
case|:
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
name|putc_both
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|cptr
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
name|cptr
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|puts_both
argument_list|(
literal|"* "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putc_both
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|puts_both
argument_list|(
literal|"*/\n"
argument_list|)
expr_stmt|;
goto|goto
name|next_line
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
name|int
name|c_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|c_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|c_cptr
init|=
name|c_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|1
operator|)
decl_stmt|;
name|putc_both
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc_both
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
operator|*
name|cptr
operator|==
literal|'/'
condition|)
block|{
name|putc_both
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
name|FREE
argument_list|(
name|c_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_comment
argument_list|(
name|c_lineno
argument_list|,
name|c_line
argument_list|,
name|c_cptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
goto|goto
name|loop
goto|;
default|default:
goto|goto
name|loop
goto|;
block|}
block|}
end_function

begin_comment
comment|/*  * Keep a linked list of parameters  */
end_comment

begin_function
specifier|static
name|void
name|copy_param
parameter_list|(
name|int
name|k
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|c
decl_stmt|;
name|param
modifier|*
name|head
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|name
decl_stmt|,
name|type2
decl_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'{'
condition|)
goto|goto
name|out
goto|;
name|cptr
operator|++
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
goto|goto
name|out
goto|;
name|buf
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|linesize
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
operator|=
operator|*
name|cptr
operator|++
operator|)
operator|!=
literal|'}'
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
name|missing_brace
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|buf
index|[
name|i
operator|--
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
name|UCH
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
name|buf
index|[
name|i
operator|--
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|']'
condition|)
block|{
name|int
name|level
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
operator|&&
name|level
operator|>
literal|0
operator|&&
name|buf
index|[
name|i
index|]
operator|!=
literal|'['
condition|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|']'
condition|)
operator|++
name|level
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'['
condition|)
operator|--
name|level
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
name|type2
operator|=
name|i
operator|--
expr_stmt|;
block|}
else|else
block|{
name|type2
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
operator|(
name|isalnum
argument_list|(
name|UCH
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|||
name|UCH
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
operator|==
literal|'_'
operator|)
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|UCH
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|&&
name|buf
index|[
name|i
index|]
operator|!=
literal|'*'
condition|)
goto|goto
name|out
goto|;
name|name
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|TMALLOC
argument_list|(
name|param
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|type2
operator|=
name|strdup
argument_list|(
name|buf
operator|+
name|type2
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|p
operator|->
name|type2
argument_list|)
expr_stmt|;
name|buf
index|[
name|type2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|buf
operator|+
name|name
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|buf
index|[
name|name
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|LEX_PARAM
condition|)
name|head
operator|=
name|lex_param
expr_stmt|;
else|else
name|head
operator|=
name|parse_param
expr_stmt|;
if|if
condition|(
name|head
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|head
operator|->
name|next
condition|)
name|head
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|head
operator|->
name|next
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|k
operator|==
name|LEX_PARAM
condition|)
name|lex_param
operator|=
name|p
expr_stmt|;
else|else
name|parse_param
operator|=
name|p
expr_stmt|;
block|}
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return;
name|out
label|:
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hexval
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
return|return
operator|(
name|c
operator|-
literal|'0'
operator|)
return|;
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
return|return
operator|(
name|c
operator|-
literal|'A'
operator|+
literal|10
operator|)
return|;
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
return|return
operator|(
name|c
operator|-
literal|'a'
operator|+
literal|10
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bucket
modifier|*
name|get_literal
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|quote
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|;
name|int
name|s_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|s_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|s_cptr
init|=
name|s_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|)
decl_stmt|;
name|quote
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|cinc
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quote
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|unterminated_string
argument_list|(
name|s_lineno
argument_list|,
name|s_line
argument_list|,
name|s_cptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|char
modifier|*
name|c_cptr
init|=
name|cptr
operator|-
literal|1
decl_stmt|;
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_string
argument_list|(
name|s_lineno
argument_list|,
name|s_line
argument_list|,
name|s_cptr
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|n
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|IS_OCTAL
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|n
operator|=
operator|(
name|n
operator|<<
literal|3
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|IS_OCTAL
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|n
operator|=
operator|(
name|n
operator|<<
literal|3
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|>
name|MAXCHAR
condition|)
name|illegal_character
argument_list|(
name|c_cptr
argument_list|)
expr_stmt|;
name|c
operator|=
name|n
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|n
operator|=
name|hexval
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
literal|16
condition|)
name|illegal_character
argument_list|(
name|c_cptr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
name|i
operator|=
name|hexval
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
literal|16
condition|)
break|break;
operator|++
name|cptr
expr_stmt|;
name|n
operator|=
operator|(
name|n
operator|<<
literal|4
operator|)
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|MAXCHAR
condition|)
name|illegal_character
argument_list|(
name|c_cptr
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|n
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|c
operator|=
literal|7
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|c
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|c
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|c
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|c
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|c
operator|=
literal|'\v'
expr_stmt|;
break|break;
block|}
block|}
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|s_line
argument_list|)
expr_stmt|;
name|n
operator|=
name|cinc
expr_stmt|;
name|s
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|s
index|[
name|i
index|]
operator|=
name|cache
index|[
name|i
index|]
expr_stmt|;
name|cinc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
name|cachec
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
else|else
name|cachec
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|c
operator|=
name|UCH
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
name|cache
index|[
literal|0
index|]
condition|)
block|{
name|cachec
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|cachec
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|7
case|:
name|cachec
argument_list|(
literal|'a'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|cachec
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|cachec
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|cachec
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|cachec
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|cachec
argument_list|(
literal|'t'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
name|cachec
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cachec
argument_list|(
operator|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|cachec
argument_list|(
operator|(
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|cachec
argument_list|(
operator|(
name|c
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|n
operator|==
literal|1
condition|)
name|cachec
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
else|else
name|cachec
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|cachec
argument_list|(
name|NUL
argument_list|)
expr_stmt|;
name|bp
operator|=
name|lookup
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|bp
operator|->
name|class
operator|=
name|TERM
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
name|bp
operator|->
name|value
operator|==
name|UNDEFINED
condition|)
name|bp
operator|->
name|value
operator|=
name|UCH
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_reserved
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"$accept"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"$end"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'$'
operator|&&
name|isdigit
argument_list|(
name|UCH
argument_list|(
name|name
index|[
literal|2
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|s
operator|=
name|name
operator|+
literal|3
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|UCH
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|NUL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bucket
modifier|*
name|get_name
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|cinc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|cptr
init|;
name|IS_IDENT
argument_list|(
name|c
argument_list|)
condition|;
name|c
operator|=
operator|*
operator|++
name|cptr
control|)
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|cachec
argument_list|(
name|NUL
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_reserved
argument_list|(
name|cache
argument_list|)
condition|)
name|used_reserved
argument_list|(
name|cache
argument_list|)
expr_stmt|;
return|return
operator|(
name|lookup
argument_list|(
name|cache
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|Value_t
name|get_number
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|Value_t
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|cptr
init|;
name|isdigit
argument_list|(
name|c
argument_list|)
condition|;
name|c
operator|=
operator|*
operator|++
name|cptr
control|)
name|n
operator|=
call|(
name|Value_t
call|)
argument_list|(
literal|10
operator|*
name|n
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_tag
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|t_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|t_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|t_cptr
init|=
name|t_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|)
decl_stmt|;
operator|++
name|cptr
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
name|illegal_tag
argument_list|(
name|t_lineno
argument_list|,
name|t_line
argument_list|,
name|t_cptr
argument_list|)
expr_stmt|;
name|cinc
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
block|}
do|while
condition|(
name|IS_IDENT
argument_list|(
name|c
argument_list|)
condition|)
do|;
name|cachec
argument_list|(
name|NUL
argument_list|)
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'>'
condition|)
name|illegal_tag
argument_list|(
name|t_lineno
argument_list|,
name|t_line
argument_list|,
name|t_cptr
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntags
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cache
argument_list|,
name|tag_table
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FREE
argument_list|(
name|t_line
argument_list|)
expr_stmt|;
return|return
operator|(
name|tag_table
index|[
name|i
index|]
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ntags
operator|>=
name|tagmax
condition|)
block|{
name|tagmax
operator|+=
literal|16
expr_stmt|;
name|tag_table
operator|=
operator|(
name|tag_table
condition|?
name|TREALLOC
argument_list|(
name|char
operator|*
argument_list|,
name|tag_table
argument_list|,
name|tagmax
argument_list|)
else|:
name|TMALLOC
argument_list|(
name|char
operator|*
argument_list|,
name|tagmax
argument_list|)
operator|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|tag_table
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|cinc
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|tag_table
index|[
name|ntags
index|]
operator|=
name|s
expr_stmt|;
operator|++
name|ntags
expr_stmt|;
name|FREE
argument_list|(
name|t_line
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|declare_tokens
parameter_list|(
name|int
name|assoc
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|;
name|Value_t
name|value
decl_stmt|;
name|char
modifier|*
name|tag
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|assoc
operator|!=
name|TOKEN
condition|)
operator|++
name|prec
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|tag
operator|=
name|get_tag
argument_list|()
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'$'
condition|)
name|bp
operator|=
name|get_name
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
name|bp
operator|=
name|get_literal
argument_list|()
expr_stmt|;
else|else
return|return;
if|if
condition|(
name|bp
operator|==
name|goal
condition|)
name|tokenized_start
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|class
operator|=
name|TERM
expr_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|tag
operator|&&
name|tag
operator|!=
name|bp
operator|->
name|tag
condition|)
name|retyped_warning
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
block|}
if|if
condition|(
name|assoc
operator|!=
name|TOKEN
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|prec
operator|&&
name|prec
operator|!=
name|bp
operator|->
name|prec
condition|)
name|reprec_warning
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|assoc
operator|=
operator|(
name|Assoc_t
operator|)
name|assoc
expr_stmt|;
name|bp
operator|->
name|prec
operator|=
name|prec
expr_stmt|;
block|}
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|value
operator|=
name|get_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|value
operator|!=
name|UNDEFINED
operator|&&
name|value
operator|!=
name|bp
operator|->
name|value
condition|)
name|revalued_warning
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * %expect requires special handling  * as it really isn't part of the yacc  * grammar only a flag for yacc proper.  */
end_comment

begin_function
specifier|static
name|void
name|declare_expect
parameter_list|(
name|int
name|assoc
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|assoc
operator|!=
name|EXPECT
operator|&&
name|assoc
operator|!=
name|EXPECT_RR
condition|)
operator|++
name|prec
expr_stmt|;
comment|/*      * Stay away from nextc - doesn't      * detect EOL and will read to EOF.      */
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|assoc
operator|==
name|EXPECT
condition|)
name|SRexpect
operator|=
name|get_number
argument_list|()
expr_stmt|;
else|else
name|RRexpect
operator|=
name|get_number
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* 	 * Looking for number before EOL. 	 * Spaces, tabs, and numbers are ok, 	 * words, punc., etc. are syntax errors. 	 */
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|declare_types
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'<'
condition|)
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
name|tag
operator|=
name|get_tag
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'$'
condition|)
name|bp
operator|=
name|get_name
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
name|bp
operator|=
name|get_literal
argument_list|()
expr_stmt|;
else|else
return|return;
if|if
condition|(
name|bp
operator|->
name|tag
operator|&&
name|tag
operator|!=
name|bp
operator|->
name|tag
condition|)
name|retyped_warning
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|declare_start
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'.'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
name|bp
operator|=
name|get_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|TERM
condition|)
name|terminal_start
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|goal
operator|&&
name|goal
operator|!=
name|bp
condition|)
name|restarted_warning
argument_list|()
expr_stmt|;
name|goal
operator|=
name|bp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_declarations
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|k
decl_stmt|;
name|cache_size
operator|=
literal|256
expr_stmt|;
name|cache
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|cache_size
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|cache
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'%'
condition|)
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|k
operator|=
name|keyword
argument_list|()
condition|)
block|{
case|case
name|MARK
case|:
return|return;
case|case
name|IDENT
case|:
name|copy_ident
argument_list|()
expr_stmt|;
break|break;
case|case
name|TEXT
case|:
name|copy_text
argument_list|()
expr_stmt|;
break|break;
case|case
name|UNION
case|:
name|copy_union
argument_list|()
expr_stmt|;
break|break;
case|case
name|TOKEN
case|:
case|case
name|LEFT
case|:
case|case
name|RIGHT
case|:
case|case
name|NONASSOC
case|:
name|declare_tokens
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPECT
case|:
case|case
name|EXPECT_RR
case|:
name|declare_expect
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE
case|:
name|declare_types
argument_list|()
expr_stmt|;
break|break;
case|case
name|START
case|:
name|declare_start
argument_list|()
expr_stmt|;
break|break;
case|case
name|PURE_PARSER
case|:
name|pure_parser
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PARSE_PARAM
case|:
case|case
name|LEX_PARAM
case|:
name|copy_param
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOKEN_TABLE
case|:
name|token_table
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|POSIX_YACC
case|:
comment|/* noop for bison compatibility. byacc is already designed to be posix 	     * yacc compatible. */
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|initialize_grammar
parameter_list|(
name|void
parameter_list|)
block|{
name|nitems
operator|=
literal|4
expr_stmt|;
name|maxitems
operator|=
literal|300
expr_stmt|;
name|pitem
operator|=
name|TMALLOC
argument_list|(
name|bucket
operator|*
argument_list|,
name|maxitems
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|pitem
argument_list|)
expr_stmt|;
name|pitem
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|pitem
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pitem
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|pitem
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|nrules
operator|=
literal|3
expr_stmt|;
name|maxrules
operator|=
literal|100
expr_stmt|;
name|plhs
operator|=
name|TMALLOC
argument_list|(
name|bucket
operator|*
argument_list|,
name|maxrules
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|plhs
argument_list|)
expr_stmt|;
name|plhs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|plhs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|plhs
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|rprec
operator|=
name|TMALLOC
argument_list|(
name|Value_t
argument_list|,
name|maxrules
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|rprec
argument_list|)
expr_stmt|;
name|rprec
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rprec
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rprec
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|rassoc
operator|=
name|TMALLOC
argument_list|(
name|Assoc_t
argument_list|,
name|maxrules
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|rassoc
argument_list|)
expr_stmt|;
name|rassoc
index|[
literal|0
index|]
operator|=
name|TOKEN
expr_stmt|;
name|rassoc
index|[
literal|1
index|]
operator|=
name|TOKEN
expr_stmt|;
name|rassoc
index|[
literal|2
index|]
operator|=
name|TOKEN
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expand_items
parameter_list|(
name|void
parameter_list|)
block|{
name|maxitems
operator|+=
literal|300
expr_stmt|;
name|pitem
operator|=
name|TREALLOC
argument_list|(
name|bucket
operator|*
argument_list|,
name|pitem
argument_list|,
name|maxitems
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|pitem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expand_rules
parameter_list|(
name|void
parameter_list|)
block|{
name|maxrules
operator|+=
literal|100
expr_stmt|;
name|plhs
operator|=
name|TREALLOC
argument_list|(
name|bucket
operator|*
argument_list|,
name|plhs
argument_list|,
name|maxrules
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|plhs
argument_list|)
expr_stmt|;
name|rprec
operator|=
name|TREALLOC
argument_list|(
name|Value_t
argument_list|,
name|rprec
argument_list|,
name|maxrules
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|rprec
argument_list|)
expr_stmt|;
name|rassoc
operator|=
name|TREALLOC
argument_list|(
name|Assoc_t
argument_list|,
name|rassoc
argument_list|,
name|maxrules
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|rassoc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|advance_to_start
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|s_cptr
decl_stmt|;
name|int
name|s_lineno
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'%'
condition|)
break|break;
name|s_cptr
operator|=
name|cptr
expr_stmt|;
switch|switch
condition|(
name|keyword
argument_list|()
condition|)
block|{
case|case
name|MARK
case|:
name|no_grammar
argument_list|()
expr_stmt|;
case|case
name|TEXT
case|:
name|copy_text
argument_list|()
expr_stmt|;
break|break;
case|case
name|START
case|:
name|declare_start
argument_list|()
expr_stmt|;
break|break;
default|default:
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|s_cptr
argument_list|)
expr_stmt|;
block|}
block|}
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'.'
operator|&&
name|c
operator|!=
literal|'_'
condition|)
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
name|bp
operator|=
name|get_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|goal
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|TERM
condition|)
name|terminal_start
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|goal
operator|=
name|bp
expr_stmt|;
block|}
name|s_lineno
operator|=
name|lineno
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|':'
condition|)
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
name|start_rule
argument_list|(
name|bp
argument_list|,
name|s_lineno
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_rule
parameter_list|(
name|bucket
modifier|*
name|bp
parameter_list|,
name|int
name|s_lineno
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|TERM
condition|)
name|terminal_lhs
argument_list|(
name|s_lineno
argument_list|)
expr_stmt|;
name|bp
operator|->
name|class
operator|=
name|NONTERM
expr_stmt|;
if|if
condition|(
name|nrules
operator|>=
name|maxrules
condition|)
name|expand_rules
argument_list|()
expr_stmt|;
name|plhs
index|[
name|nrules
index|]
operator|=
name|bp
expr_stmt|;
name|rprec
index|[
name|nrules
index|]
operator|=
name|UNDEFINED
expr_stmt|;
name|rassoc
index|[
name|nrules
index|]
operator|=
name|TOKEN
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|end_rule
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|last_was_action
operator|&&
name|plhs
index|[
name|nrules
index|]
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|pitem
index|[
name|nitems
operator|-
literal|1
index|]
condition|)
block|{
for|for
control|(
name|i
operator|=
name|nitems
operator|-
literal|1
init|;
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
name|pitem
index|[
name|i
index|]
condition|;
operator|--
name|i
control|)
continue|continue;
if|if
condition|(
name|pitem
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|0
operator|||
name|pitem
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|tag
operator|!=
name|plhs
index|[
name|nrules
index|]
operator|->
name|tag
condition|)
name|default_action_warning
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|default_action_warning
argument_list|()
expr_stmt|;
block|}
block|}
name|last_was_action
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nitems
operator|>=
name|maxitems
condition|)
name|expand_items
argument_list|()
expr_stmt|;
name|pitem
index|[
name|nitems
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|nitems
expr_stmt|;
operator|++
name|nrules
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_empty_rule
parameter_list|(
name|void
parameter_list|)
block|{
name|bucket
modifier|*
name|bp
decl_stmt|,
modifier|*
modifier|*
name|bpp
decl_stmt|;
name|assert
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cache
argument_list|,
literal|"$$%d"
argument_list|,
operator|++
name|gensym
argument_list|)
expr_stmt|;
name|bp
operator|=
name|make_bucket
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|last_symbol
operator|->
name|next
operator|=
name|bp
expr_stmt|;
name|last_symbol
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|tag
operator|=
name|plhs
index|[
name|nrules
index|]
operator|->
name|tag
expr_stmt|;
name|bp
operator|->
name|class
operator|=
name|NONTERM
expr_stmt|;
if|if
condition|(
operator|(
name|nitems
operator|+=
literal|2
operator|)
operator|>
name|maxitems
condition|)
name|expand_items
argument_list|()
expr_stmt|;
name|bpp
operator|=
name|pitem
operator|+
name|nitems
operator|-
literal|1
expr_stmt|;
operator|*
name|bpp
operator|--
operator|=
name|bp
expr_stmt|;
while|while
condition|(
operator|(
name|bpp
index|[
literal|0
index|]
operator|=
name|bpp
index|[
operator|-
literal|1
index|]
operator|)
operator|!=
literal|0
condition|)
operator|--
name|bpp
expr_stmt|;
if|if
condition|(
operator|++
name|nrules
operator|>=
name|maxrules
condition|)
name|expand_rules
argument_list|()
expr_stmt|;
name|plhs
index|[
name|nrules
index|]
operator|=
name|plhs
index|[
name|nrules
operator|-
literal|1
index|]
expr_stmt|;
name|plhs
index|[
name|nrules
operator|-
literal|1
index|]
operator|=
name|bp
expr_stmt|;
name|rprec
index|[
name|nrules
index|]
operator|=
name|rprec
index|[
name|nrules
operator|-
literal|1
index|]
expr_stmt|;
name|rprec
index|[
name|nrules
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rassoc
index|[
name|nrules
index|]
operator|=
name|rassoc
index|[
name|nrules
operator|-
literal|1
index|]
expr_stmt|;
name|rassoc
index|[
name|nrules
operator|-
literal|1
index|]
operator|=
name|TOKEN
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_symbol
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|;
name|int
name|s_lineno
init|=
name|lineno
decl_stmt|;
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
name|bp
operator|=
name|get_literal
argument_list|()
expr_stmt|;
else|else
name|bp
operator|=
name|get_name
argument_list|()
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|end_rule
argument_list|()
expr_stmt|;
name|start_rule
argument_list|(
name|bp
argument_list|,
name|s_lineno
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|last_was_action
condition|)
name|insert_empty_rule
argument_list|()
expr_stmt|;
name|last_was_action
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|nitems
operator|>
name|maxitems
condition|)
name|expand_items
argument_list|()
expr_stmt|;
name|pitem
index|[
name|nitems
operator|-
literal|1
index|]
operator|=
name|bp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|after_blanks
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
name|UCH
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_action
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|int
name|quote
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|action_file
decl_stmt|;
name|int
name|a_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|a_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|a_cptr
init|=
name|a_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|)
decl_stmt|;
if|if
condition|(
name|last_was_action
condition|)
name|insert_empty_rule
argument_list|()
expr_stmt|;
name|last_was_action
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"case %d:\n"
argument_list|,
name|nrules
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lflag
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
name|line_format
argument_list|,
name|lineno
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cptr
operator|==
literal|'='
condition|)
operator|++
name|cptr
expr_stmt|;
comment|/* avoid putting curly-braces in first column, to ease editing */
if|if
condition|(
operator|*
name|after_blanks
argument_list|(
name|cptr
argument_list|)
operator|==
name|L_CURL
condition|)
block|{
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|cptr
operator|=
name|after_blanks
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nitems
operator|-
literal|1
init|;
name|pitem
index|[
name|i
index|]
condition|;
operator|--
name|i
control|)
operator|++
name|n
expr_stmt|;
name|depth
operator|=
literal|0
expr_stmt|;
name|loop
label|:
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|cptr
index|[
literal|1
index|]
operator|==
literal|'<'
condition|)
block|{
name|int
name|d_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|d_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|d_cptr
init|=
name|d_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|)
decl_stmt|;
operator|++
name|cptr
expr_stmt|;
name|tag
operator|=
name|get_tag
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yyval.%s"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
name|FREE
argument_list|(
name|d_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|i
operator|=
name|get_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|n
condition|)
name|dollar_warning
argument_list|(
name|d_lineno
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.l_mark[%d].%s"
argument_list|,
name|i
operator|-
name|n
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|d_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
name|isdigit
argument_list|(
name|UCH
argument_list|(
name|cptr
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|cptr
expr_stmt|;
name|i
operator|=
operator|-
name|get_number
argument_list|()
operator|-
name|n
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.l_mark[%d].%s"
argument_list|,
name|i
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|d_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
else|else
name|dollar_error
argument_list|(
name|d_lineno
argument_list|,
name|d_line
argument_list|,
name|d_cptr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cptr
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|ntags
condition|)
block|{
name|tag
operator|=
name|plhs
index|[
name|nrules
index|]
operator|->
name|tag
expr_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
condition|)
name|untyped_lhs
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yyval.%s"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yyval"
argument_list|)
expr_stmt|;
name|cptr
operator|+=
literal|2
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|UCH
argument_list|(
name|cptr
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|cptr
expr_stmt|;
name|i
operator|=
name|get_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|ntags
condition|)
block|{
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>
name|n
condition|)
name|unknown_rhs
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|tag
operator|=
name|pitem
index|[
name|nitems
operator|+
name|i
operator|-
name|n
operator|-
literal|1
index|]
operator|->
name|tag
expr_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
condition|)
name|untyped_rhs
argument_list|(
name|i
argument_list|,
name|pitem
index|[
name|nitems
operator|+
name|i
operator|-
name|n
operator|-
literal|1
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.l_mark[%d].%s"
argument_list|,
name|i
operator|-
name|n
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|>
name|n
condition|)
name|dollar_warning
argument_list|(
name|lineno
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.l_mark[%d]"
argument_list|,
name|i
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
block|}
elseif|else
if|if
condition|(
name|cptr
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|cptr
operator|+=
literal|2
expr_stmt|;
name|i
operator|=
name|get_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|ntags
condition|)
name|unknown_rhs
argument_list|(
operator|-
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.l_mark[%d]"
argument_list|,
operator|-
name|i
operator|-
name|n
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
block|}
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
condition|)
block|{
do|do
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
block|}
do|while
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
condition|)
do|;
goto|goto
name|loop
goto|;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|next_line
label|:
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
condition|)
goto|goto
name|loop
goto|;
name|unterminated_action
argument_list|(
name|a_lineno
argument_list|,
name|a_line
argument_list|,
name|a_cptr
argument_list|)
expr_stmt|;
case|case
literal|';'
case|:
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
goto|goto
name|loop
goto|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nbreak;\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a_line
argument_list|)
expr_stmt|;
return|return;
case|case
name|L_CURL
case|:
operator|++
name|depth
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|R_CURL
case|:
if|if
condition|(
operator|--
name|depth
operator|>
literal|0
condition|)
goto|goto
name|loop
goto|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nbreak;\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a_line
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
block|{
name|int
name|s_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|s_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|s_cptr
init|=
name|s_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|1
operator|)
decl_stmt|;
name|quote
operator|=
name|c
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quote
condition|)
block|{
name|FREE
argument_list|(
name|s_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|unterminated_string
argument_list|(
name|s_lineno
argument_list|,
name|s_line
argument_list|,
name|s_cptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_string
argument_list|(
name|s_lineno
argument_list|,
name|s_line
argument_list|,
name|s_cptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
case|case
literal|'/'
case|:
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
name|putc
argument_list|(
literal|'*'
argument_list|,
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|cptr
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
name|cptr
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"* "
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*/\n"
argument_list|)
expr_stmt|;
goto|goto
name|next_line
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
name|int
name|c_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|c_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|c_cptr
init|=
name|c_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|1
operator|)
decl_stmt|;
name|putc
argument_list|(
literal|'*'
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
operator|*
name|cptr
operator|==
literal|'/'
condition|)
block|{
name|putc
argument_list|(
literal|'/'
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
name|FREE
argument_list|(
name|c_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_comment
argument_list|(
name|c_lineno
argument_list|,
name|c_line
argument_list|,
name|c_cptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
goto|goto
name|loop
goto|;
default|default:
goto|goto
name|loop
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mark_symbol
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|bucket
modifier|*
name|bp
init|=
name|NULL
decl_stmt|;
name|c
operator|=
name|cptr
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'%'
operator|||
name|c
operator|==
literal|'\\'
condition|)
block|{
name|cptr
operator|+=
literal|2
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
name|cptr
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'p'
operator|||
name|c
operator|==
literal|'P'
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|cptr
index|[
literal|2
index|]
operator|)
operator|==
literal|'r'
operator|||
name|c
operator|==
literal|'R'
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|cptr
index|[
literal|3
index|]
operator|)
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|cptr
index|[
literal|4
index|]
operator|)
operator|==
literal|'c'
operator|||
name|c
operator|==
literal|'C'
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|cptr
index|[
literal|5
index|]
operator|,
operator|!
name|IS_IDENT
argument_list|(
name|c
argument_list|)
operator|)
operator|)
condition|)
name|cptr
operator|+=
literal|5
expr_stmt|;
else|else
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'$'
condition|)
name|bp
operator|=
name|get_name
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
name|bp
operator|=
name|get_literal
argument_list|()
expr_stmt|;
else|else
block|{
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
comment|/*NOTREACHED */
block|}
if|if
condition|(
name|rprec
index|[
name|nrules
index|]
operator|!=
name|UNDEFINED
operator|&&
name|bp
operator|->
name|prec
operator|!=
name|rprec
index|[
name|nrules
index|]
condition|)
name|prec_redeclared
argument_list|()
expr_stmt|;
name|rprec
index|[
name|nrules
index|]
operator|=
name|bp
operator|->
name|prec
expr_stmt|;
name|rassoc
index|[
name|nrules
index|]
operator|=
name|bp
operator|->
name|assoc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_grammar
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|initialize_grammar
argument_list|()
expr_stmt|;
name|advance_to_start
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'$'
operator|||
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
name|add_symbol
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|L_CURL
operator|||
name|c
operator|==
literal|'='
condition|)
name|copy_action
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'|'
condition|)
block|{
name|end_rule
argument_list|()
expr_stmt|;
name|start_rule
argument_list|(
name|plhs
index|[
name|nrules
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|mark_symbol
argument_list|()
condition|)
break|break;
block|}
else|else
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
block|}
name|end_rule
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_tags
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tag_table
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntags
condition|;
operator|++
name|i
control|)
block|{
name|assert
argument_list|(
name|tag_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|tag_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|tag_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pack_names
parameter_list|(
name|void
parameter_list|)
block|{
name|bucket
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|name_pool_size
operator|=
literal|13
expr_stmt|;
comment|/* 13 == sizeof("$end") + sizeof("$accept") */
for|for
control|(
name|bp
operator|=
name|first_symbol
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
name|name_pool_size
operator|+=
name|strlen
argument_list|(
name|bp
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name_pool
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|name_pool_size
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|name_pool
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name_pool
argument_list|,
literal|"$accept"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name_pool
operator|+
literal|8
argument_list|,
literal|"$end"
argument_list|)
expr_stmt|;
name|t
operator|=
name|name_pool
operator|+
literal|13
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|first_symbol
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
name|p
operator|=
name|t
expr_stmt|;
name|s
operator|=
name|bp
operator|->
name|name
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|FREE
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|name
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_symbols
parameter_list|(
name|void
parameter_list|)
block|{
name|bucket
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|goal
operator|->
name|class
operator|==
name|UNKNOWN
condition|)
name|undefined_goal
argument_list|(
name|goal
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|first_symbol
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|UNKNOWN
condition|)
block|{
name|undefined_symbol_warning
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|class
operator|=
name|TERM
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|protect_string
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|char
modifier|*
modifier|*
name|des
parameter_list|)
block|{
name|unsigned
name|len
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|;
operator|*
name|des
operator|=
name|src
expr_stmt|;
if|if
condition|(
name|src
condition|)
block|{
name|len
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|src
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
literal|'\\'
operator|==
operator|*
name|s
operator|||
literal|'"'
operator|==
operator|*
name|s
condition|)
name|len
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
operator|*
name|des
operator|=
name|d
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|s
operator|=
name|src
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
literal|'\\'
operator|==
operator|*
name|s
operator|||
literal|'"'
operator|==
operator|*
name|s
condition|)
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pack_symbols
parameter_list|(
name|void
parameter_list|)
block|{
name|bucket
modifier|*
name|bp
decl_stmt|;
name|bucket
modifier|*
modifier|*
name|v
decl_stmt|;
name|Value_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|;
name|nsyms
operator|=
literal|2
expr_stmt|;
name|ntokens
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|first_symbol
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
operator|++
name|nsyms
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|TERM
condition|)
operator|++
name|ntokens
expr_stmt|;
block|}
name|start_symbol
operator|=
operator|(
name|Value_t
operator|)
name|ntokens
expr_stmt|;
name|nvars
operator|=
name|nsyms
operator|-
name|ntokens
expr_stmt|;
name|symbol_name
operator|=
name|TMALLOC
argument_list|(
name|char
operator|*
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
name|symbol_value
operator|=
name|TMALLOC
argument_list|(
name|Value_t
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|symbol_value
argument_list|)
expr_stmt|;
name|symbol_prec
operator|=
name|TMALLOC
argument_list|(
name|short
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|symbol_prec
argument_list|)
expr_stmt|;
name|symbol_assoc
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|symbol_assoc
argument_list|)
expr_stmt|;
name|v
operator|=
name|TMALLOC
argument_list|(
name|bucket
operator|*
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|v
index|[
name|start_symbol
index|]
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|j
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|start_symbol
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|first_symbol
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|TERM
condition|)
name|v
index|[
name|i
operator|++
index|]
operator|=
name|bp
expr_stmt|;
else|else
name|v
index|[
name|j
operator|++
index|]
operator|=
name|bp
expr_stmt|;
block|}
name|assert
argument_list|(
name|i
operator|==
name|ntokens
operator|&&
name|j
operator|==
name|nsyms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
operator|++
name|i
control|)
name|v
index|[
name|i
index|]
operator|->
name|index
operator|=
name|i
expr_stmt|;
name|goal
operator|->
name|index
operator|=
call|(
name|Index_t
call|)
argument_list|(
name|start_symbol
operator|+
literal|1
argument_list|)
expr_stmt|;
name|k
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|start_symbol
operator|+
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<
name|nsyms
condition|)
if|if
condition|(
name|v
index|[
name|i
index|]
operator|!=
name|goal
condition|)
block|{
name|v
index|[
name|i
index|]
operator|->
name|index
operator|=
name|k
expr_stmt|;
operator|++
name|k
expr_stmt|;
block|}
name|goal
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|k
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|start_symbol
operator|+
literal|1
argument_list|)
init|;
name|i
operator|<
name|nsyms
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|v
index|[
name|i
index|]
operator|!=
name|goal
condition|)
block|{
name|v
index|[
name|i
index|]
operator|->
name|value
operator|=
name|k
expr_stmt|;
operator|++
name|k
expr_stmt|;
block|}
block|}
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
operator|++
name|i
control|)
block|{
name|n
operator|=
name|v
index|[
name|i
index|]
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|256
condition|)
block|{
for|for
control|(
name|j
operator|=
name|k
operator|++
init|;
name|j
operator|>
literal|0
operator|&&
name|symbol_value
index|[
name|j
operator|-
literal|1
index|]
operator|>
name|n
condition|;
operator|--
name|j
control|)
name|symbol_value
index|[
name|j
index|]
operator|=
name|symbol_value
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|symbol_value
index|[
name|j
index|]
operator|=
name|n
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|v
index|[
literal|1
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
index|[
literal|1
index|]
operator|->
name|value
operator|==
name|UNDEFINED
condition|)
name|v
index|[
literal|1
index|]
operator|->
name|value
operator|=
literal|256
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|257
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|v
index|[
name|i
index|]
operator|->
name|value
operator|==
name|UNDEFINED
condition|)
block|{
while|while
condition|(
name|j
operator|<
name|k
operator|&&
name|n
operator|==
name|symbol_value
index|[
name|j
index|]
condition|)
block|{
while|while
condition|(
operator|++
name|j
operator|<
name|k
operator|&&
name|n
operator|==
name|symbol_value
index|[
name|j
index|]
condition|)
continue|continue;
operator|++
name|n
expr_stmt|;
block|}
name|v
index|[
name|i
index|]
operator|->
name|value
operator|=
name|n
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
block|}
name|symbol_name
index|[
literal|0
index|]
operator|=
name|name_pool
operator|+
literal|8
expr_stmt|;
name|symbol_value
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|symbol_prec
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|symbol_assoc
index|[
literal|0
index|]
operator|=
name|TOKEN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
operator|++
name|i
control|)
block|{
name|symbol_name
index|[
name|i
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|name
expr_stmt|;
name|symbol_value
index|[
name|i
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|value
expr_stmt|;
name|symbol_prec
index|[
name|i
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|prec
expr_stmt|;
name|symbol_assoc
index|[
name|i
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|assoc
expr_stmt|;
block|}
name|symbol_name
index|[
name|start_symbol
index|]
operator|=
name|name_pool
expr_stmt|;
name|symbol_value
index|[
name|start_symbol
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|symbol_prec
index|[
name|start_symbol
index|]
operator|=
literal|0
expr_stmt|;
name|symbol_assoc
index|[
name|start_symbol
index|]
operator|=
name|TOKEN
expr_stmt|;
for|for
control|(
operator|++
name|i
init|;
name|i
operator|<
name|nsyms
condition|;
operator|++
name|i
control|)
block|{
name|k
operator|=
name|v
index|[
name|i
index|]
operator|->
name|index
expr_stmt|;
name|symbol_name
index|[
name|k
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|name
expr_stmt|;
name|symbol_value
index|[
name|k
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|value
expr_stmt|;
name|symbol_prec
index|[
name|k
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|prec
expr_stmt|;
name|symbol_assoc
index|[
name|k
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|assoc
expr_stmt|;
block|}
if|if
condition|(
name|gflag
condition|)
block|{
name|symbol_pname
operator|=
name|TMALLOC
argument_list|(
name|char
operator|*
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|symbol_pname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
operator|++
name|i
control|)
name|protect_string
argument_list|(
name|symbol_name
index|[
name|i
index|]
argument_list|,
operator|&
operator|(
name|symbol_pname
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pack_grammar
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Value_t
name|j
decl_stmt|;
name|Assoc_t
name|assoc
decl_stmt|;
name|Value_t
name|prec2
decl_stmt|;
name|ritem
operator|=
name|TMALLOC
argument_list|(
name|Value_t
argument_list|,
name|nitems
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|ritem
argument_list|)
expr_stmt|;
name|rlhs
operator|=
name|TMALLOC
argument_list|(
name|Value_t
argument_list|,
name|nrules
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|rlhs
argument_list|)
expr_stmt|;
name|rrhs
operator|=
name|TMALLOC
argument_list|(
name|Value_t
argument_list|,
name|nrules
operator|+
literal|1
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|rrhs
argument_list|)
expr_stmt|;
name|rprec
operator|=
name|TREALLOC
argument_list|(
name|Value_t
argument_list|,
name|rprec
argument_list|,
name|nrules
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|rprec
argument_list|)
expr_stmt|;
name|rassoc
operator|=
name|TREALLOC
argument_list|(
name|Assoc_t
argument_list|,
name|rassoc
argument_list|,
name|nrules
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|rassoc
argument_list|)
expr_stmt|;
name|ritem
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|ritem
index|[
literal|1
index|]
operator|=
name|goal
operator|->
name|index
expr_stmt|;
name|ritem
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ritem
index|[
literal|3
index|]
operator|=
operator|-
literal|2
expr_stmt|;
name|rlhs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rlhs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rlhs
index|[
literal|2
index|]
operator|=
name|start_symbol
expr_stmt|;
name|rrhs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rrhs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rrhs
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
name|j
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|nrules
condition|;
operator|++
name|i
control|)
block|{
name|rlhs
index|[
name|i
index|]
operator|=
name|plhs
index|[
name|i
index|]
operator|->
name|index
expr_stmt|;
name|rrhs
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|assoc
operator|=
name|TOKEN
expr_stmt|;
name|prec2
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pitem
index|[
name|j
index|]
condition|)
block|{
name|ritem
index|[
name|j
index|]
operator|=
name|pitem
index|[
name|j
index|]
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|pitem
index|[
name|j
index|]
operator|->
name|class
operator|==
name|TERM
condition|)
block|{
name|prec2
operator|=
name|pitem
index|[
name|j
index|]
operator|->
name|prec
expr_stmt|;
name|assoc
operator|=
name|pitem
index|[
name|j
index|]
operator|->
name|assoc
expr_stmt|;
block|}
operator|++
name|j
expr_stmt|;
block|}
name|ritem
index|[
name|j
index|]
operator|=
operator|(
name|Value_t
operator|)
operator|-
name|i
expr_stmt|;
operator|++
name|j
expr_stmt|;
if|if
condition|(
name|rprec
index|[
name|i
index|]
operator|==
name|UNDEFINED
condition|)
block|{
name|rprec
index|[
name|i
index|]
operator|=
name|prec2
expr_stmt|;
name|rassoc
index|[
name|i
index|]
operator|=
name|assoc
expr_stmt|;
block|}
block|}
name|rrhs
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|FREE
argument_list|(
name|plhs
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pitem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_grammar
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|size_t
name|j
decl_stmt|,
name|spacing
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|verbose_file
decl_stmt|;
if|if
condition|(
operator|!
name|vflag
condition|)
return|return;
name|k
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|nrules
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|rlhs
index|[
name|i
index|]
operator|!=
name|rlhs
index|[
name|i
operator|-
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|i
operator|!=
literal|2
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%4d  %s :"
argument_list|,
name|i
operator|-
literal|2
argument_list|,
name|symbol_name
index|[
name|rlhs
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|spacing
operator|=
name|strlen
argument_list|(
name|symbol_name
index|[
name|rlhs
index|[
name|i
index|]
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%4d  "
argument_list|,
name|i
operator|-
literal|2
argument_list|)
expr_stmt|;
name|j
operator|=
name|spacing
expr_stmt|;
while|while
condition|(
name|j
operator|--
operator|!=
literal|0
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'|'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|ritem
index|[
name|k
index|]
operator|>=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %s"
argument_list|,
name|symbol_name
index|[
name|ritem
index|[
name|k
index|]
index|]
argument_list|)
expr_stmt|;
operator|++
name|k
expr_stmt|;
block|}
operator|++
name|k
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|reader
parameter_list|(
name|void
parameter_list|)
block|{
name|write_section
argument_list|(
name|code_file
argument_list|,
name|banner
argument_list|)
expr_stmt|;
name|create_symbol_table
argument_list|()
expr_stmt|;
name|read_declarations
argument_list|()
expr_stmt|;
name|read_grammar
argument_list|()
expr_stmt|;
name|free_symbol_table
argument_list|()
expr_stmt|;
name|free_tags
argument_list|()
expr_stmt|;
name|pack_names
argument_list|()
expr_stmt|;
name|check_symbols
argument_list|()
expr_stmt|;
name|pack_symbols
argument_list|()
expr_stmt|;
name|pack_grammar
argument_list|()
expr_stmt|;
name|free_symbols
argument_list|()
expr_stmt|;
name|print_grammar
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NO_LEAKS
end_ifdef

begin_function
specifier|static
name|param
modifier|*
name|free_declarations
parameter_list|(
name|param
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
operator|!=
literal|0
condition|)
block|{
name|param
modifier|*
name|next
init|=
name|list
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|list
operator|->
name|type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
operator|->
name|type2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|next
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function

begin_function
name|void
name|reader_leaks
parameter_list|(
name|void
parameter_list|)
block|{
name|lex_param
operator|=
name|free_declarations
argument_list|(
name|lex_param
argument_list|)
expr_stmt|;
name|parse_param
operator|=
name|free_declarations
argument_list|(
name|parse_param
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|rrhs
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|rlhs
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|rprec
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|ritem
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|rassoc
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|name_pool
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|symbol_prec
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|symbol_assoc
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|symbol_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

