begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: reader.c,v 1.68 2017/02/02 01:05:36 tom Exp $ */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/*  The line size must be a positive integer.  One hundred was chosen	*/
end_comment

begin_comment
comment|/*  because few lines in Yacc input grammars exceed 100 characters.	*/
end_comment

begin_comment
comment|/*  Note that if a line exceeds LINESIZE characters, the line buffer	*/
end_comment

begin_comment
comment|/*  will be expanded to accomodate it.					*/
end_comment

begin_define
define|#
directive|define
name|LINESIZE
value|100
end_define

begin_define
define|#
directive|define
name|L_CURL
value|'{'
end_define

begin_define
define|#
directive|define
name|R_CURL
value|'}'
end_define

begin_define
define|#
directive|define
name|L_PAREN
value|'('
end_define

begin_define
define|#
directive|define
name|R_PAREN
value|')'
end_define

begin_define
define|#
directive|define
name|L_BRAC
value|'['
end_define

begin_define
define|#
directive|define
name|R_BRAC
value|']'
end_define

begin_comment
comment|/* the maximum number of arguments (inherited attributes) to a non-terminal */
end_comment

begin_comment
comment|/* this is a hard limit, but seems more than adequate */
end_comment

begin_define
define|#
directive|define
name|MAXARGS
value|20
end_define

begin_function_decl
specifier|static
name|void
name|start_rule
parameter_list|(
name|bucket
modifier|*
name|bp
parameter_list|,
name|int
name|s_lineno
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|copy_initial_action
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_destructor
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|process_destructor_XX
parameter_list|(
name|char
modifier|*
name|code
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CACHE_SIZE
value|256
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cinc
decl_stmt|,
name|cache_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ntags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tagmax
decl_stmt|,
name|havetags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|tag_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|saw_eof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|unionized
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cptr
decl_stmt|,
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|linesize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bucket
modifier|*
name|goal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Value_t
name|prec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gensym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|last_was_action
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|trialaction
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|maxitems
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bucket
modifier|*
modifier|*
name|pitem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maxrules
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bucket
modifier|*
modifier|*
name|plhs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|name_pool_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|name_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|line_format
index|[]
init|=
literal|"#line %d \"%s\"\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|param
modifier|*
name|lex_param
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|param
modifier|*
name|parse_param
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
end_if

begin_decl_stmt
name|int
name|destructor
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* =1 if at least one %destructor */
end_comment

begin_decl_stmt
specifier|static
name|bucket
modifier|*
name|default_destructor
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UNTYPED_DEFAULT
value|0
end_define

begin_define
define|#
directive|define
name|TYPED_DEFAULT
value|1
end_define

begin_define
define|#
directive|define
name|TYPE_SPECIFIED
value|2
end_define

begin_function
specifier|static
name|bucket
modifier|*
name|lookup_type_destructor
parameter_list|(
name|char
modifier|*
name|tag
parameter_list|)
block|{
specifier|const
name|char
name|fmt
index|[]
init|=
literal|"%.*s destructor"
decl_stmt|;
name|char
name|name
index|[
literal|1024
index|]
init|=
literal|"\0"
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|,
modifier|*
modifier|*
name|bpp
init|=
operator|&
name|default_destructor
index|[
name|TYPE_SPECIFIED
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
operator|*
name|bpp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|tag
operator|==
name|tag
condition|)
return|return
operator|(
name|bp
operator|)
return|;
name|bpp
operator|=
operator|&
name|bp
operator|->
name|link
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|name
argument_list|,
name|fmt
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|name
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|fmt
argument_list|)
argument_list|)
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|bp
operator|=
name|make_bucket
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(YYBTYACC) */
end_comment

begin_function
specifier|static
name|void
name|cachec
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|assert
argument_list|(
name|cinc
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinc
operator|>=
name|cache_size
condition|)
block|{
name|cache_size
operator|+=
name|CACHE_SIZE
expr_stmt|;
name|cache
operator|=
name|TREALLOC
argument_list|(
name|char
argument_list|,
name|cache
argument_list|,
name|cache_size
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
name|cache
index|[
name|cinc
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
operator|++
name|cinc
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
name|ldSPC1
block|,
name|ldSPC2
block|,
name|ldNAME
block|,
name|ldSPC3
block|,
name|ldNUM
block|,
name|ldSPC4
block|,
name|ldFILE
block|,
name|ldOK
block|,
name|ldERR
block|}
name|LINE_DIR
typedef|;
end_typedef

begin_comment
comment|/*  * Expect this pattern:  *	/^[[:space:]]*#[[:space:]]*  *	  line[[:space:]]+  *	  [[:digit:]]+  *	  ([[:space:]]*|[[:space:]]+"[^"]+")/  */
end_comment

begin_function
specifier|static
name|int
name|line_directive
parameter_list|(
name|void
parameter_list|)
block|{
define|#
directive|define
name|UNLESS
parameter_list|(
name|what
parameter_list|)
value|if (what) { ld = ldERR; break; }
name|int
name|n
decl_stmt|;
name|int
name|line_1st
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|name_1st
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|name_end
init|=
operator|-
literal|1
decl_stmt|;
name|LINE_DIR
name|ld
init|=
name|ldSPC1
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|(
name|ld
operator|<=
name|ldOK
operator|)
operator|&&
operator|(
name|line
index|[
name|n
index|]
operator|!=
literal|'\0'
operator|)
condition|;
operator|++
name|n
control|)
block|{
name|int
name|ch
init|=
name|UCH
argument_list|(
name|line
index|[
name|n
index|]
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ld
condition|)
block|{
case|case
name|ldSPC1
case|:
if|if
condition|(
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
name|UNLESS
argument_list|(
name|ch
operator|!=
literal|'#'
argument_list|)
expr_stmt|;
name|ld
operator|=
name|ldSPC2
expr_stmt|;
break|break;
case|case
name|ldSPC2
case|:
if|if
condition|(
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
break|break;
block|}
comment|/* FALLTHRU */
case|case
name|ldNAME
case|:
name|UNLESS
argument_list|(
name|strncmp
argument_list|(
name|line
operator|+
name|n
argument_list|,
literal|"line"
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|line
index|[
name|n
index|]
operator|==
literal|'\0'
condition|)
block|{
name|ld
operator|=
name|ldOK
expr_stmt|;
break|break;
block|}
else|else
name|UNLESS
argument_list|(
operator|!
name|isspace
argument_list|(
name|UCH
argument_list|(
name|line
index|[
name|n
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ld
operator|=
name|ldSPC3
expr_stmt|;
break|break;
case|case
name|ldSPC3
case|:
if|if
condition|(
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
name|UNLESS
argument_list|(
operator|!
name|isdigit
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
name|line_1st
operator|=
name|n
expr_stmt|;
name|ld
operator|=
name|ldNUM
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|ldNUM
case|:
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
name|UNLESS
argument_list|(
operator|!
name|isspace
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
name|ld
operator|=
name|ldSPC4
expr_stmt|;
break|break;
case|case
name|ldSPC4
case|:
if|if
condition|(
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
name|UNLESS
argument_list|(
name|ch
operator|!=
literal|'"'
argument_list|)
expr_stmt|;
name|UNLESS
argument_list|(
name|line
index|[
name|n
operator|+
literal|1
index|]
operator|==
literal|'"'
argument_list|)
expr_stmt|;
name|ld
operator|=
name|ldFILE
expr_stmt|;
name|name_1st
operator|=
name|n
expr_stmt|;
break|break;
case|case
name|ldFILE
case|:
if|if
condition|(
name|ch
operator|!=
literal|'"'
condition|)
block|{
break|break;
block|}
name|ld
operator|=
name|ldOK
expr_stmt|;
name|name_end
operator|=
name|n
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|ldERR
case|:
case|case
name|ldOK
case|:
break|break;
block|}
block|}
if|if
condition|(
name|ld
operator|==
name|ldOK
condition|)
block|{
name|size_t
name|need
init|=
call|(
name|size_t
call|)
argument_list|(
name|name_end
operator|-
name|name_1st
argument_list|)
decl_stmt|;
if|if
condition|(
name|need
operator|>
name|input_file_name_len
condition|)
block|{
name|input_file_name_len
operator|=
name|need
expr_stmt|;
name|input_file_name
operator|=
name|TREALLOC
argument_list|(
name|char
argument_list|,
name|input_file_name
argument_list|,
name|need
operator|+
literal|1
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|input_file_name
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|input_file_name
argument_list|,
name|line
operator|+
name|name_1st
operator|+
literal|1
argument_list|,
name|need
operator|-
literal|1
argument_list|)
expr_stmt|;
name|input_file_name
index|[
name|need
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|ld
operator|>=
name|ldNUM
operator|&&
name|ld
operator|<
name|ldERR
condition|)
block|{
name|lineno
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|line
operator|+
name|line_1st
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ld
operator|==
name|ldOK
operator|)
return|;
undef|#
directive|undef
name|UNLESS
block|}
end_function

begin_function
specifier|static
name|void
name|get_line
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|input_file
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
do|do
block|{
if|if
condition|(
name|saw_eof
operator|||
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|line
condition|)
block|{
name|FREE
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
literal|0
expr_stmt|;
block|}
name|cptr
operator|=
literal|0
expr_stmt|;
name|saw_eof
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|line
operator|==
name|NULL
operator|||
name|linesize
operator|!=
operator|(
name|LINESIZE
operator|+
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|line
condition|)
name|FREE
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|linesize
operator|=
name|LINESIZE
operator|+
literal|1
expr_stmt|;
name|line
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|linesize
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
operator|++
name|lineno
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|line
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
operator|(
name|i
operator|+
literal|3
operator|)
operator|>=
name|linesize
condition|)
block|{
name|linesize
operator|+=
name|LINESIZE
expr_stmt|;
name|line
operator|=
name|TREALLOC
argument_list|(
name|char
argument_list|,
name|line
argument_list|,
name|linesize
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|line
index|[
name|i
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|saw_eof
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|line
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
do|while
condition|(
name|line_directive
argument_list|()
condition|)
do|;
name|cptr
operator|=
name|line
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|dup_line
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|s
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\n'
condition|)
operator|++
name|s
expr_stmt|;
name|p
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|s
operator|-
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|s
operator|=
name|line
expr_stmt|;
name|t
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
continue|continue;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|skip_comment
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|ainfo
name|a
decl_stmt|;
name|a
operator|.
name|a_lineno
operator|=
name|lineno
expr_stmt|;
name|a
operator|.
name|a_line
operator|=
name|dup_line
argument_list|()
expr_stmt|;
name|a
operator|.
name|a_cptr
operator|=
name|a
operator|.
name|a_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|)
expr_stmt|;
name|s
operator|=
name|cptr
operator|+
literal|2
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|cptr
operator|=
name|s
operator|+
literal|2
expr_stmt|;
name|FREE
argument_list|(
name|a
operator|.
name|a_line
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
name|unterminated_comment
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
name|s
operator|=
name|cptr
expr_stmt|;
block|}
else|else
operator|++
name|s
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|next_inline
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
block|}
name|s
operator|=
name|cptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'/'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|cptr
operator|=
name|s
expr_stmt|;
name|skip_comment
argument_list|()
expr_stmt|;
name|s
operator|=
name|cptr
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
name|s
operator|=
name|cptr
expr_stmt|;
break|break;
block|}
comment|/* FALLTHRU */
default|default:
name|cptr
operator|=
name|s
expr_stmt|;
return|return
operator|(
operator|*
name|s
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nextc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|int
name|finish
init|=
literal|0
decl_stmt|;
do|do
block|{
switch|switch
condition|(
name|ch
operator|=
name|next_inline
argument_list|()
condition|)
block|{
case|case
literal|'\n'
case|:
name|get_line
argument_list|()
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\v'
case|:
case|case
literal|','
case|:
case|case
literal|';'
case|:
operator|++
name|cptr
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|ch
operator|=
literal|'%'
expr_stmt|;
comment|/* FALLTHRU */
default|default:
name|finish
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|!
name|finish
condition|)
do|;
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_struct
specifier|static
struct|struct
name|keyword
block|{
name|char
name|name
index|[
literal|14
index|]
decl_stmt|;
name|int
name|token
decl_stmt|;
block|}
name|keywords
index|[]
init|=
block|{
block|{
literal|"binary"
block|,
name|NONASSOC
block|}
block|,
block|{
literal|"debug"
block|,
name|XXXDEBUG
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
block|{
literal|"destructor"
block|,
name|DESTRUCTOR
block|}
block|,
endif|#
directive|endif
block|{
literal|"error-verbose"
block|,
name|ERROR_VERBOSE
block|}
block|,
block|{
literal|"expect"
block|,
name|EXPECT
block|}
block|,
block|{
literal|"expect-rr"
block|,
name|EXPECT_RR
block|}
block|,
block|{
literal|"ident"
block|,
name|IDENT
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
block|{
literal|"initial-action"
block|,
name|INITIAL_ACTION
block|}
block|,
endif|#
directive|endif
block|{
literal|"left"
block|,
name|LEFT
block|}
block|,
block|{
literal|"lex-param"
block|,
name|LEX_PARAM
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
block|{
literal|"locations"
block|,
name|LOCATIONS
block|}
block|,
endif|#
directive|endif
block|{
literal|"nonassoc"
block|,
name|NONASSOC
block|}
block|,
block|{
literal|"parse-param"
block|,
name|PARSE_PARAM
block|}
block|,
block|{
literal|"pure-parser"
block|,
name|PURE_PARSER
block|}
block|,
block|{
literal|"right"
block|,
name|RIGHT
block|}
block|,
block|{
literal|"start"
block|,
name|START
block|}
block|,
block|{
literal|"term"
block|,
name|TOKEN
block|}
block|,
block|{
literal|"token"
block|,
name|TOKEN
block|}
block|,
block|{
literal|"token-table"
block|,
name|TOKEN_TABLE
block|}
block|,
block|{
literal|"type"
block|,
name|TYPE
block|}
block|,
block|{
literal|"union"
block|,
name|UNION
block|}
block|,
block|{
literal|"yacc"
block|,
name|POSIX_YACC
block|}
block|, }
struct|;
end_struct

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_function
specifier|static
name|int
name|compare_keys
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|keyword
modifier|*
name|p
init|=
operator|(
specifier|const
expr|struct
name|keyword
operator|*
operator|)
name|a
decl_stmt|;
specifier|const
name|struct
name|keyword
modifier|*
name|q
init|=
operator|(
specifier|const
expr|struct
name|keyword
operator|*
operator|)
name|b
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|q
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|keyword
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|t_cptr
init|=
name|cptr
decl_stmt|;
name|struct
name|keyword
modifier|*
name|key
decl_stmt|;
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|cinc
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'$'
condition|)
block|{
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
block|{
comment|/* treat keywords spelled with '_' as if it were '-' */
name|cachec
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
block|}
name|cachec
argument_list|(
name|NUL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|key
operator|=
name|bsearch
argument_list|(
name|cache
argument_list|,
name|keywords
argument_list|,
sizeof|sizeof
argument_list|(
name|keywords
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|key
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|key
argument_list|)
argument_list|,
name|compare_keys
argument_list|)
operator|)
condition|)
return|return
name|key
operator|->
name|token
return|;
block|}
else|else
block|{
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|L_CURL
condition|)
return|return
operator|(
name|TEXT
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'%'
operator|||
name|c
operator|==
literal|'\\'
condition|)
return|return
operator|(
name|MARK
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
return|return
operator|(
name|LEFT
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
return|return
operator|(
name|RIGHT
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
return|return
operator|(
name|TOKEN
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'2'
condition|)
return|return
operator|(
name|NONASSOC
operator|)
return|;
block|}
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|t_cptr
argument_list|)
expr_stmt|;
comment|/*NOTREACHED */
block|}
end_function

begin_function
specifier|static
name|void
name|copy_ident
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|output_file
decl_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'"'
condition|)
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"#ident \""
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|copy_string
parameter_list|(
name|int
name|quote
parameter_list|)
block|{
name|struct
name|mstring
modifier|*
name|temp
init|=
name|msnew
argument_list|()
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|ainfo
name|a
decl_stmt|;
name|a
operator|.
name|a_lineno
operator|=
name|lineno
expr_stmt|;
name|a
operator|.
name|a_line
operator|=
name|dup_line
argument_list|()
expr_stmt|;
name|a
operator|.
name|a_cptr
operator|=
name|a
operator|.
name|a_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|mputc
argument_list|(
name|temp
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quote
condition|)
block|{
name|FREE
argument_list|(
name|a
operator|.
name|a_line
argument_list|)
expr_stmt|;
return|return
name|msdone
argument_list|(
name|temp
argument_list|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|unterminated_string
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|mputc
argument_list|(
name|temp
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
name|unterminated_string
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|copy_comment
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mstring
modifier|*
name|temp
init|=
name|msnew
argument_list|()
decl_stmt|;
name|int
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
name|mputc
argument_list|(
name|temp
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|cptr
operator|)
operator|!=
literal|'\n'
condition|)
block|{
name|mputc
argument_list|(
name|temp
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
name|cptr
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|mputc
argument_list|(
name|temp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|mputc
argument_list|(
name|temp
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
name|mputc
argument_list|(
name|temp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
name|struct
name|ainfo
name|a
decl_stmt|;
name|a
operator|.
name|a_lineno
operator|=
name|lineno
expr_stmt|;
name|a
operator|.
name|a_line
operator|=
name|dup_line
argument_list|()
expr_stmt|;
name|a
operator|.
name|a_cptr
operator|=
name|a
operator|.
name|a_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|1
operator|)
expr_stmt|;
name|mputc
argument_list|(
name|temp
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|mputc
argument_list|(
name|temp
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
operator|*
name|cptr
operator|==
literal|'/'
condition|)
block|{
name|mputc
argument_list|(
name|temp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
name|FREE
argument_list|(
name|a
operator|.
name|a_line
argument_list|)
expr_stmt|;
return|return
name|msdone
argument_list|(
name|temp
argument_list|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
name|unterminated_comment
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|msdone
argument_list|(
name|temp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_text
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|text_file
decl_stmt|;
name|int
name|need_newline
init|=
literal|0
decl_stmt|;
name|struct
name|ainfo
name|a
decl_stmt|;
name|a
operator|.
name|a_lineno
operator|=
name|lineno
expr_stmt|;
name|a
operator|.
name|a_line
operator|=
name|dup_line
argument_list|()
expr_stmt|;
name|a
operator|.
name|a_cptr
operator|=
name|a
operator|.
name|a_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|2
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|cptr
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
name|unterminated_text
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lflag
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
name|line_format
argument_list|,
name|lineno
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
name|loop
label|:
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|need_newline
operator|=
literal|0
expr_stmt|;
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
condition|)
goto|goto
name|loop
goto|;
name|unterminated_text
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|s
init|=
name|copy_string
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|fputs
argument_list|(
name|s
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|need_newline
operator|=
literal|1
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'/'
case|:
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|s
init|=
name|copy_comment
argument_list|()
decl_stmt|;
name|fputs
argument_list|(
name|s
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|need_newline
operator|=
literal|1
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'%'
case|:
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|cptr
operator|==
name|R_CURL
condition|)
block|{
if|if
condition|(
name|need_newline
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
name|FREE
argument_list|(
name|a
operator|.
name|a_line
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FALLTHRU */
default|default:
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|need_newline
operator|=
literal|1
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|puts_both
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|fputs
argument_list|(
name|s
argument_list|,
name|text_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|fputs
argument_list|(
name|s
argument_list|,
name|union_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|putc_both
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|text_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|union_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_union
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|struct
name|ainfo
name|a
decl_stmt|;
name|a
operator|.
name|a_lineno
operator|=
name|lineno
expr_stmt|;
name|a
operator|.
name|a_line
operator|=
name|dup_line
argument_list|()
expr_stmt|;
name|a
operator|.
name|a_cptr
operator|=
name|a
operator|.
name|a_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|6
operator|)
expr_stmt|;
if|if
condition|(
name|unionized
condition|)
name|over_unionized
argument_list|(
name|cptr
operator|-
literal|6
argument_list|)
expr_stmt|;
name|unionized
operator|=
literal|1
expr_stmt|;
name|puts_both
argument_list|(
literal|"#ifdef YYSTYPE\n"
argument_list|)
expr_stmt|;
name|puts_both
argument_list|(
literal|"#undef  YYSTYPE_IS_DECLARED\n"
argument_list|)
expr_stmt|;
name|puts_both
argument_list|(
literal|"#define YYSTYPE_IS_DECLARED 1\n"
argument_list|)
expr_stmt|;
name|puts_both
argument_list|(
literal|"#endif\n"
argument_list|)
expr_stmt|;
name|puts_both
argument_list|(
literal|"#ifndef YYSTYPE_IS_DECLARED\n"
argument_list|)
expr_stmt|;
name|puts_both
argument_list|(
literal|"#define YYSTYPE_IS_DECLARED 1\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lflag
condition|)
name|fprintf
argument_list|(
name|text_file
argument_list|,
name|line_format
argument_list|,
name|lineno
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
name|puts_both
argument_list|(
literal|"typedef union"
argument_list|)
expr_stmt|;
name|depth
operator|=
literal|0
expr_stmt|;
name|loop
label|:
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc_both
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
name|unterminated_union
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|L_CURL
case|:
operator|++
name|depth
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|R_CURL
case|:
if|if
condition|(
operator|--
name|depth
operator|==
literal|0
condition|)
block|{
name|puts_both
argument_list|(
literal|" YYSTYPE;\n"
argument_list|)
expr_stmt|;
name|puts_both
argument_list|(
literal|"#endif /* !YYSTYPE_IS_DECLARED */\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|a
operator|.
name|a_line
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|loop
goto|;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
block|{
name|char
modifier|*
name|s
init|=
name|copy_string
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|puts_both
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
case|case
literal|'/'
case|:
block|{
name|char
modifier|*
name|s
init|=
name|copy_comment
argument_list|()
decl_stmt|;
name|puts_both
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
default|default:
goto|goto
name|loop
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|after_blanks
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
name|UCH
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Trim leading/trailing blanks, and collapse multiple embedded blanks to a  * single space.  Return index to last character in the buffer.  */
end_comment

begin_function
specifier|static
name|int
name|trim_blanks
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|)
block|{
if|if
condition|(
operator|*
name|buffer
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|d
init|=
name|buffer
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|after_blanks
argument_list|(
name|d
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
empty_stmt|;
block|}
operator|--
name|d
expr_stmt|;
while|while
condition|(
operator|(
operator|--
name|d
operator|!=
name|buffer
operator|)
operator|&&
name|isspace
argument_list|(
name|UCH
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
condition|)
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|s
operator|=
name|d
operator|=
name|buffer
init|;
operator|(
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|;
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|UCH
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|s
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|UCH
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|--
name|s
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Scan forward in the current line-buffer looking for a right-curly bracket.  *  * Parameters begin with a left-curly bracket, and continue until there are no  * more interesting characters after the last right-curly bracket on the  * current line.  Bison documents parameters as separated like this:  *	{type param1} {type2 param2}  * but also accepts commas (although some versions of bison mishandle this)  *	{type param1,  type2 param2}  */
end_comment

begin_function
specifier|static
name|int
name|more_curly
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|save
init|=
name|cptr
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|int
name|finish
init|=
literal|0
decl_stmt|;
do|do
block|{
switch|switch
condition|(
name|next_inline
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|'\n'
case|:
name|finish
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_CURL
case|:
name|finish
operator|=
literal|1
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
break|break;
block|}
operator|++
name|cptr
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|finish
condition|)
do|;
name|cptr
operator|=
name|save
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_param
parameter_list|(
name|int
name|k
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|name
parameter_list|,
name|int
name|type2
parameter_list|)
block|{
name|param
modifier|*
name|head
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|TMALLOC
argument_list|(
name|param
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|type2
operator|=
name|strdup
argument_list|(
name|buffer
operator|+
name|type2
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|p
operator|->
name|type2
argument_list|)
expr_stmt|;
name|buffer
index|[
name|type2
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|trim_blanks
argument_list|(
name|p
operator|->
name|type2
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|buffer
operator|+
name|name
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|buffer
index|[
name|name
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|trim_blanks
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|strdup
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|trim_blanks
argument_list|(
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|LEX_PARAM
condition|)
name|head
operator|=
name|lex_param
expr_stmt|;
else|else
name|head
operator|=
name|parse_param
expr_stmt|;
if|if
condition|(
name|head
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|head
operator|->
name|next
condition|)
name|head
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|head
operator|->
name|next
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|k
operator|==
name|LEX_PARAM
condition|)
name|lex_param
operator|=
name|p
expr_stmt|;
else|else
name|parse_param
operator|=
name|p
expr_stmt|;
block|}
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Keep a linked list of parameters.  This may be multi-line, if the trailing  * right-curly bracket is absent.  */
end_comment

begin_function
specifier|static
name|void
name|copy_param
parameter_list|(
name|int
name|k
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|name
decl_stmt|,
name|type2
decl_stmt|;
name|int
name|curly
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
name|size_t
name|buf_size
init|=
literal|0
decl_stmt|;
name|int
name|st_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|comma
decl_stmt|;
do|do
block|{
name|int
name|state
init|=
name|curly
decl_stmt|;
name|c
operator|=
name|next_inline
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
name|unexpected_EOF
argument_list|()
expr_stmt|;
break|break;
case|case
name|L_CURL
case|:
if|if
condition|(
name|curly
operator|==
literal|1
condition|)
block|{
goto|goto
name|oops
goto|;
block|}
name|curly
operator|=
literal|1
expr_stmt|;
name|st_lineno
operator|=
name|lineno
expr_stmt|;
break|break;
case|case
name|R_CURL
case|:
if|if
condition|(
name|curly
operator|!=
literal|1
condition|)
block|{
goto|goto
name|oops
goto|;
block|}
name|curly
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
if|if
condition|(
name|curly
operator|==
literal|0
condition|)
block|{
goto|goto
name|oops
goto|;
block|}
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
operator|(
name|curly
operator|==
literal|1
operator|)
operator|&&
operator|(
name|cptr
operator|==
name|line
operator|)
condition|)
block|{
name|lineno
operator|=
name|st_lineno
expr_stmt|;
name|missing_brace
argument_list|()
expr_stmt|;
block|}
comment|/* FALLTHRU */
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
goto|goto
name|oops
goto|;
default|default:
if|if
condition|(
name|curly
operator|==
literal|0
operator|&&
operator|!
name|isspace
argument_list|(
name|UCH
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
block|{
goto|goto
name|oops
goto|;
block|}
break|break;
block|}
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
block|{
name|buf_size
operator|=
operator|(
name|size_t
operator|)
name|linesize
expr_stmt|;
name|buf
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
operator|--
name|cptr
expr_stmt|;
name|buf_size
operator|+=
operator|(
name|size_t
operator|)
name|linesize
expr_stmt|;
name|buf
operator|=
name|TREALLOC
argument_list|(
name|char
argument_list|,
name|buf
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
block|}
name|NO_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|curly
condition|)
block|{
if|if
condition|(
operator|(
name|state
operator|==
literal|2
operator|)
operator|&&
operator|(
name|c
operator|==
name|L_CURL
operator|)
condition|)
block|{
name|buf
index|[
operator|++
name|i
index|]
operator|=
literal|','
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
literal|2
operator|)
operator|&&
name|isspace
argument_list|(
name|UCH
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|!=
name|L_CURL
operator|)
operator|&&
operator|(
name|c
operator|!=
name|R_CURL
operator|)
condition|)
block|{
name|buf
index|[
operator|++
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
block|}
block|}
name|cptr
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|curly
operator|<
literal|2
operator|||
name|more_curly
argument_list|()
condition|)
do|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|curly
operator|==
literal|1
condition|)
block|{
name|lineno
operator|=
name|st_lineno
expr_stmt|;
name|missing_brace
argument_list|()
expr_stmt|;
block|}
goto|goto
name|oops
goto|;
block|}
name|buf
index|[
operator|++
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|trim_blanks
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|comma
operator|=
name|buf
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|char
modifier|*
name|parms
init|=
operator|(
name|comma
operator|+
literal|1
operator|)
decl_stmt|;
name|comma
operator|=
name|strchr
argument_list|(
name|parms
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|comma
operator|!=
literal|0
condition|)
operator|*
name|comma
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|trim_blanks
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|parms
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
goto|goto
name|oops
goto|;
block|}
if|if
condition|(
name|parms
index|[
name|i
index|]
operator|==
literal|']'
condition|)
block|{
name|int
name|level
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
operator|&&
name|level
operator|>
literal|0
operator|&&
name|parms
index|[
name|i
index|]
operator|!=
literal|'['
condition|)
block|{
if|if
condition|(
name|parms
index|[
name|i
index|]
operator|==
literal|']'
condition|)
operator|++
name|level
expr_stmt|;
elseif|else
if|if
condition|(
name|parms
index|[
name|i
index|]
operator|==
literal|'['
condition|)
operator|--
name|level
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
name|type2
operator|=
name|i
operator|--
expr_stmt|;
block|}
else|else
block|{
name|type2
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
operator|(
name|isalnum
argument_list|(
name|UCH
argument_list|(
name|parms
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|||
name|UCH
argument_list|(
name|parms
index|[
name|i
index|]
argument_list|)
operator|==
literal|'_'
operator|)
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|UCH
argument_list|(
name|parms
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|&&
name|parms
index|[
name|i
index|]
operator|!=
literal|'*'
condition|)
goto|goto
name|oops
goto|;
name|name
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|save_param
argument_list|(
name|k
argument_list|,
name|parms
argument_list|,
name|name
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|comma
operator|!=
literal|0
condition|)
do|;
name|FREE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
name|oops
label|:
name|FREE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hexval
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
return|return
operator|(
name|c
operator|-
literal|'0'
operator|)
return|;
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
return|return
operator|(
name|c
operator|-
literal|'A'
operator|+
literal|10
operator|)
return|;
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
return|return
operator|(
name|c
operator|-
literal|'a'
operator|+
literal|10
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bucket
modifier|*
name|get_literal
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|quote
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|;
name|struct
name|ainfo
name|a
decl_stmt|;
name|a
operator|.
name|a_lineno
operator|=
name|lineno
expr_stmt|;
name|a
operator|.
name|a_line
operator|=
name|dup_line
argument_list|()
expr_stmt|;
name|a
operator|.
name|a_cptr
operator|=
name|a
operator|.
name|a_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|)
expr_stmt|;
name|quote
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|cinc
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quote
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|unterminated_string
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|char
modifier|*
name|c_cptr
init|=
name|cptr
operator|-
literal|1
decl_stmt|;
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
name|unterminated_string
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|n
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|IS_OCTAL
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|n
operator|=
operator|(
name|n
operator|<<
literal|3
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|IS_OCTAL
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|n
operator|=
operator|(
name|n
operator|<<
literal|3
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|>
name|MAXCHAR
condition|)
name|illegal_character
argument_list|(
name|c_cptr
argument_list|)
expr_stmt|;
name|c
operator|=
name|n
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|n
operator|=
name|hexval
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
literal|16
condition|)
name|illegal_character
argument_list|(
name|c_cptr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
name|i
operator|=
name|hexval
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
literal|16
condition|)
break|break;
operator|++
name|cptr
expr_stmt|;
name|n
operator|=
operator|(
name|n
operator|<<
literal|4
operator|)
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|MAXCHAR
condition|)
name|illegal_character
argument_list|(
name|c_cptr
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|n
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|c
operator|=
literal|7
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|c
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|c
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|c
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|c
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|c
operator|=
literal|'\v'
expr_stmt|;
break|break;
block|}
block|}
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|a
operator|.
name|a_line
argument_list|)
expr_stmt|;
name|n
operator|=
name|cinc
expr_stmt|;
name|s
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|s
index|[
name|i
index|]
operator|=
name|cache
index|[
name|i
index|]
expr_stmt|;
name|cinc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
name|cachec
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
else|else
name|cachec
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|c
operator|=
name|UCH
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
name|cache
index|[
literal|0
index|]
condition|)
block|{
name|cachec
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|cachec
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|7
case|:
name|cachec
argument_list|(
literal|'a'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|cachec
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|cachec
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|cachec
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|cachec
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|cachec
argument_list|(
literal|'t'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
name|cachec
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cachec
argument_list|(
operator|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|cachec
argument_list|(
operator|(
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|cachec
argument_list|(
operator|(
name|c
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|n
operator|==
literal|1
condition|)
name|cachec
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
else|else
name|cachec
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|cachec
argument_list|(
name|NUL
argument_list|)
expr_stmt|;
name|bp
operator|=
name|lookup
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|bp
operator|->
name|class
operator|=
name|TERM
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
name|bp
operator|->
name|value
operator|==
name|UNDEFINED
condition|)
name|bp
operator|->
name|value
operator|=
name|UCH
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_reserved
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"$accept"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"$end"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'$'
operator|&&
name|isdigit
argument_list|(
name|UCH
argument_list|(
name|name
index|[
literal|2
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|s
operator|=
name|name
operator|+
literal|3
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|UCH
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|NUL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bucket
modifier|*
name|get_name
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|cinc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|cptr
init|;
name|IS_IDENT
argument_list|(
name|c
argument_list|)
condition|;
name|c
operator|=
operator|*
operator|++
name|cptr
control|)
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|cachec
argument_list|(
name|NUL
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_reserved
argument_list|(
name|cache
argument_list|)
condition|)
name|used_reserved
argument_list|(
name|cache
argument_list|)
expr_stmt|;
return|return
operator|(
name|lookup
argument_list|(
name|cache
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|Value_t
name|get_number
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|Value_t
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|cptr
init|;
name|isdigit
argument_list|(
name|c
argument_list|)
condition|;
name|c
operator|=
operator|*
operator|++
name|cptr
control|)
name|n
operator|=
call|(
name|Value_t
call|)
argument_list|(
literal|10
operator|*
name|n
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|cache_tag
parameter_list|(
name|char
modifier|*
name|tag
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntags
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|tag
argument_list|,
name|tag_table
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|tag_table
index|[
name|i
index|]
index|[
name|len
index|]
operator|==
name|NUL
condition|)
return|return
operator|(
name|tag_table
index|[
name|i
index|]
operator|)
return|;
block|}
if|if
condition|(
name|ntags
operator|>=
name|tagmax
condition|)
block|{
name|tagmax
operator|+=
literal|16
expr_stmt|;
name|tag_table
operator|=
operator|(
name|tag_table
condition|?
name|TREALLOC
argument_list|(
name|char
operator|*
argument_list|,
name|tag_table
argument_list|,
name|tagmax
argument_list|)
else|:
name|TMALLOC
argument_list|(
name|char
operator|*
argument_list|,
name|tagmax
argument_list|)
operator|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|tag_table
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|s
argument_list|,
name|tag
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|tag_table
index|[
name|ntags
operator|++
index|]
operator|=
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_tag
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|t_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|t_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|t_cptr
init|=
name|t_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|)
decl_stmt|;
operator|++
name|cptr
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
name|illegal_tag
argument_list|(
name|t_lineno
argument_list|,
name|t_line
argument_list|,
name|t_cptr
argument_list|)
expr_stmt|;
name|cinc
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
block|}
do|while
condition|(
name|IS_IDENT
argument_list|(
name|c
argument_list|)
condition|)
do|;
name|cachec
argument_list|(
name|NUL
argument_list|)
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'>'
condition|)
name|illegal_tag
argument_list|(
name|t_lineno
argument_list|,
name|t_line
argument_list|,
name|t_cptr
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
name|FREE
argument_list|(
name|t_line
argument_list|)
expr_stmt|;
name|havetags
operator|=
literal|1
expr_stmt|;
return|return
name|cache_tag
argument_list|(
name|cache
argument_list|,
operator|(
name|size_t
operator|)
name|cinc
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
end_if

begin_function
specifier|static
name|char
modifier|*
name|scan_id
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|b
init|=
name|cptr
decl_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|UCH
argument_list|(
operator|*
name|cptr
argument_list|)
argument_list|)
operator|||
operator|*
name|cptr
operator|==
literal|'_'
operator|||
operator|*
name|cptr
operator|==
literal|'$'
condition|)
name|cptr
operator|++
expr_stmt|;
return|return
name|cache_tag
argument_list|(
name|b
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|cptr
operator|-
name|b
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|declare_tokens
parameter_list|(
name|int
name|assoc
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|;
name|Value_t
name|value
decl_stmt|;
name|char
modifier|*
name|tag
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|assoc
operator|!=
name|TOKEN
condition|)
operator|++
name|prec
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|tag
operator|=
name|get_tag
argument_list|()
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'$'
condition|)
name|bp
operator|=
name|get_name
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
name|bp
operator|=
name|get_literal
argument_list|()
expr_stmt|;
else|else
return|return;
if|if
condition|(
name|bp
operator|==
name|goal
condition|)
name|tokenized_start
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|class
operator|=
name|TERM
expr_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|tag
operator|&&
name|tag
operator|!=
name|bp
operator|->
name|tag
condition|)
name|retyped_warning
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
block|}
if|if
condition|(
name|assoc
operator|!=
name|TOKEN
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|prec
operator|&&
name|prec
operator|!=
name|bp
operator|->
name|prec
condition|)
name|reprec_warning
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|assoc
operator|=
operator|(
name|Assoc_t
operator|)
name|assoc
expr_stmt|;
name|bp
operator|->
name|prec
operator|=
name|prec
expr_stmt|;
block|}
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
name|value
operator|=
name|UNDEFINED
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|value
operator|=
name|get_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|value
operator|!=
name|UNDEFINED
operator|&&
name|value
operator|!=
name|bp
operator|->
name|value
condition|)
name|revalued_warning
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * %expect requires special handling  * as it really isn't part of the yacc  * grammar only a flag for yacc proper.  */
end_comment

begin_function
specifier|static
name|void
name|declare_expect
parameter_list|(
name|int
name|assoc
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|assoc
operator|!=
name|EXPECT
operator|&&
name|assoc
operator|!=
name|EXPECT_RR
condition|)
operator|++
name|prec
expr_stmt|;
comment|/*      * Stay away from nextc - doesn't      * detect EOL and will read to EOF.      */
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|assoc
operator|==
name|EXPECT
condition|)
name|SRexpect
operator|=
name|get_number
argument_list|()
expr_stmt|;
else|else
name|RRexpect
operator|=
name|get_number
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* 	 * Looking for number before EOL. 	 * Spaces, tabs, and numbers are ok, 	 * words, punc., etc. are syntax errors. 	 */
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
end_if

begin_function
specifier|static
name|void
name|declare_argtypes
parameter_list|(
name|bucket
modifier|*
name|bp
parameter_list|)
block|{
name|char
modifier|*
name|tags
index|[
name|MAXARGS
index|]
decl_stmt|;
name|int
name|args
init|=
literal|0
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|args
operator|>=
literal|0
condition|)
name|retyped_warning
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|cptr
operator|++
expr_stmt|;
comment|/* skip open paren */
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'<'
condition|)
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
name|tags
index|[
name|args
operator|++
index|]
operator|=
name|get_tag
argument_list|()
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|R_PAREN
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
block|}
name|cptr
operator|++
expr_stmt|;
comment|/* skip close paren */
name|bp
operator|->
name|args
operator|=
name|args
expr_stmt|;
name|bp
operator|->
name|argnames
operator|=
name|TMALLOC
argument_list|(
name|char
operator|*
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|bp
operator|->
name|argnames
argument_list|)
expr_stmt|;
name|bp
operator|->
name|argtags
operator|=
name|CALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|args
operator|+
literal|1
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|bp
operator|->
name|argtags
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|args
operator|>=
literal|0
condition|)
block|{
name|bp
operator|->
name|argtags
index|[
name|args
index|]
operator|=
name|tags
index|[
name|args
index|]
expr_stmt|;
name|bp
operator|->
name|argnames
index|[
name|args
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|declare_types
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|bucket
modifier|*
name|bp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
name|tag
operator|=
name|get_tag
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'$'
condition|)
block|{
name|bp
operator|=
name|get_name
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|nextc
argument_list|()
operator|==
name|L_PAREN
condition|)
name|declare_argtypes
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|bp
operator|->
name|args
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
block|{
name|bp
operator|=
name|get_literal
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|bp
operator|->
name|args
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
else|else
return|return;
if|if
condition|(
name|tag
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|tag
operator|&&
name|tag
operator|!=
name|bp
operator|->
name|tag
condition|)
name|retyped_warning
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|declare_start
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'.'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
name|bp
operator|=
name|get_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|TERM
condition|)
name|terminal_start
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|goal
operator|&&
name|goal
operator|!=
name|bp
condition|)
name|restarted_warning
argument_list|()
expr_stmt|;
name|goal
operator|=
name|bp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_declarations
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|k
decl_stmt|;
name|cache_size
operator|=
name|CACHE_SIZE
expr_stmt|;
name|cache
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|cache_size
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|cache
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'%'
condition|)
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|k
operator|=
name|keyword
argument_list|()
condition|)
block|{
case|case
name|MARK
case|:
return|return;
case|case
name|IDENT
case|:
name|copy_ident
argument_list|()
expr_stmt|;
break|break;
case|case
name|TEXT
case|:
name|copy_text
argument_list|()
expr_stmt|;
break|break;
case|case
name|UNION
case|:
name|copy_union
argument_list|()
expr_stmt|;
break|break;
case|case
name|TOKEN
case|:
case|case
name|LEFT
case|:
case|case
name|RIGHT
case|:
case|case
name|NONASSOC
case|:
name|declare_tokens
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPECT
case|:
case|case
name|EXPECT_RR
case|:
name|declare_expect
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE
case|:
name|declare_types
argument_list|()
expr_stmt|;
break|break;
case|case
name|START
case|:
name|declare_start
argument_list|()
expr_stmt|;
break|break;
case|case
name|PURE_PARSER
case|:
name|pure_parser
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PARSE_PARAM
case|:
case|case
name|LEX_PARAM
case|:
name|copy_param
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOKEN_TABLE
case|:
name|token_table
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ERROR_VERBOSE
case|:
name|error_verbose
operator|=
literal|1
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
case|case
name|LOCATIONS
case|:
name|locations
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DESTRUCTOR
case|:
name|destructor
operator|=
literal|1
expr_stmt|;
name|copy_destructor
argument_list|()
expr_stmt|;
break|break;
case|case
name|INITIAL_ACTION
case|:
name|copy_initial_action
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|XXXDEBUG
case|:
comment|/* XXX: FIXME */
break|break;
case|case
name|POSIX_YACC
case|:
comment|/* noop for bison compatibility. byacc is already designed to be posix 	     * yacc compatible. */
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|initialize_grammar
parameter_list|(
name|void
parameter_list|)
block|{
name|nitems
operator|=
literal|4
expr_stmt|;
name|maxitems
operator|=
literal|300
expr_stmt|;
name|pitem
operator|=
name|TMALLOC
argument_list|(
name|bucket
operator|*
argument_list|,
name|maxitems
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|pitem
argument_list|)
expr_stmt|;
name|pitem
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|pitem
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pitem
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|pitem
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|nrules
operator|=
literal|3
expr_stmt|;
name|maxrules
operator|=
literal|100
expr_stmt|;
name|plhs
operator|=
name|TMALLOC
argument_list|(
name|bucket
operator|*
argument_list|,
name|maxrules
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|plhs
argument_list|)
expr_stmt|;
name|plhs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|plhs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|plhs
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|rprec
operator|=
name|TMALLOC
argument_list|(
name|Value_t
argument_list|,
name|maxrules
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|rprec
argument_list|)
expr_stmt|;
name|rprec
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rprec
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rprec
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|rassoc
operator|=
name|TMALLOC
argument_list|(
name|Assoc_t
argument_list|,
name|maxrules
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|rassoc
argument_list|)
expr_stmt|;
name|rassoc
index|[
literal|0
index|]
operator|=
name|TOKEN
expr_stmt|;
name|rassoc
index|[
literal|1
index|]
operator|=
name|TOKEN
expr_stmt|;
name|rassoc
index|[
literal|2
index|]
operator|=
name|TOKEN
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expand_items
parameter_list|(
name|void
parameter_list|)
block|{
name|maxitems
operator|+=
literal|300
expr_stmt|;
name|pitem
operator|=
name|TREALLOC
argument_list|(
name|bucket
operator|*
argument_list|,
name|pitem
argument_list|,
name|maxitems
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|pitem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expand_rules
parameter_list|(
name|void
parameter_list|)
block|{
name|maxrules
operator|+=
literal|100
expr_stmt|;
name|plhs
operator|=
name|TREALLOC
argument_list|(
name|bucket
operator|*
argument_list|,
name|plhs
argument_list|,
name|maxrules
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|plhs
argument_list|)
expr_stmt|;
name|rprec
operator|=
name|TREALLOC
argument_list|(
name|Value_t
argument_list|,
name|rprec
argument_list|,
name|maxrules
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|rprec
argument_list|)
expr_stmt|;
name|rassoc
operator|=
name|TREALLOC
argument_list|(
name|Assoc_t
argument_list|,
name|rassoc
argument_list|,
name|maxrules
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|rassoc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set immediately prior to where copy_args() could be called, and incremented by    the various routines that will rescan the argument list as appropriate */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rescan_lineno
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
end_if

begin_function
specifier|static
name|char
modifier|*
name|copy_args
parameter_list|(
name|int
modifier|*
name|alen
parameter_list|)
block|{
name|struct
name|mstring
modifier|*
name|s
init|=
name|msnew
argument_list|()
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|,
name|len
init|=
literal|1
decl_stmt|;
name|char
name|c
decl_stmt|,
name|quote
init|=
literal|0
decl_stmt|;
name|struct
name|ainfo
name|a
decl_stmt|;
name|a
operator|.
name|a_lineno
operator|=
name|lineno
expr_stmt|;
name|a
operator|.
name|a_line
operator|=
name|dup_line
argument_list|()
expr_stmt|;
name|a
operator|.
name|a_cptr
operator|=
name|a
operator|.
name|a_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cptr
operator|++
operator|)
operator|!=
name|R_PAREN
operator|||
name|depth
operator|||
name|quote
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|','
operator|&&
operator|!
name|quote
operator|&&
operator|!
name|depth
condition|)
block|{
name|len
operator|++
expr_stmt|;
name|mputc
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mputc
argument_list|(
name|s
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|line
condition|)
block|{
if|if
condition|(
name|quote
condition|)
name|unterminated_string
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
else|else
name|unterminated_arglist
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|quote
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|quote
condition|)
name|quote
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|*
name|cptr
operator|!=
literal|'\n'
condition|)
name|mputc
argument_list|(
name|s
argument_list|,
operator|*
name|cptr
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
name|L_PAREN
condition|)
name|depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|R_PAREN
condition|)
name|depth
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\''
condition|)
name|quote
operator|=
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|alen
condition|)
operator|*
name|alen
operator|=
name|len
expr_stmt|;
name|FREE
argument_list|(
name|a
operator|.
name|a_line
argument_list|)
expr_stmt|;
return|return
name|msdone
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_id
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
modifier|*
name|save
parameter_list|)
block|{
name|char
modifier|*
name|b
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|UCH
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\n'
condition|)
name|rescan_lineno
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|UCH
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'_'
condition|)
return|return
name|NULL
return|;
name|b
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|UCH
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|||
operator|*
name|p
operator|==
literal|'$'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|save
condition|)
block|{
operator|*
name|save
operator|=
name|cache_tag
argument_list|(
name|b
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_int
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|int
modifier|*
name|save
parameter_list|)
block|{
name|int
name|neg
init|=
literal|0
decl_stmt|,
name|val
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|UCH
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\n'
condition|)
name|rescan_lineno
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|neg
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|UCH
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|isdigit
argument_list|(
name|UCH
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
name|val
operator|=
name|val
operator|*
literal|10
operator|+
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|neg
condition|)
name|val
operator|=
operator|-
name|val
expr_stmt|;
if|if
condition|(
name|save
condition|)
operator|*
name|save
operator|=
name|val
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_arginfo
parameter_list|(
name|bucket
modifier|*
name|a
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|int
name|argslen
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|redec
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|args
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|args
operator|!=
name|argslen
condition|)
name|arg_number_disagree_warning
argument_list|(
name|rescan_lineno
argument_list|,
name|a
operator|->
name|name
argument_list|)
expr_stmt|;
name|redec
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|a
operator|->
name|args
operator|=
name|argslen
operator|)
operator|==
literal|0
condition|)
return|return;
name|a
operator|->
name|argnames
operator|=
name|TMALLOC
argument_list|(
name|char
operator|*
argument_list|,
name|argslen
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|a
operator|->
name|argnames
argument_list|)
expr_stmt|;
name|a
operator|->
name|argtags
operator|=
name|TMALLOC
argument_list|(
name|char
operator|*
argument_list|,
name|argslen
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|a
operator|->
name|argtags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|args
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argslen
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
name|UCH
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\n'
condition|)
name|rescan_lineno
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'$'
condition|)
name|bad_formals
argument_list|()
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|UCH
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\n'
condition|)
name|rescan_lineno
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'<'
condition|)
block|{
name|havetags
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|parse_id
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|tmp
argument_list|)
operator|)
condition|)
name|bad_formals
argument_list|()
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|UCH
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\n'
condition|)
name|rescan_lineno
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'>'
condition|)
name|bad_formals
argument_list|()
expr_stmt|;
if|if
condition|(
name|redec
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|argtags
index|[
name|i
index|]
operator|!=
name|tmp
condition|)
name|arg_type_disagree_warning
argument_list|(
name|rescan_lineno
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|a
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|a
operator|->
name|argtags
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|redec
condition|)
name|a
operator|->
name|argtags
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|parse_id
argument_list|(
name|p
argument_list|,
operator|&
name|a
operator|->
name|argnames
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
name|bad_formals
argument_list|()
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|UCH
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\n'
condition|)
name|rescan_lineno
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
condition|)
name|bad_formals
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|compile_arg
parameter_list|(
name|char
modifier|*
modifier|*
name|theptr
parameter_list|,
name|char
modifier|*
name|yyvaltag
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|theptr
decl_stmt|;
name|struct
name|mstring
modifier|*
name|c
init|=
name|msnew
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|Value_t
modifier|*
name|offsets
init|=
name|NULL
decl_stmt|,
name|maxoffset
decl_stmt|;
name|bucket
modifier|*
modifier|*
name|rhs
decl_stmt|;
name|maxoffset
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nitems
operator|-
literal|1
init|;
name|pitem
index|[
name|i
index|]
condition|;
operator|--
name|i
control|)
block|{
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|pitem
index|[
name|i
index|]
operator|->
name|class
operator|!=
name|ARGUMENT
condition|)
name|maxoffset
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|maxoffset
operator|>
literal|0
condition|)
block|{
name|offsets
operator|=
name|TMALLOC
argument_list|(
name|Value_t
argument_list|,
name|maxoffset
operator|+
literal|1
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|offsets
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|i
operator|++
init|;
name|i
operator|<
name|nitems
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pitem
index|[
name|i
index|]
operator|->
name|class
operator|!=
name|ARGUMENT
condition|)
name|offsets
index|[
operator|++
name|j
index|]
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|i
operator|-
name|nitems
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|rhs
operator|=
name|pitem
operator|+
name|nitems
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|yyvaltag
condition|)
name|msprintf
argument_list|(
name|c
argument_list|,
literal|"yyval.%s = "
argument_list|,
name|yyvaltag
argument_list|)
expr_stmt|;
else|else
name|msprintf
argument_list|(
name|c
argument_list|,
literal|"yyval = "
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
name|char
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
operator|++
name|p
operator|==
literal|'<'
condition|)
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|parse_id
argument_list|(
operator|++
name|p
argument_list|,
operator|&
name|tag
argument_list|)
operator|)
operator|||
operator|*
name|p
operator|++
operator|!=
literal|'>'
condition|)
name|illegal_tag
argument_list|(
name|rescan_lineno
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|UCH
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|parse_int
argument_list|(
name|p
argument_list|,
operator|&
name|val
argument_list|)
operator|)
condition|)
name|dollar_error
argument_list|(
name|rescan_lineno
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<=
literal|0
condition|)
name|i
operator|=
name|val
operator|-
name|n
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|>
name|maxoffset
condition|)
block|{
name|dollar_warning
argument_list|(
name|rescan_lineno
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|i
operator|=
name|val
operator|-
name|maxoffset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|maxoffset
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|offsets
index|[
name|val
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|tag
operator|&&
operator|!
operator|(
name|tag
operator|=
name|rhs
index|[
name|i
index|]
operator|->
name|tag
operator|)
operator|&&
name|havetags
condition|)
name|untyped_rhs
argument_list|(
name|val
argument_list|,
name|rhs
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|msprintf
argument_list|(
name|c
argument_list|,
literal|"yystack.l_mark[%d]"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
condition|)
name|msprintf
argument_list|(
name|c
argument_list|,
literal|".%s"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|havetags
condition|)
name|unknown_rhs
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|UCH
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
condition|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|parse_id
argument_list|(
name|p
argument_list|,
operator|&
name|arg
argument_list|)
operator|)
condition|)
name|dollar_error
argument_list|(
name|rescan_lineno
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|plhs
index|[
name|nrules
index|]
operator|->
name|args
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|arg
operator|==
name|plhs
index|[
name|nrules
index|]
operator|->
name|argnames
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|unknown_arg_warning
argument_list|(
name|rescan_lineno
argument_list|,
literal|"$"
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|tag
condition|)
name|tag
operator|=
name|plhs
index|[
name|nrules
index|]
operator|->
name|argtags
index|[
name|i
index|]
expr_stmt|;
name|msprintf
argument_list|(
name|c
argument_list|,
literal|"yystack.l_mark[%d]"
argument_list|,
name|i
operator|-
name|plhs
index|[
name|nrules
index|]
operator|->
name|args
operator|+
literal|1
operator|-
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
condition|)
name|msprintf
argument_list|(
name|c
argument_list|,
literal|".%s"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|havetags
condition|)
name|untyped_arg_warning
argument_list|(
name|rescan_lineno
argument_list|,
literal|"$"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
name|dollar_error
argument_list|(
name|rescan_lineno
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'@'
condition|)
block|{
name|at_error
argument_list|(
name|rescan_lineno
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|rescan_lineno
operator|++
expr_stmt|;
name|mputc
argument_list|(
name|c
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|theptr
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|maxoffset
operator|>
literal|0
condition|)
name|FREE
argument_list|(
name|offsets
argument_list|)
expr_stmt|;
return|return
name|msdone
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|can_elide_arg
parameter_list|(
name|char
modifier|*
modifier|*
name|theptr
parameter_list|,
name|char
modifier|*
name|yyvaltag
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|theptr
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
name|Value_t
modifier|*
name|offsets
init|=
name|NULL
decl_stmt|,
name|maxoffset
init|=
literal|0
decl_stmt|;
name|bucket
modifier|*
modifier|*
name|rhs
decl_stmt|;
name|char
modifier|*
name|tag
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'$'
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|parse_id
argument_list|(
operator|++
name|p
argument_list|,
operator|&
name|tag
argument_list|)
operator|)
operator|||
operator|*
name|p
operator|++
operator|!=
literal|'>'
condition|)
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
name|nitems
operator|-
literal|1
init|;
name|pitem
index|[
name|i
index|]
condition|;
operator|--
name|i
control|)
block|{
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|pitem
index|[
name|i
index|]
operator|->
name|class
operator|!=
name|ARGUMENT
condition|)
name|maxoffset
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|maxoffset
operator|>
literal|0
condition|)
block|{
name|offsets
operator|=
name|TMALLOC
argument_list|(
name|Value_t
argument_list|,
name|maxoffset
operator|+
literal|1
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|offsets
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|i
operator|++
init|;
name|i
operator|<
name|nitems
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pitem
index|[
name|i
index|]
operator|->
name|class
operator|!=
name|ARGUMENT
condition|)
name|offsets
index|[
operator|++
name|j
index|]
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|i
operator|-
name|nitems
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|rhs
operator|=
name|pitem
operator|+
name|nitems
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|UCH
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|parse_int
argument_list|(
name|p
argument_list|,
operator|&
name|val
argument_list|)
operator|)
condition|)
name|rv
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|val
operator|<=
literal|0
condition|)
name|rv
operator|=
literal|1
operator|-
name|val
operator|+
name|n
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|>
name|maxoffset
condition|)
name|rv
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|i
operator|=
name|offsets
index|[
name|val
index|]
expr_stmt|;
name|rv
operator|=
literal|1
operator|-
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|tag
condition|)
name|tag
operator|=
name|rhs
index|[
name|i
index|]
operator|->
name|tag
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|UCH
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
condition|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|parse_id
argument_list|(
name|p
argument_list|,
operator|&
name|arg
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|plhs
index|[
name|nrules
index|]
operator|->
name|args
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|arg
operator|==
name|plhs
index|[
name|nrules
index|]
operator|->
name|argnames
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|tag
condition|)
name|tag
operator|=
name|plhs
index|[
name|nrules
index|]
operator|->
name|argtags
index|[
name|i
index|]
expr_stmt|;
name|rv
operator|=
name|plhs
index|[
name|nrules
index|]
operator|->
name|args
operator|+
name|n
operator|-
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tag
operator|&&
name|yyvaltag
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tag
argument_list|,
name|yyvaltag
argument_list|)
condition|)
name|rv
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tag
operator|||
name|yyvaltag
condition|)
name|rv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|maxoffset
operator|>
literal|0
condition|)
name|FREE
argument_list|(
name|offsets
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|||
name|rv
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
operator|*
name|theptr
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ARG_CACHE_SIZE
value|1024
end_define

begin_struct
specifier|static
struct|struct
name|arg_cache
block|{
name|struct
name|arg_cache
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|code
decl_stmt|;
name|int
name|rule
decl_stmt|;
block|}
modifier|*
name|arg_cache
index|[
name|ARG_CACHE_SIZE
index|]
struct|;
end_struct

begin_function
specifier|static
name|int
name|lookup_arg_cache
parameter_list|(
name|char
modifier|*
name|code
parameter_list|)
block|{
name|struct
name|arg_cache
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|arg_cache
index|[
name|strnshash
argument_list|(
name|code
argument_list|)
operator|%
name|ARG_CACHE_SIZE
index|]
expr_stmt|;
while|while
condition|(
name|entry
condition|)
block|{
if|if
condition|(
operator|!
name|strnscmp
argument_list|(
name|entry
operator|->
name|code
argument_list|,
name|code
argument_list|)
condition|)
return|return
name|entry
operator|->
name|rule
return|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_arg_cache
parameter_list|(
name|char
modifier|*
name|code
parameter_list|,
name|int
name|rule
parameter_list|)
block|{
name|struct
name|arg_cache
modifier|*
name|entry
init|=
name|NEW
argument_list|(
expr|struct
name|arg_cache
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|NO_SPACE
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|i
operator|=
name|strnshash
argument_list|(
name|code
argument_list|)
operator|%
name|ARG_CACHE_SIZE
expr_stmt|;
name|entry
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|entry
operator|->
name|rule
operator|=
name|rule
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|arg_cache
index|[
name|i
index|]
expr_stmt|;
name|arg_cache
index|[
name|i
index|]
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clean_arg_cache
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|arg_cache
modifier|*
name|e
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARG_CACHE_SIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|e
operator|=
name|arg_cache
index|[
name|i
index|]
init|;
operator|(
name|t
operator|=
name|e
operator|)
condition|;
name|e
operator|=
name|e
operator|->
name|next
operator|,
name|FREE
argument_list|(
name|t
argument_list|)
control|)
name|free
argument_list|(
name|e
operator|->
name|code
argument_list|)
expr_stmt|;
name|arg_cache
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(YYBTYACC) */
end_comment

begin_function
specifier|static
name|void
name|advance_to_start
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|s_cptr
decl_stmt|;
name|int
name|s_lineno
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|char
modifier|*
name|args
init|=
name|NULL
decl_stmt|;
name|int
name|argslen
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'%'
condition|)
break|break;
name|s_cptr
operator|=
name|cptr
expr_stmt|;
switch|switch
condition|(
name|keyword
argument_list|()
condition|)
block|{
case|case
name|MARK
case|:
name|no_grammar
argument_list|()
expr_stmt|;
case|case
name|TEXT
case|:
name|copy_text
argument_list|()
expr_stmt|;
break|break;
case|case
name|START
case|:
name|declare_start
argument_list|()
expr_stmt|;
break|break;
default|default:
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|s_cptr
argument_list|)
expr_stmt|;
block|}
block|}
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'.'
operator|&&
name|c
operator|!=
literal|'_'
condition|)
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
name|bp
operator|=
name|get_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|goal
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|TERM
condition|)
name|terminal_start
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|goal
operator|=
name|bp
expr_stmt|;
block|}
name|s_lineno
operator|=
name|lineno
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
name|rescan_lineno
operator|=
name|lineno
expr_stmt|;
comment|/* line# for possible inherited args rescan */
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|c
operator|==
name|L_PAREN
condition|)
block|{
operator|++
name|cptr
expr_stmt|;
name|args
operator|=
name|copy_args
argument_list|(
operator|&
name|argslen
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|c
operator|!=
literal|':'
condition|)
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
name|start_rule
argument_list|(
name|bp
argument_list|,
name|s_lineno
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|parse_arginfo
argument_list|(
name|bp
argument_list|,
name|args
argument_list|,
name|argslen
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|cptr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_rule
parameter_list|(
name|bucket
modifier|*
name|bp
parameter_list|,
name|int
name|s_lineno
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|TERM
condition|)
name|terminal_lhs
argument_list|(
name|s_lineno
argument_list|)
expr_stmt|;
name|bp
operator|->
name|class
operator|=
name|NONTERM
expr_stmt|;
if|if
condition|(
operator|!
name|bp
operator|->
name|index
condition|)
name|bp
operator|->
name|index
operator|=
name|nrules
expr_stmt|;
if|if
condition|(
name|nrules
operator|>=
name|maxrules
condition|)
name|expand_rules
argument_list|()
expr_stmt|;
name|plhs
index|[
name|nrules
index|]
operator|=
name|bp
expr_stmt|;
name|rprec
index|[
name|nrules
index|]
operator|=
name|UNDEFINED
expr_stmt|;
name|rassoc
index|[
name|nrules
index|]
operator|=
name|TOKEN
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|end_rule
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|last_was_action
operator|&&
name|plhs
index|[
name|nrules
index|]
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|pitem
index|[
name|nitems
operator|-
literal|1
index|]
condition|)
block|{
for|for
control|(
name|i
operator|=
name|nitems
operator|-
literal|1
init|;
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
name|pitem
index|[
name|i
index|]
condition|;
operator|--
name|i
control|)
continue|continue;
if|if
condition|(
name|pitem
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|0
operator|||
name|pitem
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|tag
operator|!=
name|plhs
index|[
name|nrules
index|]
operator|->
name|tag
condition|)
name|default_action_warning
argument_list|(
name|plhs
index|[
name|nrules
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|default_action_warning
argument_list|(
name|plhs
index|[
name|nrules
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|last_was_action
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nitems
operator|>=
name|maxitems
condition|)
name|expand_items
argument_list|()
expr_stmt|;
name|pitem
index|[
name|nitems
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|nitems
expr_stmt|;
operator|++
name|nrules
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_empty_rule
parameter_list|(
name|void
parameter_list|)
block|{
name|bucket
modifier|*
name|bp
decl_stmt|,
modifier|*
modifier|*
name|bpp
decl_stmt|;
name|assert
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cache_size
operator|>=
name|CACHE_SIZE
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cache
argument_list|,
literal|"$$%d"
argument_list|,
operator|++
name|gensym
argument_list|)
expr_stmt|;
name|bp
operator|=
name|make_bucket
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|last_symbol
operator|->
name|next
operator|=
name|bp
expr_stmt|;
name|last_symbol
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|tag
operator|=
name|plhs
index|[
name|nrules
index|]
operator|->
name|tag
expr_stmt|;
name|bp
operator|->
name|class
operator|=
name|ACTION
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|bp
operator|->
name|args
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|nitems
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|nitems
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nitems
operator|>
name|maxitems
condition|)
name|expand_items
argument_list|()
expr_stmt|;
name|bpp
operator|=
name|pitem
operator|+
name|nitems
operator|-
literal|1
expr_stmt|;
operator|*
name|bpp
operator|--
operator|=
name|bp
expr_stmt|;
while|while
condition|(
operator|(
name|bpp
index|[
literal|0
index|]
operator|=
name|bpp
index|[
operator|-
literal|1
index|]
operator|)
operator|!=
literal|0
condition|)
operator|--
name|bpp
expr_stmt|;
if|if
condition|(
operator|++
name|nrules
operator|>=
name|maxrules
condition|)
name|expand_rules
argument_list|()
expr_stmt|;
name|plhs
index|[
name|nrules
index|]
operator|=
name|plhs
index|[
name|nrules
operator|-
literal|1
index|]
expr_stmt|;
name|plhs
index|[
name|nrules
operator|-
literal|1
index|]
operator|=
name|bp
expr_stmt|;
name|rprec
index|[
name|nrules
index|]
operator|=
name|rprec
index|[
name|nrules
operator|-
literal|1
index|]
expr_stmt|;
name|rprec
index|[
name|nrules
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rassoc
index|[
name|nrules
index|]
operator|=
name|rassoc
index|[
name|nrules
operator|-
literal|1
index|]
expr_stmt|;
name|rassoc
index|[
name|nrules
operator|-
literal|1
index|]
operator|=
name|TOKEN
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
end_if

begin_function
specifier|static
name|char
modifier|*
name|insert_arg_rule
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|int
name|line_number
init|=
name|rescan_lineno
decl_stmt|;
name|char
modifier|*
name|code
init|=
name|compile_arg
argument_list|(
operator|&
name|arg
argument_list|,
name|tag
argument_list|)
decl_stmt|;
name|int
name|rule
init|=
name|lookup_arg_cache
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|action_file
decl_stmt|;
if|if
condition|(
name|rule
operator|<
literal|0
condition|)
block|{
name|rule
operator|=
name|nrules
expr_stmt|;
name|insert_arg_cache
argument_list|(
name|code
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|trialaction
operator|=
literal|1
expr_stmt|;
comment|/* arg rules always run in trial mode */
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"case %d:\n"
argument_list|,
name|rule
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lflag
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
name|line_format
argument_list|,
name|line_number
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s;\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"break;\n"
argument_list|)
expr_stmt|;
name|insert_empty_rule
argument_list|()
expr_stmt|;
name|plhs
index|[
name|rule
index|]
operator|->
name|tag
operator|=
name|cache_tag
argument_list|(
name|tag
argument_list|,
name|strlen
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
name|plhs
index|[
name|rule
index|]
operator|->
name|class
operator|=
name|ARGUMENT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|++
name|nitems
operator|>
name|maxitems
condition|)
name|expand_items
argument_list|()
expr_stmt|;
name|pitem
index|[
name|nitems
operator|-
literal|1
index|]
operator|=
name|plhs
index|[
name|rule
index|]
expr_stmt|;
name|free
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
return|return
name|arg
operator|+
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|add_symbol
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|;
name|int
name|s_lineno
init|=
name|lineno
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|char
modifier|*
name|args
init|=
name|NULL
decl_stmt|;
name|int
name|argslen
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
name|bp
operator|=
name|get_literal
argument_list|()
expr_stmt|;
else|else
name|bp
operator|=
name|get_name
argument_list|()
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
name|rescan_lineno
operator|=
name|lineno
expr_stmt|;
comment|/* line# for possible inherited args rescan */
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|c
operator|==
name|L_PAREN
condition|)
block|{
operator|++
name|cptr
expr_stmt|;
name|args
operator|=
name|copy_args
argument_list|(
operator|&
name|argslen
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|end_rule
argument_list|()
expr_stmt|;
name|start_rule
argument_list|(
name|bp
argument_list|,
name|s_lineno
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|parse_arginfo
argument_list|(
name|bp
argument_list|,
name|args
argument_list|,
name|argslen
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|cptr
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|last_was_action
condition|)
name|insert_empty_rule
argument_list|()
expr_stmt|;
name|last_was_action
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|bp
operator|->
name|args
operator|<
literal|0
condition|)
name|bp
operator|->
name|args
operator|=
name|argslen
expr_stmt|;
if|if
condition|(
name|argslen
operator|==
literal|0
operator|&&
name|bp
operator|->
name|args
operator|>
literal|0
operator|&&
name|pitem
index|[
name|nitems
operator|-
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|plhs
index|[
name|nrules
index|]
operator|->
name|args
operator|!=
name|bp
operator|->
name|args
condition|)
name|wrong_number_args_warning
argument_list|(
literal|"default "
argument_list|,
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|bp
operator|->
name|args
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|plhs
index|[
name|nrules
index|]
operator|->
name|argtags
index|[
name|i
index|]
operator|!=
name|bp
operator|->
name|argtags
index|[
name|i
index|]
condition|)
name|wrong_type_for_arg_warning
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|args
operator|!=
name|argslen
condition|)
name|wrong_number_args_warning
argument_list|(
literal|""
argument_list|,
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|ap
init|=
name|args
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|elide_cnt
init|=
name|can_elide_arg
argument_list|(
operator|&
name|ap
argument_list|,
name|bp
operator|->
name|argtags
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|elide_cnt
operator|>
name|argslen
condition|)
name|elide_cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|elide_cnt
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|elide_cnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|can_elide_arg
argument_list|(
operator|&
name|ap
argument_list|,
name|bp
operator|->
name|argtags
index|[
name|i
index|]
argument_list|)
operator|!=
name|elide_cnt
operator|-
name|i
condition|)
block|{
name|elide_cnt
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|elide_cnt
condition|)
block|{
name|assert
argument_list|(
name|i
operator|==
name|elide_cnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ap
operator|=
name|args
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|argslen
condition|;
name|i
operator|++
control|)
name|ap
operator|=
name|insert_arg_rule
argument_list|(
name|ap
argument_list|,
name|bp
operator|->
name|argtags
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(YYBTYACC) */
if|if
condition|(
operator|++
name|nitems
operator|>
name|maxitems
condition|)
name|expand_items
argument_list|()
expr_stmt|;
name|pitem
index|[
name|nitems
operator|-
literal|1
index|]
operator|=
name|bp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_action
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|int
name|depth
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|int
name|haveyyval
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|tag
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|action_file
decl_stmt|;
name|struct
name|ainfo
name|a
decl_stmt|;
name|Value_t
modifier|*
name|offsets
init|=
name|NULL
decl_stmt|,
name|maxoffset
decl_stmt|;
name|bucket
modifier|*
modifier|*
name|rhs
decl_stmt|;
name|a
operator|.
name|a_lineno
operator|=
name|lineno
expr_stmt|;
name|a
operator|.
name|a_line
operator|=
name|dup_line
argument_list|()
expr_stmt|;
name|a
operator|.
name|a_cptr
operator|=
name|a
operator|.
name|a_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|)
expr_stmt|;
if|if
condition|(
name|last_was_action
condition|)
name|insert_empty_rule
argument_list|()
expr_stmt|;
name|last_was_action
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|trialaction
operator|=
operator|(
operator|*
name|cptr
operator|==
name|L_BRAC
operator|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"case %d:\n"
argument_list|,
name|nrules
operator|-
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|backtrack
condition|)
block|{
if|if
condition|(
operator|!
name|trialaction
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  if (!yytrial)\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|lflag
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
name|line_format
argument_list|,
name|lineno
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cptr
operator|==
literal|'='
condition|)
operator|++
name|cptr
expr_stmt|;
comment|/* avoid putting curly-braces in first column, to ease editing */
if|if
condition|(
operator|*
name|after_blanks
argument_list|(
name|cptr
argument_list|)
operator|==
name|L_CURL
condition|)
block|{
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|cptr
operator|=
name|after_blanks
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
block|}
name|maxoffset
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nitems
operator|-
literal|1
init|;
name|pitem
index|[
name|i
index|]
condition|;
operator|--
name|i
control|)
block|{
operator|++
name|n
expr_stmt|;
if|if
condition|(
name|pitem
index|[
name|i
index|]
operator|->
name|class
operator|!=
name|ARGUMENT
condition|)
name|maxoffset
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|maxoffset
operator|>
literal|0
condition|)
block|{
name|offsets
operator|=
name|TMALLOC
argument_list|(
name|Value_t
argument_list|,
name|maxoffset
operator|+
literal|1
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|offsets
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|i
operator|++
init|;
name|i
operator|<
name|nitems
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pitem
index|[
name|i
index|]
operator|->
name|class
operator|!=
name|ARGUMENT
condition|)
block|{
name|offsets
index|[
operator|++
name|j
index|]
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|i
operator|-
name|nitems
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|rhs
operator|=
name|pitem
operator|+
name|nitems
operator|-
literal|1
expr_stmt|;
name|depth
operator|=
literal|0
expr_stmt|;
name|loop
label|:
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|cptr
index|[
literal|1
index|]
operator|==
literal|'<'
condition|)
block|{
name|int
name|d_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|d_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|d_cptr
init|=
name|d_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|)
decl_stmt|;
operator|++
name|cptr
expr_stmt|;
name|tag
operator|=
name|get_tag
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yyval.%s"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
name|FREE
argument_list|(
name|d_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|i
operator|=
name|get_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.l_mark[%d].%s"
argument_list|,
operator|-
name|n
argument_list|,
name|tag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
name|maxoffset
condition|)
block|{
name|dollar_warning
argument_list|(
name|d_lineno
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.l_mark[%d].%s"
argument_list|,
name|i
operator|-
name|maxoffset
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offsets
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.l_mark[%d].%s"
argument_list|,
name|offsets
index|[
name|i
index|]
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|d_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
name|isdigit
argument_list|(
name|UCH
argument_list|(
name|cptr
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|cptr
expr_stmt|;
name|i
operator|=
operator|-
name|get_number
argument_list|()
operator|-
name|n
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.l_mark[%d].%s"
argument_list|,
name|i
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|d_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
condition|)
block|{
name|char
modifier|*
name|arg
init|=
name|scan_id
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
name|plhs
index|[
name|nrules
index|]
operator|->
name|args
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|arg
operator|==
name|plhs
index|[
name|nrules
index|]
operator|->
name|argnames
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|unknown_arg_warning
argument_list|(
name|d_lineno
argument_list|,
literal|"$"
argument_list|,
name|arg
argument_list|,
name|d_line
argument_list|,
name|d_cptr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.l_mark[%d].%s"
argument_list|,
name|i
operator|-
name|plhs
index|[
name|nrules
index|]
operator|->
name|args
operator|+
literal|1
operator|-
name|n
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|d_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
endif|#
directive|endif
else|else
name|dollar_error
argument_list|(
name|d_lineno
argument_list|,
name|d_line
argument_list|,
name|d_cptr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cptr
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|havetags
condition|)
block|{
name|tag
operator|=
name|plhs
index|[
name|nrules
index|]
operator|->
name|tag
expr_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
condition|)
name|untyped_lhs
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yyval.%s"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yyval"
argument_list|)
expr_stmt|;
name|cptr
operator|+=
literal|2
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|haveyyval
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
goto|goto
name|loop
goto|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|UCH
argument_list|(
name|cptr
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|cptr
expr_stmt|;
name|i
operator|=
name|get_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|havetags
operator|&&
name|offsets
condition|)
block|{
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>
name|maxoffset
condition|)
name|unknown_rhs
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|tag
operator|=
name|rhs
index|[
name|offsets
index|[
name|i
index|]
index|]
operator|->
name|tag
expr_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
condition|)
name|untyped_rhs
argument_list|(
name|i
argument_list|,
name|rhs
index|[
name|offsets
index|[
name|i
index|]
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.l_mark[%d].%s"
argument_list|,
name|offsets
index|[
name|i
index|]
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.l_mark[%d]"
argument_list|,
operator|-
name|n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
name|maxoffset
condition|)
block|{
name|dollar_warning
argument_list|(
name|lineno
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.l_mark[%d]"
argument_list|,
name|i
operator|-
name|maxoffset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offsets
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.l_mark[%d]"
argument_list|,
name|offsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
block|}
elseif|else
if|if
condition|(
name|cptr
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|cptr
operator|+=
literal|2
expr_stmt|;
name|i
operator|=
name|get_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|havetags
condition|)
name|unknown_rhs
argument_list|(
operator|-
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.l_mark[%d]"
argument_list|,
operator|-
name|i
operator|-
name|n
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|UCH
argument_list|(
name|cptr
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|||
name|cptr
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
operator|++
name|cptr
expr_stmt|;
name|arg
operator|=
name|scan_id
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|plhs
index|[
name|nrules
index|]
operator|->
name|args
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|arg
operator|==
name|plhs
index|[
name|nrules
index|]
operator|->
name|argnames
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|unknown_arg_warning
argument_list|(
name|lineno
argument_list|,
literal|"$"
argument_list|,
name|arg
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
name|tag
operator|=
operator|(
name|i
operator|<
literal|0
condition|?
name|NULL
else|:
name|plhs
index|[
name|nrules
index|]
operator|->
name|argtags
index|[
name|i
index|]
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.l_mark[%d]"
argument_list|,
name|i
operator|-
name|plhs
index|[
name|nrules
index|]
operator|->
name|args
operator|+
literal|1
operator|-
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|".%s"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|havetags
condition|)
name|untyped_arg_warning
argument_list|(
name|lineno
argument_list|,
literal|"$"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|c
operator|==
literal|'@'
condition|)
block|{
if|if
condition|(
operator|!
name|locations
condition|)
block|{
name|int
name|l_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|l_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|l_cptr
init|=
name|l_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|)
decl_stmt|;
name|syntax_error
argument_list|(
name|l_lineno
argument_list|,
name|l_line
argument_list|,
name|l_cptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cptr
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yyloc"
argument_list|)
expr_stmt|;
name|cptr
operator|+=
literal|2
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|UCH
argument_list|(
name|cptr
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|cptr
expr_stmt|;
name|i
operator|=
name|get_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.p_mark[%d]"
argument_list|,
operator|-
name|n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
name|maxoffset
condition|)
block|{
name|at_warning
argument_list|(
name|lineno
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.p_mark[%d]"
argument_list|,
name|i
operator|-
name|maxoffset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offsets
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.p_mark[%d]"
argument_list|,
name|offsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
elseif|else
if|if
condition|(
name|cptr
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|cptr
operator|+=
literal|2
expr_stmt|;
name|i
operator|=
name|get_number
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yystack.p_mark[%d]"
argument_list|,
operator|-
name|i
operator|-
name|n
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
condition|)
block|{
do|do
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
block|}
do|while
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
condition|)
do|;
goto|goto
name|loop
goto|;
block|}
operator|++
name|cptr
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|backtrack
condition|)
block|{
if|if
condition|(
name|trialaction
operator|&&
name|c
operator|==
name|L_BRAC
operator|&&
name|depth
operator|==
literal|0
condition|)
block|{
operator|++
name|depth
expr_stmt|;
name|putc
argument_list|(
name|L_CURL
argument_list|,
name|f
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|trialaction
operator|&&
name|c
operator|==
name|R_BRAC
operator|&&
name|depth
operator|==
literal|1
condition|)
block|{
operator|--
name|depth
expr_stmt|;
name|putc
argument_list|(
name|R_CURL
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|L_BRAC
operator|&&
operator|!
name|haveyyval
condition|)
block|{
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|c
operator|==
name|L_CURL
operator|&&
operator|!
name|haveyyval
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  if (!yytrial)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lflag
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
name|line_format
argument_list|,
name|lineno
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
name|trialaction
operator|=
literal|0
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nbreak;\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|a
operator|.
name|a_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxoffset
operator|>
literal|0
condition|)
name|FREE
argument_list|(
name|offsets
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
condition|)
goto|goto
name|loop
goto|;
name|unterminated_action
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
case|case
literal|';'
case|:
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
goto|goto
name|loop
goto|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nbreak;\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
operator|.
name|a_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxoffset
operator|>
literal|0
condition|)
name|FREE
argument_list|(
name|offsets
argument_list|)
expr_stmt|;
return|return;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
case|case
name|L_BRAC
case|:
if|if
condition|(
name|backtrack
condition|)
operator|++
name|depth
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|R_BRAC
case|:
if|if
condition|(
name|backtrack
condition|)
operator|--
name|depth
expr_stmt|;
goto|goto
name|loop
goto|;
endif|#
directive|endif
case|case
name|L_CURL
case|:
operator|++
name|depth
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|R_CURL
case|:
if|if
condition|(
operator|--
name|depth
operator|>
literal|0
condition|)
goto|goto
name|loop
goto|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|backtrack
condition|)
block|{
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|L_BRAC
operator|&&
operator|!
name|haveyyval
condition|)
block|{
name|trialaction
operator|=
literal|1
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|c
operator|==
name|L_CURL
operator|&&
operator|!
name|haveyyval
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  if (!yytrial)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lflag
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
name|line_format
argument_list|,
name|lineno
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
block|}
endif|#
directive|endif
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nbreak;\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
operator|.
name|a_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxoffset
operator|>
literal|0
condition|)
name|FREE
argument_list|(
name|offsets
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
block|{
name|char
modifier|*
name|s
init|=
name|copy_string
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|fputs
argument_list|(
name|s
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
case|case
literal|'/'
case|:
block|{
name|char
modifier|*
name|s
init|=
name|copy_comment
argument_list|()
decl_stmt|;
name|fputs
argument_list|(
name|s
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
default|default:
goto|goto
name|loop
goto|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
end_if

begin_function
specifier|static
name|char
modifier|*
name|get_code
parameter_list|(
name|struct
name|ainfo
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|loc
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|struct
name|mstring
modifier|*
name|code_mstr
init|=
name|msnew
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|lflag
condition|)
name|msprintf
argument_list|(
name|code_mstr
argument_list|,
name|line_format
argument_list|,
name|lineno
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
name|cptr
operator|=
name|after_blanks
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cptr
operator|==
name|L_CURL
condition|)
comment|/* avoid putting curly-braces in first column, to ease editing */
name|mputc
argument_list|(
name|code_mstr
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
else|else
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
name|a
operator|->
name|a_lineno
operator|=
name|lineno
expr_stmt|;
name|a
operator|->
name|a_line
operator|=
name|dup_line
argument_list|()
expr_stmt|;
name|a
operator|->
name|a_cptr
operator|=
name|a
operator|->
name|a_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|)
expr_stmt|;
name|depth
operator|=
literal|0
expr_stmt|;
name|loop
label|:
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|cptr
index|[
literal|1
index|]
operator|==
literal|'<'
condition|)
block|{
name|int
name|d_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|d_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|d_cptr
init|=
name|d_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|)
decl_stmt|;
operator|++
name|cptr
expr_stmt|;
name|tag
operator|=
name|get_tag
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
name|msprintf
argument_list|(
name|code_mstr
argument_list|,
literal|"(*val).%s"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
name|FREE
argument_list|(
name|d_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
else|else
name|dollar_error
argument_list|(
name|d_lineno
argument_list|,
name|d_line
argument_list|,
name|d_cptr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cptr
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
block|{
comment|/* process '$$' later; replacement is context dependent */
name|msprintf
argument_list|(
name|code_mstr
argument_list|,
literal|"$$"
argument_list|)
expr_stmt|;
name|cptr
operator|+=
literal|2
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'@'
operator|&&
name|cptr
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
operator|!
name|locations
condition|)
block|{
name|int
name|l_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|l_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|l_cptr
init|=
name|l_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|)
decl_stmt|;
name|syntax_error
argument_list|(
name|l_lineno
argument_list|,
name|l_line
argument_list|,
name|l_cptr
argument_list|)
expr_stmt|;
block|}
name|msprintf
argument_list|(
name|code_mstr
argument_list|,
literal|"%s"
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|cptr
operator|+=
literal|2
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
condition|)
block|{
do|do
block|{
name|mputc
argument_list|(
name|code_mstr
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
block|}
do|while
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
condition|)
do|;
goto|goto
name|loop
goto|;
block|}
operator|++
name|cptr
expr_stmt|;
name|mputc
argument_list|(
name|code_mstr
argument_list|,
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
condition|)
goto|goto
name|loop
goto|;
name|unterminated_action
argument_list|(
name|a
argument_list|)
expr_stmt|;
case|case
name|L_CURL
case|:
operator|++
name|depth
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|R_CURL
case|:
if|if
condition|(
operator|--
name|depth
operator|>
literal|0
condition|)
goto|goto
name|loop
goto|;
goto|goto
name|out
goto|;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
block|{
name|char
modifier|*
name|s
init|=
name|copy_string
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|msprintf
argument_list|(
name|code_mstr
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
case|case
literal|'/'
case|:
block|{
name|char
modifier|*
name|s
init|=
name|copy_comment
argument_list|()
decl_stmt|;
name|msprintf
argument_list|(
name|code_mstr
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
default|default:
goto|goto
name|loop
goto|;
block|}
name|out
label|:
return|return
name|msdone
argument_list|(
name|code_mstr
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_initial_action
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ainfo
name|a
decl_stmt|;
name|initial_action
operator|=
name|get_code
argument_list|(
operator|&
name|a
argument_list|,
literal|"yyloc"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
operator|.
name|a_line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_destructor
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|code_text
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|ainfo
name|a
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|;
name|code_text
operator|=
name|get_code
argument_list|(
operator|&
name|a
argument_list|,
literal|"(*loc)"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|cptr
index|[
literal|1
index|]
operator|==
literal|'>'
condition|)
block|{
comment|/* "no semantic type" default destructor */
name|cptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|default_destructor
index|[
name|UNTYPED_DEFAULT
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
specifier|static
name|char
name|untyped_default
index|[]
init|=
literal|"<>"
decl_stmt|;
name|bp
operator|=
name|make_bucket
argument_list|(
literal|"untyped default"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|tag
operator|=
name|untyped_default
expr_stmt|;
name|default_destructor
index|[
name|UNTYPED_DEFAULT
index|]
operator|=
name|bp
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|destructor
operator|!=
name|NULL
condition|)
name|destructor_redeclared_warning
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
else|else
comment|/* replace "$$" with "(*val)" in destructor code */
name|bp
operator|->
name|destructor
operator|=
name|process_destructor_XX
argument_list|(
name|code_text
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cptr
index|[
literal|1
index|]
operator|==
literal|'*'
operator|&&
name|cptr
index|[
literal|2
index|]
operator|==
literal|'>'
condition|)
block|{
comment|/* "no per-symbol or per-type" default destructor */
name|cptr
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|default_destructor
index|[
name|TYPED_DEFAULT
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
specifier|static
name|char
name|typed_default
index|[]
init|=
literal|"<*>"
decl_stmt|;
name|bp
operator|=
name|make_bucket
argument_list|(
literal|"typed default"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|tag
operator|=
name|typed_default
expr_stmt|;
name|default_destructor
index|[
name|TYPED_DEFAULT
index|]
operator|=
name|bp
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|destructor
operator|!=
name|NULL
condition|)
name|destructor_redeclared_warning
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* postpone re-processing destructor $$s until end of grammar spec */
name|bp
operator|->
name|destructor
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|code_text
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|bp
operator|->
name|destructor
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bp
operator|->
name|destructor
argument_list|,
name|code_text
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* "semantic type" default destructor */
name|char
modifier|*
name|tag
init|=
name|get_tag
argument_list|()
decl_stmt|;
name|bp
operator|=
name|lookup_type_destructor
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|destructor
operator|!=
name|NULL
condition|)
name|destructor_redeclared_warning
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
else|else
comment|/* replace "$$" with "(*val).tag" in destructor code */
name|bp
operator|->
name|destructor
operator|=
name|process_destructor_XX
argument_list|(
name|code_text
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'$'
condition|)
block|{
comment|/* "symbol" destructor */
name|bp
operator|=
name|get_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|destructor
operator|!=
name|NULL
condition|)
name|destructor_redeclared_warning
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* postpone re-processing destructor $$s until end of grammar spec */
name|bp
operator|->
name|destructor
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|code_text
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|bp
operator|->
name|destructor
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bp
operator|->
name|destructor
argument_list|,
name|code_text
argument_list|)
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
name|free
argument_list|(
name|a
operator|.
name|a_line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|code_text
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|process_destructor_XX
parameter_list|(
name|char
modifier|*
name|code
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|quote
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|struct
name|mstring
modifier|*
name|new_code
init|=
name|msnew
argument_list|()
decl_stmt|;
name|char
modifier|*
name|codeptr
init|=
name|code
decl_stmt|;
name|depth
operator|=
literal|0
expr_stmt|;
name|loop
label|:
comment|/* step thru code */
name|c
operator|=
operator|*
name|codeptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
operator|&&
name|codeptr
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
block|{
name|codeptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
name|msprintf
argument_list|(
name|new_code
argument_list|,
literal|"(*val)"
argument_list|)
expr_stmt|;
else|else
name|msprintf
argument_list|(
name|new_code
argument_list|,
literal|"(*val).%s"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
condition|)
block|{
do|do
block|{
name|mputc
argument_list|(
name|new_code
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|codeptr
expr_stmt|;
block|}
do|while
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
condition|)
do|;
goto|goto
name|loop
goto|;
block|}
operator|++
name|codeptr
expr_stmt|;
name|mputc
argument_list|(
name|new_code
argument_list|,
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|L_CURL
case|:
operator|++
name|depth
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|R_CURL
case|:
if|if
condition|(
operator|--
name|depth
operator|>
literal|0
condition|)
goto|goto
name|loop
goto|;
return|return
name|msdone
argument_list|(
name|new_code
argument_list|)
return|;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
name|quote
operator|=
name|c
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|codeptr
operator|++
expr_stmt|;
name|mputc
argument_list|(
name|new_code
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quote
condition|)
goto|goto
name|loop
goto|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
operator|*
name|codeptr
operator|++
expr_stmt|;
name|mputc
argument_list|(
name|new_code
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
case|case
literal|'/'
case|:
name|c
operator|=
operator|*
name|codeptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
name|mputc
argument_list|(
name|new_code
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|++
name|codeptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|codeptr
operator|++
expr_stmt|;
name|mputc
argument_list|(
name|new_code
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
operator|*
name|codeptr
operator|==
literal|'/'
condition|)
block|{
name|mputc
argument_list|(
name|new_code
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
operator|++
name|codeptr
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
block|}
block|}
goto|goto
name|loop
goto|;
default|default:
goto|goto
name|loop
goto|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(YYBTYACC) */
end_comment

begin_function
specifier|static
name|int
name|mark_symbol
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|bucket
modifier|*
name|bp
init|=
name|NULL
decl_stmt|;
name|c
operator|=
name|cptr
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'%'
operator|||
name|c
operator|==
literal|'\\'
condition|)
block|{
name|cptr
operator|+=
literal|2
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
name|cptr
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'p'
operator|||
name|c
operator|==
literal|'P'
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|cptr
index|[
literal|2
index|]
operator|)
operator|==
literal|'r'
operator|||
name|c
operator|==
literal|'R'
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|cptr
index|[
literal|3
index|]
operator|)
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|cptr
index|[
literal|4
index|]
operator|)
operator|==
literal|'c'
operator|||
name|c
operator|==
literal|'C'
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|cptr
index|[
literal|5
index|]
operator|,
operator|!
name|IS_IDENT
argument_list|(
name|c
argument_list|)
operator|)
operator|)
condition|)
name|cptr
operator|+=
literal|5
expr_stmt|;
else|else
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'$'
condition|)
name|bp
operator|=
name|get_name
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
name|bp
operator|=
name|get_literal
argument_list|()
expr_stmt|;
else|else
block|{
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
comment|/*NOTREACHED */
block|}
if|if
condition|(
name|rprec
index|[
name|nrules
index|]
operator|!=
name|UNDEFINED
operator|&&
name|bp
operator|->
name|prec
operator|!=
name|rprec
index|[
name|nrules
index|]
condition|)
name|prec_redeclared
argument_list|()
expr_stmt|;
name|rprec
index|[
name|nrules
index|]
operator|=
name|bp
operator|->
name|prec
expr_stmt|;
name|rassoc
index|[
name|nrules
index|]
operator|=
name|bp
operator|->
name|assoc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_grammar
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|initialize_grammar
argument_list|()
expr_stmt|;
name|advance_to_start
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'$'
operator|||
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
name|add_symbol
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
elseif|else
if|if
condition|(
name|c
operator|==
name|L_CURL
operator|||
name|c
operator|==
literal|'='
operator|||
operator|(
name|backtrack
operator|&&
name|c
operator|==
name|L_BRAC
operator|)
condition|)
else|#
directive|else
elseif|else
if|if
condition|(
name|c
operator|==
name|L_CURL
operator|||
name|c
operator|==
literal|'='
condition|)
endif|#
directive|endif
name|copy_action
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'|'
condition|)
block|{
name|end_rule
argument_list|()
expr_stmt|;
name|start_rule
argument_list|(
name|plhs
index|[
name|nrules
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|mark_symbol
argument_list|()
condition|)
break|break;
block|}
else|else
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
block|}
name|end_rule
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|goal
operator|->
name|args
operator|>
literal|0
condition|)
name|start_requires_args
argument_list|(
name|goal
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|free_tags
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tag_table
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntags
condition|;
operator|++
name|i
control|)
block|{
name|assert
argument_list|(
name|tag_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|tag_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|tag_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pack_names
parameter_list|(
name|void
parameter_list|)
block|{
name|bucket
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|name_pool_size
operator|=
literal|13
expr_stmt|;
comment|/* 13 == sizeof("$end") + sizeof("$accept") */
for|for
control|(
name|bp
operator|=
name|first_symbol
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
name|name_pool_size
operator|+=
name|strlen
argument_list|(
name|bp
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name_pool
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|name_pool_size
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|name_pool
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name_pool
argument_list|,
literal|"$accept"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name_pool
operator|+
literal|8
argument_list|,
literal|"$end"
argument_list|)
expr_stmt|;
name|t
operator|=
name|name_pool
operator|+
literal|13
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|first_symbol
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
name|p
operator|=
name|t
expr_stmt|;
name|s
operator|=
name|bp
operator|->
name|name
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|FREE
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|name
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_symbols
parameter_list|(
name|void
parameter_list|)
block|{
name|bucket
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|goal
operator|->
name|class
operator|==
name|UNKNOWN
condition|)
name|undefined_goal
argument_list|(
name|goal
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|first_symbol
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|UNKNOWN
condition|)
block|{
name|undefined_symbol_warning
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|class
operator|=
name|TERM
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|protect_string
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|char
modifier|*
modifier|*
name|des
parameter_list|)
block|{
name|unsigned
name|len
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|;
operator|*
name|des
operator|=
name|src
expr_stmt|;
if|if
condition|(
name|src
condition|)
block|{
name|len
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|src
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
literal|'\\'
operator|==
operator|*
name|s
operator|||
literal|'"'
operator|==
operator|*
name|s
condition|)
name|len
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
operator|*
name|des
operator|=
name|d
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|s
operator|=
name|src
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
literal|'\\'
operator|==
operator|*
name|s
operator|||
literal|'"'
operator|==
operator|*
name|s
condition|)
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pack_symbols
parameter_list|(
name|void
parameter_list|)
block|{
name|bucket
modifier|*
name|bp
decl_stmt|;
name|bucket
modifier|*
modifier|*
name|v
decl_stmt|;
name|Value_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|Value_t
name|max_tok_pval
decl_stmt|;
endif|#
directive|endif
name|nsyms
operator|=
literal|2
expr_stmt|;
name|ntokens
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|first_symbol
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
operator|++
name|nsyms
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|TERM
condition|)
operator|++
name|ntokens
expr_stmt|;
block|}
name|start_symbol
operator|=
operator|(
name|Value_t
operator|)
name|ntokens
expr_stmt|;
name|nvars
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|nsyms
operator|-
name|ntokens
argument_list|)
expr_stmt|;
name|symbol_name
operator|=
name|TMALLOC
argument_list|(
name|char
operator|*
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
name|symbol_value
operator|=
name|TMALLOC
argument_list|(
name|Value_t
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|symbol_value
argument_list|)
expr_stmt|;
name|symbol_prec
operator|=
name|TMALLOC
argument_list|(
name|Value_t
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|symbol_prec
argument_list|)
expr_stmt|;
name|symbol_assoc
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|symbol_assoc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|symbol_pval
operator|=
name|TMALLOC
argument_list|(
name|Value_t
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|symbol_pval
argument_list|)
expr_stmt|;
if|if
condition|(
name|destructor
condition|)
block|{
name|symbol_destructor
operator|=
name|CALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|symbol_destructor
argument_list|)
expr_stmt|;
name|symbol_type_tag
operator|=
name|CALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|symbol_type_tag
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|v
operator|=
name|TMALLOC
argument_list|(
name|bucket
operator|*
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|v
index|[
name|start_symbol
index|]
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|j
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|start_symbol
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|first_symbol
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|TERM
condition|)
name|v
index|[
name|i
operator|++
index|]
operator|=
name|bp
expr_stmt|;
else|else
name|v
index|[
name|j
operator|++
index|]
operator|=
name|bp
expr_stmt|;
block|}
name|assert
argument_list|(
name|i
operator|==
name|ntokens
operator|&&
name|j
operator|==
name|nsyms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
operator|++
name|i
control|)
name|v
index|[
name|i
index|]
operator|->
name|index
operator|=
name|i
expr_stmt|;
name|goal
operator|->
name|index
operator|=
call|(
name|Index_t
call|)
argument_list|(
name|start_symbol
operator|+
literal|1
argument_list|)
expr_stmt|;
name|k
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|start_symbol
operator|+
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<
name|nsyms
condition|)
if|if
condition|(
name|v
index|[
name|i
index|]
operator|!=
name|goal
condition|)
block|{
name|v
index|[
name|i
index|]
operator|->
name|index
operator|=
name|k
expr_stmt|;
operator|++
name|k
expr_stmt|;
block|}
name|goal
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|k
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|start_symbol
operator|+
literal|1
argument_list|)
init|;
name|i
operator|<
name|nsyms
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|v
index|[
name|i
index|]
operator|!=
name|goal
condition|)
block|{
name|v
index|[
name|i
index|]
operator|->
name|value
operator|=
name|k
expr_stmt|;
operator|++
name|k
expr_stmt|;
block|}
block|}
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
operator|++
name|i
control|)
block|{
name|n
operator|=
name|v
index|[
name|i
index|]
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|256
condition|)
block|{
for|for
control|(
name|j
operator|=
name|k
operator|++
init|;
name|j
operator|>
literal|0
operator|&&
name|symbol_value
index|[
name|j
operator|-
literal|1
index|]
operator|>
name|n
condition|;
operator|--
name|j
control|)
name|symbol_value
index|[
name|j
index|]
operator|=
name|symbol_value
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|symbol_value
index|[
name|j
index|]
operator|=
name|n
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|v
index|[
literal|1
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
index|[
literal|1
index|]
operator|->
name|value
operator|==
name|UNDEFINED
condition|)
name|v
index|[
literal|1
index|]
operator|->
name|value
operator|=
literal|256
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|257
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|v
index|[
name|i
index|]
operator|->
name|value
operator|==
name|UNDEFINED
condition|)
block|{
while|while
condition|(
name|j
operator|<
name|k
operator|&&
name|n
operator|==
name|symbol_value
index|[
name|j
index|]
condition|)
block|{
while|while
condition|(
operator|++
name|j
operator|<
name|k
operator|&&
name|n
operator|==
name|symbol_value
index|[
name|j
index|]
condition|)
continue|continue;
operator|++
name|n
expr_stmt|;
block|}
name|v
index|[
name|i
index|]
operator|->
name|value
operator|=
name|n
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
block|}
name|symbol_name
index|[
literal|0
index|]
operator|=
name|name_pool
operator|+
literal|8
expr_stmt|;
name|symbol_value
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|symbol_prec
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|symbol_assoc
index|[
literal|0
index|]
operator|=
name|TOKEN
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|symbol_pval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|max_tok_pval
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
operator|++
name|i
control|)
block|{
name|symbol_name
index|[
name|i
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|name
expr_stmt|;
name|symbol_value
index|[
name|i
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|value
expr_stmt|;
name|symbol_prec
index|[
name|i
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|prec
expr_stmt|;
name|symbol_assoc
index|[
name|i
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|assoc
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|symbol_pval
index|[
name|i
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|symbol_pval
index|[
name|i
index|]
operator|>
name|max_tok_pval
condition|)
name|max_tok_pval
operator|=
name|symbol_pval
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|destructor
condition|)
block|{
name|symbol_destructor
index|[
name|i
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|destructor
expr_stmt|;
name|symbol_type_tag
index|[
name|i
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|tag
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|symbol_name
index|[
name|start_symbol
index|]
operator|=
name|name_pool
expr_stmt|;
name|symbol_value
index|[
name|start_symbol
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|symbol_prec
index|[
name|start_symbol
index|]
operator|=
literal|0
expr_stmt|;
name|symbol_assoc
index|[
name|start_symbol
index|]
operator|=
name|TOKEN
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|symbol_pval
index|[
name|start_symbol
index|]
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|max_tok_pval
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
operator|++
name|i
init|;
name|i
operator|<
name|nsyms
condition|;
operator|++
name|i
control|)
block|{
name|k
operator|=
name|v
index|[
name|i
index|]
operator|->
name|index
expr_stmt|;
name|symbol_name
index|[
name|k
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|name
expr_stmt|;
name|symbol_value
index|[
name|k
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|value
expr_stmt|;
name|symbol_prec
index|[
name|k
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|prec
expr_stmt|;
name|symbol_assoc
index|[
name|k
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|assoc
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|symbol_pval
index|[
name|k
index|]
operator|=
call|(
name|Value_t
call|)
argument_list|(
operator|(
name|max_tok_pval
operator|+
literal|1
operator|)
operator|+
name|v
index|[
name|i
index|]
operator|->
name|value
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|destructor
condition|)
block|{
name|symbol_destructor
index|[
name|k
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|destructor
expr_stmt|;
name|symbol_type_tag
index|[
name|k
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|tag
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|gflag
condition|)
block|{
name|symbol_pname
operator|=
name|TMALLOC
argument_list|(
name|char
operator|*
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|symbol_pname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
operator|++
name|i
control|)
name|protect_string
argument_list|(
name|symbol_name
index|[
name|i
index|]
argument_list|,
operator|&
operator|(
name|symbol_pname
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pack_grammar
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Value_t
name|j
decl_stmt|;
name|Assoc_t
name|assoc
decl_stmt|;
name|Value_t
name|prec2
decl_stmt|;
name|ritem
operator|=
name|TMALLOC
argument_list|(
name|Value_t
argument_list|,
name|nitems
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|ritem
argument_list|)
expr_stmt|;
name|rlhs
operator|=
name|TMALLOC
argument_list|(
name|Value_t
argument_list|,
name|nrules
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|rlhs
argument_list|)
expr_stmt|;
name|rrhs
operator|=
name|TMALLOC
argument_list|(
name|Value_t
argument_list|,
name|nrules
operator|+
literal|1
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|rrhs
argument_list|)
expr_stmt|;
name|rprec
operator|=
name|TREALLOC
argument_list|(
name|Value_t
argument_list|,
name|rprec
argument_list|,
name|nrules
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|rprec
argument_list|)
expr_stmt|;
name|rassoc
operator|=
name|TREALLOC
argument_list|(
name|Assoc_t
argument_list|,
name|rassoc
argument_list|,
name|nrules
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|rassoc
argument_list|)
expr_stmt|;
name|ritem
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|ritem
index|[
literal|1
index|]
operator|=
name|goal
operator|->
name|index
expr_stmt|;
name|ritem
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ritem
index|[
literal|3
index|]
operator|=
operator|-
literal|2
expr_stmt|;
name|rlhs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rlhs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rlhs
index|[
literal|2
index|]
operator|=
name|start_symbol
expr_stmt|;
name|rrhs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rrhs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rrhs
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
name|j
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|nrules
condition|;
operator|++
name|i
control|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|plhs
index|[
name|i
index|]
operator|->
name|args
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|plhs
index|[
name|i
index|]
operator|->
name|argnames
condition|)
block|{
name|FREE
argument_list|(
name|plhs
index|[
name|i
index|]
operator|->
name|argnames
argument_list|)
expr_stmt|;
name|plhs
index|[
name|i
index|]
operator|->
name|argnames
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|plhs
index|[
name|i
index|]
operator|->
name|argtags
condition|)
block|{
name|FREE
argument_list|(
name|plhs
index|[
name|i
index|]
operator|->
name|argtags
argument_list|)
expr_stmt|;
name|plhs
index|[
name|i
index|]
operator|->
name|argtags
operator|=
name|NULL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* defined(YYBTYACC) */
name|rlhs
index|[
name|i
index|]
operator|=
name|plhs
index|[
name|i
index|]
operator|->
name|index
expr_stmt|;
name|rrhs
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|assoc
operator|=
name|TOKEN
expr_stmt|;
name|prec2
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pitem
index|[
name|j
index|]
condition|)
block|{
name|ritem
index|[
name|j
index|]
operator|=
name|pitem
index|[
name|j
index|]
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|pitem
index|[
name|j
index|]
operator|->
name|class
operator|==
name|TERM
condition|)
block|{
name|prec2
operator|=
name|pitem
index|[
name|j
index|]
operator|->
name|prec
expr_stmt|;
name|assoc
operator|=
name|pitem
index|[
name|j
index|]
operator|->
name|assoc
expr_stmt|;
block|}
operator|++
name|j
expr_stmt|;
block|}
name|ritem
index|[
name|j
index|]
operator|=
operator|(
name|Value_t
operator|)
operator|-
name|i
expr_stmt|;
operator|++
name|j
expr_stmt|;
if|if
condition|(
name|rprec
index|[
name|i
index|]
operator|==
name|UNDEFINED
condition|)
block|{
name|rprec
index|[
name|i
index|]
operator|=
name|prec2
expr_stmt|;
name|rassoc
index|[
name|i
index|]
operator|=
name|assoc
expr_stmt|;
block|}
block|}
name|rrhs
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|FREE
argument_list|(
name|plhs
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pitem
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|clean_arg_cache
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|print_grammar
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|size_t
name|j
decl_stmt|,
name|spacing
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|verbose_file
decl_stmt|;
if|if
condition|(
operator|!
name|vflag
condition|)
return|return;
name|k
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|nrules
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|rlhs
index|[
name|i
index|]
operator|!=
name|rlhs
index|[
name|i
operator|-
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|i
operator|!=
literal|2
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%4d  %s :"
argument_list|,
name|i
operator|-
literal|2
argument_list|,
name|symbol_name
index|[
name|rlhs
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|spacing
operator|=
name|strlen
argument_list|(
name|symbol_name
index|[
name|rlhs
index|[
name|i
index|]
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%4d  "
argument_list|,
name|i
operator|-
literal|2
argument_list|)
expr_stmt|;
name|j
operator|=
name|spacing
expr_stmt|;
while|while
condition|(
name|j
operator|--
operator|!=
literal|0
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'|'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|ritem
index|[
name|k
index|]
operator|>=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %s"
argument_list|,
name|symbol_name
index|[
name|ritem
index|[
name|k
index|]
index|]
argument_list|)
expr_stmt|;
operator|++
name|k
expr_stmt|;
block|}
operator|++
name|k
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
end_if

begin_function
specifier|static
name|void
name|finalize_destructors
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|nsyms
condition|;
operator|++
name|i
control|)
block|{
name|tag
operator|=
name|symbol_type_tag
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|symbol_destructor
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
block|{
comment|/* use<> destructor, if there is one */
if|if
condition|(
operator|(
name|bp
operator|=
name|default_destructor
index|[
name|UNTYPED_DEFAULT
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|symbol_destructor
index|[
name|i
index|]
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|bp
operator|->
name|destructor
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|symbol_destructor
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|symbol_destructor
index|[
name|i
index|]
argument_list|,
name|bp
operator|->
name|destructor
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* use type destructor for this tag, if there is one */
name|bp
operator|=
name|lookup_type_destructor
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|destructor
operator|!=
name|NULL
condition|)
block|{
name|symbol_destructor
index|[
name|i
index|]
operator|=
name|TMALLOC
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|bp
operator|->
name|destructor
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|symbol_destructor
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|symbol_destructor
index|[
name|i
index|]
argument_list|,
name|bp
operator|->
name|destructor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* use<*> destructor, if there is one */
if|if
condition|(
operator|(
name|bp
operator|=
name|default_destructor
index|[
name|TYPED_DEFAULT
index|]
operator|)
operator|!=
name|NULL
condition|)
comment|/* replace "$$" with "(*val).tag" in destructor code */
name|symbol_destructor
index|[
name|i
index|]
operator|=
name|process_destructor_XX
argument_list|(
name|bp
operator|->
name|destructor
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* replace "$$" with "(*val)[.tag]" in destructor code */
name|symbol_destructor
index|[
name|i
index|]
operator|=
name|process_destructor_XX
argument_list|(
name|symbol_destructor
index|[
name|i
index|]
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 'symbol_type_tag[]' elements are freed by 'free_tags()' */
name|DO_FREE
argument_list|(
name|symbol_type_tag
argument_list|)
expr_stmt|;
comment|/* no longer needed */
if|if
condition|(
operator|(
name|bp
operator|=
name|default_destructor
index|[
name|UNTYPED_DEFAULT
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 'bp->tag' is a static value, don't free */
name|FREE
argument_list|(
name|bp
operator|->
name|destructor
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bp
operator|=
name|default_destructor
index|[
name|TYPED_DEFAULT
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 'bp->tag' is a static value, don't free */
name|FREE
argument_list|(
name|bp
operator|->
name|destructor
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bp
operator|=
name|default_destructor
index|[
name|TYPE_SPECIFIED
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bucket
modifier|*
name|p
decl_stmt|;
for|for
control|(
init|;
name|bp
condition|;
name|bp
operator|=
name|p
control|)
block|{
name|p
operator|=
name|bp
operator|->
name|link
expr_stmt|;
name|FREE
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 'bp->tag' freed by 'free_tags()' */
name|FREE
argument_list|(
name|bp
operator|->
name|destructor
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(YYBTYACC) */
end_comment

begin_function
name|void
name|reader
parameter_list|(
name|void
parameter_list|)
block|{
name|write_section
argument_list|(
name|code_file
argument_list|,
name|banner
argument_list|)
expr_stmt|;
name|create_symbol_table
argument_list|()
expr_stmt|;
name|read_declarations
argument_list|()
expr_stmt|;
name|read_grammar
argument_list|()
expr_stmt|;
name|free_symbol_table
argument_list|()
expr_stmt|;
name|pack_names
argument_list|()
expr_stmt|;
name|check_symbols
argument_list|()
expr_stmt|;
name|pack_symbols
argument_list|()
expr_stmt|;
name|pack_grammar
argument_list|()
expr_stmt|;
name|free_symbols
argument_list|()
expr_stmt|;
name|print_grammar
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|destructor
condition|)
name|finalize_destructors
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|free_tags
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NO_LEAKS
end_ifdef

begin_function
specifier|static
name|param
modifier|*
name|free_declarations
parameter_list|(
name|param
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
operator|!=
literal|0
condition|)
block|{
name|param
modifier|*
name|next
init|=
name|list
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|list
operator|->
name|type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
operator|->
name|type2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|next
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function

begin_function
name|void
name|reader_leaks
parameter_list|(
name|void
parameter_list|)
block|{
name|lex_param
operator|=
name|free_declarations
argument_list|(
name|lex_param
argument_list|)
expr_stmt|;
name|parse_param
operator|=
name|free_declarations
argument_list|(
name|parse_param
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|rrhs
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|rlhs
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|rprec
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|ritem
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|rassoc
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|name_pool
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|symbol_prec
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|symbol_assoc
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|symbol_value
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|DO_FREE
argument_list|(
name|symbol_pval
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|symbol_destructor
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|symbol_type_tag
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

