begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* sort - sort lines of text (with all kinds of options).    Copyright (C) 88, 1991-2002 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written December 1988 by Mike Haertel.    The author may be reached (Email) at the address mike@gnu.ai.mit.edu,    or (US mail) as Mike Haertel c/o Free Software Foundation.     Ã˜rn E. Hansen added NLS support in 1997.  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"long-options.h"
end_include

begin_include
include|#
directive|include
file|"error.h"
end_include

begin_include
include|#
directive|include
file|"hard-locale.h"
end_include

begin_include
include|#
directive|include
file|"human.h"
end_include

begin_include
include|#
directive|include
file|"physmem.h"
end_include

begin_include
include|#
directive|include
file|"posixver.h"
end_include

begin_include
include|#
directive|include
file|"stdio-safer.h"
end_include

begin_include
include|#
directive|include
file|"xmemcoll.h"
end_include

begin_include
include|#
directive|include
file|"xstrtol.h"
end_include

begin_if
if|#
directive|if
name|HAVE_SYS_RESOURCE_H
end_if

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RLIMIT_DATA
end_ifndef

begin_struct
struct|struct
name|rlimit
block|{
name|size_t
name|rlim_cur
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|getrlimit
parameter_list|(
name|Resource
parameter_list|,
name|Rlp
parameter_list|)
value|(-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The official name of this program (e.g., no `g' prefix).  */
end_comment

begin_define
define|#
directive|define
name|PROGRAM_NAME
value|"sort"
end_define

begin_define
define|#
directive|define
name|AUTHORS
value|N_ ("Mike Haertel and Paul Eggert")
end_define

begin_if
if|#
directive|if
name|HAVE_LANGINFO_H
end_if

begin_include
include|#
directive|include
file|<langinfo.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SA_NOCLDSTOP
end_ifndef

begin_define
define|#
directive|define
name|sigprocmask
parameter_list|(
name|How
parameter_list|,
name|Set
parameter_list|,
name|Oset
parameter_list|)
end_define

begin_comment
comment|/* empty */
end_comment

begin_define
define|#
directive|define
name|sigset_t
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STDC_HEADERS
end_ifndef

begin_function_decl
name|double
name|strtod
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Undefine, to avoid warning about redefinition on some systems.  */
end_comment

begin_comment
comment|/* FIXME: Remove these: use MIN/MAX from sys2.h.  */
end_comment

begin_undef
undef|#
directive|undef
name|min
end_undef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_undef
undef|#
directive|undef
name|max
end_undef

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|UCHAR_LIM
value|(UCHAR_MAX + 1)
end_define

begin_define
define|#
directive|define
name|UCHAR
parameter_list|(
name|c
parameter_list|)
value|((unsigned char) (c))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_TMPDIR
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_TMPDIR
value|"/tmp"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Use this as exit status in case of error, not EXIT_FAILURE.  This    is necessary because EXIT_FAILURE is usually 1 and POSIX requires    that sort exit with status 1 IFF invoked with -c and the input is    not properly sorted.  Any other irregular exit must exit with a    status code greater than 1.  */
end_comment

begin_define
define|#
directive|define
name|SORT_FAILURE
value|2
end_define

begin_define
define|#
directive|define
name|SORT_OUT_OF_ORDER
value|1
end_define

begin_define
define|#
directive|define
name|C_DECIMAL_POINT
value|'.'
end_define

begin_define
define|#
directive|define
name|NEGATION_SIGN
value|'-'
end_define

begin_define
define|#
directive|define
name|NUMERIC_ZERO
value|'0'
end_define

begin_if
if|#
directive|if
name|HAVE_SETLOCALE
end_if

begin_decl_stmt
specifier|static
name|char
name|decimal_point
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|th_sep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if CHAR_MAX + 1, then there is no thousands separator */
end_comment

begin_comment
comment|/* Nonzero if the corresponding locales are hard.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hard_LC_COLLATE
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HAVE_NL_LANGINFO
end_if

begin_decl_stmt
specifier|static
name|int
name|hard_LC_TIME
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IS_THOUSANDS_SEP
parameter_list|(
name|x
parameter_list|)
value|((x) == th_sep)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|decimal_point
value|C_DECIMAL_POINT
end_define

begin_define
define|#
directive|define
name|IS_THOUSANDS_SEP
parameter_list|(
name|x
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NONZERO
parameter_list|(
name|x
parameter_list|)
value|(x != 0)
end_define

begin_comment
comment|/* The kind of blanks for '-b' to skip in various options. */
end_comment

begin_enum
enum|enum
name|blanktype
block|{
name|bl_start
block|,
name|bl_end
block|,
name|bl_both
block|}
enum|;
end_enum

begin_comment
comment|/* The character marking end of line. Default to \n. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|eolchar
init|=
literal|'\n'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lines are held in core as counted strings. */
end_comment

begin_struct
struct|struct
name|line
block|{
name|char
modifier|*
name|text
decl_stmt|;
comment|/* Text of the line. */
name|size_t
name|length
decl_stmt|;
comment|/* Length including final newline. */
name|char
modifier|*
name|keybeg
decl_stmt|;
comment|/* Start of first key. */
name|char
modifier|*
name|keylim
decl_stmt|;
comment|/* Limit of first key. */
block|}
struct|;
end_struct

begin_comment
comment|/* Input buffers. */
end_comment

begin_struct
struct|struct
name|buffer
block|{
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Dynamically allocated buffer, 				   partitioned into 3 regions: 				   - input data; 				   - unused area; 				   - an array of lines, in reverse order.  */
name|size_t
name|used
decl_stmt|;
comment|/* Number of bytes used for input data.  */
name|size_t
name|nlines
decl_stmt|;
comment|/* Number of lines in the line array.  */
name|size_t
name|alloc
decl_stmt|;
comment|/* Number of bytes allocated. */
name|size_t
name|left
decl_stmt|;
comment|/* Number of bytes left from previous reads. */
name|size_t
name|line_bytes
decl_stmt|;
comment|/* Number of bytes to reserve for each line. */
name|int
name|eof
decl_stmt|;
comment|/* An EOF has been read.  */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|keyfield
block|{
name|size_t
name|sword
decl_stmt|;
comment|/* Zero-origin 'word' to start at. */
name|size_t
name|schar
decl_stmt|;
comment|/* Additional characters to skip. */
name|int
name|skipsblanks
decl_stmt|;
comment|/* Skip leading white space at start. */
name|size_t
name|eword
decl_stmt|;
comment|/* Zero-origin first word after field. */
name|size_t
name|echar
decl_stmt|;
comment|/* Additional characters in field. */
name|int
name|skipeblanks
decl_stmt|;
comment|/* Skip trailing white space at finish. */
name|int
modifier|*
name|ignore
decl_stmt|;
comment|/* Boolean array of characters to ignore. */
name|char
modifier|*
name|translate
decl_stmt|;
comment|/* Translation applied to characters. */
name|int
name|numeric
decl_stmt|;
comment|/* Flag for numeric comparison.  Handle 				   strings of digits with optional decimal 				   point, but no exponential notation. */
name|int
name|general_numeric
decl_stmt|;
comment|/* Flag for general, numeric comparison. 				   Handle numbers in exponential notation. */
name|int
name|month
decl_stmt|;
comment|/* Flag for comparison by month name. */
name|int
name|reverse
decl_stmt|;
comment|/* Reverse the sense of comparison. */
name|struct
name|keyfield
modifier|*
name|next
decl_stmt|;
comment|/* Next keyfield to try. */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|month
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The name this program was run with. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME: None of these tables work with multibyte character sets.    Also, there are many other bugs when handling multibyte characters,    or even unibyte encodings where line boundaries are not in the    initial shift state.  One way to fix this is to rewrite `sort' to    use wide characters internally, but doing this with good    performance is a bit tricky.  */
end_comment

begin_comment
comment|/* Table of white space. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|blanks
index|[
name|UCHAR_LIM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of non-printing characters. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nonprinting
index|[
name|UCHAR_LIM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of non-dictionary characters (not letters, digits, or blanks). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nondictionary
index|[
name|UCHAR_LIM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Translation table folding lower case to upper.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|fold_toupper
index|[
name|UCHAR_LIM
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MONTHS_PER_YEAR
value|12
end_define

begin_comment
comment|/* Table mapping month names to integers.    Alphabetic order allows binary search. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|month
name|monthtab
index|[]
init|=
block|{
block|{
literal|"APR"
block|,
literal|4
block|}
block|,
block|{
literal|"AUG"
block|,
literal|8
block|}
block|,
block|{
literal|"DEC"
block|,
literal|12
block|}
block|,
block|{
literal|"FEB"
block|,
literal|2
block|}
block|,
block|{
literal|"JAN"
block|,
literal|1
block|}
block|,
block|{
literal|"JUL"
block|,
literal|7
block|}
block|,
block|{
literal|"JUN"
block|,
literal|6
block|}
block|,
block|{
literal|"MAR"
block|,
literal|3
block|}
block|,
block|{
literal|"MAY"
block|,
literal|5
block|}
block|,
block|{
literal|"NOV"
block|,
literal|11
block|}
block|,
block|{
literal|"OCT"
block|,
literal|10
block|}
block|,
block|{
literal|"SEP"
block|,
literal|9
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During the merge phase, the number of files to merge at once. */
end_comment

begin_define
define|#
directive|define
name|NMERGE
value|16
end_define

begin_comment
comment|/* Minimum size for a merge or check buffer.  */
end_comment

begin_define
define|#
directive|define
name|MIN_MERGE_BUFFER_SIZE
value|(2 + sizeof (struct line))
end_define

begin_comment
comment|/* Minimum sort size; the code might not work with smaller sizes.  */
end_comment

begin_define
define|#
directive|define
name|MIN_SORT_SIZE
value|(NMERGE * MIN_MERGE_BUFFER_SIZE)
end_define

begin_comment
comment|/* The number of bytes needed for a merge or check buffer, which can    function relatively efficiently even if it holds only one line.  If    a longer line is seen, this value is increased.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|merge_buffer_size
init|=
name|MAX
argument_list|(
name|MIN_MERGE_BUFFER_SIZE
argument_list|,
literal|256
operator|*
literal|1024
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The approximate maximum number of bytes of main memory to use, as    specified by the user.  Zero if the user has not specified a size.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|sort_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The guessed size for non-regular files.  */
end_comment

begin_define
define|#
directive|define
name|INPUT_FILE_SIZE_GUESS
value|(1024 * 1024)
end_define

begin_comment
comment|/* Array of directory names in which any temporary files are to be created. */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
modifier|*
name|temp_dirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of temporary directory names used.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|temp_dir_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of allocated slots in temp_dirs.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|temp_dir_alloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Our process ID.  */
end_comment

begin_decl_stmt
specifier|static
name|pid_t
name|process_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag to reverse the order of all comparisons. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reverse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag for stable sort.  This turns off the last ditch bytewise    comparison of lines, and instead leaves lines in the same order    they were read if all keys compare equal.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tab character separating fields.  If NUL, then fields are separated    by the empty string between a non-whitespace character and a whitespace    character. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|tab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag to remove consecutive duplicate lines from the output.    Only the last of a sequence of equal lines will be output. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unique
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if any of the input files are the standard input. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|have_read_stdin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of key field comparisons to be tried.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyfield
modifier|*
name|keylist
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|usage
parameter_list|(
name|int
name|status
parameter_list|)
block|{
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Try `%s --help' for more information.\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ Usage: %s [OPTION]... [FILE]...\n\ "
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ Write sorted concatenation of all FILE(s) to standard output.\n\ \n\ Ordering options:\n\ \n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ Mandatory arguments to long options are mandatory for short options too.\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   -b, --ignore-leading-blanks ignore leading blanks\n\   -d, --dictionary-order      consider only blanks and alphanumeric characters\n\   -f, --ignore-case           fold lower case to upper case characters\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   -g, --general-numeric-sort  compare according to general numerical value\n\   -i, --ignore-nonprinting    consider only printable characters\n\   -M, --month-sort            compare (unknown)< `JAN'< ...< `DEC'\n\   -n, --numeric-sort          compare according to string numerical value\n\   -r, --reverse               reverse the result of comparisons\n\ \n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ Other options:\n\ \n\   -c, --check               check whether input is sorted; do not sort\n\   -k, --key=POS1[,POS2]     start a key at POS1, end it at POS 2 (origin 1)\n\   -m, --merge               merge already sorted files; do not sort\n\   -o, --output=FILE         write result to FILE instead of standard output\n\   -s, --stable              stabilize sort by disabling last-resort comparison\n\   -S, --buffer-size=SIZE    use SIZE for main memory buffer\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\   -t, --field-separator=SEP use SEP instead of non- to whitespace transition\n\   -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s\n\                               multiple options specify multiple directories\n\   -u, --unique              with -c: check for strict ordering\n\                               otherwise: output only the first of an equal run\n\ "
argument_list|)
argument_list|,
name|DEFAULT_TMPDIR
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   -z, --zero-terminated     end lines with 0 byte, not newline\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|HELP_OPTION_DESCRIPTION
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|VERSION_OPTION_DESCRIPTION
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ \n\ POS is F[.C][OPTS], where F is the field number and C the character position\n\ in the field.  OPTS is one or more single-letter ordering options, which\n\ override global ordering options for that key.  If no key is given, use the\n\ entire line as the key.\n\ \n\ SIZE may be followed by the following multiplicative suffixes:\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ % 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n\ \n\ With no FILE, or when FILE is -, read standard input.\n\ \n\ *** WARNING ***\n\ The locale specified by the environment affects sort order.\n\ Set LC_ALL=C to get the traditional sort order that uses\n\ native byte values.\n\ "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nReport bugs to<%s>.\n"
argument_list|)
argument_list|,
name|PACKAGE_BUGREPORT
argument_list|)
expr_stmt|;
block|}
comment|/* Don't use EXIT_FAILURE here in case it is defined to be 1.      POSIX requires that sort return 1 IFF invoked with -c and      the input is not properly sorted.  */
name|assert
argument_list|(
name|status
operator|==
literal|0
operator|||
name|status
operator|==
name|SORT_FAILURE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|COMMON_SHORT_OPTIONS
value|"-bcdfgik:mMno:rsS:t:T:uz"
end_define

begin_decl_stmt
specifier|static
name|struct
name|option
specifier|const
name|long_options
index|[]
init|=
block|{
block|{
literal|"ignore-leading-blanks"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
block|{
literal|"check"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"dictionary-order"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"ignore-case"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"general-numeric-sort"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'g'
block|}
block|,
block|{
literal|"ignore-nonprinting"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'i'
block|}
block|,
block|{
literal|"key"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'k'
block|}
block|,
block|{
literal|"merge"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'m'
block|}
block|,
block|{
literal|"month-sort"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'M'
block|}
block|,
block|{
literal|"numeric-sort"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"output"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'o'
block|}
block|,
block|{
literal|"reverse"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'r'
block|}
block|,
block|{
literal|"stable"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"buffer-size"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
block|{
literal|"field-separator"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
block|{
literal|"temporary-directory"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'T'
block|}
block|,
block|{
literal|"unique"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'u'
block|}
block|,
block|{
literal|"zero-terminated"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'z'
block|}
block|,
block|{
name|GETOPT_HELP_OPTION_DECL
block|}
block|,
block|{
name|GETOPT_VERSION_OPTION_DECL
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The set of signals that are caught.  */
end_comment

begin_decl_stmt
specifier|static
name|sigset_t
name|caught_signals
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of temporary files. */
end_comment

begin_struct
struct|struct
name|tempnode
block|{
name|struct
name|tempnode
modifier|*
specifier|volatile
name|next
decl_stmt|;
name|char
name|name
index|[
literal|1
index|]
decl_stmt|;
comment|/* Actual size is 1 + file name length.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|tempnode
modifier|*
specifier|volatile
name|temphead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Clean up any remaining temporary files. */
end_comment

begin_function
specifier|static
name|void
name|cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tempnode
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|temphead
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|unlink
argument_list|(
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report MESSAGE for FILE, then clean up and exit.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|die
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|die
parameter_list|(
name|char
specifier|const
modifier|*
name|message
parameter_list|,
name|char
specifier|const
modifier|*
name|file
parameter_list|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s: %s"
argument_list|,
name|message
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|SORT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new temporary file, returning its newly allocated name.    Store into *PFP a stream open for writing.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|create_temp_file
parameter_list|(
name|FILE
modifier|*
modifier|*
name|pfp
parameter_list|)
block|{
specifier|static
name|char
specifier|const
name|slashbase
index|[]
init|=
literal|"/sortXXXXXX"
decl_stmt|;
specifier|static
name|size_t
name|temp_dir_index
decl_stmt|;
name|sigset_t
name|oldset
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|saved_errno
decl_stmt|;
name|char
specifier|const
modifier|*
name|temp_dir
init|=
name|temp_dirs
index|[
name|temp_dir_index
index|]
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|temp_dir
argument_list|)
decl_stmt|;
name|struct
name|tempnode
modifier|*
name|node
init|=
operator|(
expr|struct
name|tempnode
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
name|node
operator|->
name|next
operator|+
name|len
operator|+
sizeof|sizeof
name|slashbase
argument_list|)
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|node
operator|->
name|name
decl_stmt|;
name|memcpy
argument_list|(
name|file
argument_list|,
name|temp_dir
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|file
operator|+
name|len
argument_list|,
name|slashbase
argument_list|,
sizeof|sizeof
name|slashbase
argument_list|)
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|temphead
expr_stmt|;
if|if
condition|(
operator|++
name|temp_dir_index
operator|==
name|temp_dir_count
condition|)
name|temp_dir_index
operator|=
literal|0
expr_stmt|;
comment|/* Create the temporary file in a critical section, to avoid races.  */
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|caught_signals
argument_list|,
operator|&
name|oldset
argument_list|)
expr_stmt|;
name|fd
operator|=
name|mkstemp
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|fd
condition|)
name|temphead
operator|=
name|node
expr_stmt|;
name|saved_errno
operator|=
name|errno
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|oldset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
operator|(
operator|*
name|pfp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"cannot create temporary file"
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|file
return|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|xfopen
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|how
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|how
operator|==
literal|'r'
condition|)
block|{
name|have_read_stdin
operator|=
literal|1
expr_stmt|;
name|fp
operator|=
name|stdin
expr_stmt|;
block|}
else|else
name|fp
operator|=
name|stdout
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen_safer
argument_list|(
name|file
argument_list|,
name|how
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"open failed"
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/* Close FP, whose name is FILE, and report any errors.  */
end_comment

begin_function
specifier|static
name|void
name|xfclose
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
specifier|const
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
name|fp
operator|==
name|stdin
condition|)
block|{
comment|/* Allow reading stdin from tty more than once. */
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
name|clearerr
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|!=
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"close failed"
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|write_bytes
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|n_bytes
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|output_file
parameter_list|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|n_bytes
argument_list|,
name|fp
argument_list|)
operator|!=
name|n_bytes
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"write failed"
argument_list|)
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append DIR to the array of temporary directory names.  */
end_comment

begin_function
specifier|static
name|void
name|add_temp_dir
parameter_list|(
name|char
specifier|const
modifier|*
name|dir
parameter_list|)
block|{
if|if
condition|(
name|temp_dir_count
operator|==
name|temp_dir_alloc
condition|)
block|{
name|temp_dir_alloc
operator|=
name|temp_dir_alloc
condition|?
name|temp_dir_alloc
operator|*
literal|2
else|:
literal|16
expr_stmt|;
name|temp_dirs
operator|=
name|xrealloc
argument_list|(
name|temp_dirs
argument_list|,
sizeof|sizeof
argument_list|(
name|temp_dirs
argument_list|)
operator|*
name|temp_dir_alloc
argument_list|)
expr_stmt|;
block|}
name|temp_dirs
index|[
name|temp_dir_count
operator|++
index|]
operator|=
name|dir
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search through the list of temporary files for NAME;    remove it if it is found on the list. */
end_comment

begin_function
specifier|static
name|void
name|zaptemp
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|tempnode
modifier|*
specifier|volatile
modifier|*
name|pnode
decl_stmt|;
name|struct
name|tempnode
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|pnode
operator|=
operator|&
name|temphead
init|;
operator|(
name|node
operator|=
operator|*
name|pnode
operator|)
condition|;
name|pnode
operator|=
operator|&
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|name
operator|==
name|name
condition|)
block|{
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|pnode
operator|=
name|node
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|HAVE_NL_LANGINFO
end_if

begin_function
specifier|static
name|int
name|struct_month_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|m1
parameter_list|,
specifier|const
name|void
modifier|*
name|m2
parameter_list|)
block|{
return|return
name|strcmp
argument_list|(
operator|(
operator|(
specifier|const
expr|struct
name|month
operator|*
operator|)
name|m1
operator|)
operator|->
name|name
argument_list|,
operator|(
operator|(
specifier|const
expr|struct
name|month
operator|*
operator|)
name|m2
operator|)
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Initialize the character class tables. */
end_comment

begin_function
specifier|static
name|void
name|inittables
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UCHAR_LIM
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ISBLANK
argument_list|(
name|i
argument_list|)
condition|)
name|blanks
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ISPRINT
argument_list|(
name|i
argument_list|)
condition|)
name|nonprinting
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ISALNUM
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|ISBLANK
argument_list|(
name|i
argument_list|)
condition|)
name|nondictionary
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ISLOWER
argument_list|(
name|i
argument_list|)
condition|)
name|fold_toupper
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
name|fold_toupper
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
if|#
directive|if
name|HAVE_NL_LANGINFO
comment|/* If we're not in the "C" locale, read different names for months.  */
if|if
condition|(
name|hard_LC_TIME
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MONTHS_PER_YEAR
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|s_len
decl_stmt|;
name|size_t
name|j
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|nl_langinfo
argument_list|(
name|ABMON_1
operator|+
name|i
argument_list|)
expr_stmt|;
name|s_len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|monthtab
index|[
name|i
index|]
operator|.
name|name
operator|=
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|s_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|monthtab
index|[
name|i
index|]
operator|.
name|val
operator|=
name|i
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s_len
condition|;
name|j
operator|++
control|)
name|name
index|[
name|j
index|]
operator|=
name|fold_toupper
index|[
name|UCHAR
argument_list|(
name|s
index|[
name|j
index|]
argument_list|)
index|]
expr_stmt|;
name|name
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|qsort
argument_list|(
operator|(
name|void
operator|*
operator|)
name|monthtab
argument_list|,
name|MONTHS_PER_YEAR
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|month
argument_list|)
argument_list|,
name|struct_month_cmp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Specify the amount of main memory to use when sorting.  */
end_comment

begin_function
specifier|static
name|void
name|specify_sort_size
parameter_list|(
name|char
specifier|const
modifier|*
name|s
parameter_list|)
block|{
name|uintmax_t
name|n
decl_stmt|;
name|char
modifier|*
name|suffix
decl_stmt|;
name|enum
name|strtol_error
name|e
init|=
name|xstrtoumax
argument_list|(
name|s
argument_list|,
operator|&
name|suffix
argument_list|,
literal|10
argument_list|,
operator|&
name|n
argument_list|,
literal|"EgGkKmMPtTYZ"
argument_list|)
decl_stmt|;
comment|/* The default unit is KiB.  */
if|if
condition|(
name|e
operator|==
name|LONGINT_OK
operator|&&
name|ISDIGIT
argument_list|(
name|suffix
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|<=
name|UINTMAX_MAX
operator|/
literal|1024
condition|)
name|n
operator|*=
literal|1024
expr_stmt|;
else|else
name|e
operator|=
name|LONGINT_OVERFLOW
expr_stmt|;
block|}
comment|/* A 'b' suffix means bytes; a '%' suffix means percent of memory.  */
if|if
condition|(
name|e
operator|==
name|LONGINT_INVALID_SUFFIX_CHAR
operator|&&
name|ISDIGIT
argument_list|(
name|suffix
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|suffix
index|[
literal|1
index|]
condition|)
switch|switch
condition|(
name|suffix
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'b'
case|:
name|e
operator|=
name|LONGINT_OK
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
block|{
name|double
name|mem
init|=
name|physmem_total
argument_list|()
operator|*
name|n
operator|/
literal|100
decl_stmt|;
comment|/* Use "<", not "<=", to avoid problems with rounding.  */
if|if
condition|(
name|mem
operator|<
name|UINTMAX_MAX
condition|)
block|{
name|n
operator|=
name|mem
expr_stmt|;
name|e
operator|=
name|LONGINT_OK
expr_stmt|;
block|}
else|else
name|e
operator|=
name|LONGINT_OVERFLOW
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|e
operator|==
name|LONGINT_OK
condition|)
block|{
name|sort_size
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|sort_size
operator|==
name|n
condition|)
block|{
name|sort_size
operator|=
name|MAX
argument_list|(
name|sort_size
argument_list|,
name|MIN_SORT_SIZE
argument_list|)
expr_stmt|;
return|return;
block|}
name|e
operator|=
name|LONGINT_OVERFLOW
expr_stmt|;
block|}
name|STRTOL_FATAL_ERROR
argument_list|(
name|s
argument_list|,
name|_
argument_list|(
literal|"sort size"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the default sort size.  */
end_comment

begin_function
specifier|static
name|size_t
name|default_sort_size
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Let MEM be available memory or 1/8 of total memory, whichever      is greater.  */
name|double
name|avail
init|=
name|physmem_available
argument_list|()
decl_stmt|;
name|double
name|total
init|=
name|physmem_total
argument_list|()
decl_stmt|;
name|double
name|mem
init|=
name|MAX
argument_list|(
name|avail
argument_list|,
name|total
operator|/
literal|8
argument_list|)
decl_stmt|;
name|struct
name|rlimit
name|rlimit
decl_stmt|;
comment|/* Let SIZE be MEM, but no more than the maximum object size or      system resource limits.  Avoid the MIN macro here, as it is not      quite right when only one argument is floating point.  Don't      bother to check for values like RLIM_INFINITY since in practice      they are not much less than SIZE_MAX.  */
name|size_t
name|size
init|=
name|SIZE_MAX
decl_stmt|;
if|if
condition|(
name|mem
operator|<
name|size
condition|)
name|size
operator|=
name|mem
expr_stmt|;
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_DATA
argument_list|,
operator|&
name|rlimit
argument_list|)
operator|==
literal|0
operator|&&
name|rlimit
operator|.
name|rlim_cur
operator|<
name|size
condition|)
name|size
operator|=
name|rlimit
operator|.
name|rlim_cur
expr_stmt|;
ifdef|#
directive|ifdef
name|RLIMIT_AS
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_AS
argument_list|,
operator|&
name|rlimit
argument_list|)
operator|==
literal|0
operator|&&
name|rlimit
operator|.
name|rlim_cur
operator|<
name|size
condition|)
name|size
operator|=
name|rlimit
operator|.
name|rlim_cur
expr_stmt|;
endif|#
directive|endif
comment|/* Leave a large safety margin for the above limits, as failure can      occur when they are exceeded.  */
name|size
operator|/=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|RLIMIT_RSS
comment|/* Leave a 1/16 margin for RSS to leave room for code, stack, etc.      Exceeding RSS is not fatal, but can be quite slow.  */
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_RSS
argument_list|,
operator|&
name|rlimit
argument_list|)
operator|==
literal|0
operator|&&
name|rlimit
operator|.
name|rlim_cur
operator|/
literal|16
operator|*
literal|15
operator|<
name|size
condition|)
name|size
operator|=
name|rlimit
operator|.
name|rlim_cur
operator|/
literal|16
operator|*
literal|15
expr_stmt|;
endif|#
directive|endif
comment|/* Use no less than the minimum.  */
return|return
name|MAX
argument_list|(
name|size
argument_list|,
name|MIN_SORT_SIZE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the sort buffer size to use with the input files identified    by FPS and FILES, which are alternate paths to the same files.    NFILES gives the number of input files; NFPS may be less.  Assume    that each input line requires LINE_BYTES extra bytes' worth of line    information.  Return at most SIZE_BOUND.  */
end_comment

begin_function
specifier|static
name|size_t
name|sort_buffer_size
parameter_list|(
name|FILE
modifier|*
specifier|const
modifier|*
name|fps
parameter_list|,
name|int
name|nfps
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|files
parameter_list|,
name|int
name|nfiles
parameter_list|,
name|size_t
name|line_bytes
parameter_list|,
name|size_t
name|size_bound
parameter_list|)
block|{
comment|/* In the worst case, each input byte is a newline.  */
name|size_t
name|worst_case_per_input_byte
init|=
name|line_bytes
operator|+
literal|1
decl_stmt|;
comment|/* Keep enough room for one extra input line and an extra byte.      This extra room might be needed when preparing to read EOF.  */
name|size_t
name|size
init|=
name|worst_case_per_input_byte
operator|+
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|off_t
name|file_size
decl_stmt|;
name|size_t
name|worst_case
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|<
name|nfps
condition|?
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fps
index|[
name|i
index|]
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
else|:
name|strcmp
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|?
name|fstat
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|st
argument_list|)
else|:
name|stat
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
operator|&
name|st
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"stat failed"
argument_list|)
argument_list|,
name|files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|file_size
operator|=
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|?
name|st
operator|.
name|st_size
else|:
name|INPUT_FILE_SIZE_GUESS
expr_stmt|;
comment|/* Add the amount of memory needed to represent the worst case 	 where the input consists entirely of newlines followed by a 	 single non-newline.  Check for overflow.  */
name|worst_case
operator|=
name|file_size
operator|*
name|worst_case_per_input_byte
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|file_size
operator|!=
name|worst_case
operator|/
name|worst_case_per_input_byte
operator|||
name|size_bound
operator|-
name|size
operator|<=
name|worst_case
condition|)
return|return
name|size_bound
return|;
name|size
operator|+=
name|worst_case
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Initialize BUF.  Reserve LINE_BYTES bytes for each line; LINE_BYTES    must be at least sizeof (struct line).  Allocate ALLOC bytes    initially.  */
end_comment

begin_function
specifier|static
name|void
name|initbuf
parameter_list|(
name|struct
name|buffer
modifier|*
name|buf
parameter_list|,
name|size_t
name|line_bytes
parameter_list|,
name|size_t
name|alloc
parameter_list|)
block|{
comment|/* Ensure that the line array is properly aligned.  If the desired      size cannot be allocated, repeatedly halve it until allocation      succeeds.  The smaller allocation may hurt overall performance,      but that's better than failing.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|alloc
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
operator|-
name|alloc
operator|%
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
expr_stmt|;
name|buf
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|buf
condition|)
break|break;
name|alloc
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|alloc
operator|<=
name|line_bytes
operator|+
literal|1
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
block|}
name|buf
operator|->
name|line_bytes
operator|=
name|line_bytes
expr_stmt|;
name|buf
operator|->
name|alloc
operator|=
name|alloc
expr_stmt|;
name|buf
operator|->
name|used
operator|=
name|buf
operator|->
name|left
operator|=
name|buf
operator|->
name|nlines
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|eof
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return one past the limit of the line array.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|line
modifier|*
name|buffer_linelim
parameter_list|(
name|struct
name|buffer
specifier|const
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|(
expr|struct
name|line
operator|*
operator|)
operator|(
name|buf
operator|->
name|buf
operator|+
name|buf
operator|->
name|alloc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the first character of the field specified    by KEY in LINE. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|begfield
parameter_list|(
specifier|const
name|struct
name|line
modifier|*
name|line
parameter_list|,
specifier|const
name|struct
name|keyfield
modifier|*
name|key
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|ptr
init|=
name|line
operator|->
name|text
decl_stmt|,
modifier|*
name|lim
init|=
name|ptr
operator|+
name|line
operator|->
name|length
operator|-
literal|1
decl_stmt|;
specifier|register
name|size_t
name|sword
init|=
name|key
operator|->
name|sword
decl_stmt|;
specifier|register
name|size_t
name|schar
init|=
name|key
operator|->
name|schar
decl_stmt|;
if|if
condition|(
name|tab
condition|)
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|sword
operator|--
condition|)
block|{
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
operator|*
name|ptr
operator|!=
name|tab
condition|)
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
name|ptr
operator|<
name|lim
condition|)
operator|++
name|ptr
expr_stmt|;
block|}
else|else
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|sword
operator|--
condition|)
block|{
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|ptr
argument_list|)
index|]
condition|)
operator|++
name|ptr
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
operator|!
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|ptr
argument_list|)
index|]
condition|)
operator|++
name|ptr
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|->
name|skipsblanks
condition|)
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|ptr
argument_list|)
index|]
condition|)
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
name|schar
operator|<
name|lim
operator|-
name|ptr
condition|)
name|ptr
operator|+=
name|schar
expr_stmt|;
else|else
name|ptr
operator|=
name|lim
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Return the limit of (a pointer to the first character after) the field    in LINE specified by KEY. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|limfield
parameter_list|(
specifier|const
name|struct
name|line
modifier|*
name|line
parameter_list|,
specifier|const
name|struct
name|keyfield
modifier|*
name|key
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|ptr
init|=
name|line
operator|->
name|text
decl_stmt|,
modifier|*
name|lim
init|=
name|ptr
operator|+
name|line
operator|->
name|length
operator|-
literal|1
decl_stmt|;
specifier|register
name|size_t
name|eword
init|=
name|key
operator|->
name|eword
decl_stmt|,
name|echar
init|=
name|key
operator|->
name|echar
decl_stmt|;
comment|/* Note: from the POSIX spec:      The leading field separator itself is included in      a field when -t is not used.  FIXME: move this comment up... */
comment|/* Move PTR past EWORD fields or to one past the last byte on LINE,      whichever comes first.  If there are more than EWORD fields, leave      PTR pointing at the beginning of the field having zero-based index,      EWORD.  If a delimiter character was specified (via -t), then that      `beginning' is the first character following the delimiting TAB.      Otherwise, leave PTR pointing at the first `blank' character after      the preceding field.  */
if|if
condition|(
name|tab
condition|)
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|eword
operator|--
condition|)
block|{
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
operator|*
name|ptr
operator|!=
name|tab
condition|)
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
name|ptr
operator|<
name|lim
operator|&&
operator|(
name|eword
operator||
name|echar
operator|)
condition|)
operator|++
name|ptr
expr_stmt|;
block|}
else|else
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|eword
operator|--
condition|)
block|{
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|ptr
argument_list|)
index|]
condition|)
operator|++
name|ptr
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
operator|!
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|ptr
argument_list|)
index|]
condition|)
operator|++
name|ptr
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|POSIX_UNSPECIFIED
comment|/* The following block of code makes GNU sort incompatible with      standard Unix sort, so it's ifdef'd out for now.      The POSIX spec isn't clear on how to interpret this.      FIXME: request clarification.       From: kwzh@gnu.ai.mit.edu (Karl Heuer)      Date: Thu, 30 May 96 12:20:41 -0400      [Translated to POSIX 1003.1-2001 terminology by Paul Eggert.]       [...]I believe I've found another bug in `sort'.       $ cat /tmp/sort.in      a b c 2 d      pq rs 1 t      $ textutils-1.15/src/sort -k1.7,1.7</tmp/sort.in      a b c 2 d      pq rs 1 t      $ /bin/sort -k1.7,1.7</tmp/sort.in      pq rs 1 t      a b c 2 d       Unix sort produced the answer I expected: sort on the single character      in column 7.  GNU sort produced different results, because it disagrees      on the interpretation of the key-end spec "M.N".  Unix sort reads this      as "skip M-1 fields, then N-1 characters"; but GNU sort wants it to mean      "skip M-1 fields, then either N-1 characters or the rest of the current      field, whichever comes first".  This extra clause applies only to      key-ends, not key-starts.      */
comment|/* Make LIM point to the end of (one byte past) the current field.  */
if|if
condition|(
name|tab
condition|)
block|{
name|char
modifier|*
name|newlim
decl_stmt|;
name|newlim
operator|=
name|memchr
argument_list|(
name|ptr
argument_list|,
name|tab
argument_list|,
name|lim
operator|-
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlim
condition|)
name|lim
operator|=
name|newlim
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|newlim
decl_stmt|;
name|newlim
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
name|newlim
operator|<
name|lim
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|newlim
argument_list|)
index|]
condition|)
operator|++
name|newlim
expr_stmt|;
while|while
condition|(
name|newlim
operator|<
name|lim
operator|&&
operator|!
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|newlim
argument_list|)
index|]
condition|)
operator|++
name|newlim
expr_stmt|;
name|lim
operator|=
name|newlim
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If we're skipping leading blanks, don't start counting characters      until after skipping past any leading blanks.  */
if|if
condition|(
name|key
operator|->
name|skipsblanks
condition|)
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|ptr
argument_list|)
index|]
condition|)
operator|++
name|ptr
expr_stmt|;
comment|/* Advance PTR by ECHAR (if possible), but no further than LIM.  */
if|if
condition|(
name|echar
operator|<
name|lim
operator|-
name|ptr
condition|)
name|ptr
operator|+=
name|echar
expr_stmt|;
else|else
name|ptr
operator|=
name|lim
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* FIXME */
end_comment

begin_function
specifier|static
name|void
name|trim_trailing_blanks
parameter_list|(
specifier|const
name|char
modifier|*
name|a_start
parameter_list|,
name|char
modifier|*
modifier|*
name|a_end
parameter_list|)
block|{
while|while
condition|(
operator|*
name|a_end
operator|>
name|a_start
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
operator|(
operator|*
name|a_end
operator|-
literal|1
operator|)
argument_list|)
index|]
condition|)
operator|--
operator|(
operator|*
name|a_end
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill BUF reading from FP, moving buf->left bytes from the end    of buf->buf to the beginning first.  If EOF is reached and the    file wasn't terminated by a newline, supply one.  Set up BUF's line    table too.  FILE is the name of the file corresponding to FP.    Return nonzero if some input was read.  */
end_comment

begin_function
specifier|static
name|int
name|fillbuf
parameter_list|(
name|struct
name|buffer
modifier|*
name|buf
parameter_list|,
specifier|register
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
specifier|const
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|keyfield
specifier|const
modifier|*
name|key
init|=
name|keylist
decl_stmt|;
name|char
name|eol
init|=
name|eolchar
decl_stmt|;
name|size_t
name|line_bytes
init|=
name|buf
operator|->
name|line_bytes
decl_stmt|;
name|size_t
name|mergesize
init|=
name|merge_buffer_size
operator|-
name|MIN_MERGE_BUFFER_SIZE
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|eof
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|buf
operator|->
name|used
operator|!=
name|buf
operator|->
name|left
condition|)
block|{
name|memmove
argument_list|(
name|buf
operator|->
name|buf
argument_list|,
name|buf
operator|->
name|buf
operator|+
name|buf
operator|->
name|used
operator|-
name|buf
operator|->
name|left
argument_list|,
name|buf
operator|->
name|left
argument_list|)
expr_stmt|;
name|buf
operator|->
name|used
operator|=
name|buf
operator|->
name|left
expr_stmt|;
name|buf
operator|->
name|nlines
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|ptr
init|=
name|buf
operator|->
name|buf
operator|+
name|buf
operator|->
name|used
decl_stmt|;
name|struct
name|line
modifier|*
name|linelim
init|=
name|buffer_linelim
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|struct
name|line
modifier|*
name|line
init|=
name|linelim
operator|-
name|buf
operator|->
name|nlines
decl_stmt|;
name|size_t
name|avail
init|=
operator|(
name|char
operator|*
operator|)
name|linelim
operator|-
name|buf
operator|->
name|nlines
operator|*
name|line_bytes
operator|-
name|ptr
decl_stmt|;
name|char
modifier|*
name|line_start
init|=
name|buf
operator|->
name|nlines
condition|?
name|line
operator|->
name|text
operator|+
name|line
operator|->
name|length
else|:
name|buf
operator|->
name|buf
decl_stmt|;
while|while
condition|(
name|line_bytes
operator|+
literal|1
operator|<
name|avail
condition|)
block|{
comment|/* Read as many bytes as possible, but do not read so many 	     bytes that there might not be enough room for the 	     corresponding line array.  The worst case is when the 	     rest of the input file consists entirely of newlines, 	     except that the last byte is not a newline.  */
name|size_t
name|readsize
init|=
operator|(
name|avail
operator|-
literal|1
operator|)
operator|/
operator|(
name|line_bytes
operator|+
literal|1
operator|)
decl_stmt|;
name|size_t
name|bytes_read
init|=
name|fread
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|,
name|readsize
argument_list|,
name|fp
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ptrlim
init|=
name|ptr
operator|+
name|bytes_read
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|avail
operator|-=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|!=
name|readsize
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"read failed"
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|buf
operator|->
name|eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|buf
operator|==
name|ptrlim
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ptrlim
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|)
operator|*
name|ptrlim
operator|++
operator|=
name|eol
expr_stmt|;
block|}
block|}
comment|/* Find and record each line in the just-read input.  */
while|while
condition|(
operator|(
name|p
operator|=
name|memchr
argument_list|(
name|ptr
argument_list|,
name|eol
argument_list|,
name|ptrlim
operator|-
name|ptr
argument_list|)
operator|)
condition|)
block|{
name|ptr
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|line
operator|--
expr_stmt|;
name|line
operator|->
name|text
operator|=
name|line_start
expr_stmt|;
name|line
operator|->
name|length
operator|=
name|ptr
operator|-
name|line_start
expr_stmt|;
name|mergesize
operator|=
name|MAX
argument_list|(
name|mergesize
argument_list|,
name|line
operator|->
name|length
argument_list|)
expr_stmt|;
name|avail
operator|-=
name|line_bytes
expr_stmt|;
if|if
condition|(
name|key
condition|)
block|{
comment|/* Precompute the position of the first key for                      efficiency. */
name|line
operator|->
name|keylim
operator|=
name|key
operator|->
name|eword
operator|==
operator|-
literal|1
condition|?
name|p
else|:
name|limfield
argument_list|(
name|line
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|sword
operator|!=
operator|-
literal|1
condition|)
name|line
operator|->
name|keybeg
operator|=
name|begfield
argument_list|(
name|line
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|key
operator|->
name|skipsblanks
condition|)
while|while
condition|(
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|line_start
argument_list|)
index|]
condition|)
name|line_start
operator|++
expr_stmt|;
name|line
operator|->
name|keybeg
operator|=
name|line_start
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|->
name|skipeblanks
condition|)
name|trim_trailing_blanks
argument_list|(
name|line
operator|->
name|keybeg
argument_list|,
operator|&
name|line
operator|->
name|keylim
argument_list|)
expr_stmt|;
block|}
name|line_start
operator|=
name|ptr
expr_stmt|;
block|}
name|ptr
operator|=
name|ptrlim
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|eof
condition|)
break|break;
block|}
name|buf
operator|->
name|used
operator|=
name|ptr
operator|-
name|buf
operator|->
name|buf
expr_stmt|;
name|buf
operator|->
name|nlines
operator|=
name|buffer_linelim
argument_list|(
name|buf
argument_list|)
operator|-
name|line
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|nlines
operator|!=
literal|0
condition|)
block|{
name|buf
operator|->
name|left
operator|=
name|ptr
operator|-
name|line_start
expr_stmt|;
name|merge_buffer_size
operator|=
name|mergesize
operator|+
name|MIN_MERGE_BUFFER_SIZE
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* The current input line is too long to fit in the buffer. 	 Double the buffer size and try again.  */
if|if
condition|(
literal|2
operator|*
name|buf
operator|->
name|alloc
operator|<
name|buf
operator|->
name|alloc
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
name|buf
operator|->
name|alloc
operator|*=
literal|2
expr_stmt|;
name|buf
operator|->
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
operator|->
name|buf
argument_list|,
name|buf
operator|->
name|alloc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compare strings A and B containing decimal fractions< 1.  Each string    should begin with a decimal point followed immediately by the digits    of the fraction.  Strings not of this form are considered to be zero. */
end_comment

begin_comment
comment|/* The goal here, is to take two numbers a and b... compare these    in parallel.  Instead of converting each, and then comparing the    outcome.  Most likely stopping the comparison before the conversion    is complete.  The algorithm used, in the old sort:     Algorithm: fraccompare    Action   : compare two decimal fractions    accepts  : char *a, char *b    returns  : -1 if a<b, 0 if a=b, 1 if a>b.    implement:     if *a == decimal_point AND *b == decimal_point      find first character different in a and b.      if both are digits, return the difference *a - *b.      if *a is a digit        skip past zeros        if digit return 1, else 0      if *b is a digit        skip past zeros        if digit return -1, else 0    if *a is a decimal_point      skip past decimal_point and zeros      if digit return 1, else 0    if *b is a decimal_point      skip past decimal_point and zeros      if digit return -1, else 0    return 0 */
end_comment

begin_function
specifier|static
name|int
name|fraccompare
parameter_list|(
specifier|register
specifier|const
name|char
modifier|*
name|a
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|*
name|a
operator|==
name|decimal_point
operator|&&
operator|*
name|b
operator|==
name|decimal_point
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|a
operator|==
operator|*
operator|++
name|b
condition|)
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|a
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|a
argument_list|)
operator|&&
name|ISDIGIT
argument_list|(
operator|*
name|b
argument_list|)
condition|)
return|return
operator|*
name|a
operator|-
operator|*
name|b
return|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|a
argument_list|)
condition|)
goto|goto
name|a_trailing_nonzero
goto|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|b
argument_list|)
condition|)
goto|goto
name|b_trailing_nonzero
goto|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|a
operator|++
operator|==
name|decimal_point
condition|)
block|{
name|a_trailing_nonzero
label|:
while|while
condition|(
operator|*
name|a
operator|==
name|NUMERIC_ZERO
condition|)
name|a
operator|++
expr_stmt|;
return|return
name|ISDIGIT
argument_list|(
operator|*
name|a
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|b
operator|++
operator|==
name|decimal_point
condition|)
block|{
name|b_trailing_nonzero
label|:
while|while
condition|(
operator|*
name|b
operator|==
name|NUMERIC_ZERO
condition|)
name|b
operator|++
expr_stmt|;
return|return
operator|-
name|ISDIGIT
argument_list|(
operator|*
name|b
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compare strings A and B as numbers without explicitly converting them to    machine numbers.  Comparatively slow for short strings, but asymptotically    hideously fast. */
end_comment

begin_function
specifier|static
name|int
name|numcompare
parameter_list|(
specifier|register
specifier|const
name|char
modifier|*
name|a
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|b
parameter_list|)
block|{
specifier|register
name|int
name|tmpa
decl_stmt|,
name|tmpb
decl_stmt|,
name|tmp
decl_stmt|;
specifier|register
name|size_t
name|loga
decl_stmt|,
name|logb
decl_stmt|;
name|tmpa
operator|=
operator|*
name|a
expr_stmt|;
name|tmpb
operator|=
operator|*
name|b
expr_stmt|;
while|while
condition|(
name|blanks
index|[
name|UCHAR
argument_list|(
name|tmpa
argument_list|)
index|]
condition|)
name|tmpa
operator|=
operator|*
operator|++
name|a
expr_stmt|;
while|while
condition|(
name|blanks
index|[
name|UCHAR
argument_list|(
name|tmpb
argument_list|)
index|]
condition|)
name|tmpb
operator|=
operator|*
operator|++
name|b
expr_stmt|;
if|if
condition|(
name|tmpa
operator|==
name|NEGATION_SIGN
condition|)
block|{
do|do
name|tmpa
operator|=
operator|*
operator|++
name|a
expr_stmt|;
do|while
condition|(
name|tmpa
operator|==
name|NUMERIC_ZERO
operator|||
name|IS_THOUSANDS_SEP
argument_list|(
name|tmpa
argument_list|)
condition|)
do|;
if|if
condition|(
name|tmpb
operator|!=
name|NEGATION_SIGN
condition|)
block|{
if|if
condition|(
name|tmpa
operator|==
name|decimal_point
condition|)
do|do
name|tmpa
operator|=
operator|*
operator|++
name|a
expr_stmt|;
do|while
condition|(
name|tmpa
operator|==
name|NUMERIC_ZERO
condition|)
do|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|tmpa
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|tmpb
operator|==
name|NUMERIC_ZERO
operator|||
name|IS_THOUSANDS_SEP
argument_list|(
name|tmpb
argument_list|)
condition|)
name|tmpb
operator|=
operator|*
operator|++
name|b
expr_stmt|;
if|if
condition|(
name|tmpb
operator|==
name|decimal_point
condition|)
do|do
name|tmpb
operator|=
operator|*
operator|++
name|b
expr_stmt|;
do|while
condition|(
name|tmpb
operator|==
name|NUMERIC_ZERO
condition|)
do|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|tmpb
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
do|do
name|tmpb
operator|=
operator|*
operator|++
name|b
expr_stmt|;
do|while
condition|(
name|tmpb
operator|==
name|NUMERIC_ZERO
operator|||
name|IS_THOUSANDS_SEP
argument_list|(
name|tmpb
argument_list|)
condition|)
do|;
while|while
condition|(
name|tmpa
operator|==
name|tmpb
operator|&&
name|ISDIGIT
argument_list|(
name|tmpa
argument_list|)
condition|)
block|{
do|do
name|tmpa
operator|=
operator|*
operator|++
name|a
expr_stmt|;
do|while
condition|(
name|IS_THOUSANDS_SEP
argument_list|(
name|tmpa
argument_list|)
condition|)
do|;
do|do
name|tmpb
operator|=
operator|*
operator|++
name|b
expr_stmt|;
do|while
condition|(
name|IS_THOUSANDS_SEP
argument_list|(
name|tmpb
argument_list|)
condition|)
do|;
block|}
if|if
condition|(
operator|(
name|tmpa
operator|==
name|decimal_point
operator|&&
operator|!
name|ISDIGIT
argument_list|(
name|tmpb
argument_list|)
operator|)
operator|||
operator|(
name|tmpb
operator|==
name|decimal_point
operator|&&
operator|!
name|ISDIGIT
argument_list|(
name|tmpa
argument_list|)
operator|)
condition|)
return|return
operator|-
name|fraccompare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
name|tmp
operator|=
name|tmpb
operator|-
name|tmpa
expr_stmt|;
for|for
control|(
name|loga
operator|=
literal|0
init|;
name|ISDIGIT
argument_list|(
name|tmpa
argument_list|)
condition|;
operator|++
name|loga
control|)
do|do
name|tmpa
operator|=
operator|*
operator|++
name|a
expr_stmt|;
do|while
condition|(
name|IS_THOUSANDS_SEP
argument_list|(
name|tmpa
argument_list|)
condition|)
do|;
for|for
control|(
name|logb
operator|=
literal|0
init|;
name|ISDIGIT
argument_list|(
name|tmpb
argument_list|)
condition|;
operator|++
name|logb
control|)
do|do
name|tmpb
operator|=
operator|*
operator|++
name|b
expr_stmt|;
do|while
condition|(
name|IS_THOUSANDS_SEP
argument_list|(
name|tmpb
argument_list|)
condition|)
do|;
if|if
condition|(
name|loga
operator|!=
name|logb
condition|)
return|return
name|loga
operator|<
name|logb
condition|?
literal|1
else|:
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|loga
condition|)
return|return
literal|0
return|;
return|return
name|tmp
return|;
block|}
elseif|else
if|if
condition|(
name|tmpb
operator|==
name|NEGATION_SIGN
condition|)
block|{
do|do
name|tmpb
operator|=
operator|*
operator|++
name|b
expr_stmt|;
do|while
condition|(
name|tmpb
operator|==
name|NUMERIC_ZERO
operator|||
name|IS_THOUSANDS_SEP
argument_list|(
name|tmpb
argument_list|)
condition|)
do|;
if|if
condition|(
name|tmpb
operator|==
name|decimal_point
condition|)
do|do
name|tmpb
operator|=
operator|*
operator|++
name|b
expr_stmt|;
do|while
condition|(
name|tmpb
operator|==
name|NUMERIC_ZERO
condition|)
do|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|tmpb
argument_list|)
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|tmpa
operator|==
name|NUMERIC_ZERO
operator|||
name|IS_THOUSANDS_SEP
argument_list|(
name|tmpa
argument_list|)
condition|)
name|tmpa
operator|=
operator|*
operator|++
name|a
expr_stmt|;
if|if
condition|(
name|tmpa
operator|==
name|decimal_point
condition|)
do|do
name|tmpa
operator|=
operator|*
operator|++
name|a
expr_stmt|;
do|while
condition|(
name|tmpa
operator|==
name|NUMERIC_ZERO
condition|)
do|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|tmpa
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
else|else
block|{
while|while
condition|(
name|tmpa
operator|==
name|NUMERIC_ZERO
operator|||
name|IS_THOUSANDS_SEP
argument_list|(
name|tmpa
argument_list|)
condition|)
name|tmpa
operator|=
operator|*
operator|++
name|a
expr_stmt|;
while|while
condition|(
name|tmpb
operator|==
name|NUMERIC_ZERO
operator|||
name|IS_THOUSANDS_SEP
argument_list|(
name|tmpb
argument_list|)
condition|)
name|tmpb
operator|=
operator|*
operator|++
name|b
expr_stmt|;
while|while
condition|(
name|tmpa
operator|==
name|tmpb
operator|&&
name|ISDIGIT
argument_list|(
name|tmpa
argument_list|)
condition|)
block|{
do|do
name|tmpa
operator|=
operator|*
operator|++
name|a
expr_stmt|;
do|while
condition|(
name|IS_THOUSANDS_SEP
argument_list|(
name|tmpa
argument_list|)
condition|)
do|;
do|do
name|tmpb
operator|=
operator|*
operator|++
name|b
expr_stmt|;
do|while
condition|(
name|IS_THOUSANDS_SEP
argument_list|(
name|tmpb
argument_list|)
condition|)
do|;
block|}
if|if
condition|(
operator|(
name|tmpa
operator|==
name|decimal_point
operator|&&
operator|!
name|ISDIGIT
argument_list|(
name|tmpb
argument_list|)
operator|)
operator|||
operator|(
name|tmpb
operator|==
name|decimal_point
operator|&&
operator|!
name|ISDIGIT
argument_list|(
name|tmpa
argument_list|)
operator|)
condition|)
return|return
name|fraccompare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
name|tmp
operator|=
name|tmpa
operator|-
name|tmpb
expr_stmt|;
for|for
control|(
name|loga
operator|=
literal|0
init|;
name|ISDIGIT
argument_list|(
name|tmpa
argument_list|)
condition|;
operator|++
name|loga
control|)
do|do
name|tmpa
operator|=
operator|*
operator|++
name|a
expr_stmt|;
do|while
condition|(
name|IS_THOUSANDS_SEP
argument_list|(
name|tmpa
argument_list|)
condition|)
do|;
for|for
control|(
name|logb
operator|=
literal|0
init|;
name|ISDIGIT
argument_list|(
name|tmpb
argument_list|)
condition|;
operator|++
name|logb
control|)
do|do
name|tmpb
operator|=
operator|*
operator|++
name|b
expr_stmt|;
do|while
condition|(
name|IS_THOUSANDS_SEP
argument_list|(
name|tmpb
argument_list|)
condition|)
do|;
if|if
condition|(
name|loga
operator|!=
name|logb
condition|)
return|return
name|loga
operator|<
name|logb
condition|?
operator|-
literal|1
else|:
literal|1
return|;
if|if
condition|(
operator|!
name|loga
condition|)
return|return
literal|0
return|;
return|return
name|tmp
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|general_numcompare
parameter_list|(
specifier|const
name|char
modifier|*
name|sa
parameter_list|,
specifier|const
name|char
modifier|*
name|sb
parameter_list|)
block|{
comment|/* FIXME: add option to warn about failed conversions.  */
comment|/* FIXME: maybe add option to try expensive FP conversion      only if A and B can't be compared more cheaply/accurately.  */
name|char
modifier|*
name|ea
decl_stmt|;
name|char
modifier|*
name|eb
decl_stmt|;
name|double
name|a
init|=
name|strtod
argument_list|(
name|sa
argument_list|,
operator|&
name|ea
argument_list|)
decl_stmt|;
name|double
name|b
init|=
name|strtod
argument_list|(
name|sb
argument_list|,
operator|&
name|eb
argument_list|)
decl_stmt|;
comment|/* Put conversion errors at the start of the collating sequence.  */
if|if
condition|(
name|sa
operator|==
name|ea
condition|)
return|return
name|sb
operator|==
name|eb
condition|?
literal|0
else|:
operator|-
literal|1
return|;
if|if
condition|(
name|sb
operator|==
name|eb
condition|)
return|return
literal|1
return|;
comment|/* Sort numbers in the usual way, where -0 == +0.  Put NaNs after      conversion errors but before numbers; sort them by internal      bit-pattern, for lack of a more portable alternative.  */
return|return
operator|(
name|a
operator|<
name|b
condition|?
operator|-
literal|1
else|:
name|a
operator|>
name|b
condition|?
literal|1
else|:
name|a
operator|==
name|b
condition|?
literal|0
else|:
name|b
operator|==
name|b
condition|?
operator|-
literal|1
else|:
name|a
operator|==
name|a
condition|?
literal|1
else|:
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|a
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|b
argument_list|,
sizeof|sizeof
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return an integer in 1..12 of the month name S with length LEN.    Return 0 if the name in S is not recognized.  */
end_comment

begin_function
specifier|static
name|int
name|getmonth
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|month
decl_stmt|;
specifier|register
name|size_t
name|i
decl_stmt|;
specifier|register
name|int
name|lo
init|=
literal|0
decl_stmt|,
name|hi
init|=
name|MONTHS_PER_YEAR
decl_stmt|,
name|result
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|s
argument_list|)
index|]
condition|)
block|{
operator|++
name|s
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|month
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|month
index|[
name|i
index|]
operator|=
name|fold_toupper
index|[
name|UCHAR
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|blanks
index|[
name|UCHAR
argument_list|(
name|month
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
index|]
condition|)
operator|--
name|i
expr_stmt|;
name|month
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
name|int
name|ix
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|month
argument_list|,
name|monthtab
index|[
name|ix
index|]
operator|.
name|name
argument_list|,
name|strlen
argument_list|(
name|monthtab
index|[
name|ix
index|]
operator|.
name|name
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|hi
operator|=
name|ix
expr_stmt|;
else|else
name|lo
operator|=
name|ix
expr_stmt|;
block|}
do|while
condition|(
name|hi
operator|-
name|lo
operator|>
literal|1
condition|)
do|;
name|result
operator|=
operator|(
operator|!
name|strncmp
argument_list|(
name|month
argument_list|,
name|monthtab
index|[
name|lo
index|]
operator|.
name|name
argument_list|,
name|strlen
argument_list|(
name|monthtab
index|[
name|lo
index|]
operator|.
name|name
argument_list|)
argument_list|)
condition|?
name|monthtab
index|[
name|lo
index|]
operator|.
name|val
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Compare two lines A and B trying every key in sequence until there    are no more keys or a difference is found. */
end_comment

begin_function
specifier|static
name|int
name|keycompare
parameter_list|(
specifier|const
name|struct
name|line
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|line
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|keyfield
modifier|*
name|key
init|=
name|keylist
decl_stmt|;
comment|/* For the first iteration only, the key positions have been      precomputed for us. */
specifier|register
name|char
modifier|*
name|texta
init|=
name|a
operator|->
name|keybeg
decl_stmt|;
specifier|register
name|char
modifier|*
name|textb
init|=
name|b
operator|->
name|keybeg
decl_stmt|;
specifier|register
name|char
modifier|*
name|lima
init|=
name|a
operator|->
name|keylim
decl_stmt|;
specifier|register
name|char
modifier|*
name|limb
init|=
name|b
operator|->
name|keylim
decl_stmt|;
name|int
name|diff
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|translate
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|key
operator|->
name|translate
decl_stmt|;
specifier|register
name|int
modifier|*
name|ignore
init|=
name|key
operator|->
name|ignore
decl_stmt|;
comment|/* Find the lengths. */
name|size_t
name|lena
init|=
name|lima
operator|<=
name|texta
condition|?
literal|0
else|:
name|lima
operator|-
name|texta
decl_stmt|;
name|size_t
name|lenb
init|=
name|limb
operator|<=
name|textb
condition|?
literal|0
else|:
name|limb
operator|-
name|textb
decl_stmt|;
if|if
condition|(
name|key
operator|->
name|skipeblanks
condition|)
block|{
name|char
modifier|*
name|a_end
init|=
name|texta
operator|+
name|lena
decl_stmt|;
name|char
modifier|*
name|b_end
init|=
name|textb
operator|+
name|lenb
decl_stmt|;
name|trim_trailing_blanks
argument_list|(
name|texta
argument_list|,
operator|&
name|a_end
argument_list|)
expr_stmt|;
name|trim_trailing_blanks
argument_list|(
name|textb
argument_list|,
operator|&
name|b_end
argument_list|)
expr_stmt|;
name|lena
operator|=
name|a_end
operator|-
name|texta
expr_stmt|;
name|lenb
operator|=
name|b_end
operator|-
name|textb
expr_stmt|;
block|}
comment|/* Actually compare the fields. */
if|if
condition|(
name|key
operator|->
name|numeric
operator||
name|key
operator|->
name|general_numeric
condition|)
block|{
name|char
name|savea
init|=
operator|*
name|lima
decl_stmt|,
name|saveb
init|=
operator|*
name|limb
decl_stmt|;
operator|*
name|lima
operator|=
operator|*
name|limb
operator|=
literal|'\0'
expr_stmt|;
name|diff
operator|=
operator|(
operator|(
name|key
operator|->
name|numeric
condition|?
name|numcompare
else|:
name|general_numcompare
operator|)
operator|(
name|texta
operator|,
name|textb
operator|)
operator|)
expr_stmt|;
operator|*
name|lima
operator|=
name|savea
operator|,
operator|*
name|limb
operator|=
name|saveb
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|->
name|month
condition|)
name|diff
operator|=
name|getmonth
argument_list|(
name|texta
argument_list|,
name|lena
argument_list|)
operator|-
name|getmonth
argument_list|(
name|textb
argument_list|,
name|lenb
argument_list|)
expr_stmt|;
comment|/* Sorting like this may become slow, so in a simple locale the user          can select a faster sort that is similar to ascii sort  */
elseif|else
if|if
condition|(
name|HAVE_SETLOCALE
operator|&&
name|hard_LC_COLLATE
condition|)
block|{
if|if
condition|(
name|ignore
operator|||
name|translate
condition|)
block|{
name|char
modifier|*
name|copy_a
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|lena
operator|+
literal|1
operator|+
name|lenb
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|copy_b
init|=
name|copy_a
operator|+
name|lena
operator|+
literal|1
decl_stmt|;
name|size_t
name|new_len_a
decl_stmt|,
name|new_len_b
decl_stmt|,
name|i
decl_stmt|;
comment|/* Ignore and/or translate chars before comparing.  */
for|for
control|(
name|new_len_a
operator|=
name|new_len_b
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
argument_list|(
name|lena
argument_list|,
name|lenb
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|lena
condition|)
block|{
name|copy_a
index|[
name|new_len_a
index|]
operator|=
operator|(
name|translate
condition|?
name|translate
index|[
name|UCHAR
argument_list|(
name|texta
index|[
name|i
index|]
argument_list|)
index|]
else|:
name|texta
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ignore
operator|||
operator|!
name|ignore
index|[
name|UCHAR
argument_list|(
name|texta
index|[
name|i
index|]
argument_list|)
index|]
condition|)
operator|++
name|new_len_a
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|lenb
condition|)
block|{
name|copy_b
index|[
name|new_len_b
index|]
operator|=
operator|(
name|translate
condition|?
name|translate
index|[
name|UCHAR
argument_list|(
name|textb
index|[
name|i
index|]
argument_list|)
index|]
else|:
name|textb
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ignore
operator|||
operator|!
name|ignore
index|[
name|UCHAR
argument_list|(
name|textb
index|[
name|i
index|]
argument_list|)
index|]
condition|)
operator|++
name|new_len_b
expr_stmt|;
block|}
block|}
name|diff
operator|=
name|xmemcoll
argument_list|(
name|copy_a
argument_list|,
name|new_len_a
argument_list|,
name|copy_b
argument_list|,
name|new_len_b
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lena
operator|==
literal|0
condition|)
name|diff
operator|=
operator|-
name|NONZERO
argument_list|(
name|lenb
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lenb
operator|==
literal|0
condition|)
goto|goto
name|greater
goto|;
else|else
name|diff
operator|=
name|xmemcoll
argument_list|(
name|texta
argument_list|,
name|lena
argument_list|,
name|textb
argument_list|,
name|lenb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ignore
condition|)
block|{
define|#
directive|define
name|CMP_WITH_IGNORE
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
define|\
value|do									\     {									\ 	  for (;;)							\ 	    {								\ 	      while (texta< lima&& ignore[UCHAR (*texta)])		\ 		++texta;						\ 	      while (textb< limb&& ignore[UCHAR (*textb)])		\ 		++textb;						\ 	      if (! (texta< lima&& textb< limb))			\ 		break;							\ 	      diff = UCHAR (A) - UCHAR (B);				\ 	      if (diff)							\ 		goto not_equal;						\ 	      ++texta;							\ 	      ++textb;							\ 	    }								\ 									\ 	  diff = (texta< lima) - (textb< limb);			\     }									\   while (0)
if|if
condition|(
name|translate
condition|)
name|CMP_WITH_IGNORE
argument_list|(
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
name|texta
argument_list|)
index|]
argument_list|,
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
name|textb
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|CMP_WITH_IGNORE
argument_list|(
name|UCHAR
argument_list|(
operator|*
name|texta
argument_list|)
argument_list|,
name|UCHAR
argument_list|(
operator|*
name|textb
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lena
operator|==
literal|0
condition|)
name|diff
operator|=
operator|-
name|NONZERO
argument_list|(
name|lenb
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lenb
operator|==
literal|0
condition|)
goto|goto
name|greater
goto|;
else|else
block|{
if|if
condition|(
name|translate
condition|)
block|{
while|while
condition|(
name|texta
operator|<
name|lima
operator|&&
name|textb
operator|<
name|limb
condition|)
block|{
name|diff
operator|=
operator|(
name|UCHAR
argument_list|(
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
name|texta
operator|++
argument_list|)
index|]
argument_list|)
operator|-
name|UCHAR
argument_list|(
name|translate
index|[
name|UCHAR
argument_list|(
operator|*
name|textb
operator|++
argument_list|)
index|]
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|diff
condition|)
goto|goto
name|not_equal
goto|;
block|}
block|}
else|else
block|{
name|diff
operator|=
name|memcmp
argument_list|(
name|texta
argument_list|,
name|textb
argument_list|,
name|min
argument_list|(
name|lena
argument_list|,
name|lenb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
condition|)
goto|goto
name|not_equal
goto|;
block|}
name|diff
operator|=
name|lena
operator|<
name|lenb
condition|?
operator|-
literal|1
else|:
name|lena
operator|!=
name|lenb
expr_stmt|;
block|}
if|if
condition|(
name|diff
condition|)
goto|goto
name|not_equal
goto|;
name|key
operator|=
name|key
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
break|break;
comment|/* Find the beginning and limit of the next field.  */
if|if
condition|(
name|key
operator|->
name|eword
operator|!=
operator|-
literal|1
condition|)
name|lima
operator|=
name|limfield
argument_list|(
name|a
argument_list|,
name|key
argument_list|)
operator|,
name|limb
operator|=
name|limfield
argument_list|(
name|b
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|lima
operator|=
name|a
operator|->
name|text
operator|+
name|a
operator|->
name|length
operator|-
literal|1
operator|,
name|limb
operator|=
name|b
operator|->
name|text
operator|+
name|b
operator|->
name|length
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|sword
operator|!=
operator|-
literal|1
condition|)
name|texta
operator|=
name|begfield
argument_list|(
name|a
argument_list|,
name|key
argument_list|)
operator|,
name|textb
operator|=
name|begfield
argument_list|(
name|b
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
name|texta
operator|=
name|a
operator|->
name|text
operator|,
name|textb
operator|=
name|b
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|skipsblanks
condition|)
block|{
while|while
condition|(
name|texta
operator|<
name|lima
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|texta
argument_list|)
index|]
condition|)
operator|++
name|texta
expr_stmt|;
while|while
condition|(
name|textb
operator|<
name|limb
operator|&&
name|blanks
index|[
name|UCHAR
argument_list|(
operator|*
name|textb
argument_list|)
index|]
condition|)
operator|++
name|textb
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
name|greater
label|:
name|diff
operator|=
literal|1
expr_stmt|;
name|not_equal
label|:
return|return
name|key
operator|->
name|reverse
condition|?
operator|-
name|diff
else|:
name|diff
return|;
block|}
end_function

begin_comment
comment|/* Compare two lines A and B, returning negative, zero, or positive    depending on whether A compares less than, equal to, or greater than B. */
end_comment

begin_function
specifier|static
name|int
name|compare
parameter_list|(
specifier|register
specifier|const
name|struct
name|line
modifier|*
name|a
parameter_list|,
specifier|register
specifier|const
name|struct
name|line
modifier|*
name|b
parameter_list|)
block|{
name|int
name|diff
decl_stmt|;
name|size_t
name|alen
decl_stmt|,
name|blen
decl_stmt|;
comment|/* First try to compare on the specified keys (if any).      The only two cases with no key at all are unadorned sort,      and unadorned sort -r. */
if|if
condition|(
name|keylist
condition|)
block|{
name|diff
operator|=
name|keycompare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
operator|||
name|unique
operator|||
name|stable
condition|)
return|return
name|diff
return|;
block|}
comment|/* If the keys all compare equal (or no keys were specified)      fall through to the default comparison.  */
name|alen
operator|=
name|a
operator|->
name|length
operator|-
literal|1
operator|,
name|blen
operator|=
name|b
operator|->
name|length
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|alen
operator|==
literal|0
condition|)
name|diff
operator|=
operator|-
name|NONZERO
argument_list|(
name|blen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|blen
operator|==
literal|0
condition|)
name|diff
operator|=
name|NONZERO
argument_list|(
name|alen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|HAVE_SETLOCALE
operator|&&
name|hard_LC_COLLATE
condition|)
name|diff
operator|=
name|xmemcoll
argument_list|(
name|a
operator|->
name|text
argument_list|,
name|alen
argument_list|,
name|b
operator|->
name|text
argument_list|,
name|blen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|diff
operator|=
name|memcmp
argument_list|(
name|a
operator|->
name|text
argument_list|,
name|b
operator|->
name|text
argument_list|,
name|min
argument_list|(
name|alen
argument_list|,
name|blen
argument_list|)
argument_list|)
operator|)
condition|)
name|diff
operator|=
name|alen
operator|<
name|blen
condition|?
operator|-
literal|1
else|:
name|alen
operator|!=
name|blen
expr_stmt|;
return|return
name|reverse
condition|?
operator|-
name|diff
else|:
name|diff
return|;
block|}
end_function

begin_comment
comment|/* Check that the lines read from the given FP come in order.  Print a    diagnostic (FILE_NAME, line number, contents of line) to stderr and return    one if they are not in order.  Otherwise, print no diagnostic    and return zero.  */
end_comment

begin_function
specifier|static
name|int
name|checkfp
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|file_name
parameter_list|)
block|{
name|struct
name|buffer
name|buf
decl_stmt|;
comment|/* Input buffer. */
name|struct
name|line
name|temp
decl_stmt|;
comment|/* Copy of previous line. */
name|size_t
name|alloc
init|=
literal|0
decl_stmt|;
name|uintmax_t
name|line_number
init|=
literal|0
decl_stmt|;
name|struct
name|keyfield
modifier|*
name|key
init|=
name|keylist
decl_stmt|;
name|int
name|nonunique
init|=
literal|1
operator|-
name|unique
decl_stmt|;
name|int
name|disordered
init|=
literal|0
decl_stmt|;
name|initbuf
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|,
name|MAX
argument_list|(
name|merge_buffer_size
argument_list|,
name|sort_size
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|.
name|text
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|fillbuf
argument_list|(
operator|&
name|buf
argument_list|,
name|fp
argument_list|,
name|file_name
argument_list|)
condition|)
block|{
name|struct
name|line
specifier|const
modifier|*
name|line
init|=
name|buffer_linelim
argument_list|(
operator|&
name|buf
argument_list|)
decl_stmt|;
name|struct
name|line
specifier|const
modifier|*
name|linebase
init|=
name|line
operator|-
name|buf
operator|.
name|nlines
decl_stmt|;
comment|/* Make sure the line saved from the old buffer contents is 	 less than or equal to the first line of the new buffer. */
if|if
condition|(
name|alloc
operator|&&
name|nonunique
operator|<=
name|compare
argument_list|(
operator|&
name|temp
argument_list|,
name|line
operator|-
literal|1
argument_list|)
condition|)
block|{
name|found_disorder
label|:
block|{
name|char
name|hr_buf
index|[
name|LONGEST_HUMAN_READABLE
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|line
specifier|const
modifier|*
name|disorder_line
init|=
name|line
operator|-
literal|1
decl_stmt|;
name|uintmax_t
name|disorder_line_number
init|=
name|buffer_linelim
argument_list|(
operator|&
name|buf
argument_list|)
operator|-
name|disorder_line
operator|+
name|line_number
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: %s:%s: disorder: "
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|file_name
argument_list|,
name|human_readable
argument_list|(
name|disorder_line_number
argument_list|,
name|hr_buf
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|write_bytes
argument_list|(
name|disorder_line
operator|->
name|text
argument_list|,
name|disorder_line
operator|->
name|length
argument_list|,
name|stderr
argument_list|,
name|_
argument_list|(
literal|"standard error"
argument_list|)
argument_list|)
expr_stmt|;
name|disordered
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Compare each line in the buffer with its successor.  */
while|while
condition|(
name|linebase
operator|<
operator|--
name|line
condition|)
if|if
condition|(
name|nonunique
operator|<=
name|compare
argument_list|(
name|line
argument_list|,
name|line
operator|-
literal|1
argument_list|)
condition|)
goto|goto
name|found_disorder
goto|;
name|line_number
operator|+=
name|buf
operator|.
name|nlines
expr_stmt|;
comment|/* Save the last line of the buffer.  */
if|if
condition|(
name|alloc
operator|<
name|line
operator|->
name|length
condition|)
block|{
do|do
block|{
name|alloc
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|alloc
condition|)
block|{
name|alloc
operator|=
name|line
operator|->
name|length
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|alloc
operator|<
name|line
operator|->
name|length
condition|)
do|;
name|temp
operator|.
name|text
operator|=
name|xrealloc
argument_list|(
name|temp
operator|.
name|text
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|temp
operator|.
name|text
argument_list|,
name|line
operator|->
name|text
argument_list|,
name|line
operator|->
name|length
argument_list|)
expr_stmt|;
name|temp
operator|.
name|length
operator|=
name|line
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|key
condition|)
block|{
name|temp
operator|.
name|keybeg
operator|=
name|temp
operator|.
name|text
operator|+
operator|(
name|line
operator|->
name|keybeg
operator|-
name|line
operator|->
name|text
operator|)
expr_stmt|;
name|temp
operator|.
name|keylim
operator|=
name|temp
operator|.
name|text
operator|+
operator|(
name|line
operator|->
name|keylim
operator|-
name|line
operator|->
name|text
operator|)
expr_stmt|;
block|}
block|}
name|xfclose
argument_list|(
name|fp
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|.
name|text
condition|)
name|free
argument_list|(
name|temp
operator|.
name|text
argument_list|)
expr_stmt|;
return|return
name|disordered
return|;
block|}
end_function

begin_comment
comment|/* Merge lines from FILES onto OFP.  NFILES cannot be greater than    NMERGE.  Close input and output files before returning.    OUTPUT_FILE gives the name of the output file; if OFP is NULL, the    output file has not been opened yet.  */
end_comment

begin_function
specifier|static
name|void
name|mergefps
parameter_list|(
name|char
modifier|*
modifier|*
name|files
parameter_list|,
specifier|register
name|int
name|nfiles
parameter_list|,
name|FILE
modifier|*
name|ofp
parameter_list|,
specifier|const
name|char
modifier|*
name|output_file
parameter_list|)
block|{
name|FILE
modifier|*
name|fps
index|[
name|NMERGE
index|]
decl_stmt|;
comment|/* Input streams for each file.  */
name|struct
name|buffer
name|buffer
index|[
name|NMERGE
index|]
decl_stmt|;
comment|/* Input buffers for each file. */
name|struct
name|line
name|saved
decl_stmt|;
comment|/* Saved line storage for unique check. */
name|struct
name|line
specifier|const
modifier|*
name|savedline
init|=
name|NULL
decl_stmt|;
comment|/*&saved if there is a saved line. */
name|size_t
name|savealloc
init|=
literal|0
decl_stmt|;
comment|/* Size allocated for the saved line. */
name|struct
name|line
specifier|const
modifier|*
name|cur
index|[
name|NMERGE
index|]
decl_stmt|;
comment|/* Current line in each line table. */
name|struct
name|line
specifier|const
modifier|*
name|base
index|[
name|NMERGE
index|]
decl_stmt|;
comment|/* Base of each line table.  */
name|int
name|ord
index|[
name|NMERGE
index|]
decl_stmt|;
comment|/* Table representing a permutation of fps, 				   such that cur[ord[0]] is the smallest line 				   and will be next output. */
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|t
decl_stmt|;
name|struct
name|keyfield
modifier|*
name|key
init|=
name|keylist
decl_stmt|;
name|saved
operator|.
name|text
operator|=
name|NULL
expr_stmt|;
comment|/* Read initial lines from each input file. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
control|)
block|{
name|fps
index|[
name|i
index|]
operator|=
name|xfopen
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|initbuf
argument_list|(
operator|&
name|buffer
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|,
name|MAX
argument_list|(
name|merge_buffer_size
argument_list|,
name|sort_size
operator|/
name|nfiles
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fillbuf
argument_list|(
operator|&
name|buffer
index|[
name|i
index|]
argument_list|,
name|fps
index|[
name|i
index|]
argument_list|,
name|files
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|struct
name|line
specifier|const
modifier|*
name|linelim
init|=
name|buffer_linelim
argument_list|(
operator|&
name|buffer
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|cur
index|[
name|i
index|]
operator|=
name|linelim
operator|-
literal|1
expr_stmt|;
name|base
index|[
name|i
index|]
operator|=
name|linelim
operator|-
name|buffer
index|[
name|i
index|]
operator|.
name|nlines
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* fps[i] is empty; eliminate it from future consideration.  */
name|xfclose
argument_list|(
name|fps
index|[
name|i
index|]
argument_list|,
name|files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|zaptemp
argument_list|(
name|files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
index|[
name|i
index|]
operator|.
name|buf
argument_list|)
expr_stmt|;
operator|--
name|nfiles
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|nfiles
condition|;
operator|++
name|j
control|)
name|files
index|[
name|j
index|]
operator|=
name|files
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ofp
condition|)
name|ofp
operator|=
name|xfopen
argument_list|(
name|output_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
comment|/* Set up the ord table according to comparisons among input lines.      Since this only reorders two items if one is strictly greater than      the other, it is stable. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
operator|++
name|i
control|)
name|ord
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nfiles
condition|;
operator|++
name|i
control|)
if|if
condition|(
literal|0
operator|<
name|compare
argument_list|(
name|cur
index|[
name|ord
index|[
name|i
operator|-
literal|1
index|]
index|]
argument_list|,
name|cur
index|[
name|ord
index|[
name|i
index|]
index|]
argument_list|)
condition|)
name|t
operator|=
name|ord
index|[
name|i
operator|-
literal|1
index|]
operator|,
name|ord
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|ord
index|[
name|i
index|]
operator|,
name|ord
index|[
name|i
index|]
operator|=
name|t
operator|,
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Repeatedly output the smallest line until no input remains. */
while|while
condition|(
name|nfiles
condition|)
block|{
name|struct
name|line
specifier|const
modifier|*
name|smallest
init|=
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
decl_stmt|;
comment|/* If uniquified output is turned on, output only the first of 	 an identical series of lines. */
if|if
condition|(
name|unique
condition|)
block|{
if|if
condition|(
name|savedline
operator|&&
name|compare
argument_list|(
name|savedline
argument_list|,
name|smallest
argument_list|)
condition|)
block|{
name|savedline
operator|=
literal|0
expr_stmt|;
name|write_bytes
argument_list|(
name|saved
operator|.
name|text
argument_list|,
name|saved
operator|.
name|length
argument_list|,
name|ofp
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|savedline
condition|)
block|{
name|savedline
operator|=
operator|&
name|saved
expr_stmt|;
if|if
condition|(
name|savealloc
operator|<
name|smallest
operator|->
name|length
condition|)
block|{
do|do
if|if
condition|(
operator|!
name|savealloc
condition|)
block|{
name|savealloc
operator|=
name|smallest
operator|->
name|length
expr_stmt|;
break|break;
block|}
do|while
condition|(
operator|(
name|savealloc
operator|*=
literal|2
operator|)
operator|<
name|smallest
operator|->
name|length
condition|)
do|;
name|saved
operator|.
name|text
operator|=
name|xrealloc
argument_list|(
name|saved
operator|.
name|text
argument_list|,
name|savealloc
argument_list|)
expr_stmt|;
block|}
name|saved
operator|.
name|length
operator|=
name|smallest
operator|->
name|length
expr_stmt|;
name|memcpy
argument_list|(
name|saved
operator|.
name|text
argument_list|,
name|smallest
operator|->
name|text
argument_list|,
name|saved
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
condition|)
block|{
name|saved
operator|.
name|keybeg
operator|=
name|saved
operator|.
name|text
operator|+
operator|(
name|smallest
operator|->
name|keybeg
operator|-
name|smallest
operator|->
name|text
operator|)
expr_stmt|;
name|saved
operator|.
name|keylim
operator|=
name|saved
operator|.
name|text
operator|+
operator|(
name|smallest
operator|->
name|keylim
operator|-
name|smallest
operator|->
name|text
operator|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|write_bytes
argument_list|(
name|smallest
operator|->
name|text
argument_list|,
name|smallest
operator|->
name|length
argument_list|,
name|ofp
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
comment|/* Check if we need to read more lines into core. */
if|if
condition|(
name|base
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|<
name|smallest
condition|)
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|=
name|smallest
operator|-
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fillbuf
argument_list|(
operator|&
name|buffer
index|[
name|ord
index|[
literal|0
index|]
index|]
argument_list|,
name|fps
index|[
name|ord
index|[
literal|0
index|]
index|]
argument_list|,
name|files
index|[
name|ord
index|[
literal|0
index|]
index|]
argument_list|)
condition|)
block|{
name|struct
name|line
specifier|const
modifier|*
name|linelim
init|=
name|buffer_linelim
argument_list|(
operator|&
name|buffer
index|[
name|ord
index|[
literal|0
index|]
index|]
argument_list|)
decl_stmt|;
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|=
name|linelim
operator|-
literal|1
expr_stmt|;
name|base
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|=
name|linelim
operator|-
name|buffer
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|nlines
expr_stmt|;
block|}
else|else
block|{
comment|/* We reached EOF on fps[ord[0]]. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nfiles
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|ord
index|[
name|i
index|]
operator|>
name|ord
index|[
literal|0
index|]
condition|)
operator|--
name|ord
index|[
name|i
index|]
expr_stmt|;
operator|--
name|nfiles
expr_stmt|;
name|xfclose
argument_list|(
name|fps
index|[
name|ord
index|[
literal|0
index|]
index|]
argument_list|,
name|files
index|[
name|ord
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
name|zaptemp
argument_list|(
name|files
index|[
name|ord
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|.
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ord
index|[
literal|0
index|]
init|;
name|i
operator|<
name|nfiles
condition|;
operator|++
name|i
control|)
block|{
name|fps
index|[
name|i
index|]
operator|=
name|fps
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|files
index|[
name|i
index|]
operator|=
name|files
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|buffer
index|[
name|i
index|]
operator|=
name|buffer
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|cur
index|[
name|i
index|]
operator|=
name|cur
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|base
index|[
name|i
index|]
operator|=
name|base
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
operator|++
name|i
control|)
name|ord
index|[
name|i
index|]
operator|=
name|ord
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* The new line just read in may be larger than other lines 	 already in core; push it back in the queue until we encounter 	 a line larger than it. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nfiles
condition|;
operator|++
name|i
control|)
block|{
name|t
operator|=
name|compare
argument_list|(
name|cur
index|[
name|ord
index|[
literal|0
index|]
index|]
argument_list|,
name|cur
index|[
name|ord
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
name|t
operator|=
name|ord
index|[
literal|0
index|]
operator|-
name|ord
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
break|break;
block|}
name|t
operator|=
name|ord
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
name|ord
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|ord
index|[
name|j
index|]
expr_stmt|;
name|ord
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|unique
operator|&&
name|savedline
condition|)
block|{
name|write_bytes
argument_list|(
name|saved
operator|.
name|text
argument_list|,
name|saved
operator|.
name|length
argument_list|,
name|ofp
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|saved
operator|.
name|text
argument_list|)
expr_stmt|;
block|}
name|xfclose
argument_list|(
name|ofp
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sort the array LINES with NLINES members, using TEMP for temporary space.    The input and output arrays are in reverse order, and LINES and    TEMP point just past the end of their respective arrays.  */
end_comment

begin_function
specifier|static
name|void
name|sortlines
parameter_list|(
name|struct
name|line
modifier|*
name|lines
parameter_list|,
name|size_t
name|nlines
parameter_list|,
name|struct
name|line
modifier|*
name|temp
parameter_list|)
block|{
specifier|register
name|struct
name|line
modifier|*
name|lo
decl_stmt|,
modifier|*
name|hi
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|register
name|size_t
name|nlo
decl_stmt|,
name|nhi
decl_stmt|;
if|if
condition|(
name|nlines
operator|==
literal|2
condition|)
block|{
if|if
condition|(
literal|0
operator|<
name|compare
argument_list|(
operator|&
name|lines
index|[
operator|-
literal|1
index|]
argument_list|,
operator|&
name|lines
index|[
operator|-
literal|2
index|]
argument_list|)
condition|)
block|{
name|struct
name|line
name|tmp
init|=
name|lines
index|[
operator|-
literal|1
index|]
decl_stmt|;
name|lines
index|[
operator|-
literal|1
index|]
operator|=
name|lines
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|lines
index|[
operator|-
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
block|}
return|return;
block|}
name|nlo
operator|=
name|nlines
operator|/
literal|2
expr_stmt|;
name|lo
operator|=
name|lines
expr_stmt|;
name|nhi
operator|=
name|nlines
operator|-
name|nlo
expr_stmt|;
name|hi
operator|=
name|lines
operator|-
name|nlo
expr_stmt|;
if|if
condition|(
name|nlo
operator|>
literal|1
condition|)
name|sortlines
argument_list|(
name|lo
argument_list|,
name|nlo
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nhi
operator|>
literal|1
condition|)
name|sortlines
argument_list|(
name|hi
argument_list|,
name|nhi
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|t
operator|=
name|temp
expr_stmt|;
while|while
condition|(
name|nlo
operator|&&
name|nhi
condition|)
if|if
condition|(
name|compare
argument_list|(
name|lo
operator|-
literal|1
argument_list|,
name|hi
operator|-
literal|1
argument_list|)
operator|<=
literal|0
condition|)
operator|*
operator|--
name|t
operator|=
operator|*
operator|--
name|lo
operator|,
operator|--
name|nlo
expr_stmt|;
else|else
operator|*
operator|--
name|t
operator|=
operator|*
operator|--
name|hi
operator|,
operator|--
name|nhi
expr_stmt|;
while|while
condition|(
name|nlo
operator|--
condition|)
operator|*
operator|--
name|t
operator|=
operator|*
operator|--
name|lo
expr_stmt|;
for|for
control|(
name|lo
operator|=
name|lines
operator|,
name|nlo
operator|=
name|nlines
operator|-
name|nhi
operator|,
name|t
operator|=
name|temp
init|;
name|nlo
condition|;
operator|--
name|nlo
control|)
operator|*
operator|--
name|lo
operator|=
operator|*
operator|--
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the index of the first of NFILES FILES that is the same file    as OUTFILE.  If none can be the same, return NFILES.  Consider an    input pipe to be the same as OUTFILE, since the pipe might be the    output of a command like "cat OUTFILE".  */
end_comment

begin_function
specifier|static
name|int
name|first_same_file
parameter_list|(
name|char
modifier|*
modifier|*
name|files
parameter_list|,
name|int
name|nfiles
parameter_list|,
name|char
specifier|const
modifier|*
name|outfile
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|got_outstat
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|instat
decl_stmt|,
name|outstat
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
block|{
name|int
name|standard_input
init|=
name|STREQ
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
literal|"-"
argument_list|)
decl_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|outfile
argument_list|,
name|files
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|standard_input
condition|)
return|return
name|i
return|;
if|if
condition|(
operator|!
name|got_outstat
condition|)
block|{
name|got_outstat
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|STREQ
argument_list|(
name|outfile
argument_list|,
literal|"-"
argument_list|)
condition|?
name|fstat
argument_list|(
name|STDOUT_FILENO
argument_list|,
operator|&
name|outstat
argument_list|)
else|:
name|stat
argument_list|(
name|outfile
argument_list|,
operator|&
name|outstat
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|nfiles
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|standard_input
condition|?
name|fstat
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|instat
argument_list|)
else|:
name|stat
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
operator|&
name|instat
argument_list|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|S_ISFIFO
argument_list|(
name|instat
operator|.
name|st_mode
argument_list|)
operator|||
name|SAME_INODE
argument_list|(
name|instat
argument_list|,
name|outstat
argument_list|)
operator|)
condition|)
return|return
name|i
return|;
block|}
return|return
name|nfiles
return|;
block|}
end_function

begin_comment
comment|/* Check that each of the NFILES FILES is ordered.    Return a count of disordered files. */
end_comment

begin_function
specifier|static
name|int
name|check
parameter_list|(
name|char
modifier|*
modifier|*
name|files
parameter_list|,
name|int
name|nfiles
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|disorders
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
operator|++
name|i
control|)
block|{
name|fp
operator|=
name|xfopen
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|disorders
operator|+=
name|checkfp
argument_list|(
name|fp
argument_list|,
name|files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|disorders
return|;
block|}
end_function

begin_comment
comment|/* Merge NFILES FILES onto OUTPUT_FILE.  However, merge at most    MAX_MERGE input files directly onto OUTPUT_FILE.  MAX_MERGE cannot    exceed NMERGE.  */
end_comment

begin_function
specifier|static
name|void
name|merge
parameter_list|(
name|char
modifier|*
modifier|*
name|files
parameter_list|,
name|int
name|nfiles
parameter_list|,
name|int
name|max_merge
parameter_list|,
name|char
specifier|const
modifier|*
name|output_file
parameter_list|)
block|{
while|while
condition|(
name|max_merge
operator|<
name|nfiles
condition|)
block|{
name|FILE
modifier|*
name|tfp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|t
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
operator|/
name|NMERGE
condition|;
operator|++
name|i
control|)
block|{
name|temp
operator|=
name|create_temp_file
argument_list|(
operator|&
name|tfp
argument_list|)
expr_stmt|;
name|mergefps
argument_list|(
operator|&
name|files
index|[
name|i
operator|*
name|NMERGE
index|]
argument_list|,
name|NMERGE
argument_list|,
name|tfp
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|files
index|[
name|t
operator|++
index|]
operator|=
name|temp
expr_stmt|;
block|}
name|temp
operator|=
name|create_temp_file
argument_list|(
operator|&
name|tfp
argument_list|)
expr_stmt|;
name|mergefps
argument_list|(
operator|&
name|files
index|[
name|i
operator|*
name|NMERGE
index|]
argument_list|,
name|nfiles
operator|%
name|NMERGE
argument_list|,
name|tfp
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|files
index|[
name|t
operator|++
index|]
operator|=
name|temp
expr_stmt|;
name|nfiles
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|nfiles
operator|==
literal|1
condition|)
break|break;
block|}
name|mergefps
argument_list|(
name|files
argument_list|,
name|nfiles
argument_list|,
name|NULL
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sort NFILES FILES onto OUTPUT_FILE. */
end_comment

begin_function
specifier|static
name|void
name|sort
parameter_list|(
name|char
modifier|*
modifier|*
name|files
parameter_list|,
name|int
name|nfiles
parameter_list|,
name|char
specifier|const
modifier|*
name|output_file
parameter_list|)
block|{
name|struct
name|buffer
name|buf
decl_stmt|;
name|int
name|n_temp_files
init|=
literal|0
decl_stmt|;
name|int
name|output_file_created
init|=
literal|0
decl_stmt|;
specifier|static
name|size_t
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|size
operator|&&
operator|!
operator|(
name|size
operator|=
name|sort_size
operator|)
condition|)
name|size
operator|=
name|default_sort_size
argument_list|()
expr_stmt|;
name|buf
operator|.
name|alloc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nfiles
condition|)
block|{
name|char
specifier|const
modifier|*
name|temp_output
decl_stmt|;
name|char
specifier|const
modifier|*
name|file
init|=
operator|*
name|files
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|xfopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|tfp
decl_stmt|;
if|if
condition|(
operator|!
name|buf
operator|.
name|alloc
condition|)
name|initbuf
argument_list|(
operator|&
name|buf
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|,
name|sort_buffer_size
argument_list|(
operator|&
name|fp
argument_list|,
literal|1
argument_list|,
name|files
argument_list|,
name|nfiles
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|eof
operator|=
literal|0
expr_stmt|;
name|files
operator|++
expr_stmt|;
name|nfiles
operator|--
expr_stmt|;
while|while
condition|(
name|fillbuf
argument_list|(
operator|&
name|buf
argument_list|,
name|fp
argument_list|,
name|file
argument_list|)
condition|)
block|{
name|struct
name|line
modifier|*
name|line
decl_stmt|;
name|struct
name|line
modifier|*
name|linebase
decl_stmt|;
if|if
condition|(
name|buf
operator|.
name|eof
operator|&&
name|nfiles
operator|&&
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
operator|+
literal|1
operator|<
operator|(
name|buf
operator|.
name|alloc
operator|-
name|buf
operator|.
name|used
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
operator|*
name|buf
operator|.
name|nlines
operator|)
operator|)
condition|)
block|{
comment|/* End of file, but there is more input and buffer room. 		 Concatenate the next input file; this is faster in 		 the usual case.  */
name|buf
operator|.
name|left
operator|=
name|buf
operator|.
name|used
expr_stmt|;
break|break;
block|}
name|line
operator|=
name|buffer_linelim
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|linebase
operator|=
name|line
operator|-
name|buf
operator|.
name|nlines
expr_stmt|;
name|sortlines
argument_list|(
name|line
argument_list|,
name|buf
operator|.
name|nlines
argument_list|,
name|linebase
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|.
name|eof
operator|&&
operator|!
name|nfiles
operator|&&
operator|!
name|n_temp_files
operator|&&
operator|!
name|buf
operator|.
name|left
condition|)
block|{
name|xfclose
argument_list|(
name|fp
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|tfp
operator|=
name|xfopen
argument_list|(
name|output_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|temp_output
operator|=
name|output_file
expr_stmt|;
name|output_file_created
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|++
name|n_temp_files
expr_stmt|;
name|temp_output
operator|=
name|create_temp_file
argument_list|(
operator|&
name|tfp
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|line
operator|--
expr_stmt|;
name|write_bytes
argument_list|(
name|line
operator|->
name|text
argument_list|,
name|line
operator|->
name|length
argument_list|,
name|tfp
argument_list|,
name|temp_output
argument_list|)
expr_stmt|;
if|if
condition|(
name|unique
condition|)
while|while
condition|(
name|linebase
operator|<
name|line
operator|&&
name|compare
argument_list|(
name|line
argument_list|,
name|line
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|line
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|linebase
operator|<
name|line
condition|)
do|;
name|xfclose
argument_list|(
name|tfp
argument_list|,
name|temp_output
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_file_created
condition|)
goto|goto
name|finish
goto|;
block|}
name|xfclose
argument_list|(
name|fp
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|finish
label|:
name|free
argument_list|(
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|output_file_created
condition|)
block|{
name|int
name|i
init|=
name|n_temp_files
decl_stmt|;
name|struct
name|tempnode
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
modifier|*
name|tempfiles
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_temp_files
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|node
operator|=
name|temphead
init|;
name|i
operator|>
literal|0
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|tempfiles
index|[
operator|--
name|i
index|]
operator|=
name|node
operator|->
name|name
expr_stmt|;
name|merge
argument_list|(
name|tempfiles
argument_list|,
name|n_temp_files
argument_list|,
name|NMERGE
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tempfiles
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert key KEY at the end of the key list.  */
end_comment

begin_function
specifier|static
name|void
name|insertkey
parameter_list|(
name|struct
name|keyfield
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|keyfield
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|keylist
init|;
operator|*
name|p
condition|;
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|next
control|)
continue|continue;
operator|*
name|p
operator|=
name|key
expr_stmt|;
name|key
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report a bad field specification SPEC, with extra info MSGID.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|badfieldspec
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|badfieldspec
parameter_list|(
name|char
specifier|const
modifier|*
name|spec
parameter_list|,
name|char
specifier|const
modifier|*
name|msgid
parameter_list|)
block|{
name|error
argument_list|(
name|SORT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"%s: invalid field specification `%s'"
argument_list|)
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|spec
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the leading integer in STRING and store the resulting value    (which must fit into size_t) into *VAL.  Return the address of the    suffix after the integer.  If MSGID is NULL, return NULL after    failure; otherwise, report MSGID and exit on failure.  */
end_comment

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|parse_field_count
parameter_list|(
name|char
specifier|const
modifier|*
name|string
parameter_list|,
name|size_t
modifier|*
name|val
parameter_list|,
name|char
specifier|const
modifier|*
name|msgid
parameter_list|)
block|{
name|char
modifier|*
name|suffix
decl_stmt|;
name|uintmax_t
name|n
decl_stmt|;
switch|switch
condition|(
name|xstrtoumax
argument_list|(
name|string
argument_list|,
operator|&
name|suffix
argument_list|,
literal|10
argument_list|,
operator|&
name|n
argument_list|,
literal|""
argument_list|)
condition|)
block|{
case|case
name|LONGINT_OK
case|:
case|case
name|LONGINT_INVALID_SUFFIX_CHAR
case|:
operator|*
name|val
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|*
name|val
operator|==
name|n
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|LONGINT_OVERFLOW
case|:
if|if
condition|(
name|msgid
condition|)
name|error
argument_list|(
name|SORT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"%s: count `%.*s' too large"
argument_list|)
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|suffix
operator|-
name|string
argument_list|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|LONGINT_INVALID
case|:
if|if
condition|(
name|msgid
condition|)
name|error
argument_list|(
name|SORT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"%s: invalid count at start of `%s'"
argument_list|)
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|suffix
return|;
block|}
end_function

begin_comment
comment|/* Handle interrupts and hangups. */
end_comment

begin_function
specifier|static
name|void
name|sighandler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|SA_NOCLDSTOP
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cleanup
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_NOCLDSTOP
block|{
name|struct
name|sigaction
name|sigact
decl_stmt|;
name|sigact
operator|.
name|sa_handler
operator|=
name|SIG_DFL
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sigact
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sigact
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|sig
argument_list|,
operator|&
name|sigact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kill
argument_list|(
name|process_id
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the ordering options for KEY specified in S.    Return the address of the first character in S that    is not a valid ordering option.    BLANKTYPE is the kind of blanks that 'b' should skip. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|set_ordering
parameter_list|(
specifier|register
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|struct
name|keyfield
modifier|*
name|key
parameter_list|,
name|enum
name|blanktype
name|blanktype
parameter_list|)
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
name|blanktype
operator|==
name|bl_start
operator|||
name|blanktype
operator|==
name|bl_both
condition|)
name|key
operator|->
name|skipsblanks
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|blanktype
operator|==
name|bl_end
operator|||
name|blanktype
operator|==
name|bl_both
condition|)
name|key
operator|->
name|skipeblanks
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|key
operator|->
name|ignore
operator|=
name|nondictionary
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|key
operator|->
name|translate
operator|=
name|fold_toupper
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|key
operator|->
name|general_numeric
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|key
operator|->
name|ignore
operator|=
name|nonprinting
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|key
operator|->
name|month
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|key
operator|->
name|numeric
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|key
operator|->
name|reverse
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
operator|++
name|s
expr_stmt|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|keyfield
modifier|*
name|new_key
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|keyfield
modifier|*
name|key
init|=
operator|(
expr|struct
name|keyfield
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|key
argument_list|)
decl_stmt|;
name|key
operator|->
name|eword
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|key
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|keyfield
modifier|*
name|key
decl_stmt|;
name|struct
name|keyfield
name|gkey
decl_stmt|;
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|c
init|=
literal|0
decl_stmt|;
name|int
name|checkonly
init|=
literal|0
decl_stmt|,
name|mergeonly
init|=
literal|0
decl_stmt|,
name|nfiles
init|=
literal|0
decl_stmt|;
name|int
name|posix_pedantic
init|=
operator|(
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
operator|!=
name|NULL
operator|)
decl_stmt|;
name|bool
name|obsolete_usage
init|=
operator|(
name|posix2_version
argument_list|()
operator|<
literal|200112
operator|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|short_options
init|=
operator|(
name|obsolete_usage
condition|?
name|COMMON_SHORT_OPTIONS
literal|"y::"
else|:
name|COMMON_SHORT_OPTIONS
literal|"y:"
operator|)
decl_stmt|;
name|char
modifier|*
name|minus
init|=
literal|"-"
decl_stmt|,
modifier|*
modifier|*
name|files
decl_stmt|;
name|char
specifier|const
modifier|*
name|outfile
init|=
name|minus
decl_stmt|;
specifier|static
name|int
specifier|const
name|sigs
index|[]
init|=
block|{
name|SIGHUP
block|,
name|SIGINT
block|,
name|SIGPIPE
block|,
name|SIGTERM
block|}
decl_stmt|;
name|int
name|nsigs
init|=
sizeof|sizeof
name|sigs
operator|/
sizeof|sizeof
expr|*
name|sigs
decl_stmt|;
ifdef|#
directive|ifdef
name|SA_NOCLDSTOP
name|struct
name|sigaction
name|oldact
decl_stmt|,
name|newact
decl_stmt|;
endif|#
directive|endif
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|process_id
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|atexit
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|hard_LC_COLLATE
operator|=
name|hard_locale
argument_list|(
name|LC_COLLATE
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_NL_LANGINFO
name|hard_LC_TIME
operator|=
name|hard_locale
argument_list|(
name|LC_TIME
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_SETLOCALE
comment|/* Let's get locale's representation of the decimal point */
block|{
name|struct
name|lconv
modifier|*
name|lconvp
init|=
name|localeconv
argument_list|()
decl_stmt|;
comment|/* If the locale doesn't define a decimal point, or if the decimal        point is multibyte, use the C decimal point.  We don't support        multibyte decimal points yet.  */
name|decimal_point
operator|=
operator|*
name|lconvp
operator|->
name|decimal_point
expr_stmt|;
if|if
condition|(
operator|!
name|decimal_point
operator|||
name|lconvp
operator|->
name|decimal_point
index|[
literal|1
index|]
condition|)
name|decimal_point
operator|=
name|C_DECIMAL_POINT
expr_stmt|;
comment|/* We don't support multibyte thousands separators yet.  */
name|th_sep
operator|=
operator|*
name|lconvp
operator|->
name|thousands_sep
expr_stmt|;
if|if
condition|(
operator|!
name|th_sep
operator|||
name|lconvp
operator|->
name|thousands_sep
index|[
literal|1
index|]
condition|)
name|th_sep
operator|=
name|CHAR_MAX
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|have_read_stdin
operator|=
literal|0
expr_stmt|;
name|inittables
argument_list|()
expr_stmt|;
comment|/* Change the way library functions fail.  */
name|xalloc_exit_failure
operator|=
name|SORT_FAILURE
expr_stmt|;
name|xmemcoll_exit_failure
operator|=
name|SORT_FAILURE
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_NOCLDSTOP
name|sigemptyset
argument_list|(
operator|&
name|caught_signals
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsigs
condition|;
name|i
operator|++
control|)
name|sigaddset
argument_list|(
operator|&
name|caught_signals
argument_list|,
name|sigs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|newact
operator|.
name|sa_handler
operator|=
name|sighandler
expr_stmt|;
name|newact
operator|.
name|sa_mask
operator|=
name|caught_signals
expr_stmt|;
name|newact
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsigs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|sig
init|=
name|sigs
index|[
name|i
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SA_NOCLDSTOP
name|sigaction
argument_list|(
name|sig
argument_list|,
name|NULL
argument_list|,
operator|&
name|oldact
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldact
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
name|sigaction
argument_list|(
name|sig
argument_list|,
operator|&
name|newact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|sig
argument_list|,
name|sighandler
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|gkey
operator|.
name|sword
operator|=
name|gkey
operator|.
name|eword
operator|=
operator|-
literal|1
expr_stmt|;
name|gkey
operator|.
name|ignore
operator|=
name|NULL
expr_stmt|;
name|gkey
operator|.
name|translate
operator|=
name|NULL
expr_stmt|;
name|gkey
operator|.
name|numeric
operator|=
name|gkey
operator|.
name|general_numeric
operator|=
name|gkey
operator|.
name|month
operator|=
name|gkey
operator|.
name|reverse
operator|=
literal|0
expr_stmt|;
name|gkey
operator|.
name|skipsblanks
operator|=
name|gkey
operator|.
name|skipeblanks
operator|=
literal|0
expr_stmt|;
name|files
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|argc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Parse an operand as a file after "--" was seen; or if          pedantic and a file was seen, unless the POSIX version          predates 1003.1-2001 and -c was not seen and the operand is          "-o FILE" or "-oFILE".  */
if|if
condition|(
name|c
operator|==
operator|-
literal|1
operator|||
operator|(
name|posix_pedantic
operator|&&
name|nfiles
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|obsolete_usage
operator|&&
operator|!
name|checkonly
operator|&&
name|optind
operator|!=
name|argc
operator|&&
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
operator|(
name|argv
index|[
name|optind
index|]
index|[
literal|2
index|]
operator|||
name|optind
operator|+
literal|1
operator|!=
name|argc
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|short_options
argument_list|,
name|long_options
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
break|break;
name|files
index|[
name|nfiles
operator|++
index|]
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|1
case|:
name|key
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|obsolete_usage
operator|&&
name|optarg
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
comment|/* Treat +POS1 [-POS2] as a key if possible; but silently 		 treat an operand as a file if it is not a valid +POS1.  */
name|key
operator|=
name|new_key
argument_list|()
expr_stmt|;
name|s
operator|=
name|parse_field_count
argument_list|(
name|optarg
operator|+
literal|1
argument_list|,
operator|&
name|key
operator|->
name|sword
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
operator|*
name|s
operator|==
literal|'.'
condition|)
name|s
operator|=
name|parse_field_count
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|key
operator|->
name|schar
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|key
operator|->
name|sword
operator||
name|key
operator|->
name|schar
operator|)
condition|)
name|key
operator|->
name|sword
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|*
name|set_ordering
argument_list|(
name|s
argument_list|,
name|key
argument_list|,
name|bl_start
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|key
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|optind
operator|!=
name|argc
operator|&&
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|ISDIGIT
argument_list|(
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|char
specifier|const
modifier|*
name|optarg1
init|=
name|argv
index|[
name|optind
operator|++
index|]
decl_stmt|;
name|s
operator|=
name|parse_field_count
argument_list|(
name|optarg1
operator|+
literal|1
argument_list|,
operator|&
name|key
operator|->
name|eword
argument_list|,
name|N_
argument_list|(
literal|"invalid number after `-'"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
name|s
operator|=
name|parse_field_count
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|key
operator|->
name|echar
argument_list|,
name|N_
argument_list|(
literal|"invalid number after `.'"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|set_ordering
argument_list|(
name|s
argument_list|,
name|key
argument_list|,
name|bl_end
argument_list|)
condition|)
name|badfieldspec
argument_list|(
name|optarg1
argument_list|,
name|N_
argument_list|(
literal|"stray character in field spec"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|insertkey
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|key
condition|)
name|files
index|[
name|nfiles
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'d'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'i'
case|:
case|case
literal|'M'
case|:
case|case
literal|'n'
case|:
case|case
literal|'r'
case|:
block|{
name|char
name|str
index|[
literal|2
index|]
decl_stmt|;
name|str
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|str
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|set_ordering
argument_list|(
name|str
argument_list|,
operator|&
name|gkey
argument_list|,
name|bl_both
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
name|checkonly
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|key
operator|=
name|new_key
argument_list|()
expr_stmt|;
comment|/* Get POS1. */
name|s
operator|=
name|parse_field_count
argument_list|(
name|optarg
argument_list|,
operator|&
name|key
operator|->
name|sword
argument_list|,
name|N_
argument_list|(
literal|"invalid number at field start"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
operator|->
name|sword
operator|--
condition|)
block|{
comment|/* Provoke with `sort -k0' */
name|badfieldspec
argument_list|(
name|optarg
argument_list|,
name|N_
argument_list|(
literal|"field number is zero"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
name|s
operator|=
name|parse_field_count
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|key
operator|->
name|schar
argument_list|,
name|N_
argument_list|(
literal|"invalid number after `.'"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
operator|->
name|schar
operator|--
condition|)
block|{
comment|/* Provoke with `sort -k1.0' */
name|badfieldspec
argument_list|(
name|optarg
argument_list|,
name|N_
argument_list|(
literal|"character offset is zero"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|key
operator|->
name|sword
operator||
name|key
operator|->
name|schar
operator|)
condition|)
name|key
operator|->
name|sword
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|set_ordering
argument_list|(
name|s
argument_list|,
name|key
argument_list|,
name|bl_start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|','
condition|)
block|{
name|key
operator|->
name|eword
operator|=
operator|-
literal|1
expr_stmt|;
name|key
operator|->
name|echar
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Get POS2. */
name|s
operator|=
name|parse_field_count
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|key
operator|->
name|eword
argument_list|,
name|N_
argument_list|(
literal|"invalid number after `,'"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
operator|->
name|eword
operator|--
condition|)
block|{
comment|/* Provoke with `sort -k1,0' */
name|badfieldspec
argument_list|(
name|optarg
argument_list|,
name|N_
argument_list|(
literal|"field number is zero"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
name|s
operator|=
name|parse_field_count
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|key
operator|->
name|echar
argument_list|,
name|N_
argument_list|(
literal|"invalid number after `.'"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* `-k 2,3' is equivalent to `+1 -3'.  */
name|key
operator|->
name|eword
operator|++
expr_stmt|;
block|}
name|s
operator|=
name|set_ordering
argument_list|(
name|s
argument_list|,
name|key
argument_list|,
name|bl_end
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
condition|)
name|badfieldspec
argument_list|(
name|optarg
argument_list|,
name|N_
argument_list|(
literal|"stray character in field spec"
argument_list|)
argument_list|)
expr_stmt|;
name|insertkey
argument_list|(
name|key
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|mergeonly
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|outfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|stable
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|specify_sort_size
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tab
operator|=
name|optarg
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|tab
operator|&&
name|optarg
index|[
literal|1
index|]
condition|)
block|{
comment|/* Provoke with `sort -txx'.  Complain about 		 "multi-character tab" instead of "multibyte tab", so 		 that the diagnostic's wording does not need to be 		 changed once multibyte characters are supported.  */
name|error
argument_list|(
name|SORT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"multi-character tab `%s'"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
name|add_temp_dir
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|unique
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
comment|/* Accept and ignore e.g. -y0 for compatibility with Solaris 	     2.x through Solaris 7.  -y is marked as obsolete starting 	     with Solaris 8.  */
break|break;
case|case
literal|'z'
case|:
name|eolchar
operator|=
literal|0
expr_stmt|;
break|break;
name|case_GETOPT_HELP_CHAR
expr_stmt|;
name|case_GETOPT_VERSION_CHAR
argument_list|(
name|PROGRAM_NAME
argument_list|,
name|AUTHORS
argument_list|)
expr_stmt|;
default|default:
name|usage
argument_list|(
name|SORT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Inheritance of global options to individual keys. */
for|for
control|(
name|key
operator|=
name|keylist
init|;
name|key
condition|;
name|key
operator|=
name|key
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|key
operator|->
name|ignore
operator|&&
operator|!
name|key
operator|->
name|translate
operator|&&
operator|!
name|key
operator|->
name|skipsblanks
operator|&&
operator|!
name|key
operator|->
name|reverse
operator|&&
operator|!
name|key
operator|->
name|skipeblanks
operator|&&
operator|!
name|key
operator|->
name|month
operator|&&
operator|!
name|key
operator|->
name|numeric
operator|&&
operator|!
name|key
operator|->
name|general_numeric
condition|)
block|{
name|key
operator|->
name|ignore
operator|=
name|gkey
operator|.
name|ignore
expr_stmt|;
name|key
operator|->
name|translate
operator|=
name|gkey
operator|.
name|translate
expr_stmt|;
name|key
operator|->
name|skipsblanks
operator|=
name|gkey
operator|.
name|skipsblanks
expr_stmt|;
name|key
operator|->
name|skipeblanks
operator|=
name|gkey
operator|.
name|skipeblanks
expr_stmt|;
name|key
operator|->
name|month
operator|=
name|gkey
operator|.
name|month
expr_stmt|;
name|key
operator|->
name|numeric
operator|=
name|gkey
operator|.
name|numeric
expr_stmt|;
name|key
operator|->
name|general_numeric
operator|=
name|gkey
operator|.
name|general_numeric
expr_stmt|;
name|key
operator|->
name|reverse
operator|=
name|gkey
operator|.
name|reverse
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|keylist
operator|&&
operator|(
name|gkey
operator|.
name|ignore
operator|||
name|gkey
operator|.
name|translate
operator|||
name|gkey
operator|.
name|skipsblanks
operator|||
name|gkey
operator|.
name|skipeblanks
operator|||
name|gkey
operator|.
name|month
operator|||
name|gkey
operator|.
name|numeric
operator|||
name|gkey
operator|.
name|general_numeric
operator|)
condition|)
name|insertkey
argument_list|(
operator|&
name|gkey
argument_list|)
expr_stmt|;
name|reverse
operator|=
name|gkey
operator|.
name|reverse
expr_stmt|;
if|if
condition|(
name|temp_dir_count
operator|==
literal|0
condition|)
block|{
name|char
specifier|const
modifier|*
name|tmp_dir
init|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
decl_stmt|;
name|add_temp_dir
argument_list|(
name|tmp_dir
condition|?
name|tmp_dir
else|:
name|DEFAULT_TMPDIR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nfiles
operator|==
literal|0
condition|)
block|{
name|nfiles
operator|=
literal|1
expr_stmt|;
name|files
operator|=
operator|&
name|minus
expr_stmt|;
block|}
if|if
condition|(
name|checkonly
condition|)
block|{
if|if
condition|(
name|nfiles
operator|>
literal|1
condition|)
name|error
argument_list|(
name|SORT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"extra operand `%s' not allowed with -c"
argument_list|)
argument_list|,
name|files
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* POSIX requires that sort return 1 IFF invoked with -c and the 	 input is not properly sorted.  */
name|exit
argument_list|(
name|check
argument_list|(
name|files
argument_list|,
name|nfiles
argument_list|)
operator|==
literal|0
condition|?
name|EXIT_SUCCESS
else|:
name|SORT_OUT_OF_ORDER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mergeonly
condition|)
block|{
name|int
name|max_merge
init|=
name|first_same_file
argument_list|(
name|files
argument_list|,
name|MIN
argument_list|(
name|nfiles
argument_list|,
name|NMERGE
argument_list|)
argument_list|,
name|outfile
argument_list|)
decl_stmt|;
name|merge
argument_list|(
name|files
argument_list|,
name|nfiles
argument_list|,
name|max_merge
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
else|else
name|sort
argument_list|(
name|files
argument_list|,
name|nfiles
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_read_stdin
operator|&&
name|fclose
argument_list|(
name|stdin
argument_list|)
operator|==
name|EOF
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"close failed"
argument_list|)
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

