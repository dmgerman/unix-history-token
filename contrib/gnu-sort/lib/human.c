begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* human.c -- print human readable file size     Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Written by Paul Eggert and Larry McVoy.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"human.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SIZE_MAX
end_ifndef

begin_define
define|#
directive|define
name|SIZE_MAX
value|((size_t) -1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UINTMAX_MAX
end_ifndef

begin_define
define|#
directive|define
name|UINTMAX_MAX
value|((uintmax_t) -1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_LOCALE_H
operator|&&
name|HAVE_LOCALECONV
end_if

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"gettext.h"
end_include

begin_define
define|#
directive|define
name|_
parameter_list|(
name|msgid
parameter_list|)
value|gettext (msgid)
end_define

begin_include
include|#
directive|include
file|<argmatch.h>
end_include

begin_include
include|#
directive|include
file|<error.h>
end_include

begin_include
include|#
directive|include
file|<xstrtol.h>
end_include

begin_comment
comment|/* The maximum length of a suffix like "KiB".  */
end_comment

begin_define
define|#
directive|define
name|HUMAN_READABLE_SUFFIX_LENGTH_MAX
value|3
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|power_letter
index|[]
init|=
block|{
literal|0
block|,
comment|/* not used */
literal|'K'
block|,
comment|/* kibi ('k' for kilo is a special case) */
literal|'M'
block|,
comment|/* mega or mebi */
literal|'G'
block|,
comment|/* giga or gibi */
literal|'T'
block|,
comment|/* tera or tebi */
literal|'P'
block|,
comment|/* peta or pebi */
literal|'E'
block|,
comment|/* exa or exbi */
literal|'Z'
block|,
comment|/* zetta or 2**70 */
literal|'Y'
comment|/* yotta or 2**80 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If INEXACT_STYLE is not human_round_to_nearest, and if easily    possible, adjust VALUE according to the style.  */
end_comment

begin_function
specifier|static
name|long
name|double
name|adjust_value
parameter_list|(
name|int
name|inexact_style
parameter_list|,
name|long
name|double
name|value
parameter_list|)
block|{
comment|/* Do not use the floorl or ceill functions, as that would mean      checking for their presence and possibly linking with the      standard math library, which is a porting pain.  So leave the      value alone if it is too large to easily round.  */
if|if
condition|(
name|inexact_style
operator|!=
name|human_round_to_nearest
operator|&&
name|value
operator|<
name|UINTMAX_MAX
condition|)
block|{
name|uintmax_t
name|u
init|=
name|value
decl_stmt|;
name|value
operator|=
name|u
operator|+
operator|(
name|inexact_style
operator|==
name|human_ceiling
operator|&&
name|u
operator|!=
name|value
operator|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Group the digits of NUMBER according to the grouping rules of the    current locale.  NUMBER contains NUMBERLEN digits.  Modify the    bytes pointed to by NUMBER in place, subtracting 1 from NUMBER for    each byte inserted.  Return the starting address of the modified    number.     To group the digits, use GROUPING and THOUSANDS_SEP as in `struct    lconv' from<locale.h>.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|group_number
parameter_list|(
name|char
modifier|*
name|number
parameter_list|,
name|size_t
name|numberlen
parameter_list|,
name|char
specifier|const
modifier|*
name|grouping
parameter_list|,
name|char
specifier|const
modifier|*
name|thousands_sep
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
name|size_t
name|grouplen
init|=
name|SIZE_MAX
decl_stmt|;
name|size_t
name|thousands_seplen
init|=
name|strlen
argument_list|(
name|thousands_sep
argument_list|)
decl_stmt|;
name|size_t
name|i
init|=
name|numberlen
decl_stmt|;
comment|/* The maximum possible value for NUMBERLEN is the number of digits      in the square of the largest uintmax_t, so double the size of      uintmax_t before converting to a bound.  302 / 1000 is ceil      (log10 (2.0)).  Add 1 for integer division truncation.  */
name|char
name|buf
index|[
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uintmax_t
argument_list|)
operator|*
name|CHAR_BIT
operator|*
literal|302
operator|/
literal|1000
operator|+
literal|1
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|number
argument_list|,
name|numberlen
argument_list|)
expr_stmt|;
name|d
operator|=
name|number
operator|+
name|numberlen
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|char
name|g
init|=
operator|*
name|grouping
decl_stmt|;
if|if
condition|(
name|g
condition|)
block|{
name|grouplen
operator|=
name|g
operator|<
name|CHAR_MAX
condition|?
name|g
else|:
name|i
expr_stmt|;
name|grouping
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|grouplen
condition|)
name|grouplen
operator|=
name|i
expr_stmt|;
name|d
operator|-=
name|grouplen
expr_stmt|;
name|i
operator|-=
name|grouplen
expr_stmt|;
name|memcpy
argument_list|(
name|d
argument_list|,
name|buf
operator|+
name|i
argument_list|,
name|grouplen
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|d
return|;
name|d
operator|-=
name|thousands_seplen
expr_stmt|;
name|memcpy
argument_list|(
name|d
argument_list|,
name|thousands_sep
argument_list|,
name|thousands_seplen
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert N to a human readable format in BUF, using the options OPTS.     N is expressed in units of FROM_BLOCK_SIZE.  FROM_BLOCK_SIZE must    be nonnegative.     Use units of TO_BLOCK_SIZE in the output number.  TO_BLOCK_SIZE    must be positive.     Use (OPTS& (human_round_to_nearest | human_floor | human_ceiling))    to determine whether to take the ceiling or floor of any result    that cannot be expressed exactly.     If (OPTS& human_group_digits), group the thousands digits    according to the locale, e.g., `1,000,000' in an American English    locale.     If (OPTS& human_autoscale), deduce the output block size    automatically; TO_BLOCK_SIZE must be 1 but it has no effect on the    output.  Use powers of 1024 if (OPTS& human_base_1024), and powers    of 1000 otherwise.  For example, assuming powers of 1024, 8500    would be converted to 8.3, 133456345 to 127, 56990456345 to 53, and    so on.  Numbers smaller than the power aren't modified.    human_autoscale is normally used together with human_SI.     If (OPTS& human_SI), append an SI prefix indicating which power is    being used.  If in addition (OPTS& human_B), append "B" (if base    1000) or "iB" (if base 1024) to the SI prefix.  When ((OPTS&    human_SI)&& ! (OPTS& human_autoscale)), TO_BLOCK_SIZE must be a    power of 1024 or of 1000, depending on (OPTS&    human_base_1024).  */
end_comment

begin_function
name|char
modifier|*
name|human_readable
parameter_list|(
name|uintmax_t
name|n
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|opts
parameter_list|,
name|uintmax_t
name|from_block_size
parameter_list|,
name|uintmax_t
name|to_block_size
parameter_list|)
block|{
name|int
name|inexact_style
init|=
name|opts
operator|&
operator|(
name|human_round_to_nearest
operator||
name|human_floor
operator||
name|human_ceiling
operator|)
decl_stmt|;
name|unsigned
name|int
name|base
init|=
name|opts
operator|&
name|human_base_1024
condition|?
literal|1024
else|:
literal|1000
decl_stmt|;
name|uintmax_t
name|amt
decl_stmt|;
name|int
name|tenths
decl_stmt|;
name|int
name|exponent
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|exponent_max
init|=
sizeof|sizeof
name|power_letter
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|psuffix
decl_stmt|;
name|char
specifier|const
modifier|*
name|integerlim
decl_stmt|;
comment|/* 0 means adjusted N == AMT.TENTHS;      1 means AMT.TENTHS< adjusted N< AMT.TENTHS + 0.05;      2 means adjusted N == AMT.TENTHS + 0.05;      3 means AMT.TENTHS + 0.05< adjusted N< AMT.TENTHS + 0.1.  */
name|int
name|rounding
decl_stmt|;
name|char
specifier|const
modifier|*
name|decimal_point
init|=
literal|"."
decl_stmt|;
name|size_t
name|decimal_pointlen
init|=
literal|1
decl_stmt|;
name|char
specifier|const
modifier|*
name|grouping
init|=
literal|""
decl_stmt|;
name|char
specifier|const
modifier|*
name|thousands_sep
init|=
literal|""
decl_stmt|;
if|#
directive|if
name|HAVE_LOCALE_H
operator|&&
name|HAVE_LOCALECONV
name|struct
name|lconv
specifier|const
modifier|*
name|l
init|=
name|localeconv
argument_list|()
decl_stmt|;
name|size_t
name|pointlen
init|=
name|strlen
argument_list|(
name|l
operator|->
name|decimal_point
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|pointlen
operator|&&
name|pointlen
operator|<=
name|MB_LEN_MAX
condition|)
block|{
name|decimal_point
operator|=
name|l
operator|->
name|decimal_point
expr_stmt|;
name|decimal_pointlen
operator|=
name|pointlen
expr_stmt|;
block|}
name|grouping
operator|=
name|l
operator|->
name|grouping
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|l
operator|->
name|thousands_sep
argument_list|)
operator|<=
name|MB_LEN_MAX
condition|)
name|thousands_sep
operator|=
name|l
operator|->
name|thousands_sep
expr_stmt|;
endif|#
directive|endif
name|psuffix
operator|=
name|buf
operator|+
name|LONGEST_HUMAN_READABLE
operator|-
name|HUMAN_READABLE_SUFFIX_LENGTH_MAX
expr_stmt|;
name|p
operator|=
name|psuffix
expr_stmt|;
comment|/* Adjust AMT out of FROM_BLOCK_SIZE units and into TO_BLOCK_SIZE      units.  If this can be done exactly with integer arithmetic, do      not use floating point operations.  */
if|if
condition|(
name|to_block_size
operator|<=
name|from_block_size
condition|)
block|{
if|if
condition|(
name|from_block_size
operator|%
name|to_block_size
operator|==
literal|0
condition|)
block|{
name|uintmax_t
name|multiplier
init|=
name|from_block_size
operator|/
name|to_block_size
decl_stmt|;
name|amt
operator|=
name|n
operator|*
name|multiplier
expr_stmt|;
if|if
condition|(
name|amt
operator|/
name|multiplier
operator|==
name|n
condition|)
block|{
name|tenths
operator|=
literal|0
expr_stmt|;
name|rounding
operator|=
literal|0
expr_stmt|;
goto|goto
name|use_integer_arithmetic
goto|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|from_block_size
operator|!=
literal|0
operator|&&
name|to_block_size
operator|%
name|from_block_size
operator|==
literal|0
condition|)
block|{
name|uintmax_t
name|divisor
init|=
name|to_block_size
operator|/
name|from_block_size
decl_stmt|;
name|uintmax_t
name|r10
init|=
operator|(
name|n
operator|%
name|divisor
operator|)
operator|*
literal|10
decl_stmt|;
name|uintmax_t
name|r2
init|=
operator|(
name|r10
operator|%
name|divisor
operator|)
operator|*
literal|2
decl_stmt|;
name|amt
operator|=
name|n
operator|/
name|divisor
expr_stmt|;
name|tenths
operator|=
name|r10
operator|/
name|divisor
expr_stmt|;
name|rounding
operator|=
name|r2
operator|<
name|divisor
condition|?
literal|0
operator|<
name|r2
else|:
literal|2
operator|+
operator|(
name|divisor
operator|<
name|r2
operator|)
expr_stmt|;
goto|goto
name|use_integer_arithmetic
goto|;
block|}
block|{
comment|/* Either the result cannot be computed easily using uintmax_t,        or from_block_size is zero.  Fall back on floating point.        FIXME: This can yield answers that are slightly off.  */
name|long
name|double
name|dto_block_size
init|=
name|to_block_size
decl_stmt|;
name|long
name|double
name|damt
init|=
name|n
operator|*
operator|(
name|from_block_size
operator|/
name|dto_block_size
operator|)
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
name|size_t
name|nonintegerlen
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|opts
operator|&
name|human_autoscale
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.0Lf"
argument_list|,
name|adjust_value
argument_list|(
name|inexact_style
argument_list|,
name|damt
argument_list|)
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|nonintegerlen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|long
name|double
name|e
init|=
literal|1
decl_stmt|;
name|exponent
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|e
operator|*=
name|base
expr_stmt|;
name|exponent
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|e
operator|*
name|base
operator|<=
name|damt
operator|&&
name|exponent
operator|<
name|exponent_max
condition|)
do|;
name|damt
operator|/=
name|e
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.1Lf"
argument_list|,
name|adjust_value
argument_list|(
name|inexact_style
argument_list|,
name|damt
argument_list|)
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|nonintegerlen
operator|=
name|decimal_pointlen
operator|+
literal|1
expr_stmt|;
if|if
condition|(
literal|1
operator|+
name|nonintegerlen
operator|+
operator|!
operator|(
name|opts
operator|&
name|human_base_1024
operator|)
operator|<
name|buflen
operator|||
operator|(
operator|(
name|opts
operator|&
name|human_suppress_point_zero
operator|)
operator|&&
name|buf
index|[
name|buflen
operator|-
literal|1
index|]
operator|==
literal|'0'
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.0Lf"
argument_list|,
name|adjust_value
argument_list|(
name|inexact_style
argument_list|,
name|damt
operator|*
literal|10
argument_list|)
operator|/
literal|10
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|nonintegerlen
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|p
operator|=
name|psuffix
operator|-
name|buflen
expr_stmt|;
name|memmove
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|integerlim
operator|=
name|p
operator|+
name|buflen
operator|-
name|nonintegerlen
expr_stmt|;
block|}
goto|goto
name|do_grouping
goto|;
name|use_integer_arithmetic
label|:
block|{
comment|/* The computation can be done exactly, with integer arithmetic.         Use power of BASE notation if requested and if adjusted AMT is        large enough.  */
if|if
condition|(
name|opts
operator|&
name|human_autoscale
condition|)
block|{
name|exponent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|base
operator|<=
name|amt
condition|)
block|{
do|do
block|{
name|unsigned
name|int
name|r10
init|=
operator|(
name|amt
operator|%
name|base
operator|)
operator|*
literal|10
operator|+
name|tenths
decl_stmt|;
name|unsigned
name|int
name|r2
init|=
operator|(
name|r10
operator|%
name|base
operator|)
operator|*
literal|2
operator|+
operator|(
name|rounding
operator|>>
literal|1
operator|)
decl_stmt|;
name|amt
operator|/=
name|base
expr_stmt|;
name|tenths
operator|=
name|r10
operator|/
name|base
expr_stmt|;
name|rounding
operator|=
operator|(
name|r2
operator|<
name|base
condition|?
operator|(
name|r2
operator|+
name|rounding
operator|)
operator|!=
literal|0
else|:
literal|2
operator|+
operator|(
name|base
operator|<
name|r2
operator|+
name|rounding
operator|)
operator|)
expr_stmt|;
name|exponent
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|base
operator|<=
name|amt
operator|&&
name|exponent
operator|<
name|exponent_max
condition|)
do|;
if|if
condition|(
name|amt
operator|<
literal|10
condition|)
block|{
if|if
condition|(
name|inexact_style
operator|==
name|human_round_to_nearest
condition|?
literal|2
operator|<
name|rounding
operator|+
operator|(
name|tenths
operator|&
literal|1
operator|)
else|:
name|inexact_style
operator|==
name|human_ceiling
operator|&&
literal|0
operator|<
name|rounding
condition|)
block|{
name|tenths
operator|++
expr_stmt|;
name|rounding
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tenths
operator|==
literal|10
condition|)
block|{
name|amt
operator|++
expr_stmt|;
name|tenths
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|amt
operator|<
literal|10
operator|&&
operator|(
name|tenths
operator|||
operator|!
operator|(
name|opts
operator|&
name|human_suppress_point_zero
operator|)
operator|)
condition|)
block|{
operator|*
operator|--
name|p
operator|=
literal|'0'
operator|+
name|tenths
expr_stmt|;
name|p
operator|-=
name|decimal_pointlen
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|decimal_point
argument_list|,
name|decimal_pointlen
argument_list|)
expr_stmt|;
name|tenths
operator|=
name|rounding
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|inexact_style
operator|==
name|human_round_to_nearest
condition|?
literal|5
operator|<
name|tenths
operator|+
operator|(
literal|0
operator|<
name|rounding
operator|+
operator|(
name|amt
operator|&
literal|1
operator|)
operator|)
else|:
name|inexact_style
operator|==
name|human_ceiling
operator|&&
literal|0
operator|<
name|tenths
operator|+
name|rounding
condition|)
block|{
name|amt
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|human_autoscale
operator|)
operator|&&
name|amt
operator|==
name|base
operator|&&
name|exponent
operator|<
name|exponent_max
condition|)
block|{
name|exponent
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|opts
operator|&
name|human_suppress_point_zero
operator|)
condition|)
block|{
operator|*
operator|--
name|p
operator|=
literal|'0'
expr_stmt|;
name|p
operator|-=
name|decimal_pointlen
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|decimal_point
argument_list|,
name|decimal_pointlen
argument_list|)
expr_stmt|;
block|}
name|amt
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|integerlim
operator|=
name|p
expr_stmt|;
do|do
block|{
name|int
name|digit
init|=
name|amt
operator|%
literal|10
decl_stmt|;
operator|*
operator|--
name|p
operator|=
name|digit
operator|+
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|amt
operator|/=
literal|10
operator|)
operator|!=
literal|0
condition|)
do|;
block|}
name|do_grouping
label|:
if|if
condition|(
name|opts
operator|&
name|human_group_digits
condition|)
name|p
operator|=
name|group_number
argument_list|(
name|p
argument_list|,
name|integerlim
operator|-
name|p
argument_list|,
name|grouping
argument_list|,
name|thousands_sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|&
name|human_SI
condition|)
block|{
if|if
condition|(
name|exponent
operator|<
literal|0
condition|)
block|{
name|uintmax_t
name|power
decl_stmt|;
name|exponent
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|power
operator|=
literal|1
init|;
name|power
operator|<
name|to_block_size
condition|;
name|power
operator|*=
name|base
control|)
if|if
condition|(
operator|++
name|exponent
operator|==
name|exponent_max
condition|)
break|break;
block|}
if|if
condition|(
name|exponent
condition|)
operator|*
name|psuffix
operator|++
operator|=
operator|(
operator|!
operator|(
name|opts
operator|&
name|human_base_1024
operator|)
operator|&&
name|exponent
operator|==
literal|1
condition|?
literal|'k'
else|:
name|power_letter
index|[
name|exponent
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|opts
operator|&
name|human_B
condition|)
block|{
if|if
condition|(
operator|(
name|opts
operator|&
name|human_base_1024
operator|)
operator|&&
name|exponent
condition|)
operator|*
name|psuffix
operator|++
operator|=
literal|'i'
expr_stmt|;
operator|*
name|psuffix
operator|++
operator|=
literal|'B'
expr_stmt|;
block|}
block|}
operator|*
name|psuffix
operator|=
literal|'\0'
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* The default block size used for output.  This number may change in    the future as disks get larger.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_BLOCK_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_BLOCK_SIZE
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|block_size_args
index|[]
init|=
block|{
literal|"human-readable"
block|,
literal|"si"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
specifier|const
name|block_size_opts
index|[]
init|=
block|{
name|human_autoscale
operator|+
name|human_SI
operator|+
name|human_base_1024
block|,
name|human_autoscale
operator|+
name|human_SI
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uintmax_t
name|default_block_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
condition|?
literal|512
else|:
name|DEFAULT_BLOCK_SIZE
return|;
block|}
end_function

begin_function
specifier|static
name|strtol_error
name|humblock
parameter_list|(
name|char
specifier|const
modifier|*
name|spec
parameter_list|,
name|uintmax_t
modifier|*
name|block_size
parameter_list|,
name|int
modifier|*
name|options
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|opts
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|spec
operator|&&
operator|!
operator|(
name|spec
operator|=
name|getenv
argument_list|(
literal|"BLOCK_SIZE"
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|spec
operator|=
name|getenv
argument_list|(
literal|"BLOCKSIZE"
argument_list|)
operator|)
condition|)
operator|*
name|block_size
operator|=
name|default_block_size
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|spec
operator|==
literal|'\''
condition|)
block|{
name|opts
operator||=
name|human_group_digits
expr_stmt|;
name|spec
operator|++
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<=
operator|(
name|i
operator|=
name|ARGMATCH
argument_list|(
name|spec
argument_list|,
name|block_size_args
argument_list|,
name|block_size_opts
argument_list|)
operator|)
condition|)
block|{
name|opts
operator||=
name|block_size_opts
index|[
name|i
index|]
expr_stmt|;
operator|*
name|block_size
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|strtol_error
name|e
init|=
name|xstrtoumax
argument_list|(
name|spec
argument_list|,
operator|&
name|ptr
argument_list|,
literal|0
argument_list|,
name|block_size
argument_list|,
literal|"eEgGkKmMpPtTyYzZ0"
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|!=
name|LONGINT_OK
condition|)
return|return
name|e
return|;
for|for
control|(
init|;
operator|!
operator|(
literal|'0'
operator|<=
operator|*
name|spec
operator|&&
operator|*
name|spec
operator|<=
literal|'9'
operator|)
condition|;
name|spec
operator|++
control|)
if|if
condition|(
name|spec
operator|==
name|ptr
condition|)
block|{
name|opts
operator||=
name|human_SI
expr_stmt|;
if|if
condition|(
name|ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|'B'
condition|)
name|opts
operator||=
name|human_B
expr_stmt|;
if|if
condition|(
name|ptr
index|[
operator|-
literal|1
index|]
operator|!=
literal|'B'
operator|||
name|ptr
index|[
operator|-
literal|2
index|]
operator|==
literal|'i'
condition|)
name|opts
operator||=
name|human_base_1024
expr_stmt|;
break|break;
block|}
block|}
block|}
operator|*
name|options
operator|=
name|opts
expr_stmt|;
return|return
name|LONGINT_OK
return|;
block|}
end_function

begin_function
name|int
name|human_options
parameter_list|(
name|char
specifier|const
modifier|*
name|spec
parameter_list|,
name|bool
name|report_errors
parameter_list|,
name|uintmax_t
modifier|*
name|block_size
parameter_list|)
block|{
name|int
name|opts
decl_stmt|;
name|strtol_error
name|e
init|=
name|humblock
argument_list|(
name|spec
argument_list|,
name|block_size
argument_list|,
operator|&
name|opts
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|block_size
operator|==
literal|0
condition|)
block|{
operator|*
name|block_size
operator|=
name|default_block_size
argument_list|()
expr_stmt|;
name|e
operator|=
name|LONGINT_INVALID
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|!=
name|LONGINT_OK
operator|&&
name|report_errors
condition|)
name|STRTOL_FATAL_ERROR
argument_list|(
name|spec
argument_list|,
name|_
argument_list|(
literal|"block size"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|opts
return|;
block|}
end_function

end_unit

