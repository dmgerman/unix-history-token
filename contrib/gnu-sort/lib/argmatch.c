begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* argmatch.c -- find a match for a string in an array     Copyright (C) 1990, 1998, 1999, 2001, 2002, 2003, 2004 Free    Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Written by David MacKenzie<djm@ai.mit.edu>    Modified by Akim Demaille<demaille@inf.enst.fr> */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Specification.  */
end_comment

begin_include
include|#
directive|include
file|"argmatch.h"
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"gettext.h"
end_include

begin_define
define|#
directive|define
name|_
parameter_list|(
name|msgid
parameter_list|)
value|gettext (msgid)
end_define

begin_include
include|#
directive|include
file|"error.h"
end_include

begin_include
include|#
directive|include
file|"exit.h"
end_include

begin_include
include|#
directive|include
file|"quotearg.h"
end_include

begin_include
include|#
directive|include
file|"quote.h"
end_include

begin_include
include|#
directive|include
file|"unlocked-io.h"
end_include

begin_comment
comment|/* When reporting an invalid argument, show nonprinting characters    by using the quoting style ARGMATCH_QUOTING_STYLE.  Do not use    literal_quoting_style.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ARGMATCH_QUOTING_STYLE
end_ifndef

begin_define
define|#
directive|define
name|ARGMATCH_QUOTING_STYLE
value|locale_quoting_style
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Non failing version of argmatch call this function after failing. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ARGMATCH_DIE
end_ifndef

begin_include
include|#
directive|include
file|"exitfail.h"
end_include

begin_define
define|#
directive|define
name|ARGMATCH_DIE
value|exit (exit_failure)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ARGMATCH_DIE_DECL
end_ifdef

begin_expr_stmt
name|ARGMATCH_DIE_DECL
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|__argmatch_die
parameter_list|(
name|void
parameter_list|)
block|{
name|ARGMATCH_DIE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used by XARGMATCH and XARGCASEMATCH.  See description in argmatch.h.    Default to __argmatch_die, but allow caller to change this at run-time. */
end_comment

begin_decl_stmt
name|argmatch_exit_fn
name|argmatch_die
init|=
name|__argmatch_die
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* If ARG is an unambiguous match for an element of the    null-terminated array ARGLIST, return the index in ARGLIST    of the matched element, else -1 if it does not match any element    or -2 if it is ambiguous (is a prefix of more than one element).     If VALLIST is none null, use it to resolve ambiguities limited to    synonyms, i.e., for      "yes", "yop" -> 0      "no", "nope" -> 1    "y" is a valid argument, for `0', and "n" for `1'.  */
end_comment

begin_function
name|ptrdiff_t
name|argmatch
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|arglist
parameter_list|,
specifier|const
name|char
modifier|*
name|vallist
parameter_list|,
name|size_t
name|valsize
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
comment|/* Temporary index in ARGLIST.  */
name|size_t
name|arglen
decl_stmt|;
comment|/* Length of ARG.  */
name|ptrdiff_t
name|matchind
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Index of first nonexact match.  */
name|bool
name|ambiguous
init|=
name|false
decl_stmt|;
comment|/* If true, multiple nonexact match(es).  */
name|arglen
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Test all elements for either exact match or abbreviated matches.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|arglist
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|arglist
index|[
name|i
index|]
argument_list|,
name|arg
argument_list|,
name|arglen
argument_list|)
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|arglist
index|[
name|i
index|]
argument_list|)
operator|==
name|arglen
condition|)
comment|/* Exact match found.  */
return|return
name|i
return|;
elseif|else
if|if
condition|(
name|matchind
operator|==
operator|-
literal|1
condition|)
comment|/* First nonexact match found.  */
name|matchind
operator|=
name|i
expr_stmt|;
else|else
block|{
comment|/* Second nonexact match found.  */
if|if
condition|(
name|vallist
operator|==
name|NULL
operator|||
name|memcmp
argument_list|(
name|vallist
operator|+
name|valsize
operator|*
name|matchind
argument_list|,
name|vallist
operator|+
name|valsize
operator|*
name|i
argument_list|,
name|valsize
argument_list|)
condition|)
block|{
comment|/* There is a real ambiguity, or we could not 		     disambiguate. */
name|ambiguous
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|ambiguous
condition|)
return|return
operator|-
literal|2
return|;
else|else
return|return
name|matchind
return|;
block|}
end_function

begin_comment
comment|/* Error reporting for argmatch.    CONTEXT is a description of the type of entity that was being matched.    VALUE is the invalid value that was given.    PROBLEM is the return value from argmatch.  */
end_comment

begin_function
name|void
name|argmatch_invalid
parameter_list|(
specifier|const
name|char
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|ptrdiff_t
name|problem
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|format
init|=
operator|(
name|problem
operator|==
operator|-
literal|1
condition|?
name|_
argument_list|(
literal|"invalid argument %s for %s"
argument_list|)
else|:
name|_
argument_list|(
literal|"ambiguous argument %s for %s"
argument_list|)
operator|)
decl_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
name|quotearg_n_style
argument_list|(
literal|0
argument_list|,
name|ARGMATCH_QUOTING_STYLE
argument_list|,
name|value
argument_list|)
argument_list|,
name|quote_n
argument_list|(
literal|1
argument_list|,
name|context
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* List the valid arguments for argmatch.    ARGLIST is the same as in argmatch.    VALLIST is a pointer to an array of values.    VALSIZE is the size of the elements of VALLIST */
end_comment

begin_function
name|void
name|argmatch_valid
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|arglist
parameter_list|,
specifier|const
name|char
modifier|*
name|vallist
parameter_list|,
name|size_t
name|valsize
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_val
init|=
name|NULL
decl_stmt|;
comment|/* We try to put synonyms on the same line.  The assumption is that      synonyms follow each other */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Valid arguments are:"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|arglist
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|||
name|memcmp
argument_list|(
name|last_val
argument_list|,
name|vallist
operator|+
name|valsize
operator|*
name|i
argument_list|,
name|valsize
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n  - `%s'"
argument_list|,
name|arglist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|last_val
operator|=
name|vallist
operator|+
name|valsize
operator|*
name|i
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", `%s'"
argument_list|,
name|arglist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Never failing versions of the previous functions.     CONTEXT is the context for which argmatch is called (e.g.,    "--version-control", or "$VERSION_CONTROL" etc.).  Upon failure,    calls the (supposed never to return) function EXIT_FN. */
end_comment

begin_function
name|ptrdiff_t
name|__xargmatch_internal
parameter_list|(
specifier|const
name|char
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|arglist
parameter_list|,
specifier|const
name|char
modifier|*
name|vallist
parameter_list|,
name|size_t
name|valsize
parameter_list|,
name|argmatch_exit_fn
name|exit_fn
parameter_list|)
block|{
name|ptrdiff_t
name|res
init|=
name|argmatch
argument_list|(
name|arg
argument_list|,
name|arglist
argument_list|,
name|vallist
argument_list|,
name|valsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|>=
literal|0
condition|)
comment|/* Success. */
return|return
name|res
return|;
comment|/* We failed.  Explain why. */
name|argmatch_invalid
argument_list|(
name|context
argument_list|,
name|arg
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|argmatch_valid
argument_list|(
name|arglist
argument_list|,
name|vallist
argument_list|,
name|valsize
argument_list|)
expr_stmt|;
call|(
modifier|*
name|exit_fn
call|)
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* To please the compilers. */
block|}
end_function

begin_comment
comment|/* Look for VALUE in VALLIST, an array of objects of size VALSIZE and    return the first corresponding argument in ARGLIST */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|argmatch_to_argument
parameter_list|(
specifier|const
name|char
modifier|*
name|value
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|arglist
parameter_list|,
specifier|const
name|char
modifier|*
name|vallist
parameter_list|,
name|size_t
name|valsize
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|arglist
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|value
argument_list|,
name|vallist
operator|+
name|valsize
operator|*
name|i
argument_list|,
name|valsize
argument_list|)
condition|)
return|return
name|arglist
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_comment
comment|/*  * Based on "getversion.c" by David MacKenzie<djm@gnu.ai.mit.edu>  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When to make backup files.  */
end_comment

begin_enum
enum|enum
name|backup_type
block|{
comment|/* Never make backups.  */
name|none
block|,
comment|/* Make simple backups of every file.  */
name|simple
block|,
comment|/* Make numbered backups of files that already have numbered backups,      and simple backups of the others.  */
name|numbered_existing
block|,
comment|/* Make numbered backups of every file.  */
name|numbered
block|}
enum|;
end_enum

begin_comment
comment|/* Two tables describing arguments (keys) and their corresponding    values */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|backup_args
index|[]
init|=
block|{
literal|"no"
block|,
literal|"none"
block|,
literal|"off"
block|,
literal|"simple"
block|,
literal|"never"
block|,
literal|"existing"
block|,
literal|"nil"
block|,
literal|"numbered"
block|,
literal|"t"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|backup_type
name|backup_vals
index|[]
init|=
block|{
name|none
block|,
name|none
block|,
name|none
block|,
name|simple
block|,
name|simple
block|,
name|numbered_existing
block|,
name|numbered_existing
block|,
name|numbered
block|,
name|numbered
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|enum
name|backup_type
name|backup_type
init|=
name|none
decl_stmt|;
name|program_name
operator|=
operator|(
name|char
operator|*
operator|)
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [VERSION_CONTROL]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"VERSION_CONTROL"
argument_list|)
operator|)
condition|)
name|backup_type
operator|=
name|XARGMATCH
argument_list|(
literal|"$VERSION_CONTROL"
argument_list|,
name|cp
argument_list|,
name|backup_args
argument_list|,
name|backup_vals
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
name|backup_type
operator|=
name|XARGMATCH
argument_list|(
name|program_name
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|backup_args
argument_list|,
name|backup_vals
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"The version control is `%s'\n"
argument_list|,
name|ARGMATCH_TO_ARGUMENT
argument_list|(
name|backup_type
argument_list|,
name|backup_args
argument_list|,
name|backup_vals
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

