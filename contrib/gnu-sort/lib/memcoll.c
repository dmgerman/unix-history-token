begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Locale-specific memory comparison.    Copyright (C) 1999, 2002, 2003, 2004 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Contributed by Paul Eggert<eggert@twinsun.com>.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"memcoll.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* Compare S1 (with length S1LEN) and S2 (with length S2LEN) according    to the LC_COLLATE locale.  S1 and S2 do not overlap, and are not    adjacent.  Perhaps temporarily modify the bytes after S1 and S2,    but restore their original contents before returning.  Set errno to an    error number if there is an error, and to zero otherwise.  */
end_comment

begin_function
name|int
name|memcoll
parameter_list|(
name|char
modifier|*
name|s1
parameter_list|,
name|size_t
name|s1len
parameter_list|,
name|char
modifier|*
name|s2
parameter_list|,
name|size_t
name|s2len
parameter_list|)
block|{
name|int
name|diff
decl_stmt|;
if|#
directive|if
name|HAVE_STRCOLL
name|char
name|n1
init|=
name|s1
index|[
name|s1len
index|]
decl_stmt|;
name|char
name|n2
init|=
name|s2
index|[
name|s2len
index|]
decl_stmt|;
name|s1
index|[
name|s1len
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s2
index|[
name|s2len
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|errno
operator|=
literal|0
operator|,
operator|(
name|diff
operator|=
name|strcoll
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
operator|)
operator|||
name|errno
operator|)
condition|)
block|{
comment|/* strcoll found no difference, but perhaps it was fooled by NUL 	 characters in the data.  Work around this problem by advancing 	 past the NUL chars.  */
name|size_t
name|size1
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
literal|1
decl_stmt|;
name|size_t
name|size2
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
literal|1
decl_stmt|;
name|s1
operator|+=
name|size1
expr_stmt|;
name|s2
operator|+=
name|size2
expr_stmt|;
name|s1len
operator|-=
name|size1
expr_stmt|;
name|s2len
operator|-=
name|size2
expr_stmt|;
if|if
condition|(
name|s1len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s2len
operator|!=
literal|0
condition|)
name|diff
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|s2len
operator|==
literal|0
condition|)
block|{
name|diff
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|s1
index|[
name|s1len
operator|-
literal|1
index|]
operator|=
name|n1
expr_stmt|;
name|s2
index|[
name|s2len
operator|-
literal|1
index|]
operator|=
name|n2
expr_stmt|;
else|#
directive|else
name|diff
operator|=
name|memcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|s1len
operator|<
name|s2len
condition|?
name|s1len
else|:
name|s2len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|diff
condition|)
name|diff
operator|=
name|s1len
operator|<
name|s2len
condition|?
operator|-
literal|1
else|:
name|s1len
operator|!=
name|s2len
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|diff
return|;
block|}
end_function

end_unit

