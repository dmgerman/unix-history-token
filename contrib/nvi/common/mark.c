begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1992, 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)mark.c	10.13 (Berkeley) 7/19/96"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_decl_stmt
specifier|static
name|LMARK
modifier|*
name|mark_find
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|ARG_CHAR_T
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Marks are maintained in a key sorted doubly linked list.  We can't  * use arrays because we have no idea how big an index key could be.  * The underlying assumption is that users don't have more than, say,  * 10 marks at any one time, so this will be is fast enough.  *  * Marks are fixed, and modifications to the line don't update the mark's  * position in the line.  This can be hard.  If you add text to the line,  * place a mark in that text, undo the addition and use ` to move to the  * mark, the location will have disappeared.  It's tempting to try to adjust  * the mark with the changes in the line, but this is hard to do, especially  * if we've given the line to v_ntext.c:v_ntext() for editing.  Historic vi  * would move to the first non-blank on the line when the mark location was  * past the end of the line.  This can be complicated by deleting to a mark  * that has disappeared using the ` command.  Historic vi treated this as  * a line-mode motion and deleted the line.  This implementation complains to  * the user.  *  * In historic vi, marks returned if the operation was undone, unless the  * mark had been subsequently reset.  Tricky.  This is hard to start with,  * but in the presence of repeated undo it gets nasty.  When a line is  * deleted, we delete (and log) any marks on that line.  An undo will create  * the mark.  Any mark creations are noted as to whether the user created  * it or if it was created by an undo.  The former cannot be reset by another  * undo, but the latter may.  *  * All of these routines translate ABSMARK2 to ABSMARK1.  Setting either of  * the absolute mark locations sets both, so that "m'" and "m`" work like  * they, ah, for lack of a better word, "should".  */
end_comment

begin_comment
comment|/*  * mark_init --  *	Set up the marks.  *  * PUBLIC: int mark_init __P((SCR *, EXF *));  */
end_comment

begin_function
name|int
name|mark_init
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
comment|/* 	 * !!! 	 * ep MAY NOT BE THE SAME AS sp->ep, DON'T USE THE LATTER. 	 * 	 * Set up the marks. 	 */
name|LIST_INIT
argument_list|(
operator|&
name|ep
operator|->
name|marks
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mark_end --  *	Free up the marks.  *  * PUBLIC: int mark_end __P((SCR *, EXF *));  */
end_comment

begin_function
name|int
name|mark_end
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
name|LMARK
modifier|*
name|lmp
decl_stmt|;
comment|/* 	 * !!! 	 * ep MAY NOT BE THE SAME AS sp->ep, DON'T USE THE LATTER. 	 */
while|while
condition|(
operator|(
name|lmp
operator|=
name|ep
operator|->
name|marks
operator|.
name|lh_first
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|lmp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lmp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mark_get --  *	Get the location referenced by a mark.  *  * PUBLIC: int mark_get __P((SCR *, ARG_CHAR_T, MARK *, mtype_t));  */
end_comment

begin_function
name|int
name|mark_get
parameter_list|(
name|sp
parameter_list|,
name|key
parameter_list|,
name|mp
parameter_list|,
name|mtype
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|ARG_CHAR_T
name|key
decl_stmt|;
name|MARK
modifier|*
name|mp
decl_stmt|;
name|mtype_t
name|mtype
decl_stmt|;
block|{
name|LMARK
modifier|*
name|lmp
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|ABSMARK2
condition|)
name|key
operator|=
name|ABSMARK1
expr_stmt|;
name|lmp
operator|=
name|mark_find
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|==
name|NULL
operator|||
name|lmp
operator|->
name|name
operator|!=
name|key
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|mtype
argument_list|,
literal|"017|Mark %s: not set"
argument_list|,
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|F_ISSET
argument_list|(
name|lmp
argument_list|,
name|MARK_DELETED
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|mtype
argument_list|,
literal|"018|Mark %s: the line was deleted"
argument_list|,
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * !!! 	 * The absolute mark is initialized to lno 1/cno 0, and historically 	 * you could use it in an empty file.  Make such a mark always work. 	 */
if|if
condition|(
operator|(
name|lmp
operator|->
name|lno
operator|!=
literal|1
operator|||
name|lmp
operator|->
name|cno
operator|!=
literal|0
operator|)
operator|&&
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
name|lmp
operator|->
name|lno
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|mtype
argument_list|,
literal|"019|Mark %s: cursor position no longer exists"
argument_list|,
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|mp
operator|->
name|lno
operator|=
name|lmp
operator|->
name|lno
expr_stmt|;
name|mp
operator|->
name|cno
operator|=
name|lmp
operator|->
name|cno
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mark_set --  *	Set the location referenced by a mark.  *  * PUBLIC: int mark_set __P((SCR *, ARG_CHAR_T, MARK *, int));  */
end_comment

begin_function
name|int
name|mark_set
parameter_list|(
name|sp
parameter_list|,
name|key
parameter_list|,
name|value
parameter_list|,
name|userset
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|ARG_CHAR_T
name|key
decl_stmt|;
name|MARK
modifier|*
name|value
decl_stmt|;
name|int
name|userset
decl_stmt|;
block|{
name|LMARK
modifier|*
name|lmp
decl_stmt|,
modifier|*
name|lmt
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|ABSMARK2
condition|)
name|key
operator|=
name|ABSMARK1
expr_stmt|;
comment|/* 	 * The rules are simple.  If the user is setting a mark (if it's a 	 * new mark this is always true), it always happens.  If not, it's 	 * an undo, and we set it if it's not already set or if it was set 	 * by a previous undo. 	 */
name|lmp
operator|=
name|mark_find
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|==
name|NULL
operator|||
name|lmp
operator|->
name|name
operator|!=
name|key
condition|)
block|{
name|MALLOC_RET
argument_list|(
name|sp
argument_list|,
name|lmt
argument_list|,
name|LMARK
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|LMARK
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sp
operator|->
name|ep
operator|->
name|marks
argument_list|,
name|lmt
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|LIST_INSERT_AFTER
argument_list|(
name|lmp
argument_list|,
name|lmt
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|lmp
operator|=
name|lmt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|userset
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|lmp
argument_list|,
name|MARK_DELETED
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|lmp
argument_list|,
name|MARK_USERSET
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lmp
operator|->
name|lno
operator|=
name|value
operator|->
name|lno
expr_stmt|;
name|lmp
operator|->
name|cno
operator|=
name|value
operator|->
name|cno
expr_stmt|;
name|lmp
operator|->
name|name
operator|=
name|key
expr_stmt|;
name|lmp
operator|->
name|flags
operator|=
name|userset
condition|?
name|MARK_USERSET
else|:
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mark_find --  *	Find the requested mark, or, the slot immediately before  *	where it would go.  */
end_comment

begin_function
specifier|static
name|LMARK
modifier|*
name|mark_find
parameter_list|(
name|sp
parameter_list|,
name|key
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|ARG_CHAR_T
name|key
decl_stmt|;
block|{
name|LMARK
modifier|*
name|lmp
decl_stmt|,
modifier|*
name|lastlmp
decl_stmt|;
comment|/* 	 * Return the requested mark or the slot immediately before 	 * where it should go. 	 */
for|for
control|(
name|lastlmp
operator|=
name|NULL
operator|,
name|lmp
operator|=
name|sp
operator|->
name|ep
operator|->
name|marks
operator|.
name|lh_first
init|;
name|lmp
operator|!=
name|NULL
condition|;
name|lastlmp
operator|=
name|lmp
operator|,
name|lmp
operator|=
name|lmp
operator|->
name|q
operator|.
name|le_next
control|)
if|if
condition|(
name|lmp
operator|->
name|name
operator|>=
name|key
condition|)
return|return
operator|(
name|lmp
operator|->
name|name
operator|==
name|key
condition|?
name|lmp
else|:
name|lastlmp
operator|)
return|;
return|return
operator|(
name|lastlmp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mark_insdel --  *	Update the marks based on an insertion or deletion.  *  * PUBLIC: int mark_insdel __P((SCR *, lnop_t, recno_t));  */
end_comment

begin_function
name|int
name|mark_insdel
parameter_list|(
name|sp
parameter_list|,
name|op
parameter_list|,
name|lno
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|lnop_t
name|op
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
block|{
name|LMARK
modifier|*
name|lmp
decl_stmt|;
name|recno_t
name|lline
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|LINE_APPEND
case|:
comment|/* All insert/append operations are done as inserts. */
name|abort
argument_list|()
expr_stmt|;
case|case
name|LINE_DELETE
case|:
for|for
control|(
name|lmp
operator|=
name|sp
operator|->
name|ep
operator|->
name|marks
operator|.
name|lh_first
init|;
name|lmp
operator|!=
name|NULL
condition|;
name|lmp
operator|=
name|lmp
operator|->
name|q
operator|.
name|le_next
control|)
if|if
condition|(
name|lmp
operator|->
name|lno
operator|>=
name|lno
condition|)
if|if
condition|(
name|lmp
operator|->
name|lno
operator|==
name|lno
condition|)
block|{
name|F_SET
argument_list|(
name|lmp
argument_list|,
name|MARK_DELETED
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|log_mark
argument_list|(
name|sp
argument_list|,
name|lmp
argument_list|)
expr_stmt|;
block|}
else|else
operator|--
name|lmp
operator|->
name|lno
expr_stmt|;
break|break;
case|case
name|LINE_INSERT
case|:
comment|/* 		 * XXX 		 * Very nasty special case.  If the file was empty, then we're 		 * adding the first line, which is a replacement.  So, we don't 		 * modify the marks.  This is a hack to make: 		 * 		 *	mz:r!echo foo<carriage-return>'z 		 * 		 * work, i.e. historically you could mark the "line" in an empty 		 * file and replace it, and continue to use the mark.  Insane, 		 * well, yes, I know, but someone complained. 		 * 		 * Check for line #2 before going to the end of the file. 		 */
if|if
condition|(
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|lline
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|lline
operator|==
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|lmp
operator|=
name|sp
operator|->
name|ep
operator|->
name|marks
operator|.
name|lh_first
init|;
name|lmp
operator|!=
name|NULL
condition|;
name|lmp
operator|=
name|lmp
operator|->
name|q
operator|.
name|le_next
control|)
if|if
condition|(
name|lmp
operator|->
name|lno
operator|>=
name|lno
condition|)
operator|++
name|lmp
operator|->
name|lno
expr_stmt|;
break|break;
case|case
name|LINE_RESET
case|:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

