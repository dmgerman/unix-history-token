begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"$Id: recover.c,v 11.2 2012/10/09 08:06:58 zy Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/*  * We include<sys/file.h>, because the open #defines were found there  * on historical systems.  We also include<fcntl.h> because the open(2)  * #defines are found there on newer systems.  */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_comment
comment|/* Required by resolv.h. */
end_comment

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"../ex/version.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_comment
comment|/*  * Recovery code.  *  * The basic scheme is as follows.  In the EXF structure, we maintain full  * paths of a b+tree file and a mail recovery file.  The former is the file  * used as backing store by the DB package.  The latter is the file that  * contains an email message to be sent to the user if we crash.  The two  * simple states of recovery are:  *  *	+ first starting the edit session:  *		the b+tree file exists and is mode 700, the mail recovery  *		file doesn't exist.  *	+ after the file has been modified:  *		the b+tree file exists and is mode 600, the mail recovery  *		file exists, and is exclusively locked.  *  * In the EXF structure we maintain a file descriptor that is the locked  * file descriptor for the mail recovery file.  *  * To find out if a recovery file/backing file pair are in use, try to get  * a lock on the recovery file.  *  * To find out if a backing file can be deleted at boot time, check for an  * owner execute bit.  (Yes, I know it's ugly, but it's either that or put  * special stuff into the backing file itself, or correlate the files at  * boot time, neither of which looks like fun.)  Note also that there's a  * window between when the file is created and the X bit is set.  It's small,  * but it's there.  To fix the window, check for 0 length files as well.  *  * To find out if a file can be recovered, check the F_RCV_ON bit.  Note,  * this DOES NOT mean that any initialization has been done, only that we  * haven't yet failed at setting up or doing recovery.  *  * To preserve a recovery file/backing file pair, set the F_RCV_NORM bit.  * If that bit is not set when ending a file session:  *	If the EXF structure paths (rcv_path and rcv_mpath) are not NULL,  *	they are unlink(2)'d, and free(3)'d.  *	If the EXF file descriptor (rcv_fd) is not -1, it is closed.  *  * The backing b+tree file is set up when a file is first edited, so that  * the DB package can use it for on-disk caching and/or to snapshot the  * file.  When the file is first modified, the mail recovery file is created,  * the backing file permissions are updated, the file is sync(2)'d to disk,  * and the timer is started.  Then, at RCV_PERIOD second intervals, the  * b+tree file is synced to disk.  RCV_PERIOD is measured using SIGALRM, which  * means that the data structures (SCR, EXF, the underlying tree structures)  * must be consistent when the signal arrives.  *  * The recovery mail file contains normal mail headers, with two additional  *  *	X-vi-data:<file|path>;<base64 encoded path>  *  * MIME headers; the folding character is limited to ' '.  *  * Btree files are named "vi.XXXXXX" and recovery files are named  * "recover.XXXXXX".  */
end_comment

begin_define
define|#
directive|define
name|VI_DHEADER
value|"X-vi-data:"
end_define

begin_decl_stmt
specifier|static
name|int
name|rcv_copy
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rcv_email
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rcv_mailfile
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rcv_mktemp
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rcv_dlnwrite
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rcv_dlnread
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * rcv_tmp --  *	Build a file name that will be used as the recovery file.  *  * PUBLIC: int rcv_tmp __P((SCR *, EXF *, char *));  */
end_comment

begin_function
name|int
name|rcv_tmp
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EXF
modifier|*
name|ep
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|,
modifier|*
name|path
decl_stmt|;
comment|/* 	 * !!! 	 * ep MAY NOT BE THE SAME AS sp->ep, DON'T USE THE LATTER. 	 * 	 * 	 * If the recovery directory doesn't exist, try and create it.  As 	 * the recovery files are themselves protected from reading/writing 	 * by other than the owner, the worst that can happen is that a user 	 * would have permission to remove other user's recovery files.  If 	 * the sticky bit has the BSD semantics, that too will be impossible. 	 */
if|if
condition|(
name|opts_empty
argument_list|(
name|sp
argument_list|,
name|O_RECDIR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|dp
operator|=
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_RECDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dp
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
operator|||
name|mkdir
argument_list|(
name|dp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"%s"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|dp
argument_list|,
name|S_IRWXU
operator||
name|S_IRWXG
operator||
name|S_IRWXO
operator||
name|S_ISVTX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|path
operator|=
name|join
argument_list|(
name|dp
argument_list|,
literal|"vi.XXXXXX"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|(
name|fd
operator|=
name|rcv_mktemp
argument_list|(
name|sp
argument_list|,
name|path
argument_list|,
name|dp
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|(
name|void
operator|)
name|fchmod
argument_list|(
name|fd
argument_list|,
name|S_IRWXU
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|ep
operator|->
name|rcv_path
operator|=
name|path
expr_stmt|;
if|if
condition|(
literal|0
condition|)
block|{
name|err
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"056|Modifications not recoverable if the session fails"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* We believe the file is recoverable. */
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_RCV_ON
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rcv_init --  *	Force the file to be snapshotted for recovery.  *  * PUBLIC: int rcv_init __P((SCR *));  */
end_comment

begin_function
name|int
name|rcv_init
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|EXF
modifier|*
name|ep
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
comment|/* Only do this once. */
name|F_CLR
argument_list|(
name|ep
argument_list|,
name|F_FIRSTMODIFY
argument_list|)
expr_stmt|;
comment|/* If we already know the file isn't recoverable, we're done. */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_RCV_ON
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Turn off recoverability until we figure out if this will work. */
name|F_CLR
argument_list|(
name|ep
argument_list|,
name|F_RCV_ON
argument_list|)
expr_stmt|;
comment|/* Test if we're recovering a file, not editing one. */
if|if
condition|(
name|ep
operator|->
name|rcv_mpath
operator|==
name|NULL
condition|)
block|{
comment|/* Build a file to mail to the user. */
if|if
condition|(
name|rcv_mailfile
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Force a read of the entire file. */
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Turn on a busy message, and sync it to backing store. */
name|sp
operator|->
name|gp
operator|->
name|scr_busy
argument_list|(
name|sp
argument_list|,
literal|"057|Copying file for recovery..."
argument_list|,
name|BUSY_ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|db
operator|->
name|sync
argument_list|(
name|ep
operator|->
name|db
argument_list|,
name|R_RECNOSYNC
argument_list|)
condition|)
block|{
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|ep
operator|->
name|rcv_path
argument_list|,
literal|"058|Preservation failed: %s"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|gp
operator|->
name|scr_busy
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|BUSY_OFF
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|sp
operator|->
name|gp
operator|->
name|scr_busy
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|BUSY_OFF
argument_list|)
expr_stmt|;
block|}
comment|/* Turn off the owner execute bit. */
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|ep
operator|->
name|rcv_path
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|)
expr_stmt|;
comment|/* We believe the file is recoverable. */
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_RCV_ON
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"059|Modifications not recoverable if the session fails"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rcv_sync --  *	Sync the file, optionally:  *		flagging the backup file to be preserved  *		snapshotting the backup file and send email to the user  *		sending email to the user if the file was modified  *		ending the file session  *  * PUBLIC: int rcv_sync __P((SCR *, u_int));  */
end_comment

begin_function
name|int
name|rcv_sync
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|EXF
modifier|*
name|ep
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|rval
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
comment|/* Make sure that there's something to recover/sync. */
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
operator|||
operator|!
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_RCV_ON
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Sync the file if it's been modified. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
condition|)
block|{
name|SIGBLOCK
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|db
operator|->
name|sync
argument_list|(
name|ep
operator|->
name|db
argument_list|,
name|R_RECNOSYNC
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|ep
argument_list|,
name|F_RCV_ON
operator||
name|F_RCV_NORM
argument_list|)
expr_stmt|;
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|ep
operator|->
name|rcv_path
argument_list|,
literal|"060|File backup failed: %s"
argument_list|)
expr_stmt|;
name|SIGUNBLOCK
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|SIGUNBLOCK
expr_stmt|;
comment|/* REQUEST: don't remove backing file on exit. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|RCV_PRESERVE
argument_list|)
condition|)
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_RCV_NORM
argument_list|)
expr_stmt|;
comment|/* REQUEST: send email. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|RCV_EMAIL
argument_list|)
condition|)
name|rcv_email
argument_list|(
name|sp
argument_list|,
name|ep
operator|->
name|rcv_mpath
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * !!! 	 * Each time the user exec's :preserve, we have to snapshot all of 	 * the recovery information, i.e. it's like the user re-edited the 	 * file.  We copy the DB(3) backing file, and then create a new mail 	 * recovery file, it's simpler than exiting and reopening all of the 	 * underlying files. 	 * 	 * REQUEST: snapshot the file. 	 */
name|rval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|RCV_SNAPSHOT
argument_list|)
condition|)
block|{
if|if
condition|(
name|opts_empty
argument_list|(
name|sp
argument_list|,
name|O_RECDIR
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|dp
operator|=
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_RECDIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|join
argument_list|(
name|dp
argument_list|,
literal|"vi.XXXXXX"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|rcv_mktemp
argument_list|(
name|sp
argument_list|,
name|buf
argument_list|,
name|dp
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|sp
operator|->
name|gp
operator|->
name|scr_busy
argument_list|(
name|sp
argument_list|,
literal|"061|Copying file for recovery..."
argument_list|,
name|BUSY_ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcv_copy
argument_list|(
name|sp
argument_list|,
name|fd
argument_list|,
name|ep
operator|->
name|rcv_path
argument_list|)
operator|||
name|close
argument_list|(
name|fd
argument_list|)
operator|||
name|rcv_mailfile
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|,
name|buf
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sp
operator|->
name|gp
operator|->
name|scr_busy
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|BUSY_OFF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
condition|)
block|{
name|err
label|:
name|rval
operator|=
literal|1
expr_stmt|;
block|}
comment|/* REQUEST: end the file session. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|RCV_ENDSESSION
argument_list|)
operator|&&
name|file_end
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
condition|)
name|rval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rcv_mailfile --  *	Build the file to mail to the user.  */
end_comment

begin_function
specifier|static
name|int
name|rcv_mailfile
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|int
name|issync
parameter_list|,
name|char
modifier|*
name|cp_path
parameter_list|)
block|{
name|EXF
modifier|*
name|ep
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|int
name|len
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|qt
decl_stmt|,
modifier|*
name|buf
decl_stmt|,
modifier|*
name|mpath
decl_stmt|;
name|char
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|,
modifier|*
name|t3
decl_stmt|;
name|int
name|st
decl_stmt|;
comment|/* 	 * XXX 	 * MAXHOSTNAMELEN/HOST_NAME_MAX are deprecated. We try sysconf(3) 	 * first, then fallback to _POSIX_HOST_NAME_MAX. 	 */
name|char
modifier|*
name|host
decl_stmt|;
name|long
name|hostmax
init|=
name|sysconf
argument_list|(
name|_SC_HOST_NAME_MAX
argument_list|)
decl_stmt|;
if|if
condition|(
name|hostmax
operator|<
literal|0
condition|)
name|hostmax
operator|=
name|_POSIX_HOST_NAME_MAX
expr_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwuid
argument_list|(
name|uid
operator|=
name|getuid
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"062|Information on user id %u not found"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|opts_empty
argument_list|(
name|sp
argument_list|,
name|O_RECDIR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|dp
operator|=
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_RECDIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mpath
operator|=
name|join
argument_list|(
name|dp
argument_list|,
literal|"recover.XXXXXX"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|rcv_mktemp
argument_list|(
name|sp
argument_list|,
name|mpath
argument_list|,
name|dp
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|mpath
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|mpath
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * XXX 	 * We keep an open lock on the file so that the recover option can 	 * distinguish between files that are live and those that need to 	 * be recovered.  There's an obvious window between the mkstemp call 	 * and the lock, but it's pretty small. 	 */
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
if|if
condition|(
name|file_lock
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|fd
argument_list|,
literal|1
argument_list|)
operator|!=
name|LOCK_SUCCESS
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"063|Unable to lock recovery file"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|issync
condition|)
block|{
comment|/* Save the recover file descriptor, and mail path. */
name|ep
operator|->
name|rcv_fd
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|ep
operator|->
name|rcv_mpath
operator|=
name|mpath
expr_stmt|;
name|cp_path
operator|=
name|ep
operator|->
name|rcv_path
expr_stmt|;
block|}
name|t
operator|=
name|sp
operator|->
name|frp
operator|->
name|name
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|t
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|p
operator|=
name|t
expr_stmt|;
else|else
operator|++
name|p
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|=
name|rcv_dlnwrite
argument_list|(
name|sp
argument_list|,
literal|"file"
argument_list|,
name|t
argument_list|,
name|fp
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|st
operator|==
literal|1
condition|)
goto|goto
name|werr
goto|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|st
operator|=
name|rcv_dlnwrite
argument_list|(
name|sp
argument_list|,
literal|"path"
argument_list|,
name|cp_path
argument_list|,
name|fp
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|st
operator|==
literal|1
condition|)
goto|goto
name|werr
goto|;
goto|goto
name|err
goto|;
block|}
name|MALLOC
argument_list|(
name|sp
argument_list|,
name|host
argument_list|,
name|char
operator|*
argument_list|,
name|hostmax
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
operator|(
name|void
operator|)
name|gethostname
argument_list|(
name|host
argument_list|,
name|hostmax
operator|+
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s%s%s\n%s%s%s%s\n%s%.40s\n%s\n\n"
argument_list|,
literal|"From: root@"
argument_list|,
name|host
argument_list|,
literal|" (Nvi recovery program)"
argument_list|,
literal|"To: "
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
literal|"@"
argument_list|,
name|host
argument_list|,
literal|"Subject: Nvi saved the file "
argument_list|,
name|p
argument_list|,
literal|"Precedence: bulk"
argument_list|)
expr_stmt|;
comment|/* For vacation(1). */
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|host
argument_list|)
expr_stmt|;
goto|goto
name|werr
goto|;
block|}
if|if
condition|(
operator|(
name|qt
operator|=
name|quote
argument_list|(
name|t
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|len
operator|=
name|asprintf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"%s%.24s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n\n"
argument_list|,
literal|"On "
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|,
literal|", the user "
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
literal|" was editing a file named "
argument_list|,
name|t
argument_list|,
literal|" on the machine "
argument_list|,
name|host
argument_list|,
literal|", when it was saved for recovery. "
argument_list|,
literal|"You can recover most, if not all, of the changes "
argument_list|,
literal|"to this file using the -r option to "
argument_list|,
name|gp
operator|->
name|progname
argument_list|,
literal|":\n\n\t"
argument_list|,
name|gp
operator|->
name|progname
argument_list|,
literal|" -r "
argument_list|,
name|qt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|qt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 	 * Format the message.  (Yes, I know it's silly.) 	 * Requires that the message end in a<newline>. 	 */
define|#
directive|define
name|FMTCOLS
value|60
for|for
control|(
name|t1
operator|=
name|buf
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
name|t2
operator|-
name|t1
operator|,
name|t1
operator|=
name|t2
control|)
block|{
comment|/* Check for a short length. */
if|if
condition|(
name|len
operator|<=
name|FMTCOLS
condition|)
block|{
name|t2
operator|=
name|t1
operator|+
operator|(
name|len
operator|-
literal|1
operator|)
expr_stmt|;
goto|goto
name|wout
goto|;
block|}
comment|/* Check for a required<newline>. */
name|t2
operator|=
name|strchr
argument_list|(
name|t1
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|-
name|t1
operator|<=
name|FMTCOLS
condition|)
goto|goto
name|wout
goto|;
comment|/* Find the closest space, if any. */
for|for
control|(
name|t3
operator|=
name|t2
init|;
name|t2
operator|>
name|t1
condition|;
operator|--
name|t2
control|)
if|if
condition|(
operator|*
name|t2
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
name|t2
operator|-
name|t1
operator|<=
name|FMTCOLS
condition|)
goto|goto
name|wout
goto|;
name|t3
operator|=
name|t2
expr_stmt|;
block|}
name|t2
operator|=
name|t3
expr_stmt|;
comment|/* t2 points to the last character to display. */
name|wout
label|:
operator|*
name|t2
operator|++
operator|=
literal|'\n'
expr_stmt|;
comment|/* t2 points one after the last character to display. */
if|if
condition|(
name|fwrite
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|,
name|t2
operator|-
name|t1
argument_list|,
name|fp
argument_list|)
operator|!=
name|t2
operator|-
name|t1
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|werr
goto|;
block|}
block|}
if|if
condition|(
name|issync
condition|)
block|{
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|rcv_email
argument_list|(
name|sp
argument_list|,
name|mpath
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mpath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|werr
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"065|Recovery file"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
if|if
condition|(
operator|!
name|issync
condition|)
name|ep
operator|->
name|rcv_fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	people making love  *	never exactly the same  *	just like a snowflake  *  * rcv_list --  *	List the files that can be recovered by this user.  *  * PUBLIC: int rcv_list __P((SCR *));  */
end_comment

begin_function
name|int
name|rcv_list
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|found
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|file
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|dtype
decl_stmt|,
modifier|*
name|data
decl_stmt|;
name|int
name|st
decl_stmt|;
comment|/* Open the recovery directory for reading. */
if|if
condition|(
name|opts_empty
argument_list|(
name|sp
argument_list|,
name|O_RECDIR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|p
operator|=
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_RECDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|p
argument_list|)
operator|||
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|p
argument_list|,
literal|"recdir: %s"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Read the directory. */
for|for
control|(
name|found
operator|=
literal|0
init|;
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"recover."
argument_list|,
literal|8
argument_list|)
condition|)
continue|continue;
comment|/* If it's readable, it's recoverable. */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
switch|switch
condition|(
name|file_lock
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|LOCK_FAILED
case|:
comment|/* 			 * XXX 			 * Assume that a lock can't be acquired, but that we 			 * should permit recovery anyway.  If this is wrong, 			 * and someone else is using the file, we're going to 			 * die horribly. 			 */
break|break;
case|case
name|LOCK_SUCCESS
case|:
break|break;
case|case
name|LOCK_UNAVAIL
case|:
comment|/* If it's locked, it's live. */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Check the headers. */
for|for
control|(
name|file
operator|=
name|NULL
operator|,
name|path
operator|=
name|NULL
init|;
name|file
operator|==
name|NULL
operator|||
name|path
operator|==
name|NULL
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|st
operator|=
name|rcv_dlnread
argument_list|(
name|sp
argument_list|,
operator|&
name|dtype
argument_list|,
operator|&
name|data
argument_list|,
name|fp
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|st
operator|==
literal|1
condition|)
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
literal|"066|%s: malformed recovery file"
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|dtype
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dtype
argument_list|,
literal|"file"
argument_list|)
condition|)
name|file
operator|=
name|data
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dtype
argument_list|,
literal|"path"
argument_list|)
condition|)
name|path
operator|=
name|data
expr_stmt|;
else|else
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the file doesn't exist, it's an orphaned recovery file, 		 * toss it. 		 * 		 * XXX 		 * This can occur if the backup file was deleted and we crashed 		 * before deleting the email file. 		 */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sb
argument_list|)
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* Get the last modification time and display. */
operator|(
name|void
operator|)
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%.24s: %s\n"
argument_list|,
name|ctime
argument_list|(
operator|&
name|sb
operator|.
name|st_mtime
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
comment|/* Close, discarding lock. */
name|next
label|:
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: No files to recover\n"
argument_list|,
name|sp
operator|->
name|gp
operator|->
name|progname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rcv_read --  *	Start a recovered file as the file to edit.  *  * PUBLIC: int rcv_read __P((SCR *, FREF *));  */
end_comment

begin_function
name|int
name|rcv_read
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|FREF
modifier|*
name|frp
parameter_list|)
block|{
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|struct
name|timespec
name|rec_mtim
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|found
decl_stmt|,
name|locked
init|=
literal|0
decl_stmt|,
name|requested
decl_stmt|,
name|sv_fd
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|rp
decl_stmt|,
modifier|*
name|recp
decl_stmt|,
modifier|*
name|pathp
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|,
modifier|*
name|path
decl_stmt|,
modifier|*
name|recpath
decl_stmt|;
name|char
modifier|*
name|dtype
decl_stmt|,
modifier|*
name|data
decl_stmt|;
name|int
name|st
decl_stmt|;
if|if
condition|(
name|opts_empty
argument_list|(
name|sp
argument_list|,
name|O_RECDIR
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|rp
operator|=
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_RECDIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|rp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|rp
argument_list|,
literal|"%s"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|name
operator|=
name|frp
operator|->
name|name
expr_stmt|;
name|sv_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|recp
operator|=
name|pathp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|found
operator|=
name|requested
operator|=
literal|0
init|;
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"recover."
argument_list|,
literal|8
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|recpath
operator|=
name|join
argument_list|(
name|rp
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If it's readable, it's recoverable. */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|recpath
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|recpath
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|file_lock
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|LOCK_FAILED
case|:
comment|/* 			 * XXX 			 * Assume that a lock can't be acquired, but that we 			 * should permit recovery anyway.  If this is wrong, 			 * and someone else is using the file, we're going to 			 * die horribly. 			 */
name|locked
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LOCK_SUCCESS
case|:
name|locked
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|LOCK_UNAVAIL
case|:
comment|/* If it's locked, it's live. */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Check the headers. */
for|for
control|(
name|file
operator|=
name|NULL
operator|,
name|path
operator|=
name|NULL
init|;
name|file
operator|==
name|NULL
operator|||
name|path
operator|==
name|NULL
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|st
operator|=
name|rcv_dlnread
argument_list|(
name|sp
argument_list|,
operator|&
name|dtype
argument_list|,
operator|&
name|data
argument_list|,
name|fp
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|st
operator|==
literal|1
condition|)
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
literal|"067|%s: malformed recovery file"
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|dtype
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dtype
argument_list|,
literal|"file"
argument_list|)
condition|)
name|file
operator|=
name|data
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dtype
argument_list|,
literal|"path"
argument_list|)
condition|)
name|path
operator|=
name|data
expr_stmt|;
else|else
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
operator|++
name|found
expr_stmt|;
comment|/* 		 * If the file doesn't exist, it's an orphaned recovery file, 		 * toss it. 		 * 		 * XXX 		 * This can occur if the backup file was deleted and we crashed 		 * before deleting the email file. 		 */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sb
argument_list|)
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* Check the file name. */
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
condition|)
goto|goto
name|next
goto|;
operator|++
name|requested
expr_stmt|;
comment|/* If we've found more than one, take the most recent. */
operator|(
name|void
operator|)
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|recp
operator|==
name|NULL
operator|||
name|timespeccmp
argument_list|(
operator|&
name|rec_mtim
argument_list|,
operator|&
name|sb
operator|.
name|st_mtimespec
argument_list|,
operator|<
argument_list|)
condition|)
block|{
name|p
operator|=
name|recp
expr_stmt|;
name|t
operator|=
name|pathp
expr_stmt|;
name|recp
operator|=
name|recpath
expr_stmt|;
name|pathp
operator|=
name|path
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|rec_mtim
operator|=
name|sb
operator|.
name|st_mtimespec
expr_stmt|;
if|if
condition|(
name|sv_fd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|sv_fd
argument_list|)
expr_stmt|;
name|sv_fd
operator|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next
label|:
name|free
argument_list|(
name|recpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
name|recp
operator|==
name|NULL
condition|)
block|{
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
name|name
argument_list|,
literal|"068|No files named %s, readable by you, to recover"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|requested
operator|>
literal|1
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"069|There are older versions of this file for you to recover"
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|>
name|requested
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"070|There are other files for you to recover"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create the FREF structure, start the btree file. 	 * 	 * XXX 	 * file_init() is going to set ep->rcv_path. 	 */
if|if
condition|(
name|file_init
argument_list|(
name|sp
argument_list|,
name|frp
argument_list|,
name|pathp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|recp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pathp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sv_fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|pathp
argument_list|)
expr_stmt|;
comment|/* 	 * We keep an open lock on the file so that the recover option can 	 * distinguish between files that are live and those that need to 	 * be recovered.  The lock is already acquired, just copy it. 	 */
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
name|ep
operator|->
name|rcv_mpath
operator|=
name|recp
expr_stmt|;
name|ep
operator|->
name|rcv_fd
operator|=
name|sv_fd
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_UNLOCKED
argument_list|)
expr_stmt|;
comment|/* We believe the file is recoverable. */
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_RCV_ON
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rcv_copy --  *	Copy a recovery file.  */
end_comment

begin_function
specifier|static
name|int
name|rcv_copy
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|int
name|wfd
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|int
name|nr
decl_stmt|,
name|nw
decl_stmt|,
name|off
decl_stmt|,
name|rfd
decl_stmt|;
name|char
name|buf
index|[
literal|8
operator|*
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|rfd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err
goto|;
while|while
condition|(
operator|(
name|nr
operator|=
name|read
argument_list|(
name|rfd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
name|off
operator|=
literal|0
init|;
name|nr
condition|;
name|nr
operator|-=
name|nw
operator|,
name|off
operator|+=
name|nw
control|)
if|if
condition|(
operator|(
name|nw
operator|=
name|write
argument_list|(
name|wfd
argument_list|,
name|buf
operator|+
name|off
argument_list|,
name|nr
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|nr
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|fname
argument_list|,
literal|"%s"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rcv_mktemp --  *	Paranoid make temporary file routine.  */
end_comment

begin_function
specifier|static
name|int
name|rcv_mktemp
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|dname
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mkstemp
argument_list|(
name|path
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|dname
argument_list|,
literal|"%s"
argument_list|)
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rcv_email --  *	Send email.  */
end_comment

begin_function
specifier|static
name|void
name|rcv_email
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
operator|(
name|void
operator|)
name|asprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|_PATH_SENDMAIL
literal|" -odb -t< %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
literal|"071|not sending email: %s"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|system
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rcv_dlnwrite --  *	Encode a string into an X-vi-data line and write it.  */
end_comment

begin_function
specifier|static
name|int
name|rcv_dlnwrite
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
specifier|const
name|char
modifier|*
name|dtype
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|bp
init|=
name|NULL
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|size_t
name|blen
init|=
literal|0
decl_stmt|;
name|size_t
name|dlen
decl_stmt|,
name|len
decl_stmt|;
name|int
name|plen
decl_stmt|,
name|xlen
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|strlen
argument_list|(
name|dtype
argument_list|)
expr_stmt|;
name|GET_SPACE_GOTOC
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
operator|(
name|len
operator|+
literal|2
operator|)
operator|/
literal|3
operator|*
literal|4
operator|+
name|dlen
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|bp
argument_list|,
name|dtype
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|bp
index|[
name|dlen
index|]
operator|=
literal|';'
expr_stmt|;
if|if
condition|(
operator|(
name|xlen
operator|=
name|b64_ntop
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|src
argument_list|,
name|len
argument_list|,
name|bp
operator|+
name|dlen
operator|+
literal|1
argument_list|,
name|blen
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err
goto|;
name|xlen
operator|+=
name|dlen
operator|+
literal|1
expr_stmt|;
comment|/* Output as an MIME folding header. */
if|if
condition|(
operator|(
name|plen
operator|=
name|fprintf
argument_list|(
name|fp
argument_list|,
name|VI_DHEADER
literal|" %.*s\n"
argument_list|,
name|FMTCOLS
operator|-
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|VI_DHEADER
argument_list|)
argument_list|,
name|bp
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
name|plen
operator|-=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|VI_DHEADER
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|bp
operator|,
name|xlen
operator|-=
name|plen
init|;
name|xlen
operator|>
literal|0
condition|;
name|xlen
operator|-=
name|plen
control|)
block|{
name|p
operator|+=
name|plen
expr_stmt|;
if|if
condition|(
operator|(
name|plen
operator|=
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %.*s\n"
argument_list|,
name|FMTCOLS
operator|-
literal|1
argument_list|,
name|p
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
name|plen
operator|-=
literal|2
expr_stmt|;
block|}
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|alloc_err
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rcv_dlnread --  *	Read an X-vi-data line and decode it.  */
end_comment

begin_function
specifier|static
name|int
name|rcv_dlnread
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|char
modifier|*
modifier|*
name|dtypep
parameter_list|,
name|char
modifier|*
modifier|*
name|datap
parameter_list|,
comment|/* free *datap if != NULL after use. */
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|bp
init|=
name|NULL
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|size_t
name|blen
init|=
literal|0
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|off
decl_stmt|,
name|dlen
decl_stmt|;
name|char
modifier|*
name|dtype
decl_stmt|,
modifier|*
name|data
decl_stmt|;
name|int
name|xlen
decl_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
name|VI_DHEADER
argument_list|,
sizeof|sizeof
argument_list|(
name|VI_DHEADER
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
operator|*
name|dtypep
operator|=
name|NULL
expr_stmt|;
operator|*
name|datap
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Fetch an MIME folding header. */
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|VI_DHEADER
argument_list|)
operator|+
literal|1
expr_stmt|;
name|GET_SPACE_GOTOC
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|bp
argument_list|,
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|VI_DHEADER
argument_list|)
operator|-
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
name|bp
operator|+
name|len
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|off
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|len
operator|+=
name|off
expr_stmt|;
name|ADD_SPACE_GOTOC
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
name|bp
operator|+
name|len
operator|-
name|off
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
name|off
argument_list|)
expr_stmt|;
block|}
name|bp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|ch
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|bp
init|;
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|src
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|';'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|dlen
operator|=
name|src
operator|-
name|p
expr_stmt|;
name|src
operator|+=
literal|1
expr_stmt|;
name|len
operator|-=
name|src
operator|-
name|bp
expr_stmt|;
comment|/* Memory looks like: "<data>\0<dtype>\0". */
name|MALLOC
argument_list|(
name|sp
argument_list|,
name|data
argument_list|,
name|char
operator|*
argument_list|,
name|dlen
operator|+
name|len
operator|/
literal|4
operator|*
literal|3
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|(
name|xlen
operator|=
operator|(
name|b64_pton
argument_list|(
name|p
operator|+
name|dlen
operator|+
literal|1
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|,
name|len
operator|/
literal|4
operator|*
literal|3
operator|+
literal|1
argument_list|)
operator|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|data
index|[
name|xlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dtype
operator|=
name|data
operator|+
name|xlen
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|dtype
argument_list|,
name|p
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|dtype
index|[
name|dlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|)
expr_stmt|;
operator|*
name|dtypep
operator|=
name|dtype
expr_stmt|;
operator|*
name|datap
operator|=
name|data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|alloc_err
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

end_unit

