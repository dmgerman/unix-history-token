begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1992, 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"$Id: search.c,v 10.26 2011/07/04 20:16:26 zy Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|S_EMPTY
block|,
name|S_EOF
block|,
name|S_NOPREV
block|,
name|S_NOTFOUND
block|,
name|S_SOF
block|,
name|S_WRAP
block|}
name|smsg_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|void
name|search_msg
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|smsg_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|search_init
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|dir_t
operator|,
name|CHAR_T
operator|*
operator|,
name|size_t
operator|,
name|CHAR_T
operator|*
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * search_init --  *	Set up a search.  */
end_comment

begin_function
specifier|static
name|int
name|search_init
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|dir_t
name|dir
parameter_list|,
name|CHAR_T
modifier|*
name|ptrn
parameter_list|,
name|size_t
name|plen
parameter_list|,
name|CHAR_T
modifier|*
modifier|*
name|epp
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|recno_t
name|lno
decl_stmt|;
name|int
name|delim
decl_stmt|;
name|CHAR_T
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
comment|/* If the file is empty, it's a fast search. */
if|if
condition|(
name|sp
operator|->
name|lno
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_MSG
argument_list|)
condition|)
name|search_msg
argument_list|(
name|sp
argument_list|,
name|S_EMPTY
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_PARSE
argument_list|)
condition|)
block|{
comment|/* Parse the string. */
comment|/* 		 * Use the saved pattern if no pattern specified, or if only 		 * one or two delimiter characters specified. 		 * 		 * !!! 		 * Historically, only the pattern itself was saved, vi didn't 		 * preserve addressing or delta information. 		 */
if|if
condition|(
name|ptrn
operator|==
name|NULL
condition|)
goto|goto
name|prev
goto|;
if|if
condition|(
name|plen
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|epp
operator|!=
name|NULL
condition|)
operator|*
name|epp
operator|=
name|ptrn
operator|+
literal|1
expr_stmt|;
goto|goto
name|prev
goto|;
block|}
if|if
condition|(
name|ptrn
index|[
literal|0
index|]
operator|==
name|ptrn
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|epp
operator|!=
name|NULL
condition|)
operator|*
name|epp
operator|=
name|ptrn
operator|+
literal|2
expr_stmt|;
comment|/* Complain if we don't have a previous pattern. */
name|prev
label|:
if|if
condition|(
name|sp
operator|->
name|re
operator|==
name|NULL
condition|)
block|{
name|search_msg
argument_list|(
name|sp
argument_list|,
name|S_NOPREV
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Re-compile the search pattern if necessary. */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_RE_SEARCH
argument_list|)
operator|&&
name|re_compile
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|re
argument_list|,
name|sp
operator|->
name|re_len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sp
operator|->
name|re_c
argument_list|,
name|RE_C_SEARCH
operator||
operator|(
name|LF_ISSET
argument_list|(
name|SEARCH_MSG
argument_list|)
condition|?
literal|0
else|:
name|RE_C_SILENT
operator|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Set the search direction. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_SET
argument_list|)
condition|)
name|sp
operator|->
name|searchdir
operator|=
name|dir
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Set the delimiter, and move forward to the terminating 		 * delimiter, handling escaped delimiters. 		 * 		 * QUOTING NOTE: 		 * Only discard an escape character if it escapes a delimiter. 		 */
for|for
control|(
name|delim
operator|=
operator|*
name|ptrn
operator|,
name|p
operator|=
name|t
operator|=
operator|++
name|ptrn
init|;
condition|;
operator|*
name|t
operator|++
operator|=
operator|*
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|--
name|plen
operator|==
literal|0
operator|||
name|p
index|[
literal|0
index|]
operator|==
name|delim
condition|)
block|{
if|if
condition|(
name|plen
operator|!=
literal|0
condition|)
operator|++
name|p
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|plen
operator|>
literal|1
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|delim
condition|)
block|{
operator|++
name|p
expr_stmt|;
operator|--
name|plen
expr_stmt|;
block|}
block|}
if|if
condition|(
name|epp
operator|!=
name|NULL
condition|)
operator|*
name|epp
operator|=
name|p
expr_stmt|;
name|plen
operator|=
name|t
operator|-
name|ptrn
expr_stmt|;
block|}
comment|/* Compile the RE. */
if|if
condition|(
name|re_compile
argument_list|(
name|sp
argument_list|,
name|ptrn
argument_list|,
name|plen
argument_list|,
operator|&
name|sp
operator|->
name|re
argument_list|,
operator|&
name|sp
operator|->
name|re_len
argument_list|,
operator|&
name|sp
operator|->
name|re_c
argument_list|,
name|RE_C_SEARCH
operator||
operator|(
name|LF_ISSET
argument_list|(
name|SEARCH_MSG
argument_list|)
condition|?
literal|0
else|:
name|RE_C_SILENT
operator|)
operator||
operator|(
name|LF_ISSET
argument_list|(
name|SEARCH_TAG
argument_list|)
condition|?
name|RE_C_TAG
else|:
literal|0
operator|)
operator||
operator|(
name|LF_ISSET
argument_list|(
name|SEARCH_CSCOPE
argument_list|)
condition|?
name|RE_C_CSCOPE
else|:
literal|0
operator|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Set the search direction. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_SET
argument_list|)
condition|)
name|sp
operator|->
name|searchdir
operator|=
name|dir
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * f_search --  *	Do a forward search.  *  * PUBLIC: int f_search __P((SCR *,  * PUBLIC:    MARK *, MARK *, CHAR_T *, size_t, CHAR_T **, u_int));  */
end_comment

begin_function
name|int
name|f_search
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|MARK
modifier|*
name|fm
parameter_list|,
name|MARK
modifier|*
name|rm
parameter_list|,
name|CHAR_T
modifier|*
name|ptrn
parameter_list|,
name|size_t
name|plen
parameter_list|,
name|CHAR_T
modifier|*
modifier|*
name|eptrn
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|busy_t
name|btype
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|regmatch_t
name|match
index|[
literal|1
index|]
decl_stmt|;
name|size_t
name|coff
decl_stmt|,
name|len
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|eval
decl_stmt|,
name|rval
decl_stmt|,
name|wrapped
decl_stmt|;
name|CHAR_T
modifier|*
name|l
decl_stmt|;
if|if
condition|(
name|search_init
argument_list|(
name|sp
argument_list|,
name|FORWARD
argument_list|,
name|ptrn
argument_list|,
name|plen
argument_list|,
name|eptrn
argument_list|,
name|flags
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_FILE
argument_list|)
condition|)
block|{
name|lno
operator|=
literal|1
expr_stmt|;
name|coff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|db_get
argument_list|(
name|sp
argument_list|,
name|fm
operator|->
name|lno
argument_list|,
name|DBG_FATAL
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|lno
operator|=
name|fm
operator|->
name|lno
expr_stmt|;
comment|/* 		 * If doing incremental search, start searching at the previous 		 * column, so that we search a minimal distance and still match 		 * special patterns, e.g., \< for beginning of a word. 		 * 		 * Otherwise, start searching immediately after the cursor.  If 		 * at the end of the line, start searching on the next line. 		 * This is incompatible (read bug fix) with the historic vi -- 		 * searches for the '$' pattern never moved forward, and the 		 * "-t foo" didn't work if the 'f' was the first character in 		 * the file. 		 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_INCR
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|coff
operator|=
name|fm
operator|->
name|cno
operator|)
operator|!=
literal|0
condition|)
operator|--
name|coff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fm
operator|->
name|cno
operator|+
literal|1
operator|>=
name|len
condition|)
block|{
name|coff
operator|=
literal|0
expr_stmt|;
name|lno
operator|=
name|fm
operator|->
name|lno
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|db_get
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
literal|0
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_WRAPSCAN
argument_list|)
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_MSG
argument_list|)
condition|)
name|search_msg
argument_list|(
name|sp
argument_list|,
name|S_EOF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|lno
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|coff
operator|=
name|fm
operator|->
name|cno
operator|+
literal|1
expr_stmt|;
block|}
name|btype
operator|=
name|BUSY_ON
expr_stmt|;
for|for
control|(
name|cnt
operator|=
name|INTERRUPT_CHECK
operator|,
name|rval
operator|=
literal|1
operator|,
name|wrapped
operator|=
literal|0
init|;
condition|;
operator|++
name|lno
operator|,
name|coff
operator|=
literal|0
control|)
block|{
if|if
condition|(
name|cnt
operator|--
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|INTERRUPTED
argument_list|(
name|sp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_MSG
argument_list|)
condition|)
block|{
name|search_busy
argument_list|(
name|sp
argument_list|,
name|btype
argument_list|)
expr_stmt|;
name|btype
operator|=
name|BUSY_UPDATE
expr_stmt|;
block|}
name|cnt
operator|=
name|INTERRUPT_CHECK
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|wrapped
operator|&&
name|lno
operator|>
name|fm
operator|->
name|lno
operator|)
operator|||
name|db_get
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
literal|0
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|wrapped
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_MSG
argument_list|)
condition|)
name|search_msg
argument_list|(
name|sp
argument_list|,
name|S_NOTFOUND
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_WRAPSCAN
argument_list|)
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_MSG
argument_list|)
condition|)
name|search_msg
argument_list|(
name|sp
argument_list|,
name|S_EOF
argument_list|)
expr_stmt|;
break|break;
block|}
name|lno
operator|=
literal|0
expr_stmt|;
name|wrapped
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* If already at EOL, just keep going. */
if|if
condition|(
name|len
operator|!=
literal|0
operator|&&
name|coff
operator|==
name|len
condition|)
continue|continue;
comment|/* Set the termination. */
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
operator|=
name|coff
expr_stmt|;
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|=
name|len
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|0
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"F search: %lu from %u to %u\n"
argument_list|,
name|lno
argument_list|,
name|coff
argument_list|,
name|len
operator|!=
literal|0
condition|?
name|len
operator|-
literal|1
else|:
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Search the line. */
name|eval
operator|=
name|regexec
argument_list|(
operator|&
name|sp
operator|->
name|re_c
argument_list|,
name|l
argument_list|,
literal|1
argument_list|,
name|match
argument_list|,
operator|(
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
operator|==
literal|0
condition|?
literal|0
else|:
name|REG_NOTBOL
operator|)
operator||
name|REG_STARTEND
argument_list|)
expr_stmt|;
if|if
condition|(
name|eval
operator|==
name|REG_NOMATCH
condition|)
continue|continue;
if|if
condition|(
name|eval
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_MSG
argument_list|)
condition|)
name|re_error
argument_list|(
name|sp
argument_list|,
name|eval
argument_list|,
operator|&
name|sp
operator|->
name|re_c
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_bell
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Warn if the search wrapped. */
if|if
condition|(
name|wrapped
operator|&&
name|LF_ISSET
argument_list|(
name|SEARCH_WMSG
argument_list|)
condition|)
name|search_msg
argument_list|(
name|sp
argument_list|,
name|S_WRAP
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|0
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"F search: %qu to %qu\n"
argument_list|,
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
argument_list|,
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rm
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|rm
operator|->
name|cno
operator|=
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
expr_stmt|;
comment|/* 		 * If a change command, it's possible to move beyond the end 		 * of a line.  Historic vi generally got this wrong (e.g. try 		 * "c?$<cr>").  Not all that sure this gets it right, there 		 * are lots of strange cases. 		 */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|SEARCH_EOL
argument_list|)
operator|&&
name|rm
operator|->
name|cno
operator|>=
name|len
condition|)
name|rm
operator|->
name|cno
operator|=
name|len
operator|!=
literal|0
condition|?
name|len
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_MSG
argument_list|)
condition|)
name|search_busy
argument_list|(
name|sp
argument_list|,
name|BUSY_OFF
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * b_search --  *	Do a backward search.  *  * PUBLIC: int b_search __P((SCR *,  * PUBLIC:    MARK *, MARK *, CHAR_T *, size_t, CHAR_T **, u_int));  */
end_comment

begin_function
name|int
name|b_search
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|MARK
modifier|*
name|fm
parameter_list|,
name|MARK
modifier|*
name|rm
parameter_list|,
name|CHAR_T
modifier|*
name|ptrn
parameter_list|,
name|size_t
name|plen
parameter_list|,
name|CHAR_T
modifier|*
modifier|*
name|eptrn
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|busy_t
name|btype
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|regmatch_t
name|match
index|[
literal|1
index|]
decl_stmt|;
name|size_t
name|coff
decl_stmt|,
name|last
decl_stmt|,
name|len
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|eval
decl_stmt|,
name|rval
decl_stmt|,
name|wrapped
decl_stmt|;
name|CHAR_T
modifier|*
name|l
decl_stmt|;
if|if
condition|(
name|search_init
argument_list|(
name|sp
argument_list|,
name|BACKWARD
argument_list|,
name|ptrn
argument_list|,
name|plen
argument_list|,
name|eptrn
argument_list|,
name|flags
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * If doing incremental search, set the "starting" position past the 	 * current column, so that we search a minimal distance and still 	 * match special patterns, e.g., \> for the end of a word.  This is 	 * safe when the cursor is at the end of a line because we only use 	 * it for comparison with the location of the match. 	 * 	 * Otherwise, start searching immediately before the cursor.  If in 	 * the first column, start search on the previous line. 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_INCR
argument_list|)
condition|)
block|{
name|lno
operator|=
name|fm
operator|->
name|lno
expr_stmt|;
name|coff
operator|=
name|fm
operator|->
name|cno
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fm
operator|->
name|cno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fm
operator|->
name|lno
operator|==
literal|1
operator|&&
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_WRAPSCAN
argument_list|)
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_MSG
argument_list|)
condition|)
name|search_msg
argument_list|(
name|sp
argument_list|,
name|S_SOF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|lno
operator|=
name|fm
operator|->
name|lno
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|lno
operator|=
name|fm
operator|->
name|lno
expr_stmt|;
name|coff
operator|=
name|fm
operator|->
name|cno
expr_stmt|;
block|}
name|btype
operator|=
name|BUSY_ON
expr_stmt|;
for|for
control|(
name|cnt
operator|=
name|INTERRUPT_CHECK
operator|,
name|rval
operator|=
literal|1
operator|,
name|wrapped
operator|=
literal|0
init|;
condition|;
operator|--
name|lno
operator|,
name|coff
operator|=
literal|0
control|)
block|{
if|if
condition|(
name|cnt
operator|--
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|INTERRUPTED
argument_list|(
name|sp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_MSG
argument_list|)
condition|)
block|{
name|search_busy
argument_list|(
name|sp
argument_list|,
name|btype
argument_list|)
expr_stmt|;
name|btype
operator|=
name|BUSY_UPDATE
expr_stmt|;
block|}
name|cnt
operator|=
name|INTERRUPT_CHECK
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|wrapped
operator|&&
name|lno
operator|<
name|fm
operator|->
name|lno
operator|)
operator|||
name|lno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|wrapped
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_MSG
argument_list|)
condition|)
name|search_msg
argument_list|(
name|sp
argument_list|,
name|S_NOTFOUND
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_WRAPSCAN
argument_list|)
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_MSG
argument_list|)
condition|)
name|search_msg
argument_list|(
name|sp
argument_list|,
name|S_SOF
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
break|break;
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_MSG
argument_list|)
condition|)
name|search_msg
argument_list|(
name|sp
argument_list|,
name|S_EMPTY
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|lno
expr_stmt|;
name|wrapped
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|db_get
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
literal|0
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|len
argument_list|)
condition|)
break|break;
comment|/* Set the termination. */
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
operator|=
literal|0
expr_stmt|;
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|=
name|len
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|0
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"B search: %lu from 0 to %qu\n"
argument_list|,
name|lno
argument_list|,
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Search the line. */
name|eval
operator|=
name|regexec
argument_list|(
operator|&
name|sp
operator|->
name|re_c
argument_list|,
name|l
argument_list|,
literal|1
argument_list|,
name|match
argument_list|,
operator|(
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|==
name|len
condition|?
literal|0
else|:
name|REG_NOTEOL
operator|)
operator||
name|REG_STARTEND
argument_list|)
expr_stmt|;
if|if
condition|(
name|eval
operator|==
name|REG_NOMATCH
condition|)
continue|continue;
if|if
condition|(
name|eval
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_MSG
argument_list|)
condition|)
name|re_error
argument_list|(
name|sp
argument_list|,
name|eval
argument_list|,
operator|&
name|sp
operator|->
name|re_c
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_bell
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Check for a match starting past the cursor. */
if|if
condition|(
name|coff
operator|!=
literal|0
operator|&&
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
operator|>=
name|coff
condition|)
continue|continue;
comment|/* Warn if the search wrapped. */
if|if
condition|(
name|wrapped
operator|&&
name|LF_ISSET
argument_list|(
name|SEARCH_WMSG
argument_list|)
condition|)
name|search_msg
argument_list|(
name|sp
argument_list|,
name|S_WRAP
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|0
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"B found: %qu to %qu\n"
argument_list|,
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
argument_list|,
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * We now have the first match on the line.  Step through the 		 * line character by character until find the last acceptable 		 * match.  This is painful, we need a better interface to regex 		 * to make this work. 		 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|last
operator|=
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
operator|++
expr_stmt|;
if|if
condition|(
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
operator|>=
name|len
condition|)
break|break;
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|=
name|len
expr_stmt|;
name|eval
operator|=
name|regexec
argument_list|(
operator|&
name|sp
operator|->
name|re_c
argument_list|,
name|l
argument_list|,
literal|1
argument_list|,
name|match
argument_list|,
operator|(
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
operator|==
literal|0
condition|?
literal|0
else|:
name|REG_NOTBOL
operator|)
operator||
name|REG_STARTEND
argument_list|)
expr_stmt|;
if|if
condition|(
name|eval
operator|==
name|REG_NOMATCH
condition|)
break|break;
if|if
condition|(
name|eval
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_MSG
argument_list|)
condition|)
name|re_error
argument_list|(
name|sp
argument_list|,
name|eval
argument_list|,
operator|&
name|sp
operator|->
name|re_c
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_bell
argument_list|(
name|sp
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|coff
operator|&&
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
operator|>=
name|coff
condition|)
break|break;
block|}
name|rm
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
comment|/* See comment in f_search(). */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|SEARCH_EOL
argument_list|)
operator|&&
name|last
operator|>=
name|len
condition|)
name|rm
operator|->
name|cno
operator|=
name|len
operator|!=
literal|0
condition|?
name|len
operator|-
literal|1
else|:
literal|0
expr_stmt|;
else|else
name|rm
operator|->
name|cno
operator|=
name|last
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|err
label|:
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SEARCH_MSG
argument_list|)
condition|)
name|search_busy
argument_list|(
name|sp
argument_list|,
name|BUSY_OFF
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * search_msg --  *	Display one of the search messages.  */
end_comment

begin_function
specifier|static
name|void
name|search_msg
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|smsg_t
name|msg
parameter_list|)
block|{
switch|switch
condition|(
name|msg
condition|)
block|{
case|case
name|S_EMPTY
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"072|File empty; nothing to search"
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_EOF
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"073|Reached end-of-file without finding the pattern"
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_NOPREV
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"074|No previous search pattern"
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_NOTFOUND
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"075|Pattern not found"
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_SOF
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"076|Reached top-of-file without finding the pattern"
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_WRAP
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"077|Search wrapped"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * search_busy --  *	Put up the busy searching message.  *  * PUBLIC: void search_busy __P((SCR *, busy_t));  */
end_comment

begin_function
name|void
name|search_busy
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|busy_t
name|btype
parameter_list|)
block|{
name|sp
operator|->
name|gp
operator|->
name|scr_busy
argument_list|(
name|sp
argument_list|,
literal|"078|Searching..."
argument_list|,
name|btype
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

