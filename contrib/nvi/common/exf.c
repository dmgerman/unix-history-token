begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1992, 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  *  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static const char sccsid[] = "@(#)exf.c	10.49 (Berkeley) 10/10/96";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* XXX: param.h may not have included types.h */
end_comment

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/*  * We include<sys/file.h>, because the flock(2) and open(2) #defines  * were found there on historical systems.  We also include<fcntl.h>  * because the open(2) #defines are found there on newer systems.  */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|file_backup
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|file_cinit
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|file_comment
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|file_spath
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|FREF
operator|*
operator|,
expr|struct
name|stat
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * file_add --  *	Insert a file name into the FREF list, if it doesn't already  *	appear in it.  *  * !!!  * The "if it doesn't already appear" changes vi's semantics slightly.  If  * you do a "vi foo bar", and then execute "next bar baz", the edit of bar  * will reflect the line/column of the previous edit session.  Historic nvi  * did not do this.  The change is a logical extension of the change where  * vi now remembers the last location in any file that it has ever edited,  * not just the previously edited file.  *  * PUBLIC: FREF *file_add __P((SCR *, CHAR_T *));  */
end_comment

begin_function
name|FREF
modifier|*
name|file_add
parameter_list|(
name|sp
parameter_list|,
name|name
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|CHAR_T
modifier|*
name|name
decl_stmt|;
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|FREF
modifier|*
name|frp
decl_stmt|,
modifier|*
name|tfrp
decl_stmt|;
comment|/* 	 * Return it if it already exists.  Note that we test against the 	 * user's name, whatever that happens to be, including if it's a 	 * temporary file. 	 * 	 * If the user added a file but was unable to initialize it, there 	 * can be file list entries where the name field is NULL.  Discard 	 * them the next time we see them. 	 */
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
for|for
control|(
name|frp
operator|=
name|gp
operator|->
name|frefq
operator|.
name|cqh_first
init|;
name|frp
operator|!=
operator|(
name|FREF
operator|*
operator|)
operator|&
name|gp
operator|->
name|frefq
condition|;
name|frp
operator|=
name|frp
operator|->
name|q
operator|.
name|cqe_next
control|)
block|{
if|if
condition|(
name|frp
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|tfrp
operator|=
name|frp
operator|->
name|q
operator|.
name|cqe_next
expr_stmt|;
name|CIRCLEQ_REMOVE
argument_list|(
operator|&
name|gp
operator|->
name|frefq
argument_list|,
name|frp
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|->
name|name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|frp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|frp
argument_list|)
expr_stmt|;
name|frp
operator|=
name|tfrp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|frp
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|frp
operator|)
return|;
block|}
comment|/* Allocate and initialize the FREF structure. */
name|CALLOC
argument_list|(
name|sp
argument_list|,
name|frp
argument_list|,
name|FREF
operator|*
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|FREF
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * If no file name specified, or if the file name is a request 	 * for something temporary, file_init() will allocate the file 	 * name.  Temporary files are always ignored. 	 */
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|TEMPORARY_FILE_STRING
argument_list|)
operator|&&
operator|(
name|frp
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|frp
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Append into the chain of file names. */
name|CIRCLEQ_INSERT_TAIL
argument_list|(
operator|&
name|gp
operator|->
name|frefq
argument_list|,
name|frp
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|frp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_init --  *	Start editing a file, based on the FREF structure.  If successsful,  *	let go of any previous file.  Don't release the previous file until  *	absolutely sure we have the new one.  *  * PUBLIC: int file_init __P((SCR *, FREF *, char *, int));  */
end_comment

begin_function
name|int
name|file_init
parameter_list|(
name|sp
parameter_list|,
name|frp
parameter_list|,
name|rcv_name
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|FREF
modifier|*
name|frp
decl_stmt|;
name|char
modifier|*
name|rcv_name
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|EXF
modifier|*
name|ep
decl_stmt|;
name|RECNOINFO
name|oinfo
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|size_t
name|psize
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|exists
decl_stmt|,
name|open_err
decl_stmt|,
name|readonly
decl_stmt|;
name|char
modifier|*
name|oname
decl_stmt|,
name|tname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|open_err
operator|=
name|readonly
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the file is a recovery file, let the recovery code handle it. 	 * Clear the FR_RECOVER flag first -- the recovery code does set up, 	 * and then calls us!  If the recovery call fails, it's probably 	 * because the named file doesn't exist.  So, move boldly forward, 	 * presuming that there's an error message the user will get to see. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_RECOVER
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|frp
argument_list|,
name|FR_RECOVER
argument_list|)
expr_stmt|;
return|return
operator|(
name|rcv_read
argument_list|(
name|sp
argument_list|,
name|frp
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Required FRP initialization; the only flag we keep is the 	 * cursor information. 	 */
name|F_CLR
argument_list|(
name|frp
argument_list|,
operator|~
name|FR_CURSORSET
argument_list|)
expr_stmt|;
comment|/* 	 * Required EXF initialization: 	 *	Flush the line caches. 	 *	Default recover mail file fd to -1. 	 *	Set initial EXF flag bits. 	 */
name|CALLOC_RET
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|EXF
operator|*
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|EXF
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|c_lno
operator|=
name|ep
operator|->
name|c_nlines
operator|=
name|OOBLNO
expr_stmt|;
name|ep
operator|->
name|rcv_fd
operator|=
name|ep
operator|->
name|fcntl_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_FIRSTMODIFY
argument_list|)
expr_stmt|;
comment|/* 	 * Scan the user's path to find the file that we're going to 	 * try and open. 	 */
if|if
condition|(
name|file_spath
argument_list|(
name|sp
argument_list|,
name|frp
argument_list|,
operator|&
name|sb
argument_list|,
operator|&
name|exists
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * If no name or backing file, for whatever reason, create a backing 	 * temporary file, saving the temp file name so we can later unlink 	 * it.  If the user never named this file, copy the temporary file name 	 * to the real name (we display that until the user renames it). 	 */
name|oname
operator|=
name|frp
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_OPENERR
argument_list|)
operator|||
name|oname
operator|==
name|NULL
operator|||
operator|!
name|exists
condition|)
block|{
if|if
condition|(
name|opts_empty
argument_list|(
name|sp
argument_list|,
name|O_DIRECTORY
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tname
argument_list|,
sizeof|sizeof
argument_list|(
name|tname
argument_list|)
argument_list|,
literal|"%s/vi.XXXXXXXXXX"
argument_list|,
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_DIRECTORY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mkstemp
argument_list|(
name|tname
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"237|Unable to create temporary file"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|->
name|name
operator|==
name|NULL
condition|)
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_TMPFILE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|frp
operator|->
name|tname
operator|=
name|strdup
argument_list|(
name|tname
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|frp
operator|->
name|name
operator|==
name|NULL
operator|&&
operator|(
name|frp
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|tname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|frp
operator|->
name|tname
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|frp
operator|->
name|tname
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|oname
operator|=
name|frp
operator|->
name|tname
expr_stmt|;
name|psize
operator|=
literal|1024
expr_stmt|;
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_OPENERR
argument_list|)
condition|)
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_NEWFILE
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|ep
operator|->
name|mtime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * XXX 		 * A seat of the pants calculation: try to keep the file in 		 * 15 pages or less.  Don't use a page size larger than 10K 		 * (vi should have good locality) or smaller than 1K. 		 */
name|psize
operator|=
operator|(
operator|(
name|sb
operator|.
name|st_size
operator|/
literal|15
operator|)
operator|+
literal|1023
operator|)
operator|/
literal|1024
expr_stmt|;
if|if
condition|(
name|psize
operator|>
literal|10
condition|)
name|psize
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|psize
operator|==
literal|0
condition|)
name|psize
operator|=
literal|1
expr_stmt|;
name|psize
operator|*=
literal|1024
expr_stmt|;
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_DEVSET
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mdev
operator|=
name|sb
operator|.
name|st_dev
expr_stmt|;
name|ep
operator|->
name|minode
operator|=
name|sb
operator|.
name|st_ino
expr_stmt|;
name|ep
operator|->
name|mtime
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|oname
argument_list|,
literal|"238|Warning: %s is not a regular file"
argument_list|)
expr_stmt|;
block|}
comment|/* Set up recovery. */
name|memset
argument_list|(
operator|&
name|oinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|RECNOINFO
argument_list|)
argument_list|)
expr_stmt|;
name|oinfo
operator|.
name|bval
operator|=
literal|'\n'
expr_stmt|;
comment|/* Always set. */
name|oinfo
operator|.
name|psize
operator|=
name|psize
expr_stmt|;
name|oinfo
operator|.
name|flags
operator|=
name|F_ISSET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_SNAPSHOT
argument_list|)
condition|?
name|R_SNAPSHOT
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|rcv_name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|rcv_tmp
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|frp
operator|->
name|name
argument_list|)
condition|)
name|oinfo
operator|.
name|bfname
operator|=
name|ep
operator|->
name|rcv_path
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ep
operator|->
name|rcv_path
operator|=
name|strdup
argument_list|(
name|rcv_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|oinfo
operator|.
name|bfname
operator|=
name|ep
operator|->
name|rcv_path
expr_stmt|;
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
expr_stmt|;
block|}
comment|/* Open a db structure. */
if|if
condition|(
operator|(
name|ep
operator|->
name|db
operator|=
name|dbopen
argument_list|(
name|rcv_name
operator|==
name|NULL
condition|?
name|oname
else|:
name|NULL
argument_list|,
name|O_NONBLOCK
operator||
name|O_RDONLY
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IRGRP
operator||
name|S_IWGRP
operator||
name|S_IROTH
operator||
name|S_IWOTH
argument_list|,
name|DB_RECNO
argument_list|,
operator|&
name|oinfo
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|rcv_name
operator|==
name|NULL
condition|?
name|oname
else|:
name|rcv_name
argument_list|,
literal|"%s"
argument_list|)
expr_stmt|;
comment|/* 		 * !!! 		 * Historically, vi permitted users to edit files that couldn't 		 * be read.  This isn't useful for single files from a command 		 * line, but it's quite useful for "vi *.c", since you can skip 		 * past files that you can't read. 		 */
name|open_err
operator|=
literal|1
expr_stmt|;
goto|goto
name|oerr
goto|;
block|}
comment|/* 	 * Do the remaining things that can cause failure of the new file, 	 * mark and logging initialization. 	 */
if|if
condition|(
name|mark_init
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
operator|||
name|log_init
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 	 * Set the alternate file name to be the file we're discarding. 	 * 	 * !!! 	 * Temporary files can't become alternate files, so there's no file 	 * name.  This matches historical practice, although it could only 	 * happen in historical vi as the result of the initial command, i.e. 	 * if vi was executed without a file name. 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_SETALT
argument_list|)
condition|)
name|set_alt_name
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|frp
operator|==
name|NULL
operator|||
name|F_ISSET
argument_list|(
name|sp
operator|->
name|frp
argument_list|,
name|FR_TMPFILE
argument_list|)
condition|?
name|NULL
else|:
name|sp
operator|->
name|frp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Close the previous file; if that fails, close the new one and run 	 * for the border. 	 * 	 * !!! 	 * There's a nasty special case.  If the user edits a temporary file, 	 * and then does an ":e! %", we need to re-initialize the backing 	 * file, but we can't change the name.  (It's worse -- we're dealing 	 * with *names* here, we can't even detect that it happened.)  Set a 	 * flag so that the file_end routine ignores the backing information 	 * of the old file if it happens to be the same as the new one. 	 * 	 * !!! 	 * Side-effect: after the call to file_end(), sp->frp may be NULL. 	 */
if|if
condition|(
name|sp
operator|->
name|ep
operator|!=
name|NULL
condition|)
block|{
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_DONTDELETE
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_end
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|LF_ISSET
argument_list|(
name|FS_FORCE
argument_list|)
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|file_end
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|F_CLR
argument_list|(
name|frp
argument_list|,
name|FR_DONTDELETE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Lock the file; if it's a recovery file, it should already be 	 * locked.  Note, we acquire the lock after the previous file 	 * has been ended, so that we don't get an "already locked" error 	 * for ":edit!". 	 * 	 * XXX 	 * While the user can't interrupt us between the open and here, 	 * there's a race between the dbopen() and the lock.  Not much 	 * we can do about it. 	 * 	 * XXX 	 * We don't make a big deal of not being able to lock the file.  As 	 * locking rarely works over NFS, and often fails if the file was 	 * mmap(2)'d, it's far too common to do anything like print an error 	 * message, let alone make the file readonly.  At some future time, 	 * when locking is a little more reliable, this should change to be 	 * an error. 	 */
if|if
condition|(
name|rcv_name
operator|==
name|NULL
condition|)
switch|switch
condition|(
name|file_lock
argument_list|(
name|sp
argument_list|,
name|oname
argument_list|,
operator|&
name|ep
operator|->
name|fcntl_fd
argument_list|,
name|ep
operator|->
name|db
operator|->
name|fd
argument_list|(
name|ep
operator|->
name|db
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|LOCK_FAILED
case|:
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_UNLOCKED
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK_UNAVAIL
case|:
name|readonly
operator|=
literal|1
expr_stmt|;
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
name|oname
argument_list|,
literal|"239|%s already locked, session is read-only"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK_SUCCESS
case|:
break|break;
block|}
comment|/*          * Historically, the readonly edit option was set per edit buffer in          * vi, unless the -R command-line option was specified or the program          * was executed as "view".  (Well, to be truthful, if the letter 'w'          * occurred anywhere in the program name, but let's not get into that.) 	 * So, the persistant readonly state has to be stored in the screen 	 * structure, and the edit option value toggles with the contents of 	 * the edit buffer.  If the persistant readonly flag is set, set the 	 * readonly edit option. 	 * 	 * Otherwise, try and figure out if a file is readonly.  This is a 	 * dangerous thing to do.  The kernel is the only arbiter of whether 	 * or not a file is writeable, and the best that a user program can 	 * do is guess.  Obvious loopholes are files that are on a file system 	 * mounted readonly (access catches this one on a few systems), or 	 * alternate protection mechanisms, ACL's for example, that we can't 	 * portably check.  Lots of fun, and only here because users whined. 	 * 	 * !!! 	 * Historic vi displayed the readonly message if none of the file 	 * write bits were set, or if an an access(2) call on the path 	 * failed.  This seems reasonable.  If the file is mode 444, root 	 * users may want to know that the owner of the file did not expect 	 * it to be written. 	 * 	 * Historic vi set the readonly bit if no write bits were set for 	 * a file, even if the access call would have succeeded.  This makes 	 * the superuser force the write even when vi expects that it will 	 * succeed.  I'm less supportive of this semantic, but it's historic 	 * practice and the conservative approach to vi'ing files as root. 	 * 	 * It would be nice if there was some way to update this when the user 	 * does a "^Z; chmod ...".  The problem is that we'd first have to 	 * distinguish between readonly bits set because of file permissions 	 * and those set for other reasons.  That's not too hard, but deciding 	 * when to reevaluate the permissions is trickier.  An alternative 	 * might be to turn off the readonly bit if the user forces a write 	 * and it succeeds. 	 * 	 * XXX 	 * Access(2) doesn't consider the effective uid/gid values.  This 	 * probably isn't a problem for vi when it's running standalone. 	 */
if|if
condition|(
name|readonly
operator|||
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_READONLY
argument_list|)
operator|||
operator|!
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_NEWFILE
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|sb
operator|.
name|st_mode
operator|&
operator|(
name|S_IWUSR
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
operator|)
operator|||
name|access
argument_list|(
name|frp
operator|->
name|name
argument_list|,
name|W_OK
argument_list|)
operator|)
condition|)
name|O_SET
argument_list|(
name|sp
argument_list|,
name|O_READONLY
argument_list|)
expr_stmt|;
else|else
name|O_CLR
argument_list|(
name|sp
argument_list|,
name|O_READONLY
argument_list|)
expr_stmt|;
comment|/* Switch... */
operator|++
name|ep
operator|->
name|refcnt
expr_stmt|;
name|sp
operator|->
name|ep
operator|=
name|ep
expr_stmt|;
name|sp
operator|->
name|frp
operator|=
name|frp
expr_stmt|;
comment|/* Set the initial cursor position, queue initial command. */
name|file_cinit
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* Redraw the screen from scratch, schedule a welcome message. */
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REFORMAT
operator||
name|SC_STATUS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
if|if
condition|(
name|frp
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|frp
operator|->
name|name
argument_list|)
expr_stmt|;
name|frp
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|frp
operator|->
name|tname
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|frp
operator|->
name|tname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|frp
operator|->
name|tname
argument_list|)
expr_stmt|;
name|frp
operator|->
name|tname
operator|=
name|NULL
expr_stmt|;
block|}
name|oerr
label|:
if|if
condition|(
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_RCV_ON
argument_list|)
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|ep
operator|->
name|rcv_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|rcv_path
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ep
operator|->
name|rcv_path
argument_list|)
expr_stmt|;
name|ep
operator|->
name|rcv_path
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|db
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|ep
operator|->
name|db
operator|->
name|close
argument_list|(
name|ep
operator|->
name|db
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|open_err
condition|?
name|file_init
argument_list|(
name|sp
argument_list|,
name|frp
argument_list|,
name|rcv_name
argument_list|,
name|flags
operator||
name|FS_OPENERR
argument_list|)
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_spath --  *	Scan the user's path to find the file that we're going to  *	try and open.  */
end_comment

begin_function
specifier|static
name|int
name|file_spath
parameter_list|(
name|sp
parameter_list|,
name|frp
parameter_list|,
name|sbp
parameter_list|,
name|existsp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|FREF
modifier|*
name|frp
decl_stmt|;
name|struct
name|stat
modifier|*
name|sbp
decl_stmt|;
name|int
modifier|*
name|existsp
decl_stmt|;
block|{
name|CHAR_T
name|savech
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|found
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|,
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* 	 * If the name is NULL or an explicit reference (i.e., the first 	 * component is . or ..) ignore the O_PATH option. 	 */
name|name
operator|=
name|frp
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
operator|*
name|existsp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
operator|*
name|existsp
operator|=
operator|!
name|stat
argument_list|(
name|name
argument_list|,
name|sbp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Try . */
if|if
condition|(
operator|!
name|stat
argument_list|(
name|name
argument_list|,
name|sbp
argument_list|)
condition|)
block|{
operator|*
name|existsp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Try the O_PATH option values. */
for|for
control|(
name|found
operator|=
literal|0
operator|,
name|p
operator|=
name|t
operator|=
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_PATH
argument_list|)
init|;
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|t
operator|<
name|p
operator|-
literal|1
condition|)
block|{
name|savech
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|t
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|savech
expr_stmt|;
if|if
condition|(
operator|!
name|stat
argument_list|(
name|path
argument_list|,
name|sbp
argument_list|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|t
operator|=
name|p
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
block|}
comment|/* If we found it, build a new pathname and discard the old one. */
if|if
condition|(
name|found
condition|)
block|{
name|MALLOC_RET
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|char
operator|*
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|path
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|frp
operator|->
name|name
argument_list|)
expr_stmt|;
name|frp
operator|->
name|name
operator|=
name|p
expr_stmt|;
block|}
operator|*
name|existsp
operator|=
name|found
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_cinit --  *	Set up the initial cursor position.  */
end_comment

begin_function
specifier|static
name|void
name|file_cinit
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|MARK
name|m
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|nb
decl_stmt|;
comment|/* Set some basic defaults. */
name|sp
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Historically, initial commands (the -c option) weren't executed 	 * until a file was loaded, e.g. "vi +10 nofile", followed by an 	 * :edit or :tag command, would execute the +10 on the file loaded 	 * by the subsequent command, (assuming that it existed).  This 	 * applied as well to files loaded using the tag commands, and we 	 * follow that historic practice.  Also, all initial commands were 	 * ex commands and were always executed on the last line of the file. 	 * 	 * Otherwise, if no initial command for this file: 	 *    If in ex mode, move to the last line, first nonblank character. 	 *    If the file has previously been edited, move to the last known 	 *	  position, and check it for validity. 	 *    Otherwise, move to the first line, first nonblank. 	 * 	 * This gets called by the file init code, because we may be in a 	 * file of ex commands and we want to execute them from the right 	 * location in the file. 	 */
name|nb
operator|=
literal|0
expr_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
if|if
condition|(
name|gp
operator|->
name|c_option
operator|!=
name|NULL
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|sp
operator|->
name|frp
argument_list|,
name|FR_NEWFILE
argument_list|)
condition|)
block|{
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|lno
argument_list|)
condition|)
return|return;
if|if
condition|(
name|sp
operator|->
name|lno
operator|==
literal|0
condition|)
block|{
name|sp
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ex_run_str
argument_list|(
name|sp
argument_list|,
literal|"-c option"
argument_list|,
name|gp
operator|->
name|c_option
argument_list|,
name|strlen
argument_list|(
name|gp
operator|->
name|c_option
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
name|gp
operator|->
name|c_option
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX
argument_list|)
condition|)
block|{
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|lno
argument_list|)
condition|)
return|return;
if|if
condition|(
name|sp
operator|->
name|lno
operator|==
literal|0
condition|)
block|{
name|sp
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|nb
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
operator|->
name|frp
argument_list|,
name|FR_CURSORSET
argument_list|)
condition|)
block|{
name|sp
operator|->
name|lno
operator|=
name|sp
operator|->
name|frp
operator|->
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|sp
operator|->
name|frp
operator|->
name|cno
expr_stmt|;
comment|/* If returning to a file in vi, center the line. */
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_CENTER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_COMMENT
argument_list|)
condition|)
name|file_comment
argument_list|(
name|sp
argument_list|)
expr_stmt|;
else|else
name|sp
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
name|nb
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|db_get
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
name|sp
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|nb
operator|&&
name|sp
operator|->
name|cno
operator|>
name|len
condition|)
name|nb
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nb
condition|)
block|{
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|nonblank
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
operator|&
name|sp
operator|->
name|cno
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * !!! 	 * The initial column is also the most attractive column. 	 */
name|sp
operator|->
name|rcm
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* 	 * !!! 	 * Historically, vi initialized the absolute mark, but ex did not. 	 * Which meant, that if the first command in ex mode was "visual", 	 * or if an ex command was executed first (e.g. vi +10 file) vi was 	 * entered without the mark being initialized.  For consistency, if 	 * the file isn't empty, we initialize it for everyone, believing 	 * that it can't hurt, and is generally useful.  Not initializing it 	 * if the file is empty is historic practice, although it has always 	 * been possible to set (and use) marks in empty vi files. 	 */
name|m
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|m
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
operator|(
name|void
operator|)
name|mark_set
argument_list|(
name|sp
argument_list|,
name|ABSMARK1
argument_list|,
operator|&
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * file_end --  *	Stop editing a file.  *  * PUBLIC: int file_end __P((SCR *, EXF *, int));  */
end_comment

begin_function
name|int
name|file_end
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|force
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|FREF
modifier|*
name|frp
decl_stmt|;
comment|/* 	 * !!! 	 * ep MAY NOT BE THE SAME AS sp->ep, DON'T USE THE LATTER. 	 * (If argument ep is NULL, use sp->ep.) 	 * 	 * If multiply referenced, just decrement the count and return. 	 */
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
if|if
condition|(
operator|--
name|ep
operator|->
name|refcnt
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * 	 * Clean up the FREF structure. 	 * 	 * Save the cursor location. 	 * 	 * XXX 	 * It would be cleaner to do this somewhere else, but by the time 	 * ex or vi knows that we're changing files it's already happened. 	 */
name|frp
operator|=
name|sp
operator|->
name|frp
expr_stmt|;
name|frp
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|frp
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_CURSORSET
argument_list|)
expr_stmt|;
comment|/* 	 * We may no longer need the temporary backing file, so clean it 	 * up.  We don't need the FREF structure either, if the file was 	 * never named, so lose it. 	 * 	 * !!! 	 * Re: FR_DONTDELETE, see the comment above in file_init(). 	 */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_DONTDELETE
argument_list|)
operator|&&
name|frp
operator|->
name|tname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|frp
operator|->
name|tname
argument_list|)
condition|)
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|frp
operator|->
name|tname
argument_list|,
literal|"240|%s: remove"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|frp
operator|->
name|tname
argument_list|)
expr_stmt|;
name|frp
operator|->
name|tname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_TMPFILE
argument_list|)
condition|)
block|{
name|CIRCLEQ_REMOVE
argument_list|(
operator|&
name|sp
operator|->
name|gp
operator|->
name|frefq
argument_list|,
name|frp
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|->
name|name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|frp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|frp
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|frp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Clean up the EXF structure. 	 * 	 * Close the db structure. 	 */
if|if
condition|(
name|ep
operator|->
name|db
operator|->
name|close
operator|!=
name|NULL
operator|&&
name|ep
operator|->
name|db
operator|->
name|close
argument_list|(
name|ep
operator|->
name|db
argument_list|)
operator|&&
operator|!
name|force
condition|)
block|{
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|frp
operator|->
name|name
argument_list|,
literal|"241|%s: close"
argument_list|)
expr_stmt|;
operator|++
name|ep
operator|->
name|refcnt
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* COMMITTED TO THE CLOSE.  THERE'S NO GOING BACK... */
comment|/* Stop logging. */
operator|(
name|void
operator|)
name|log_end
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* Free up any marks. */
operator|(
name|void
operator|)
name|mark_end
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* 	 * Delete recovery files, close the open descriptor, free recovery 	 * memory.  See recover.c for a description of the protocol. 	 * 	 * XXX 	 * Unlink backup file first, we can detect that the recovery file 	 * doesn't reference anything when the user tries to recover it. 	 * There's a race, here, obviously, but it's fairly small. 	 */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_RCV_NORM
argument_list|)
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|rcv_path
operator|!=
name|NULL
operator|&&
name|unlink
argument_list|(
name|ep
operator|->
name|rcv_path
argument_list|)
condition|)
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|ep
operator|->
name|rcv_path
argument_list|,
literal|"242|%s: remove"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|rcv_mpath
operator|!=
name|NULL
operator|&&
name|unlink
argument_list|(
name|ep
operator|->
name|rcv_mpath
argument_list|)
condition|)
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|ep
operator|->
name|rcv_mpath
argument_list|,
literal|"243|%s: remove"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|fcntl_fd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|ep
operator|->
name|fcntl_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|rcv_fd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|ep
operator|->
name|rcv_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|rcv_path
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ep
operator|->
name|rcv_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|rcv_mpath
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ep
operator|->
name|rcv_mpath
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_write --  *	Write the file to disk.  Historic vi had fairly convoluted  *	semantics for whether or not writes would happen.  That's  *	why all the flags.  *  * PUBLIC: int file_write __P((SCR *, MARK *, MARK *, char *, int));  */
end_comment

begin_function
name|int
name|file_write
parameter_list|(
name|sp
parameter_list|,
name|fm
parameter_list|,
name|tm
parameter_list|,
name|name
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|tm
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
enum|enum
block|{
name|NEWFILE
block|,
name|OLDFILE
block|}
name|mtype
enum|;
name|struct
name|stat
name|sb
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|FREF
modifier|*
name|frp
decl_stmt|;
name|MARK
name|from
decl_stmt|,
name|to
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|u_long
name|nlno
decl_stmt|,
name|nch
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|nf
decl_stmt|,
name|noname
decl_stmt|,
name|oflags
decl_stmt|,
name|rval
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
name|buf
index|[
name|MAXPATHLEN
operator|+
literal|64
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgstr
decl_stmt|;
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
name|frp
operator|=
name|sp
operator|->
name|frp
expr_stmt|;
comment|/* 	 * Writing '%', or naming the current file explicitly, has the 	 * same semantics as writing without a name. 	 */
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|frp
operator|->
name|name
argument_list|)
condition|)
block|{
name|noname
operator|=
literal|1
expr_stmt|;
name|name
operator|=
name|frp
operator|->
name|name
expr_stmt|;
block|}
else|else
name|noname
operator|=
literal|0
expr_stmt|;
comment|/* Can't write files marked read-only, unless forced. */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_FORCE
argument_list|)
operator|&&
name|noname
operator|&&
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_READONLY
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|LF_ISSET
argument_list|(
name|FS_POSSIBLE
argument_list|)
condition|?
literal|"244|Read-only file, not written; use ! to override"
else|:
literal|"245|Read-only file, not written"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* If not forced, not appending, and "writeany" not set ... */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_FORCE
operator||
name|FS_APPEND
argument_list|)
operator|&&
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_WRITEANY
argument_list|)
condition|)
block|{
comment|/* Don't overwrite anything but the original file. */
if|if
condition|(
operator|(
operator|!
name|noname
operator|||
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_NAMECHANGE
argument_list|)
operator|)
operator|&&
operator|!
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|name
argument_list|,
name|LF_ISSET
argument_list|(
name|FS_POSSIBLE
argument_list|)
condition|?
literal|"246|%s exists, not written; use ! to override"
else|:
literal|"247|%s exists, not written"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * Don't write part of any existing file.  Only test for the 		 * original file, the previous test catches anything else. 		 */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_ALL
argument_list|)
operator|&&
name|noname
operator|&&
operator|!
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|LF_ISSET
argument_list|(
name|FS_POSSIBLE
argument_list|)
condition|?
literal|"248|Partial file, not written; use ! to override"
else|:
literal|"249|Partial file, not written"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * Figure out if the file already exists -- if it doesn't, we display 	 * the "new file" message.  The stat might not be necessary, but we 	 * just repeat it because it's easier than hacking the previous tests. 	 * The information is only used for the user message and modification 	 * time test, so we can ignore the obvious race condition. 	 * 	 * One final test.  If we're not forcing or appending the current file, 	 * and we have a saved modification time, object if the file changed 	 * since we last edited or wrote it, and make them force it. 	 */
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
name|mtype
operator|=
name|NEWFILE
expr_stmt|;
else|else
block|{
if|if
condition|(
name|noname
operator|&&
operator|!
name|LF_ISSET
argument_list|(
name|FS_FORCE
operator||
name|FS_APPEND
argument_list|)
operator|&&
operator|(
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_DEVSET
argument_list|)
operator|&&
operator|(
name|sb
operator|.
name|st_dev
operator|!=
name|ep
operator|->
name|mdev
operator|||
name|sb
operator|.
name|st_ino
operator|!=
name|ep
operator|->
name|minode
operator|)
operator|||
name|sb
operator|.
name|st_mtime
operator|!=
name|ep
operator|->
name|mtime
operator|)
condition|)
block|{
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|name
argument_list|,
name|LF_ISSET
argument_list|(
name|FS_POSSIBLE
argument_list|)
condition|?
literal|"250|%s: file modified more recently than this copy; use ! to override"
else|:
literal|"251|%s: file modified more recently than this copy"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|mtype
operator|=
name|OLDFILE
expr_stmt|;
block|}
comment|/* Set flags to create, write, and either append or truncate. */
name|oflags
operator|=
name|O_CREAT
operator||
name|O_WRONLY
operator||
operator|(
name|LF_ISSET
argument_list|(
name|FS_APPEND
argument_list|)
condition|?
name|O_APPEND
else|:
name|O_TRUNC
operator|)
expr_stmt|;
comment|/* Backup the file if requested. */
if|if
condition|(
operator|!
name|opts_empty
argument_list|(
name|sp
argument_list|,
name|O_BACKUP
argument_list|,
literal|1
argument_list|)
operator|&&
name|file_backup
argument_list|(
name|sp
argument_list|,
name|name
argument_list|,
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_BACKUP
argument_list|)
argument_list|)
operator|&&
operator|!
name|LF_ISSET
argument_list|(
name|FS_FORCE
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Open the file. */
name|SIGBLOCK
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|oflags
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IRGRP
operator||
name|S_IWGRP
operator||
name|S_IROTH
operator||
name|S_IWOTH
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EACCES
operator|&&
name|LF_ISSET
argument_list|(
name|FS_FORCE
argument_list|)
condition|)
block|{
comment|/* 			 * If the user owns the file but does not 			 * have write permission on it, grant it 			 * automatically for the duration of the 			 * opening of the file, if possible. 			 */
name|struct
name|stat
name|sb
decl_stmt|;
name|mode_t
name|fmode
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail_open
goto|;
name|fmode
operator|=
name|sb
operator|.
name|st_mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IWUSR
operator|)
operator|&&
name|sb
operator|.
name|st_uid
operator|==
name|getuid
argument_list|()
condition|)
name|fmode
operator||=
name|S_IWUSR
expr_stmt|;
else|else
goto|goto
name|fail_open
goto|;
if|if
condition|(
name|chmod
argument_list|(
name|name
argument_list|,
name|fmode
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail_open
goto|;
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|oflags
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IRGRP
operator||
name|S_IWGRP
operator||
name|S_IROTH
operator||
name|S_IWOTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
goto|goto
name|fail_open
goto|;
operator|(
name|void
operator|)
name|fchmod
argument_list|(
name|fd
argument_list|,
name|sb
operator|.
name|st_mode
argument_list|)
expr_stmt|;
goto|goto
name|success_open
goto|;
name|fail_open
label|:
name|errno
operator|=
name|EACCES
expr_stmt|;
block|}
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|name
argument_list|,
literal|"%s"
argument_list|)
expr_stmt|;
name|SIGUNBLOCK
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|success_open
label|:
name|SIGUNBLOCK
expr_stmt|;
comment|/* Try and get a lock. */
if|if
condition|(
operator|!
name|noname
operator|&&
name|file_lock
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
operator|==
name|LOCK_UNAVAIL
condition|)
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|name
argument_list|,
literal|"252|%s: write lock was unavailable"
argument_list|)
expr_stmt|;
if|#
directive|if
name|__linux__
comment|/* 	 * XXX 	 * In libc 4.5.x, fdopen(fd, "w") clears the O_APPEND flag (if set). 	 * This bug is fixed in libc 4.6.x. 	 * 	 * This code works around this problem for libc 4.5.x users. 	 * Note that this code is harmless if you're using libc 4.6.x. 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_APPEND
argument_list|)
operator|&&
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 	 * Use stdio for buffering. 	 * 	 * XXX 	 * SVR4.2 requires the fdopen mode exactly match the original open 	 * mode, i.e. you have to open with "a" if appending. 	 */
if|if
condition|(
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
name|LF_ISSET
argument_list|(
name|FS_APPEND
argument_list|)
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|name
argument_list|,
literal|"%s"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Build fake addresses, if necessary. */
if|if
condition|(
name|fm
operator|==
name|NULL
condition|)
block|{
name|from
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
name|from
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
name|fm
operator|=
operator|&
name|from
expr_stmt|;
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|to
operator|.
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|to
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
name|tm
operator|=
operator|&
name|to
expr_stmt|;
block|}
name|rval
operator|=
name|ex_writefp
argument_list|(
name|sp
argument_list|,
name|name
argument_list|,
name|fp
argument_list|,
name|fm
argument_list|,
name|tm
argument_list|,
operator|&
name|nlno
argument_list|,
operator|&
name|nch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Save the new last modification time -- even if the write fails 	 * we re-init the time.  That way the user can clean up the disk 	 * and rewrite without having to force it. 	 */
if|if
condition|(
name|noname
condition|)
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
name|time
argument_list|(
operator|&
name|ep
operator|->
name|mtime
argument_list|)
expr_stmt|;
else|else
block|{
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_DEVSET
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mdev
operator|=
name|sb
operator|.
name|st_dev
expr_stmt|;
name|ep
operator|->
name|minode
operator|=
name|sb
operator|.
name|st_ino
expr_stmt|;
name|ep
operator|->
name|mtime
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
block|}
comment|/* 	 * If the write failed, complain loudly.  ex_writefp() has already 	 * complained about the actual error, reinforce it if data was lost. 	 */
if|if
condition|(
name|rval
condition|)
block|{
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_APPEND
argument_list|)
condition|)
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|name
argument_list|,
literal|"254|%s: WARNING: FILE TRUNCATED"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Once we've actually written the file, it doesn't matter that the 	 * file name was changed -- if it was, we've already whacked it. 	 */
name|F_CLR
argument_list|(
name|frp
argument_list|,
name|FR_NAMECHANGE
argument_list|)
expr_stmt|;
comment|/* 	 * If wrote the entire file, and it wasn't by appending it to a file, 	 * clear the modified bit.  If the file was written to the original 	 * file name and the file is a temporary, set the "no exit" bit.  This 	 * permits the user to write the file and use it in the context of the 	 * filesystem, but still keeps them from discarding their changes by 	 * exiting. 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_ALL
argument_list|)
operator|&&
operator|!
name|LF_ISSET
argument_list|(
name|FS_APPEND
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_TMPFILE
argument_list|)
condition|)
if|if
condition|(
name|noname
condition|)
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_TMPEXIT
argument_list|)
expr_stmt|;
else|else
name|F_CLR
argument_list|(
name|frp
argument_list|,
name|FR_TMPEXIT
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|name
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mtype
condition|)
block|{
case|case
name|NEWFILE
case|:
name|msgstr
operator|=
name|msg_cat
argument_list|(
name|sp
argument_list|,
literal|"256|%s: new file: %lu lines, %lu characters"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|len
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|msgstr
argument_list|,
name|p
argument_list|,
name|nlno
argument_list|,
name|nch
argument_list|)
expr_stmt|;
break|break;
case|case
name|OLDFILE
case|:
name|msgstr
operator|=
name|msg_cat
argument_list|(
name|sp
argument_list|,
name|LF_ISSET
argument_list|(
name|FS_APPEND
argument_list|)
condition|?
literal|"315|%s: appended: %lu lines, %lu characters"
else|:
literal|"257|%s: %lu lines, %lu characters"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|len
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|msgstr
argument_list|,
name|p
argument_list|,
name|nlno
argument_list|,
name|nch
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * There's a nasty problem with long path names.  Cscope and tags files 	 * can result in long paths and vi will request a continuation key from 	 * the user.  Unfortunately, the user has typed ahead, and chaos will 	 * result.  If we assume that the characters in the filenames only take 	 * a single screen column each, we can trim the filename. 	 */
name|s
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|sp
operator|->
name|cols
condition|)
block|{
for|for
control|(
name|s
operator|=
name|buf
operator|,
name|t
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
init|;
name|s
operator|<
name|t
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'/'
operator|||
name|len
operator|>=
name|sp
operator|->
name|cols
operator|-
literal|3
operator|)
condition|;
operator|++
name|s
operator|,
operator|--
name|len
control|)
empty_stmt|;
if|if
condition|(
name|s
operator|==
name|t
condition|)
name|s
operator|=
name|buf
expr_stmt|;
else|else
block|{
operator|*
operator|--
name|s
operator|=
literal|'.'
expr_stmt|;
comment|/* Leading ellipses. */
operator|*
operator|--
name|s
operator|=
literal|'.'
expr_stmt|;
operator|*
operator|--
name|s
operator|=
literal|'.'
expr_stmt|;
block|}
block|}
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * file_backup --  *	Backup the about-to-be-written file.  *  * XXX  * We do the backup by copying the entire file.  It would be nice to do  * a rename instead, but: (1) both files may not fit and we want to fail  * before doing the rename; (2) the backup file may not be on the same  * disk partition as the file being written; (3) there may be optional  * file information (MACs, DACs, whatever) that we won't get right if we  * recreate the file.  So, let's not risk it.  */
end_comment

begin_function
specifier|static
name|int
name|file_backup
parameter_list|(
name|sp
parameter_list|,
name|name
parameter_list|,
name|bname
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|bname
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|EXCMD
name|cmd
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|size_t
name|blen
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|maxnum
decl_stmt|,
name|nr
decl_stmt|,
name|num
decl_stmt|,
name|nw
decl_stmt|,
name|rfd
decl_stmt|,
name|wfd
decl_stmt|,
name|version
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|estr
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|pct
decl_stmt|,
modifier|*
name|slash
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|wfname
decl_stmt|,
name|buf
index|[
literal|8192
index|]
decl_stmt|;
name|rfd
operator|=
name|wfd
operator|=
operator|-
literal|1
expr_stmt|;
name|bp
operator|=
name|estr
operator|=
name|wfname
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Open the current file for reading.  Do this first, so that 	 * we don't exec a shell before the most likely failure point. 	 * If it doesn't exist, it's okay, there's just nothing to back 	 * up. 	 */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rfd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|estr
operator|=
name|name
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 	 * If the name starts with an 'N' character, add a version number 	 * to the name.  Strip the leading N from the string passed to the 	 * expansion routines, for no particular reason.  It would be nice 	 * to permit users to put the version number anywhere in the backup 	 * name, but there isn't a special character that we can use in the 	 * name, and giving a new character a special meaning leads to ugly 	 * hacks both here and in the supporting ex routines. 	 * 	 * Shell and file name expand the option's value. 	 */
name|argv_init
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|ex_cinit
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bname
index|[
literal|0
index|]
operator|==
literal|'N'
condition|)
block|{
name|version
operator|=
literal|1
expr_stmt|;
operator|++
name|bname
expr_stmt|;
block|}
else|else
name|version
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argv_exp2
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|bname
argument_list|,
name|strlen
argument_list|(
name|bname
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 *  0 args: impossible. 	 *  1 args: use it. 	 *>1 args: object, too many args. 	 */
if|if
condition|(
name|cmd
operator|.
name|argc
operator|!=
literal|1
condition|)
block|{
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|bname
argument_list|,
literal|"258|%s expanded into too many file names"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * If appending a version number, read through the directory, looking 	 * for file names that match the name followed by a number.  Make all 	 * of the other % characters in name literal, so the user doesn't get 	 * surprised and sscanf doesn't drop core indirecting through pointers 	 * that don't exist.  If any such files are found, increment its number 	 * by one. 	 */
if|if
condition|(
name|version
condition|)
block|{
name|GET_SPACE_GOTO
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
name|cmd
operator|.
name|argv
index|[
literal|0
index|]
operator|->
name|len
operator|*
literal|2
operator|+
literal|50
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|bp
operator|,
name|slash
operator|=
name|NULL
operator|,
name|p
operator|=
name|cmd
operator|.
name|argv
index|[
literal|0
index|]
operator|->
name|bp
init|;
name|p
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|;
operator|*
name|t
operator|++
operator|=
operator|*
name|p
operator|++
control|)
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|'%'
condition|)
operator|*
name|t
operator|++
operator|=
literal|'%'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|slash
operator|=
name|t
expr_stmt|;
name|pct
operator|=
name|t
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'d'
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|slash
operator|==
name|NULL
condition|)
block|{
name|dirp
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|p
operator|=
name|bp
expr_stmt|;
block|}
else|else
block|{
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|dirp
operator|=
name|opendir
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|*
name|slash
operator|=
literal|'/'
expr_stmt|;
name|p
operator|=
name|slash
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dirp
operator|==
name|NULL
condition|)
block|{
name|estr
operator|=
name|cmd
operator|.
name|argv
index|[
literal|0
index|]
operator|->
name|bp
expr_stmt|;
goto|goto
name|err
goto|;
block|}
for|for
control|(
name|maxnum
operator|=
literal|0
init|;
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
name|sscanf
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|p
argument_list|,
operator|&
name|num
argument_list|)
operator|==
literal|1
operator|&&
name|num
operator|>
name|maxnum
condition|)
name|maxnum
operator|=
name|num
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
comment|/* Format the backup file name. */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pct
argument_list|,
name|blen
operator|-
operator|(
name|pct
operator|-
name|bp
operator|)
argument_list|,
literal|"%d"
argument_list|,
name|maxnum
operator|+
literal|1
argument_list|)
expr_stmt|;
name|wfname
operator|=
name|bp
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|=
name|NULL
expr_stmt|;
name|wfname
operator|=
name|cmd
operator|.
name|argv
index|[
literal|0
index|]
operator|->
name|bp
expr_stmt|;
block|}
comment|/* Open the backup file, avoiding lurkers. */
if|if
condition|(
name|stat
argument_list|(
name|wfname
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|bname
argument_list|,
literal|"259|%s: not a regular file"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|sb
operator|.
name|st_uid
operator|!=
name|getuid
argument_list|()
condition|)
block|{
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|bname
argument_list|,
literal|"260|%s: not owned by you"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|sb
operator|.
name|st_mode
operator|&
operator|(
name|S_IRGRP
operator||
name|S_IWGRP
operator||
name|S_IROTH
operator||
name|S_IWOTH
operator|)
condition|)
block|{
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|bname
argument_list|,
literal|"261|%s: accessible by a user other than the owner"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|flags
operator|=
name|O_TRUNC
expr_stmt|;
block|}
else|else
name|flags
operator|=
name|O_CREAT
operator||
name|O_EXCL
expr_stmt|;
if|if
condition|(
operator|(
name|wfd
operator|=
name|open
argument_list|(
name|wfname
argument_list|,
name|flags
operator||
name|O_WRONLY
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|estr
operator|=
name|bname
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Copy the file's current contents to its backup value. */
while|while
condition|(
operator|(
name|nr
operator|=
name|read
argument_list|(
name|rfd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
name|off
operator|=
literal|0
init|;
name|nr
operator|!=
literal|0
condition|;
name|nr
operator|-=
name|nw
operator|,
name|off
operator|+=
name|nw
control|)
if|if
condition|(
operator|(
name|nw
operator|=
name|write
argument_list|(
name|wfd
argument_list|,
name|buf
operator|+
name|off
argument_list|,
name|nr
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|estr
operator|=
name|wfname
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|nr
operator|<
literal|0
condition|)
block|{
name|estr
operator|=
name|name
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|close
argument_list|(
name|rfd
argument_list|)
condition|)
block|{
name|estr
operator|=
name|name
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|close
argument_list|(
name|wfd
argument_list|)
condition|)
block|{
name|estr
operator|=
name|wfname
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|alloc_err
label|:
name|err
label|:
if|if
condition|(
name|rfd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|wfd
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|wfname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|wfd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|estr
condition|)
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|estr
argument_list|,
literal|"%s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * file_comment --  *	Skip the first comment.  */
end_comment

begin_function
specifier|static
name|void
name|file_comment
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|recno_t
name|lno
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|lno
operator|=
literal|1
init|;
operator|!
name|db_get
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
operator|&&
name|len
operator|==
literal|0
condition|;
operator|++
name|lno
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_TOP
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|db_get
argument_list|(
name|sp
argument_list|,
operator|++
name|lno
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
condition|)
if|if
condition|(
name|len
operator|<
literal|1
operator|||
name|p
index|[
literal|0
index|]
operator|!=
literal|'#'
condition|)
block|{
name|sp
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|len
operator|>
literal|1
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_TOP
argument_list|)
expr_stmt|;
do|do
block|{
for|for
control|(
init|;
name|len
operator|>
literal|1
condition|;
operator|--
name|len
operator|,
operator|++
name|p
control|)
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|sp
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
return|return;
block|}
block|}
do|while
condition|(
operator|!
name|db_get
argument_list|(
name|sp
argument_list|,
operator|++
name|lno
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
literal|1
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_TOP
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
do|do
block|{
for|for
control|(
init|;
name|len
operator|>
literal|1
condition|;
operator|--
name|len
operator|,
operator|++
name|p
control|)
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|sp
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
return|return;
block|}
block|}
do|while
condition|(
operator|!
name|db_get
argument_list|(
name|sp
argument_list|,
operator|++
name|lno
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
condition|)
do|;
block|}
block|}
end_function

begin_comment
comment|/*  * file_m1 --  * 	First modification check routine.  The :next, :prev, :rewind, :tag,  *	:tagpush, :tagpop, ^^ modifications check.  *  * PUBLIC: int file_m1 __P((SCR *, int, int));  */
end_comment

begin_function
name|int
name|file_m1
parameter_list|(
name|sp
parameter_list|,
name|force
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|force
decl_stmt|,
name|flags
decl_stmt|;
block|{
name|EXF
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
comment|/* If no file loaded, return no modifications. */
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If the file has been modified, we'll want to write it back or 	 * fail.  If autowrite is set, we'll write it back automatically, 	 * unless force is also set.  Otherwise, we fail unless forced or 	 * there's another open screen on this file. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
condition|)
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_AUTOWRITE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|force
operator|&&
name|file_aw
argument_list|(
name|sp
argument_list|,
name|flags
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ep
operator|->
name|refcnt
operator|<=
literal|1
operator|&&
operator|!
name|force
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|LF_ISSET
argument_list|(
name|FS_POSSIBLE
argument_list|)
condition|?
literal|"262|File modified since last complete write; write or use ! to override"
else|:
literal|"263|File modified since last complete write; write or use :edit! to override"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|file_m3
argument_list|(
name|sp
argument_list|,
name|force
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_m2 --  * 	Second modification check routine.  The :edit, :quit, :recover  *	modifications check.  *  * PUBLIC: int file_m2 __P((SCR *, int));  */
end_comment

begin_function
name|int
name|file_m2
parameter_list|(
name|sp
parameter_list|,
name|force
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|EXF
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
comment|/* If no file loaded, return no modifications. */
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If the file has been modified, we'll want to fail, unless forced 	 * or there's another open screen on this file. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
operator|&&
name|ep
operator|->
name|refcnt
operator|<=
literal|1
operator|&&
operator|!
name|force
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"264|File modified since last complete write; write or use ! to override"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|file_m3
argument_list|(
name|sp
argument_list|,
name|force
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_m3 --  * 	Third modification check routine.  *  * PUBLIC: int file_m3 __P((SCR *, int));  */
end_comment

begin_function
name|int
name|file_m3
parameter_list|(
name|sp
parameter_list|,
name|force
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|EXF
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
comment|/* If no file loaded, return no modifications. */
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Don't exit while in a temporary files if the file was ever modified. 	 * The problem is that if the user does a ":wq", we write and quit, 	 * unlinking the temporary file.  Not what the user had in mind at all. 	 * We permit writing to temporary files, so that user maps using file 	 * system names work with temporary files. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
operator|->
name|frp
argument_list|,
name|FR_TMPEXIT
argument_list|)
operator|&&
name|ep
operator|->
name|refcnt
operator|<=
literal|1
operator|&&
operator|!
name|force
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"265|File is a temporary; exit will discard modifications"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_aw --  *	Autowrite routine.  If modified, autowrite is set and the readonly bit  *	is not set, write the file.  A routine so there's a place to put the  *	comment.  *  * PUBLIC: int file_aw __P((SCR *, int));  */
end_comment

begin_function
name|int
name|file_aw
parameter_list|(
name|sp
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
operator|->
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_AUTOWRITE
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * !!! 	 * Historic 4BSD vi attempted to write the file if autowrite was set, 	 * regardless of the writeability of the file (as defined by the file 	 * readonly flag).  System V changed this as some point, not attempting 	 * autowrite if the file was readonly.  This feels like a bug fix to 	 * me (e.g. the principle of least surprise is violated if readonly is 	 * set and vi writes the file), so I'm compatible with System V. 	 */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_READONLY
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"266|File readonly, modifications not auto-written"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|file_write
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * set_alt_name --  *	Set the alternate pathname.  *  * Set the alternate pathname.  It's a routine because I wanted some place  * to hang this comment.  The alternate pathname (normally referenced using  * the special character '#' during file expansion and in the vi ^^ command)  * is set by almost all ex commands that take file names as arguments.  The  * rules go something like this:  *  *    1: If any ex command takes a file name as an argument (except for the  *	 :next command), the alternate pathname is set to that file name.  *	 This excludes the command ":e" and ":w !command" as no file name  *       was specified.  Note, historically, the :source command did not set  *	 the alternate pathname.  It does in nvi, for consistency.  *  *    2: However, if any ex command sets the current pathname, e.g. the  *	 ":e file" or ":rew" commands succeed, then the alternate pathname  *	 is set to the previous file's current pathname, if it had one.  *	 This includes the ":file" command and excludes the ":e" command.  *	 So, by rule #1 and rule #2, if ":edit foo" fails, the alternate  *	 pathname will be "foo", if it succeeds, the alternate pathname will  *	 be the previous current pathname.  The ":e" command will not set  *       the alternate or current pathnames regardless.  *  *    3: However, if it's a read or write command with a file argument and  *	 the current pathname has not yet been set, the file name becomes  *	 the current pathname, and the alternate pathname is unchanged.  *  * If the user edits a temporary file, there may be times when there is no  * alternative file name.  A name argument of NULL turns it off.  *  * PUBLIC: void set_alt_name __P((SCR *, char *));  */
end_comment

begin_function
name|void
name|set_alt_name
parameter_list|(
name|sp
parameter_list|,
name|name
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|sp
operator|->
name|alt_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sp
operator|->
name|alt_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|sp
operator|->
name|alt_name
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sp
operator|->
name|alt_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * file_lock --  *	Get an exclusive lock on a file.  *  * XXX  * The default locking is flock(2) style, not fcntl(2).  The latter is  * known to fail badly on some systems, and its only advantage is that  * it occasionally works over NFS.  *  * Furthermore, the semantics of fcntl(2) are wrong.  The problems are  * two-fold: you can't close any file descriptor associated with the file  * without losing all of the locks, and you can't get an exclusive lock  * unless you have the file open for writing.  Someone ought to be shot,  * but it's probably too late, they may already have reproduced.  To get  * around these problems, nvi opens the files for writing when it can and  * acquires a second file descriptor when it can't.  The recovery files  * are examples of the former, they're always opened for writing.  The DB  * files can't be opened for writing because the semantics of DB are that  * files opened for writing are flushed back to disk when the DB session  * is ended. So, in that case we have to acquire an extra file descriptor.  *  * PUBLIC: lockr_t file_lock __P((SCR *, char *, int *, int, int));  */
end_comment

begin_function
name|lockr_t
name|file_lock
parameter_list|(
name|sp
parameter_list|,
name|name
parameter_list|,
name|fdp
parameter_list|,
name|fd
parameter_list|,
name|iswrite
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
modifier|*
name|fdp
decl_stmt|,
name|fd
decl_stmt|,
name|iswrite
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LOCKFILES
argument_list|)
condition|)
return|return
operator|(
name|LOCK_SUCCESS
operator|)
return|;
ifdef|#
directive|ifdef
name|HAVE_LOCK_FLOCK
comment|/* Hurrah!  We've got flock(2). */
comment|/* 	 * !!! 	 * We need to distinguish a lock not being available for the file 	 * from the file system not supporting locking.  Flock is documented 	 * as returning EWOULDBLOCK; add EAGAIN for good measure, and assume 	 * they are the former.  There's no portable way to do this. 	 */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
condition|)
block|{
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|LOCK_SUCCESS
operator|)
return|;
block|}
return|return
operator|(
name|errno
operator|==
name|EAGAIN
ifdef|#
directive|ifdef
name|EWOULDBLOCK
operator|||
name|errno
operator|==
name|EWOULDBLOCK
endif|#
directive|endif
condition|?
name|LOCK_UNAVAIL
else|:
name|LOCK_FAILED
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_LOCK_FCNTL
comment|/* Gag me.  We've got fcntl(2). */
block|{
name|struct
name|flock
name|arg
decl_stmt|;
name|int
name|didopen
decl_stmt|,
name|sverrno
decl_stmt|;
name|arg
operator|.
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
name|arg
operator|.
name|l_whence
operator|=
literal|0
expr_stmt|;
comment|/* SEEK_SET */
name|arg
operator|.
name|l_start
operator|=
name|arg
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
name|arg
operator|.
name|l_pid
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the file descriptor isn't opened for writing, it must fail. 	 * If we fail because we can't get a read/write file descriptor, 	 * we return LOCK_SUCCESS, believing that the file is readonly 	 * and that will be sufficient to warn the user. 	 */
if|if
condition|(
operator|!
name|iswrite
condition|)
block|{
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|fdp
operator|==
name|NULL
condition|)
return|return
operator|(
name|LOCK_FAILED
operator|)
return|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|LOCK_SUCCESS
operator|)
return|;
operator|*
name|fdp
operator|=
name|fd
expr_stmt|;
name|didopen
operator|=
literal|1
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETLK
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
block|{
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|LOCK_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
name|didopen
condition|)
block|{
name|sverrno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|sverrno
expr_stmt|;
block|}
comment|/* 	 * !!! 	 * We need to distinguish a lock not being available for the file 	 * from the file system not supporting locking.  Fcntl is documented 	 * as returning EACCESS and EAGAIN; add EWOULDBLOCK for good measure, 	 * and assume they are the former.  There's no portable way to do this. 	 */
return|return
operator|(
name|errno
operator|==
name|EACCES
operator|||
name|errno
operator|==
name|EAGAIN
ifdef|#
directive|ifdef
name|EWOULDBLOCK
operator|||
name|errno
operator|==
name|EWOULDBLOCK
endif|#
directive|endif
condition|?
name|LOCK_UNAVAIL
else|:
name|LOCK_FAILED
operator|)
return|;
block|}
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_LOCK_FLOCK
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_LOCK_FCNTL
argument_list|)
return|return
operator|(
name|LOCK_SUCCESS
operator|)
return|;
endif|#
directive|endif
block|}
end_function

end_unit

