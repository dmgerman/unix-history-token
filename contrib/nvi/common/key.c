begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1991, 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"$Id: key.c,v 10.54 2013/11/13 12:15:27 zy Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"../vi/vi.h"
end_include

begin_function_decl
specifier|static
name|int
name|v_event_append
parameter_list|(
name|SCR
modifier|*
parameter_list|,
name|EVENT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|v_event_grow
parameter_list|(
name|SCR
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|v_key_cmp
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|v_keyval
parameter_list|(
name|SCR
modifier|*
parameter_list|,
name|int
parameter_list|,
name|scr_keyval_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|v_sync
parameter_list|(
name|SCR
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * !!!  * Historic vi always used:  *  *	^D: autoindent deletion  *	^H: last character deletion  *	^W: last word deletion  *	^Q: quote the next character (if not used in flow control).  *	^V: quote the next character  *  * regardless of the user's choices for these characters.  The user's erase  * and kill characters worked in addition to these characters.  Nvi wires  * down the above characters, but in addition permits the VEOF, VERASE, VKILL  * and VWERASE characters described by the user's termios structure.  *  * Ex was not consistent with this scheme, as it historically ran in tty  * cooked mode.  This meant that the scroll command and autoindent erase  * characters were mapped to the user's EOF character, and the character  * and word deletion characters were the user's tty character and word  * deletion characters.  This implementation makes it all consistent, as  * described above for vi.  *  * !!!  * This means that all screens share a special key set.  */
end_comment

begin_decl_stmt
name|KEYLIST
name|keylist
index|[]
init|=
block|{
block|{
name|K_BACKSLASH
block|,
literal|'\\'
block|}
block|,
comment|/*  \ */
block|{
name|K_CARAT
block|,
literal|'^'
block|}
block|,
comment|/*  ^ */
block|{
name|K_CNTRLD
block|,
literal|'\004'
block|}
block|,
comment|/* ^D */
block|{
name|K_CNTRLR
block|,
literal|'\022'
block|}
block|,
comment|/* ^R */
block|{
name|K_CNTRLT
block|,
literal|'\024'
block|}
block|,
comment|/* ^T */
block|{
name|K_CNTRLZ
block|,
literal|'\032'
block|}
block|,
comment|/* ^Z */
block|{
name|K_COLON
block|,
literal|':'
block|}
block|,
comment|/*  : */
block|{
name|K_CR
block|,
literal|'\r'
block|}
block|,
comment|/* \r */
block|{
name|K_ESCAPE
block|,
literal|'\033'
block|}
block|,
comment|/* ^[ */
block|{
name|K_FORMFEED
block|,
literal|'\f'
block|}
block|,
comment|/* \f */
block|{
name|K_HEXCHAR
block|,
literal|'\030'
block|}
block|,
comment|/* ^X */
block|{
name|K_NL
block|,
literal|'\n'
block|}
block|,
comment|/* \n */
block|{
name|K_RIGHTBRACE
block|,
literal|'}'
block|}
block|,
comment|/*  } */
block|{
name|K_RIGHTPAREN
block|,
literal|')'
block|}
block|,
comment|/*  ) */
block|{
name|K_TAB
block|,
literal|'\t'
block|}
block|,
comment|/* \t */
block|{
name|K_VERASE
block|,
literal|'\b'
block|}
block|,
comment|/* \b */
block|{
name|K_VKILL
block|,
literal|'\025'
block|}
block|,
comment|/* ^U */
block|{
name|K_VLNEXT
block|,
literal|'\021'
block|}
block|,
comment|/* ^Q */
block|{
name|K_VLNEXT
block|,
literal|'\026'
block|}
block|,
comment|/* ^V */
block|{
name|K_VWERASE
block|,
literal|'\027'
block|}
block|,
comment|/* ^W */
block|{
name|K_ZERO
block|,
literal|'0'
block|}
block|,
comment|/*  0 */
define|#
directive|define
name|ADDITIONAL_CHARACTERS
value|4
block|{
name|K_NOTUSED
block|,
literal|0
block|}
block|,
comment|/* VEOF, VERASE, VKILL, VWERASE */
block|{
name|K_NOTUSED
block|,
literal|0
block|}
block|,
block|{
name|K_NOTUSED
block|,
literal|0
block|}
block|,
block|{
name|K_NOTUSED
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nkeylist
init|=
operator|(
sizeof|sizeof
argument_list|(
name|keylist
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|keylist
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
name|ADDITIONAL_CHARACTERS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * v_key_init --  *	Initialize the special key lookup table.  *  * PUBLIC: int v_key_init(SCR *);  */
end_comment

begin_function
name|int
name|v_key_init
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|KEYLIST
modifier|*
name|kp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|v_key_ilookup
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|v_keyval
argument_list|(
name|sp
argument_list|,
name|K_CNTRLD
argument_list|,
name|KEY_VEOF
argument_list|)
expr_stmt|;
name|v_keyval
argument_list|(
name|sp
argument_list|,
name|K_VERASE
argument_list|,
name|KEY_VERASE
argument_list|)
expr_stmt|;
name|v_keyval
argument_list|(
name|sp
argument_list|,
name|K_VKILL
argument_list|,
name|KEY_VKILL
argument_list|)
expr_stmt|;
name|v_keyval
argument_list|(
name|sp
argument_list|,
name|K_VWERASE
argument_list|,
name|KEY_VWERASE
argument_list|)
expr_stmt|;
comment|/* Sort the special key list. */
name|qsort
argument_list|(
name|keylist
argument_list|,
name|nkeylist
argument_list|,
sizeof|sizeof
argument_list|(
name|keylist
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|v_key_cmp
argument_list|)
expr_stmt|;
comment|/* Initialize the fast lookup table. */
for|for
control|(
name|kp
operator|=
name|keylist
operator|,
name|cnt
operator|=
name|nkeylist
init|;
name|cnt
operator|--
condition|;
operator|++
name|kp
control|)
name|gp
operator|->
name|special_key
index|[
name|kp
operator|->
name|ch
index|]
operator|=
name|kp
operator|->
name|value
expr_stmt|;
comment|/* Find a non-printable character to use as a message separator. */
for|for
control|(
name|ch
operator|=
literal|1
init|;
name|ch
operator|<=
name|UCHAR_MAX
condition|;
operator|++
name|ch
control|)
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|gp
operator|->
name|noprint
operator|=
name|ch
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ch
operator|!=
name|gp
operator|->
name|noprint
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"079|No non-printable character found"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_keyval --  *	Set key values.  *  * We've left some open slots in the keylist table, and if these values exist,  * we put them into place.  Note, they may reset (or duplicate) values already  * in the table, so we check for that first.  */
end_comment

begin_function
specifier|static
name|void
name|v_keyval
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|int
name|val
parameter_list|,
name|scr_keyval_t
name|name
parameter_list|)
block|{
name|KEYLIST
modifier|*
name|kp
decl_stmt|;
name|CHAR_T
name|ch
decl_stmt|;
name|int
name|dne
decl_stmt|;
comment|/* Get the key's value from the screen. */
if|if
condition|(
name|sp
operator|->
name|gp
operator|->
name|scr_keyval
argument_list|(
name|sp
argument_list|,
name|name
argument_list|,
operator|&
name|ch
argument_list|,
operator|&
name|dne
argument_list|)
condition|)
return|return;
if|if
condition|(
name|dne
condition|)
return|return;
comment|/* Check for duplication. */
for|for
control|(
name|kp
operator|=
name|keylist
init|;
name|kp
operator|->
name|value
operator|!=
name|K_NOTUSED
condition|;
operator|++
name|kp
control|)
if|if
condition|(
name|kp
operator|->
name|ch
operator|==
name|ch
condition|)
block|{
name|kp
operator|->
name|value
operator|=
name|val
expr_stmt|;
return|return;
block|}
comment|/* Add a new entry. */
if|if
condition|(
name|kp
operator|->
name|value
operator|==
name|K_NOTUSED
condition|)
block|{
name|keylist
index|[
name|nkeylist
index|]
operator|.
name|ch
operator|=
name|ch
expr_stmt|;
name|keylist
index|[
name|nkeylist
index|]
operator|.
name|value
operator|=
name|val
expr_stmt|;
operator|++
name|nkeylist
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * v_key_ilookup --  *	Build the fast-lookup key display array.  *  * PUBLIC: void v_key_ilookup(SCR *);  */
end_comment

begin_function
name|void
name|v_key_ilookup
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|UCHAR_T
name|ch
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
for|for
control|(
name|gp
operator|=
name|sp
operator|->
name|gp
operator|,
name|ch
operator|=
literal|0
init|;
condition|;
operator|++
name|ch
control|)
block|{
for|for
control|(
name|p
operator|=
name|gp
operator|->
name|cname
index|[
name|ch
index|]
operator|.
name|name
operator|,
name|t
operator|=
name|v_key_name
argument_list|(
name|sp
argument_list|,
name|ch
argument_list|)
operator|,
name|len
operator|=
name|gp
operator|->
name|cname
index|[
name|ch
index|]
operator|.
name|len
operator|=
name|sp
operator|->
name|clen
init|;
name|len
operator|--
condition|;
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|MAX_FAST_KEY
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * v_key_len --  *	Return the length of the string that will display the key.  *	This routine is the backup for the KEY_LEN() macro.  *  * PUBLIC: size_t v_key_len(SCR *, ARG_CHAR_T);  */
end_comment

begin_function
name|size_t
name|v_key_len
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|ARG_CHAR_T
name|ch
parameter_list|)
block|{
operator|(
name|void
operator|)
name|v_key_name
argument_list|(
name|sp
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|sp
operator|->
name|clen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_key_name --  *	Return the string that will display the key.  This routine  *	is the backup for the KEY_NAME() macro.  *  * PUBLIC: char *v_key_name(SCR *, ARG_CHAR_T);  */
end_comment

begin_function
name|char
modifier|*
name|v_key_name
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|ARG_CHAR_T
name|ach
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|hexdigit
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
specifier|static
specifier|const
name|char
name|octdigit
index|[]
init|=
literal|"01234567"
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|chp
decl_stmt|;
comment|/* 	 * Cache the last checked character.  It won't be a problem 	 * since nvi will rescan the mapping when settings changed. 	 */
if|if
condition|(
name|ach
operator|&&
name|sp
operator|->
name|lastc
operator|==
name|ach
condition|)
return|return
operator|(
name|sp
operator|->
name|cname
operator|)
return|;
name|sp
operator|->
name|lastc
operator|=
name|ach
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WIDECHAR
name|len
operator|=
name|wctomb
argument_list|(
name|sp
operator|->
name|cname
argument_list|,
name|ach
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MB_CUR_MAX
condition|)
endif|#
directive|endif
name|sp
operator|->
name|cname
index|[
operator|(
name|len
operator|=
literal|1
operator|)
operator|-
literal|1
index|]
operator|=
operator|(
name|u_char
operator|)
name|ach
expr_stmt|;
name|ch
operator|=
operator|(
name|u_char
operator|)
name|sp
operator|->
name|cname
index|[
literal|0
index|]
expr_stmt|;
name|sp
operator|->
name|cname
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* See if the character was explicitly declared printable or not. */
if|if
condition|(
operator|(
name|chp
operator|=
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_PRINT
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|strstr
argument_list|(
name|chp
argument_list|,
name|sp
operator|->
name|cname
argument_list|)
operator|!=
name|NULL
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|chp
operator|=
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_NOPRINT
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|strstr
argument_list|(
name|chp
argument_list|,
name|sp
operator|->
name|cname
argument_list|)
operator|!=
name|NULL
condition|)
goto|goto
name|nopr
goto|;
comment|/* 	 * Historical (ARPA standard) mappings.  Printable characters are left 	 * alone.  Control characters less than 0x20 are represented as '^' 	 * followed by the character offset from the '@' character in the ASCII 	 * character set.  Del (0x7f) is represented as '^' followed by '?'. 	 * 	 * XXX 	 * The following code depends on the current locale being identical to 	 * the ASCII map from 0x40 to 0x5f (since 0x1f + 0x40 == 0x5f).  I'm 	 * told that this is a reasonable assumption... 	 * 	 * XXX 	 * The code prints non-printable wide characters in 4 or 5 digits 	 * Unicode escape sequences, so only supports plane 0 to 15. 	 */
if|if
condition|(
name|CAN_PRINT
argument_list|(
name|sp
argument_list|,
name|ach
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|nopr
label|:
if|if
condition|(
name|iscntrl
argument_list|(
name|ch
argument_list|)
operator|&&
operator|(
name|ch
operator|<
literal|0x20
operator|||
name|ch
operator|==
literal|0x7f
operator|)
condition|)
block|{
name|sp
operator|->
name|cname
index|[
literal|0
index|]
operator|=
literal|'^'
expr_stmt|;
name|sp
operator|->
name|cname
index|[
literal|1
index|]
operator|=
name|ch
operator|==
literal|0x7f
condition|?
literal|'?'
else|:
literal|'@'
operator|+
name|ch
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
goto|goto
name|done
goto|;
block|}
ifdef|#
directive|ifdef
name|USE_WIDECHAR
if|if
condition|(
name|INTISWIDE
argument_list|(
name|ach
argument_list|)
condition|)
block|{
name|int
name|uc
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|codeset
argument_list|()
argument_list|,
literal|"UTF-8"
argument_list|)
condition|)
name|uc
operator|=
name|decode_utf8
argument_list|(
name|sp
operator|->
name|cname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_ICONV
else|else
block|{
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|cname
argument_list|)
index|]
init|=
literal|""
decl_stmt|;
name|size_t
name|left
init|=
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|cname
argument_list|)
decl_stmt|;
name|char
modifier|*
name|in
init|=
name|sp
operator|->
name|cname
decl_stmt|;
name|char
modifier|*
name|out
init|=
name|buf
decl_stmt|;
name|iconv
argument_list|(
name|sp
operator|->
name|conv
operator|.
name|id
index|[
name|IC_IE_TO_UTF16
index|]
argument_list|,
operator|(
name|iconv_src_t
operator|)
operator|&
name|in
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
name|iconv
argument_list|(
name|sp
operator|->
name|conv
operator|.
name|id
index|[
name|IC_IE_TO_UTF16
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|uc
operator|=
name|decode_utf16
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|uc
operator|>=
literal|0
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|sp
operator|->
name|cname
argument_list|,
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|cname
argument_list|)
argument_list|,
name|uc
operator|<
literal|0x10000
condition|?
literal|"\\u%04x"
else|:
literal|"\\U%05X"
argument_list|,
name|uc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_OCTAL
argument_list|)
condition|)
block|{
name|sp
operator|->
name|cname
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|sp
operator|->
name|cname
index|[
literal|1
index|]
operator|=
name|octdigit
index|[
operator|(
name|ch
operator|&
literal|0300
operator|)
operator|>>
literal|6
index|]
expr_stmt|;
name|sp
operator|->
name|cname
index|[
literal|2
index|]
operator|=
name|octdigit
index|[
operator|(
name|ch
operator|&
literal|070
operator|)
operator|>>
literal|3
index|]
expr_stmt|;
name|sp
operator|->
name|cname
index|[
literal|3
index|]
operator|=
name|octdigit
index|[
name|ch
operator|&
literal|07
index|]
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|cname
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|sp
operator|->
name|cname
index|[
literal|1
index|]
operator|=
literal|'x'
expr_stmt|;
name|sp
operator|->
name|cname
index|[
literal|2
index|]
operator|=
name|hexdigit
index|[
operator|(
name|ch
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
index|]
expr_stmt|;
name|sp
operator|->
name|cname
index|[
literal|3
index|]
operator|=
name|hexdigit
index|[
name|ch
operator|&
literal|0x0f
index|]
expr_stmt|;
block|}
name|len
operator|=
literal|4
expr_stmt|;
name|done
label|:
name|sp
operator|->
name|cname
index|[
name|sp
operator|->
name|clen
operator|=
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|sp
operator|->
name|cname
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_key_val --  *	Fill in the value for a key.  This routine is the backup  *	for the KEY_VAL() macro.  *  * PUBLIC: e_key_t v_key_val(SCR *, ARG_CHAR_T);  */
end_comment

begin_function
name|e_key_t
name|v_key_val
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|ARG_CHAR_T
name|ch
parameter_list|)
block|{
name|KEYLIST
name|k
decl_stmt|,
modifier|*
name|kp
decl_stmt|;
name|k
operator|.
name|ch
operator|=
name|ch
expr_stmt|;
name|kp
operator|=
name|bsearch
argument_list|(
operator|&
name|k
argument_list|,
name|keylist
argument_list|,
name|nkeylist
argument_list|,
sizeof|sizeof
argument_list|(
name|keylist
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|v_key_cmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|kp
operator|==
name|NULL
condition|?
name|K_NOTUSED
else|:
name|kp
operator|->
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_event_push --  *	Push events/keys onto the front of the buffer.  *  * There is a single input buffer in ex/vi.  Characters are put onto the  * end of the buffer by the terminal input routines, and pushed onto the  * front of the buffer by various other functions in ex/vi.  Each key has  * an associated flag value, which indicates if it has already been quoted,  * and if it is the result of a mapping or an abbreviation.  *  * PUBLIC: int v_event_push(SCR *, EVENT *, CHAR_T *, size_t, u_int);  */
end_comment

begin_function
name|int
name|v_event_push
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EVENT
modifier|*
name|p_evp
parameter_list|,
comment|/* Push event. */
name|CHAR_T
modifier|*
name|p_s
parameter_list|,
comment|/* Push characters. */
name|size_t
name|nitems
parameter_list|,
comment|/* Number of items to push. */
name|u_int
name|flags
parameter_list|)
comment|/* CH_* flags. */
block|{
name|EVENT
modifier|*
name|evp
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|size_t
name|total
decl_stmt|;
comment|/* If we have room, stuff the items into the buffer. */
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
if|if
condition|(
name|nitems
operator|<=
name|gp
operator|->
name|i_next
operator|||
operator|(
name|gp
operator|->
name|i_event
operator|!=
name|NULL
operator|&&
name|gp
operator|->
name|i_cnt
operator|==
literal|0
operator|&&
name|nitems
operator|<=
name|gp
operator|->
name|i_nelem
operator|)
condition|)
block|{
if|if
condition|(
name|gp
operator|->
name|i_cnt
operator|!=
literal|0
condition|)
name|gp
operator|->
name|i_next
operator|-=
name|nitems
expr_stmt|;
goto|goto
name|copy
goto|;
block|}
comment|/* 	 * If there are currently items in the queue, shift them up, 	 * leaving some extra room.  Get enough space plus a little 	 * extra. 	 */
define|#
directive|define
name|TERM_PUSH_SHIFT
value|30
name|total
operator|=
name|gp
operator|->
name|i_cnt
operator|+
name|gp
operator|->
name|i_next
operator|+
name|nitems
operator|+
name|TERM_PUSH_SHIFT
expr_stmt|;
if|if
condition|(
name|total
operator|>=
name|gp
operator|->
name|i_nelem
operator|&&
name|v_event_grow
argument_list|(
name|sp
argument_list|,
name|MAX
argument_list|(
name|total
argument_list|,
literal|64
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|gp
operator|->
name|i_cnt
condition|)
name|BCOPY
argument_list|(
name|gp
operator|->
name|i_event
operator|+
name|gp
operator|->
name|i_next
argument_list|,
name|gp
operator|->
name|i_event
operator|+
name|TERM_PUSH_SHIFT
operator|+
name|nitems
argument_list|,
name|gp
operator|->
name|i_cnt
argument_list|)
expr_stmt|;
name|gp
operator|->
name|i_next
operator|=
name|TERM_PUSH_SHIFT
expr_stmt|;
comment|/* Put the new items into the queue. */
name|copy
label|:
name|gp
operator|->
name|i_cnt
operator|+=
name|nitems
expr_stmt|;
for|for
control|(
name|evp
operator|=
name|gp
operator|->
name|i_event
operator|+
name|gp
operator|->
name|i_next
init|;
name|nitems
operator|--
condition|;
operator|++
name|evp
control|)
block|{
if|if
condition|(
name|p_evp
operator|!=
name|NULL
condition|)
operator|*
name|evp
operator|=
operator|*
name|p_evp
operator|++
expr_stmt|;
else|else
block|{
name|evp
operator|->
name|e_event
operator|=
name|E_CHARACTER
expr_stmt|;
name|evp
operator|->
name|e_c
operator|=
operator|*
name|p_s
operator|++
expr_stmt|;
name|evp
operator|->
name|e_value
operator|=
name|KEY_VAL
argument_list|(
name|sp
argument_list|,
name|evp
operator|->
name|e_c
argument_list|)
expr_stmt|;
name|F_INIT
argument_list|(
operator|&
name|evp
operator|->
name|e_ch
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_event_append --  *	Append events onto the tail of the buffer.  */
end_comment

begin_function
specifier|static
name|int
name|v_event_append
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EVENT
modifier|*
name|argp
parameter_list|)
block|{
name|CHAR_T
modifier|*
name|s
decl_stmt|;
comment|/* Characters. */
name|EVENT
modifier|*
name|evp
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|size_t
name|nevents
decl_stmt|;
comment|/* Number of events. */
comment|/* Grow the buffer as necessary. */
name|nevents
operator|=
name|argp
operator|->
name|e_event
operator|==
name|E_STRING
condition|?
name|argp
operator|->
name|e_len
else|:
literal|1
expr_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
if|if
condition|(
name|gp
operator|->
name|i_event
operator|==
name|NULL
operator|||
name|nevents
operator|>
name|gp
operator|->
name|i_nelem
operator|-
operator|(
name|gp
operator|->
name|i_next
operator|+
name|gp
operator|->
name|i_cnt
operator|)
condition|)
name|v_event_grow
argument_list|(
name|sp
argument_list|,
name|MAX
argument_list|(
name|nevents
argument_list|,
literal|64
argument_list|)
argument_list|)
expr_stmt|;
name|evp
operator|=
name|gp
operator|->
name|i_event
operator|+
name|gp
operator|->
name|i_next
operator|+
name|gp
operator|->
name|i_cnt
expr_stmt|;
name|gp
operator|->
name|i_cnt
operator|+=
name|nevents
expr_stmt|;
comment|/* Transform strings of characters into single events. */
if|if
condition|(
name|argp
operator|->
name|e_event
operator|==
name|E_STRING
condition|)
for|for
control|(
name|s
operator|=
name|argp
operator|->
name|e_csp
init|;
name|nevents
operator|--
condition|;
operator|++
name|evp
control|)
block|{
name|evp
operator|->
name|e_event
operator|=
name|E_CHARACTER
expr_stmt|;
name|evp
operator|->
name|e_c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|evp
operator|->
name|e_value
operator|=
name|KEY_VAL
argument_list|(
name|sp
argument_list|,
name|evp
operator|->
name|e_c
argument_list|)
expr_stmt|;
name|evp
operator|->
name|e_flags
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|*
name|evp
operator|=
operator|*
name|argp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Remove events from the queue. */
end_comment

begin_define
define|#
directive|define
name|QREM
parameter_list|(
name|len
parameter_list|)
value|{							\ 	if ((gp->i_cnt -= len) == 0)					\ 		gp->i_next = 0;						\ 	else								\ 		gp->i_next += len;					\ }
end_define

begin_comment
comment|/*  * v_event_get --  *	Return the next event.  *  * !!!  * The flag EC_NODIGIT probably needs some explanation.  First, the idea of  * mapping keys is that one or more keystrokes act like a function key.  * What's going on is that vi is reading a number, and the character following  * the number may or may not be mapped (EC_MAPCOMMAND).  For example, if the  * user is entering the z command, a valid command is "z40+", and we don't want  * to map the '+', i.e. if '+' is mapped to "xxx", we don't want to change it  * into "z40xxx".  However, if the user enters "35x", we want to put all of the  * characters through the mapping code.  *  * Historical practice is a bit muddled here.  (Surprise!)  It always permitted  * mapping digits as long as they weren't the first character of the map, e.g.  * ":map ^A1 xxx" was okay.  It also permitted the mapping of the digits 1-9  * (the digit 0 was a special case as it doesn't indicate the start of a count)  * as the first character of the map, but then ignored those mappings.  While  * it's probably stupid to map digits, vi isn't your mother.  *  * The way this works is that the EC_MAPNODIGIT causes term_key to return the  * end-of-digit without "looking" at the next character, i.e. leaving it as the  * user entered it.  Presumably, the next term_key call will tell us how the  * user wants it handled.  *  * There is one more complication.  Users might map keys to digits, and, as  * it's described above, the commands:  *  *	:map g 1G  *	d2g  *  * would return the keys "d2<end-of-digits>1G", when the user probably wanted  * "d21<end-of-digits>G".  So, if a map starts off with a digit we continue as  * before, otherwise, we pretend we haven't mapped the character, and return  *<end-of-digits>.  *  * Now that that's out of the way, let's talk about Energizer Bunny macros.  * It's easy to create macros that expand to a loop, e.g. map x 3x.  It's  * fairly easy to detect this example, because it's all internal to term_key.  * If we're expanding a macro and it gets big enough, at some point we can  * assume it's looping and kill it.  The examples that are tough are the ones  * where the parser is involved, e.g. map x "ayyx"byy.  We do an expansion  * on 'x', and get "ayyx"byy.  We then return the first 4 characters, and then  * find the looping macro again.  There is no way that we can detect this  * without doing a full parse of the command, because the character that might  * cause the loop (in this case 'x') may be a literal character, e.g. the map  * map x "ayy"xyy"byy is perfectly legal and won't cause a loop.  *  * Historic vi tried to detect looping macros by disallowing obvious cases in  * the map command, maps that that ended with the same letter as they started  * (which wrongly disallowed "map x 'x"), and detecting macros that expanded  * too many times before keys were returned to the command parser.  It didn't  * get many (most?) of the tricky cases right, however, and it was certainly  * possible to create macros that ran forever.  And, even if it did figure out  * what was going on, the user was usually tossed into ex mode.  Finally, any  * changes made before vi realized that the macro was recursing were left in  * place.  We recover gracefully, but the only recourse the user has in an  * infinite macro loop is to interrupt.  *  * !!!  * It is historic practice that mapping characters to themselves as the first  * part of the mapped string was legal, and did not cause infinite loops, i.e.  * ":map! { {^M^T" and ":map n nz." were known to work.  The initial, matching  * characters were returned instead of being remapped.  *  * !!!  * It is also historic practice that the macro "map ] ]]^" caused a single ]  * keypress to behave as the command ]] (the ^ got the map past the vi check  * for "tail recursion").  Conversely, the mapping "map n nn^" went recursive.  * What happened was that, in the historic vi, maps were expanded as the keys  * were retrieved, but not all at once and not centrally.  So, the keypress ]  * pushed ]]^ on the stack, and then the first ] from the stack was passed to  * the ]] command code.  The ]] command then retrieved a key without entering  * the mapping code.  This could bite us anytime a user has a map that depends  * on secondary keys NOT being mapped.  I can't see any possible way to make  * this work in here without the complete abandonment of Rationality Itself.  *  * XXX  * The final issue is recovery.  It would be possible to undo all of the work  * that was done by the macro if we entered a record into the log so that we  * knew when the macro started, and, in fact, this might be worth doing at some  * point.  Given that this might make the log grow unacceptably (consider that  * cursor keys are done with maps), for now we leave any changes made in place.  *  * PUBLIC: int v_event_get(SCR *, EVENT *, int, u_int32_t);  */
end_comment

begin_function
name|int
name|v_event_get
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EVENT
modifier|*
name|argp
parameter_list|,
name|int
name|timeout
parameter_list|,
name|u_int32_t
name|flags
parameter_list|)
block|{
name|EVENT
modifier|*
name|evp
decl_stmt|,
name|ev
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|SEQ
modifier|*
name|qp
decl_stmt|;
name|int
name|init_nomap
decl_stmt|,
name|ispartial
decl_stmt|,
name|istimeout
decl_stmt|,
name|remap_cnt
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
comment|/* If simply checking for interrupts, argp may be NULL. */
if|if
condition|(
name|argp
operator|==
name|NULL
condition|)
name|argp
operator|=
operator|&
name|ev
expr_stmt|;
name|retry
label|:
name|istimeout
operator|=
name|remap_cnt
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the queue isn't empty and we're timing out for characters, 	 * return immediately. 	 */
if|if
condition|(
name|gp
operator|->
name|i_cnt
operator|!=
literal|0
operator|&&
name|LF_ISSET
argument_list|(
name|EC_TIMEOUT
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If the queue is empty, we're checking for interrupts, or we're 	 * timing out for characters, get more events. 	 */
if|if
condition|(
name|gp
operator|->
name|i_cnt
operator|==
literal|0
operator|||
name|LF_ISSET
argument_list|(
name|EC_INTERRUPT
operator||
name|EC_TIMEOUT
argument_list|)
condition|)
block|{
comment|/* 		 * If we're reading new characters, check any scripting 		 * windows for input. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|gp
argument_list|,
name|G_SCRWIN
argument_list|)
operator|&&
name|sscr_input
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|loop
label|:
if|if
condition|(
name|gp
operator|->
name|scr_event
argument_list|(
name|sp
argument_list|,
name|argp
argument_list|,
name|LF_ISSET
argument_list|(
name|EC_INTERRUPT
operator||
name|EC_QUOTED
operator||
name|EC_RAW
argument_list|)
argument_list|,
name|timeout
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|argp
operator|->
name|e_event
condition|)
block|{
case|case
name|E_ERR
case|:
case|case
name|E_SIGHUP
case|:
case|case
name|E_SIGTERM
case|:
comment|/* 			 * Fatal conditions cause the file to be synced to 			 * disk immediately. 			 */
name|v_sync
argument_list|(
name|sp
argument_list|,
name|RCV_ENDSESSION
operator||
name|RCV_PRESERVE
operator||
operator|(
name|argp
operator|->
name|e_event
operator|==
name|E_SIGTERM
condition|?
literal|0
else|:
name|RCV_EMAIL
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|E_TIMEOUT
case|:
name|istimeout
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|E_INTERRUPT
case|:
comment|/* Set the global interrupt flag. */
name|F_SET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_INTERRUPTED
argument_list|)
expr_stmt|;
comment|/* 			 * If the caller was interested in interrupts, return 			 * immediately. 			 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|EC_INTERRUPT
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
goto|goto
name|append
goto|;
default|default:
name|append
label|:
if|if
condition|(
name|v_event_append
argument_list|(
name|sp
argument_list|,
name|argp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
block|}
comment|/* 	 * If the caller was only interested in interrupts or timeouts, return 	 * immediately.  (We may have gotten characters, and that's okay, they 	 * were queued up for later use.) 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|EC_INTERRUPT
operator||
name|EC_TIMEOUT
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|newmap
label|:
name|evp
operator|=
operator|&
name|gp
operator|->
name|i_event
index|[
name|gp
operator|->
name|i_next
index|]
expr_stmt|;
comment|/*  	 * If the next event in the queue isn't a character event, return 	 * it, we're done. 	 */
if|if
condition|(
name|evp
operator|->
name|e_event
operator|!=
name|E_CHARACTER
condition|)
block|{
operator|*
name|argp
operator|=
operator|*
name|evp
expr_stmt|;
name|QREM
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the key isn't mappable because: 	 * 	 *	+ ... the timeout has expired 	 *	+ ... it's not a mappable key 	 *	+ ... neither the command or input map flags are set 	 *	+ ... there are no maps that can apply to it 	 * 	 * return it forthwith. 	 */
if|if
condition|(
name|istimeout
operator|||
name|F_ISSET
argument_list|(
operator|&
name|evp
operator|->
name|e_ch
argument_list|,
name|CH_NOMAP
argument_list|)
operator|||
operator|!
name|LF_ISSET
argument_list|(
name|EC_MAPCOMMAND
operator||
name|EC_MAPINPUT
argument_list|)
operator|||
operator|(
operator|(
name|evp
operator|->
name|e_c
operator|&
operator|~
name|MAX_BIT_SEQ
operator|)
operator|==
literal|0
operator|&&
operator|!
name|bit_test
argument_list|(
name|gp
operator|->
name|seqb
argument_list|,
name|evp
operator|->
name|e_c
argument_list|)
operator|)
condition|)
goto|goto
name|nomap
goto|;
comment|/* Search the map. */
name|qp
operator|=
name|seq_find
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|evp
argument_list|,
name|NULL
argument_list|,
name|gp
operator|->
name|i_cnt
argument_list|,
name|LF_ISSET
argument_list|(
name|EC_MAPCOMMAND
argument_list|)
condition|?
name|SEQ_COMMAND
else|:
name|SEQ_INPUT
argument_list|,
operator|&
name|ispartial
argument_list|)
expr_stmt|;
comment|/* 	 * If get a partial match, get more characters and retry the map. 	 * If time out without further characters, return the characters 	 * unmapped. 	 * 	 * !!! 	 *<escape> characters are a problem.  Cursor keys start with<escape> 	 * characters, so there's almost always a map in place that begins with 	 * an<escape> character.  If we timeout<escape> keys in the same way 	 * that we timeout other keys, the user will get a noticeable pause as 	 * they enter<escape> to terminate input mode.  If key timeout is set 	 * for a slow link, users will get an even longer pause.  Nvi used to 	 * simply timeout<escape> characters at 1/10th of a second, but this 	 * loses over PPP links where the latency is greater than 100Ms. 	 */
if|if
condition|(
name|ispartial
condition|)
block|{
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_TIMEOUT
argument_list|)
condition|)
name|timeout
operator|=
operator|(
name|evp
operator|->
name|e_value
operator|==
name|K_ESCAPE
condition|?
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_ESCAPETIME
argument_list|)
else|:
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_KEYTIME
argument_list|)
operator|)
operator|*
literal|100
expr_stmt|;
else|else
name|timeout
operator|=
literal|0
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
comment|/* If no map, return the character. */
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
block|{
name|nomap
label|:
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|evp
operator|->
name|e_c
argument_list|)
operator|&&
name|LF_ISSET
argument_list|(
name|EC_MAPNODIGIT
argument_list|)
condition|)
goto|goto
name|not_digit
goto|;
operator|*
name|argp
operator|=
operator|*
name|evp
expr_stmt|;
name|QREM
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If looking for the end of a digit string, and the first character 	 * of the map is it, pretend we haven't seen the character. 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|EC_MAPNODIGIT
argument_list|)
operator|&&
name|qp
operator|->
name|output
operator|!=
name|NULL
operator|&&
operator|!
name|ISDIGIT
argument_list|(
name|qp
operator|->
name|output
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|not_digit
label|:
name|argp
operator|->
name|e_c
operator|=
name|CH_NOT_DIGIT
expr_stmt|;
name|argp
operator|->
name|e_value
operator|=
name|K_NOTUSED
expr_stmt|;
name|argp
operator|->
name|e_event
operator|=
name|E_CHARACTER
expr_stmt|;
name|F_INIT
argument_list|(
operator|&
name|argp
operator|->
name|e_ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Find out if the initial segments are identical. */
name|init_nomap
operator|=
operator|!
name|e_memcmp
argument_list|(
name|qp
operator|->
name|output
argument_list|,
operator|&
name|gp
operator|->
name|i_event
index|[
name|gp
operator|->
name|i_next
index|]
argument_list|,
name|qp
operator|->
name|ilen
argument_list|)
expr_stmt|;
comment|/* Delete the mapped characters from the queue. */
name|QREM
argument_list|(
name|qp
operator|->
name|ilen
argument_list|)
expr_stmt|;
comment|/* If keys mapped to nothing, go get more. */
if|if
condition|(
name|qp
operator|->
name|output
operator|==
name|NULL
condition|)
goto|goto
name|retry
goto|;
comment|/* If remapping characters... */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_REMAP
argument_list|)
condition|)
block|{
comment|/* 		 * Periodically check for interrupts.  Always check the first 		 * time through, because it's possible to set up a map that 		 * will return a character every time, but will expand to more, 		 * e.g. "map! a aaaa" will always return a 'a', but we'll never 		 * get anywhere useful. 		 */
if|if
condition|(
operator|(
operator|++
name|remap_cnt
operator|==
literal|1
operator|||
name|remap_cnt
operator|%
literal|10
operator|==
literal|0
operator|)
operator|&&
operator|(
name|gp
operator|->
name|scr_event
argument_list|(
name|sp
argument_list|,
operator|&
name|ev
argument_list|,
name|EC_INTERRUPT
argument_list|,
literal|0
argument_list|)
operator|||
name|ev
operator|.
name|e_event
operator|==
name|E_INTERRUPT
operator|)
condition|)
block|{
name|F_SET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_INTERRUPTED
argument_list|)
expr_stmt|;
name|argp
operator|->
name|e_event
operator|=
name|E_INTERRUPT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * If an initial part of the characters mapped, they are not 		 * further remapped -- return the first one.  Push the rest 		 * of the characters, or all of the characters if no initial 		 * part mapped, back on the queue. 		 */
if|if
condition|(
name|init_nomap
condition|)
block|{
if|if
condition|(
name|v_event_push
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|qp
operator|->
name|output
operator|+
name|qp
operator|->
name|ilen
argument_list|,
name|qp
operator|->
name|olen
operator|-
name|qp
operator|->
name|ilen
argument_list|,
name|CH_MAPPED
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|v_event_push
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|qp
operator|->
name|output
argument_list|,
name|qp
operator|->
name|ilen
argument_list|,
name|CH_NOMAP
operator||
name|CH_MAPPED
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|evp
operator|=
operator|&
name|gp
operator|->
name|i_event
index|[
name|gp
operator|->
name|i_next
index|]
expr_stmt|;
goto|goto
name|nomap
goto|;
block|}
if|if
condition|(
name|v_event_push
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|qp
operator|->
name|output
argument_list|,
name|qp
operator|->
name|olen
argument_list|,
name|CH_MAPPED
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
goto|goto
name|newmap
goto|;
block|}
comment|/* Else, push the characters on the queue and return one. */
if|if
condition|(
name|v_event_push
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|qp
operator|->
name|output
argument_list|,
name|qp
operator|->
name|olen
argument_list|,
name|CH_MAPPED
operator||
name|CH_NOMAP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
goto|goto
name|nomap
goto|;
block|}
end_function

begin_comment
comment|/*  * v_sync --  *	Walk the screen lists, sync'ing files to their backup copies.  */
end_comment

begin_function
specifier|static
name|void
name|v_sync
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|gp->dq
argument_list|,
argument|q
argument_list|)
name|rcv_sync
argument_list|(
name|sp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|gp->hq
argument_list|,
argument|q
argument_list|)
name|rcv_sync
argument_list|(
name|sp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * v_event_err --  *	Unexpected event.  *  * PUBLIC: void v_event_err(SCR *, EVENT *);  */
end_comment

begin_function
name|void
name|v_event_err
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EVENT
modifier|*
name|evp
parameter_list|)
block|{
switch|switch
condition|(
name|evp
operator|->
name|e_event
condition|)
block|{
case|case
name|E_CHARACTER
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"276|Unexpected character event"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_EOF
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"277|Unexpected end-of-file event"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_INTERRUPT
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"279|Unexpected interrupt event"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_REPAINT
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"281|Unexpected repaint event"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_STRING
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"285|Unexpected string event"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_TIMEOUT
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"286|Unexpected timeout event"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_WRESIZE
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"316|Unexpected resize event"
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Theoretically, none of these can occur, as they're handled at the 	 * top editor level. 	 */
case|case
name|E_ERR
case|:
case|case
name|E_SIGHUP
case|:
case|case
name|E_SIGTERM
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Free any allocated memory. */
if|if
condition|(
name|evp
operator|->
name|e_asp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|evp
operator|->
name|e_asp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * v_event_flush --  *	Flush any flagged keys, returning if any keys were flushed.  *  * PUBLIC: int v_event_flush(SCR *, u_int);  */
end_comment

begin_function
name|int
name|v_event_flush
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|int
name|rval
decl_stmt|;
for|for
control|(
name|rval
operator|=
literal|0
operator|,
name|gp
operator|=
name|sp
operator|->
name|gp
init|;
name|gp
operator|->
name|i_cnt
operator|!=
literal|0
operator|&&
name|F_ISSET
argument_list|(
operator|&
name|gp
operator|->
name|i_event
index|[
name|gp
operator|->
name|i_next
index|]
operator|.
name|e_ch
argument_list|,
name|flags
argument_list|)
condition|;
name|rval
operator|=
literal|1
control|)
name|QREM
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_event_grow --  *	Grow the terminal queue.  */
end_comment

begin_function
specifier|static
name|int
name|v_event_grow
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|int
name|add
parameter_list|)
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|size_t
name|new_nelem
decl_stmt|,
name|olen
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|new_nelem
operator|=
name|gp
operator|->
name|i_nelem
operator|+
name|add
expr_stmt|;
name|olen
operator|=
name|gp
operator|->
name|i_nelem
operator|*
sizeof|sizeof
argument_list|(
name|gp
operator|->
name|i_event
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|EVENT
argument_list|,
name|gp
operator|->
name|i_event
argument_list|,
name|olen
argument_list|,
name|new_nelem
operator|*
sizeof|sizeof
argument_list|(
name|gp
operator|->
name|i_event
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|gp
operator|->
name|i_nelem
operator|=
name|olen
operator|/
sizeof|sizeof
argument_list|(
name|gp
operator|->
name|i_event
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_key_cmp --  *	Compare two keys for sorting.  */
end_comment

begin_function
specifier|static
name|int
name|v_key_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|ap
parameter_list|,
specifier|const
name|void
modifier|*
name|bp
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|KEYLIST
operator|*
operator|)
name|ap
operator|)
operator|->
name|ch
operator|-
operator|(
operator|(
name|KEYLIST
operator|*
operator|)
name|bp
operator|)
operator|->
name|ch
operator|)
return|;
block|}
end_function

end_unit

