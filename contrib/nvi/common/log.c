begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1992, 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)log.c	10.8 (Berkeley) 3/6/96"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_comment
comment|/*  * The log consists of records, each containing a type byte and a variable  * length byte string, as follows:  *  *	LOG_CURSOR_INIT		MARK  *	LOG_CURSOR_END		MARK  *	LOG_LINE_APPEND 	recno_t		char *  *	LOG_LINE_DELETE		recno_t		char *  *	LOG_LINE_INSERT		recno_t		char *  *	LOG_LINE_RESET_F	recno_t		char *  *	LOG_LINE_RESET_B	recno_t		char *  *	LOG_MARK		LMARK  *  * We do before image physical logging.  This means that the editor layer  * MAY NOT modify records in place, even if simply deleting or overwriting  * characters.  Since the smallest unit of logging is a line, we're using  * up lots of space.  This may eventually have to be reduced, probably by  * doing logical logging, which is a much cooler database phrase.  *  * The implementation of the historic vi 'u' command, using roll-forward and  * roll-back, is simple.  Each set of changes has a LOG_CURSOR_INIT record,  * followed by a number of other records, followed by a LOG_CURSOR_END record.  * LOG_LINE_RESET records come in pairs.  The first is a LOG_LINE_RESET_B  * record, and is the line before the change.  The second is LOG_LINE_RESET_F,  * and is the line after the change.  Roll-back is done by backing up to the  * first LOG_CURSOR_INIT record before a change.  Roll-forward is done in a  * similar fashion.  *  * The 'U' command is implemented by rolling backward to a LOG_CURSOR_END  * record for a line different from the current one.  It should be noted that  * this means that a subsequent 'u' command will make a change based on the  * new position of the log's cursor.  This is okay, and, in fact, historic vi  * behaved that way.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|log_cursor1
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|log_err
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|0
end_if

begin_decl_stmt
specifier|static
name|void
name|log_trace
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|char
operator|*
operator|,
name|recno_t
operator|,
name|u_char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Try and restart the log on failure, i.e. if we run out of memory. */
end_comment

begin_define
define|#
directive|define
name|LOG_ERR
value|{							\ 	log_err(sp, __FILE__, __LINE__);				\ 	return (1);							\ }
end_define

begin_comment
comment|/*  * log_init --  *	Initialize the logging subsystem.  *  * PUBLIC: int log_init __P((SCR *, EXF *));  */
end_comment

begin_function
name|int
name|log_init
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
comment|/* 	 * !!! 	 * ep MAY NOT BE THE SAME AS sp->ep, DON'T USE THE LATTER. 	 * 	 * Initialize the buffer.  The logging subsystem has its own 	 * buffers because the global ones are almost by definition 	 * going to be in use when the log runs. 	 */
name|ep
operator|->
name|l_lp
operator|=
name|NULL
expr_stmt|;
name|ep
operator|->
name|l_len
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|l_cursor
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
comment|/* XXX Any valid recno. */
name|ep
operator|->
name|l_cursor
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|l_high
operator|=
name|ep
operator|->
name|l_cur
operator|=
literal|1
expr_stmt|;
name|ep
operator|->
name|log
operator|=
name|dbopen
argument_list|(
name|NULL
argument_list|,
name|O_CREAT
operator||
name|O_NONBLOCK
operator||
name|O_RDWR
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|,
name|DB_RECNO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|log
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"009|Log file"
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_NOLOG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * log_end --  *	Close the logging subsystem.  *  * PUBLIC: int log_end __P((SCR *, EXF *));  */
end_comment

begin_function
name|int
name|log_end
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
comment|/* 	 * !!! 	 * ep MAY NOT BE THE SAME AS sp->ep, DON'T USE THE LATTER. 	 */
if|if
condition|(
name|ep
operator|->
name|log
operator|!=
name|NULL
condition|)
block|{
call|(
name|void
call|)
argument_list|(
name|ep
operator|->
name|log
operator|->
name|close
argument_list|)
argument_list|(
name|ep
operator|->
name|log
argument_list|)
expr_stmt|;
name|ep
operator|->
name|log
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|l_lp
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ep
operator|->
name|l_lp
argument_list|)
expr_stmt|;
name|ep
operator|->
name|l_lp
operator|=
name|NULL
expr_stmt|;
block|}
name|ep
operator|->
name|l_len
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|l_cursor
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
comment|/* XXX Any valid recno. */
name|ep
operator|->
name|l_cursor
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|l_high
operator|=
name|ep
operator|->
name|l_cur
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * log_cursor --  *	Log the current cursor position, starting an event.  *  * PUBLIC: int log_cursor __P((SCR *));  */
end_comment

begin_function
name|int
name|log_cursor
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|EXF
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_NOLOG
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If any changes were made since the last cursor init, 	 * put out the ending cursor record. 	 */
if|if
condition|(
name|ep
operator|->
name|l_cursor
operator|.
name|lno
operator|==
name|OOBLNO
condition|)
block|{
name|ep
operator|->
name|l_cursor
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|ep
operator|->
name|l_cursor
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
return|return
operator|(
name|log_cursor1
argument_list|(
name|sp
argument_list|,
name|LOG_CURSOR_END
argument_list|)
operator|)
return|;
block|}
name|ep
operator|->
name|l_cursor
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|ep
operator|->
name|l_cursor
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * log_cursor1 --  *	Actually push a cursor record out.  */
end_comment

begin_function
specifier|static
name|int
name|log_cursor1
parameter_list|(
name|sp
parameter_list|,
name|type
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|DBT
name|data
decl_stmt|,
name|key
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|ep
operator|->
name|l_lp
argument_list|,
name|ep
operator|->
name|l_len
argument_list|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|MARK
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|l_lp
index|[
literal|0
index|]
operator|=
name|type
expr_stmt|;
name|memmove
argument_list|(
name|ep
operator|->
name|l_lp
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
operator|&
name|ep
operator|->
name|l_cursor
argument_list|,
sizeof|sizeof
argument_list|(
name|MARK
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|.
name|data
operator|=
operator|&
name|ep
operator|->
name|l_cur
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
expr_stmt|;
name|data
operator|.
name|data
operator|=
name|ep
operator|->
name|l_lp
expr_stmt|;
name|data
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|MARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|log
operator|->
name|put
argument_list|(
name|ep
operator|->
name|log
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|LOG_ERR
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|0
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"%lu: %s: %u/%u\n"
argument_list|,
name|ep
operator|->
name|l_cur
argument_list|,
name|type
operator|==
name|LOG_CURSOR_INIT
condition|?
literal|"log_cursor_init"
else|:
literal|"log_cursor_end"
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
name|sp
operator|->
name|cno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Reset high water mark. */
name|ep
operator|->
name|l_high
operator|=
operator|++
name|ep
operator|->
name|l_cur
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * log_line --  *	Log a line change.  *  * PUBLIC: int log_line __P((SCR *, recno_t, u_int));  */
end_comment

begin_function
name|int
name|log_line
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|,
name|action
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|u_int
name|action
decl_stmt|;
block|{
name|DBT
name|data
decl_stmt|,
name|key
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|lp
decl_stmt|;
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_NOLOG
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * XXX 	 * 	 * Kluge for vi.  Clear the EXF undo flag so that the 	 * next 'u' command does a roll-back, regardless. 	 */
name|F_CLR
argument_list|(
name|ep
argument_list|,
name|F_UNDO
argument_list|)
expr_stmt|;
comment|/* Put out one initial cursor record per set of changes. */
if|if
condition|(
name|ep
operator|->
name|l_cursor
operator|.
name|lno
operator|!=
name|OOBLNO
condition|)
block|{
if|if
condition|(
name|log_cursor1
argument_list|(
name|sp
argument_list|,
name|LOG_CURSOR_INIT
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ep
operator|->
name|l_cursor
operator|.
name|lno
operator|=
name|OOBLNO
expr_stmt|;
block|}
comment|/* 	 * Put out the changes.  If it's a LOG_LINE_RESET_B call, it's a 	 * special case, avoid the caches.  Also, if it fails and it's 	 * line 1, it just means that the user started with an empty file, 	 * so fake an empty length line. 	 */
if|if
condition|(
name|action
operator|==
name|LOG_LINE_RESET_B
condition|)
block|{
if|if
condition|(
name|db_get
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|DBG_NOCACHE
argument_list|,
operator|&
name|lp
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|lno
operator|!=
literal|1
condition|)
block|{
name|db_err
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|len
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
literal|""
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|db_get
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|DBG_FATAL
argument_list|,
operator|&
name|lp
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|ep
operator|->
name|l_lp
argument_list|,
name|ep
operator|->
name|l_len
argument_list|,
name|len
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|l_lp
index|[
literal|0
index|]
operator|=
name|action
expr_stmt|;
name|memmove
argument_list|(
name|ep
operator|->
name|l_lp
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
operator|&
name|lno
argument_list|,
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|ep
operator|->
name|l_lp
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|,
name|lp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|key
operator|.
name|data
operator|=
operator|&
name|ep
operator|->
name|l_cur
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
expr_stmt|;
name|data
operator|.
name|data
operator|=
name|ep
operator|->
name|l_lp
expr_stmt|;
name|data
operator|.
name|size
operator|=
name|len
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|log
operator|->
name|put
argument_list|(
name|ep
operator|->
name|log
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|LOG_ERR
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|0
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|LOG_LINE_APPEND
case|:
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"%u: log_line: append: %lu {%u}\n"
argument_list|,
name|ep
operator|->
name|l_cur
argument_list|,
name|lno
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOG_LINE_DELETE
case|:
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"%lu: log_line: delete: %lu {%u}\n"
argument_list|,
name|ep
operator|->
name|l_cur
argument_list|,
name|lno
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOG_LINE_INSERT
case|:
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"%lu: log_line: insert: %lu {%u}\n"
argument_list|,
name|ep
operator|->
name|l_cur
argument_list|,
name|lno
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOG_LINE_RESET_F
case|:
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"%lu: log_line: reset_f: %lu {%u}\n"
argument_list|,
name|ep
operator|->
name|l_cur
argument_list|,
name|lno
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOG_LINE_RESET_B
case|:
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"%lu: log_line: reset_b: %lu {%u}\n"
argument_list|,
name|ep
operator|->
name|l_cur
argument_list|,
name|lno
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* Reset high water mark. */
name|ep
operator|->
name|l_high
operator|=
operator|++
name|ep
operator|->
name|l_cur
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * log_mark --  *	Log a mark position.  For the log to work, we assume that there  *	aren't any operations that just put out a log record -- this  *	would mean that undo operations would only reset marks, and not  *	cause any other change.  *  * PUBLIC: int log_mark __P((SCR *, LMARK *));  */
end_comment

begin_function
name|int
name|log_mark
parameter_list|(
name|sp
parameter_list|,
name|lmp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|LMARK
modifier|*
name|lmp
decl_stmt|;
block|{
name|DBT
name|data
decl_stmt|,
name|key
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_NOLOG
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Put out one initial cursor record per set of changes. */
if|if
condition|(
name|ep
operator|->
name|l_cursor
operator|.
name|lno
operator|!=
name|OOBLNO
condition|)
block|{
if|if
condition|(
name|log_cursor1
argument_list|(
name|sp
argument_list|,
name|LOG_CURSOR_INIT
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ep
operator|->
name|l_cursor
operator|.
name|lno
operator|=
name|OOBLNO
expr_stmt|;
block|}
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|ep
operator|->
name|l_lp
argument_list|,
name|ep
operator|->
name|l_len
argument_list|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|LMARK
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|l_lp
index|[
literal|0
index|]
operator|=
name|LOG_MARK
expr_stmt|;
name|memmove
argument_list|(
name|ep
operator|->
name|l_lp
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
name|lmp
argument_list|,
sizeof|sizeof
argument_list|(
name|LMARK
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|.
name|data
operator|=
operator|&
name|ep
operator|->
name|l_cur
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
expr_stmt|;
name|data
operator|.
name|data
operator|=
name|ep
operator|->
name|l_lp
expr_stmt|;
name|data
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|LMARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|log
operator|->
name|put
argument_list|(
name|ep
operator|->
name|log
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|LOG_ERR
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|0
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"%lu: mark %c: %lu/%u\n"
argument_list|,
name|ep
operator|->
name|l_cur
argument_list|,
name|lmp
operator|->
name|name
argument_list|,
name|lmp
operator|->
name|lno
argument_list|,
name|lmp
operator|->
name|cno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Reset high water mark. */
name|ep
operator|->
name|l_high
operator|=
operator|++
name|ep
operator|->
name|l_cur
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Log_backward --  *	Roll the log backward one operation.  *  * PUBLIC: int log_backward __P((SCR *, MARK *));  */
end_comment

begin_function
name|int
name|log_backward
parameter_list|(
name|sp
parameter_list|,
name|rp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|MARK
modifier|*
name|rp
decl_stmt|;
block|{
name|DBT
name|key
decl_stmt|,
name|data
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|LMARK
name|lm
decl_stmt|;
name|MARK
name|m
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|int
name|didop
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_NOLOG
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"010|Logging not being performed, undo not possible"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ep
operator|->
name|l_cur
operator|==
literal|1
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"011|No changes to undo"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_NOLOG
argument_list|)
expr_stmt|;
comment|/* Turn off logging. */
name|key
operator|.
name|data
operator|=
operator|&
name|ep
operator|->
name|l_cur
expr_stmt|;
comment|/* Initialize db request. */
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
expr_stmt|;
for|for
control|(
name|didop
operator|=
literal|0
init|;
condition|;
control|)
block|{
operator|--
name|ep
operator|->
name|l_cur
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|log
operator|->
name|get
argument_list|(
name|ep
operator|->
name|log
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
condition|)
name|LOG_ERR
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|0
name|log_trace
argument_list|(
name|sp
argument_list|,
literal|"log_backward"
argument_list|,
name|ep
operator|->
name|l_cur
argument_list|,
name|data
operator|.
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
operator|*
operator|(
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
operator|.
name|data
operator|)
condition|)
block|{
case|case
name|LOG_CURSOR_INIT
case|:
if|if
condition|(
name|didop
condition|)
block|{
name|memmove
argument_list|(
name|rp
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|MARK
argument_list|)
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|ep
argument_list|,
name|F_NOLOG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|LOG_CURSOR_END
case|:
break|break;
case|case
name|LOG_LINE_APPEND
case|:
case|case
name|LOG_LINE_INSERT
case|:
name|didop
operator|=
literal|1
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|lno
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_delete
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
operator|++
name|sp
operator|->
name|rptlines
index|[
name|L_DELETED
index|]
expr_stmt|;
break|break;
case|case
name|LOG_LINE_DELETE
case|:
name|didop
operator|=
literal|1
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|lno
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_insert
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|,
name|data
operator|.
name|size
operator|-
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
condition|)
goto|goto
name|err
goto|;
operator|++
name|sp
operator|->
name|rptlines
index|[
name|L_ADDED
index|]
expr_stmt|;
break|break;
case|case
name|LOG_LINE_RESET_F
case|:
break|break;
case|case
name|LOG_LINE_RESET_B
case|:
name|didop
operator|=
literal|1
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|lno
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_set
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|,
name|data
operator|.
name|size
operator|-
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|sp
operator|->
name|rptlchange
operator|!=
name|lno
condition|)
block|{
name|sp
operator|->
name|rptlchange
operator|=
name|lno
expr_stmt|;
operator|++
name|sp
operator|->
name|rptlines
index|[
name|L_CHANGED
index|]
expr_stmt|;
block|}
break|break;
case|case
name|LOG_MARK
case|:
name|didop
operator|=
literal|1
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|lm
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LMARK
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|.
name|lno
operator|=
name|lm
operator|.
name|lno
expr_stmt|;
name|m
operator|.
name|cno
operator|=
name|lm
operator|.
name|cno
expr_stmt|;
if|if
condition|(
name|mark_set
argument_list|(
name|sp
argument_list|,
name|lm
operator|.
name|name
argument_list|,
operator|&
name|m
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|err
label|:
name|F_CLR
argument_list|(
name|ep
argument_list|,
name|F_NOLOG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Log_setline --  *	Reset the line to its original appearance.  *  * XXX  * There's a bug in this code due to our not logging cursor movements  * unless a change was made.  If you do a change, move off the line,  * then move back on and do a 'U', the line will be restored to the way  * it was before the original change.  *  * PUBLIC: int log_setline __P((SCR *));  */
end_comment

begin_function
name|int
name|log_setline
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|DBT
name|key
decl_stmt|,
name|data
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|LMARK
name|lm
decl_stmt|;
name|MARK
name|m
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_NOLOG
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"012|Logging not being performed, undo not possible"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ep
operator|->
name|l_cur
operator|==
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_NOLOG
argument_list|)
expr_stmt|;
comment|/* Turn off logging. */
name|key
operator|.
name|data
operator|=
operator|&
name|ep
operator|->
name|l_cur
expr_stmt|;
comment|/* Initialize db request. */
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|--
name|ep
operator|->
name|l_cur
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|log
operator|->
name|get
argument_list|(
name|ep
operator|->
name|log
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
condition|)
name|LOG_ERR
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|0
name|log_trace
argument_list|(
name|sp
argument_list|,
literal|"log_setline"
argument_list|,
name|ep
operator|->
name|l_cur
argument_list|,
name|data
operator|.
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
operator|*
operator|(
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
operator|.
name|data
operator|)
condition|)
block|{
case|case
name|LOG_CURSOR_INIT
case|:
name|memmove
argument_list|(
operator|&
name|m
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|MARK
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|lno
operator|!=
name|sp
operator|->
name|lno
operator|||
name|ep
operator|->
name|l_cur
operator|==
literal|1
condition|)
block|{
name|F_CLR
argument_list|(
name|ep
argument_list|,
name|F_NOLOG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|LOG_CURSOR_END
case|:
name|memmove
argument_list|(
operator|&
name|m
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|MARK
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|lno
operator|!=
name|sp
operator|->
name|lno
condition|)
block|{
operator|++
name|ep
operator|->
name|l_cur
expr_stmt|;
name|F_CLR
argument_list|(
name|ep
argument_list|,
name|F_NOLOG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|LOG_LINE_APPEND
case|:
case|case
name|LOG_LINE_INSERT
case|:
case|case
name|LOG_LINE_DELETE
case|:
case|case
name|LOG_LINE_RESET_F
case|:
break|break;
case|case
name|LOG_LINE_RESET_B
case|:
name|memmove
argument_list|(
operator|&
name|lno
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lno
operator|==
name|sp
operator|->
name|lno
operator|&&
name|db_set
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|,
name|data
operator|.
name|size
operator|-
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|sp
operator|->
name|rptlchange
operator|!=
name|lno
condition|)
block|{
name|sp
operator|->
name|rptlchange
operator|=
name|lno
expr_stmt|;
operator|++
name|sp
operator|->
name|rptlines
index|[
name|L_CHANGED
index|]
expr_stmt|;
block|}
case|case
name|LOG_MARK
case|:
name|memmove
argument_list|(
operator|&
name|lm
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LMARK
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|.
name|lno
operator|=
name|lm
operator|.
name|lno
expr_stmt|;
name|m
operator|.
name|cno
operator|=
name|lm
operator|.
name|cno
expr_stmt|;
if|if
condition|(
name|mark_set
argument_list|(
name|sp
argument_list|,
name|lm
operator|.
name|name
argument_list|,
operator|&
name|m
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|err
label|:
name|F_CLR
argument_list|(
name|ep
argument_list|,
name|F_NOLOG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Log_forward --  *	Roll the log forward one operation.  *  * PUBLIC: int log_forward __P((SCR *, MARK *));  */
end_comment

begin_function
name|int
name|log_forward
parameter_list|(
name|sp
parameter_list|,
name|rp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|MARK
modifier|*
name|rp
decl_stmt|;
block|{
name|DBT
name|key
decl_stmt|,
name|data
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|LMARK
name|lm
decl_stmt|;
name|MARK
name|m
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|int
name|didop
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_NOLOG
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"013|Logging not being performed, roll-forward not possible"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ep
operator|->
name|l_cur
operator|==
name|ep
operator|->
name|l_high
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"014|No changes to re-do"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_NOLOG
argument_list|)
expr_stmt|;
comment|/* Turn off logging. */
name|key
operator|.
name|data
operator|=
operator|&
name|ep
operator|->
name|l_cur
expr_stmt|;
comment|/* Initialize db request. */
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
expr_stmt|;
for|for
control|(
name|didop
operator|=
literal|0
init|;
condition|;
control|)
block|{
operator|++
name|ep
operator|->
name|l_cur
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|log
operator|->
name|get
argument_list|(
name|ep
operator|->
name|log
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
condition|)
name|LOG_ERR
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|0
name|log_trace
argument_list|(
name|sp
argument_list|,
literal|"log_forward"
argument_list|,
name|ep
operator|->
name|l_cur
argument_list|,
name|data
operator|.
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
operator|*
operator|(
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
operator|.
name|data
operator|)
condition|)
block|{
case|case
name|LOG_CURSOR_END
case|:
if|if
condition|(
name|didop
condition|)
block|{
operator|++
name|ep
operator|->
name|l_cur
expr_stmt|;
name|memmove
argument_list|(
name|rp
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|MARK
argument_list|)
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|ep
argument_list|,
name|F_NOLOG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|LOG_CURSOR_INIT
case|:
break|break;
case|case
name|LOG_LINE_APPEND
case|:
case|case
name|LOG_LINE_INSERT
case|:
name|didop
operator|=
literal|1
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|lno
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_insert
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|,
name|data
operator|.
name|size
operator|-
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
condition|)
goto|goto
name|err
goto|;
operator|++
name|sp
operator|->
name|rptlines
index|[
name|L_ADDED
index|]
expr_stmt|;
break|break;
case|case
name|LOG_LINE_DELETE
case|:
name|didop
operator|=
literal|1
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|lno
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_delete
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
operator|++
name|sp
operator|->
name|rptlines
index|[
name|L_DELETED
index|]
expr_stmt|;
break|break;
case|case
name|LOG_LINE_RESET_B
case|:
break|break;
case|case
name|LOG_LINE_RESET_F
case|:
name|didop
operator|=
literal|1
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|lno
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_set
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|,
name|data
operator|.
name|size
operator|-
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|sp
operator|->
name|rptlchange
operator|!=
name|lno
condition|)
block|{
name|sp
operator|->
name|rptlchange
operator|=
name|lno
expr_stmt|;
operator|++
name|sp
operator|->
name|rptlines
index|[
name|L_CHANGED
index|]
expr_stmt|;
block|}
break|break;
case|case
name|LOG_MARK
case|:
name|didop
operator|=
literal|1
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|lm
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LMARK
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|.
name|lno
operator|=
name|lm
operator|.
name|lno
expr_stmt|;
name|m
operator|.
name|cno
operator|=
name|lm
operator|.
name|cno
expr_stmt|;
if|if
condition|(
name|mark_set
argument_list|(
name|sp
argument_list|,
name|lm
operator|.
name|name
argument_list|,
operator|&
name|m
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|err
label|:
name|F_CLR
argument_list|(
name|ep
argument_list|,
name|F_NOLOG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * log_err --  *	Try and restart the log on failure, i.e. if we run out of memory.  */
end_comment

begin_function
specifier|static
name|void
name|log_err
parameter_list|(
name|sp
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|EXF
modifier|*
name|ep
decl_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"015|%s/%d: log put error"
argument_list|,
name|tail
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
operator|(
name|void
operator|)
name|ep
operator|->
name|log
operator|->
name|close
argument_list|(
name|ep
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|log_init
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"267|Log restarted"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|0
end_if

begin_function
specifier|static
name|void
name|log_trace
parameter_list|(
name|sp
parameter_list|,
name|msg
parameter_list|,
name|rno
parameter_list|,
name|p
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|recno_t
name|rno
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
block|{
name|LMARK
name|lm
decl_stmt|;
name|MARK
name|m
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
name|LOG_CURSOR_INIT
case|:
name|memmove
argument_list|(
operator|&
name|m
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|MARK
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"%lu: %s:  C_INIT: %u/%u\n"
argument_list|,
name|rno
argument_list|,
name|msg
argument_list|,
name|m
operator|.
name|lno
argument_list|,
name|m
operator|.
name|cno
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOG_CURSOR_END
case|:
name|memmove
argument_list|(
operator|&
name|m
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|MARK
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"%lu: %s:   C_END: %u/%u\n"
argument_list|,
name|rno
argument_list|,
name|msg
argument_list|,
name|m
operator|.
name|lno
argument_list|,
name|m
operator|.
name|cno
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOG_LINE_APPEND
case|:
name|memmove
argument_list|(
operator|&
name|lno
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"%lu: %s:  APPEND: %lu\n"
argument_list|,
name|rno
argument_list|,
name|msg
argument_list|,
name|lno
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOG_LINE_INSERT
case|:
name|memmove
argument_list|(
operator|&
name|lno
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"%lu: %s:  INSERT: %lu\n"
argument_list|,
name|rno
argument_list|,
name|msg
argument_list|,
name|lno
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOG_LINE_DELETE
case|:
name|memmove
argument_list|(
operator|&
name|lno
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"%lu: %s:  DELETE: %lu\n"
argument_list|,
name|rno
argument_list|,
name|msg
argument_list|,
name|lno
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOG_LINE_RESET_F
case|:
name|memmove
argument_list|(
operator|&
name|lno
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"%lu: %s: RESET_F: %lu\n"
argument_list|,
name|rno
argument_list|,
name|msg
argument_list|,
name|lno
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOG_LINE_RESET_B
case|:
name|memmove
argument_list|(
operator|&
name|lno
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"%lu: %s: RESET_B: %lu\n"
argument_list|,
name|rno
argument_list|,
name|msg
argument_list|,
name|lno
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOG_MARK
case|:
name|memmove
argument_list|(
operator|&
name|lm
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LMARK
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"%lu: %s:    MARK: %u/%u\n"
argument_list|,
name|rno
argument_list|,
name|msg
argument_list|,
name|lm
operator|.
name|lno
argument_list|,
name|lm
operator|.
name|cno
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

