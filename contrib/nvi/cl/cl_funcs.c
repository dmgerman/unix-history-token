begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"$Id: cl_funcs.c,v 10.74 2012/10/11 10:30:16 zy Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERM_H
end_ifdef

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"../common/common.h"
end_include

begin_include
include|#
directive|include
file|"../vi/vi.h"
end_include

begin_include
include|#
directive|include
file|"cl.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|cl_rdiv
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|addstr4
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|void
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|wide
parameter_list|)
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|size_t
name|y
decl_stmt|,
name|x
decl_stmt|;
name|int
name|iv
decl_stmt|;
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|win
operator|=
name|CLSP
argument_list|(
name|sp
argument_list|)
condition|?
name|CLSP
argument_list|(
name|sp
argument_list|)
else|:
name|stdscr
expr_stmt|;
comment|/* 	 * If ex isn't in control, it's the last line of the screen and 	 * it's a split screen, use inverse video. 	 */
name|iv
operator|=
literal|0
expr_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EXWROTE
argument_list|)
operator|&&
name|y
operator|==
name|RLNO
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|&&
name|IS_SPLIT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|iv
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|wstandout
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_WIDECHAR
if|if
condition|(
name|wide
condition|)
block|{
if|if
condition|(
name|waddnwstr
argument_list|(
name|win
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
operator|==
name|ERR
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|waddnstr
argument_list|(
name|win
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
operator|==
name|ERR
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|iv
condition|)
operator|(
name|void
operator|)
name|wstandend
argument_list|(
name|win
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_waddstr --  *	Add len bytes from the string at the cursor, advancing the cursor.  *  * PUBLIC: int cl_waddstr __P((SCR *, const CHAR_T *, size_t));  */
end_comment

begin_function
name|int
name|cl_waddstr
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
specifier|const
name|CHAR_T
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|addstr4
argument_list|(
name|sp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|str
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_addstr --  *	Add len bytes from the string at the cursor, advancing the cursor.  *  * PUBLIC: int cl_addstr __P((SCR *, const char *, size_t));  */
end_comment

begin_function
name|int
name|cl_addstr
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|addstr4
argument_list|(
name|sp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|str
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_attr --  *	Toggle a screen attribute on/off.  *  * PUBLIC: int cl_attr __P((SCR *, scr_attr_t, int));  */
end_comment

begin_function
name|int
name|cl_attr
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|scr_attr_t
name|attribute
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|win
operator|=
name|CLSP
argument_list|(
name|sp
argument_list|)
condition|?
name|CLSP
argument_list|(
name|sp
argument_list|)
else|:
name|stdscr
expr_stmt|;
switch|switch
condition|(
name|attribute
condition|)
block|{
case|case
name|SA_ALTERNATE
case|:
comment|/* 	 * !!! 	 * There's a major layering violation here.  The problem is that the 	 * X11 xterm screen has what's known as an "alternate" screen.  Some 	 * xterm termcap/terminfo entries include sequences to switch to/from 	 * that alternate screen as part of the ti/te (smcup/rmcup) strings. 	 * Vi runs in the alternate screen, so that you are returned to the 	 * same screen contents on exit from vi that you had when you entered 	 * vi.  Further, when you run :shell, or :!date or similar ex commands, 	 * you also see the original screen contents.  This wasn't deliberate 	 * on vi's part, it's just that it historically sent terminal init/end 	 * sequences at those times, and the addition of the alternate screen 	 * sequences to the strings changed the behavior of vi.  The problem 	 * caused by this is that we don't want to switch back to the alternate 	 * screen while getting a new command from the user, when the user is 	 * continuing to enter ex commands, e.g.: 	 * 	 *	:!date<<< switch to original screen 	 *	[Hit return to continue]<<< prompt user to continue 	 *	:command<<< get command from user 	 * 	 * Note that the :command input is a true vi input mode, e.g., input 	 * maps and abbreviations are being done.  So, we need to be able to 	 * switch back into the vi screen mode, without flashing the screen.  	 * 	 * To make matters worse, the curses initscr() and endwin() calls will 	 * do this automatically -- so, this attribute isn't as controlled by 	 * the higher level screen as closely as one might like. 	 */
if|if
condition|(
name|on
condition|)
block|{
if|if
condition|(
name|clp
operator|->
name|ti_te
operator|!=
name|TI_SENT
condition|)
block|{
name|clp
operator|->
name|ti_te
operator|=
name|TI_SENT
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|smcup
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|cl_getcap
argument_list|(
name|sp
argument_list|,
literal|"smcup"
argument_list|,
operator|&
name|clp
operator|->
name|smcup
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|smcup
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|tputs
argument_list|(
name|clp
operator|->
name|smcup
argument_list|,
literal|1
argument_list|,
name|cl_putchar
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|clp
operator|->
name|ti_te
operator|!=
name|TE_SENT
condition|)
block|{
name|clp
operator|->
name|ti_te
operator|=
name|TE_SENT
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|rmcup
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|cl_getcap
argument_list|(
name|sp
argument_list|,
literal|"rmcup"
argument_list|,
operator|&
name|clp
operator|->
name|rmcup
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|rmcup
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|tputs
argument_list|(
name|clp
operator|->
name|rmcup
argument_list|,
literal|1
argument_list|,
name|cl_putchar
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|SA_INVERSE
case|:
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX
operator||
name|SC_SCR_EXWROTE
argument_list|)
condition|)
block|{
if|if
condition|(
name|clp
operator|->
name|smso
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|on
condition|)
operator|(
name|void
operator|)
name|tputs
argument_list|(
name|clp
operator|->
name|smso
argument_list|,
literal|1
argument_list|,
name|cl_putchar
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|tputs
argument_list|(
name|clp
operator|->
name|rmso
argument_list|,
literal|1
argument_list|,
name|cl_putchar
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|on
condition|)
operator|(
name|void
operator|)
name|wstandout
argument_list|(
name|win
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|wstandend
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_baud --  *	Return the baud rate.  *  * PUBLIC: int cl_baud __P((SCR *, u_long *));  */
end_comment

begin_function
name|int
name|cl_baud
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|u_long
modifier|*
name|ratep
parameter_list|)
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
comment|/* 	 * XXX 	 * There's no portable way to get a "baud rate" -- cfgetospeed(3) 	 * returns the value associated with some #define, which we may 	 * never have heard of, or which may be a purely local speed.  Vi 	 * only cares if it's SLOW (w300), slow (w1200) or fast (w9600). 	 * Try and detect the slow ones, and default to fast. 	 */
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cfgetospeed
argument_list|(
operator|&
name|clp
operator|->
name|orig
argument_list|)
condition|)
block|{
case|case
name|B50
case|:
case|case
name|B75
case|:
case|case
name|B110
case|:
case|case
name|B134
case|:
case|case
name|B150
case|:
case|case
name|B200
case|:
case|case
name|B300
case|:
case|case
name|B600
case|:
operator|*
name|ratep
operator|=
literal|600
expr_stmt|;
break|break;
case|case
name|B1200
case|:
operator|*
name|ratep
operator|=
literal|1200
expr_stmt|;
break|break;
default|default:
operator|*
name|ratep
operator|=
literal|9600
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_bell --  *	Ring the bell/flash the screen.  *  * PUBLIC: int cl_bell __P((SCR *));  */
end_comment

begin_function
name|int
name|cl_bell
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX
operator||
name|SC_SCR_EXWROTE
operator||
name|SC_SCR_EX
argument_list|)
condition|)
operator|(
name|void
operator|)
name|write
argument_list|(
name|STDOUT_FILENO
argument_list|,
literal|"\07"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* \a */
else|else
block|{
comment|/* 		 * Vi has an edit option which determines if the terminal 		 * should be beeped or the screen flashed. 		 */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_FLASH
argument_list|)
condition|)
operator|(
name|void
operator|)
name|flash
argument_list|()
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|beep
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_clrtoeol --  *	Clear from the current cursor to the end of the line.  *  * PUBLIC: int cl_clrtoeol __P((SCR *));  */
end_comment

begin_function
name|int
name|cl_clrtoeol
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|;
if|#
directive|if
literal|0
block|size_t spcnt, y, x;
endif|#
directive|endif
name|win
operator|=
name|CLSP
argument_list|(
name|sp
argument_list|)
condition|?
name|CLSP
argument_list|(
name|sp
argument_list|)
else|:
name|stdscr
expr_stmt|;
if|#
directive|if
literal|0
block|if (IS_VSPLIT(sp)) {
comment|/* The cursor must be returned to its original position. */
block|getyx(win, y, x); 		for (spcnt = (sp->coff + sp->cols) - x; spcnt> 0; --spcnt) 			(void)waddch(win, ' '); 		(void)wmove(win, y, x); 		return (0); 	} else
endif|#
directive|endif
return|return
operator|(
name|wclrtoeol
argument_list|(
name|win
argument_list|)
operator|==
name|ERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_cursor --  *	Return the current cursor position.  *  * PUBLIC: int cl_cursor __P((SCR *, size_t *, size_t *));  */
end_comment

begin_function
name|int
name|cl_cursor
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|size_t
modifier|*
name|yp
parameter_list|,
name|size_t
modifier|*
name|xp
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|win
operator|=
name|CLSP
argument_list|(
name|sp
argument_list|)
condition|?
name|CLSP
argument_list|(
name|sp
argument_list|)
else|:
name|stdscr
expr_stmt|;
comment|/* 	 * The curses screen support splits a single underlying curses screen 	 * into multiple screens to support split screen semantics.  For this 	 * reason the returned value must be adjusted to be relative to the 	 * current screen, and not absolute.  Screens that implement the split 	 * using physically distinct screens won't need this hack. 	 */
name|getyx
argument_list|(
name|win
argument_list|,
operator|*
name|yp
argument_list|,
operator|*
name|xp
argument_list|)
expr_stmt|;
comment|/* 	*yp -= sp->roff; 	*xp -= sp->coff; 	*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_deleteln --  *	Delete the current line, scrolling all lines below it.  *  * PUBLIC: int cl_deleteln __P((SCR *));  */
end_comment

begin_function
name|int
name|cl_deleteln
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|size_t
name|y
decl_stmt|,
name|x
decl_stmt|;
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|win
operator|=
name|CLSP
argument_list|(
name|sp
argument_list|)
condition|?
name|CLSP
argument_list|(
name|sp
argument_list|)
else|:
name|stdscr
expr_stmt|;
comment|/* 	 * This clause is required because the curses screen uses reverse 	 * video to delimit split screens.  If the screen does not do this, 	 * this code won't be necessary. 	 * 	 * If the bottom line was in reverse video, rewrite it in normal 	 * video before it's scrolled. 	 */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EXWROTE
argument_list|)
operator|&&
name|IS_SPLIT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|getyx
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|mvwchgat
argument_list|(
name|win
argument_list|,
name|RLNO
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|A_NORMAL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The bottom line is expected to be blank after this operation, 	 * and other screens must support that semantic. 	 */
return|return
operator|(
name|wdeleteln
argument_list|(
name|win
argument_list|)
operator|==
name|ERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * cl_discard --  *	Discard a screen.  *  * PUBLIC: int cl_discard __P((SCR *, SCR **));  */
end_comment

begin_function
name|int
name|cl_discard
parameter_list|(
name|SCR
modifier|*
name|discardp
parameter_list|,
name|SCR
modifier|*
modifier|*
name|acquirep
parameter_list|)
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|SCR
modifier|*
name|tsp
decl_stmt|;
if|if
condition|(
name|discardp
condition|)
block|{
name|clp
operator|=
name|CLP
argument_list|(
name|discardp
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|clp
argument_list|,
name|CL_LAYOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLSP
argument_list|(
name|discardp
argument_list|)
condition|)
block|{
name|delwin
argument_list|(
name|CLSP
argument_list|(
name|discardp
argument_list|)
argument_list|)
expr_stmt|;
name|discardp
operator|->
name|cl_private
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* no screens got a piece; we're done */
if|if
condition|(
operator|!
name|acquirep
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
operator|(
name|tsp
operator|=
operator|*
name|acquirep
operator|)
operator|!=
name|NULL
condition|;
operator|++
name|acquirep
control|)
block|{
name|clp
operator|=
name|CLP
argument_list|(
name|tsp
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|clp
argument_list|,
name|CL_LAYOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLSP
argument_list|(
name|tsp
argument_list|)
condition|)
name|delwin
argument_list|(
name|CLSP
argument_list|(
name|tsp
argument_list|)
argument_list|)
expr_stmt|;
name|tsp
operator|->
name|cl_private
operator|=
name|subwin
argument_list|(
name|stdscr
argument_list|,
name|tsp
operator|->
name|rows
argument_list|,
name|tsp
operator|->
name|cols
argument_list|,
name|tsp
operator|->
name|roff
argument_list|,
name|tsp
operator|->
name|coff
argument_list|)
expr_stmt|;
block|}
comment|/* discardp is going away, acquirep is taking up its space. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * cl_ex_adjust --  *	Adjust the screen for ex.  This routine is purely for standalone  *	ex programs.  All special purpose, all special case.  *  * PUBLIC: int cl_ex_adjust __P((SCR *, exadj_t));  */
end_comment

begin_function
name|int
name|cl_ex_adjust
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|exadj_t
name|action
parameter_list|)
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|EX_TERM_SCROLL
case|:
comment|/* Move the cursor up one line if that's possible. */
if|if
condition|(
name|clp
operator|->
name|cuu1
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|tputs
argument_list|(
name|clp
operator|->
name|cuu1
argument_list|,
literal|1
argument_list|,
name|cl_putchar
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|clp
operator|->
name|cup
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|clp
operator|->
name|cup
argument_list|,
literal|0
argument_list|,
name|LINES
operator|-
literal|2
argument_list|)
argument_list|,
literal|1
argument_list|,
name|cl_putchar
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
comment|/* FALLTHROUGH */
case|case
name|EX_TERM_CE
case|:
comment|/* Clear the line. */
if|if
condition|(
name|clp
operator|->
name|el
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tputs
argument_list|(
name|clp
operator|->
name|el
argument_list|,
literal|1
argument_list|,
name|cl_putchar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Historically, ex didn't erase the line, so, if the 			 * displayed line was only a single glyph, and<eof> 			 * was more than one glyph, the output would not fully 			 * overwrite the user's input.  To fix this, output 			 * the maxiumum character number of spaces.  Note, 			 * this won't help if the user entered extra prompt 			 * or<blank> characters before the command character. 			 * We'd have to do a lot of work to make that work, and 			 * it's almost certainly not worth the effort. 			 */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|MAX_CHARACTER_COLUMNS
condition|;
operator|++
name|cnt
control|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|MAX_CHARACTER_COLUMNS
condition|;
operator|++
name|cnt
control|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_insertln --  *	Push down the current line, discarding the bottom line.  *  * PUBLIC: int cl_insertln __P((SCR *));  */
end_comment

begin_function
name|int
name|cl_insertln
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|win
operator|=
name|CLSP
argument_list|(
name|sp
argument_list|)
condition|?
name|CLSP
argument_list|(
name|sp
argument_list|)
else|:
name|stdscr
expr_stmt|;
comment|/* 	 * The current line is expected to be blank after this operation, 	 * and the screen must support that semantic. 	 */
return|return
operator|(
name|winsertln
argument_list|(
name|win
argument_list|)
operator|==
name|ERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_keyval --  *	Return the value for a special key.  *  * PUBLIC: int cl_keyval __P((SCR *, scr_keyval_t, CHAR_T *, int *));  */
end_comment

begin_function
name|int
name|cl_keyval
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|scr_keyval_t
name|val
parameter_list|,
name|CHAR_T
modifier|*
name|chp
parameter_list|,
name|int
modifier|*
name|dnep
parameter_list|)
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
comment|/* 	 * VEOF, VERASE and VKILL are required by POSIX 1003.1-1990, 	 * VWERASE is a 4BSD extension. 	 */
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|KEY_VEOF
case|:
operator|*
name|dnep
operator|=
operator|(
operator|*
name|chp
operator|=
name|clp
operator|->
name|orig
operator|.
name|c_cc
index|[
name|VEOF
index|]
operator|)
operator|==
name|_POSIX_VDISABLE
expr_stmt|;
break|break;
case|case
name|KEY_VERASE
case|:
operator|*
name|dnep
operator|=
operator|(
operator|*
name|chp
operator|=
name|clp
operator|->
name|orig
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|)
operator|==
name|_POSIX_VDISABLE
expr_stmt|;
break|break;
case|case
name|KEY_VKILL
case|:
operator|*
name|dnep
operator|=
operator|(
operator|*
name|chp
operator|=
name|clp
operator|->
name|orig
operator|.
name|c_cc
index|[
name|VKILL
index|]
operator|)
operator|==
name|_POSIX_VDISABLE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|VWERASE
case|case
name|KEY_VWERASE
case|:
operator|*
name|dnep
operator|=
operator|(
operator|*
name|chp
operator|=
name|clp
operator|->
name|orig
operator|.
name|c_cc
index|[
name|VWERASE
index|]
operator|)
operator|==
name|_POSIX_VDISABLE
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
operator|*
name|dnep
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_move --  *	Move the cursor.  *  * PUBLIC: int cl_move __P((SCR *, size_t, size_t));  */
end_comment

begin_function
name|int
name|cl_move
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|size_t
name|lno
parameter_list|,
name|size_t
name|cno
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|win
operator|=
name|CLSP
argument_list|(
name|sp
argument_list|)
condition|?
name|CLSP
argument_list|(
name|sp
argument_list|)
else|:
name|stdscr
expr_stmt|;
comment|/* See the comment in cl_cursor. */
if|if
condition|(
name|wmove
argument_list|(
name|win
argument_list|,
name|RLNO
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
argument_list|,
name|RCNO
argument_list|(
name|sp
argument_list|,
name|cno
argument_list|)
argument_list|)
operator|==
name|ERR
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Error: move: l(%zu + %zu) c(%zu + %zu)"
argument_list|,
name|lno
argument_list|,
name|sp
operator|->
name|roff
argument_list|,
name|cno
argument_list|,
name|sp
operator|->
name|coff
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_refresh --  *	Refresh the screen.  *  * PUBLIC: int cl_refresh __P((SCR *, int));  */
end_comment

begin_function
name|int
name|cl_refresh
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|int
name|repaint
parameter_list|)
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|SCR
modifier|*
name|psp
decl_stmt|,
modifier|*
name|tsp
decl_stmt|;
name|size_t
name|y
decl_stmt|,
name|x
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|win
operator|=
name|CLSP
argument_list|(
name|sp
argument_list|)
condition|?
name|CLSP
argument_list|(
name|sp
argument_list|)
else|:
name|stdscr
expr_stmt|;
comment|/* 	 * If we received a killer signal, we're done, there's no point 	 * in refreshing the screen. 	 */
if|if
condition|(
name|clp
operator|->
name|killersig
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If repaint is set, the editor is telling us that we don't know 	 * what's on the screen, so we have to repaint from scratch. 	 * 	 * If repaint set or the screen layout changed, we need to redraw 	 * any lines separating vertically split screens.  If the horizontal 	 * offsets are the same, then the split was vertical, and need to 	 * draw a dividing line. 	 */
if|if
condition|(
name|repaint
operator|||
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_LAYOUT
argument_list|)
condition|)
block|{
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|psp
operator|=
name|sp
init|;
name|psp
operator|!=
name|NULL
condition|;
name|psp
operator|=
name|TAILQ_NEXT
argument_list|(
name|psp
argument_list|,
name|q
argument_list|)
control|)
for|for
control|(
name|tsp
operator|=
name|TAILQ_NEXT
argument_list|(
name|psp
argument_list|,
name|q
argument_list|)
init|;
name|tsp
operator|!=
name|NULL
condition|;
name|tsp
operator|=
name|TAILQ_NEXT
argument_list|(
name|tsp
argument_list|,
name|q
argument_list|)
control|)
if|if
condition|(
name|psp
operator|->
name|roff
operator|==
name|tsp
operator|->
name|roff
condition|)
block|{
if|if
condition|(
name|psp
operator|->
name|coff
operator|+
name|psp
operator|->
name|cols
operator|+
literal|1
operator|==
name|tsp
operator|->
name|coff
condition|)
name|cl_rdiv
argument_list|(
name|psp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tsp
operator|->
name|coff
operator|+
name|tsp
operator|->
name|cols
operator|+
literal|1
operator|==
name|psp
operator|->
name|coff
condition|)
name|cl_rdiv
argument_list|(
name|tsp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|stdscr
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|clp
argument_list|,
name|CL_LAYOUT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * In the curses library, doing wrefresh(curscr) is okay, but the 	 * screen flashes when we then apply the refresh() to bring it up 	 * to date.  So, use clearok(). 	 */
if|if
condition|(
name|repaint
condition|)
name|clearok
argument_list|(
name|curscr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Only do an actual refresh, when this is the focus window, 	 * i.e. the one holding the cursor. This assumes that refresh 	 * is called for that window after refreshing the others. 	 * This prevents the cursor being drawn in the other windows. 	 */
return|return
operator|(
name|wnoutrefresh
argument_list|(
name|stdscr
argument_list|)
operator|==
name|ERR
operator|||
name|wnoutrefresh
argument_list|(
name|win
argument_list|)
operator|==
name|ERR
operator|||
operator|(
name|sp
operator|==
name|clp
operator|->
name|focus
operator|&&
name|doupdate
argument_list|()
operator|==
name|ERR
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_rdiv --  *	Draw a dividing line between two vertically split screens.  */
end_comment

begin_function
specifier|static
name|void
name|cl_rdiv
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__NetBSD__
name|mvvline
argument_list|(
name|sp
operator|->
name|roff
argument_list|,
name|sp
operator|->
name|cols
operator|+
name|sp
operator|->
name|coff
argument_list|,
literal|'|'
argument_list|,
name|sp
operator|->
name|rows
argument_list|)
expr_stmt|;
else|#
directive|else
name|mvvline
argument_list|(
name|sp
operator|->
name|roff
argument_list|,
name|sp
operator|->
name|cols
operator|+
name|sp
operator|->
name|coff
argument_list|,
name|ACS_VLINE
argument_list|,
name|sp
operator|->
name|rows
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * cl_rename --  *	Rename the file.  *  * PUBLIC: int cl_rename __P((SCR *, char *, int));  */
end_comment

begin_function
name|int
name|cl_rename
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|FILE
modifier|*
name|pfp
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|wid
decl_stmt|;
name|char
name|cmd
index|[
literal|64
index|]
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * XXX 	 * We can only rename windows for xterm. 	 */
if|if
condition|(
name|on
condition|)
block|{
name|clp
operator|->
name|focus
operator|=
name|sp
expr_stmt|;
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_RENAME_OK
argument_list|)
operator|||
name|strncmp
argument_list|(
name|OG_STR
argument_list|(
name|gp
argument_list|,
name|GO_TERM
argument_list|)
argument_list|,
literal|"xterm"
argument_list|,
literal|5
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|clp
operator|->
name|oname
operator|==
name|NULL
operator|&&
operator|(
name|wid
operator|=
name|getenv
argument_list|(
literal|"WINDOWID"
argument_list|)
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
literal|"xprop -id %s WM_NAME"
argument_list|,
name|wid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pfp
operator|=
name|popen
argument_list|(
name|cmd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|rename
goto|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|pfp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|pclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
goto|goto
name|rename
goto|;
block|}
name|pclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'"'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|e
operator|=
name|strrchr
argument_list|(
name|buf
argument_list|,
literal|'"'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|clp
operator|->
name|oname
operator|=
name|strndup
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|e
operator|-
name|s
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|rename
label|:
name|cl_setname
argument_list|(
name|gp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|clp
argument_list|,
name|CL_RENAME
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_RENAME
argument_list|)
condition|)
block|{
name|cl_setname
argument_list|(
name|gp
argument_list|,
name|clp
operator|->
name|oname
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|clp
argument_list|,
name|CL_RENAME
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_setname --  *	Set a X11 icon/window name.  *  * PUBLIC: void cl_setname __P((GS *, char *));  */
end_comment

begin_function
name|void
name|cl_setname
parameter_list|(
name|GS
modifier|*
name|gp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* X11 xterm escape sequence to rename the icon/window. */
define|#
directive|define
name|XTERM_RENAME
value|"\033]0;%s\007"
operator|(
name|void
operator|)
name|printf
argument_list|(
name|XTERM_RENAME
argument_list|,
name|name
operator|==
name|NULL
condition|?
name|OG_STR
argument_list|(
name|gp
argument_list|,
name|GO_TERM
argument_list|)
else|:
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|XTERM_RENAME
block|}
end_function

begin_comment
comment|/*   * cl_split --  *	Split a screen.  *  * PUBLIC: int cl_split __P((SCR *, SCR *));  */
end_comment

begin_function
name|int
name|cl_split
parameter_list|(
name|SCR
modifier|*
name|origp
parameter_list|,
name|SCR
modifier|*
name|newp
parameter_list|)
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|clp
operator|=
name|CLP
argument_list|(
name|origp
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|clp
argument_list|,
name|CL_LAYOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLSP
argument_list|(
name|origp
argument_list|)
condition|)
name|delwin
argument_list|(
name|CLSP
argument_list|(
name|origp
argument_list|)
argument_list|)
expr_stmt|;
name|origp
operator|->
name|cl_private
operator|=
name|subwin
argument_list|(
name|stdscr
argument_list|,
name|origp
operator|->
name|rows
argument_list|,
name|origp
operator|->
name|cols
argument_list|,
name|origp
operator|->
name|roff
argument_list|,
name|origp
operator|->
name|coff
argument_list|)
expr_stmt|;
name|newp
operator|->
name|cl_private
operator|=
name|subwin
argument_list|(
name|stdscr
argument_list|,
name|newp
operator|->
name|rows
argument_list|,
name|newp
operator|->
name|cols
argument_list|,
name|newp
operator|->
name|roff
argument_list|,
name|newp
operator|->
name|coff
argument_list|)
expr_stmt|;
comment|/* origp is the original screen, giving up space to newp. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_suspend --  *	Suspend a screen.  *  * PUBLIC: int cl_suspend __P((SCR *, int *));  */
end_comment

begin_function
name|int
name|cl_suspend
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|int
modifier|*
name|allowedp
parameter_list|)
block|{
name|struct
name|termios
name|t
decl_stmt|;
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|size_t
name|y
decl_stmt|,
name|x
decl_stmt|;
name|int
name|changed
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|win
operator|=
name|CLSP
argument_list|(
name|sp
argument_list|)
condition|?
name|CLSP
argument_list|(
name|sp
argument_list|)
else|:
name|stdscr
expr_stmt|;
operator|*
name|allowedp
operator|=
literal|1
expr_stmt|;
comment|/* 	 * The ex implementation of this function isn't needed by screens not 	 * supporting ex commands that require full terminal canonical mode 	 * (e.g. :suspend). 	 * 	 * The vi implementation of this function isn't needed by screens not 	 * supporting vi process suspension, i.e. any screen that isn't backed 	 * by a UNIX shell. 	 * 	 * Setting allowedp to 0 will cause the editor to reject the command. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX
argument_list|)
condition|)
block|{
comment|/* Save the terminal settings, and restore the original ones. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_STDIN_TTY
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|tcgetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSASOFT
operator||
name|TCSADRAIN
argument_list|,
operator|&
name|clp
operator|->
name|orig
argument_list|)
expr_stmt|;
block|}
comment|/* Stop the process group. */
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* Time passes ... */
comment|/* Restore terminal settings. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_STDIN_TTY
argument_list|)
condition|)
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSASOFT
operator||
name|TCSADRAIN
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Move to the lower left-hand corner of the screen. 	 * 	 * XXX 	 * Not sure this is necessary in System V implementations, but it 	 * shouldn't hurt. 	 */
name|getyx
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|win
argument_list|,
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
comment|/* 	 * Temporarily end the screen.  System V introduced a semantic where 	 * endwin() could be restarted.  We use it because restarting curses 	 * from scratch often fails in System V.  4BSD curses didn't support 	 * restarting after endwin(), so we have to do what clean up we can 	 * without calling it. 	 */
comment|/* Save the terminal settings. */
operator|(
name|void
operator|)
name|tcgetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
comment|/* Restore the cursor keys to normal mode. */
operator|(
name|void
operator|)
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Restore the window name. */
operator|(
name|void
operator|)
name|cl_rename
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|endwin
argument_list|()
expr_stmt|;
comment|/* 	 * XXX 	 * Restore the original terminal settings.  This is bad -- the 	 * reset can cause character loss from the tty queue.  However, 	 * we can't call endwin() in BSD curses implementations, and too 	 * many System V curses implementations don't get it right. 	 */
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSADRAIN
operator||
name|TCSASOFT
argument_list|,
operator|&
name|clp
operator|->
name|orig
argument_list|)
expr_stmt|;
comment|/* Stop the process group. */
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* Time passes ... */
comment|/* 	 * If we received a killer signal, we're done.  Leave everything 	 * unchanged.  In addition, the terminal has already been reset 	 * correctly, so leave it alone. 	 */
if|if
condition|(
name|clp
operator|->
name|killersig
condition|)
block|{
name|F_CLR
argument_list|(
name|clp
argument_list|,
name|CL_SCR_EX_INIT
operator||
name|CL_SCR_VI_INIT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Restore terminal settings. */
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
comment|/* Needed on SunOs/Solaris ? */
if|if
condition|(
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_STDIN_TTY
argument_list|)
condition|)
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSASOFT
operator||
name|TCSADRAIN
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
comment|/* Set the window name. */
operator|(
name|void
operator|)
name|cl_rename
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|frp
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Put the cursor keys into application mode. */
operator|(
name|void
operator|)
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Refresh and repaint the screen. */
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cl_refresh
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If the screen changed size, set the SIGWINCH bit. */
if|if
condition|(
name|cl_ssize
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|changed
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|changed
condition|)
name|F_SET
argument_list|(
name|CLP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|CL_SIGWINCH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_usage --  *	Print out the curses usage messages.  *   * PUBLIC: void cl_usage __P((void));  */
end_comment

begin_function
name|void
name|cl_usage
parameter_list|(
name|void
parameter_list|)
block|{
define|#
directive|define
name|USAGE
value|"\ usage: ex [-eFRrSsv] [-c command] [-t tag] [-w size] [file ...]\n\ usage: vi [-eFlRrSv] [-c command] [-t tag] [-w size] [file ...]\n"
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|USAGE
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|USAGE
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * gdbrefresh --  *	Stub routine so can flush out curses screen changes using gdb.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
name|gdbrefresh
argument_list|(
name|void
argument_list|)
block|{
name|refresh
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX Convince gdb to run it. */
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

