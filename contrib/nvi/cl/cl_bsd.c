begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)cl_bsd.c	8.29 (Berkeley) 7/1/96"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"../common/common.h"
end_include

begin_include
include|#
directive|include
file|"../vi/vi.h"
end_include

begin_include
include|#
directive|include
file|"cl.h"
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ke
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keypad on. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keypad off. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Visible bell string. */
end_comment

begin_comment
comment|/*  * HP's support the entire System V curses package except for the tigetstr  * and tigetnum functions.  Ultrix supports the BSD curses package except  * for the idlok function.  Cthulu only knows why.  Break things up into a  * minimal set of functions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_CURSES_ADDNSTR
end_ifndef

begin_comment
comment|/*  * addnstr --  *  * PUBLIC: #ifndef HAVE_CURSES_ADDNSTR  * PUBLIC: int addnstr __P((char *, int));  * PUBLIC: #endif  */
end_comment

begin_function
name|int
name|addnstr
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|&&
operator|(
name|ch
operator|=
operator|*
name|s
operator|++
operator|)
condition|)
name|addch
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_CURSES_BEEP
end_ifndef

begin_comment
comment|/*  * beep --  *  * PUBLIC: #ifndef HAVE_CURSES_BEEP  * PUBLIC: void beep __P((void));  * PUBLIC: #endif  */
end_comment

begin_function
name|void
name|beep
parameter_list|()
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
literal|"\007"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* '\a' */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_CURSES_BEEP */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_CURSES_FLASH
end_ifndef

begin_comment
comment|/*  * flash --  *	Flash the screen.  *  * PUBLIC: #ifndef HAVE_CURSES_FLASH  * PUBLIC: void flash __P((void));  * PUBLIC: #endif  */
end_comment

begin_function
name|void
name|flash
parameter_list|()
block|{
if|if
condition|(
name|vb
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|tputs
argument_list|(
name|vb
argument_list|,
literal|1
argument_list|,
name|cl_putchar
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|beep
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_CURSES_FLASH */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_CURSES_IDLOK
end_ifndef

begin_comment
comment|/*  * idlok --  *	Turn on/off hardware line insert/delete.  *  * PUBLIC: #ifndef HAVE_CURSES_IDLOK  * PUBLIC: void idlok __P((WINDOW *, int));  * PUBLIC: #endif  */
end_comment

begin_function
name|void
name|idlok
parameter_list|(
name|win
parameter_list|,
name|bf
parameter_list|)
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|int
name|bf
decl_stmt|;
block|{
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_CURSES_IDLOK */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_CURSES_KEYPAD
end_ifndef

begin_comment
comment|/*  * keypad --  *	Put the keypad/cursor arrows into or out of application mode.  *  * PUBLIC: #ifndef HAVE_CURSES_KEYPAD  * PUBLIC: int keypad __P((void *, int));  * PUBLIC: #endif  */
end_comment

begin_function
name|int
name|keypad
parameter_list|(
name|a
parameter_list|,
name|on
parameter_list|)
name|void
modifier|*
name|a
decl_stmt|;
name|int
name|on
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|tigetstr
argument_list|(
name|on
condition|?
literal|"smkx"
else|:
literal|"rmkx"
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|tputs
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|cl_putchar
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_CURSES_KEYPAD */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_CURSES_NEWTERM
end_ifndef

begin_comment
comment|/*  * newterm --  *	Create a new curses screen.  *  * PUBLIC: #ifndef HAVE_CURSES_NEWTERM  * PUBLIC: void *newterm __P((const char *, FILE *, FILE *));  * PUBLIC: #endif  */
end_comment

begin_function
name|void
modifier|*
name|newterm
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
specifier|const
name|char
modifier|*
name|a
decl_stmt|;
name|FILE
modifier|*
name|b
decl_stmt|,
decl|*
name|c
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|initscr
argument_list|()
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_CURSES_NEWTERM */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_CURSES_SETUPTERM
end_ifndef

begin_comment
comment|/*  * setupterm --  *	Set up terminal.  *  * PUBLIC: #ifndef HAVE_CURSES_SETUPTERM  * PUBLIC: void setupterm __P((char *, int, int *));  * PUBLIC: #endif  */
end_comment

begin_function
name|void
name|setupterm
parameter_list|(
name|ttype
parameter_list|,
name|fno
parameter_list|,
name|errp
parameter_list|)
name|char
modifier|*
name|ttype
decl_stmt|;
name|int
name|fno
decl_stmt|,
decl|*
name|errp
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|errp
operator|=
name|tgetent
argument_list|(
name|buf
argument_list|,
name|ttype
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ke
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ke
argument_list|)
expr_stmt|;
name|ke
operator|=
operator|(
operator|(
name|p
operator|=
name|tigetstr
argument_list|(
literal|"rmkx"
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
operator|)
condition|?
name|NULL
else|:
name|strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ks
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ks
argument_list|)
expr_stmt|;
name|ks
operator|=
operator|(
operator|(
name|p
operator|=
name|tigetstr
argument_list|(
literal|"smkx"
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
operator|)
condition|?
name|NULL
else|:
name|strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|vb
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vb
argument_list|)
expr_stmt|;
name|vb
operator|=
operator|(
operator|(
name|p
operator|=
name|tigetstr
argument_list|(
literal|"flash"
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
operator|)
condition|?
name|NULL
else|:
name|strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_CURSES_SETUPTERM */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_CURSES_TIGETSTR
end_ifndef

begin_comment
comment|/* Terminfo-to-termcap translation table. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_tl
block|{
name|char
modifier|*
name|terminfo
decl_stmt|;
comment|/* Terminfo name. */
name|char
modifier|*
name|termcap
decl_stmt|;
comment|/* Termcap name. */
block|}
name|TL
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|TL
name|list
index|[]
init|=
block|{
literal|"cols"
block|,
literal|"co"
block|,
comment|/* Terminal columns. */
literal|"cup"
block|,
literal|"cm"
block|,
comment|/* Cursor up. */
literal|"cuu1"
block|,
literal|"up"
block|,
comment|/* Cursor up. */
literal|"el"
block|,
literal|"ce"
block|,
comment|/* Clear to end-of-line. */
literal|"flash"
block|,
literal|"vb"
block|,
comment|/* Visible bell. */
literal|"kcub1"
block|,
literal|"kl"
block|,
comment|/* Cursor left. */
literal|"kcud1"
block|,
literal|"kd"
block|,
comment|/* Cursor down. */
literal|"kcuf1"
block|,
literal|"kr"
block|,
comment|/* Cursor right. */
literal|"kcuu1"
block|,
literal|"ku"
block|,
comment|/* Cursor up. */
literal|"kdch1"
block|,
literal|"kD"
block|,
comment|/* Delete character. */
literal|"kdl1"
block|,
literal|"kL"
block|,
comment|/* Delete line. */
literal|"ked"
block|,
literal|"kS"
block|,
comment|/* Delete to end of screen. */
literal|"kel"
block|,
literal|"kE"
block|,
comment|/* Delete to eol. */
literal|"kend"
block|,
literal|"@7"
block|,
comment|/* Go to eol. */
literal|"khome"
block|,
literal|"kh"
block|,
comment|/* Go to sol. */
literal|"kich1"
block|,
literal|"kI"
block|,
comment|/* Insert at cursor. */
literal|"kil1"
block|,
literal|"kA"
block|,
comment|/* Insert line. */
literal|"kind"
block|,
literal|"kF"
block|,
comment|/* Scroll down. */
literal|"kll"
block|,
literal|"kH"
block|,
comment|/* Go to eol. */
literal|"knp"
block|,
literal|"kN"
block|,
comment|/* Page down. */
literal|"kpp"
block|,
literal|"kP"
block|,
comment|/* Page up. */
literal|"kri"
block|,
literal|"kR"
block|,
comment|/* Scroll up. */
literal|"lines"
block|,
literal|"li"
block|,
comment|/* Terminal lines. */
literal|"rmcup"
block|,
literal|"te"
block|,
comment|/* Terminal end string. */
literal|"rmkx"
block|,
literal|"ke"
block|,
comment|/* Exit "keypad-transmit" mode. */
literal|"rmso"
block|,
literal|"se"
block|,
comment|/* Standout end. */
literal|"smcup"
block|,
literal|"ti"
block|,
comment|/* Terminal initialization string. */
literal|"smkx"
block|,
literal|"ks"
block|,
comment|/* Enter "keypad-transmit" mode. */
literal|"smso"
block|,
literal|"so"
block|,
comment|/* Standout begin. */
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_comment
comment|/*  * AIX's implementation for function keys greater than 10 is different and  * only goes as far as 36.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|codes
index|[]
init|=
block|{
comment|/*  0-10 */
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|';'
block|,
comment|/* 11-20 */
literal|'<'
block|,
literal|'>'
block|,
literal|'!'
block|,
literal|'@'
block|,
literal|'#'
block|,
literal|'$'
block|,
literal|'%'
block|,
literal|'^'
block|,
literal|'&'
block|,
literal|'*'
block|,
comment|/* 21-30 */
literal|'('
block|,
literal|')'
block|,
literal|'-'
block|,
literal|'_'
block|,
literal|'+'
block|,
literal|','
block|,
literal|':'
block|,
literal|'?'
block|,
literal|'['
block|,
literal|']'
block|,
comment|/* 31-36 */
literal|'{'
block|,
literal|'}'
block|,
literal|'|'
block|,
literal|'~'
block|,
literal|'/'
block|,
literal|'='
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * !!!  * Historically, the 4BSD termcap code didn't support functions keys greater  * than 9.  This was silently enforced -- asking for key k12 would return the  * value for k1.  We try and get around this by using the tables specified in  * the terminfo(TI_ENV) man page from the 3rd Edition SVID.  This assumes the  * implementors of any System V compatibility code or an extended termcap used  * those codes.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|codes
index|[]
init|=
block|{
comment|/*  0-10 */
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|';'
block|,
comment|/* 11-19 */
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
comment|/* 20-63 */
literal|'A'
block|,
literal|'B'
block|,
literal|'C'
block|,
literal|'D'
block|,
literal|'E'
block|,
literal|'F'
block|,
literal|'G'
block|,
literal|'H'
block|,
literal|'I'
block|,
literal|'J'
block|,
literal|'K'
block|,
literal|'L'
block|,
literal|'M'
block|,
literal|'N'
block|,
literal|'O'
block|,
literal|'P'
block|,
literal|'Q'
block|,
literal|'R'
block|,
literal|'S'
block|,
literal|'T'
block|,
literal|'U'
block|,
literal|'V'
block|,
literal|'W'
block|,
literal|'X'
block|,
literal|'Y'
block|,
literal|'Z'
block|,
literal|'a'
block|,
literal|'b'
block|,
literal|'c'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|'f'
block|,
literal|'g'
block|,
literal|'h'
block|,
literal|'i'
block|,
literal|'j'
block|,
literal|'k'
block|,
literal|'l'
block|,
literal|'m'
block|,
literal|'n'
block|,
literal|'o'
block|,
literal|'p'
block|,
literal|'q'
block|,
literal|'r'
block|,
literal|'s'
block|,
literal|'t'
block|,
literal|'u'
block|,
literal|'v'
block|,
literal|'w'
block|,
literal|'x'
block|,
literal|'y'
block|,
literal|'z'
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _AIX */
end_comment

begin_comment
comment|/*  * lcmp --  *	list comparison routine for bsearch.  */
end_comment

begin_function
specifier|static
name|int
name|lcmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|const
name|void
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|a
argument_list|,
operator|(
operator|(
name|TL
operator|*
operator|)
name|b
operator|)
operator|->
name|terminfo
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * tigetstr --  *  * Vendors put the prototype for tigetstr into random include files, including  *<term.h>, which we can't include because it makes other systems unhappy.  * Try and work around the problem, since we only care about the return value.  *  * PUBLIC: #ifdef HAVE_CURSES_TIGETSTR  * PUBLIC: char *tigetstr();  * PUBLIC: #else  * PUBLIC: char *tigetstr __P((char *));  * PUBLIC: #endif  */
end_comment

begin_function
name|char
modifier|*
name|tigetstr
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
name|char
name|sbuf
index|[
literal|256
index|]
decl_stmt|;
name|TL
modifier|*
name|tlp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|keyname
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|tlp
operator|=
name|bsearch
argument_list|(
name|name
argument_list|,
name|list
argument_list|,
sizeof|sizeof
argument_list|(
name|list
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|TL
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|TL
argument_list|)
argument_list|,
name|lcmp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|_AIX
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'k'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|(
name|n
operator|=
name|atoi
argument_list|(
name|name
operator|+
literal|2
argument_list|)
operator|)
operator|<=
literal|36
condition|)
block|{
name|keyname
index|[
literal|0
index|]
operator|=
literal|'k'
expr_stmt|;
name|keyname
index|[
literal|1
index|]
operator|=
name|codes
index|[
name|n
index|]
expr_stmt|;
name|keyname
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'k'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|(
name|n
operator|=
name|atoi
argument_list|(
name|name
operator|+
literal|2
argument_list|)
operator|)
operator|<=
literal|63
condition|)
block|{
name|keyname
index|[
literal|0
index|]
operator|=
name|n
operator|<=
literal|10
condition|?
literal|'k'
else|:
literal|'F'
expr_stmt|;
name|keyname
index|[
literal|1
index|]
operator|=
name|codes
index|[
name|n
index|]
expr_stmt|;
name|keyname
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
name|name
operator|=
name|keyname
expr_stmt|;
block|}
block|}
else|else
name|name
operator|=
name|tlp
operator|->
name|termcap
expr_stmt|;
name|p
operator|=
name|sbuf
expr_stmt|;
ifdef|#
directive|ifdef
name|_AIX
return|return
operator|(
operator|(
name|p
operator|=
name|tgetstr
argument_list|(
name|name
argument_list|,
operator|&
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|?
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
else|:
name|strcpy
argument_list|(
name|sbuf
argument_list|,
name|p
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|tgetstr
argument_list|(
name|name
argument_list|,
operator|&
name|p
argument_list|)
operator|==
name|NULL
condition|?
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
else|:
name|sbuf
operator|)
return|;
endif|#
directive|endif
block|}
comment|/*  * tigetnum --  *  * PUBLIC: #ifndef HAVE_CURSES_TIGETSTR  * PUBLIC: int tigetnum __P((char *));  * PUBLIC: #endif  */
name|int
name|tigetnum
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|TL
modifier|*
name|tlp
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
operator|(
name|tlp
operator|=
name|bsearch
argument_list|(
name|name
argument_list|,
name|list
argument_list|,
sizeof|sizeof
argument_list|(
name|list
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|TL
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|TL
argument_list|)
argument_list|,
name|lcmp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|name
operator|=
name|tlp
operator|->
name|termcap
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|val
operator|=
name|tgetnum
argument_list|(
name|name
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|?
operator|-
literal|2
else|:
name|val
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_CURSES_TIGETSTR */
end_comment

end_unit

