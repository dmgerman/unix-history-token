begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994, 1996  *	Rob Mayoff.  All rights reserved.  * Copyright (c) 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"$Id: ex_cscope.c,v 10.25 2012/10/04 09:23:03 zy Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"../common/common.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"tag.h"
end_include

begin_define
define|#
directive|define
name|CSCOPE_DBFILE
value|"cscope.out"
end_define

begin_define
define|#
directive|define
name|CSCOPE_PATHS
value|"cscope.tpath"
end_define

begin_comment
comment|/*  * 0name	find all uses of name  * 1name	find definition of name  * 2name	find all function calls made from name  * 3name	find callers of name  * 4string	find text string (cscope 12.9)  * 4name	find assignments to name (cscope 13.3)  * 5pattern	change pattern -- NOT USED  * 6pattern	find pattern  * 7name	find files with name as substring  * 8name	find files #including name  */
end_comment

begin_define
define|#
directive|define
name|FINDHELP
value|"\ find c|d|e|f|g|i|s|t buffer|pattern\n\       c: find callers of name\n\       d: find all function calls made from name\n\       e: find pattern\n\       f: find files with name as substring\n\       g: find definition of name\n\       i: find files #including name\n\       s: find all uses of name\n\       t: find assignments to name"
end_define

begin_decl_stmt
specifier|static
name|int
name|cscope_add
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXCMD
operator|*
operator|,
name|CHAR_T
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cscope_find
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXCMD
operator|*
operator|,
name|CHAR_T
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cscope_help
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXCMD
operator|*
operator|,
name|CHAR_T
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cscope_kill
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXCMD
operator|*
operator|,
name|CHAR_T
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cscope_reset
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXCMD
operator|*
operator|,
name|CHAR_T
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|_cc
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
argument_list|(
argument|*function
argument_list|)
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXCMD
operator|*
operator|,
name|CHAR_T
operator|*
operator|)
argument_list|)
expr_stmt|;
name|char
modifier|*
name|help_msg
decl_stmt|;
name|char
modifier|*
name|usage_msg
decl_stmt|;
block|}
name|CC
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|CC
specifier|const
name|cscope_cmds
index|[]
init|=
block|{
block|{
literal|"add"
block|,
name|cscope_add
block|,
literal|"Add a new cscope database"
block|,
literal|"add file | directory"
block|}
block|,
block|{
literal|"find"
block|,
name|cscope_find
block|,
literal|"Query the databases for a pattern"
block|,
name|FINDHELP
block|}
block|,
block|{
literal|"help"
block|,
name|cscope_help
block|,
literal|"Show help for cscope commands"
block|,
literal|"help [command]"
block|}
block|,
block|{
literal|"kill"
block|,
name|cscope_kill
block|,
literal|"Kill a cscope connection"
block|,
literal|"kill number"
block|}
block|,
block|{
literal|"reset"
block|,
name|cscope_reset
block|,
literal|"Discard all current cscope connections"
block|,
literal|"reset"
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TAGQ
modifier|*
name|create_cs_cmd
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|char
operator|*
operator|,
name|size_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|csc_help
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|csc_file
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|CSC
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_paths
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|CSC
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CC
specifier|const
modifier|*
name|lookup_ccmd
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|CSC
operator|*
operator|,
name|TAGQ
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|read_prompt
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|CSC
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|run_cscope
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|CSC
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|start_cscopes
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXCMD
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|terminate
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|CSC
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ex_cscope --  *	Perform an ex cscope.  *  * PUBLIC: int ex_cscope __P((SCR *, EXCMD *));  */
end_comment

begin_function
name|int
name|ex_cscope
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EXCMD
modifier|*
name|cmdp
parameter_list|)
block|{
name|CC
specifier|const
modifier|*
name|ccp
decl_stmt|;
name|EX_PRIVATE
modifier|*
name|exp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CHAR_T
modifier|*
name|cmd
decl_stmt|;
name|CHAR_T
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|np
decl_stmt|;
name|size_t
name|nlen
decl_stmt|;
comment|/* Initialize the default cscope directories. */
name|exp
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|exp
argument_list|,
name|EXP_CSCINIT
argument_list|)
operator|&&
name|start_cscopes
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|exp
argument_list|,
name|EXP_CSCINIT
argument_list|)
expr_stmt|;
comment|/* Skip leading whitespace. */
for|for
control|(
name|p
operator|=
name|cmdp
operator|->
name|argv
index|[
literal|0
index|]
operator|->
name|bp
operator|,
name|i
operator|=
name|cmdp
operator|->
name|argv
index|[
literal|0
index|]
operator|->
name|len
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
operator|,
operator|++
name|p
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|usage
goto|;
comment|/* Skip the command to any arguments. */
for|for
control|(
name|cmd
operator|=
name|p
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
operator|,
operator|++
name|p
control|)
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
control|)
empty_stmt|;
block|}
name|INT2CHAR
argument_list|(
name|sp
argument_list|,
name|cmd
argument_list|,
name|STRLEN
argument_list|(
name|cmd
argument_list|)
operator|+
literal|1
argument_list|,
name|np
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccp
operator|=
name|lookup_ccmd
argument_list|(
name|np
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|usage
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"309|Use \"cscope help\" for help"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Call the underlying function. */
return|return
operator|(
name|ccp
operator|->
name|function
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * start_cscopes --  *	Initialize the cscope package.  */
end_comment

begin_function
specifier|static
name|int
name|start_cscopes
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EXCMD
modifier|*
name|cmdp
parameter_list|)
block|{
name|size_t
name|blen
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cscopes
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|CHAR_T
modifier|*
name|wp
decl_stmt|;
name|size_t
name|wlen
decl_stmt|;
comment|/* 	 * EXTENSION #1: 	 * 	 * If the CSCOPE_DIRS environment variable is set, we treat it as a 	 * list of cscope directories that we're using, similar to the tags 	 * edit option. 	 * 	 * XXX 	 * This should probably be an edit option, although that implies that 	 * we start/stop cscope processes periodically, instead of once when 	 * the editor starts. 	 */
if|if
condition|(
operator|(
name|cscopes
operator|=
name|getenv
argument_list|(
literal|"CSCOPE_DIRS"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|len
operator|=
name|strlen
argument_list|(
name|cscopes
argument_list|)
expr_stmt|;
name|GET_SPACE_RETC
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bp
argument_list|,
name|cscopes
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|cscopes
operator|=
name|t
operator|=
name|bp
init|;
operator|(
name|p
operator|=
name|strsep
argument_list|(
operator|&
name|t
argument_list|,
literal|"\t :"
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|CHAR2INT
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|,
name|wp
argument_list|,
name|wlen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cscope_add
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|,
name|wp
argument_list|)
expr_stmt|;
block|}
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cscope_add --  *	The cscope add command.  */
end_comment

begin_function
specifier|static
name|int
name|cscope_add
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EXCMD
modifier|*
name|cmdp
parameter_list|,
name|CHAR_T
modifier|*
name|dname
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|EX_PRIVATE
modifier|*
name|exp
decl_stmt|;
name|CSC
modifier|*
name|csc
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|cur_argc
decl_stmt|;
name|char
modifier|*
name|dbname
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|np
init|=
name|NULL
decl_stmt|;
name|size_t
name|nlen
decl_stmt|;
name|exp
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 *  0 additional args: usage. 	 *  1 additional args: matched a file. 	 *>1 additional args: object, too many args. 	 */
name|cur_argc
operator|=
name|cmdp
operator|->
name|argc
expr_stmt|;
if|if
condition|(
name|argv_exp2
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|,
name|dname
argument_list|,
name|STRLEN
argument_list|(
name|dname
argument_list|)
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cmdp
operator|->
name|argc
operator|==
name|cur_argc
condition|)
block|{
operator|(
name|void
operator|)
name|csc_help
argument_list|(
name|sp
argument_list|,
literal|"add"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cmdp
operator|->
name|argc
operator|==
name|cur_argc
operator|+
literal|1
condition|)
name|dname
operator|=
name|cmdp
operator|->
name|argv
index|[
name|cur_argc
index|]
operator|->
name|bp
expr_stmt|;
else|else
block|{
name|ex_emsg
argument_list|(
name|sp
argument_list|,
name|np
argument_list|,
name|EXM_FILECOUNT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|INT2CHAR
argument_list|(
name|sp
argument_list|,
name|dname
argument_list|,
name|STRLEN
argument_list|(
name|dname
argument_list|)
operator|+
literal|1
argument_list|,
name|np
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
comment|/* 	 * The user can specify a specific file (so they can have multiple 	 * Cscope databases in a single directory) or a directory.  If the 	 * file doesn't exist, we're done.  If it's a directory, append the 	 * standard database file name and try again.  Store the directory 	 * name regardless so that we can use it as a base for searches. 	 */
if|if
condition|(
name|stat
argument_list|(
name|np
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"%s"
argument_list|,
name|np
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|path
operator|=
name|join
argument_list|(
name|np
argument_list|,
name|CSCOPE_DBFILE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|dbname
operator|=
name|CSCOPE_DBFILE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dbname
operator|=
name|strrchr
argument_list|(
name|np
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|dbname
operator|++
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|dbname
operator|=
name|np
expr_stmt|;
name|np
operator|=
literal|"."
expr_stmt|;
block|}
comment|/* Allocate a cscope connection structure and initialize its fields. */
name|len
operator|=
name|strlen
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|CALLOC_RET
argument_list|(
name|sp
argument_list|,
name|csc
argument_list|,
name|CSC
operator|*
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|CSC
argument_list|)
operator|+
name|len
argument_list|)
expr_stmt|;
name|csc
operator|->
name|dname
operator|=
name|csc
operator|->
name|buf
expr_stmt|;
name|csc
operator|->
name|dlen
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|csc
operator|->
name|dname
argument_list|,
name|np
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|csc
operator|->
name|mtim
operator|=
name|sb
operator|.
name|st_mtimespec
expr_stmt|;
comment|/* Get the search paths for the cscope. */
if|if
condition|(
name|get_paths
argument_list|(
name|sp
argument_list|,
name|csc
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Start the cscope process. */
if|if
condition|(
name|run_cscope
argument_list|(
name|sp
argument_list|,
name|csc
argument_list|,
name|dbname
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 	 * Add the cscope connection to the screen's list.  From now on,  	 * on error, we have to call terminate, which expects the csc to 	 * be on the chain. 	 */
name|SLIST_INSERT_HEAD
argument_list|(
name|exp
operator|->
name|cscq
argument_list|,
name|csc
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Read the initial prompt from the cscope to make sure it's okay. */
return|return
name|read_prompt
argument_list|(
name|sp
argument_list|,
name|csc
argument_list|)
return|;
name|err
label|:
name|free
argument_list|(
name|csc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * get_paths --  *	Get the directories to search for the files associated with this  *	cscope database.  */
end_comment

begin_function
specifier|static
name|int
name|get_paths
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|CSC
modifier|*
name|csc
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|nentries
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pathp
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
comment|/* 	 * EXTENSION #2: 	 * 	 * If there's a cscope directory with a file named CSCOPE_PATHS, it 	 * contains a colon-separated list of paths in which to search for 	 * files returned by cscope. 	 * 	 * XXX 	 * These paths are absolute paths, and not relative to the cscope 	 * directory.  To fix this, rewrite the each path using the cscope 	 * directory as a prefix. 	 */
if|if
condition|(
operator|(
name|buf
operator|=
name|join
argument_list|(
name|csc
operator|->
name|dname
argument_list|,
name|CSCOPE_PATHS
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|buf
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Read in the CSCOPE_PATHS file. */
name|len
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
name|MALLOC_RET
argument_list|(
name|sp
argument_list|,
name|csc
operator|->
name|pbuf
argument_list|,
name|char
operator|*
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|buf
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|read
argument_list|(
name|fd
argument_list|,
name|csc
operator|->
name|pbuf
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
block|{
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|buf
argument_list|,
literal|"%s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|csc
operator|->
name|pbuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Count up the entries. */
for|for
control|(
name|nentries
operator|=
literal|0
operator|,
name|p
operator|=
name|csc
operator|->
name|pbuf
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
operator|++
name|nentries
expr_stmt|;
comment|/* Build an array of pointers to the paths. */
name|CALLOC_GOTO
argument_list|(
name|sp
argument_list|,
name|csc
operator|->
name|paths
argument_list|,
name|char
operator|*
operator|*
argument_list|,
name|nentries
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pathp
operator|=
name|csc
operator|->
name|paths
operator|,
name|p
operator|=
name|strtok
argument_list|(
name|csc
operator|->
name|pbuf
argument_list|,
literal|":"
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
control|)
operator|*
name|pathp
operator|++
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* 	 * If the CSCOPE_PATHS file doesn't exist, we look for files 	 * relative to the cscope directory. 	 */
if|if
condition|(
operator|(
name|csc
operator|->
name|pbuf
operator|=
name|strdup
argument_list|(
name|csc
operator|->
name|dname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|CALLOC_GOTO
argument_list|(
name|sp
argument_list|,
name|csc
operator|->
name|paths
argument_list|,
name|char
operator|*
operator|*
argument_list|,
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|csc
operator|->
name|paths
index|[
literal|0
index|]
operator|=
name|csc
operator|->
name|pbuf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|alloc_err
label|:
if|if
condition|(
name|csc
operator|->
name|pbuf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|csc
operator|->
name|pbuf
argument_list|)
expr_stmt|;
name|csc
operator|->
name|pbuf
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * run_cscope --  *	Fork off the cscope process.  */
end_comment

begin_function
specifier|static
name|int
name|run_cscope
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|CSC
modifier|*
name|csc
parameter_list|,
name|char
modifier|*
name|dbname
parameter_list|)
block|{
name|int
name|to_cs
index|[
literal|2
index|]
decl_stmt|,
name|from_cs
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* 	 * Cscope reads from to_cs[0] and writes to from_cs[1]; vi reads from 	 * from_cs[0] and writes to to_cs[1]. 	 */
name|to_cs
index|[
literal|0
index|]
operator|=
name|to_cs
index|[
literal|1
index|]
operator|=
name|from_cs
index|[
literal|0
index|]
operator|=
name|from_cs
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|to_cs
argument_list|)
operator|<
literal|0
operator|||
name|pipe
argument_list|(
name|from_cs
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"pipe"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
switch|switch
condition|(
name|csc
operator|->
name|pid
operator|=
name|vfork
argument_list|()
condition|)
block|{
name|char
modifier|*
name|dn
decl_stmt|,
modifier|*
name|dbn
decl_stmt|;
case|case
operator|-
literal|1
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"vfork"
argument_list|)
expr_stmt|;
name|err
label|:
if|if
condition|(
name|to_cs
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|to_cs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_cs
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|to_cs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_cs
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|from_cs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_cs
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|from_cs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|0
case|:
comment|/* child: run cscope. */
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|to_cs
index|[
literal|0
index|]
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|from_cs
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|from_cs
index|[
literal|1
index|]
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
comment|/* Close unused file descriptors. */
operator|(
name|void
operator|)
name|close
argument_list|(
name|to_cs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|from_cs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Run the cscope command. */
define|#
directive|define
name|CSCOPE_CMD_FMT
value|"cd %s&& exec cscope -dl -f %s"
if|if
condition|(
operator|(
name|dn
operator|=
name|quote
argument_list|(
name|csc
operator|->
name|dname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|nomem
goto|;
if|if
condition|(
operator|(
name|dbn
operator|=
name|quote
argument_list|(
name|dbname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
operator|(
name|void
operator|)
name|asprintf
argument_list|(
operator|&
name|cmd
argument_list|,
name|CSCOPE_CMD_FMT
argument_list|,
name|dn
argument_list|,
name|dbn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dbn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
block|{
name|nomem
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|execl
argument_list|(
name|_PATH_BSHELL
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|cmd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|cmd
argument_list|,
literal|"execl: %s"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
comment|/* parent. */
comment|/* Close unused file descriptors. */
operator|(
name|void
operator|)
name|close
argument_list|(
name|to_cs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|from_cs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * Save the file descriptors for later duplication, and 		 * reopen as streams. 		 */
name|csc
operator|->
name|to_fd
operator|=
name|to_cs
index|[
literal|1
index|]
expr_stmt|;
name|csc
operator|->
name|to_fp
operator|=
name|fdopen
argument_list|(
name|to_cs
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|csc
operator|->
name|from_fd
operator|=
name|from_cs
index|[
literal|0
index|]
expr_stmt|;
name|csc
operator|->
name|from_fp
operator|=
name|fdopen
argument_list|(
name|from_cs
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cscope_find --  *	The cscope find command.  */
end_comment

begin_function
specifier|static
name|int
name|cscope_find
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EXCMD
modifier|*
name|cmdp
parameter_list|,
name|CHAR_T
modifier|*
name|pattern
parameter_list|)
block|{
name|CSC
modifier|*
name|csc
decl_stmt|,
modifier|*
name|csc_next
decl_stmt|;
name|EX_PRIVATE
modifier|*
name|exp
decl_stmt|;
name|FREF
modifier|*
name|frp
decl_stmt|;
name|TAGQ
modifier|*
name|rtqp
decl_stmt|,
modifier|*
name|tqp
decl_stmt|;
name|TAG
modifier|*
name|rtp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|size_t
name|cno
decl_stmt|,
name|search
decl_stmt|;
name|int
name|force
decl_stmt|,
name|istmp
decl_stmt|,
name|matches
decl_stmt|;
name|char
modifier|*
name|np
init|=
name|NULL
decl_stmt|;
name|size_t
name|nlen
decl_stmt|;
name|exp
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* Check for connections. */
if|if
condition|(
name|SLIST_EMPTY
argument_list|(
name|exp
operator|->
name|cscq
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"310|No cscope connections running"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Allocate all necessary memory before doing anything hard.  If the 	 * tags stack is empty, we'll need the `local context' TAGQ structure 	 * later. 	 */
name|rtp
operator|=
name|NULL
expr_stmt|;
name|rtqp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
name|exp
operator|->
name|tq
argument_list|)
condition|)
block|{
comment|/* Initialize the `local context' tag queue structure. */
name|CALLOC_GOTO
argument_list|(
name|sp
argument_list|,
name|rtqp
argument_list|,
name|TAGQ
operator|*
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|TAGQ
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
name|rtqp
operator|->
name|tagq
argument_list|)
expr_stmt|;
comment|/* Initialize and link in its tag structure. */
name|CALLOC_GOTO
argument_list|(
name|sp
argument_list|,
name|rtp
argument_list|,
name|TAG
operator|*
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|TAG
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
name|rtqp
operator|->
name|tagq
argument_list|,
name|rtp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|rtqp
operator|->
name|current
operator|=
name|rtp
expr_stmt|;
block|}
comment|/* Create the cscope command. */
name|INT2CHAR
argument_list|(
name|sp
argument_list|,
name|pattern
argument_list|,
name|STRLEN
argument_list|(
name|pattern
argument_list|)
operator|+
literal|1
argument_list|,
name|np
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|np
operator|=
name|strdup
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tqp
operator|=
name|create_cs_cmd
argument_list|(
name|sp
argument_list|,
name|np
argument_list|,
operator|&
name|search
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|np
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* 	 * Stick the current context in a convenient place, we'll lose it 	 * when we switch files. 	 */
name|frp
operator|=
name|sp
operator|->
name|frp
expr_stmt|;
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|istmp
operator|=
name|F_ISSET
argument_list|(
name|sp
operator|->
name|frp
argument_list|,
name|FR_TMPFILE
argument_list|)
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|cmdp
argument_list|,
name|E_NEWSCREEN
argument_list|)
expr_stmt|;
comment|/* Search all open connections for a match. */
name|matches
operator|=
literal|0
expr_stmt|;
comment|/* Copy next connect here in case csc is killed. */
name|SLIST_FOREACH_SAFE
argument_list|(
argument|csc
argument_list|,
argument|exp->cscq
argument_list|,
argument|q
argument_list|,
argument|csc_next
argument_list|)
block|{
comment|/* 		 * Send the command to the cscope program.  (We skip the 		 * first two bytes of the command, because we stored the 		 * search cscope command character and a leading space 		 * there.) 		 */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|csc
operator|->
name|to_fp
argument_list|,
literal|"%lu%s\n"
argument_list|,
name|search
argument_list|,
name|tqp
operator|->
name|tag
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|csc
operator|->
name|to_fp
argument_list|)
expr_stmt|;
comment|/* Read the output. */
if|if
condition|(
name|parse
argument_list|(
name|sp
argument_list|,
name|csc
argument_list|,
name|tqp
argument_list|,
operator|&
name|matches
argument_list|)
condition|)
goto|goto
name|nomatch
goto|;
block|}
if|if
condition|(
name|matches
operator|==
literal|0
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"278|No matches for query"
argument_list|)
expr_stmt|;
name|nomatch
label|:
if|if
condition|(
name|rtp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rtp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtqp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rtqp
argument_list|)
expr_stmt|;
name|tagq_free
argument_list|(
name|sp
argument_list|,
name|tqp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Try to switch to the first tag. */
name|force
operator|=
name|FL_ISSET
argument_list|(
name|cmdp
operator|->
name|iflags
argument_list|,
name|E_C_FORCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|cmdp
argument_list|,
name|E_NEWSCREEN
argument_list|)
condition|)
block|{
if|if
condition|(
name|ex_tag_Nswitch
argument_list|(
name|sp
argument_list|,
name|tqp
operator|->
name|current
argument_list|,
name|force
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Everything else gets done in the new screen. */
name|sp
operator|=
name|sp
operator|->
name|nextdisp
expr_stmt|;
name|exp
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ex_tag_nswitch
argument_list|(
name|sp
argument_list|,
name|tqp
operator|->
name|current
argument_list|,
name|force
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 	 * If this is the first tag, put a `current location' queue entry 	 * in place, so we can pop all the way back to the current mark. 	 * Note, it doesn't point to much of anything, it's a placeholder. 	 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
name|exp
operator|->
name|tq
argument_list|)
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
name|exp
operator|->
name|tq
argument_list|,
name|rtqp
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|rtqp
operator|=
name|TAILQ_FIRST
argument_list|(
name|exp
operator|->
name|tq
argument_list|)
expr_stmt|;
comment|/* Link the current TAGQ structure into place. */
name|TAILQ_INSERT_HEAD
argument_list|(
name|exp
operator|->
name|tq
argument_list|,
name|tqp
argument_list|,
name|q
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cscope_search
argument_list|(
name|sp
argument_list|,
name|tqp
argument_list|,
name|tqp
operator|->
name|current
argument_list|)
expr_stmt|;
comment|/* 	 * Move the current context from the temporary save area into the 	 * right structure. 	 * 	 * If we were in a temporary file, we don't have a context to which 	 * we can return, so just make it be the same as what we're moving 	 * to.  It will be a little odd that ^T doesn't change anything, but 	 * I don't think it's a big deal. 	 */
if|if
condition|(
name|istmp
condition|)
block|{
name|rtqp
operator|->
name|current
operator|->
name|frp
operator|=
name|sp
operator|->
name|frp
expr_stmt|;
name|rtqp
operator|->
name|current
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|rtqp
operator|->
name|current
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
block|}
else|else
block|{
name|rtqp
operator|->
name|current
operator|->
name|frp
operator|=
name|frp
expr_stmt|;
name|rtqp
operator|->
name|current
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|rtqp
operator|->
name|current
operator|->
name|cno
operator|=
name|cno
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|alloc_err
label|:
if|if
condition|(
name|rtqp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rtqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rtp
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * create_cs_cmd --  *	Build a cscope command, creating and initializing the base TAGQ.  */
end_comment

begin_function
specifier|static
name|TAGQ
modifier|*
name|create_cs_cmd
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|char
modifier|*
name|pattern
parameter_list|,
name|size_t
modifier|*
name|searchp
parameter_list|)
block|{
name|CB
modifier|*
name|cbp
decl_stmt|;
name|TAGQ
modifier|*
name|tqp
decl_stmt|;
name|size_t
name|tlen
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Cscope supports a "change pattern" command which we never use, 	 * cscope command 5.  Set CSCOPE_QUERIES[5] to " " since the user 	 * can't pass " " as the first character of pattern.  That way the 	 * user can't ask for pattern 5 so we don't need any special-case 	 * code. 	 */
define|#
directive|define
name|CSCOPE_QUERIES
value|"sgdct efi"
if|if
condition|(
name|pattern
operator|==
name|NULL
condition|)
goto|goto
name|usage
goto|;
comment|/* Skip leading blanks, check for command character. */
for|for
control|(
init|;
name|cmdskip
argument_list|(
name|pattern
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|pattern
control|)
empty_stmt|;
if|if
condition|(
name|pattern
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|!
name|cmdskip
argument_list|(
name|pattern
index|[
literal|1
index|]
argument_list|)
condition|)
goto|goto
name|usage
goto|;
for|for
control|(
operator|*
name|searchp
operator|=
literal|0
operator|,
name|p
operator|=
name|CSCOPE_QUERIES
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
name|pattern
index|[
literal|0
index|]
condition|;
operator|++
operator|*
name|searchp
operator|,
operator|++
name|p
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"311|%s: unknown search type: use one of %s"
argument_list|,
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
name|pattern
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|CSCOPE_QUERIES
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Skip<blank> characters to the pattern. */
for|for
control|(
name|p
operator|=
name|pattern
operator|+
literal|1
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|cmdskip
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|usage
label|:
operator|(
name|void
operator|)
name|csc_help
argument_list|(
name|sp
argument_list|,
literal|"find"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* The user can specify the contents of a buffer as the pattern. */
name|cbp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'"'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|CBNAME
argument_list|(
name|sp
argument_list|,
name|cbp
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|!=
name|NULL
condition|)
block|{
name|INT2CHAR
argument_list|(
name|sp
argument_list|,
name|TAILQ_FIRST
argument_list|(
name|cbp
operator|->
name|textq
argument_list|)
operator|->
name|lb
argument_list|,
name|TAILQ_FIRST
argument_list|(
name|cbp
operator|->
name|textq
argument_list|)
operator|->
name|len
argument_list|,
name|p
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
block|}
else|else
name|tlen
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Allocate and initialize the TAGQ structure. */
name|CALLOC
argument_list|(
name|sp
argument_list|,
name|tqp
argument_list|,
name|TAGQ
operator|*
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|TAGQ
argument_list|)
operator|+
name|tlen
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|tqp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|TAILQ_INIT
argument_list|(
name|tqp
operator|->
name|tagq
argument_list|)
expr_stmt|;
name|tqp
operator|->
name|tag
operator|=
name|tqp
operator|->
name|buf
expr_stmt|;
name|tqp
operator|->
name|tag
index|[
literal|0
index|]
operator|=
name|pattern
index|[
literal|0
index|]
expr_stmt|;
name|tqp
operator|->
name|tag
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|tqp
operator|->
name|tlen
operator|=
name|tlen
operator|+
literal|2
expr_stmt|;
name|memcpy
argument_list|(
name|tqp
operator|->
name|tag
operator|+
literal|2
argument_list|,
name|p
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|tqp
operator|->
name|tag
index|[
name|tlen
operator|+
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|F_SET
argument_list|(
name|tqp
argument_list|,
name|TAG_CSCOPE
argument_list|)
expr_stmt|;
return|return
operator|(
name|tqp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * parse --  *	Parse the cscope output.  */
end_comment

begin_function
specifier|static
name|int
name|parse
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|CSC
modifier|*
name|csc
parameter_list|,
name|TAGQ
modifier|*
name|tqp
parameter_list|,
name|int
modifier|*
name|matchesp
parameter_list|)
block|{
name|TAG
modifier|*
name|tp
decl_stmt|;
name|recno_t
name|slno
init|=
literal|0
decl_stmt|;
name|size_t
name|dlen
decl_stmt|,
name|nlen
init|=
literal|0
decl_stmt|,
name|slen
init|=
literal|0
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|i
decl_stmt|,
name|isolder
init|=
literal|0
decl_stmt|,
name|nlines
decl_stmt|;
name|char
modifier|*
name|dname
init|=
name|NULL
decl_stmt|,
modifier|*
name|name
init|=
name|NULL
decl_stmt|,
modifier|*
name|search
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|,
name|dummy
index|[
literal|2
index|]
decl_stmt|,
name|buf
index|[
literal|2048
index|]
decl_stmt|;
name|CHAR_T
modifier|*
name|wp
decl_stmt|;
name|size_t
name|wlen
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|csc
operator|->
name|from_fp
argument_list|)
condition|)
goto|goto
name|io_err
goto|;
comment|/* 		 * If the database is out of date, or there's some other 		 * problem, cscope will output error messages before the 		 * number-of-lines output.  Display/discard any output 		 * that doesn't match what we want. 		 */
define|#
directive|define
name|CSCOPE_NLINES_FMT
value|"cscope: %d lines%1[\n]"
if|if
condition|(
name|sscanf
argument_list|(
name|buf
argument_list|,
name|CSCOPE_NLINES_FMT
argument_list|,
operator|&
name|nlines
argument_list|,
name|dummy
argument_list|)
operator|==
literal|2
condition|)
break|break;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: \"%s\""
argument_list|,
name|csc
operator|->
name|dname
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|nlines
operator|--
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|csc
operator|->
name|from_fp
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|io_err
goto|;
comment|/* If the line's too long for the buffer, discard it. */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|csc
operator|->
name|from_fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
empty_stmt|;
continue|continue;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * The cscope output is in the following format: 		 * 		 *<filename><context><line number><pattern> 		 * 		 * Figure out how long everything is so we can allocate in one 		 * swell foop, but discard anything that looks wrong. 		 */
for|for
control|(
name|p
operator|=
name|buf
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
operator|&&
operator|(
name|t
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|"\t "
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
comment|/* Filename. */
name|name
operator|=
name|t
expr_stmt|;
name|nlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Context. */
break|break;
case|case
literal|2
case|:
comment|/* Line number. */
name|slno
operator|=
operator|(
name|recno_t
operator|)
name|atol
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|!=
literal|3
operator|||
name|p
operator|==
name|NULL
operator|||
name|t
operator|==
name|NULL
condition|)
continue|continue;
comment|/* The rest of the string is the search pattern. */
name|search
operator|=
name|p
expr_stmt|;
name|slen
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Resolve the file name. */
name|csc_file
argument_list|(
name|sp
argument_list|,
name|csc
argument_list|,
name|name
argument_list|,
operator|&
name|dname
argument_list|,
operator|&
name|dlen
argument_list|,
operator|&
name|isolder
argument_list|)
expr_stmt|;
comment|/* 		 * If the file is older than the cscope database, that is, 		 * the database was built since the file was last modified, 		 * or there wasn't a search string, use the line number. 		 */
if|if
condition|(
name|isolder
operator|||
name|strcmp
argument_list|(
name|search
argument_list|,
literal|"<unknown>"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|search
operator|=
name|NULL
expr_stmt|;
name|slen
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Allocate and initialize a tag structure plus the variable 		 * length cscope information that follows it. 		 */
name|CALLOC_RET
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|,
name|TAG
operator|*
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|TAG
argument_list|)
operator|+
name|dlen
operator|+
literal|2
operator|+
name|nlen
operator|+
literal|1
operator|+
operator|(
name|slen
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|CHAR_T
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|tp
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|dlen
operator|==
literal|1
operator|&&
operator|*
name|dname
operator|==
literal|'.'
condition|)
operator|--
name|dlen
expr_stmt|;
elseif|else
if|if
condition|(
name|dlen
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|tp
operator|->
name|fname
argument_list|,
name|dname
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|tp
operator|->
name|fname
index|[
name|dlen
index|]
operator|=
literal|'/'
expr_stmt|;
operator|++
name|dlen
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|tp
operator|->
name|fname
operator|+
name|dlen
argument_list|,
name|name
argument_list|,
name|nlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tp
operator|->
name|fnlen
operator|=
name|dlen
operator|+
name|nlen
expr_stmt|;
name|tp
operator|->
name|slno
operator|=
name|slno
expr_stmt|;
name|tp
operator|->
name|search
operator|=
operator|(
name|CHAR_T
operator|*
operator|)
operator|(
name|tp
operator|->
name|fname
operator|+
name|tp
operator|->
name|fnlen
operator|+
literal|1
operator|)
expr_stmt|;
name|CHAR2INT
argument_list|(
name|sp
argument_list|,
name|search
argument_list|,
name|slen
operator|+
literal|1
argument_list|,
name|wp
argument_list|,
name|wlen
argument_list|)
expr_stmt|;
name|MEMCPY
argument_list|(
name|tp
operator|->
name|search
argument_list|,
name|wp
argument_list|,
operator|(
name|tp
operator|->
name|slen
operator|=
name|slen
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|tqp
operator|->
name|tagq
argument_list|,
name|tp
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Try to preset the tag within the current file. */
if|if
condition|(
name|sp
operator|->
name|frp
operator|!=
name|NULL
operator|&&
name|sp
operator|->
name|frp
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|tqp
operator|->
name|current
operator|==
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|tp
operator|->
name|fname
argument_list|,
name|sp
operator|->
name|frp
operator|->
name|name
argument_list|)
condition|)
name|tqp
operator|->
name|current
operator|=
name|tp
expr_stmt|;
operator|++
operator|*
name|matchesp
expr_stmt|;
block|}
if|if
condition|(
name|tqp
operator|->
name|current
operator|==
name|NULL
condition|)
name|tqp
operator|->
name|current
operator|=
name|TAILQ_FIRST
argument_list|(
name|tqp
operator|->
name|tagq
argument_list|)
expr_stmt|;
return|return
name|read_prompt
argument_list|(
name|sp
argument_list|,
name|csc
argument_list|)
return|;
name|io_err
label|:
if|if
condition|(
name|feof
argument_list|(
name|csc
operator|->
name|from_fp
argument_list|)
condition|)
name|errno
operator|=
name|EIO
expr_stmt|;
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"%s"
argument_list|,
name|csc
operator|->
name|dname
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
name|sp
argument_list|,
name|csc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * csc_file --  *	Search for the right path to this file.  */
end_comment

begin_function
specifier|static
name|void
name|csc_file
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|CSC
modifier|*
name|csc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
modifier|*
name|dirp
parameter_list|,
name|size_t
modifier|*
name|dlenp
parameter_list|,
name|int
modifier|*
name|isolderp
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|char
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
comment|/* 	 * Check for the file in all of the listed paths.  If we don't 	 * find it, we simply return it unchanged.  We have to do this 	 * now, even though it's expensive, because if the user changes 	 * directories, we can't change our minds as to where the file 	 * lives. 	 */
for|for
control|(
name|pp
operator|=
name|csc
operator|->
name|paths
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
operator|++
name|pp
control|)
block|{
if|if
condition|(
operator|(
name|buf
operator|=
name|join
argument_list|(
operator|*
name|pp
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|dlenp
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stat
argument_list|(
name|buf
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|*
name|dirp
operator|=
operator|*
name|pp
expr_stmt|;
operator|*
name|dlenp
operator|=
name|strlen
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|isolderp
operator|=
name|timespeccmp
argument_list|(
operator|&
name|sb
operator|.
name|st_mtimespec
argument_list|,
operator|&
name|csc
operator|->
name|mtim
argument_list|,
operator|<
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
operator|*
name|dlenp
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * cscope_help --  *	The cscope help command.  */
end_comment

begin_function
specifier|static
name|int
name|cscope_help
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EXCMD
modifier|*
name|cmdp
parameter_list|,
name|CHAR_T
modifier|*
name|subcmd
parameter_list|)
block|{
name|char
modifier|*
name|np
decl_stmt|;
name|size_t
name|nlen
decl_stmt|;
name|INT2CHAR
argument_list|(
name|sp
argument_list|,
name|subcmd
argument_list|,
name|STRLEN
argument_list|(
name|subcmd
argument_list|)
operator|+
literal|1
argument_list|,
name|np
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|csc_help
argument_list|(
name|sp
argument_list|,
name|np
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * csc_help --  *	Display help/usage messages.  */
end_comment

begin_function
specifier|static
name|int
name|csc_help
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|char
modifier|*
name|cmd
parameter_list|)
block|{
name|CC
specifier|const
modifier|*
name|ccp
decl_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|NULL
operator|&&
operator|*
name|cmd
operator|!=
literal|'\0'
condition|)
if|if
condition|(
operator|(
name|ccp
operator|=
name|lookup_ccmd
argument_list|(
name|cmd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ex_printf
argument_list|(
name|sp
argument_list|,
literal|"%s doesn't match any cscope command\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|ex_printf
argument_list|(
name|sp
argument_list|,
literal|"Command: %s (%s)\n"
argument_list|,
name|ccp
operator|->
name|name
argument_list|,
name|ccp
operator|->
name|help_msg
argument_list|)
expr_stmt|;
name|ex_printf
argument_list|(
name|sp
argument_list|,
literal|"  Usage: %s\n"
argument_list|,
name|ccp
operator|->
name|usage_msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ex_printf
argument_list|(
name|sp
argument_list|,
literal|"cscope commands:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ccp
operator|=
name|cscope_cmds
init|;
name|ccp
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|ccp
control|)
name|ex_printf
argument_list|(
name|sp
argument_list|,
literal|"  %*s: %s\n"
argument_list|,
literal|5
argument_list|,
name|ccp
operator|->
name|name
argument_list|,
name|ccp
operator|->
name|help_msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cscope_kill --  *	The cscope kill command.  */
end_comment

begin_function
specifier|static
name|int
name|cscope_kill
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EXCMD
modifier|*
name|cmdp
parameter_list|,
name|CHAR_T
modifier|*
name|cn
parameter_list|)
block|{
name|char
modifier|*
name|np
decl_stmt|;
name|size_t
name|nlen
decl_stmt|;
name|int
name|n
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|cn
condition|)
block|{
name|INT2CHAR
argument_list|(
name|sp
argument_list|,
name|cn
argument_list|,
name|STRLEN
argument_list|(
name|cn
argument_list|)
operator|+
literal|1
argument_list|,
name|np
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|n
operator|=
name|atoi
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|terminate
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|n
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * terminate --  *	Detach from a cscope process.  */
end_comment

begin_function
specifier|static
name|int
name|terminate
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|CSC
modifier|*
name|csc
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|EX_PRIVATE
modifier|*
name|exp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|pstat
decl_stmt|;
name|CSC
modifier|*
name|cp
decl_stmt|,
modifier|*
name|pre_cp
init|=
name|NULL
decl_stmt|;
name|exp
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * We either get a csc structure or a number.  Locate and remove 	 * the candidate which matches the structure or the number. 	 */
if|if
condition|(
name|csc
operator|==
name|NULL
operator|&&
name|n
operator|<
literal|1
condition|)
goto|goto
name|badno
goto|;
name|SLIST_FOREACH
argument_list|(
argument|cp
argument_list|,
argument|exp->cscq
argument_list|,
argument|q
argument_list|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|csc
operator|==
name|NULL
condition|?
name|i
operator|!=
name|n
else|:
name|cp
operator|!=
name|csc
condition|)
block|{
name|pre_cp
operator|=
name|cp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cp
operator|==
name|SLIST_FIRST
argument_list|(
name|exp
operator|->
name|cscq
argument_list|)
condition|)
name|SLIST_REMOVE_HEAD
argument_list|(
name|exp
operator|->
name|cscq
argument_list|,
name|q
argument_list|)
expr_stmt|;
else|else
name|SLIST_REMOVE_AFTER
argument_list|(
name|pre_cp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|csc
operator|=
name|cp
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|csc
operator|==
name|NULL
condition|)
block|{
name|badno
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"312|%d: no such cscope session"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * XXX 	 * Theoretically, we have the only file descriptors to the process, 	 * so closing them should let it exit gracefully, deleting temporary 	 * files, etc.  However, the earlier created cscope processes seems 	 * to refuse to quit unless we send a SIGTERM signal. 	 */
if|if
condition|(
name|csc
operator|->
name|from_fp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|csc
operator|->
name|from_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|csc
operator|->
name|to_fp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|csc
operator|->
name|to_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|kill
argument_list|(
name|csc
operator|->
name|pid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|waitpid
argument_list|(
name|csc
operator|->
name|pid
argument_list|,
operator|&
name|pstat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Discard cscope connection information. */
if|if
condition|(
name|csc
operator|->
name|pbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|csc
operator|->
name|pbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|csc
operator|->
name|paths
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|csc
operator|->
name|paths
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|csc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cscope_reset --  *	The cscope reset command.  */
end_comment

begin_function
specifier|static
name|int
name|cscope_reset
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EXCMD
modifier|*
name|cmdp
parameter_list|,
name|CHAR_T
modifier|*
name|notusedp
parameter_list|)
block|{
return|return
name|cscope_end
argument_list|(
name|sp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * cscope_end --  *	End all cscope connections.  *  * PUBLIC: int cscope_end __P((SCR *));  */
end_comment

begin_function
name|int
name|cscope_end
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|EX_PRIVATE
modifier|*
name|exp
decl_stmt|;
for|for
control|(
name|exp
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
init|;
operator|!
name|SLIST_EMPTY
argument_list|(
name|exp
operator|->
name|cscq
argument_list|)
condition|;
control|)
if|if
condition|(
name|terminate
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cscope_display --  *	Display current connections.  *  * PUBLIC: int cscope_display __P((SCR *));  */
end_comment

begin_function
name|int
name|cscope_display
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|EX_PRIVATE
modifier|*
name|exp
decl_stmt|;
name|CSC
modifier|*
name|csc
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|exp
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLIST_EMPTY
argument_list|(
name|exp
operator|->
name|cscq
argument_list|)
condition|)
block|{
name|ex_printf
argument_list|(
name|sp
argument_list|,
literal|"No cscope connections.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|SLIST_FOREACH
argument_list|(
argument|csc
argument_list|,
argument|exp->cscq
argument_list|,
argument|q
argument_list|)
name|ex_printf
argument_list|(
name|sp
argument_list|,
literal|"%2d %s (process %lu)\n"
argument_list|,
operator|++
name|i
argument_list|,
name|csc
operator|->
name|dname
argument_list|,
operator|(
name|u_long
operator|)
name|csc
operator|->
name|pid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cscope_search --  *	Search a file for a cscope entry.  *  * PUBLIC: int cscope_search __P((SCR *, TAGQ *, TAG *));  */
end_comment

begin_function
name|int
name|cscope_search
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|TAGQ
modifier|*
name|tqp
parameter_list|,
name|TAG
modifier|*
name|tp
parameter_list|)
block|{
name|MARK
name|m
decl_stmt|;
comment|/* If we don't have a search pattern, use the line number. */
if|if
condition|(
name|tp
operator|->
name|search
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
name|tp
operator|->
name|slno
argument_list|)
condition|)
block|{
name|tag_msg
argument_list|(
name|sp
argument_list|,
name|TAG_BADLNO
argument_list|,
name|tqp
operator|->
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|m
operator|.
name|lno
operator|=
name|tp
operator|->
name|slno
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Search for the tag; cheap fallback for C functions 		 * if the name is the same but the arguments have changed. 		 */
name|m
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
name|m
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|f_search
argument_list|(
name|sp
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|m
argument_list|,
name|tp
operator|->
name|search
argument_list|,
name|tp
operator|->
name|slen
argument_list|,
name|NULL
argument_list|,
name|SEARCH_CSCOPE
operator||
name|SEARCH_FILE
argument_list|)
condition|)
block|{
name|tag_msg
argument_list|(
name|sp
argument_list|,
name|TAG_SEARCH
argument_list|,
name|tqp
operator|->
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * !!! 		 * Historically, tags set the search direction if it wasn't 		 * already set. 		 */
if|if
condition|(
name|sp
operator|->
name|searchdir
operator|==
name|NOTSET
condition|)
name|sp
operator|->
name|searchdir
operator|=
name|FORWARD
expr_stmt|;
block|}
comment|/* 	 * !!! 	 * Tags move to the first non-blank, NOT the search pattern start. 	 */
name|sp
operator|->
name|lno
operator|=
name|m
operator|.
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|nonblank
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
operator|&
name|sp
operator|->
name|cno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lookup_ccmd --  *	Return a pointer to the command structure.  */
end_comment

begin_function
specifier|static
name|CC
specifier|const
modifier|*
name|lookup_ccmd
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|CC
specifier|const
modifier|*
name|ccp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|ccp
operator|=
name|cscope_cmds
init|;
name|ccp
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|ccp
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|ccp
operator|->
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ccp
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * read_prompt --  *	Read a prompt from cscope.  */
end_comment

begin_function
specifier|static
name|int
name|read_prompt
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|CSC
modifier|*
name|csc
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
define|#
directive|define
name|CSCOPE_PROMPT
value|">> "
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|csc
operator|->
name|from_fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
name|CSCOPE_PROMPT
index|[
literal|0
index|]
condition|)
empty_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|terminate
argument_list|(
name|sp
argument_list|,
name|csc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|getc
argument_list|(
name|csc
operator|->
name|from_fp
argument_list|)
operator|!=
name|CSCOPE_PROMPT
index|[
literal|1
index|]
condition|)
continue|continue;
if|if
condition|(
name|getc
argument_list|(
name|csc
operator|->
name|from_fp
argument_list|)
operator|!=
name|CSCOPE_PROMPT
index|[
literal|2
index|]
condition|)
continue|continue;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

