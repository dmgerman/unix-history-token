begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1992, 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"$Id: ex_append.c,v 10.34 2001/06/25 15:19:14 skimo Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"../common/common.h"
end_include

begin_enum
enum|enum
name|which
block|{
name|APPEND
block|,
name|CHANGE
block|,
name|INSERT
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|int
name|ex_aci
parameter_list|(
name|SCR
modifier|*
parameter_list|,
name|EXCMD
modifier|*
parameter_list|,
name|enum
name|which
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * ex_append -- :[line] a[ppend][!]  *	Append one or more lines of new text after the specified line,  *	or the current line if no address is specified.  *  * PUBLIC: int ex_append(SCR *, EXCMD *);  */
end_comment

begin_function
name|int
name|ex_append
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EXCMD
modifier|*
name|cmdp
parameter_list|)
block|{
return|return
operator|(
name|ex_aci
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|,
name|APPEND
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_change -- :[line[,line]] c[hange][!] [count]  *	Change one or more lines to the input text.  *  * PUBLIC: int ex_change(SCR *, EXCMD *);  */
end_comment

begin_function
name|int
name|ex_change
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EXCMD
modifier|*
name|cmdp
parameter_list|)
block|{
return|return
operator|(
name|ex_aci
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|,
name|CHANGE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_insert -- :[line] i[nsert][!]  *	Insert one or more lines of new text before the specified line,  *	or the current line if no address is specified.  *  * PUBLIC: int ex_insert(SCR *, EXCMD *);  */
end_comment

begin_function
name|int
name|ex_insert
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EXCMD
modifier|*
name|cmdp
parameter_list|)
block|{
return|return
operator|(
name|ex_aci
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|,
name|INSERT
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_aci --  *	Append, change, insert in ex.  */
end_comment

begin_function
specifier|static
name|int
name|ex_aci
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EXCMD
modifier|*
name|cmdp
parameter_list|,
name|enum
name|which
name|cmd
parameter_list|)
block|{
name|CHAR_T
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|TEXTH
name|tiq
index|[]
init|=
block|{
block|{
literal|0
block|}
block|}
decl_stmt|;
name|recno_t
name|cnt
init|=
literal|0
decl_stmt|,
name|lno
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
name|int
name|need_newline
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|NEEDFILE
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|)
expr_stmt|;
comment|/* 	 * If doing a change, replace lines for as long as possible.  Then, 	 * append more lines or delete remaining lines.  Changes to an empty 	 * file are appends, inserts are the same as appends to the previous 	 * line. 	 * 	 * !!! 	 * Set the address to which we'll append.  We set sp->lno to this 	 * address as well so that autoindent works correctly when get text 	 * from the user. 	 */
name|lno
operator|=
name|cmdp
operator|->
name|addr1
operator|.
name|lno
expr_stmt|;
name|sp
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|==
name|CHANGE
operator|||
name|cmd
operator|==
name|INSERT
operator|)
operator|&&
name|lno
operator|!=
literal|0
condition|)
operator|--
name|lno
expr_stmt|;
comment|/* 	 * !!! 	 * If the file isn't empty, cut changes into the unnamed buffer. 	 */
if|if
condition|(
name|cmd
operator|==
name|CHANGE
operator|&&
name|cmdp
operator|->
name|addr1
operator|.
name|lno
operator|!=
literal|0
operator|&&
operator|(
name|cut
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
operator|&
name|cmdp
operator|->
name|addr1
argument_list|,
operator|&
name|cmdp
operator|->
name|addr2
argument_list|,
name|CUT_LINEMODE
argument_list|)
operator|||
name|del
argument_list|(
name|sp
argument_list|,
operator|&
name|cmdp
operator|->
name|addr1
argument_list|,
operator|&
name|cmdp
operator|->
name|addr2
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * !!! 	 * Anything that was left after the command separator becomes part 	 * of the inserted text.  Apparently, it was common usage to enter: 	 * 	 *	:g/pattern/append|stuff1 	 * 	 * and append the line of text "stuff1" to the lines containing the 	 * pattern.  It was also historically legal to enter: 	 * 	 *	:append|stuff1 	 *	stuff2 	 *	. 	 * 	 * and the text on the ex command line would be appended as well as 	 * the text inserted after it.  There was an historic bug however, 	 * that the user had to enter *two* terminating lines (the '.' lines) 	 * to terminate text input mode, in this case.  This whole thing 	 * could be taken too far, however.  Entering: 	 * 	 *	:append|stuff1\ 	 *	stuff2 	 *	stuff3 	 *	. 	 * 	 * i.e. mixing and matching the forms confused the historic vi, and, 	 * not only did it take two terminating lines to terminate text input 	 * mode, but the trailing backslashes were retained on the input.  We 	 * match historic practice except that we discard the backslashes. 	 * 	 * Input lines specified on the ex command line lines are separated by 	 *<newline>s.  If there is a trailing delimiter an empty line was 	 * inserted.  There may also be a leading delimiter, which is ignored 	 * unless it's also a trailing delimiter.  It is possible to encounter 	 * a termination line, i.e. a single '.', in a global command, but not 	 * necessary if the text insert command was the last of the global 	 * commands. 	 */
if|if
condition|(
name|cmdp
operator|->
name|save_cmdlen
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
name|cmdp
operator|->
name|save_cmd
operator|,
name|len
operator|=
name|cmdp
operator|->
name|save_cmdlen
init|;
name|len
operator|>
literal|0
condition|;
name|p
operator|=
name|t
control|)
block|{
for|for
control|(
name|t
operator|=
name|p
init|;
name|len
operator|>
literal|0
operator|&&
name|t
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|;
operator|++
name|t
operator|,
operator|--
name|len
control|)
empty_stmt|;
if|if
condition|(
name|t
operator|!=
name|p
operator|||
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX_GLOBAL
argument_list|)
operator|&&
name|t
operator|-
name|p
operator|==
literal|1
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
operator|++
name|t
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
operator|--
name|len
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|db_append
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|,
name|lno
operator|++
argument_list|,
name|p
argument_list|,
name|t
operator|-
name|p
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
operator|++
name|t
expr_stmt|;
if|if
condition|(
operator|--
name|len
operator|==
literal|0
operator|&&
name|db_append
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|,
name|lno
operator|++
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 		 * If there's any remaining text, we're in a global, and 		 * there's more command to parse. 		 * 		 * !!! 		 * We depend on the fact that non-global commands will eat the 		 * rest of the command line as text input, and before getting 		 * any text input from the user.  Otherwise, we'd have to save 		 * off the command text before or during the call to the text 		 * input function below. 		 */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|cmdp
operator|->
name|save_cmd
operator|=
name|t
expr_stmt|;
name|cmdp
operator|->
name|save_cmdlen
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX_GLOBAL
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|lno
operator|=
name|lno
operator|)
operator|==
literal|0
operator|&&
name|db_exist
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
condition|)
name|sp
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If not in a global command, read from the terminal. 	 * 	 * If this code is called by vi, we want to reset the terminal and use 	 * ex's line get routine.  It actually works fine if we use vi's get 	 * routine, but it doesn't look as nice.  Maybe if we had a separate 	 * window or something, but getting a line at a time looks awkward. 	 * However, depending on the screen that we're using, that may not 	 * be possible. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_VI
argument_list|)
condition|)
block|{
if|if
condition|(
name|gp
operator|->
name|scr_screen
argument_list|(
name|sp
argument_list|,
name|SC_EX
argument_list|)
condition|)
block|{
name|ex_wemsg
argument_list|(
name|sp
argument_list|,
name|cmdp
operator|->
name|cmd
operator|->
name|name
argument_list|,
name|EXM_NOCANON
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* If we're still in the vi screen, move out explicitly. */
name|need_newline
operator|=
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EXWROTE
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EX
operator||
name|SC_SCR_EXWROTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_newline
condition|)
operator|(
name|void
operator|)
name|ex_puts
argument_list|(
name|sp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 		 * !!! 		 * Users of historical versions of vi sometimes get confused 		 * when they enter append mode, and can't seem to get out of 		 * it.  Give them an informational message. 		 */
operator|(
name|void
operator|)
name|ex_puts
argument_list|(
name|sp
argument_list|,
name|msg_cat
argument_list|(
name|sp
argument_list|,
literal|"273|Entering ex input mode."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ex_puts
argument_list|(
name|sp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ex_fflush
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set input flags; the ! flag turns off autoindent for append, 	 * change and insert. 	 */
name|LF_INIT
argument_list|(
name|TXT_DOTTERM
operator||
name|TXT_NUMBER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FL_ISSET
argument_list|(
name|cmdp
operator|->
name|iflags
argument_list|,
name|E_C_FORCE
argument_list|)
operator|&&
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_AUTOINDENT
argument_list|)
condition|)
name|LF_SET
argument_list|(
name|TXT_AUTOINDENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_BEAUTIFY
argument_list|)
condition|)
name|LF_SET
argument_list|(
name|TXT_BEAUTIFY
argument_list|)
expr_stmt|;
comment|/* 	 * This code can't use the common screen TEXTH structure (sp->tiq), 	 * as it may already be in use, e.g. ":append|s/abc/ABC/" would fail 	 * as we are only halfway through the text when the append code fires. 	 * Use a local structure instead.  (The ex code would have to use a 	 * local structure except that we're guaranteed to finish remaining 	 * characters in the common TEXTH structure when they were inserted 	 * into the file, above.) 	 */
name|TAILQ_INIT
argument_list|(
name|tiq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex_txt
argument_list|(
name|sp
argument_list|,
name|tiq
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|TAILQ_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|tiq
argument_list|,
argument|q
argument_list|)
block|{
if|if
condition|(
name|db_append
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|,
name|lno
operator|++
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|len
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|++
name|cnt
expr_stmt|;
block|}
comment|/* 	 * Set sp->lno to the final line number value (correcting for a 	 * possible 0 value) as that's historically correct for the final 	 * line value, whether or not the user entered any text. 	 */
if|if
condition|(
operator|(
name|sp
operator|->
name|lno
operator|=
name|lno
operator|)
operator|==
literal|0
operator|&&
name|db_exist
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
condition|)
name|sp
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

