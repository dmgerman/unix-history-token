begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1992, 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"$Id: ex_subst.c,v 10.53 2011/12/21 20:40:35 zy Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"../common/common.h"
end_include

begin_include
include|#
directive|include
file|"../vi/vi.h"
end_include

begin_define
define|#
directive|define
name|SUB_FIRST
value|0x01
end_define

begin_comment
comment|/* The 'r' flag isn't reasonable. */
end_comment

begin_define
define|#
directive|define
name|SUB_MUSTSETR
value|0x02
end_define

begin_comment
comment|/* The 'r' flag is required. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|re_conv
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|CHAR_T
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|re_cscope_conv
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|CHAR_T
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|re_sub
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|CHAR_T
operator|*
operator|,
name|CHAR_T
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|,
name|size_t
operator|*
operator|,
name|regmatch_t
index|[
literal|10
index|]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|re_tag_conv
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|CHAR_T
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|s
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXCMD
operator|*
operator|,
name|CHAR_T
operator|*
operator|,
name|regex_t
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ex_s --  *	[line [,line]] s[ubstitute] [[/;]pat[/;]/repl[/;] [cgr] [count] [#lp]]  *  *	Substitute on lines matching a pattern.  *  * PUBLIC: int ex_s __P((SCR *, EXCMD *));  */
end_comment

begin_function
name|int
name|ex_s
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EXCMD
modifier|*
name|cmdp
parameter_list|)
block|{
name|regex_t
modifier|*
name|re
decl_stmt|;
name|size_t
name|blen
decl_stmt|,
name|len
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
name|int
name|delim
decl_stmt|;
name|CHAR_T
modifier|*
name|bp
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|ptrn
decl_stmt|,
modifier|*
name|rep
decl_stmt|,
modifier|*
name|t
decl_stmt|;
comment|/* 	 * Skip leading white space. 	 * 	 * !!! 	 * Historic vi allowed any non-alphanumeric to serve as the 	 * substitution command delimiter. 	 * 	 * !!! 	 * If the arguments are empty, it's the same as&, i.e. we 	 * repeat the last substitution. 	 */
if|if
condition|(
name|cmdp
operator|->
name|argc
operator|==
literal|0
condition|)
goto|goto
name|subagain
goto|;
for|for
control|(
name|p
operator|=
name|cmdp
operator|->
name|argv
index|[
literal|0
index|]
operator|->
name|bp
operator|,
name|len
operator|=
name|cmdp
operator|->
name|argv
index|[
literal|0
index|]
operator|->
name|len
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
operator|,
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|!
name|cmdskip
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|subagain
label|:
return|return
operator|(
name|ex_subagain
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|)
operator|)
return|;
name|delim
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|delim
argument_list|)
operator|||
name|isalnum
argument_list|(
name|delim
argument_list|)
operator|||
name|delim
operator|==
literal|'\\'
condition|)
return|return
operator|(
name|s
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|,
name|p
argument_list|,
operator|&
name|sp
operator|->
name|subre_c
argument_list|,
name|SUB_MUSTSETR
argument_list|)
operator|)
return|;
comment|/* 	 * !!! 	 * The full-blown substitute command reset the remembered 	 * state of the 'c' and 'g' suffices. 	 */
name|sp
operator|->
name|c_suffix
operator|=
name|sp
operator|->
name|g_suffix
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Get the pattern string, toss escaping characters. 	 * 	 * !!! 	 * Historic vi accepted any of the following forms: 	 * 	 *	:s/abc/def/		change "abc" to "def" 	 *	:s/abc/def		change "abc" to "def" 	 *	:s/abc/			delete "abc" 	 *	:s/abc			delete "abc" 	 * 	 * QUOTING NOTE: 	 * 	 * Only toss an escaping character if it escapes a delimiter. 	 * This means that "s/A/\\\\f" replaces "A" with "\\f".  It 	 * would be nice to be more regular, i.e. for each layer of 	 * escaping a single escaping character is removed, but that's 	 * not how the historic vi worked. 	 */
for|for
control|(
name|ptrn
operator|=
name|t
operator|=
name|p
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
literal|0
index|]
operator|==
name|delim
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
name|delim
condition|)
operator|++
name|p
expr_stmt|;
comment|/* 			 * !!! 			 * Nul terminate the pattern string -- it's passed 			 * to regcomp which doesn't understand anything else. 			 */
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
name|delim
condition|)
operator|++
name|p
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\\'
condition|)
operator|*
name|t
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|t
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
comment|/* 	 * If the pattern string is empty, use the last RE (not just the 	 * last substitution RE). 	 */
if|if
condition|(
operator|*
name|ptrn
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|re
operator|==
name|NULL
condition|)
block|{
name|ex_emsg
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|EXM_NOPREVRE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Re-compile the RE if necessary. */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_RE_SEARCH
argument_list|)
operator|&&
name|re_compile
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|re
argument_list|,
name|sp
operator|->
name|re_len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sp
operator|->
name|re_c
argument_list|,
name|RE_C_SEARCH
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|flags
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * !!! 		 * Compile the RE.  Historic practice is that substitutes set 		 * the search direction as well as both substitute and search 		 * RE's.  We compile the RE twice, as we don't want to bother 		 * ref counting the pattern string and (opaque) structure. 		 */
if|if
condition|(
name|re_compile
argument_list|(
name|sp
argument_list|,
name|ptrn
argument_list|,
name|t
operator|-
name|ptrn
argument_list|,
operator|&
name|sp
operator|->
name|re
argument_list|,
operator|&
name|sp
operator|->
name|re_len
argument_list|,
operator|&
name|sp
operator|->
name|re_c
argument_list|,
name|RE_C_SEARCH
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|re_compile
argument_list|(
name|sp
argument_list|,
name|ptrn
argument_list|,
name|t
operator|-
name|ptrn
argument_list|,
operator|&
name|sp
operator|->
name|subre
argument_list|,
operator|&
name|sp
operator|->
name|subre_len
argument_list|,
operator|&
name|sp
operator|->
name|subre_c
argument_list|,
name|RE_C_SUBST
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|flags
operator|=
name|SUB_FIRST
expr_stmt|;
name|sp
operator|->
name|searchdir
operator|=
name|FORWARD
expr_stmt|;
block|}
name|re
operator|=
operator|&
name|sp
operator|->
name|re_c
expr_stmt|;
comment|/* 	 * Get the replacement string. 	 * 	 * The special character& (\& if O_MAGIC not set) matches the 	 * entire RE.  No handling of& is required here, it's done by 	 * re_sub(). 	 * 	 * The special character ~ (\~ if O_MAGIC not set) inserts the 	 * previous replacement string into this replacement string. 	 * Count ~'s to figure out how much space we need.  We could 	 * special case nonexistent last patterns or whether or not 	 * O_MAGIC is set, but it's probably not worth the effort. 	 * 	 * QUOTING NOTE: 	 * 	 * Only toss an escaping character if it escapes a delimiter or 	 * if O_MAGIC is set and it escapes a tilde. 	 * 	 * !!! 	 * If the entire replacement pattern is "%", then use the last 	 * replacement pattern.  This semantic was added to vi in System 	 * V and then percolated elsewhere, presumably around the time 	 * that it was added to their version of ed(1). 	 */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
literal|0
index|]
operator|==
name|delim
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
name|delim
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|repl
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sp
operator|->
name|repl
argument_list|)
expr_stmt|;
name|sp
operator|->
name|repl
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|repl_len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
literal|1
index|]
operator|==
name|delim
operator|)
condition|)
name|p
operator|+=
name|p
index|[
literal|1
index|]
operator|==
name|delim
condition|?
literal|2
else|:
literal|1
expr_stmt|;
else|else
block|{
for|for
control|(
name|rep
operator|=
name|p
operator|,
name|len
operator|=
literal|0
init|;
name|p
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|p
index|[
literal|0
index|]
operator|!=
name|delim
condition|;
operator|++
name|p
operator|,
operator|++
name|len
control|)
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
name|len
operator|+=
name|sp
operator|->
name|repl_len
expr_stmt|;
name|GET_SPACE_RETW
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|bp
operator|,
name|len
operator|=
literal|0
operator|,
name|p
operator|=
name|rep
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
literal|0
index|]
operator|==
name|delim
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
name|delim
condition|)
operator|++
name|p
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
name|delim
condition|)
operator|++
name|p
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|t
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'~'
condition|)
block|{
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_MAGIC
argument_list|)
condition|)
goto|goto
name|tilde
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'~'
operator|&&
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_MAGIC
argument_list|)
condition|)
block|{
name|tilde
label|:
operator|++
name|p
expr_stmt|;
name|MEMCPY
argument_list|(
name|t
argument_list|,
name|sp
operator|->
name|repl
argument_list|,
name|sp
operator|->
name|repl_len
argument_list|)
expr_stmt|;
name|t
operator|+=
name|sp
operator|->
name|repl_len
expr_stmt|;
name|len
operator|+=
name|sp
operator|->
name|repl_len
expr_stmt|;
continue|continue;
block|}
operator|*
name|t
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|repl_len
operator|=
name|len
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|repl
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sp
operator|->
name|repl
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|repl
argument_list|,
name|CHAR_T
operator|*
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|CHAR_T
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|repl
operator|==
name|NULL
condition|)
block|{
name|FREE_SPACEW
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|MEMCPY
argument_list|(
name|sp
operator|->
name|repl
argument_list|,
name|bp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|FREE_SPACEW
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|s
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|,
name|p
argument_list|,
name|re
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_subagain --  *	[line [,line]]& [cgr] [count] [#lp]]  *  *	Substitute using the last substitute RE and replacement pattern.  *  * PUBLIC: int ex_subagain __P((SCR *, EXCMD *));  */
end_comment

begin_function
name|int
name|ex_subagain
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EXCMD
modifier|*
name|cmdp
parameter_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|subre
operator|==
name|NULL
condition|)
block|{
name|ex_emsg
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|EXM_NOPREVRE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_RE_SUBST
argument_list|)
operator|&&
name|re_compile
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|subre
argument_list|,
name|sp
operator|->
name|subre_len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sp
operator|->
name|subre_c
argument_list|,
name|RE_C_SUBST
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|s
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|,
name|cmdp
operator|->
name|argc
condition|?
name|cmdp
operator|->
name|argv
index|[
literal|0
index|]
operator|->
name|bp
else|:
name|NULL
argument_list|,
operator|&
name|sp
operator|->
name|subre_c
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_subtilde --  *	[line [,line]] ~ [cgr] [count] [#lp]]  *  *	Substitute using the last RE and last substitute replacement pattern.  *  * PUBLIC: int ex_subtilde __P((SCR *, EXCMD *));  */
end_comment

begin_function
name|int
name|ex_subtilde
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EXCMD
modifier|*
name|cmdp
parameter_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|re
operator|==
name|NULL
condition|)
block|{
name|ex_emsg
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|EXM_NOPREVRE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_RE_SEARCH
argument_list|)
operator|&&
name|re_compile
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|re
argument_list|,
name|sp
operator|->
name|re_len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sp
operator|->
name|re_c
argument_list|,
name|RE_C_SEARCH
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|s
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|,
name|cmdp
operator|->
name|argc
condition|?
name|cmdp
operator|->
name|argv
index|[
literal|0
index|]
operator|->
name|bp
else|:
name|NULL
argument_list|,
operator|&
name|sp
operator|->
name|re_c
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * s --  * Do the substitution.  This stuff is *really* tricky.  There are lots of  * special cases, and general nastiness.  Don't mess with it unless you're  * pretty confident.  *   * The nasty part of the substitution is what happens when the replacement  * string contains newlines.  It's a bit tricky -- consider the information  * that has to be retained for "s/f\(o\)o/^M\1^M\1/".  The solution here is  * to build a set of newline offsets which we use to break the line up later,  * when the replacement is done.  Don't change it unless you're *damned*  * confident.  */
end_comment

begin_define
define|#
directive|define
name|NEEDNEWLINE
parameter_list|(
name|sp
parameter_list|)
value|{						\ 	if (sp->newl_len == sp->newl_cnt) {				\ 		sp->newl_len += 25;					\ 		REALLOC(sp, sp->newl, size_t *,				\ 		    sp->newl_len * sizeof(size_t));			\ 		if (sp->newl == NULL) {					\ 			sp->newl_len = 0;				\ 			return (1);					\ 		}							\ 	}								\ }
end_define

begin_define
define|#
directive|define
name|BUILD
parameter_list|(
name|sp
parameter_list|,
name|l
parameter_list|,
name|len
parameter_list|)
value|{						\ 	if (lbclen + (len)> lblen) {					\ 		lblen = p2roundup(MAX(lbclen + (len), 256));		\ 		REALLOC(sp, lb, CHAR_T *, lblen * sizeof(CHAR_T));	\ 		if (lb == NULL) {					\ 			lbclen = 0;					\ 			return (1);					\ 		}							\ 	}								\ 	MEMCPY(lb + lbclen, l, len);					\ 	lbclen += len;							\ }
end_define

begin_define
define|#
directive|define
name|NEEDSP
parameter_list|(
name|sp
parameter_list|,
name|len
parameter_list|,
name|pnt
parameter_list|)
value|{						\ 	if (lbclen + (len)> lblen) {					\ 		lblen = p2roundup(MAX(lbclen + (len), 256));		\ 		REALLOC(sp, lb, CHAR_T *, lblen * sizeof(CHAR_T));	\ 		if (lb == NULL) {					\ 			lbclen = 0;					\ 			return (1);					\ 		}							\ 		pnt = lb + lbclen;					\ 	}								\ }
end_define

begin_function
specifier|static
name|int
name|s
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EXCMD
modifier|*
name|cmdp
parameter_list|,
name|CHAR_T
modifier|*
name|s
parameter_list|,
name|regex_t
modifier|*
name|re
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|EVENT
name|ev
decl_stmt|;
name|MARK
name|from
decl_stmt|,
name|to
decl_stmt|;
name|TEXTH
name|tiq
index|[]
init|=
block|{
block|{
literal|0
block|}
block|}
decl_stmt|;
name|recno_t
name|elno
decl_stmt|,
name|lno
decl_stmt|,
name|slno
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
name|regmatch_t
name|match
index|[
literal|10
index|]
decl_stmt|;
name|size_t
name|blen
decl_stmt|,
name|cnt
decl_stmt|,
name|last
decl_stmt|,
name|lbclen
decl_stmt|,
name|lblen
decl_stmt|,
name|len
decl_stmt|,
name|llen
decl_stmt|;
name|size_t
name|offset
decl_stmt|,
name|saved_offset
decl_stmt|,
name|scno
decl_stmt|;
name|int
name|cflag
decl_stmt|,
name|lflag
decl_stmt|,
name|nflag
decl_stmt|,
name|pflag
decl_stmt|,
name|rflag
decl_stmt|;
name|int
name|didsub
decl_stmt|,
name|do_eol_match
decl_stmt|,
name|eflags
decl_stmt|,
name|empty_ok
decl_stmt|,
name|eval
decl_stmt|;
name|int
name|linechanged
decl_stmt|,
name|matched
decl_stmt|,
name|quit
decl_stmt|,
name|rval
decl_stmt|;
name|CHAR_T
modifier|*
name|bp
decl_stmt|,
modifier|*
name|lb
decl_stmt|;
name|enum
name|nresult
name|nret
decl_stmt|;
name|NEEDFILE
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|)
expr_stmt|;
name|slno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|scno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* 	 * !!! 	 * Historically, the 'g' and 'c' suffices were always toggled as flags, 	 * so ":s/A/B/" was the same as ":s/A/B/ccgg".  If O_EDCOMPATIBLE was 	 * not set, they were initialized to 0 for all substitute commands.  If 	 * O_EDCOMPATIBLE was set, they were initialized to 0 only if the user 	 * specified substitute/replacement patterns (see ex_s()). 	 */
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_EDCOMPATIBLE
argument_list|)
condition|)
name|sp
operator|->
name|c_suffix
operator|=
name|sp
operator|->
name|g_suffix
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Historic vi permitted the '#', 'l' and 'p' options in vi mode, but 	 * it only displayed the last change.  I'd disallow them, but they are 	 * useful in combination with the [v]global commands.  In the current 	 * model the problem is combining them with the 'c' flag -- the screen 	 * would have to flip back and forth between the confirm screen and the 	 * ex print screen, which would be pretty awful.  We do display all 	 * changes, though, for what that's worth. 	 * 	 * !!! 	 * Historic vi was fairly strict about the order of "options", the 	 * count, and "flags".  I'm somewhat fuzzy on the difference between 	 * options and flags, anyway, so this is a simpler approach, and we 	 * just take it them in whatever order the user gives them.  (The ex 	 * usage statement doesn't reflect this.) 	 */
name|cflag
operator|=
name|lflag
operator|=
name|nflag
operator|=
name|pflag
operator|=
name|rflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
goto|goto
name|noargs
goto|;
for|for
control|(
name|lno
operator|=
name|OOBLNO
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
operator|++
name|s
control|)
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
continue|continue;
case|case
literal|'+'
case|:
operator|++
name|cmdp
operator|->
name|flagoff
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
operator|--
name|cmdp
operator|->
name|flagoff
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|lno
operator|!=
name|OOBLNO
condition|)
goto|goto
name|usage
goto|;
name|errno
operator|=
literal|0
expr_stmt|;
name|nret
operator|=
name|nget_uslong
argument_list|(
operator|&
name|ul
argument_list|,
name|s
argument_list|,
operator|&
name|s
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|lno
operator|=
name|ul
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
comment|/* Loop increment correction. */
operator|--
name|s
expr_stmt|;
if|if
condition|(
name|nret
operator|!=
name|NUM_OK
condition|)
block|{
if|if
condition|(
name|nret
operator|==
name|NUM_OVER
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"153|Count overflow"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nret
operator|==
name|NUM_UNDER
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"154|Count underflow"
argument_list|)
expr_stmt|;
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 			 * In historic vi, the count was inclusive from the 			 * second address. 			 */
name|cmdp
operator|->
name|addr1
operator|.
name|lno
operator|=
name|cmdp
operator|->
name|addr2
operator|.
name|lno
expr_stmt|;
name|cmdp
operator|->
name|addr2
operator|.
name|lno
operator|+=
name|lno
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
name|cmdp
operator|->
name|addr2
operator|.
name|lno
argument_list|)
operator|&&
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|cmdp
operator|->
name|addr2
operator|.
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
literal|'#'
case|:
name|nflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|sp
operator|->
name|c_suffix
operator|=
operator|!
name|sp
operator|->
name|c_suffix
expr_stmt|;
comment|/* Ex text structure initialization. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX
argument_list|)
condition|)
name|TAILQ_INIT
argument_list|(
name|tiq
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|sp
operator|->
name|g_suffix
operator|=
operator|!
name|sp
operator|->
name|g_suffix
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|lflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|pflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SUB_FIRST
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"155|Regular expression specified; r flag meaningless"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_RE_SEARCH
argument_list|)
condition|)
block|{
name|ex_emsg
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|EXM_NOPREVRE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rflag
operator|=
literal|1
expr_stmt|;
name|re
operator|=
operator|&
name|sp
operator|->
name|re_c
expr_stmt|;
break|break;
default|default:
goto|goto
name|usage
goto|;
block|}
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|||
operator|(
operator|!
name|rflag
operator|&&
name|LF_ISSET
argument_list|(
name|SUB_MUSTSETR
argument_list|)
operator|)
condition|)
block|{
name|usage
label|:
name|ex_emsg
argument_list|(
name|sp
argument_list|,
name|cmdp
operator|->
name|cmd
operator|->
name|usage
argument_list|,
name|EXM_USAGE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|noargs
label|:
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_VI
argument_list|)
operator|&&
name|sp
operator|->
name|c_suffix
operator|&&
operator|(
name|lflag
operator|||
name|nflag
operator|||
name|pflag
operator|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"156|The #, l and p flags may not be combined with the c flag in vi mode"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * bp:		if interactive, line cache 	 * blen:	if interactive, line cache length 	 * lb:		build buffer pointer. 	 * lbclen:	current length of built buffer. 	 * lblen;	length of build buffer. 	 */
name|bp
operator|=
name|lb
operator|=
name|NULL
expr_stmt|;
name|blen
operator|=
name|lbclen
operator|=
name|lblen
operator|=
literal|0
expr_stmt|;
comment|/* For each line... */
name|lno
operator|=
name|cmdp
operator|->
name|addr1
operator|.
name|lno
operator|==
literal|0
condition|?
literal|1
else|:
name|cmdp
operator|->
name|addr1
operator|.
name|lno
expr_stmt|;
for|for
control|(
name|matched
operator|=
name|quit
operator|=
literal|0
operator|,
name|elno
operator|=
name|cmdp
operator|->
name|addr2
operator|.
name|lno
init|;
operator|!
name|quit
operator|&&
name|lno
operator|<=
name|elno
condition|;
operator|++
name|lno
control|)
block|{
comment|/* Someone's unhappy, time to stop. */
if|if
condition|(
name|INTERRUPTED
argument_list|(
name|sp
argument_list|)
condition|)
break|break;
comment|/* Get the line. */
if|if
condition|(
name|db_get
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|DBG_FATAL
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|llen
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 		 * Make a local copy if doing confirmation -- when calling 		 * the confirm routine we're likely to lose the cached copy. 		 */
if|if
condition|(
name|sp
operator|->
name|c_suffix
condition|)
block|{
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|GET_SPACE_RETW
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
name|llen
argument_list|)
expr_stmt|;
block|}
else|else
name|ADD_SPACE_RETW
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
name|llen
argument_list|)
expr_stmt|;
name|MEMCPY
argument_list|(
name|bp
argument_list|,
name|s
argument_list|,
name|llen
argument_list|)
expr_stmt|;
name|s
operator|=
name|bp
expr_stmt|;
block|}
comment|/* Start searching from the beginning. */
name|offset
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|llen
expr_stmt|;
comment|/* Reset the build buffer offset. */
name|lbclen
operator|=
literal|0
expr_stmt|;
comment|/* Reset empty match flag. */
name|empty_ok
operator|=
literal|1
expr_stmt|;
comment|/* 		 * We don't want to have to do a setline if the line didn't 		 * change -- keep track of whether or not this line changed. 		 * If doing confirmations, don't want to keep setting the 		 * line if change is refused -- keep track of substitutions. 		 */
name|didsub
operator|=
name|linechanged
operator|=
literal|0
expr_stmt|;
comment|/* New line, do an EOL match. */
name|do_eol_match
operator|=
literal|1
expr_stmt|;
comment|/* It's not nul terminated, but we pretend it is. */
name|eflags
operator|=
name|REG_STARTEND
expr_stmt|;
comment|/* 		 * The search area is from s + offset to the EOL. 		 * 		 * Generally, match[0].rm_so is the offset of the start 		 * of the match from the start of the search, and offset 		 * is the offset of the start of the last search. 		 */
name|nextmatch
label|:
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
operator|=
literal|0
expr_stmt|;
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|=
name|len
expr_stmt|;
comment|/* Get the next match. */
name|eval
operator|=
name|regexec
argument_list|(
name|re
argument_list|,
name|s
operator|+
name|offset
argument_list|,
literal|10
argument_list|,
name|match
argument_list|,
name|eflags
argument_list|)
expr_stmt|;
comment|/* 		 * There wasn't a match or if there was an error, deal with 		 * it.  If there was a previous match in this line, resolve 		 * the changes into the database.  Otherwise, just move on. 		 */
if|if
condition|(
name|eval
operator|==
name|REG_NOMATCH
condition|)
goto|goto
name|endmatch
goto|;
if|if
condition|(
name|eval
operator|!=
literal|0
condition|)
block|{
name|re_error
argument_list|(
name|sp
argument_list|,
name|eval
argument_list|,
name|re
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|matched
operator|=
literal|1
expr_stmt|;
comment|/* Only the first search can match an anchored expression. */
name|eflags
operator||=
name|REG_NOTBOL
expr_stmt|;
comment|/* 		 * !!! 		 * It's possible to match 0-length strings -- for example, the 		 * command s;a*;X;, when matched against the string "aabb" will 		 * result in "XbXbX", i.e. the matches are "aa", the space 		 * between the b's and the space between the b's and the end of 		 * the string.  There is a similar space between the beginning 		 * of the string and the a's.  The rule that we use (because vi 		 * historically used it) is that any 0-length match, occurring 		 * immediately after a match, is ignored.  Otherwise, the above 		 * example would have resulted in "XXbXbX".  Another example is 		 * incorrectly using " *" to replace groups of spaces with one 		 * space. 		 * 		 * The way we do this is that if we just had a successful match, 		 * the starting offset does not skip characters, and the match 		 * is empty, ignore the match and move forward.  If there's no 		 * more characters in the string, we were attempting to match 		 * after the last character, so quit. 		 */
if|if
condition|(
operator|!
name|empty_ok
operator|&&
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
operator|==
literal|0
operator|&&
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|==
literal|0
condition|)
block|{
name|empty_ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|endmatch
goto|;
name|BUILD
argument_list|(
name|sp
argument_list|,
name|s
operator|+
name|offset
argument_list|,
literal|1
argument_list|)
operator|++
name|offset
expr_stmt|;
operator|--
name|len
expr_stmt|;
goto|goto
name|nextmatch
goto|;
block|}
comment|/* Confirm change. */
if|if
condition|(
name|sp
operator|->
name|c_suffix
condition|)
block|{
comment|/* 			 * Set the cursor position for confirmation.  Note, 			 * if we matched on a '$', the cursor may be past 			 * the end of line. 			 */
name|from
operator|.
name|lno
operator|=
name|to
operator|.
name|lno
operator|=
name|lno
expr_stmt|;
name|from
operator|.
name|cno
operator|=
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
operator|+
name|offset
expr_stmt|;
name|to
operator|.
name|cno
operator|=
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|+
name|offset
expr_stmt|;
comment|/* 			 * Both ex and vi have to correct for a change before 			 * the first character in the line. 			 */
if|if
condition|(
name|llen
operator|==
literal|0
condition|)
name|from
operator|.
name|cno
operator|=
name|to
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_VI
argument_list|)
condition|)
block|{
comment|/* 				 * Only vi has to correct for a change after 				 * the last character in the line. 				 * 				 * XXX 				 * It would be nice to change the vi code so 				 * that we could display a cursor past EOL. 				 */
if|if
condition|(
name|to
operator|.
name|cno
operator|>=
name|llen
condition|)
name|to
operator|.
name|cno
operator|=
name|llen
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|from
operator|.
name|cno
operator|>=
name|llen
condition|)
name|from
operator|.
name|cno
operator|=
name|llen
operator|-
literal|1
expr_stmt|;
name|sp
operator|->
name|lno
operator|=
name|from
operator|.
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|from
operator|.
name|cno
expr_stmt|;
if|if
condition|(
name|vs_refresh
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|vs_update
argument_list|(
name|sp
argument_list|,
name|msg_cat
argument_list|(
name|sp
argument_list|,
literal|"169|Confirm change? [n]"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|v_event_get
argument_list|(
name|sp
argument_list|,
operator|&
name|ev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
switch|switch
condition|(
name|ev
operator|.
name|e_event
condition|)
block|{
case|case
name|E_CHARACTER
case|:
break|break;
case|case
name|E_EOF
case|:
case|case
name|E_ERR
case|:
case|case
name|E_INTERRUPT
case|:
goto|goto
name|lquit
goto|;
default|default:
name|v_event_err
argument_list|(
name|sp
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
goto|goto
name|lquit
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ex_print
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|,
literal|0
argument_list|)
operator|||
name|ex_scprint
argument_list|(
name|sp
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|)
condition|)
goto|goto
name|lquit
goto|;
if|if
condition|(
name|ex_txt
argument_list|(
name|sp
argument_list|,
name|tiq
argument_list|,
literal|0
argument_list|,
name|TXT_CR
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ev
operator|.
name|e_c
operator|=
name|TAILQ_FIRST
argument_list|(
name|tiq
argument_list|)
operator|->
name|lb
index|[
literal|0
index|]
expr_stmt|;
block|}
switch|switch
condition|(
name|ev
operator|.
name|e_c
condition|)
block|{
case|case
name|CH_YES
case|:
break|break;
default|default:
case|case
name|CH_NO
case|:
name|didsub
operator|=
literal|0
expr_stmt|;
name|BUILD
argument_list|(
name|sp
argument_list|,
name|s
operator|+
name|offset
argument_list|,
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
case|case
name|CH_QUIT
case|:
comment|/* Set the quit/interrupted flags. */
name|lquit
label|:
name|quit
operator|=
literal|1
expr_stmt|;
name|F_SET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_INTERRUPTED
argument_list|)
expr_stmt|;
comment|/* 				 * Resolve any changes, then return to (and 				 * exit from) the main loop. 				 */
goto|goto
name|endmatch
goto|;
block|}
block|}
comment|/* 		 * Set the cursor to the last position changed, converting 		 * from 1-based to 0-based. 		 */
name|sp
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
expr_stmt|;
comment|/* Copy the bytes before the match into the build buffer. */
name|BUILD
argument_list|(
name|sp
argument_list|,
name|s
operator|+
name|offset
argument_list|,
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
argument_list|)
expr_stmt|;
comment|/* Substitute the matching bytes. */
name|didsub
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|re_sub
argument_list|(
name|sp
argument_list|,
name|s
operator|+
name|offset
argument_list|,
operator|&
name|lb
argument_list|,
operator|&
name|lbclen
argument_list|,
operator|&
name|lblen
argument_list|,
name|match
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Set the change flag so we know this line was modified. */
name|linechanged
operator|=
literal|1
expr_stmt|;
comment|/* Move past the matched bytes. */
name|skip
label|:
name|offset
operator|+=
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
expr_stmt|;
name|len
operator|-=
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
expr_stmt|;
comment|/* A match cannot be followed by an empty pattern. */
name|empty_ok
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If doing a global change with confirmation, we have to 		 * update the screen.  The basic idea is to store the line 		 * so the screen update routines can find it, and restart. 		 */
if|if
condition|(
name|didsub
operator|&&
name|sp
operator|->
name|c_suffix
operator|&&
name|sp
operator|->
name|g_suffix
condition|)
block|{
comment|/* 			 * The new search offset will be the end of the 			 * modified line. 			 */
name|saved_offset
operator|=
name|lbclen
expr_stmt|;
comment|/* Copy the rest of the line. */
if|if
condition|(
name|len
condition|)
name|BUILD
argument_list|(
argument|sp
argument_list|,
argument|s + offset
argument_list|,
argument|len
argument_list|)
comment|/* Set the new offset. */
name|offset
operator|=
name|saved_offset
expr_stmt|;
comment|/* Store inserted lines, adjusting the build buffer. */
name|last
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|newl_cnt
condition|)
block|{
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|sp
operator|->
name|newl_cnt
condition|;
operator|++
name|cnt
operator|,
operator|++
name|lno
operator|,
operator|++
name|elno
control|)
block|{
if|if
condition|(
name|db_insert
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|lb
operator|+
name|last
argument_list|,
name|sp
operator|->
name|newl
index|[
name|cnt
index|]
operator|-
name|last
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|last
operator|=
name|sp
operator|->
name|newl
index|[
name|cnt
index|]
operator|+
literal|1
expr_stmt|;
operator|++
name|sp
operator|->
name|rptlines
index|[
name|L_ADDED
index|]
expr_stmt|;
block|}
name|lbclen
operator|-=
name|last
expr_stmt|;
name|offset
operator|-=
name|last
expr_stmt|;
name|sp
operator|->
name|newl_cnt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Store and retrieve the line. */
if|if
condition|(
name|db_set
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|lb
operator|+
name|last
argument_list|,
name|lbclen
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|db_get
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|DBG_FATAL
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|llen
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ADD_SPACE_RETW
argument_list|(
argument|sp
argument_list|,
argument|bp
argument_list|,
argument|blen
argument_list|,
argument|llen
argument_list|)
name|MEMCPY
argument_list|(
name|bp
argument_list|,
name|s
argument_list|,
name|llen
argument_list|)
expr_stmt|;
name|s
operator|=
name|bp
expr_stmt|;
name|len
operator|=
name|llen
operator|-
name|offset
expr_stmt|;
comment|/* Restart the build. */
name|lbclen
operator|=
literal|0
expr_stmt|;
name|BUILD
argument_list|(
name|sp
argument_list|,
name|s
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* 			 * If we haven't already done the after-the-string 			 * match, do one.  Set REG_NOTEOL so the '$' pattern 			 * only matches once. 			 */
if|if
condition|(
operator|!
name|do_eol_match
condition|)
goto|goto
name|endmatch
goto|;
if|if
condition|(
name|offset
operator|==
name|len
condition|)
block|{
name|do_eol_match
operator|=
literal|0
expr_stmt|;
name|eflags
operator||=
name|REG_NOTEOL
expr_stmt|;
block|}
goto|goto
name|nextmatch
goto|;
block|}
comment|/* 		 * If it's a global: 		 * 		 * If at the end of the string, do a test for the after 		 * the string match.  Set REG_NOTEOL so the '$' pattern 		 * only matches once. 		 */
if|if
condition|(
name|sp
operator|->
name|g_suffix
operator|&&
name|do_eol_match
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|do_eol_match
operator|=
literal|0
expr_stmt|;
name|eflags
operator||=
name|REG_NOTEOL
expr_stmt|;
block|}
goto|goto
name|nextmatch
goto|;
block|}
name|endmatch
label|:
if|if
condition|(
operator|!
name|linechanged
condition|)
continue|continue;
comment|/* Copy any remaining bytes into the build buffer. */
if|if
condition|(
name|len
condition|)
name|BUILD
argument_list|(
argument|sp
argument_list|,
argument|s + offset
argument_list|,
argument|len
argument_list|)
comment|/* Store inserted lines, adjusting the build buffer. */
name|last
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|newl_cnt
condition|)
block|{
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|sp
operator|->
name|newl_cnt
condition|;
operator|++
name|cnt
operator|,
operator|++
name|lno
operator|,
operator|++
name|elno
control|)
block|{
if|if
condition|(
name|db_insert
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|lb
operator|+
name|last
argument_list|,
name|sp
operator|->
name|newl
index|[
name|cnt
index|]
operator|-
name|last
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|last
operator|=
name|sp
operator|->
name|newl
index|[
name|cnt
index|]
operator|+
literal|1
expr_stmt|;
operator|++
name|sp
operator|->
name|rptlines
index|[
name|L_ADDED
index|]
expr_stmt|;
block|}
name|lbclen
operator|-=
name|last
expr_stmt|;
name|sp
operator|->
name|newl_cnt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Store the changed line. */
if|if
condition|(
name|db_set
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|lb
operator|+
name|last
argument_list|,
name|lbclen
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Update changed line counter. */
if|if
condition|(
name|sp
operator|->
name|rptlchange
operator|!=
name|lno
condition|)
block|{
name|sp
operator|->
name|rptlchange
operator|=
name|lno
expr_stmt|;
operator|++
name|sp
operator|->
name|rptlines
index|[
name|L_CHANGED
index|]
expr_stmt|;
block|}
comment|/* 		 * !!! 		 * Display as necessary.  Historic practice is to only 		 * display the last line of a line split into multiple 		 * lines. 		 */
if|if
condition|(
name|lflag
operator|||
name|nflag
operator|||
name|pflag
condition|)
block|{
name|from
operator|.
name|lno
operator|=
name|to
operator|.
name|lno
operator|=
name|lno
expr_stmt|;
name|from
operator|.
name|cno
operator|=
name|to
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lflag
condition|)
operator|(
name|void
operator|)
name|ex_print
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|,
name|E_C_LIST
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflag
condition|)
operator|(
name|void
operator|)
name|ex_print
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|,
name|E_C_HASH
argument_list|)
expr_stmt|;
if|if
condition|(
name|pflag
condition|)
operator|(
name|void
operator|)
name|ex_print
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|,
name|E_C_PRINT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * !!! 	 * Historically, vi attempted to leave the cursor at the same place if 	 * the substitution was done at the current cursor position.  Otherwise 	 * it moved it to the first non-blank of the last line changed.  There 	 * were some problems: for example, :s/$/foo/ with the cursor on the 	 * last character of the line left the cursor on the last character, or 	 * the& command with multiple occurrences of the matching string in the 	 * line usually left the cursor in a fairly random position. 	 * 	 * We try to do the same thing, with the exception that if the user is 	 * doing substitution with confirmation, we move to the last line about 	 * which the user was consulted, as opposed to the last line that they 	 * actually changed.  This prevents a screen flash if the user doesn't 	 * change many of the possible lines. 	 */
if|if
condition|(
operator|!
name|sp
operator|->
name|c_suffix
operator|&&
operator|(
name|sp
operator|->
name|lno
operator|!=
name|slno
operator|||
name|sp
operator|->
name|cno
operator|!=
name|scno
operator|)
condition|)
block|{
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|nonblank
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
operator|&
name|sp
operator|->
name|cno
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If not in a global command, and nothing matched, say so. 	 * Else, if none of the lines displayed, put something up. 	 */
name|rval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|matched
condition|)
block|{
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX_GLOBAL
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"157|No match found"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|lflag
operator|&&
operator|!
name|nflag
operator|&&
operator|!
name|pflag
condition|)
name|F_SET
argument_list|(
name|cmdp
argument_list|,
name|E_AUTOPRINT
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
block|{
name|err
label|:
name|rval
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|FREE_SPACEW
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|)
expr_stmt|;
if|if
condition|(
name|lb
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * re_compile --  *	Compile the RE.  *  * PUBLIC: int re_compile __P((SCR *,  * PUBLIC:     CHAR_T *, size_t, CHAR_T **, size_t *, regex_t *, u_int));  */
end_comment

begin_function
name|int
name|re_compile
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|CHAR_T
modifier|*
name|ptrn
parameter_list|,
name|size_t
name|plen
parameter_list|,
name|CHAR_T
modifier|*
modifier|*
name|ptrnp
parameter_list|,
name|size_t
modifier|*
name|lenp
parameter_list|,
name|regex_t
modifier|*
name|rep
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|int
name|reflags
decl_stmt|,
name|replaced
decl_stmt|,
name|rval
decl_stmt|;
name|CHAR_T
modifier|*
name|p
decl_stmt|;
comment|/* Set RE flags. */
name|reflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|RE_C_CSCOPE
operator||
name|RE_C_TAG
argument_list|)
condition|)
block|{
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_EXTENDED
argument_list|)
condition|)
name|reflags
operator||=
name|REG_EXTENDED
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_IGNORECASE
argument_list|)
condition|)
name|reflags
operator||=
name|REG_ICASE
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_ICLOWER
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|=
name|ptrn
operator|,
name|len
operator|=
name|plen
init|;
name|len
operator|>
literal|0
condition|;
operator|++
name|p
operator|,
operator|--
name|len
control|)
if|if
condition|(
name|ISUPPER
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|reflags
operator||=
name|REG_ICASE
expr_stmt|;
block|}
block|}
comment|/* If we're replacing a saved value, clear the old one. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|RE_C_SEARCH
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_RE_SEARCH
argument_list|)
condition|)
block|{
name|regfree
argument_list|(
operator|&
name|sp
operator|->
name|re_c
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_RE_SEARCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LF_ISSET
argument_list|(
name|RE_C_SUBST
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_RE_SUBST
argument_list|)
condition|)
block|{
name|regfree
argument_list|(
operator|&
name|sp
operator|->
name|subre_c
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_RE_SUBST
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we're saving the string, it's a pattern we haven't seen before, 	 * so convert the vi-style RE's to POSIX 1003.2 RE's.  Save a copy for 	 * later recompilation.   Free any previously saved value. 	 */
if|if
condition|(
name|ptrnp
operator|!=
name|NULL
condition|)
block|{
name|replaced
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|RE_C_CSCOPE
argument_list|)
condition|)
block|{
if|if
condition|(
name|re_cscope_conv
argument_list|(
name|sp
argument_list|,
operator|&
name|ptrn
argument_list|,
operator|&
name|plen
argument_list|,
operator|&
name|replaced
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 			 * XXX 			 * Currently, the match-any-<blank> expression used in 			 * re_cscope_conv() requires extended RE's.  This may 			 * not be right or safe. 			 */
name|reflags
operator||=
name|REG_EXTENDED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LF_ISSET
argument_list|(
name|RE_C_TAG
argument_list|)
condition|)
block|{
if|if
condition|(
name|re_tag_conv
argument_list|(
name|sp
argument_list|,
operator|&
name|ptrn
argument_list|,
operator|&
name|plen
argument_list|,
operator|&
name|replaced
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|re_conv
argument_list|(
name|sp
argument_list|,
operator|&
name|ptrn
argument_list|,
operator|&
name|plen
argument_list|,
operator|&
name|replaced
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Discard previous pattern. */
if|if
condition|(
operator|*
name|ptrnp
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|*
name|ptrnp
argument_list|)
expr_stmt|;
operator|*
name|ptrnp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|lenp
operator|!=
name|NULL
condition|)
operator|*
name|lenp
operator|=
name|plen
expr_stmt|;
comment|/* 		 * Copy the string into allocated memory. 		 * 		 * XXX 		 * Regcomp isn't 8-bit clean, so the pattern is nul-terminated 		 * for now.  There's just no other solution.   		 */
name|MALLOC
argument_list|(
name|sp
argument_list|,
operator|*
name|ptrnp
argument_list|,
name|CHAR_T
operator|*
argument_list|,
operator|(
name|plen
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|CHAR_T
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptrnp
operator|!=
name|NULL
condition|)
block|{
name|MEMCPY
argument_list|(
operator|*
name|ptrnp
argument_list|,
name|ptrn
argument_list|,
name|plen
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ptrnp
operator|)
index|[
name|plen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Free up conversion-routine-allocated memory. */
if|if
condition|(
name|replaced
condition|)
name|FREE_SPACEW
argument_list|(
name|sp
argument_list|,
name|ptrn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptrnp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ptrn
operator|=
operator|*
name|ptrnp
expr_stmt|;
block|}
comment|/* 	 * XXX 	 * Regcomp isn't 8-bit clean, so we just lost if the pattern 	 * contained a nul.  Bummer! 	 */
if|if
condition|(
operator|(
name|rval
operator|=
name|regcomp
argument_list|(
name|rep
argument_list|,
name|ptrn
argument_list|,
comment|/* plen, */
name|reflags
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|RE_C_SILENT
argument_list|)
condition|)
name|re_error
argument_list|(
name|sp
argument_list|,
name|rval
argument_list|,
name|rep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|LF_ISSET
argument_list|(
name|RE_C_SEARCH
argument_list|)
condition|)
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_RE_SEARCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|RE_C_SUBST
argument_list|)
condition|)
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_RE_SUBST
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * re_conv --  *	Convert vi's regular expressions into something that the  *	the POSIX 1003.2 RE functions can handle.  *  * There are three conversions we make to make vi's RE's (specifically  * the global, search, and substitute patterns) work with POSIX RE's.  *  * 1: If O_MAGIC is not set, strip backslashes from the magic character  *    set (.[*~) that have them, and add them to the ones that don't.  * 2: If O_MAGIC is not set, the string "\~" is replaced with the text  *    from the last substitute command's replacement string.  If O_MAGIC  *    is set, it's the string "~".  * 3: The pattern \<ptrn\> does "word" searches, convert it to use the  *    new RE escapes.  *  * !!!/XXX  * This doesn't exactly match the historic behavior of vi because we do  * the ~ substitution before calling the RE engine, so magic characters  * in the replacement string will be expanded by the RE engine, and they  * weren't historically.  It's a bug.  */
end_comment

begin_function
specifier|static
name|int
name|re_conv
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|CHAR_T
modifier|*
modifier|*
name|ptrnp
parameter_list|,
name|size_t
modifier|*
name|plenp
parameter_list|,
name|int
modifier|*
name|replacedp
parameter_list|)
block|{
name|size_t
name|blen
decl_stmt|,
name|len
decl_stmt|,
name|needlen
decl_stmt|;
name|int
name|magic
decl_stmt|;
name|CHAR_T
modifier|*
name|bp
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
comment|/* 	 * First pass through, we figure out how much space we'll need. 	 * We do it in two passes, on the grounds that most of the time 	 * the user is doing a search and won't have magic characters. 	 * That way we can skip most of the memory allocation and copies. 	 */
name|magic
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|ptrnp
operator|,
name|len
operator|=
operator|*
name|plenp
operator|,
name|needlen
operator|=
literal|0
init|;
name|len
operator|>
literal|0
condition|;
operator|++
name|p
operator|,
operator|--
name|len
control|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
operator|--
name|len
expr_stmt|;
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'<'
case|:
name|magic
operator|=
literal|1
expr_stmt|;
name|needlen
operator|+=
name|RE_WSTART_LEN
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|magic
operator|=
literal|1
expr_stmt|;
name|needlen
operator|+=
name|RE_WSTOP_LEN
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_MAGIC
argument_list|)
condition|)
block|{
name|magic
operator|=
literal|1
expr_stmt|;
name|needlen
operator|+=
name|sp
operator|->
name|repl_len
expr_stmt|;
block|}
break|break;
case|case
literal|'.'
case|:
case|case
literal|'['
case|:
case|case
literal|'*'
case|:
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_MAGIC
argument_list|)
condition|)
block|{
name|magic
operator|=
literal|1
expr_stmt|;
name|needlen
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
name|needlen
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
name|needlen
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_MAGIC
argument_list|)
condition|)
block|{
name|magic
operator|=
literal|1
expr_stmt|;
name|needlen
operator|+=
name|sp
operator|->
name|repl_len
expr_stmt|;
block|}
break|break;
case|case
literal|'.'
case|:
case|case
literal|'['
case|:
case|case
literal|'*'
case|:
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_MAGIC
argument_list|)
condition|)
block|{
name|magic
operator|=
literal|1
expr_stmt|;
name|needlen
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
default|default:
name|needlen
operator|+=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|magic
condition|)
block|{
operator|*
name|replacedp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Get enough memory to hold the final pattern. */
operator|*
name|replacedp
operator|=
literal|1
expr_stmt|;
name|GET_SPACE_RETW
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
name|needlen
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|ptrnp
operator|,
name|len
operator|=
operator|*
name|plenp
operator|,
name|t
operator|=
name|bp
init|;
name|len
operator|>
literal|0
condition|;
operator|++
name|p
operator|,
operator|--
name|len
control|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
operator|--
name|len
expr_stmt|;
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'<'
case|:
name|MEMCPY
argument_list|(
name|t
argument_list|,
name|RE_WSTART
argument_list|,
name|RE_WSTART_LEN
argument_list|)
expr_stmt|;
name|t
operator|+=
name|RE_WSTART_LEN
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|MEMCPY
argument_list|(
name|t
argument_list|,
name|RE_WSTOP
argument_list|,
name|RE_WSTOP_LEN
argument_list|)
expr_stmt|;
name|t
operator|+=
name|RE_WSTOP_LEN
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_MAGIC
argument_list|)
condition|)
operator|*
name|t
operator|++
operator|=
literal|'~'
expr_stmt|;
else|else
block|{
name|MEMCPY
argument_list|(
name|t
argument_list|,
name|sp
operator|->
name|repl
argument_list|,
name|sp
operator|->
name|repl_len
argument_list|)
expr_stmt|;
name|t
operator|+=
name|sp
operator|->
name|repl_len
expr_stmt|;
block|}
break|break;
case|case
literal|'.'
case|:
case|case
literal|'['
case|:
case|case
literal|'*'
case|:
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_MAGIC
argument_list|)
condition|)
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
operator|*
name|p
expr_stmt|;
break|break;
default|default:
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
block|}
else|else
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_MAGIC
argument_list|)
condition|)
block|{
name|MEMCPY
argument_list|(
name|t
argument_list|,
name|sp
operator|->
name|repl
argument_list|,
name|sp
operator|->
name|repl_len
argument_list|)
expr_stmt|;
name|t
operator|+=
name|sp
operator|->
name|repl_len
expr_stmt|;
block|}
else|else
operator|*
name|t
operator|++
operator|=
literal|'~'
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
case|case
literal|'['
case|:
case|case
literal|'*'
case|:
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_MAGIC
argument_list|)
condition|)
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
operator|*
name|p
expr_stmt|;
break|break;
default|default:
operator|*
name|t
operator|++
operator|=
operator|*
name|p
expr_stmt|;
break|break;
block|}
operator|*
name|ptrnp
operator|=
name|bp
expr_stmt|;
operator|*
name|plenp
operator|=
name|t
operator|-
name|bp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * re_tag_conv --  *	Convert a tags search path into something that the POSIX  *	1003.2 RE functions can handle.  */
end_comment

begin_function
specifier|static
name|int
name|re_tag_conv
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|CHAR_T
modifier|*
modifier|*
name|ptrnp
parameter_list|,
name|size_t
modifier|*
name|plenp
parameter_list|,
name|int
modifier|*
name|replacedp
parameter_list|)
block|{
name|size_t
name|blen
decl_stmt|,
name|len
decl_stmt|;
name|int
name|lastdollar
decl_stmt|;
name|CHAR_T
modifier|*
name|bp
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|len
operator|=
operator|*
name|plenp
expr_stmt|;
comment|/* Max memory usage is 2 times the length of the string. */
operator|*
name|replacedp
operator|=
literal|1
expr_stmt|;
name|GET_SPACE_RETW
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
name|len
operator|*
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|ptrnp
expr_stmt|;
name|t
operator|=
name|bp
expr_stmt|;
comment|/* If the last character is a '/' or '?', we just strip it. */
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
operator|(
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'?'
operator|)
condition|)
operator|--
name|len
expr_stmt|;
comment|/* If the next-to-last or last character is a '$', it's magic. */
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'$'
condition|)
block|{
operator|--
name|len
expr_stmt|;
name|lastdollar
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|lastdollar
operator|=
literal|0
expr_stmt|;
comment|/* If the first character is a '/' or '?', we just strip it. */
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'?'
operator|)
condition|)
block|{
operator|++
name|p
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
comment|/* If the first or second character is a '^', it's magic. */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'^'
condition|)
block|{
operator|*
name|t
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
comment|/* 	 * Escape every other magic character we can find, meanwhile stripping 	 * the backslashes ctags inserts when escaping the search delimiter 	 * characters. 	 */
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'?'
operator|)
condition|)
block|{
operator|++
name|p
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STRCHR
argument_list|(
name|L
argument_list|(
literal|"^.[]$*"
argument_list|)
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|)
condition|)
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lastdollar
condition|)
operator|*
name|t
operator|++
operator|=
literal|'$'
expr_stmt|;
operator|*
name|ptrnp
operator|=
name|bp
expr_stmt|;
operator|*
name|plenp
operator|=
name|t
operator|-
name|bp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * re_cscope_conv --  *	 Convert a cscope search path into something that the POSIX  *      1003.2 RE functions can handle.  */
end_comment

begin_function
specifier|static
name|int
name|re_cscope_conv
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|CHAR_T
modifier|*
modifier|*
name|ptrnp
parameter_list|,
name|size_t
modifier|*
name|plenp
parameter_list|,
name|int
modifier|*
name|replacedp
parameter_list|)
block|{
name|size_t
name|blen
decl_stmt|,
name|len
decl_stmt|,
name|nspaces
decl_stmt|;
name|CHAR_T
modifier|*
name|bp
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|CHAR_T
modifier|*
name|p
decl_stmt|;
name|CHAR_T
modifier|*
name|wp
decl_stmt|;
name|size_t
name|wlen
decl_stmt|;
comment|/* 	 * Each space in the source line printed by cscope represents an 	 * arbitrary sequence of spaces, tabs, and comments. 	 */
define|#
directive|define
name|CSCOPE_RE_SPACE
value|"([ \t]|/\\*([^*]|\\*/)*\\*/)*"
define|#
directive|define
name|CSCOPE_LEN
value|sizeof(CSCOPE_RE_SPACE) - 1
name|CHAR2INT
argument_list|(
name|sp
argument_list|,
name|CSCOPE_RE_SPACE
argument_list|,
name|CSCOPE_LEN
argument_list|,
name|wp
argument_list|,
name|wlen
argument_list|)
expr_stmt|;
for|for
control|(
name|nspaces
operator|=
literal|0
operator|,
name|p
operator|=
operator|*
name|ptrnp
operator|,
name|len
operator|=
operator|*
name|plenp
init|;
name|len
operator|>
literal|0
condition|;
operator|++
name|p
operator|,
operator|--
name|len
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
operator|++
name|nspaces
expr_stmt|;
comment|/* 	 * Allocate plenty of space: 	 *	the string, plus potential escaping characters; 	 *	nspaces + 2 copies of CSCOPE_RE_SPACE; 	 *	^, $, nul terminator characters. 	 */
operator|*
name|replacedp
operator|=
literal|1
expr_stmt|;
name|len
operator|=
operator|(
name|p
operator|-
operator|*
name|ptrnp
operator|)
operator|*
literal|2
operator|+
operator|(
name|nspaces
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|CSCOPE_RE_SPACE
argument_list|)
operator|+
literal|3
expr_stmt|;
name|GET_SPACE_RETW
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|ptrnp
expr_stmt|;
name|t
operator|=
name|bp
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'^'
expr_stmt|;
name|MEMCPY
argument_list|(
name|t
argument_list|,
name|wp
argument_list|,
name|wlen
argument_list|)
expr_stmt|;
name|t
operator|+=
name|wlen
expr_stmt|;
for|for
control|(
name|len
operator|=
operator|*
name|plenp
init|;
name|len
operator|>
literal|0
condition|;
operator|++
name|p
operator|,
operator|--
name|len
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
block|{
name|MEMCPY
argument_list|(
name|t
argument_list|,
name|wp
argument_list|,
name|wlen
argument_list|)
expr_stmt|;
name|t
operator|+=
name|wlen
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|STRCHR
argument_list|(
name|L
argument_list|(
literal|"\\^.[]$*+?()|{}"
argument_list|)
argument_list|,
operator|*
name|p
argument_list|)
condition|)
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
name|MEMCPY
argument_list|(
name|t
argument_list|,
name|wp
argument_list|,
name|wlen
argument_list|)
expr_stmt|;
name|t
operator|+=
name|wlen
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'$'
expr_stmt|;
operator|*
name|ptrnp
operator|=
name|bp
expr_stmt|;
operator|*
name|plenp
operator|=
name|t
operator|-
name|bp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * re_error --  *	Report a regular expression error.  *  * PUBLIC: void re_error __P((SCR *, int, regex_t *));  */
end_comment

begin_function
name|void
name|re_error
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|int
name|errcode
parameter_list|,
name|regex_t
modifier|*
name|preg
parameter_list|)
block|{
name|size_t
name|s
decl_stmt|;
name|char
modifier|*
name|oe
decl_stmt|;
name|s
operator|=
name|regerror
argument_list|(
name|errcode
argument_list|,
name|preg
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|sp
argument_list|,
name|oe
argument_list|,
name|char
operator|*
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|oe
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|regerror
argument_list|(
name|errcode
argument_list|,
name|preg
argument_list|,
name|oe
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"RE error: %s"
argument_list|,
name|oe
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oe
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * re_sub --  * 	Do the substitution for a regular expression.  */
end_comment

begin_function
specifier|static
name|int
name|re_sub
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|CHAR_T
modifier|*
name|ip
parameter_list|,
comment|/* Input line. */
name|CHAR_T
modifier|*
modifier|*
name|lbp
parameter_list|,
name|size_t
modifier|*
name|lbclenp
parameter_list|,
name|size_t
modifier|*
name|lblenp
parameter_list|,
name|regmatch_t
name|match
index|[
literal|10
index|]
parameter_list|)
block|{
enum|enum
block|{
name|C_NOTSET
block|,
name|C_LOWER
block|,
name|C_ONELOWER
block|,
name|C_ONEUPPER
block|,
name|C_UPPER
block|}
name|conv
enum|;
name|size_t
name|lbclen
decl_stmt|,
name|lblen
decl_stmt|;
comment|/* Local copies. */
name|size_t
name|mlen
decl_stmt|;
comment|/* Match length. */
name|size_t
name|rpl
decl_stmt|;
comment|/* Remaining replacement length. */
name|CHAR_T
modifier|*
name|rp
decl_stmt|;
comment|/* Replacement pointer. */
name|int
name|ch
decl_stmt|;
name|int
name|no
decl_stmt|;
comment|/* Match replacement offset. */
name|CHAR_T
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
comment|/* Buffer pointers. */
name|CHAR_T
modifier|*
name|lb
decl_stmt|;
comment|/* Local copies. */
name|lb
operator|=
operator|*
name|lbp
expr_stmt|;
comment|/* Get local copies. */
name|lbclen
operator|=
operator|*
name|lbclenp
expr_stmt|;
name|lblen
operator|=
operator|*
name|lblenp
expr_stmt|;
comment|/* 	 * QUOTING NOTE: 	 * 	 * There are some special sequences that vi provides in the 	 * replacement patterns. 	 *& string the RE matched (\& if nomagic set) 	 *	\# n-th regular subexpression 	 *	\E end \U, \L conversion 	 *	\e end \U, \L conversion 	 *	\l convert the next character to lower-case 	 *	\L convert to lower-case, until \E, \e, or end of replacement 	 *	\u convert the next character to upper-case 	 *	\U convert to upper-case, until \E, \e, or end of replacement 	 * 	 * Otherwise, since this is the lowest level of replacement, discard 	 * all escaping characters.  This (hopefully) matches historic practice. 	 */
define|#
directive|define
name|OUTCH
parameter_list|(
name|ch
parameter_list|,
name|nltrans
parameter_list|)
value|{						\ 	ARG_CHAR_T __ch = (ch);						\ 	e_key_t __value = KEY_VAL(sp, __ch);				\ 	if (nltrans&& (__value == K_CR || __value == K_NL)) {		\ 		NEEDNEWLINE(sp);					\ 		sp->newl[sp->newl_cnt++] = lbclen;			\ 	} else if (conv != C_NOTSET) {					\ 		switch (conv) {						\ 		case C_ONELOWER:					\ 			conv = C_NOTSET;				\
comment|/* FALLTHROUGH */
value|\ 		case C_LOWER:						\ 			if (ISUPPER(__ch))				\ 				__ch = TOLOWER(__ch);			\ 			break;						\ 		case C_ONEUPPER:					\ 			conv = C_NOTSET;				\
comment|/* FALLTHROUGH */
value|\ 		case C_UPPER:						\ 			if (ISLOWER(__ch))				\ 				__ch = TOUPPER(__ch);			\ 			break;						\ 		default:						\ 			abort();					\ 		}							\ 	}								\ 	NEEDSP(sp, 1, p);						\ 	*p++ = __ch;							\ 	++lbclen;							\ }
name|conv
operator|=
name|C_NOTSET
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|sp
operator|->
name|repl
operator|,
name|rpl
operator|=
name|sp
operator|->
name|repl_len
operator|,
name|p
operator|=
name|lb
operator|+
name|lbclen
init|;
name|rpl
operator|--
condition|;
control|)
block|{
switch|switch
condition|(
name|ch
operator|=
operator|*
name|rp
operator|++
condition|)
block|{
case|case
literal|'&'
case|:
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_MAGIC
argument_list|)
condition|)
block|{
name|no
operator|=
literal|0
expr_stmt|;
goto|goto
name|subzero
goto|;
block|}
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|rpl
operator|==
literal|0
condition|)
break|break;
operator|--
name|rpl
expr_stmt|;
switch|switch
condition|(
name|ch
operator|=
operator|*
name|rp
condition|)
block|{
case|case
literal|'&'
case|:
operator|++
name|rp
expr_stmt|;
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_MAGIC
argument_list|)
condition|)
block|{
name|no
operator|=
literal|0
expr_stmt|;
goto|goto
name|subzero
goto|;
block|}
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|no
operator|=
operator|*
name|rp
operator|++
operator|-
literal|'0'
expr_stmt|;
name|subzero
label|:
if|if
condition|(
name|match
index|[
name|no
index|]
operator|.
name|rm_so
operator|==
operator|-
literal|1
operator|||
name|match
index|[
name|no
index|]
operator|.
name|rm_eo
operator|==
operator|-
literal|1
condition|)
break|break;
name|mlen
operator|=
name|match
index|[
name|no
index|]
operator|.
name|rm_eo
operator|-
name|match
index|[
name|no
index|]
operator|.
name|rm_so
expr_stmt|;
for|for
control|(
name|t
operator|=
name|ip
operator|+
name|match
index|[
name|no
index|]
operator|.
name|rm_so
init|;
name|mlen
operator|--
condition|;
operator|++
name|t
control|)
name|OUTCH
argument_list|(
operator|*
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
operator|++
name|rp
expr_stmt|;
name|conv
operator|=
name|C_NOTSET
expr_stmt|;
continue|continue;
case|case
literal|'l'
case|:
operator|++
name|rp
expr_stmt|;
name|conv
operator|=
name|C_ONELOWER
expr_stmt|;
continue|continue;
case|case
literal|'L'
case|:
operator|++
name|rp
expr_stmt|;
name|conv
operator|=
name|C_LOWER
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
operator|++
name|rp
expr_stmt|;
name|conv
operator|=
name|C_ONEUPPER
expr_stmt|;
continue|continue;
case|case
literal|'U'
case|:
operator|++
name|rp
expr_stmt|;
name|conv
operator|=
name|C_UPPER
expr_stmt|;
continue|continue;
case|case
literal|'\r'
case|:
name|OUTCH
argument_list|(
name|ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
default|default:
operator|++
name|rp
expr_stmt|;
break|break;
block|}
block|}
name|OUTCH
argument_list|(
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|lbp
operator|=
name|lb
expr_stmt|;
comment|/* Update caller's information. */
operator|*
name|lbclenp
operator|=
name|lbclen
expr_stmt|;
operator|*
name|lblenp
operator|=
name|lblen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

