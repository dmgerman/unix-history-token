begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"$Id: ex_util.c,v 10.32 2001/06/25 15:19:21 skimo Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"../common/common.h"
end_include

begin_comment
comment|/*  * ex_cinit --  *	Create an EX command structure.  *  * PUBLIC: void ex_cinit __P((SCR *, EXCMD *, int, int, recno_t, recno_t, int));  */
end_comment

begin_function
name|void
name|ex_cinit
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EXCMD
modifier|*
name|cmdp
parameter_list|,
name|int
name|cmd_id
parameter_list|,
name|int
name|naddr
parameter_list|,
name|recno_t
name|lno1
parameter_list|,
name|recno_t
name|lno2
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|memset
argument_list|(
name|cmdp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|EXCMD
argument_list|)
argument_list|)
expr_stmt|;
name|cmdp
operator|->
name|cmd
operator|=
operator|&
name|cmds
index|[
name|cmd_id
index|]
expr_stmt|;
name|cmdp
operator|->
name|addrcnt
operator|=
name|naddr
expr_stmt|;
name|cmdp
operator|->
name|addr1
operator|.
name|lno
operator|=
name|lno1
expr_stmt|;
name|cmdp
operator|->
name|addr2
operator|.
name|lno
operator|=
name|lno2
expr_stmt|;
name|cmdp
operator|->
name|addr1
operator|.
name|cno
operator|=
name|cmdp
operator|->
name|addr2
operator|.
name|cno
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|force
condition|)
name|cmdp
operator|->
name|iflags
operator||=
name|E_C_FORCE
expr_stmt|;
operator|(
name|void
operator|)
name|argv_init
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ex_getline --  *	Return a line from the file.  *  * PUBLIC: int ex_getline __P((SCR *, FILE *, size_t *));  */
end_comment

begin_function
name|int
name|ex_getline
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|size_t
modifier|*
name|lenp
parameter_list|)
block|{
name|EX_PRIVATE
modifier|*
name|exp
decl_stmt|;
name|size_t
name|off
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|exp
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
for|for
control|(
name|errno
operator|=
literal|0
operator|,
name|off
operator|=
literal|0
operator|,
name|p
operator|=
name|exp
operator|->
name|ibp
init|;
condition|;
control|)
block|{
if|if
condition|(
name|off
operator|>=
name|exp
operator|->
name|ibp_len
condition|)
block|{
name|BINC_RETC
argument_list|(
name|sp
argument_list|,
name|exp
operator|->
name|ibp
argument_list|,
name|exp
operator|->
name|ibp_len
argument_list|,
name|off
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|exp
operator|->
name|ibp
operator|+
name|off
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
name|EOF
operator|&&
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|clearerr
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ch
operator|==
name|EOF
operator|||
name|ch
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
name|EOF
operator|&&
operator|!
name|off
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|*
name|lenp
operator|=
name|off
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
operator|++
name|off
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * ex_ncheck --  *	Check for more files to edit.  *  * PUBLIC: int ex_ncheck __P((SCR *, int));  */
end_comment

begin_function
name|int
name|ex_ncheck
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
comment|/* 	 * !!! 	 * Historic practice: quit! or two quit's done in succession 	 * (where ZZ counts as a quit) didn't check for other files. 	 */
if|if
condition|(
operator|!
name|force
operator|&&
name|sp
operator|->
name|ccnt
operator|!=
name|sp
operator|->
name|q_ccnt
operator|+
literal|1
operator|&&
name|sp
operator|->
name|cargv
operator|!=
name|NULL
operator|&&
name|sp
operator|->
name|cargv
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|->
name|q_ccnt
operator|=
name|sp
operator|->
name|ccnt
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|sp
operator|->
name|cargv
operator|+
literal|1
init|;
operator|*
name|ap
operator|!=
name|NULL
condition|;
operator|++
name|ap
control|)
empty_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"167|%d more files to edit"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ap
operator|-
name|sp
operator|->
name|cargv
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_init --  *	Init the screen for ex.  *  * PUBLIC: int ex_init __P((SCR *));  */
end_comment

begin_function
name|int
name|ex_init
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
if|if
condition|(
name|gp
operator|->
name|scr_screen
argument_list|(
name|sp
argument_list|,
name|SC_EX
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_attr
argument_list|(
name|sp
argument_list|,
name|SA_ALTERNATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sp
operator|->
name|rows
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_LINES
argument_list|)
expr_stmt|;
name|sp
operator|->
name|cols
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_COLUMNS
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_VI
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_EX
operator||
name|SC_SCR_EX
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_emsg --  *	Display a few common ex and vi error messages.  *  * PUBLIC: void ex_wemsg __P((SCR *, CHAR_T *, exm_t));  */
end_comment

begin_function
name|void
name|ex_wemsg
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|CHAR_T
modifier|*
name|p
parameter_list|,
name|exm_t
name|which
parameter_list|)
block|{
name|char
modifier|*
name|np
decl_stmt|;
name|size_t
name|nlen
decl_stmt|;
if|if
condition|(
name|p
condition|)
name|INT2CHAR
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|STRLEN
argument_list|(
name|p
argument_list|)
argument_list|,
name|np
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
else|else
name|np
operator|=
name|NULL
expr_stmt|;
name|ex_emsg
argument_list|(
name|sp
argument_list|,
name|np
argument_list|,
name|which
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ex_emsg --  *	Display a few common ex and vi error messages.  *  * PUBLIC: void ex_emsg __P((SCR *, char *, exm_t));  */
end_comment

begin_function
name|void
name|ex_emsg
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|exm_t
name|which
parameter_list|)
block|{
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|EXM_EMPTYBUF
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"168|Buffer %s is empty"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXM_FILECOUNT
case|:
name|msgq_str
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|p
argument_list|,
literal|"144|%s: expanded into too many file names"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXM_NOCANON
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"283|The %s command requires the ex terminal interface"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXM_NOCANON_F
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"272|That form of %s requires the ex terminal interface"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXM_NOFILEYET
case|:
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"274|Command failed, no file read in yet."
argument_list|)
expr_stmt|;
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"173|The %s command requires that a file have already been read in"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXM_NOPREVBUF
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"171|No previous buffer to execute"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXM_NOPREVRE
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"172|No previous regular expression"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXM_NOSUSPEND
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"230|This screen may not be suspended"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXM_SECURE
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"290|The %s command is not supported when the secure edit option is set"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXM_SECURE_F
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"284|That form of %s is not supported when the secure edit option is set"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXM_USAGE
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"174|Usage: %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

end_unit

