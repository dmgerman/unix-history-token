begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1992, 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"$Id: vs_refresh.c,v 10.54 2015/04/08 16:32:49 zy Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"../common/common.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_define
define|#
directive|define
name|UPDATE_CURSOR
value|0x01
end_define

begin_comment
comment|/* Update the cursor. */
end_comment

begin_define
define|#
directive|define
name|UPDATE_SCREEN
value|0x02
end_define

begin_comment
comment|/* Flush to screen. */
end_comment

begin_function_decl
specifier|static
name|void
name|vs_modeline
parameter_list|(
name|SCR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vs_paint
parameter_list|(
name|SCR
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * v_repaint --  *	Repaint selected lines from the screen.  *  * PUBLIC: int vs_repaint(SCR *, EVENT *);  */
end_comment

begin_function
name|int
name|vs_repaint
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EVENT
modifier|*
name|evp
parameter_list|)
block|{
name|SMAP
modifier|*
name|smp
decl_stmt|;
for|for
control|(
init|;
name|evp
operator|->
name|e_flno
operator|<=
name|evp
operator|->
name|e_tlno
condition|;
operator|++
name|evp
operator|->
name|e_flno
control|)
block|{
name|smp
operator|=
name|HMAP
operator|+
name|evp
operator|->
name|e_flno
operator|-
literal|1
expr_stmt|;
name|SMAP_FLUSH
argument_list|(
name|smp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs_line
argument_list|(
name|sp
argument_list|,
name|smp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_refresh --  *	Refresh all screens.  *  * PUBLIC: int vs_refresh(SCR *, int);  */
end_comment

begin_function
name|int
name|vs_refresh
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|int
name|forcepaint
parameter_list|)
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|SCR
modifier|*
name|tsp
decl_stmt|;
name|int
name|need_refresh
init|=
literal|0
decl_stmt|;
name|u_int
name|priv_paint
decl_stmt|,
name|pub_paint
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
comment|/* 	 * 1: Refresh the screen. 	 * 	 * If SC_SCR_REDRAW is set in the current screen, repaint everything 	 * that we can find, including status lines. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REDRAW
argument_list|)
condition|)
name|TAILQ_FOREACH
argument_list|(
argument|tsp
argument_list|,
argument|gp->dq
argument_list|,
argument|q
argument_list|)
if|if
condition|(
name|tsp
operator|!=
name|sp
condition|)
name|F_SET
argument_list|(
name|tsp
argument_list|,
name|SC_SCR_REDRAW
operator||
name|SC_STATUS
argument_list|)
expr_stmt|;
comment|/* 	 * 2: Related or dirtied screens, or screens with messages. 	 * 	 * If related screens share a view into a file, they may have been 	 * modified as well.  Refresh any screens that aren't exiting that 	 * have paint or dirty bits set.  Always update their screens, we 	 * are not likely to get another chance.  Finally, if we refresh any 	 * screens other than the current one, the cursor will be trashed. 	 */
name|pub_paint
operator|=
name|SC_SCR_REFORMAT
operator||
name|SC_SCR_REDRAW
expr_stmt|;
name|priv_paint
operator|=
name|VIP_CUR_INVALID
operator||
name|VIP_N_REFRESH
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_NUMBER
argument_list|)
condition|)
name|priv_paint
operator||=
name|VIP_N_RENUMBER
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tsp
argument_list|,
argument|gp->dq
argument_list|,
argument|q
argument_list|)
if|if
condition|(
name|tsp
operator|!=
name|sp
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|tsp
argument_list|,
name|SC_EXIT
operator||
name|SC_EXIT_FORCE
argument_list|)
operator|&&
operator|(
name|F_ISSET
argument_list|(
name|tsp
argument_list|,
name|pub_paint
argument_list|)
operator|||
name|F_ISSET
argument_list|(
name|VIP
argument_list|(
name|tsp
argument_list|)
argument_list|,
name|priv_paint
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|vs_paint
argument_list|(
name|tsp
argument_list|,
operator|(
name|F_ISSET
argument_list|(
name|VIP
argument_list|(
name|tsp
argument_list|)
argument_list|,
name|VIP_CUR_INVALID
argument_list|)
condition|?
name|UPDATE_CURSOR
else|:
literal|0
operator|)
operator||
name|UPDATE_SCREEN
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|VIP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|VIP_CUR_INVALID
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * 3: Refresh the current screen. 	 * 	 * Always refresh the current screen, it may be a cursor movement. 	 * Also, always do it last -- that way, SC_SCR_REDRAW can be set 	 * in the current screen only, and the screen won't flash. 	 */
if|if
condition|(
name|vs_paint
argument_list|(
name|sp
argument_list|,
name|UPDATE_CURSOR
operator||
operator|(
operator|!
name|forcepaint
operator|&&
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_VI
argument_list|)
operator|&&
name|KEYS_WAITING
argument_list|(
name|sp
argument_list|)
condition|?
literal|0
else|:
name|UPDATE_SCREEN
operator|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * 4: Paint any missing status lines. 	 * 	 * XXX 	 * This is fairly evil.  Status lines are written using the vi message 	 * mechanism, since we have no idea how long they are.  Since we may be 	 * painting screens other than the current one, we don't want to make 	 * the user wait.  We depend heavily on there not being any other lines 	 * currently waiting to be displayed and the message truncation code in 	 * the msgq_status routine working. 	 * 	 * And, finally, if we updated any status lines, make sure the cursor 	 * gets back to where it belongs. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|tsp
argument_list|,
argument|gp->dq
argument_list|,
argument|q
argument_list|)
if|if
condition|(
name|F_ISSET
argument_list|(
name|tsp
argument_list|,
name|SC_STATUS
argument_list|)
condition|)
block|{
name|need_refresh
operator|=
literal|1
expr_stmt|;
name|vs_resolve
argument_list|(
name|tsp
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_refresh
condition|)
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_refresh
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * A side-effect of refreshing the screen is that it's now ready 	 * for everything else, i.e. messages. 	 */
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_VI
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_paint --  *	This is the guts of the vi curses screen code.  The idea is that  *	the SCR structure passed in contains the new coordinates of the  *	screen.  What makes this hard is that we don't know how big  *	characters are, doing input can put the cursor in illegal places,  *	and we're frantically trying to avoid repainting unless it's  *	absolutely necessary.  If you change this code, you'd better know  *	what you're doing.  It's subtle and quick to anger.  */
end_comment

begin_function
specifier|static
name|int
name|vs_paint
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|SMAP
modifier|*
name|smp
decl_stmt|,
name|tmp
decl_stmt|;
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
name|recno_t
name|lastline
decl_stmt|,
name|lcnt
decl_stmt|;
name|size_t
name|cwtotal
decl_stmt|,
name|cnt
decl_stmt|,
name|len
decl_stmt|,
name|notused
decl_stmt|,
name|off
decl_stmt|,
name|y
decl_stmt|;
name|int
name|ch
init|=
literal|0
decl_stmt|,
name|didpaint
decl_stmt|,
name|isempty
decl_stmt|,
name|leftright_warp
decl_stmt|;
name|CHAR_T
modifier|*
name|p
decl_stmt|;
define|#
directive|define
name|LNO
value|sp->lno
comment|/* Current file line. */
define|#
directive|define
name|OLNO
value|vip->olno
comment|/* Remembered file line. */
define|#
directive|define
name|CNO
value|sp->cno
comment|/* Current file column. */
define|#
directive|define
name|OCNO
value|vip->ocno
comment|/* Remembered file column. */
define|#
directive|define
name|SCNO
value|vip->sc_col
comment|/* Current screen column. */
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|didpaint
operator|=
name|leftright_warp
operator|=
literal|0
expr_stmt|;
comment|/* 	 * 5: Reformat the lines. 	 * 	 * If the lines themselves have changed (:set list, for example), 	 * fill in the map from scratch.  Adjust the screen that's being 	 * displayed if the leftright flag is set. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REFORMAT
argument_list|)
condition|)
block|{
comment|/* Invalidate the line size cache. */
name|VI_SCR_CFLUSH
argument_list|(
name|vip
argument_list|)
expr_stmt|;
comment|/* Toss vs_line() cached information. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_TOP
argument_list|)
condition|)
block|{
if|if
condition|(
name|vs_sm_fill
argument_list|(
name|sp
argument_list|,
name|LNO
argument_list|,
name|P_TOP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_CENTER
argument_list|)
condition|)
block|{
if|if
condition|(
name|vs_sm_fill
argument_list|(
name|sp
argument_list|,
name|LNO
argument_list|,
name|P_MIDDLE
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|vs_sm_fill
argument_list|(
name|sp
argument_list|,
name|OOBLNO
argument_list|,
name|P_TOP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REDRAW
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * 6: Line movement. 	 * 	 * Line changes can cause the top line to change as well.  As 	 * before, if the movement is large, the screen is repainted. 	 * 	 * 6a: Small screens. 	 * 	 * Users can use the window, w300, w1200 and w9600 options to make 	 * the screen artificially small.  The behavior of these options 	 * in the historic vi wasn't all that consistent, and, in fact, it 	 * was never documented how various screen movements affected the 	 * screen size.  Generally, one of three things would happen: 	 *	1: The screen would expand in size, showing the line 	 *	2: The screen would scroll, showing the line 	 *	3: The screen would compress to its smallest size and 	 *		repaint. 	 * In general, scrolling didn't cause compression (200^D was handled 	 * the same as ^D), movement to a specific line would (:N where N 	 * was 1 line below the screen caused a screen compress), and cursor 	 * movement would scroll if it was 11 lines or less, and compress if 	 * it was more than 11 lines.  (And, no, I have no idea where the 11 	 * comes from.) 	 * 	 * What we do is try and figure out if the line is less than half of 	 * a full screen away.  If it is, we expand the screen if there's 	 * room, and then scroll as necessary.  The alternative is to compress 	 * and repaint. 	 * 	 * !!! 	 * This code is a special case from beginning to end.  Unfortunately, 	 * home modems are still slow enough that it's worth having. 	 * 	 * XXX 	 * If the line a really long one, i.e. part of the line is on the 	 * screen but the column offset is not, we'll end up in the adjust 	 * code, when we should probably have compressed the screen. 	 */
if|if
condition|(
name|IS_SMALL
argument_list|(
name|sp
argument_list|)
condition|)
if|if
condition|(
name|LNO
operator|<
name|HMAP
operator|->
name|lno
condition|)
block|{
name|lcnt
operator|=
name|vs_sm_nlines
argument_list|(
name|sp
argument_list|,
name|HMAP
argument_list|,
name|LNO
argument_list|,
name|sp
operator|->
name|t_maxrows
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|<=
name|HALFSCREEN
argument_list|(
name|sp
argument_list|)
condition|)
for|for
control|(
init|;
name|lcnt
operator|&&
name|sp
operator|->
name|t_rows
operator|!=
name|sp
operator|->
name|t_maxrows
condition|;
operator|--
name|lcnt
operator|,
operator|++
name|sp
operator|->
name|t_rows
control|)
block|{
operator|++
name|TMAP
expr_stmt|;
if|if
condition|(
name|vs_sm_1down
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
goto|goto
name|small_fill
goto|;
block|}
elseif|else
if|if
condition|(
name|LNO
operator|>
name|TMAP
operator|->
name|lno
condition|)
block|{
name|lcnt
operator|=
name|vs_sm_nlines
argument_list|(
name|sp
argument_list|,
name|TMAP
argument_list|,
name|LNO
argument_list|,
name|sp
operator|->
name|t_maxrows
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|<=
name|HALFSCREEN
argument_list|(
name|sp
argument_list|)
condition|)
for|for
control|(
init|;
name|lcnt
operator|&&
name|sp
operator|->
name|t_rows
operator|!=
name|sp
operator|->
name|t_maxrows
condition|;
operator|--
name|lcnt
operator|,
operator|++
name|sp
operator|->
name|t_rows
control|)
block|{
if|if
condition|(
name|vs_sm_next
argument_list|(
name|sp
argument_list|,
name|TMAP
argument_list|,
name|TMAP
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|++
name|TMAP
expr_stmt|;
if|if
condition|(
name|vs_line
argument_list|(
name|sp
argument_list|,
name|TMAP
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|small_fill
label|:
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_clrtoeol
argument_list|(
name|sp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sp
operator|->
name|t_rows
operator|>
name|sp
operator|->
name|t_minrows
condition|;
operator|--
name|sp
operator|->
name|t_rows
operator|,
operator|--
name|TMAP
control|)
block|{
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|TMAP
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_clrtoeol
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vs_sm_fill
argument_list|(
name|sp
argument_list|,
name|LNO
argument_list|,
name|P_FILL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REDRAW
argument_list|)
expr_stmt|;
goto|goto
name|adjust
goto|;
block|}
block|}
comment|/* 	 * 6b: Line down, or current screen. 	 */
if|if
condition|(
name|LNO
operator|>=
name|HMAP
operator|->
name|lno
condition|)
block|{
comment|/* Current screen. */
if|if
condition|(
name|LNO
operator|<=
name|TMAP
operator|->
name|lno
condition|)
goto|goto
name|adjust
goto|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_TOP
argument_list|)
condition|)
goto|goto
name|top
goto|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_CENTER
argument_list|)
condition|)
goto|goto
name|middle
goto|;
comment|/* 		 * If less than half a screen above the line, scroll down 		 * until the line is on the screen. 		 */
name|lcnt
operator|=
name|vs_sm_nlines
argument_list|(
name|sp
argument_list|,
name|TMAP
argument_list|,
name|LNO
argument_list|,
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|<
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
while|while
condition|(
name|lcnt
operator|--
condition|)
if|if
condition|(
name|vs_sm_1up
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
goto|goto
name|adjust
goto|;
block|}
goto|goto
name|bottom
goto|;
block|}
comment|/* 	 * 6c: If not on the current screen, may request center or top. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_TOP
argument_list|)
condition|)
goto|goto
name|top
goto|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_CENTER
argument_list|)
condition|)
goto|goto
name|middle
goto|;
comment|/* 	 * 6d: Line up. 	 */
name|lcnt
operator|=
name|vs_sm_nlines
argument_list|(
name|sp
argument_list|,
name|HMAP
argument_list|,
name|LNO
argument_list|,
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|<
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
comment|/* 		 * If less than half a screen below the line, scroll up until 		 * the line is the first line on the screen.  Special check so 		 * that if the screen has been emptied, we refill it. 		 */
if|if
condition|(
name|db_exist
argument_list|(
name|sp
argument_list|,
name|HMAP
operator|->
name|lno
argument_list|)
condition|)
block|{
while|while
condition|(
name|lcnt
operator|--
condition|)
if|if
condition|(
name|vs_sm_1down
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
goto|goto
name|adjust
goto|;
block|}
else|else
goto|goto
name|top
goto|;
comment|/* XXX No such line. */
comment|/* 		 * If less than a half screen from the bottom of the file, 		 * put the last line of the file on the bottom of the screen. 		 */
name|bottom
label|:
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|lastline
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tmp
operator|.
name|lno
operator|=
name|LNO
expr_stmt|;
name|tmp
operator|.
name|coff
operator|=
name|HMAP
operator|->
name|coff
expr_stmt|;
name|tmp
operator|.
name|soff
operator|=
literal|1
expr_stmt|;
name|lcnt
operator|=
name|vs_sm_nlines
argument_list|(
name|sp
argument_list|,
operator|&
name|tmp
argument_list|,
name|lastline
argument_list|,
name|sp
operator|->
name|t_rows
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|<
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|vs_sm_fill
argument_list|(
name|sp
argument_list|,
name|lastline
argument_list|,
name|P_BOTTOM
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REDRAW
argument_list|)
expr_stmt|;
goto|goto
name|adjust
goto|;
block|}
comment|/* It's not close, just put the line in the middle. */
goto|goto
name|middle
goto|;
block|}
comment|/* 	 * If less than half a screen from the top of the file, put the first 	 * line of the file at the top of the screen.  Otherwise, put the line 	 * in the middle of the screen. 	 */
name|tmp
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
name|tmp
operator|.
name|coff
operator|=
name|HMAP
operator|->
name|coff
expr_stmt|;
name|tmp
operator|.
name|soff
operator|=
literal|1
expr_stmt|;
name|lcnt
operator|=
name|vs_sm_nlines
argument_list|(
name|sp
argument_list|,
operator|&
name|tmp
argument_list|,
name|LNO
argument_list|,
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|<
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|vs_sm_fill
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|,
name|P_TOP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|middle
label|:
if|if
condition|(
name|vs_sm_fill
argument_list|(
name|sp
argument_list|,
name|LNO
argument_list|,
name|P_MIDDLE
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
literal|0
condition|)
block|{
name|top
label|:
if|if
condition|(
name|vs_sm_fill
argument_list|(
name|sp
argument_list|,
name|LNO
argument_list|,
name|P_TOP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REDRAW
argument_list|)
expr_stmt|;
comment|/* 	 * At this point we know part of the line is on the screen.  Since 	 * scrolling is done using logical lines, not physical, all of the 	 * line may not be on the screen.  While that's not necessarily bad, 	 * if the part the cursor is on isn't there, we're going to lose. 	 * This can be tricky; if the line covers the entire screen, lno 	 * may be the same as both ends of the map, that's why we test BOTH 	 * the top and the bottom of the map.  This isn't a problem for 	 * left-right scrolling, the cursor movement code handles the problem. 	 * 	 * There's a performance issue here if editing *really* long lines. 	 * This gets to the right spot by scrolling, and, in a binary, by 	 * scrolling hundreds of lines.  If the adjustment looks like it's 	 * going to be a serious problem, refill the screen and repaint. 	 */
name|adjust
label|:
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
operator|&&
operator|(
name|LNO
operator|==
name|HMAP
operator|->
name|lno
operator|||
name|LNO
operator|==
name|TMAP
operator|->
name|lno
operator|)
condition|)
block|{
name|cnt
operator|=
name|vs_screens
argument_list|(
name|sp
argument_list|,
name|LNO
argument_list|,
operator|&
name|CNO
argument_list|)
expr_stmt|;
if|if
condition|(
name|LNO
operator|==
name|HMAP
operator|->
name|lno
operator|&&
name|cnt
operator|<
name|HMAP
operator|->
name|soff
condition|)
if|if
condition|(
operator|(
name|HMAP
operator|->
name|soff
operator|-
name|cnt
operator|)
operator|>
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|HMAP
operator|->
name|soff
operator|=
name|cnt
expr_stmt|;
name|vs_sm_fill
argument_list|(
name|sp
argument_list|,
name|OOBLNO
argument_list|,
name|P_TOP
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REDRAW
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
name|cnt
operator|<
name|HMAP
operator|->
name|soff
condition|)
if|if
condition|(
name|vs_sm_1down
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|LNO
operator|==
name|TMAP
operator|->
name|lno
operator|&&
name|cnt
operator|>
name|TMAP
operator|->
name|soff
condition|)
if|if
condition|(
operator|(
name|cnt
operator|-
name|TMAP
operator|->
name|soff
operator|)
operator|>
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|TMAP
operator|->
name|soff
operator|=
name|cnt
expr_stmt|;
name|vs_sm_fill
argument_list|(
name|sp
argument_list|,
name|OOBLNO
argument_list|,
name|P_BOTTOM
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REDRAW
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
name|cnt
operator|>
name|TMAP
operator|->
name|soff
condition|)
if|if
condition|(
name|vs_sm_1up
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * If the screen needs to be repainted, skip cursor optimization. 	 * However, in the code above we skipped leftright scrolling on 	 * the grounds that the cursor code would handle it.  Make sure 	 * the right screen is up. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REDRAW
argument_list|)
condition|)
block|{
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
goto|goto
name|slow
goto|;
goto|goto
name|paint
goto|;
block|}
comment|/* 	 * 7: Cursor movements (current screen only). 	 */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|UPDATE_CURSOR
argument_list|)
condition|)
goto|goto
name|number
goto|;
comment|/* 	 * Decide cursor position.  If the line has changed, the cursor has 	 * moved over a tab, or don't know where the cursor was, reparse the 	 * line.  Otherwise, we've just moved over fixed-width characters, 	 * and can calculate the left/right scrolling and cursor movement 	 * without reparsing the line.  Note that we don't know which (if any) 	 * of the characters between the old and new cursor positions changed. 	 * 	 * XXX 	 * With some work, it should be possible to handle tabs quickly, at 	 * least in obvious situations, like moving right and encountering 	 * a tab, without reparsing the whole line. 	 * 	 * If the line we're working with has changed, reread it.. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vip
argument_list|,
name|VIP_CUR_INVALID
argument_list|)
operator|||
name|LNO
operator|!=
name|OLNO
condition|)
goto|goto
name|slow
goto|;
comment|/* Otherwise, if nothing's changed, ignore the cursor. */
if|if
condition|(
name|CNO
operator|==
name|OCNO
condition|)
goto|goto
name|fast
goto|;
comment|/* 	 * Get the current line.  If this fails, we either have an empty 	 * file and can just repaint, or there's a real problem.  This 	 * isn't a performance issue because there aren't any ways to get 	 * here repeatedly. 	 */
if|if
condition|(
name|db_eget
argument_list|(
name|sp
argument_list|,
name|LNO
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|isempty
argument_list|)
condition|)
block|{
if|if
condition|(
name|isempty
condition|)
goto|goto
name|slow
goto|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
comment|/* Sanity checking. */
if|if
condition|(
name|CNO
operator|>=
name|len
operator|&&
name|len
operator|!=
literal|0
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Error: %s/%d: cno (%zu)>= len (%zu)"
argument_list|,
name|tail
argument_list|(
name|__FILE__
argument_list|)
argument_list|,
name|__LINE__
argument_list|,
name|CNO
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 	 * The basic scheme here is to look at the characters in between 	 * the old and new positions and decide how big they are on the 	 * screen, and therefore, how many screen positions to move. 	 */
if|if
condition|(
name|CNO
operator|<
name|OCNO
condition|)
block|{
comment|/* 		 * 7a: Cursor moved left. 		 * 		 * Point to the old character.  The old cursor position can 		 * be past EOL if, for example, we just deleted the rest of 		 * the line.  In this case, since we don't know the width of 		 * the characters we traversed, we have to do it slowly. 		 */
name|p
operator|+=
name|OCNO
expr_stmt|;
name|cnt
operator|=
operator|(
name|OCNO
operator|-
name|CNO
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|OCNO
operator|>=
name|len
condition|)
goto|goto
name|slow
goto|;
comment|/* 		 * Quick sanity check -- it's hard to figure out exactly when 		 * we cross a screen boundary as we do in the cursor right 		 * movement.  If cnt is so large that we're going to cross the 		 * boundary no matter what, stop now. 		 */
if|if
condition|(
name|SCNO
operator|+
literal|1
operator|+
name|MAX_CHARACTER_COLUMNS
operator|<
name|cnt
condition|)
goto|goto
name|slow
goto|;
comment|/* 		 * Count up the widths of the characters.  If it's a tab 		 * character, go do it the the slow way. 		 */
for|for
control|(
name|cwtotal
operator|=
literal|0
init|;
name|cnt
operator|--
condition|;
name|cwtotal
operator|+=
name|KEY_COL
argument_list|(
name|sp
argument_list|,
name|ch
argument_list|)
control|)
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
operator|(
name|UCHAR_T
operator|*
operator|)
name|p
operator|--
operator|)
operator|==
literal|'\t'
condition|)
goto|goto
name|slow
goto|;
comment|/* 		 * Decrement the screen cursor by the total width of the 		 * characters minus 1. 		 */
name|cwtotal
operator|-=
literal|1
expr_stmt|;
comment|/* 		 * If we're moving left, and there's a wide character in the 		 * current position, go to the end of the character. 		 */
if|if
condition|(
name|KEY_COL
argument_list|(
name|sp
argument_list|,
name|ch
argument_list|)
operator|>
literal|1
condition|)
name|cwtotal
operator|-=
name|KEY_COL
argument_list|(
name|sp
argument_list|,
name|ch
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* 		 * If the new column moved us off of the current logical line, 		 * calculate a new one.  If doing leftright scrolling, we've 		 * moved off of the current screen, as well. 		 */
if|if
condition|(
name|SCNO
operator|<
name|cwtotal
condition|)
goto|goto
name|slow
goto|;
name|SCNO
operator|-=
name|cwtotal
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * 7b: Cursor moved right. 		 * 		 * Point to the first character to the right. 		 */
name|p
operator|+=
name|OCNO
operator|+
literal|1
expr_stmt|;
name|cnt
operator|=
name|CNO
operator|-
name|OCNO
expr_stmt|;
comment|/* 		 * Count up the widths of the characters.  If it's a tab 		 * character, go do it the the slow way.  If we cross a 		 * screen boundary, we can quit. 		 */
for|for
control|(
name|cwtotal
operator|=
name|SCNO
init|;
name|cnt
operator|--
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
operator|(
name|UCHAR_T
operator|*
operator|)
name|p
operator|++
operator|)
operator|==
literal|'\t'
condition|)
goto|goto
name|slow
goto|;
if|if
condition|(
operator|(
name|cwtotal
operator|+=
name|KEY_COL
argument_list|(
name|sp
argument_list|,
name|ch
argument_list|)
operator|)
operator|>=
name|SCREEN_COLS
argument_list|(
name|sp
argument_list|)
condition|)
break|break;
block|}
comment|/* 		 * Increment the screen cursor by the total width of the 		 * characters. 		 */
name|SCNO
operator|=
name|cwtotal
expr_stmt|;
comment|/* See screen change comment in section 6a. */
if|if
condition|(
name|SCNO
operator|>=
name|SCREEN_COLS
argument_list|(
name|sp
argument_list|)
condition|)
goto|goto
name|slow
goto|;
block|}
comment|/* 	 * 7c: Fast cursor update. 	 * 	 * We have the current column, retrieve the current row. 	 */
name|fast
label|:
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_cursor
argument_list|(
name|sp
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|notused
argument_list|)
expr_stmt|;
goto|goto
name|done_cursor
goto|;
comment|/* 	 * 7d: Slow cursor update. 	 * 	 * Walk through the map and find the current line. 	 */
name|slow
label|:
for|for
control|(
name|smp
operator|=
name|HMAP
init|;
name|smp
operator|->
name|lno
operator|!=
name|LNO
condition|;
operator|++
name|smp
control|)
empty_stmt|;
comment|/* 	 * 7e: Leftright scrolling adjustment. 	 * 	 * If doing left-right scrolling and the cursor movement has changed 	 * the displayed screen, scroll the screen left or right, unless we're 	 * updating the info line in which case we just scroll that one line. 	 * We adjust the offset up or down until we have a window that covers 	 * the current column, making sure that we adjust differently for the 	 * first screen as compared to subsequent ones. 	 */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
block|{
comment|/* 		 * Get the screen column for this character, and correct 		 * for the number option offset. 		 */
name|cnt
operator|=
name|vs_columns
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|LNO
argument_list|,
operator|&
name|CNO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_NUMBER
argument_list|)
condition|)
name|cnt
operator|-=
name|O_NUMBER_LENGTH
expr_stmt|;
comment|/* Adjust the window towards the beginning of the line. */
name|off
operator|=
name|smp
operator|->
name|coff
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|cnt
condition|)
block|{
do|do
block|{
if|if
condition|(
name|off
operator|>=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_SIDESCROLL
argument_list|)
condition|)
name|off
operator|-=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_SIDESCROLL
argument_list|)
expr_stmt|;
else|else
block|{
name|off
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|off
operator|>=
name|cnt
condition|)
do|;
goto|goto
name|shifted
goto|;
block|}
comment|/* Adjust the window towards the end of the line. */
if|if
condition|(
operator|(
name|off
operator|==
literal|0
operator|&&
name|off
operator|+
name|SCREEN_COLS
argument_list|(
name|sp
argument_list|)
operator|<
name|cnt
operator|)
operator|||
operator|(
name|off
operator|!=
literal|0
operator|&&
name|off
operator|+
name|sp
operator|->
name|cols
operator|<
name|cnt
operator|)
condition|)
block|{
do|do
block|{
name|off
operator|+=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_SIDESCROLL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|off
operator|+
name|sp
operator|->
name|cols
operator|<
name|cnt
condition|)
do|;
name|shifted
label|:
comment|/* Fill in screen map with the new offset. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_TINPUT_INFO
argument_list|)
condition|)
name|smp
operator|->
name|coff
operator|=
name|off
expr_stmt|;
else|else
block|{
for|for
control|(
name|smp
operator|=
name|HMAP
init|;
name|smp
operator|<=
name|TMAP
condition|;
operator|++
name|smp
control|)
name|smp
operator|->
name|coff
operator|=
name|off
expr_stmt|;
name|leftright_warp
operator|=
literal|1
expr_stmt|;
block|}
goto|goto
name|paint
goto|;
block|}
comment|/* 		 * We may have jumped here to adjust a leftright screen because 		 * redraw was set.  If so, we have to paint the entire screen. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REDRAW
argument_list|)
condition|)
goto|goto
name|paint
goto|;
block|}
comment|/* 	 * Update the screen lines for this particular file line until we 	 * have a new screen cursor position. 	 */
for|for
control|(
name|y
operator|=
operator|-
literal|1
operator|,
name|vip
operator|->
name|sc_smap
operator|=
name|NULL
init|;
name|smp
operator|<=
name|TMAP
operator|&&
name|smp
operator|->
name|lno
operator|==
name|LNO
condition|;
operator|++
name|smp
control|)
block|{
if|if
condition|(
name|vs_line
argument_list|(
name|sp
argument_list|,
name|smp
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|SCNO
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|y
operator|!=
operator|-
literal|1
condition|)
block|{
name|vip
operator|->
name|sc_smap
operator|=
name|smp
expr_stmt|;
break|break;
block|}
block|}
goto|goto
name|done_cursor
goto|;
comment|/* 	 * 8: Repaint the entire screen. 	 * 	 * Lost big, do what you have to do.  We flush the cache, since 	 * SC_SCR_REDRAW gets set when the screen isn't worth fixing, and 	 * it's simpler to repaint.  So, don't trust anything that we 	 * think we know about it. 	 */
name|paint
label|:
for|for
control|(
name|smp
operator|=
name|HMAP
init|;
name|smp
operator|<=
name|TMAP
condition|;
operator|++
name|smp
control|)
name|SMAP_FLUSH
argument_list|(
name|smp
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
operator|-
literal|1
operator|,
name|vip
operator|->
name|sc_smap
operator|=
name|NULL
operator|,
name|smp
operator|=
name|HMAP
init|;
name|smp
operator|<=
name|TMAP
condition|;
operator|++
name|smp
control|)
block|{
if|if
condition|(
name|vs_line
argument_list|(
name|sp
argument_list|,
name|smp
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|SCNO
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|y
operator|!=
operator|-
literal|1
operator|&&
name|vip
operator|->
name|sc_smap
operator|==
name|NULL
condition|)
name|vip
operator|->
name|sc_smap
operator|=
name|smp
expr_stmt|;
block|}
comment|/* 	 * If it's a small screen and we're redrawing, clear the unused lines, 	 * ex may have overwritten them. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REDRAW
argument_list|)
operator|&&
name|IS_SMALL
argument_list|(
name|sp
argument_list|)
condition|)
for|for
control|(
name|cnt
operator|=
name|sp
operator|->
name|t_rows
init|;
name|cnt
operator|<=
name|sp
operator|->
name|t_maxrows
condition|;
operator|++
name|cnt
control|)
block|{
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_clrtoeol
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
name|didpaint
operator|=
literal|1
expr_stmt|;
name|done_cursor
label|:
comment|/* 	 * Sanity checking.  When the repainting code messes up, the usual 	 * result is we don't repaint the cursor and so sc_smap will be 	 * NULL.  If we're debugging, die, otherwise restart from scratch. 	 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|vip
operator|->
name|sc_smap
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|vip
operator|->
name|sc_smap
operator|==
name|NULL
condition|)
block|{
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REFORMAT
argument_list|)
expr_stmt|;
return|return
operator|(
name|vs_paint
argument_list|(
name|sp
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 	 * 9: Set the remembered cursor values. 	 */
name|OCNO
operator|=
name|CNO
expr_stmt|;
name|OLNO
operator|=
name|LNO
expr_stmt|;
comment|/* 	 * 10: Repaint the line numbers. 	 * 	 * If O_NUMBER is set and the VIP_N_RENUMBER bit is set, and we 	 * didn't repaint the screen, repaint all of the line numbers, 	 * they've changed. 	 */
name|number
label|:
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_NUMBER
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|vip
argument_list|,
name|VIP_N_RENUMBER
argument_list|)
operator|&&
operator|!
name|didpaint
operator|&&
name|vs_number
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * 11: Update the mode line, position the cursor, and flush changes. 	 * 	 * If we warped the screen, we have to refresh everything. 	 */
if|if
condition|(
name|leftright_warp
condition|)
name|LF_SET
argument_list|(
name|UPDATE_CURSOR
operator||
name|UPDATE_SCREEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|UPDATE_SCREEN
argument_list|)
operator|&&
operator|!
name|IS_ONELINE
argument_list|(
name|sp
argument_list|)
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|vip
argument_list|,
name|VIP_S_MODELINE
argument_list|)
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_TINPUT_INFO
argument_list|)
condition|)
name|vs_modeline
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|UPDATE_CURSOR
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|y
argument_list|,
name|SCNO
argument_list|)
expr_stmt|;
comment|/* 		 * XXX 		 * If the screen shifted, we recalculate the "most favorite" 		 * cursor position.  Vi won't know that we've warped the 		 * screen, so it's going to have a wrong idea about where the 		 * cursor should be.  This is vi's problem, and fixing it here 		 * is a gross layering violation. 		 */
if|if
condition|(
name|leftright_warp
condition|)
operator|(
name|void
operator|)
name|vs_column
argument_list|(
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|rcm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LF_ISSET
argument_list|(
name|UPDATE_SCREEN
argument_list|)
condition|)
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_refresh
argument_list|(
name|sp
argument_list|,
name|F_ISSET
argument_list|(
name|vip
argument_list|,
name|VIP_N_EX_PAINT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 12: Clear the flags that are handled by this routine. */
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_SCR_CENTER
operator||
name|SC_SCR_REDRAW
operator||
name|SC_SCR_REFORMAT
operator||
name|SC_SCR_TOP
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|vip
argument_list|,
name|VIP_CUR_INVALID
operator||
name|VIP_N_EX_PAINT
operator||
name|VIP_N_REFRESH
operator||
name|VIP_N_RENUMBER
operator||
name|VIP_S_MODELINE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
undef|#
directive|undef
name|LNO
undef|#
directive|undef
name|OLNO
undef|#
directive|undef
name|CNO
undef|#
directive|undef
name|OCNO
undef|#
directive|undef
name|SCNO
block|}
end_function

begin_comment
comment|/*  * vs_modeline --  *	Update the mode line.  */
end_comment

begin_function
specifier|static
name|void
name|vs_modeline
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
specifier|static
name|char
modifier|*
specifier|const
name|modes
index|[]
init|=
block|{
literal|"215|Append"
block|,
comment|/* SM_APPEND */
literal|"216|Change"
block|,
comment|/* SM_CHANGE */
literal|"217|Command"
block|,
comment|/* SM_COMMAND */
literal|"218|Insert"
block|,
comment|/* SM_INSERT */
literal|"219|Replace"
block|,
comment|/* SM_REPLACE */
block|}
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|size_t
name|cols
decl_stmt|,
name|curcol
decl_stmt|,
name|curlen
decl_stmt|,
name|endpoint
decl_stmt|,
name|len
decl_stmt|,
name|midpoint
decl_stmt|;
specifier|const
name|char
modifier|*
name|t
init|=
name|NULL
decl_stmt|;
name|int
name|ellipsis
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
comment|/* 	 * We put down the file name, the ruler, the mode and the dirty flag. 	 * If there's not enough room, there's not enough room, we don't play 	 * any special games.  We try to put the ruler in the middle and the 	 * mode and dirty flag at the end. 	 * 	 * !!! 	 * Leave the last character blank, in case it's a really dumb terminal 	 * with hardware scroll.  Second, don't paint the last character in the 	 * screen, SunOS 4.1.1 and Ultrix 4.2 curses won't let you. 	 * 	 * Move to the last line on the screen. 	 */
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If more than one screen in the display, show the file name. */
name|curlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_SPLIT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|CHAR_T
modifier|*
name|wp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|CHAR2INT
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|frp
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|sp
operator|->
name|frp
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|wp
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|p
operator|=
name|wp
operator|+
name|l
expr_stmt|;
for|for
control|(
name|ellipsis
operator|=
literal|0
operator|,
name|cols
operator|=
name|sp
operator|->
name|cols
operator|/
literal|2
init|;
operator|--
name|p
operator|>
name|wp
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
operator|++
name|p
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|curlen
operator|+=
name|KEY_COL
argument_list|(
name|sp
argument_list|,
operator|*
name|p
argument_list|)
operator|)
operator|>
name|cols
condition|)
block|{
name|ellipsis
operator|=
literal|3
expr_stmt|;
name|curlen
operator|+=
name|KEY_LEN
argument_list|(
name|sp
argument_list|,
literal|'.'
argument_list|)
operator|*
literal|3
operator|+
name|KEY_LEN
argument_list|(
name|sp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
while|while
condition|(
name|curlen
operator|>
name|cols
condition|)
block|{
operator|++
name|p
expr_stmt|;
name|curlen
operator|-=
name|KEY_COL
argument_list|(
name|sp
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|ellipsis
condition|)
block|{
while|while
condition|(
name|ellipsis
operator|--
condition|)
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_addstr
argument_list|(
name|sp
argument_list|,
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
literal|'.'
argument_list|)
argument_list|,
name|KEY_LEN
argument_list|(
name|sp
argument_list|,
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_addstr
argument_list|(
name|sp
argument_list|,
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
literal|' '
argument_list|)
argument_list|,
name|KEY_LEN
argument_list|(
name|sp
argument_list|,
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_addstr
argument_list|(
name|sp
argument_list|,
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
operator|*
name|p
argument_list|)
argument_list|,
name|KEY_COL
argument_list|(
name|sp
argument_list|,
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the rest of the line. */
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_clrtoeol
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * Display the ruler.  If we're not at the midpoint yet, move there. 	 * Otherwise, add in two extra spaces. 	 * 	 * Adjust the current column for the fact that the editor uses it as 	 * a zero-based number. 	 * 	 * XXX 	 * Assume that numbers, commas, and spaces only take up a single 	 * column on the screen. 	 */
name|cols
operator|=
name|sp
operator|->
name|cols
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_RULER
argument_list|)
condition|)
block|{
name|vs_column
argument_list|(
name|sp
argument_list|,
operator|&
name|curcol
argument_list|)
expr_stmt|;
name|len
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%lu,%lu"
argument_list|,
operator|(
name|u_long
operator|)
name|sp
operator|->
name|lno
argument_list|,
call|(
name|u_long
call|)
argument_list|(
name|curcol
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|midpoint
operator|=
operator|(
name|cols
operator|-
operator|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|curlen
operator|<
name|midpoint
condition|)
block|{
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
name|midpoint
argument_list|)
expr_stmt|;
name|curlen
operator|+=
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curlen
operator|+
literal|2
operator|+
name|len
operator|<
name|cols
condition|)
block|{
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_addstr
argument_list|(
name|sp
argument_list|,
literal|"  "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|curlen
operator|+=
literal|2
operator|+
name|len
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_addstr
argument_list|(
name|sp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Display the mode and the modified flag, as close to the end of the 	 * line as possible, but guaranteeing at least two spaces between the 	 * ruler and the modified flag. 	 */
define|#
directive|define
name|MODESIZE
value|9
name|endpoint
operator|=
name|cols
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_SHOWMODE
argument_list|)
condition|)
block|{
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
operator|->
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
condition|)
operator|--
name|endpoint
expr_stmt|;
name|t
operator|=
name|msg_cat
argument_list|(
name|sp
argument_list|,
name|modes
index|[
name|sp
operator|->
name|showmode
index|]
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|endpoint
operator|-=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|endpoint
operator|>
name|curlen
operator|+
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
name|endpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_SHOWMODE
argument_list|)
condition|)
block|{
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
operator|->
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
condition|)
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_addstr
argument_list|(
name|sp
argument_list|,
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
literal|'*'
argument_list|)
argument_list|,
name|KEY_LEN
argument_list|(
name|sp
argument_list|,
literal|'*'
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_addstr
argument_list|(
name|sp
argument_list|,
name|t
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

