begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)vs_relative.c	10.11 (Berkeley) 5/13/96"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"../common/common.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_comment
comment|/*  * vs_column --  *	Return the logical column of the cursor in the line.  *  * PUBLIC: int vs_column __P((SCR *, size_t *));  */
end_comment

begin_function
name|int
name|vs_column
parameter_list|(
name|sp
parameter_list|,
name|colp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|size_t
modifier|*
name|colp
decl_stmt|;
block|{
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|*
name|colp
operator|=
operator|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|?
name|vip
operator|->
name|sc_smap
operator|->
name|coff
else|:
operator|(
name|vip
operator|->
name|sc_smap
operator|->
name|soff
operator|-
literal|1
operator|)
operator|*
name|sp
operator|->
name|cols
operator|)
operator|+
name|vip
operator|->
name|sc_col
operator|-
operator|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_NUMBER
argument_list|)
condition|?
name|O_NUMBER_LENGTH
else|:
literal|0
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_screens --  *	Return the screens necessary to display the line, or if specified,  *	the physical character column within the line, including space  *	required for the O_NUMBER and O_LIST options.  *  * PUBLIC: size_t vs_screens __P((SCR *, recno_t, size_t *));  */
end_comment

begin_function
name|size_t
name|vs_screens
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|,
name|cnop
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|size_t
modifier|*
name|cnop
decl_stmt|;
block|{
name|size_t
name|cols
decl_stmt|,
name|screens
decl_stmt|;
comment|/* Left-right screens are simple, it's always 1. */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Check for a cached value.  We maintain a cache because, if the 	 * line is large, this routine gets called repeatedly.  One other 	 * hack, lots of time the cursor is on column one, which is an easy 	 * one. 	 */
if|if
condition|(
name|cnop
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|VIP
argument_list|(
name|sp
argument_list|)
operator|->
name|ss_lno
operator|==
name|lno
condition|)
return|return
operator|(
name|VIP
argument_list|(
name|sp
argument_list|)
operator|->
name|ss_screens
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cnop
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Figure out how many columns the line/column needs. */
name|cols
operator|=
name|vs_columns
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|lno
argument_list|,
name|cnop
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|screens
operator|=
operator|(
name|cols
operator|/
name|sp
operator|->
name|cols
operator|+
operator|(
name|cols
operator|%
name|sp
operator|->
name|cols
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|screens
operator|==
literal|0
condition|)
name|screens
operator|=
literal|1
expr_stmt|;
comment|/* Cache the value. */
if|if
condition|(
name|cnop
operator|==
name|NULL
condition|)
block|{
name|VIP
argument_list|(
name|sp
argument_list|)
operator|->
name|ss_lno
operator|=
name|lno
expr_stmt|;
name|VIP
argument_list|(
name|sp
argument_list|)
operator|->
name|ss_screens
operator|=
name|screens
expr_stmt|;
block|}
return|return
operator|(
name|screens
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_columns --  *	Return the screen columns necessary to display the line, or,  *	if specified, the physical character column within the line.  *  * PUBLIC: size_t vs_columns __P((SCR *, char *, recno_t, size_t *, size_t *));  */
end_comment

begin_function
name|size_t
name|vs_columns
parameter_list|(
name|sp
parameter_list|,
name|lp
parameter_list|,
name|lno
parameter_list|,
name|cnop
parameter_list|,
name|diffp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|lp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|size_t
modifier|*
name|cnop
decl_stmt|,
decl|*
name|diffp
decl_stmt|;
end_function

begin_block
block|{
name|size_t
name|chlen
decl_stmt|,
name|cno
decl_stmt|,
name|curoff
decl_stmt|,
name|last
decl_stmt|,
name|len
decl_stmt|,
name|scno
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|leftright
decl_stmt|,
name|listset
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Need the line to go any further. */
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|db_get
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
literal|0
argument_list|,
operator|&
name|lp
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* Missing or empty lines are easy. */
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
block|{
name|done
label|:
if|if
condition|(
name|diffp
operator|!=
name|NULL
condition|)
comment|/* XXX */
operator|*
name|diffp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Store away the values of the list and leftright edit options. */
name|listset
operator|=
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LIST
argument_list|)
expr_stmt|;
name|leftright
operator|=
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the pointer into the buffer and screen and current 	 * offsets. 	 */
name|p
operator|=
name|lp
expr_stmt|;
name|curoff
operator|=
name|scno
operator|=
literal|0
expr_stmt|;
comment|/* Leading number if O_NUMBER option set. */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_NUMBER
argument_list|)
condition|)
name|scno
operator|+=
name|O_NUMBER_LENGTH
expr_stmt|;
comment|/* Macro to return the display length of any signal character. */
define|#
directive|define
name|CHLEN
parameter_list|(
name|val
parameter_list|)
value|(ch = *(u_char *)p++) == '\t'&&			\ 	    !listset ? TAB_OFF(val) : KEY_LEN(sp, ch);
comment|/* 	 * If folding screens (the historic vi screen format), past the end 	 * of the current screen, and the character was a tab, reset the 	 * current screen column to 0, and the total screen columns to the 	 * last column of the screen.  Otherwise, display the rest of the 	 * character in the next screen. 	 */
define|#
directive|define
name|TAB_RESET
value|{							\ 	curoff += chlen;						\ 	if (!leftright&& curoff>= sp->cols)				\ 		if (ch == '\t') {					\ 			curoff = 0;					\ 			scno -= scno % sp->cols;			\ 		} else							\ 			curoff -= sp->cols;				\ }
if|if
condition|(
name|cnop
operator|==
name|NULL
condition|)
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|chlen
operator|=
name|CHLEN
argument_list|(
name|curoff
argument_list|)
expr_stmt|;
name|last
operator|=
name|scno
expr_stmt|;
name|scno
operator|+=
name|chlen
expr_stmt|;
name|TAB_RESET
expr_stmt|;
block|}
else|else
for|for
control|(
name|cno
operator|=
operator|*
name|cnop
init|;
condition|;
operator|--
name|cno
control|)
block|{
name|chlen
operator|=
name|CHLEN
argument_list|(
name|curoff
argument_list|)
expr_stmt|;
name|last
operator|=
name|scno
expr_stmt|;
name|scno
operator|+=
name|chlen
expr_stmt|;
name|TAB_RESET
expr_stmt|;
if|if
condition|(
name|cno
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Add the trailing '$' if the O_LIST option set. */
if|if
condition|(
name|listset
operator|&&
name|cnop
operator|==
name|NULL
condition|)
name|scno
operator|+=
name|KEY_LEN
argument_list|(
name|sp
argument_list|,
literal|'$'
argument_list|)
expr_stmt|;
comment|/* 	 * The text input screen code needs to know how much additional 	 * room the last two characters required, so that it can handle 	 * tab character displays correctly. 	 */
if|if
condition|(
name|diffp
operator|!=
name|NULL
condition|)
operator|*
name|diffp
operator|=
name|scno
operator|-
name|last
expr_stmt|;
return|return
operator|(
name|scno
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * vs_rcm --  *	Return the physical column from the line that will display a  *	character closest to the currently most attractive character  *	position (which is stored as a screen column).  *  * PUBLIC: size_t vs_rcm __P((SCR *, recno_t, int));  */
end_comment

begin_function
name|size_t
name|vs_rcm
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|,
name|islast
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|int
name|islast
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
comment|/* Last character is easy, and common. */
if|if
condition|(
name|islast
condition|)
block|{
if|if
condition|(
name|db_get
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|)
operator|||
name|len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|len
operator|-
literal|1
operator|)
return|;
block|}
comment|/* First character is easy, and common. */
if|if
condition|(
name|sp
operator|->
name|rcm
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|vs_colpos
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|sp
operator|->
name|rcm
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_colpos --  *	Return the physical column from the line that will display a  *	character closest to the specified screen column.  *  * PUBLIC: size_t vs_colpos __P((SCR *, recno_t, size_t));  */
end_comment

begin_function
name|size_t
name|vs_colpos
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|,
name|cno
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|size_t
name|cno
decl_stmt|;
block|{
name|size_t
name|chlen
decl_stmt|,
name|curoff
decl_stmt|,
name|len
decl_stmt|,
name|llen
decl_stmt|,
name|off
decl_stmt|,
name|scno
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|leftright
decl_stmt|,
name|listset
decl_stmt|;
name|char
modifier|*
name|lp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* Need the line to go any further. */
operator|(
name|void
operator|)
name|db_get
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
literal|0
argument_list|,
operator|&
name|lp
argument_list|,
operator|&
name|llen
argument_list|)
expr_stmt|;
comment|/* Missing or empty lines are easy. */
if|if
condition|(
name|lp
operator|==
name|NULL
operator|||
name|llen
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Store away the values of the list and leftright edit options. */
name|listset
operator|=
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LIST
argument_list|)
expr_stmt|;
name|leftright
operator|=
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
expr_stmt|;
comment|/* Discard screen (logical) lines. */
name|off
operator|=
name|cno
operator|/
name|sp
operator|->
name|cols
expr_stmt|;
name|cno
operator|%=
name|sp
operator|->
name|cols
expr_stmt|;
for|for
control|(
name|scno
operator|=
literal|0
operator|,
name|p
operator|=
name|lp
operator|,
name|len
operator|=
name|llen
init|;
name|off
operator|--
condition|;
control|)
block|{
for|for
control|(
init|;
name|len
operator|&&
name|scno
operator|<
name|sp
operator|->
name|cols
condition|;
operator|--
name|len
control|)
name|scno
operator|+=
name|CHLEN
argument_list|(
name|scno
argument_list|)
expr_stmt|;
comment|/* 		 * If reached the end of the physical line, return the last 		 * physical character in the line. 		 */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
name|llen
operator|-
literal|1
operator|)
return|;
comment|/* 		 * If folding screens (the historic vi screen format), past 		 * the end of the current screen, and the character was a tab, 		 * reset the current screen column to 0.  Otherwise, the rest 		 * of the character is displayed in the next screen. 		 */
if|if
condition|(
name|leftright
operator|&&
name|ch
operator|==
literal|'\t'
condition|)
name|scno
operator|=
literal|0
expr_stmt|;
else|else
name|scno
operator|-=
name|sp
operator|->
name|cols
expr_stmt|;
block|}
comment|/* Step through the line until reach the right character or EOL. */
for|for
control|(
name|curoff
operator|=
name|scno
init|;
name|len
operator|--
condition|;
control|)
block|{
name|chlen
operator|=
name|CHLEN
argument_list|(
name|curoff
argument_list|)
expr_stmt|;
comment|/* 		 * If we've reached the specific character, there are three 		 * cases. 		 * 		 * 1: scno == cno, i.e. the current character ends at the 		 *    screen character we care about. 		 *	a: off< llen - 1, i.e. not the last character in 		 *	   the line, return the offset of the next character. 		 *	b: else return the offset of the last character. 		 * 2: scno != cno, i.e. this character overruns the character 		 *    we care about, return the offset of this character. 		 */
if|if
condition|(
operator|(
name|scno
operator|+=
name|chlen
operator|)
operator|>=
name|cno
condition|)
block|{
name|off
operator|=
name|p
operator|-
name|lp
expr_stmt|;
return|return
operator|(
name|scno
operator|==
name|cno
condition|?
operator|(
name|off
operator|<
name|llen
operator|-
literal|1
condition|?
name|off
else|:
name|llen
operator|-
literal|1
operator|)
else|:
name|off
operator|-
literal|1
operator|)
return|;
block|}
name|TAB_RESET
expr_stmt|;
block|}
comment|/* No such character; return the start of the last character. */
return|return
operator|(
name|llen
operator|-
literal|1
operator|)
return|;
block|}
end_function

end_unit

