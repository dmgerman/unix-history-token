begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1992, 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"$Id: v_ex.c,v 10.61 2011/12/22 18:41:53 zy Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"../common/common.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|v_ecl
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|v_ecl_init
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|v_ecl_log
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|TEXT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|v_ex_done
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|VICMD
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|v_exec_ex
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|VICMD
operator|*
operator|,
name|EXCMD
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * v_again --&  *	Repeat the previous substitution.  *  * PUBLIC: int v_again __P((SCR *, VICMD *));  */
end_comment

begin_function
name|int
name|v_again
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|VICMD
modifier|*
name|vp
parameter_list|)
block|{
name|EXCMD
name|cmd
decl_stmt|;
name|ex_cinit
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|C_SUBAGAIN
argument_list|,
literal|2
argument_list|,
name|vp
operator|->
name|m_start
operator|.
name|lno
argument_list|,
name|vp
operator|->
name|m_start
operator|.
name|lno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|argv_exp0
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|L
argument_list|(
literal|""
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|v_exec_ex
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|,
operator|&
name|cmd
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_exmode -- Q  *	Switch the editor into EX mode.  *  * PUBLIC: int v_exmode __P((SCR *, VICMD *));  */
end_comment

begin_function
name|int
name|v_exmode
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|VICMD
modifier|*
name|vp
parameter_list|)
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
comment|/* Try and switch screens -- the screen may not permit it. */
if|if
condition|(
name|gp
operator|->
name|scr_screen
argument_list|(
name|sp
argument_list|,
name|SC_EX
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"207|The Q command requires the ex terminal interface"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_attr
argument_list|(
name|sp
argument_list|,
name|SA_ALTERNATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Save the current cursor position. */
name|sp
operator|->
name|frp
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|sp
operator|->
name|frp
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|F_SET
argument_list|(
name|sp
operator|->
name|frp
argument_list|,
name|FR_CURSORSET
argument_list|)
expr_stmt|;
comment|/* Switch to ex mode. */
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_VI
operator||
name|SC_SCR_VI
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_EX
argument_list|)
expr_stmt|;
comment|/* Move out of the vi screen. */
operator|(
name|void
operator|)
name|ex_puts
argument_list|(
name|sp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_join -- [count]J  *	Join lines together.  *  * PUBLIC: int v_join __P((SCR *, VICMD *));  */
end_comment

begin_function
name|int
name|v_join
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|VICMD
modifier|*
name|vp
parameter_list|)
block|{
name|EXCMD
name|cmd
decl_stmt|;
name|int
name|lno
decl_stmt|;
comment|/* 	 * YASC. 	 * The general rule is that '#J' joins # lines, counting the current 	 * line.  However, 'J' and '1J' are the same as '2J', i.e. join the 	 * current and next lines.  This doesn't map well into the ex command 	 * (which takes two line numbers), so we handle it here.  Note that 	 * we never test for EOF -- historically going past the end of file 	 * worked just fine. 	 */
name|lno
operator|=
name|vp
operator|->
name|m_start
operator|.
name|lno
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
operator|&&
name|vp
operator|->
name|count
operator|>
literal|2
condition|)
name|lno
operator|=
name|vp
operator|->
name|m_start
operator|.
name|lno
operator|+
operator|(
name|vp
operator|->
name|count
operator|-
literal|1
operator|)
expr_stmt|;
name|ex_cinit
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|C_JOIN
argument_list|,
literal|2
argument_list|,
name|vp
operator|->
name|m_start
operator|.
name|lno
argument_list|,
name|lno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|v_exec_ex
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|,
operator|&
name|cmd
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_shiftl -- [count]<motion  *	Shift lines left.  *  * PUBLIC: int v_shiftl __P((SCR *, VICMD *));  */
end_comment

begin_function
name|int
name|v_shiftl
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|VICMD
modifier|*
name|vp
parameter_list|)
block|{
name|EXCMD
name|cmd
decl_stmt|;
name|ex_cinit
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|C_SHIFTL
argument_list|,
literal|2
argument_list|,
name|vp
operator|->
name|m_start
operator|.
name|lno
argument_list|,
name|vp
operator|->
name|m_stop
operator|.
name|lno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argv_exp0
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|L
argument_list|(
literal|"<"
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|v_exec_ex
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|,
operator|&
name|cmd
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_shiftr -- [count]>motion  *	Shift lines right.  *  * PUBLIC: int v_shiftr __P((SCR *, VICMD *));  */
end_comment

begin_function
name|int
name|v_shiftr
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|VICMD
modifier|*
name|vp
parameter_list|)
block|{
name|EXCMD
name|cmd
decl_stmt|;
name|ex_cinit
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|C_SHIFTR
argument_list|,
literal|2
argument_list|,
name|vp
operator|->
name|m_start
operator|.
name|lno
argument_list|,
name|vp
operator|->
name|m_stop
operator|.
name|lno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argv_exp0
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|L
argument_list|(
literal|">"
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|v_exec_ex
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|,
operator|&
name|cmd
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_suspend -- ^Z  *	Suspend vi.  *  * PUBLIC: int v_suspend __P((SCR *, VICMD *));  */
end_comment

begin_function
name|int
name|v_suspend
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|VICMD
modifier|*
name|vp
parameter_list|)
block|{
name|EXCMD
name|cmd
decl_stmt|;
name|ex_cinit
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|C_STOP
argument_list|,
literal|0
argument_list|,
name|OOBLNO
argument_list|,
name|OOBLNO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argv_exp0
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|L
argument_list|(
literal|"suspend"
argument_list|)
argument_list|,
name|SIZE
argument_list|(
name|L
argument_list|(
literal|"suspend"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|v_exec_ex
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|,
operator|&
name|cmd
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_switch -- ^^  *	Switch to the previous file.  *  * PUBLIC: int v_switch __P((SCR *, VICMD *));  */
end_comment

begin_function
name|int
name|v_switch
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|VICMD
modifier|*
name|vp
parameter_list|)
block|{
name|EXCMD
name|cmd
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|CHAR_T
modifier|*
name|wp
decl_stmt|;
name|size_t
name|wlen
decl_stmt|;
comment|/* 	 * Try the alternate file name, then the previous file 	 * name.  Use the real name, not the user's current name. 	 */
if|if
condition|(
operator|(
name|name
operator|=
name|sp
operator|->
name|alt_name
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"180|No previous file to edit"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* If autowrite is set, write out the file. */
if|if
condition|(
name|file_m1
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|,
name|FS_ALL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ex_cinit
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|C_EDIT
argument_list|,
literal|0
argument_list|,
name|OOBLNO
argument_list|,
name|OOBLNO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHAR2INT
argument_list|(
name|sp
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|wp
argument_list|,
name|wlen
argument_list|)
expr_stmt|;
name|argv_exp0
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|wp
argument_list|,
name|wlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|v_exec_ex
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|,
operator|&
name|cmd
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_tagpush -- ^[  *	Do a tag search on the cursor keyword.  *  * PUBLIC: int v_tagpush __P((SCR *, VICMD *));  */
end_comment

begin_function
name|int
name|v_tagpush
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|VICMD
modifier|*
name|vp
parameter_list|)
block|{
name|EXCMD
name|cmd
decl_stmt|;
name|ex_cinit
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|C_TAG
argument_list|,
literal|0
argument_list|,
name|OOBLNO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argv_exp0
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|VIP
argument_list|(
name|sp
argument_list|)
operator|->
name|keyw
argument_list|,
name|STRLEN
argument_list|(
name|VIP
argument_list|(
name|sp
argument_list|)
operator|->
name|keyw
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|v_exec_ex
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|,
operator|&
name|cmd
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_tagpop -- ^T  *	Pop the tags stack.  *  * PUBLIC: int v_tagpop __P((SCR *, VICMD *));  */
end_comment

begin_function
name|int
name|v_tagpop
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|VICMD
modifier|*
name|vp
parameter_list|)
block|{
name|EXCMD
name|cmd
decl_stmt|;
name|ex_cinit
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|C_TAGPOP
argument_list|,
literal|0
argument_list|,
name|OOBLNO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|v_exec_ex
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|,
operator|&
name|cmd
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_filter -- [count]!motion command(s)  *	Run range through shell commands, replacing text.  *  * PUBLIC: int v_filter __P((SCR *, VICMD *));  */
end_comment

begin_function
name|int
name|v_filter
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|VICMD
modifier|*
name|vp
parameter_list|)
block|{
name|EXCMD
name|cmd
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
comment|/* 	 * !!! 	 * Historical vi permitted "!!" in an empty file, and it's handled 	 * as a special case in the ex_bang routine.  Don't modify this setup 	 * without understanding that one.  In particular, note that we're 	 * manipulating the ex argument structures behind ex's back. 	 * 	 * !!! 	 * Historical vi did not permit the '!' command to be associated with 	 * a non-line oriented motion command, in general, although it did 	 * with search commands.  So, !f; and !w would fail, but !/;<CR> 	 * would succeed, even if they all moved to the same location in the 	 * current line.  I don't see any reason to disallow '!' using any of 	 * the possible motion commands. 	 * 	 * !!! 	 * Historical vi ran the last bang command if N or n was used as the 	 * search motion. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_ISDOT
argument_list|)
operator|||
name|ISCMD
argument_list|(
name|vp
operator|->
name|rkp
argument_list|,
literal|'N'
argument_list|)
operator|||
name|ISCMD
argument_list|(
name|vp
operator|->
name|rkp
argument_list|,
literal|'n'
argument_list|)
condition|)
block|{
name|ex_cinit
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|C_BANG
argument_list|,
literal|2
argument_list|,
name|vp
operator|->
name|m_start
operator|.
name|lno
argument_list|,
name|vp
operator|->
name|m_stop
operator|.
name|lno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EXP
argument_list|(
name|sp
argument_list|)
operator|->
name|argsoff
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|argv_exp1
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|L
argument_list|(
literal|"!"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cmd
operator|.
name|argc
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
operator|->
name|argsoff
expr_stmt|;
comment|/* XXX */
name|cmd
operator|.
name|argv
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
operator|->
name|args
expr_stmt|;
comment|/* XXX */
return|return
operator|(
name|v_exec_ex
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|,
operator|&
name|cmd
argument_list|)
operator|)
return|;
block|}
comment|/* Get the command from the user. */
if|if
condition|(
name|v_tcmd
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|,
literal|'!'
argument_list|,
name|TXT_BS
operator||
name|TXT_CR
operator||
name|TXT_ESCAPE
operator||
name|TXT_FILEC
operator||
name|TXT_PROMPT
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Check to see if the user changed their mind. 	 * 	 * !!! 	 * Entering<escape> on an empty line was historically an error, 	 * this implementation doesn't bother. 	 */
name|tp
operator|=
name|TAILQ_FIRST
argument_list|(
name|sp
operator|->
name|tiq
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|term
operator|!=
name|TERM_OK
condition|)
block|{
name|vp
operator|->
name|m_final
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|vp
operator|->
name|m_final
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Home the cursor. */
name|vs_home
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|ex_cinit
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|C_BANG
argument_list|,
literal|2
argument_list|,
name|vp
operator|->
name|m_start
operator|.
name|lno
argument_list|,
name|vp
operator|->
name|m_stop
operator|.
name|lno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EXP
argument_list|(
name|sp
argument_list|)
operator|->
name|argsoff
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|argv_exp1
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|tp
operator|->
name|lb
operator|+
literal|1
argument_list|,
name|tp
operator|->
name|len
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cmd
operator|.
name|argc
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
operator|->
name|argsoff
expr_stmt|;
comment|/* XXX */
name|cmd
operator|.
name|argv
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
operator|->
name|args
expr_stmt|;
comment|/* XXX */
return|return
operator|(
name|v_exec_ex
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|,
operator|&
name|cmd
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_exec_ex --  *	Execute an ex command.  */
end_comment

begin_function
specifier|static
name|int
name|v_exec_ex
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|VICMD
modifier|*
name|vp
parameter_list|,
name|EXCMD
modifier|*
name|exp
parameter_list|)
block|{
name|int
name|rval
decl_stmt|;
name|rval
operator|=
name|exp
operator|->
name|cmd
operator|->
name|fn
argument_list|(
name|sp
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return
operator|(
name|v_ex_done
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|)
operator|||
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_ex -- :  *	Execute a colon command line.  *  * PUBLIC: int v_ex __P((SCR *, VICMD *));  */
end_comment

begin_function
name|int
name|v_ex
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|VICMD
modifier|*
name|vp
parameter_list|)
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|int
name|do_cedit
decl_stmt|,
name|do_resolution
decl_stmt|,
name|ifcontinue
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
comment|/* 	 * !!! 	 * If we put out more than a single line of messages, or ex trashes 	 * the screen, the user may continue entering ex commands.  We find 	 * this out when we do the screen/message resolution.  We can't enter 	 * completely into ex mode however, because the user can elect to 	 * return into vi mode by entering any key, i.e. we have to be in raw 	 * mode. 	 */
for|for
control|(
name|do_cedit
operator|=
name|do_resolution
operator|=
literal|0
init|;
condition|;
control|)
block|{
comment|/* 		 * !!! 		 * There may already be an ex command waiting to run.  If 		 * so, we continue with it. 		 */
if|if
condition|(
operator|!
name|EXCMD_RUNNING
argument_list|(
name|gp
argument_list|)
condition|)
block|{
comment|/* Get a command. */
if|if
condition|(
name|v_tcmd
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|,
literal|':'
argument_list|,
name|TXT_BS
operator||
name|TXT_CEDIT
operator||
name|TXT_FILEC
operator||
name|TXT_PROMPT
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tp
operator|=
name|TAILQ_FIRST
argument_list|(
name|sp
operator|->
name|tiq
argument_list|)
expr_stmt|;
comment|/* 			 * If the user entered a single<esc>, they want to 			 * edit their colon command history.  If they already 			 * entered some text, move it into the edit history. 			 */
if|if
condition|(
name|tp
operator|->
name|term
operator|==
name|TERM_CEDIT
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|len
operator|>
literal|1
operator|&&
name|v_ecl_log
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|do_cedit
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* If the user didn't enter anything, return. */
if|if
condition|(
name|tp
operator|->
name|term
operator|==
name|TERM_BS
condition|)
break|break;
comment|/* If the user changed their mind, return. */
if|if
condition|(
name|tp
operator|->
name|term
operator|!=
name|TERM_OK
condition|)
break|break;
comment|/* Log the command. */
if|if
condition|(
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_CEDIT
argument_list|)
operator|!=
name|NULL
operator|&&
name|v_ecl_log
argument_list|(
name|sp
argument_list|,
name|tp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Push a command on the command stack. */
if|if
condition|(
name|ex_run_str
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|len
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Home the cursor. */
name|vs_home
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 		 * !!! 		 * If the editor wrote the screen behind curses back, put out 		 * a<newline> so that we don't overwrite the user's command 		 * with its output or the next want-to-continue? message.  This 		 * doesn't belong here, but I can't find another place to put 		 * it.  See, we resolved the output from the last ex command, 		 * and the user entered another one.  This is the only place 		 * where we have control before the ex command writes output. 		 * We could get control in vs_msg(), but we have no way to know 		 * if command didn't put out any output when we try and resolve 		 * this command.  This fixes a bug where combinations of ex 		 * commands, e.g. ":set<CR>:!date<CR>:set" didn't look right. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EXWROTE
argument_list|)
condition|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Call the ex parser. */
operator|(
name|void
operator|)
name|ex_cmd
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* Flush ex messages. */
operator|(
name|void
operator|)
name|ex_fflush
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* Resolve any messages. */
if|if
condition|(
name|vs_ex_resolve
argument_list|(
name|sp
argument_list|,
operator|&
name|ifcontinue
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 		 * Continue or return.  If continuing, make sure that we 		 * eventually do resolution. 		 */
if|if
condition|(
operator|!
name|ifcontinue
condition|)
break|break;
name|do_resolution
operator|=
literal|1
expr_stmt|;
comment|/* If we're continuing, it's a new command. */
operator|++
name|sp
operator|->
name|ccnt
expr_stmt|;
block|}
comment|/* 	 * If the user previously continued an ex command, we have to do 	 * resolution to clean up the screen.  Don't wait, we already did 	 * that. 	 */
if|if
condition|(
name|do_resolution
condition|)
block|{
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_EX_WAIT_NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs_ex_resolve
argument_list|(
name|sp
argument_list|,
operator|&
name|ifcontinue
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Cleanup from the ex command. */
if|if
condition|(
name|v_ex_done
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* The user may want to edit their colon command history. */
if|if
condition|(
name|do_cedit
condition|)
return|return
operator|(
name|v_ecl
argument_list|(
name|sp
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_ex_done --  *	Cleanup from an ex command.  */
end_comment

begin_function
specifier|static
name|int
name|v_ex_done
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|VICMD
modifier|*
name|vp
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
comment|/* 	 * The only cursor modifications are real, however, the underlying 	 * line may have changed; don't trust anything.  This code has been 	 * a remarkably fertile place for bugs.  Do a reality check on a 	 * cursor value, and make sure it's okay.  If necessary, change it. 	 * Ex keeps track of the line number, but it cares less about the 	 * column and it may have disappeared. 	 * 	 * Don't trust ANYTHING. 	 * 	 * XXX 	 * Ex will soon have to start handling the column correctly; see 	 * the POSIX 1003.2 standard. 	 */
if|if
condition|(
name|db_eget
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|sp
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|cno
operator|>=
name|len
condition|)
name|sp
operator|->
name|cno
operator|=
name|len
condition|?
name|len
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|vp
operator|->
name|m_final
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|vp
operator|->
name|m_final
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* 	 * Don't re-adjust the cursor after executing an ex command, 	 * and ex movements are permanent. 	 */
name|F_CLR
argument_list|(
name|vp
argument_list|,
name|VM_RCM_MASK
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VM_RCM_SET
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_ecl --  *	Start an edit window on the colon command-line commands.  */
end_comment

begin_function
specifier|static
name|int
name|v_ecl
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|SCR
modifier|*
name|new
decl_stmt|;
comment|/* Initialize the screen, if necessary. */
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
if|if
condition|(
name|gp
operator|->
name|ccl_sp
operator|==
name|NULL
operator|&&
name|v_ecl_init
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Get a new screen. */
if|if
condition|(
name|screen_init
argument_list|(
name|gp
argument_list|,
name|sp
argument_list|,
operator|&
name|new
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|vs_split
argument_list|(
name|sp
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|screen_end
argument_list|(
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Attach to the screen. */
name|new
operator|->
name|ep
operator|=
name|gp
operator|->
name|ccl_sp
operator|->
name|ep
expr_stmt|;
operator|++
name|new
operator|->
name|ep
operator|->
name|refcnt
expr_stmt|;
name|new
operator|->
name|frp
operator|=
name|gp
operator|->
name|ccl_sp
operator|->
name|frp
expr_stmt|;
name|new
operator|->
name|frp
operator|->
name|flags
operator|=
name|sp
operator|->
name|frp
operator|->
name|flags
expr_stmt|;
comment|/* Move the cursor to the end. */
operator|(
name|void
operator|)
name|db_last
argument_list|(
name|new
argument_list|,
operator|&
name|new
operator|->
name|lno
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|lno
operator|==
literal|0
condition|)
name|new
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
comment|/* Remember the originating window. */
name|sp
operator|->
name|ccl_parent
operator|=
name|sp
expr_stmt|;
comment|/* It's a special window. */
name|F_SET
argument_list|(
name|new
argument_list|,
name|SC_COMEDIT
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_WIDECHAR
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_ICONV
argument_list|)
comment|/* Bypass iconv on writing to DB. */
name|o_set
argument_list|(
name|new
argument_list|,
name|O_FILEENCODING
argument_list|,
name|OS_STRDUP
argument_list|,
name|codeset
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set up the switch. */
name|sp
operator|->
name|nextdisp
operator|=
name|new
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SSWITCH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_ecl_exec --  *	Execute a command from a colon command-line window.  *  * PUBLIC: int v_ecl_exec __P((SCR *));  */
end_comment

begin_function
name|int
name|v_ecl_exec
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|CHAR_T
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|db_get
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
operator|&&
name|sp
operator|->
name|lno
operator|==
literal|1
condition|)
block|{
name|v_emsg
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|VIM_EMPTY
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"307|No ex command to execute"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Push the command on the command stack. */
if|if
condition|(
name|ex_run_str
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Set up the switch. */
name|sp
operator|->
name|nextdisp
operator|=
name|sp
operator|->
name|ccl_parent
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_EXIT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_ecl_log --  *	Log a command into the colon command-line log file.  */
end_comment

begin_function
specifier|static
name|int
name|v_ecl_log
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|TEXT
modifier|*
name|tp
parameter_list|)
block|{
name|recno_t
name|lno
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|CHAR_T
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|SCR
modifier|*
name|ccl_sp
decl_stmt|;
comment|/* Initialize the screen, if necessary. */
if|if
condition|(
name|sp
operator|->
name|gp
operator|->
name|ccl_sp
operator|==
name|NULL
operator|&&
name|v_ecl_init
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ccl_sp
operator|=
name|sp
operator|->
name|gp
operator|->
name|ccl_sp
expr_stmt|;
comment|/* 	 * Don't log colon command window commands into the colon command 	 * window... 	 */
if|if
condition|(
name|sp
operator|->
name|ep
operator|==
name|ccl_sp
operator|->
name|ep
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|db_last
argument_list|(
name|ccl_sp
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Don't log line that is identical to previous one */
if|if
condition|(
name|lno
operator|>
literal|0
operator|&&
operator|!
name|db_get
argument_list|(
name|ccl_sp
argument_list|,
name|lno
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
operator|&&
name|len
operator|==
name|tp
operator|->
name|len
operator|&&
operator|!
name|MEMCMP
argument_list|(
name|tp
operator|->
name|lb
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
condition|)
name|rval
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|rval
operator|=
name|db_append
argument_list|(
name|ccl_sp
argument_list|,
literal|0
argument_list|,
name|lno
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* XXXX end "transaction" on ccl */
comment|/* Is this still necessary now that we no longer hijack sp ? */
name|log_cursor
argument_list|(
name|ccl_sp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_ecl_init --  *	Initialize the colon command-line log file.  */
end_comment

begin_function
specifier|static
name|int
name|v_ecl_init
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|FREF
modifier|*
name|frp
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
comment|/* Get a temporary file. */
if|if
condition|(
operator|(
name|frp
operator|=
name|file_add
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * XXX 	 * Create a screen -- the file initialization code wants one. 	 */
if|if
condition|(
name|screen_init
argument_list|(
name|gp
argument_list|,
name|sp
argument_list|,
operator|&
name|gp
operator|->
name|ccl_sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|file_init
argument_list|(
name|gp
operator|->
name|ccl_sp
argument_list|,
name|frp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|screen_end
argument_list|(
name|gp
operator|->
name|ccl_sp
argument_list|)
expr_stmt|;
name|gp
operator|->
name|ccl_sp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* The underlying file isn't recoverable. */
name|F_CLR
argument_list|(
name|gp
operator|->
name|ccl_sp
operator|->
name|ep
argument_list|,
name|F_RCV_ON
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

