begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)vs_smap.c	10.25 (Berkeley) 7/12/96"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"../common/common.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|vs_deleteln
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vs_insertln
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vs_sm_delete
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|recno_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vs_sm_down
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|MARK
operator|*
operator|,
name|recno_t
operator|,
name|scroll_t
operator|,
name|SMAP
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vs_sm_erase
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vs_sm_insert
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|recno_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vs_sm_reset
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|recno_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vs_sm_up
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|MARK
operator|*
operator|,
name|recno_t
operator|,
name|scroll_t
operator|,
name|SMAP
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * vs_change --  *	Make a change to the screen.  *  * PUBLIC: int vs_change __P((SCR *, recno_t, lnop_t));  */
end_comment

begin_function
name|int
name|vs_change
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|,
name|op
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|lnop_t
name|op
decl_stmt|;
block|{
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
name|SMAP
modifier|*
name|p
decl_stmt|;
name|size_t
name|cnt
decl_stmt|,
name|oldy
decl_stmt|,
name|oldx
decl_stmt|;
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * XXX 	 * Very nasty special case.  The historic vi code displays a single 	 * space (or a '$' if the list option is set) for the first line in 	 * an "empty" file.  If we "insert" a line, that line gets scrolled 	 * down, not repainted, so it's incorrect when we refresh the screen. 	 * The vi text input functions detect it explicitly and don't insert 	 * a new line. 	 * 	 * Check for line #2 before going to the end of the file. 	 */
if|if
condition|(
operator|(
name|op
operator|==
name|LINE_APPEND
operator|&&
name|lno
operator|==
literal|0
operator|||
name|op
operator|==
name|LINE_INSERT
operator|&&
name|lno
operator|==
literal|1
operator|)
operator|&&
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|lno
operator|=
literal|1
expr_stmt|;
name|op
operator|=
name|LINE_RESET
expr_stmt|;
block|}
comment|/* Appending is the same as inserting, if the line is incremented. */
if|if
condition|(
name|op
operator|==
name|LINE_APPEND
condition|)
block|{
operator|++
name|lno
expr_stmt|;
name|op
operator|=
name|LINE_INSERT
expr_stmt|;
block|}
comment|/* Ignore the change if the line is after the map. */
if|if
condition|(
name|lno
operator|>
name|TMAP
operator|->
name|lno
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If the line is before the map, and it's a decrement, decrement 	 * the map.  If it's an increment, increment the map.  Otherwise, 	 * ignore it. 	 */
if|if
condition|(
name|lno
operator|<
name|HMAP
operator|->
name|lno
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|LINE_APPEND
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|LINE_DELETE
case|:
for|for
control|(
name|p
operator|=
name|HMAP
operator|,
name|cnt
operator|=
name|sp
operator|->
name|t_rows
init|;
name|cnt
operator|--
condition|;
operator|++
name|p
control|)
operator|--
name|p
operator|->
name|lno
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|lno
operator|>=
name|lno
condition|)
operator|--
name|sp
operator|->
name|lno
expr_stmt|;
name|F_SET
argument_list|(
name|vip
argument_list|,
name|VIP_N_RENUMBER
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINE_INSERT
case|:
for|for
control|(
name|p
operator|=
name|HMAP
operator|,
name|cnt
operator|=
name|sp
operator|->
name|t_rows
init|;
name|cnt
operator|--
condition|;
operator|++
name|p
control|)
operator|++
name|p
operator|->
name|lno
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|lno
operator|>=
name|lno
condition|)
operator|++
name|sp
operator|->
name|lno
expr_stmt|;
name|F_SET
argument_list|(
name|vip
argument_list|,
name|VIP_N_RENUMBER
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINE_RESET
case|:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|F_SET
argument_list|(
name|vip
argument_list|,
name|VIP_N_REFRESH
argument_list|)
expr_stmt|;
comment|/* 	 * Invalidate the line size cache, and invalidate the cursor if it's 	 * on this line, 	 */
name|VI_SCR_CFLUSH
argument_list|(
name|vip
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|lno
operator|==
name|lno
condition|)
name|F_SET
argument_list|(
name|vip
argument_list|,
name|VIP_CUR_INVALID
argument_list|)
expr_stmt|;
comment|/* 	 * If ex modifies the screen after ex output is already on the screen 	 * or if we've switched into ex canonical mode, don't touch it -- we'll 	 * get scrolling wrong, at best. 	 */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_TINPUT_INFO
argument_list|)
operator|&&
operator|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EXWROTE
argument_list|)
operator|||
name|VIP
argument_list|(
name|sp
argument_list|)
operator|->
name|totalcount
operator|>
literal|1
operator|)
condition|)
block|{
name|F_SET
argument_list|(
name|vip
argument_list|,
name|VIP_N_EX_REDRAW
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Save and restore the cursor for these routines. */
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_cursor
argument_list|(
name|sp
argument_list|,
operator|&
name|oldy
argument_list|,
operator|&
name|oldx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|LINE_DELETE
case|:
if|if
condition|(
name|vs_sm_delete
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|vip
argument_list|,
name|VIP_N_RENUMBER
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINE_INSERT
case|:
if|if
condition|(
name|vs_sm_insert
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|vip
argument_list|,
name|VIP_N_RENUMBER
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINE_RESET
case|:
if|if
condition|(
name|vs_sm_reset
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_sm_fill --  *	Fill in the screen map, placing the specified line at the  *	right position.  There isn't any way to tell if an SMAP  *	entry has been filled in, so this routine had better be  *	called with P_FILL set before anything else is done.  *  * !!!  * Unexported interface: if lno is OOBLNO, P_TOP means that the HMAP  * slot is already filled in, P_BOTTOM means that the TMAP slot is  * already filled in, and we just finish up the job.  *  * PUBLIC: int vs_sm_fill __P((SCR *, recno_t, pos_t));  */
end_comment

begin_function
name|int
name|vs_sm_fill
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|,
name|pos
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|pos_t
name|pos
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
name|tmp
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
comment|/* Flush all cached information from the SMAP. */
for|for
control|(
name|p
operator|=
name|HMAP
operator|,
name|cnt
operator|=
name|sp
operator|->
name|t_rows
init|;
name|cnt
operator|--
condition|;
operator|++
name|p
control|)
name|SMAP_FLUSH
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * If the map is filled, the screen must be redrawn. 	 * 	 * XXX 	 * This is a bug.  We should try and figure out if the desired line 	 * is already in the map or close by -- scrolling the screen would 	 * be a lot better than redrawing. 	 */
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REDRAW
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pos
condition|)
block|{
case|case
name|P_FILL
case|:
name|tmp
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
name|tmp
operator|.
name|coff
operator|=
literal|0
expr_stmt|;
name|tmp
operator|.
name|soff
operator|=
literal|1
expr_stmt|;
comment|/* See if less than half a screen from the top. */
if|if
condition|(
name|vs_sm_nlines
argument_list|(
name|sp
argument_list|,
operator|&
name|tmp
argument_list|,
name|lno
argument_list|,
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|<=
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|lno
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
comment|/* See if less than half a screen from the bottom. */
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|tmp
operator|.
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tmp
operator|.
name|coff
operator|=
literal|0
expr_stmt|;
name|tmp
operator|.
name|soff
operator|=
name|vs_screens
argument_list|(
name|sp
argument_list|,
name|tmp
operator|.
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs_sm_nlines
argument_list|(
name|sp
argument_list|,
operator|&
name|tmp
argument_list|,
name|lno
argument_list|,
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|<=
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|TMAP
operator|->
name|lno
operator|=
name|tmp
operator|.
name|lno
expr_stmt|;
name|TMAP
operator|->
name|coff
operator|=
name|tmp
operator|.
name|coff
expr_stmt|;
name|TMAP
operator|->
name|soff
operator|=
name|tmp
operator|.
name|soff
expr_stmt|;
goto|goto
name|bottom
goto|;
block|}
goto|goto
name|middle
goto|;
case|case
name|P_TOP
case|:
if|if
condition|(
name|lno
operator|!=
name|OOBLNO
condition|)
block|{
name|top
label|:
name|HMAP
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|HMAP
operator|->
name|coff
operator|=
literal|0
expr_stmt|;
name|HMAP
operator|->
name|soff
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we fail, just punt. */
for|for
control|(
name|p
operator|=
name|HMAP
operator|,
name|cnt
operator|=
name|sp
operator|->
name|t_rows
init|;
operator|--
name|cnt
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|vs_sm_next
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
break|break;
case|case
name|P_MIDDLE
case|:
comment|/* If we fail, guess that the file is too small. */
name|middle
label|:
name|p
operator|=
name|HMAP
operator|+
name|sp
operator|->
name|t_rows
operator|/
literal|2
expr_stmt|;
name|p
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|p
operator|->
name|coff
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|soff
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|p
operator|>
name|HMAP
condition|;
operator|--
name|p
control|)
if|if
condition|(
name|vs_sm_prev
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|p
operator|-
literal|1
argument_list|)
condition|)
block|{
name|lno
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
comment|/* If we fail, just punt. */
name|p
operator|=
name|HMAP
operator|+
name|sp
operator|->
name|t_rows
operator|/
literal|2
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|TMAP
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|vs_sm_next
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
break|break;
case|case
name|P_BOTTOM
case|:
if|if
condition|(
name|lno
operator|!=
name|OOBLNO
condition|)
block|{
name|TMAP
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|TMAP
operator|->
name|coff
operator|=
literal|0
expr_stmt|;
name|TMAP
operator|->
name|soff
operator|=
name|vs_screens
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* If we fail, guess that the file is too small. */
name|bottom
label|:
for|for
control|(
name|p
operator|=
name|TMAP
init|;
name|p
operator|>
name|HMAP
condition|;
operator|--
name|p
control|)
if|if
condition|(
name|vs_sm_prev
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|p
operator|-
literal|1
argument_list|)
condition|)
block|{
name|lno
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Try and put *something* on the screen.  If this fails, we have a 	 * serious hard error. 	 */
name|err
label|:
name|HMAP
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
name|HMAP
operator|->
name|coff
operator|=
literal|0
expr_stmt|;
name|HMAP
operator|->
name|soff
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|<
name|TMAP
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|vs_sm_next
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For the routines vs_sm_reset, vs_sm_delete and vs_sm_insert: if the  * screen contains only a single line (whether because the screen is small  * or the line large), it gets fairly exciting.  Skip the fun, set a flag  * so the screen map is refilled and the screen redrawn, and return.  This  * is amazingly slow, but it's not clear that anyone will care.  */
end_comment

begin_define
define|#
directive|define
name|HANDLE_WEIRDNESS
parameter_list|(
name|cnt
parameter_list|)
value|{						\ 	if (cnt>= sp->t_rows) {					\ 		F_SET(sp, SC_SCR_REFORMAT);				\ 		return (0);						\ 	}								\ }
end_define

begin_comment
comment|/*  * vs_sm_delete --  *	Delete a line out of the SMAP.  */
end_comment

begin_function
specifier|static
name|int
name|vs_sm_delete
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|size_t
name|cnt_orig
decl_stmt|;
comment|/* 	 * Find the line in the map, and count the number of screen lines 	 * which display any part of the deleted line. 	 */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|->
name|lno
operator|!=
name|lno
condition|;
operator|++
name|p
control|)
empty_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
name|cnt_orig
operator|=
literal|1
expr_stmt|;
else|else
for|for
control|(
name|cnt_orig
operator|=
literal|1
operator|,
name|t
operator|=
name|p
operator|+
literal|1
init|;
name|t
operator|<=
name|TMAP
operator|&&
name|t
operator|->
name|lno
operator|==
name|lno
condition|;
operator|++
name|cnt_orig
operator|,
operator|++
name|t
control|)
empty_stmt|;
name|HANDLE_WEIRDNESS
argument_list|(
name|cnt_orig
argument_list|)
expr_stmt|;
comment|/* Delete that many lines from the screen. */
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|p
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs_deleteln
argument_list|(
name|sp
argument_list|,
name|cnt_orig
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Shift the screen map up. */
name|memmove
argument_list|(
name|p
argument_list|,
name|p
operator|+
name|cnt_orig
argument_list|,
operator|(
operator|(
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|-
name|cnt_orig
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Decrement the line numbers for the rest of the map. */
for|for
control|(
name|t
operator|=
name|TMAP
operator|-
name|cnt_orig
init|;
name|p
operator|<=
name|t
condition|;
operator|++
name|p
control|)
operator|--
name|p
operator|->
name|lno
expr_stmt|;
comment|/* Display the new lines. */
for|for
control|(
name|p
operator|=
name|TMAP
operator|-
name|cnt_orig
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|<
name|TMAP
operator|&&
name|vs_sm_next
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* vs_sm_next() flushed the cache. */
if|if
condition|(
name|vs_line
argument_list|(
name|sp
argument_list|,
operator|++
name|p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|==
name|TMAP
condition|)
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_sm_insert --  *	Insert a line into the SMAP.  */
end_comment

begin_function
specifier|static
name|int
name|vs_sm_insert
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|size_t
name|cnt_orig
decl_stmt|,
name|cnt
decl_stmt|,
name|coff
decl_stmt|;
comment|/* Save the offset. */
name|coff
operator|=
name|HMAP
operator|->
name|coff
expr_stmt|;
comment|/* 	 * Find the line in the map, find out how many screen lines 	 * needed to display the line. 	 */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|->
name|lno
operator|!=
name|lno
condition|;
operator|++
name|p
control|)
empty_stmt|;
name|cnt_orig
operator|=
name|vs_screens
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|HANDLE_WEIRDNESS
argument_list|(
name|cnt_orig
argument_list|)
expr_stmt|;
comment|/* 	 * The lines left in the screen override the number of screen 	 * lines in the inserted line. 	 */
name|cnt
operator|=
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cnt_orig
operator|>
name|cnt
condition|)
name|cnt_orig
operator|=
name|cnt
expr_stmt|;
comment|/* Push down that many lines. */
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|p
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs_insertln
argument_list|(
name|sp
argument_list|,
name|cnt_orig
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Shift the screen map down. */
name|memmove
argument_list|(
name|p
operator|+
name|cnt_orig
argument_list|,
name|p
argument_list|,
operator|(
operator|(
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|-
name|cnt_orig
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Increment the line numbers for the rest of the map. */
for|for
control|(
name|t
operator|=
name|p
operator|+
name|cnt_orig
init|;
name|t
operator|<=
name|TMAP
condition|;
operator|++
name|t
control|)
operator|++
name|t
operator|->
name|lno
expr_stmt|;
comment|/* Fill in the SMAP for the new lines, and display. */
for|for
control|(
name|cnt
operator|=
literal|1
operator|,
name|t
operator|=
name|p
init|;
name|cnt
operator|<=
name|cnt_orig
condition|;
operator|++
name|t
operator|,
operator|++
name|cnt
control|)
block|{
name|t
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|t
operator|->
name|coff
operator|=
name|coff
expr_stmt|;
name|t
operator|->
name|soff
operator|=
name|cnt
expr_stmt|;
name|SMAP_FLUSH
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs_line
argument_list|(
name|sp
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_sm_reset --  *	Reset a line in the SMAP.  */
end_comment

begin_function
specifier|static
name|int
name|vs_sm_reset
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|size_t
name|cnt_orig
decl_stmt|,
name|cnt_new
decl_stmt|,
name|cnt
decl_stmt|,
name|diff
decl_stmt|;
comment|/* 	 * See if the number of on-screen rows taken up by the old display 	 * for the line is the same as the number needed for the new one. 	 * If so, repaint, otherwise do it the hard way. 	 */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|->
name|lno
operator|!=
name|lno
condition|;
operator|++
name|p
control|)
empty_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
block|{
name|t
operator|=
name|p
expr_stmt|;
name|cnt_orig
operator|=
name|cnt_new
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|cnt_orig
operator|=
literal|0
operator|,
name|t
operator|=
name|p
init|;
name|t
operator|<=
name|TMAP
operator|&&
name|t
operator|->
name|lno
operator|==
name|lno
condition|;
operator|++
name|cnt_orig
operator|,
operator|++
name|t
control|)
empty_stmt|;
name|cnt_new
operator|=
name|vs_screens
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|HANDLE_WEIRDNESS
argument_list|(
name|cnt_orig
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt_orig
operator|==
name|cnt_new
condition|)
block|{
do|do
block|{
name|SMAP_FLUSH
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs_line
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
operator|++
name|p
operator|<
name|t
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cnt_orig
operator|<
name|cnt_new
condition|)
block|{
comment|/* Get the difference. */
name|diff
operator|=
name|cnt_new
operator|-
name|cnt_orig
expr_stmt|;
comment|/* 		 * The lines left in the screen override the number of screen 		 * lines in the inserted line. 		 */
name|cnt
operator|=
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|diff
operator|>
name|cnt
condition|)
name|diff
operator|=
name|cnt
expr_stmt|;
comment|/* If there are any following lines, push them down. */
if|if
condition|(
name|cnt
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|p
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs_insertln
argument_list|(
name|sp
argument_list|,
name|diff
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Shift the screen map down. */
name|memmove
argument_list|(
name|p
operator|+
name|diff
argument_list|,
name|p
argument_list|,
operator|(
operator|(
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|-
name|diff
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fill in the SMAP for the replaced line, and display. */
for|for
control|(
name|cnt
operator|=
literal|1
operator|,
name|t
operator|=
name|p
init|;
name|cnt_new
operator|--
operator|&&
name|t
operator|<=
name|TMAP
condition|;
operator|++
name|t
operator|,
operator|++
name|cnt
control|)
block|{
name|t
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|t
operator|->
name|soff
operator|=
name|cnt
expr_stmt|;
name|SMAP_FLUSH
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs_line
argument_list|(
name|sp
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Get the difference. */
name|diff
operator|=
name|cnt_orig
operator|-
name|cnt_new
expr_stmt|;
comment|/* Delete that many lines from the screen. */
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|p
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs_deleteln
argument_list|(
name|sp
argument_list|,
name|diff
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Shift the screen map up. */
name|memmove
argument_list|(
name|p
argument_list|,
name|p
operator|+
name|diff
argument_list|,
operator|(
operator|(
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|-
name|diff
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill in the SMAP for the replaced line, and display. */
for|for
control|(
name|cnt
operator|=
literal|1
operator|,
name|t
operator|=
name|p
init|;
name|cnt_new
operator|--
condition|;
operator|++
name|t
operator|,
operator|++
name|cnt
control|)
block|{
name|t
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|t
operator|->
name|soff
operator|=
name|cnt
expr_stmt|;
name|SMAP_FLUSH
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs_line
argument_list|(
name|sp
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Display the new lines at the bottom of the screen. */
for|for
control|(
name|t
operator|=
name|TMAP
operator|-
name|diff
init|;
condition|;
control|)
block|{
if|if
condition|(
name|t
operator|<
name|TMAP
operator|&&
name|vs_sm_next
argument_list|(
name|sp
argument_list|,
name|t
argument_list|,
name|t
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* vs_sm_next() flushed the cache. */
if|if
condition|(
name|vs_line
argument_list|(
name|sp
argument_list|,
operator|++
name|t
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|t
operator|==
name|TMAP
condition|)
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_sm_scroll  *	Scroll the SMAP up/down count logical lines.  Different  *	semantics based on the vi command, *sigh*.  *  * PUBLIC: int vs_sm_scroll __P((SCR *, MARK *, recno_t, scroll_t));  */
end_comment

begin_function
name|int
name|vs_sm_scroll
parameter_list|(
name|sp
parameter_list|,
name|rp
parameter_list|,
name|count
parameter_list|,
name|scmd
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|MARK
modifier|*
name|rp
decl_stmt|;
name|recno_t
name|count
decl_stmt|;
name|scroll_t
name|scmd
decl_stmt|;
block|{
name|SMAP
modifier|*
name|smp
decl_stmt|;
comment|/* 	 * Invalidate the cursor.  The line is probably going to change, 	 * (although for ^E and ^Y it may not).  In any case, the scroll 	 * routines move the cursor to draw things. 	 */
name|F_SET
argument_list|(
name|VIP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|VIP_CUR_INVALID
argument_list|)
expr_stmt|;
comment|/* Find the cursor in the screen. */
if|if
condition|(
name|vs_sm_cursor
argument_list|(
name|sp
argument_list|,
operator|&
name|smp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|scmd
condition|)
block|{
case|case
name|CNTRL_B
case|:
case|case
name|CNTRL_U
case|:
case|case
name|CNTRL_Y
case|:
case|case
name|Z_CARAT
case|:
if|if
condition|(
name|vs_sm_down
argument_list|(
name|sp
argument_list|,
name|rp
argument_list|,
name|count
argument_list|,
name|scmd
argument_list|,
name|smp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
name|CNTRL_D
case|:
case|case
name|CNTRL_E
case|:
case|case
name|CNTRL_F
case|:
case|case
name|Z_PLUS
case|:
if|if
condition|(
name|vs_sm_up
argument_list|(
name|sp
argument_list|,
name|rp
argument_list|,
name|count
argument_list|,
name|scmd
argument_list|,
name|smp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * !!! 	 * If we're at the start of a line, go for the first non-blank. 	 * This makes it look like the old vi, even though we're moving 	 * around by logical lines, not physical ones. 	 * 	 * XXX 	 * In the presence of a long line, which has more than a screen 	 * width of leading spaces, this code can cause a cursor warp. 	 * Live with it. 	 */
if|if
condition|(
name|scmd
operator|!=
name|CNTRL_E
operator|&&
name|scmd
operator|!=
name|CNTRL_Y
operator|&&
name|rp
operator|->
name|cno
operator|==
literal|0
operator|&&
name|nonblank
argument_list|(
name|sp
argument_list|,
name|rp
operator|->
name|lno
argument_list|,
operator|&
name|rp
operator|->
name|cno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_sm_up --  *	Scroll the SMAP up count logical lines.  */
end_comment

begin_function
specifier|static
name|int
name|vs_sm_up
parameter_list|(
name|sp
parameter_list|,
name|rp
parameter_list|,
name|count
parameter_list|,
name|scmd
parameter_list|,
name|smp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|MARK
modifier|*
name|rp
decl_stmt|;
name|scroll_t
name|scmd
decl_stmt|;
name|recno_t
name|count
decl_stmt|;
name|SMAP
modifier|*
name|smp
decl_stmt|;
block|{
name|int
name|cursor_set
decl_stmt|,
name|echanged
decl_stmt|,
name|zset
decl_stmt|;
name|SMAP
modifier|*
name|ssmp
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|;
comment|/* 	 * Check to see if movement is possible. 	 * 	 * Get the line after the map.  If that line is a new one (and if 	 * O_LEFTRIGHT option is set, this has to be true), and the next 	 * line doesn't exist, and the cursor doesn't move, or the cursor 	 * isn't even on the screen, or the cursor is already at the last 	 * line in the map, it's an error.  If that test succeeded because 	 * the cursor wasn't at the end of the map, test to see if the map 	 * is mostly empty. 	 */
if|if
condition|(
name|vs_sm_next
argument_list|(
name|sp
argument_list|,
name|TMAP
argument_list|,
operator|&
name|s1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|s1
operator|.
name|lno
operator|>
name|TMAP
operator|->
name|lno
operator|&&
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
name|s1
operator|.
name|lno
argument_list|)
condition|)
block|{
if|if
condition|(
name|scmd
operator|==
name|CNTRL_E
operator|||
name|scmd
operator|==
name|Z_PLUS
operator|||
name|smp
operator|==
name|TMAP
condition|)
block|{
name|v_eof
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|vs_sm_next
argument_list|(
name|sp
argument_list|,
name|smp
argument_list|,
operator|&
name|s1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|s1
operator|.
name|lno
operator|>
name|smp
operator|->
name|lno
operator|&&
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
name|s1
operator|.
name|lno
argument_list|)
condition|)
block|{
name|v_eof
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * Small screens: see vs_refresh.c section 6a. 	 * 	 * If it's a small screen, and the movement isn't larger than a 	 * screen, i.e some context will remain, open up the screen and 	 * display by scrolling.  In this case, the cursor moves down one 	 * line for each line displayed.  Otherwise, erase/compress and 	 * repaint, and move the cursor to the first line in the screen. 	 * Note, the ^F command is always in the latter case, for historical 	 * reasons. 	 */
name|cursor_set
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_SMALL
argument_list|(
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|count
operator|>=
name|sp
operator|->
name|t_maxrows
operator|||
name|scmd
operator|==
name|CNTRL_F
condition|)
block|{
name|s1
operator|=
name|TMAP
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|vs_sm_erase
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
init|;
name|count
operator|--
condition|;
name|s1
operator|=
name|s2
control|)
block|{
if|if
condition|(
name|vs_sm_next
argument_list|(
name|sp
argument_list|,
operator|&
name|s1
argument_list|,
operator|&
name|s2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|s2
operator|.
name|lno
operator|!=
name|s1
operator|.
name|lno
operator|&&
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
name|s2
operator|.
name|lno
argument_list|)
condition|)
break|break;
block|}
name|TMAP
index|[
literal|0
index|]
operator|=
name|s2
expr_stmt|;
if|if
condition|(
name|vs_sm_fill
argument_list|(
name|sp
argument_list|,
name|OOBLNO
argument_list|,
name|P_BOTTOM
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|vs_sm_position
argument_list|(
name|sp
argument_list|,
name|rp
argument_list|,
literal|0
argument_list|,
name|P_TOP
argument_list|)
operator|)
return|;
block|}
name|cursor_set
operator|=
name|scmd
operator|==
name|CNTRL_E
operator|||
name|vs_sm_cursor
argument_list|(
name|sp
argument_list|,
operator|&
name|ssmp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|count
operator|&&
name|sp
operator|->
name|t_rows
operator|!=
name|sp
operator|->
name|t_maxrows
condition|;
operator|--
name|count
operator|,
operator|++
name|sp
operator|->
name|t_rows
control|)
block|{
if|if
condition|(
name|vs_sm_next
argument_list|(
name|sp
argument_list|,
name|TMAP
argument_list|,
operator|&
name|s1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|TMAP
operator|->
name|lno
operator|!=
name|s1
operator|.
name|lno
operator|&&
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
name|s1
operator|.
name|lno
argument_list|)
condition|)
break|break;
operator|*
operator|++
name|TMAP
operator|=
name|s1
expr_stmt|;
comment|/* vs_sm_next() flushed the cache. */
if|if
condition|(
name|vs_line
argument_list|(
name|sp
argument_list|,
name|TMAP
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|cursor_set
condition|)
operator|++
name|ssmp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cursor_set
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
name|ssmp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|ssmp
operator|->
name|c_sboff
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|echanged
operator|=
name|zset
operator|=
literal|0
init|;
name|count
condition|;
operator|--
name|count
control|)
block|{
comment|/* Decide what would show up on the screen. */
if|if
condition|(
name|vs_sm_next
argument_list|(
name|sp
argument_list|,
name|TMAP
argument_list|,
operator|&
name|s1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* If the line doesn't exist, we're done. */
if|if
condition|(
name|TMAP
operator|->
name|lno
operator|!=
name|s1
operator|.
name|lno
operator|&&
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
name|s1
operator|.
name|lno
argument_list|)
condition|)
break|break;
comment|/* Scroll the screen cursor up one logical line. */
if|if
condition|(
name|vs_sm_1up
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|scmd
condition|)
block|{
case|case
name|CNTRL_E
case|:
if|if
condition|(
name|smp
operator|>
name|HMAP
condition|)
operator|--
name|smp
expr_stmt|;
else|else
name|echanged
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Z_PLUS
case|:
if|if
condition|(
name|zset
condition|)
block|{
if|if
condition|(
name|smp
operator|>
name|HMAP
condition|)
operator|--
name|smp
expr_stmt|;
block|}
else|else
block|{
name|smp
operator|=
name|TMAP
expr_stmt|;
name|zset
operator|=
literal|1
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|cursor_set
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|scmd
condition|)
block|{
case|case
name|CNTRL_E
case|:
comment|/* 		 * On a ^E that was forced to change lines, try and keep the 		 * cursor as close as possible to the last position, but also 		 * set it up so that the next "real" movement will return the 		 * cursor to the closest position to the last real movement. 		 */
if|if
condition|(
name|echanged
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
name|smp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|vs_colpos
argument_list|(
name|sp
argument_list|,
name|smp
operator|->
name|lno
argument_list|,
operator|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|?
name|smp
operator|->
name|coff
else|:
operator|(
name|smp
operator|->
name|soff
operator|-
literal|1
operator|)
operator|*
name|sp
operator|->
name|cols
operator|)
operator|+
name|sp
operator|->
name|rcm
operator|%
name|sp
operator|->
name|cols
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CNTRL_F
case|:
comment|/* 		 * If there are more lines, the ^F command is positioned at 		 * the first line of the screen. 		 */
if|if
condition|(
operator|!
name|count
condition|)
block|{
name|smp
operator|=
name|HMAP
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|CNTRL_D
case|:
comment|/* 		 * The ^D and ^F commands move the cursor towards EOF 		 * if there are more lines to move.  Check to be sure 		 * the lines actually exist.  (They may not if the 		 * file is smaller than the screen.) 		 */
for|for
control|(
init|;
name|count
condition|;
operator|--
name|count
operator|,
operator|++
name|smp
control|)
if|if
condition|(
name|smp
operator|==
name|TMAP
operator|||
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
name|smp
index|[
literal|1
index|]
operator|.
name|lno
argument_list|)
condition|)
break|break;
break|break;
case|case
name|Z_PLUS
case|:
comment|/* The z+ command moves the cursor to the first new line. */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SMAP_CACHE
argument_list|(
name|smp
argument_list|)
operator|&&
name|vs_line
argument_list|(
name|sp
argument_list|,
name|smp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|rp
operator|->
name|lno
operator|=
name|smp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|smp
operator|->
name|c_scoff
operator|==
literal|255
condition|?
literal|0
else|:
name|smp
operator|->
name|c_sboff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_sm_1up --  *	Scroll the SMAP up one.  *  * PUBLIC: int vs_sm_1up __P((SCR *));  */
end_comment

begin_function
name|int
name|vs_sm_1up
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
comment|/* 	 * Delete the top line of the screen.  Shift the screen map 	 * up and display a new line at the bottom of the screen. 	 */
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs_deleteln
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* One-line screens can fail. */
if|if
condition|(
name|IS_ONELINE
argument_list|(
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|vs_sm_next
argument_list|(
name|sp
argument_list|,
name|TMAP
argument_list|,
name|TMAP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|memmove
argument_list|(
name|HMAP
argument_list|,
name|HMAP
operator|+
literal|1
argument_list|,
operator|(
name|sp
operator|->
name|rows
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs_sm_next
argument_list|(
name|sp
argument_list|,
name|TMAP
operator|-
literal|1
argument_list|,
name|TMAP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* vs_sm_next() flushed the cache. */
return|return
operator|(
name|vs_line
argument_list|(
name|sp
argument_list|,
name|TMAP
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_deleteln --  *	Delete a line a la curses, make sure to put the information  *	line and other screens back.  */
end_comment

begin_function
specifier|static
name|int
name|vs_deleteln
parameter_list|(
name|sp
parameter_list|,
name|cnt
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|size_t
name|oldy
decl_stmt|,
name|oldx
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
if|if
condition|(
name|IS_ONELINE
argument_list|(
name|sp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_clrtoeol
argument_list|(
name|sp
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_cursor
argument_list|(
name|sp
argument_list|,
operator|&
name|oldy
argument_list|,
operator|&
name|oldx
argument_list|)
expr_stmt|;
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_deleteln
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_insertln
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_sm_down --  *	Scroll the SMAP down count logical lines.  */
end_comment

begin_function
specifier|static
name|int
name|vs_sm_down
parameter_list|(
name|sp
parameter_list|,
name|rp
parameter_list|,
name|count
parameter_list|,
name|scmd
parameter_list|,
name|smp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|MARK
modifier|*
name|rp
decl_stmt|;
name|recno_t
name|count
decl_stmt|;
name|SMAP
modifier|*
name|smp
decl_stmt|;
name|scroll_t
name|scmd
decl_stmt|;
block|{
name|SMAP
modifier|*
name|ssmp
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|;
name|int
name|cursor_set
decl_stmt|,
name|ychanged
decl_stmt|,
name|zset
decl_stmt|;
comment|/* Check to see if movement is possible. */
if|if
condition|(
name|HMAP
operator|->
name|lno
operator|==
literal|1
operator|&&
operator|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
operator|||
name|HMAP
operator|->
name|soff
operator|==
literal|1
operator|)
operator|&&
operator|(
name|scmd
operator|==
name|CNTRL_Y
operator|||
name|scmd
operator|==
name|Z_CARAT
operator|||
name|smp
operator|==
name|HMAP
operator|)
condition|)
block|{
name|v_sof
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Small screens: see vs_refresh.c section 6a. 	 * 	 * If it's a small screen, and the movement isn't larger than a 	 * screen, i.e some context will remain, open up the screen and 	 * display by scrolling.  In this case, the cursor moves up one 	 * line for each line displayed.  Otherwise, erase/compress and 	 * repaint, and move the cursor to the first line in the screen. 	 * Note, the ^B command is always in the latter case, for historical 	 * reasons. 	 */
name|cursor_set
operator|=
name|scmd
operator|==
name|CNTRL_Y
expr_stmt|;
if|if
condition|(
name|IS_SMALL
argument_list|(
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|count
operator|>=
name|sp
operator|->
name|t_maxrows
operator|||
name|scmd
operator|==
name|CNTRL_B
condition|)
block|{
name|s1
operator|=
name|HMAP
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|vs_sm_erase
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
init|;
name|count
operator|--
condition|;
name|s1
operator|=
name|s2
control|)
block|{
if|if
condition|(
name|vs_sm_prev
argument_list|(
name|sp
argument_list|,
operator|&
name|s1
argument_list|,
operator|&
name|s2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|s2
operator|.
name|lno
operator|==
literal|1
operator|&&
operator|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
operator|||
name|s2
operator|.
name|soff
operator|==
literal|1
operator|)
condition|)
break|break;
block|}
name|HMAP
index|[
literal|0
index|]
operator|=
name|s2
expr_stmt|;
if|if
condition|(
name|vs_sm_fill
argument_list|(
name|sp
argument_list|,
name|OOBLNO
argument_list|,
name|P_TOP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|vs_sm_position
argument_list|(
name|sp
argument_list|,
name|rp
argument_list|,
literal|0
argument_list|,
name|P_BOTTOM
argument_list|)
operator|)
return|;
block|}
name|cursor_set
operator|=
name|scmd
operator|==
name|CNTRL_Y
operator|||
name|vs_sm_cursor
argument_list|(
name|sp
argument_list|,
operator|&
name|ssmp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|count
operator|&&
name|sp
operator|->
name|t_rows
operator|!=
name|sp
operator|->
name|t_maxrows
condition|;
operator|--
name|count
operator|,
operator|++
name|sp
operator|->
name|t_rows
control|)
block|{
if|if
condition|(
name|HMAP
operator|->
name|lno
operator|==
literal|1
operator|&&
operator|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
operator|||
name|HMAP
operator|->
name|soff
operator|==
literal|1
operator|)
condition|)
break|break;
operator|++
name|TMAP
expr_stmt|;
if|if
condition|(
name|vs_sm_1down
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|cursor_set
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
name|ssmp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|ssmp
operator|->
name|c_sboff
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|ychanged
operator|=
name|zset
operator|=
literal|0
init|;
name|count
condition|;
operator|--
name|count
control|)
block|{
comment|/* If the line doesn't exist, we're done. */
if|if
condition|(
name|HMAP
operator|->
name|lno
operator|==
literal|1
operator|&&
operator|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
operator|||
name|HMAP
operator|->
name|soff
operator|==
literal|1
operator|)
condition|)
break|break;
comment|/* Scroll the screen and cursor down one logical line. */
if|if
condition|(
name|vs_sm_1down
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|scmd
condition|)
block|{
case|case
name|CNTRL_Y
case|:
if|if
condition|(
name|smp
operator|<
name|TMAP
condition|)
operator|++
name|smp
expr_stmt|;
else|else
name|ychanged
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Z_CARAT
case|:
if|if
condition|(
name|zset
condition|)
block|{
if|if
condition|(
name|smp
operator|<
name|TMAP
condition|)
operator|++
name|smp
expr_stmt|;
block|}
else|else
block|{
name|smp
operator|=
name|HMAP
expr_stmt|;
name|zset
operator|=
literal|1
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|scmd
operator|!=
name|CNTRL_Y
operator|&&
name|cursor_set
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|scmd
condition|)
block|{
case|case
name|CNTRL_B
case|:
comment|/* 		 * If there are more lines, the ^B command is positioned at 		 * the last line of the screen.  However, the line may not 		 * exist. 		 */
if|if
condition|(
operator|!
name|count
condition|)
block|{
for|for
control|(
name|smp
operator|=
name|TMAP
init|;
name|smp
operator|>
name|HMAP
condition|;
operator|--
name|smp
control|)
if|if
condition|(
name|db_exist
argument_list|(
name|sp
argument_list|,
name|smp
operator|->
name|lno
argument_list|)
condition|)
break|break;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|CNTRL_U
case|:
comment|/* 		 * The ^B and ^U commands move the cursor towards SOF 		 * if there are more lines to move. 		 */
if|if
condition|(
name|count
operator|<
name|smp
operator|-
name|HMAP
condition|)
name|smp
operator|-=
name|count
expr_stmt|;
else|else
name|smp
operator|=
name|HMAP
expr_stmt|;
break|break;
case|case
name|CNTRL_Y
case|:
comment|/* 		 * On a ^Y that was forced to change lines, try and keep the 		 * cursor as close as possible to the last position, but also 		 * set it up so that the next "real" movement will return the 		 * cursor to the closest position to the last real movement. 		 */
if|if
condition|(
name|ychanged
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
name|smp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|vs_colpos
argument_list|(
name|sp
argument_list|,
name|smp
operator|->
name|lno
argument_list|,
operator|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|?
name|smp
operator|->
name|coff
else|:
operator|(
name|smp
operator|->
name|soff
operator|-
literal|1
operator|)
operator|*
name|sp
operator|->
name|cols
operator|)
operator|+
name|sp
operator|->
name|rcm
operator|%
name|sp
operator|->
name|cols
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|Z_CARAT
case|:
comment|/* The z^ command moves the cursor to the first new line. */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SMAP_CACHE
argument_list|(
name|smp
argument_list|)
operator|&&
name|vs_line
argument_list|(
name|sp
argument_list|,
name|smp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|rp
operator|->
name|lno
operator|=
name|smp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|smp
operator|->
name|c_scoff
operator|==
literal|255
condition|?
literal|0
else|:
name|smp
operator|->
name|c_sboff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_sm_erase --  *	Erase the small screen area for the scrolling functions.  */
end_comment

begin_function
specifier|static
name|int
name|vs_sm_erase
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_clrtoeol
argument_list|(
name|sp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sp
operator|->
name|t_rows
operator|>
name|sp
operator|->
name|t_minrows
condition|;
operator|--
name|sp
operator|->
name|t_rows
operator|,
operator|--
name|TMAP
control|)
block|{
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|TMAP
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_clrtoeol
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_sm_1down --  *	Scroll the SMAP down one.  *  * PUBLIC: int vs_sm_1down __P((SCR *));  */
end_comment

begin_function
name|int
name|vs_sm_1down
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
comment|/* 	 * Insert a line at the top of the screen.  Shift the screen map 	 * down and display a new line at the top of the screen. 	 */
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs_insertln
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* One-line screens can fail. */
if|if
condition|(
name|IS_ONELINE
argument_list|(
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|vs_sm_prev
argument_list|(
name|sp
argument_list|,
name|HMAP
argument_list|,
name|HMAP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|memmove
argument_list|(
name|HMAP
operator|+
literal|1
argument_list|,
name|HMAP
argument_list|,
operator|(
name|sp
operator|->
name|rows
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs_sm_prev
argument_list|(
name|sp
argument_list|,
name|HMAP
operator|+
literal|1
argument_list|,
name|HMAP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* vs_sm_prev() flushed the cache. */
return|return
operator|(
name|vs_line
argument_list|(
name|sp
argument_list|,
name|HMAP
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_insertln --  *	Insert a line a la curses, make sure to put the information  *	line and other screens back.  */
end_comment

begin_function
specifier|static
name|int
name|vs_insertln
parameter_list|(
name|sp
parameter_list|,
name|cnt
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|size_t
name|oldy
decl_stmt|,
name|oldx
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
if|if
condition|(
name|IS_ONELINE
argument_list|(
name|sp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_clrtoeol
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_cursor
argument_list|(
name|sp
argument_list|,
operator|&
name|oldy
argument_list|,
operator|&
name|oldx
argument_list|)
expr_stmt|;
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_deleteln
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_insertln
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_sm_next --  *	Fill in the next entry in the SMAP.  *  * PUBLIC: int vs_sm_next __P((SCR *, SMAP *, SMAP *));  */
end_comment

begin_function
name|int
name|vs_sm_next
parameter_list|(
name|sp
parameter_list|,
name|p
parameter_list|,
name|t
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|SMAP
modifier|*
name|p
decl_stmt|,
decl|*
name|t
decl_stmt|;
end_function

begin_block
block|{
name|size_t
name|lcnt
decl_stmt|;
name|SMAP_FLUSH
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
operator|+
literal|1
expr_stmt|;
name|t
operator|->
name|coff
operator|=
name|p
operator|->
name|coff
expr_stmt|;
block|}
else|else
block|{
name|lcnt
operator|=
name|vs_screens
argument_list|(
name|sp
argument_list|,
name|p
operator|->
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|==
name|p
operator|->
name|soff
condition|)
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
operator|+
literal|1
expr_stmt|;
name|t
operator|->
name|soff
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
expr_stmt|;
name|t
operator|->
name|soff
operator|=
name|p
operator|->
name|soff
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * vs_sm_prev --  *	Fill in the previous entry in the SMAP.  *  * PUBLIC: int vs_sm_prev __P((SCR *, SMAP *, SMAP *));  */
end_comment

begin_function
name|int
name|vs_sm_prev
parameter_list|(
name|sp
parameter_list|,
name|p
parameter_list|,
name|t
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|SMAP
modifier|*
name|p
decl_stmt|,
decl|*
name|t
decl_stmt|;
end_function

begin_block
block|{
name|SMAP_FLUSH
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
operator|-
literal|1
expr_stmt|;
name|t
operator|->
name|coff
operator|=
name|p
operator|->
name|coff
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|soff
operator|!=
literal|1
condition|)
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
expr_stmt|;
name|t
operator|->
name|soff
operator|=
name|p
operator|->
name|soff
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
operator|-
literal|1
expr_stmt|;
name|t
operator|->
name|soff
operator|=
name|vs_screens
argument_list|(
name|sp
argument_list|,
name|t
operator|->
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|t
operator|->
name|lno
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * vs_sm_cursor --  *	Return the SMAP entry referenced by the cursor.  *  * PUBLIC: int vs_sm_cursor __P((SCR *, SMAP **));  */
end_comment

begin_function
name|int
name|vs_sm_cursor
parameter_list|(
name|sp
parameter_list|,
name|smpp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|SMAP
modifier|*
modifier|*
name|smpp
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|;
comment|/* See if the cursor is not in the map. */
if|if
condition|(
name|sp
operator|->
name|lno
operator|<
name|HMAP
operator|->
name|lno
operator|||
name|sp
operator|->
name|lno
operator|>
name|TMAP
operator|->
name|lno
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Find the first occurence of the line. */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|->
name|lno
operator|!=
name|sp
operator|->
name|lno
condition|;
operator|++
name|p
control|)
empty_stmt|;
comment|/* Fill in the map information until we find the right line. */
for|for
control|(
init|;
name|p
operator|<=
name|TMAP
condition|;
operator|++
name|p
control|)
block|{
comment|/* Short lines are common and easy to detect. */
if|if
condition|(
name|p
operator|!=
name|TMAP
operator|&&
operator|(
name|p
operator|+
literal|1
operator|)
operator|->
name|lno
operator|!=
name|p
operator|->
name|lno
condition|)
block|{
operator|*
name|smpp
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|SMAP_CACHE
argument_list|(
name|p
argument_list|)
operator|&&
name|vs_line
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|c_eboff
operator|>=
name|sp
operator|->
name|cno
condition|)
block|{
operator|*
name|smpp
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* It was past the end of the map after all. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_sm_position --  *	Return the line/column of the top, middle or last line on the screen.  *	(The vi H, M and L commands.)  Here because only the screen routines  *	know what's really out there.  *  * PUBLIC: int vs_sm_position __P((SCR *, MARK *, u_long, pos_t));  */
end_comment

begin_function
name|int
name|vs_sm_position
parameter_list|(
name|sp
parameter_list|,
name|rp
parameter_list|,
name|cnt
parameter_list|,
name|pos
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|MARK
modifier|*
name|rp
decl_stmt|;
name|u_long
name|cnt
decl_stmt|;
name|pos_t
name|pos
decl_stmt|;
block|{
name|SMAP
modifier|*
name|smp
decl_stmt|;
name|recno_t
name|last
decl_stmt|;
switch|switch
condition|(
name|pos
condition|)
block|{
case|case
name|P_TOP
case|:
comment|/* 		 * !!! 		 * Historically, an invalid count to the H command failed. 		 * We do nothing special here, just making sure that H in 		 * an empty screen works. 		 */
if|if
condition|(
name|cnt
operator|>
name|TMAP
operator|-
name|HMAP
condition|)
goto|goto
name|sof
goto|;
name|smp
operator|=
name|HMAP
operator|+
name|cnt
expr_stmt|;
if|if
condition|(
name|cnt
operator|&&
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
name|smp
operator|->
name|lno
argument_list|)
condition|)
block|{
name|sof
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"220|Movement past the end-of-screen"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|P_MIDDLE
case|:
comment|/* 		 * !!! 		 * Historically, a count to the M command was ignored. 		 * If the screen isn't filled, find the middle of what's 		 * real and move there. 		 */
if|if
condition|(
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
name|TMAP
operator|->
name|lno
argument_list|)
condition|)
block|{
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|last
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|smp
operator|=
name|TMAP
init|;
name|smp
operator|->
name|lno
operator|>
name|last
operator|&&
name|smp
operator|>
name|HMAP
condition|;
operator|--
name|smp
control|)
empty_stmt|;
if|if
condition|(
name|smp
operator|>
name|HMAP
condition|)
name|smp
operator|-=
operator|(
name|smp
operator|-
name|HMAP
operator|)
operator|/
literal|2
expr_stmt|;
block|}
else|else
name|smp
operator|=
operator|(
name|HMAP
operator|+
operator|(
name|TMAP
operator|-
name|HMAP
operator|)
operator|/
literal|2
operator|)
operator|+
name|cnt
expr_stmt|;
break|break;
case|case
name|P_BOTTOM
case|:
comment|/* 		 * !!! 		 * Historically, an invalid count to the L command failed. 		 * If the screen isn't filled, find the bottom of what's 		 * real and try to offset from there. 		 */
if|if
condition|(
name|cnt
operator|>
name|TMAP
operator|-
name|HMAP
condition|)
goto|goto
name|eof
goto|;
name|smp
operator|=
name|TMAP
operator|-
name|cnt
expr_stmt|;
if|if
condition|(
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
name|smp
operator|->
name|lno
argument_list|)
condition|)
block|{
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|last
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
init|;
name|smp
operator|->
name|lno
operator|>
name|last
operator|&&
name|smp
operator|>
name|HMAP
condition|;
operator|--
name|smp
control|)
empty_stmt|;
if|if
condition|(
name|cnt
operator|>
name|smp
operator|-
name|HMAP
condition|)
block|{
name|eof
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"221|Movement past the beginning-of-screen"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|smp
operator|-=
name|cnt
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Make sure that the cached information is valid. */
if|if
condition|(
operator|!
name|SMAP_CACHE
argument_list|(
name|smp
argument_list|)
operator|&&
name|vs_line
argument_list|(
name|sp
argument_list|,
name|smp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|rp
operator|->
name|lno
operator|=
name|smp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|smp
operator|->
name|c_sboff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_sm_nlines --  *	Return the number of screen lines from an SMAP entry to the  *	start of some file line, less than a maximum value.  *  * PUBLIC: recno_t vs_sm_nlines __P((SCR *, SMAP *, recno_t, size_t));  */
end_comment

begin_function
name|recno_t
name|vs_sm_nlines
parameter_list|(
name|sp
parameter_list|,
name|from_sp
parameter_list|,
name|to_lno
parameter_list|,
name|max
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|SMAP
modifier|*
name|from_sp
decl_stmt|;
name|recno_t
name|to_lno
decl_stmt|;
name|size_t
name|max
decl_stmt|;
block|{
name|recno_t
name|lno
decl_stmt|,
name|lcnt
decl_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
return|return
operator|(
name|from_sp
operator|->
name|lno
operator|>
name|to_lno
condition|?
name|from_sp
operator|->
name|lno
operator|-
name|to_lno
else|:
name|to_lno
operator|-
name|from_sp
operator|->
name|lno
operator|)
return|;
if|if
condition|(
name|from_sp
operator|->
name|lno
operator|==
name|to_lno
condition|)
return|return
operator|(
name|from_sp
operator|->
name|soff
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|from_sp
operator|->
name|lno
operator|>
name|to_lno
condition|)
block|{
name|lcnt
operator|=
name|from_sp
operator|->
name|soff
operator|-
literal|1
expr_stmt|;
comment|/* Correct for off-by-one. */
for|for
control|(
name|lno
operator|=
name|from_sp
operator|->
name|lno
init|;
operator|--
name|lno
operator|>=
name|to_lno
operator|&&
name|lcnt
operator|<=
name|max
condition|;
control|)
name|lcnt
operator|+=
name|vs_screens
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lno
operator|=
name|from_sp
operator|->
name|lno
expr_stmt|;
name|lcnt
operator|=
operator|(
name|vs_screens
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
operator|-
name|from_sp
operator|->
name|soff
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
operator|++
name|lno
operator|<
name|to_lno
operator|&&
name|lcnt
operator|<=
name|max
condition|;
control|)
name|lcnt
operator|+=
name|vs_screens
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lcnt
operator|)
return|;
block|}
end_function

end_unit

