begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1992, 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"$Id: vi.c,v 10.61 2011/12/21 13:08:30 zy Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"../common/common.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|GC_ERR
block|,
name|GC_ERR_NOFLUSH
block|,
name|GC_EVENT
block|,
name|GC_FATAL
block|,
name|GC_INTERRUPT
block|,
name|GC_OK
block|}
name|gcret_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|VIKEYS
specifier|const
modifier|*
name|v_alias
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|VICMD
operator|*
operator|,
name|VIKEYS
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gcret_t
name|v_cmd
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|VICMD
operator|*
operator|,
name|VICMD
operator|*
operator|,
name|VICMD
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|v_count
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|ARG_CHAR_T
operator|,
name|u_long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|v_dtoh
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|v_init
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gcret_t
name|v_key
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|int
operator|,
name|EVENT
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|v_motion
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|VICMD
operator|*
operator|,
name|VICMD
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|COMLOG
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|v_comlog
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|VICMD
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Side-effect:  *	The dot structure can be set by the underlying vi functions,  *	see v_Put() and v_put().  */
end_comment

begin_define
define|#
directive|define
name|DOT
value|(&VIP(sp)->sdot)
end_define

begin_define
define|#
directive|define
name|DOTMOTION
value|(&VIP(sp)->sdotmotion)
end_define

begin_comment
comment|/*  * vi --  * 	Main vi command loop.  *  * PUBLIC: int vi __P((SCR **));  */
end_comment

begin_function
name|int
name|vi
parameter_list|(
name|SCR
modifier|*
modifier|*
name|spp
parameter_list|)
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|MARK
name|abs
decl_stmt|;
name|SCR
modifier|*
name|next
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|VICMD
name|cmd
init|=
block|{
literal|0
block|}
decl_stmt|,
modifier|*
name|vp
decl_stmt|;
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
name|int
name|comcount
decl_stmt|,
name|mapped
decl_stmt|,
name|rval
decl_stmt|;
comment|/* Get the first screen. */
name|sp
operator|=
operator|*
name|spp
expr_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
comment|/* Point to the command structure. */
name|vp
operator|=
operator|&
name|cmd
expr_stmt|;
comment|/* Reset strange attraction. */
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VM_RCM_SET
argument_list|)
expr_stmt|;
comment|/* Initialize the vi screen. */
if|if
condition|(
name|v_init
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Set the focus. */
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_rename
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|frp
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
operator|,
name|rval
operator|=
literal|0
init|;
condition|;
control|)
block|{
comment|/* Resolve messages. */
if|if
condition|(
operator|!
name|MAPPED_KEYS_WAITING
argument_list|(
name|sp
argument_list|)
operator|&&
name|vs_resolve
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|ret
goto|;
comment|/* 		 * If not skipping a refresh, return to command mode and 		 * refresh the screen. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vip
argument_list|,
name|VIP_S_REFRESH
argument_list|)
condition|)
name|F_CLR
argument_list|(
name|vip
argument_list|,
name|VIP_S_REFRESH
argument_list|)
expr_stmt|;
else|else
block|{
name|sp
operator|->
name|showmode
operator|=
name|SM_COMMAND
expr_stmt|;
if|if
condition|(
name|vs_refresh
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|ret
goto|;
block|}
comment|/* Set the new favorite position. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VM_RCM_SET
operator||
name|VM_RCM_SETFNB
operator||
name|VM_RCM_SETNNB
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|vip
argument_list|,
name|VIP_RCM_LAST
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vs_column
argument_list|(
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|rcm
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If not currently in a map, log the cursor position, 		 * and set a flag so that this command can become the 		 * DOT command. 		 */
if|if
condition|(
name|MAPPED_KEYS_WAITING
argument_list|(
name|sp
argument_list|)
condition|)
name|mapped
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|log_cursor
argument_list|(
name|sp
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|mapped
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * There may be an ex command waiting, and we returned here 		 * only because we exited a screen or file.  In this case, 		 * we simply go back into the ex parser. 		 */
if|if
condition|(
name|EXCMD_RUNNING
argument_list|(
name|gp
argument_list|)
condition|)
block|{
name|vp
operator|->
name|kp
operator|=
operator|&
name|vikeys
index|[
literal|':'
index|]
expr_stmt|;
goto|goto
name|ex_continue
goto|;
block|}
comment|/* Refresh the command structure. */
name|memset
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|VICMD
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * We get a command, which may or may not have an associated 		 * motion.  If it does, we get it too, calling its underlying 		 * function to get the resulting mark.  We then call the 		 * command setting the cursor to the resulting mark. 		 * 		 * !!! 		 * Vi historically flushed mapped characters on error, but 		 * entering extra<escape> characters at the beginning of 		 * a map wasn't considered an error -- in fact, users would 		 * put leading<escape> characters in maps to clean up vi 		 * state before the map was interpreted.  Beauty! 		 */
switch|switch
condition|(
name|v_cmd
argument_list|(
name|sp
argument_list|,
name|DOT
argument_list|,
name|vp
argument_list|,
name|NULL
argument_list|,
operator|&
name|comcount
argument_list|,
operator|&
name|mapped
argument_list|)
condition|)
block|{
case|case
name|GC_ERR
case|:
goto|goto
name|err
goto|;
case|case
name|GC_ERR_NOFLUSH
case|:
goto|goto
name|gc_err_noflush
goto|;
case|case
name|GC_EVENT
case|:
goto|goto
name|gc_event
goto|;
case|case
name|GC_FATAL
case|:
goto|goto
name|ret
goto|;
case|case
name|GC_INTERRUPT
case|:
goto|goto
name|intr
goto|;
case|case
name|GC_OK
case|:
break|break;
block|}
comment|/* Check for security setting. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
operator|->
name|kp
argument_list|,
name|V_SECURE
argument_list|)
operator|&&
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_SECURE
argument_list|)
condition|)
block|{
name|ex_emsg
argument_list|(
name|sp
argument_list|,
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
name|vp
operator|->
name|key
argument_list|)
argument_list|,
name|EXM_SECURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 		 * Historical practice: if a dot command gets a new count, 		 * any motion component goes away, i.e. "d3w2." deletes a 		 * total of 5 words. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_ISDOT
argument_list|)
operator|&&
name|comcount
condition|)
name|DOTMOTION
operator|->
name|count
operator|=
literal|1
expr_stmt|;
comment|/* Copy the key flags into the local structure. */
name|F_SET
argument_list|(
name|vp
argument_list|,
name|vp
operator|->
name|kp
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* Prepare to set the previous context. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|V_ABS
operator||
name|V_ABS_C
operator||
name|V_ABS_L
argument_list|)
condition|)
block|{
name|abs
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|abs
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
block|}
comment|/* 		 * Set the three cursor locations to the current cursor.  The 		 * underlying routines don't bother if the cursor doesn't move. 		 * This also handles line commands (e.g. Y) defaulting to the 		 * current line. 		 */
name|vp
operator|->
name|m_start
operator|.
name|lno
operator|=
name|vp
operator|->
name|m_stop
operator|.
name|lno
operator|=
name|vp
operator|->
name|m_final
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|vp
operator|->
name|m_start
operator|.
name|cno
operator|=
name|vp
operator|->
name|m_stop
operator|.
name|cno
operator|=
name|vp
operator|->
name|m_final
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* 		 * Do any required motion; v_motion sets the from MARK and the 		 * line mode flag, as well as the VM_RCM flags. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|V_MOTION
argument_list|)
operator|&&
name|v_motion
argument_list|(
name|sp
argument_list|,
name|DOTMOTION
argument_list|,
name|vp
argument_list|,
operator|&
name|mapped
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTERRUPTED
argument_list|(
name|sp
argument_list|)
condition|)
goto|goto
name|intr
goto|;
goto|goto
name|err
goto|;
block|}
comment|/* 		 * If a count is set and the command is line oriented, set the 		 * to MARK here relative to the cursor/from MARK.  This is for 		 * commands that take both counts and motions, i.e. "4yy" and 		 * "y%".  As there's no way the command can know which the user 		 * did, we have to do it here.  (There are commands that are 		 * line oriented and that take counts ("#G", "#H"), for which 		 * this calculation is either completely meaningless or wrong. 		 * Each command must validate the value for itself. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VM_LMODE
argument_list|)
condition|)
name|vp
operator|->
name|m_stop
operator|.
name|lno
operator|+=
name|vp
operator|->
name|count
operator|-
literal|1
expr_stmt|;
comment|/* Increment the command count. */
operator|++
name|sp
operator|->
name|ccnt
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|COMLOG
argument_list|)
name|v_comlog
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Call the function. */
name|ex_continue
label|:
if|if
condition|(
name|vp
operator|->
name|kp
operator|->
name|func
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|gc_event
label|:
ifdef|#
directive|ifdef
name|DEBUG
comment|/* Make sure no function left the temporary space locked. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|gp
argument_list|,
name|G_TMP_INUSE
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|gp
argument_list|,
name|G_TMP_INUSE
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"232|vi: temporary buffer not released"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * If we're exiting this screen, move to the next one, or, if 		 * there aren't any more, return to the main editor loop.  The 		 * ordering is careful, don't discard the contents of sp until 		 * the end. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EXIT
operator||
name|SC_EXIT_FORCE
argument_list|)
condition|)
block|{
if|if
condition|(
name|file_end
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EXIT_FORCE
argument_list|)
argument_list|)
condition|)
goto|goto
name|ret
goto|;
if|if
condition|(
name|vs_discard
argument_list|(
name|sp
argument_list|,
operator|&
name|next
argument_list|)
condition|)
goto|goto
name|ret
goto|;
if|if
condition|(
name|next
operator|==
name|NULL
operator|&&
name|vs_swap
argument_list|(
name|sp
argument_list|,
operator|&
name|next
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|ret
goto|;
operator|*
name|spp
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|screen_end
argument_list|(
name|sp
argument_list|)
condition|)
goto|goto
name|ret
goto|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
break|break;
comment|/* Switch screens, change focus. */
name|sp
operator|=
name|next
expr_stmt|;
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_rename
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|frp
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Don't trust the cursor. */
name|F_SET
argument_list|(
name|vip
argument_list|,
name|VIP_CUR_INVALID
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Set the dot command structure. 		 * 		 * !!! 		 * Historically, commands which used mapped keys did not 		 * set the dot command, with the exception of the text 		 * input commands. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|V_DOT
argument_list|)
operator|&&
operator|!
name|mapped
condition|)
block|{
operator|*
name|DOT
operator|=
name|cmd
expr_stmt|;
name|F_SET
argument_list|(
name|DOT
argument_list|,
name|VC_ISDOT
argument_list|)
expr_stmt|;
comment|/* 			 * If a count was supplied for both the command and 			 * its motion, the count was used only for the motion. 			 * Turn the count back on for the dot structure. 			 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1RESET
argument_list|)
condition|)
name|F_SET
argument_list|(
name|DOT
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
comment|/* VM flags aren't retained. */
name|F_CLR
argument_list|(
name|DOT
argument_list|,
name|VM_COMMASK
operator||
name|VM_RCM_MASK
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Some vi row movements are "attracted" to the last position 		 * set, i.e. the VM_RCM commands are moths to the VM_RCM_SET 		 * commands' candle.  If the movement is to the EOL the vi 		 * command handles it.  If it's to the beginning, we handle it 		 * here. 		 * 		 * Note, some commands (e.g. _, ^) don't set the VM_RCM_SETFNB 		 * flag, but do the work themselves.  The reason is that they 		 * have to modify the column in case they're being used as a 		 * motion component.  Other similar commands (e.g. +, -) don't 		 * have to modify the column because they are always line mode 		 * operations when used as motions, so the column number isn't 		 * of any interest. 		 * 		 * Does this totally violate the screen and editor layering? 		 * You betcha.  As they say, if you think you understand it, 		 * you don't. 		 */
switch|switch
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VM_RCM_MASK
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
case|case
name|VM_RCM_SET
case|:
break|break;
case|case
name|VM_RCM
case|:
name|vp
operator|->
name|m_final
operator|.
name|cno
operator|=
name|vs_rcm
argument_list|(
name|sp
argument_list|,
name|vp
operator|->
name|m_final
operator|.
name|lno
argument_list|,
name|F_ISSET
argument_list|(
name|vip
argument_list|,
name|VIP_RCM_LAST
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_RCM_SETLAST
case|:
name|F_SET
argument_list|(
name|vip
argument_list|,
name|VIP_RCM_LAST
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_RCM_SETFNB
case|:
name|vp
operator|->
name|m_final
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|VM_RCM_SETNNB
case|:
if|if
condition|(
name|nonblank
argument_list|(
name|sp
argument_list|,
name|vp
operator|->
name|m_final
operator|.
name|lno
argument_list|,
operator|&
name|vp
operator|->
name|m_final
operator|.
name|cno
argument_list|)
condition|)
goto|goto
name|err
goto|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Update the cursor. */
name|sp
operator|->
name|lno
operator|=
name|vp
operator|->
name|m_final
operator|.
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|vp
operator|->
name|m_final
operator|.
name|cno
expr_stmt|;
comment|/* 		 * Set the absolute mark -- set even if a tags or similar 		 * command, since the tag may be moving to the same file. 		 */
if|if
condition|(
operator|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|V_ABS
argument_list|)
operator|||
operator|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|V_ABS_L
argument_list|)
operator|&&
name|sp
operator|->
name|lno
operator|!=
name|abs
operator|.
name|lno
operator|)
operator|||
operator|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|V_ABS_C
argument_list|)
operator|&&
operator|(
name|sp
operator|->
name|lno
operator|!=
name|abs
operator|.
name|lno
operator|||
name|sp
operator|->
name|cno
operator|!=
name|abs
operator|.
name|cno
operator|)
operator|)
operator|)
operator|&&
name|mark_set
argument_list|(
name|sp
argument_list|,
name|ABSMARK1
argument_list|,
operator|&
name|abs
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
literal|0
condition|)
block|{
name|err
label|:
if|if
condition|(
name|v_event_flush
argument_list|(
name|sp
argument_list|,
name|CH_MAPPED
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"110|Vi command failed: mapped keys discarded"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Check and clear interrupts.  There's an obvious race, but 		 * it's not worth fixing. 		 */
name|gc_err_noflush
label|:
if|if
condition|(
name|INTERRUPTED
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|intr
label|:
name|CLR_INTERRUPT
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|v_event_flush
argument_list|(
name|sp
argument_list|,
name|CH_MAPPED
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"231|Interrupted: mapped keys discarded"
argument_list|)
expr_stmt|;
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"236|Interrupted"
argument_list|)
expr_stmt|;
block|}
comment|/* If the last command switched screens, update. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SSWITCH
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_SSWITCH
argument_list|)
expr_stmt|;
comment|/* 			 * If the current screen is still displayed, it will 			 * need a new status line. 			 */
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_STATUS
argument_list|)
expr_stmt|;
comment|/* Switch screens, change focus. */
name|sp
operator|=
name|sp
operator|->
name|nextdisp
expr_stmt|;
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_rename
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|frp
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Don't trust the cursor. */
name|F_SET
argument_list|(
name|vip
argument_list|,
name|VIP_CUR_INVALID
argument_list|)
expr_stmt|;
comment|/* Refresh so we can display messages. */
if|if
condition|(
name|vs_refresh
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* If the last command switched files, change focus. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_FSWITCH
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_FSWITCH
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_rename
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|frp
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If leaving vi, return to the main editor loop. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|gp
argument_list|,
name|G_SRESTART
argument_list|)
operator|||
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX
argument_list|)
condition|)
block|{
operator|*
name|spp
operator|=
name|sp
expr_stmt|;
name|v_dtoh
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|gp
operator|->
name|scr_discard
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
literal|0
condition|)
name|ret
label|:
name|rval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|KEY
parameter_list|(
name|key
parameter_list|,
name|ec_flags
parameter_list|)
value|{						\ 	if ((gcret = v_key(sp, 0,&ev, ec_flags)) != GC_OK)		\ 		return (gcret);						\ 	if (ev.e_value == K_ESCAPE)					\ 		goto esc;						\ 	if (F_ISSET(&ev.e_ch, CH_MAPPED))				\ 		*mappedp = 1;						\ 	key = ev.e_c;							\ }
end_define

begin_comment
comment|/*  * The O_TILDEOP option makes the ~ command take a motion instead  * of a straight count.  This is the replacement structure we use  * instead of the one currently in the VIKEYS table.  *  * XXX  * This should probably be deleted -- it's not all that useful, and  * we get help messages wrong.  */
end_comment

begin_decl_stmt
name|VIKEYS
specifier|const
name|tmotion
init|=
block|{
name|v_mulcase
block|,
name|V_CNT
operator||
name|V_DOT
operator||
name|V_MOTION
operator||
name|VM_RCM_SET
block|,
literal|"[count]~[count]motion"
block|,
literal|" ~ change case to motion"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * v_cmd --  *  * The command structure for vi is less complex than ex (and don't think  * I'm not grateful!)  The command syntax is:  *  *	[count] [buffer] [count] key [[motion] | [buffer] [character]]  *  * and there are several special cases.  The motion value is itself a vi  * command, with the syntax:  *  *	[count] key [character]  */
end_comment

begin_function
specifier|static
name|gcret_t
name|v_cmd
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|VICMD
modifier|*
name|dp
parameter_list|,
name|VICMD
modifier|*
name|vp
parameter_list|,
name|VICMD
modifier|*
name|ismotion
parameter_list|,
comment|/* Previous key if getting motion component. */
name|int
modifier|*
name|comcountp
parameter_list|,
name|int
modifier|*
name|mappedp
parameter_list|)
block|{
enum|enum
block|{
name|COMMANDMODE
block|,
name|ISPARTIAL
block|,
name|NOTPARTIAL
block|}
name|cpart
enum|;
name|EVENT
name|ev
decl_stmt|;
name|VIKEYS
specifier|const
modifier|*
name|kp
decl_stmt|;
name|gcret_t
name|gcret
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
name|CHAR_T
name|key
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
comment|/* 	 * Get a key. 	 * 	 *<escape> cancels partial commands, i.e. a command where at least 	 * one non-numeric character has been entered.  Otherwise, it beeps 	 * the terminal. 	 * 	 * !!! 	 * POSIX 1003.2-1992 explicitly disallows cancelling commands where 	 * all that's been entered is a number, requiring that the terminal 	 * be alerted. 	 */
name|cpart
operator|=
name|ismotion
operator|==
name|NULL
condition|?
name|COMMANDMODE
else|:
name|ISPARTIAL
expr_stmt|;
if|if
condition|(
operator|(
name|gcret
operator|=
name|v_key
argument_list|(
name|sp
argument_list|,
name|ismotion
operator|==
name|NULL
argument_list|,
operator|&
name|ev
argument_list|,
name|EC_MAPCOMMAND
argument_list|)
operator|)
operator|!=
name|GC_OK
condition|)
block|{
if|if
condition|(
name|gcret
operator|==
name|GC_EVENT
condition|)
name|vp
operator|->
name|ev
operator|=
name|ev
expr_stmt|;
return|return
operator|(
name|gcret
operator|)
return|;
block|}
if|if
condition|(
name|ev
operator|.
name|e_value
operator|==
name|K_ESCAPE
condition|)
goto|goto
name|esc
goto|;
if|if
condition|(
name|F_ISSET
argument_list|(
operator|&
name|ev
operator|.
name|e_ch
argument_list|,
name|CH_MAPPED
argument_list|)
condition|)
operator|*
name|mappedp
operator|=
literal|1
expr_stmt|;
name|key
operator|=
name|ev
operator|.
name|e_c
expr_stmt|;
if|if
condition|(
name|ismotion
operator|==
name|NULL
condition|)
name|cpart
operator|=
name|NOTPARTIAL
expr_stmt|;
comment|/* Pick up an optional buffer. */
if|if
condition|(
name|key
operator|==
literal|'"'
condition|)
block|{
name|cpart
operator|=
name|ISPARTIAL
expr_stmt|;
if|if
condition|(
name|ismotion
operator|!=
name|NULL
condition|)
block|{
name|v_emsg
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|VIM_COMBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|GC_ERR
operator|)
return|;
block|}
name|KEY
argument_list|(
name|vp
operator|->
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_BUFFER
argument_list|)
expr_stmt|;
name|KEY
argument_list|(
name|key
argument_list|,
name|EC_MAPCOMMAND
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Pick up an optional count, where a leading 0 is not a count, 	 * it's a command. 	 */
if|if
condition|(
name|ISDIGIT
argument_list|(
name|key
argument_list|)
operator|&&
name|key
operator|!=
literal|'0'
condition|)
block|{
if|if
condition|(
name|v_count
argument_list|(
name|sp
argument_list|,
name|key
argument_list|,
operator|&
name|vp
operator|->
name|count
argument_list|)
condition|)
return|return
operator|(
name|GC_ERR
operator|)
return|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
operator|*
name|comcountp
operator|=
literal|1
expr_stmt|;
name|KEY
argument_list|(
name|key
argument_list|,
name|EC_MAPCOMMAND
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|comcountp
operator|=
literal|0
expr_stmt|;
comment|/* Pick up optional buffer. */
if|if
condition|(
name|key
operator|==
literal|'"'
condition|)
block|{
name|cpart
operator|=
name|ISPARTIAL
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_BUFFER
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"234|Only one buffer may be specified"
argument_list|)
expr_stmt|;
return|return
operator|(
name|GC_ERR
operator|)
return|;
block|}
if|if
condition|(
name|ismotion
operator|!=
name|NULL
condition|)
block|{
name|v_emsg
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|VIM_COMBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|GC_ERR
operator|)
return|;
block|}
name|KEY
argument_list|(
name|vp
operator|->
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_BUFFER
argument_list|)
expr_stmt|;
name|KEY
argument_list|(
name|key
argument_list|,
name|EC_MAPCOMMAND
argument_list|)
expr_stmt|;
block|}
comment|/* Check for an OOB command key. */
name|cpart
operator|=
name|ISPARTIAL
expr_stmt|;
if|if
condition|(
name|key
operator|>
name|MAXVIKEY
condition|)
block|{
name|v_emsg
argument_list|(
name|sp
argument_list|,
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
argument_list|,
name|VIM_NOCOM
argument_list|)
expr_stmt|;
return|return
operator|(
name|GC_ERR
operator|)
return|;
block|}
name|kp
operator|=
operator|&
name|vikeys
index|[
name|vp
operator|->
name|key
operator|=
name|key
index|]
expr_stmt|;
comment|/* 	 * !!! 	 * Historically, D accepted and then ignored a count.  Match it. 	 */
if|if
condition|(
name|vp
operator|->
name|key
operator|==
literal|'D'
operator|&&
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
condition|)
block|{
operator|*
name|comcountp
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|F_CLR
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
block|}
comment|/* Check for command aliases. */
if|if
condition|(
name|kp
operator|->
name|func
operator|==
name|NULL
operator|&&
operator|(
name|kp
operator|=
name|v_alias
argument_list|(
name|sp
argument_list|,
name|vp
argument_list|,
name|kp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|GC_ERR
operator|)
return|;
comment|/* The tildeop option makes the ~ command take a motion. */
if|if
condition|(
name|key
operator|==
literal|'~'
operator|&&
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_TILDEOP
argument_list|)
condition|)
name|kp
operator|=
operator|&
name|tmotion
expr_stmt|;
name|vp
operator|->
name|kp
operator|=
name|kp
expr_stmt|;
comment|/* 	 * Find the command.  The only legal command with no underlying 	 * function is dot.  It's historic practice that<escape> doesn't 	 * just erase the preceding number, it beeps the terminal as well. 	 * It's a common problem, so just beep the terminal unless verbose 	 * was set. 	 */
if|if
condition|(
name|kp
operator|->
name|func
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|key
operator|!=
literal|'.'
condition|)
block|{
name|v_emsg
argument_list|(
name|sp
argument_list|,
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
argument_list|,
name|ev
operator|.
name|e_value
operator|==
name|K_ESCAPE
condition|?
name|VIM_NOCOM_B
else|:
name|VIM_NOCOM
argument_list|)
expr_stmt|;
return|return
operator|(
name|GC_ERR
operator|)
return|;
block|}
comment|/* If called for a motion command, stop now. */
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
goto|goto
name|usage
goto|;
comment|/* 		 * !!! 		 * If a '.' is immediately entered after an undo command, we 		 * replay the log instead of redoing the last command.  This 		 * is necessary because 'u' can't set the dot command -- see 		 * vi/v_undo.c:v_undo for details. 		 */
if|if
condition|(
name|VIP
argument_list|(
name|sp
argument_list|)
operator|->
name|u_ccnt
operator|==
name|sp
operator|->
name|ccnt
condition|)
block|{
name|vp
operator|->
name|kp
operator|=
operator|&
name|vikeys
index|[
literal|'u'
index|]
expr_stmt|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_ISDOT
argument_list|)
expr_stmt|;
return|return
operator|(
name|GC_OK
operator|)
return|;
block|}
comment|/* Otherwise, a repeatable command must have been executed. */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|dp
argument_list|,
name|VC_ISDOT
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"208|No command to repeat"
argument_list|)
expr_stmt|;
return|return
operator|(
name|GC_ERR
operator|)
return|;
block|}
comment|/* Set new count/buffer, if any, and return. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
condition|)
block|{
name|F_SET
argument_list|(
name|dp
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
name|dp
operator|->
name|count
operator|=
name|vp
operator|->
name|count
expr_stmt|;
block|}
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_BUFFER
argument_list|)
condition|)
name|dp
operator|->
name|buffer
operator|=
name|vp
operator|->
name|buffer
expr_stmt|;
operator|*
name|vp
operator|=
operator|*
name|dp
expr_stmt|;
return|return
operator|(
name|GC_OK
operator|)
return|;
block|}
comment|/* Set the flags based on the command flags. */
name|flags
operator|=
name|kp
operator|->
name|flags
expr_stmt|;
comment|/* Check for illegal count. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
operator|&&
operator|!
name|LF_ISSET
argument_list|(
name|V_CNT
argument_list|)
condition|)
goto|goto
name|usage
goto|;
comment|/* Illegal motion command. */
if|if
condition|(
name|ismotion
operator|==
name|NULL
condition|)
block|{
comment|/* Illegal buffer. */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|V_OBUF
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_BUFFER
argument_list|)
condition|)
goto|goto
name|usage
goto|;
comment|/* Required buffer. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_RBUF
argument_list|)
condition|)
block|{
name|KEY
argument_list|(
name|vp
operator|->
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_BUFFER
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Special case: '[', ']' and 'Z' commands.  Doesn't the fact that 	 * the *single* characters don't mean anything but the *doubled* 	 * characters do, just frost your shorts? 	 */
if|if
condition|(
name|vp
operator|->
name|key
operator|==
literal|'['
operator|||
name|vp
operator|->
name|key
operator|==
literal|']'
operator|||
name|vp
operator|->
name|key
operator|==
literal|'Z'
condition|)
block|{
comment|/* 		 * Historically, half entered [[, ]] or Z commands weren't 		 * cancelled by<escape>, the terminal was beeped instead. 		 * POSIX.2-1992 probably didn't notice, and requires that 		 * they be cancelled instead of beeping.  Seems fine to me. 		 * 		 * Don't set the EC_MAPCOMMAND flag, apparently ] is a popular 		 * vi meta-character, and we don't want the user to wait while 		 * we time out a possible mapping.  This *appears* to match 		 * historic vi practice, but with mapping characters, You Just 		 * Never Know. 		 */
name|KEY
argument_list|(
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|key
operator|!=
name|key
condition|)
block|{
name|usage
label|:
if|if
condition|(
name|ismotion
operator|==
name|NULL
condition|)
name|s
operator|=
name|kp
operator|->
name|usage
expr_stmt|;
elseif|else
if|if
condition|(
name|ismotion
operator|->
name|key
operator|==
literal|'~'
operator|&&
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_TILDEOP
argument_list|)
condition|)
name|s
operator|=
name|tmotion
operator|.
name|usage
expr_stmt|;
else|else
name|s
operator|=
name|vikeys
index|[
name|ismotion
operator|->
name|key
index|]
operator|.
name|usage
expr_stmt|;
name|v_emsg
argument_list|(
name|sp
argument_list|,
name|s
argument_list|,
name|VIM_USAGE
argument_list|)
expr_stmt|;
return|return
operator|(
name|GC_ERR
operator|)
return|;
block|}
block|}
comment|/* Special case: 'z' command. */
if|if
condition|(
name|vp
operator|->
name|key
operator|==
literal|'z'
condition|)
block|{
name|KEY
argument_list|(
name|vp
operator|->
name|character
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|vp
operator|->
name|character
argument_list|)
condition|)
block|{
if|if
condition|(
name|v_count
argument_list|(
name|sp
argument_list|,
name|vp
operator|->
name|character
argument_list|,
operator|&
name|vp
operator|->
name|count2
argument_list|)
condition|)
return|return
operator|(
name|GC_ERR
operator|)
return|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_C2SET
argument_list|)
expr_stmt|;
name|KEY
argument_list|(
name|vp
operator|->
name|character
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Commands that have motion components can be doubled to imply the 	 * current line. 	 */
if|if
condition|(
name|ismotion
operator|!=
name|NULL
operator|&&
name|ismotion
operator|->
name|key
operator|!=
name|key
operator|&&
operator|!
name|LF_ISSET
argument_list|(
name|V_MOVE
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"210|%s may not be used as a motion command"
argument_list|,
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|GC_ERR
operator|)
return|;
block|}
comment|/* Pick up required trailing character. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_CHAR
argument_list|)
condition|)
name|KEY
argument_list|(
name|vp
operator|->
name|character
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Get any associated cursor word. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|kp
argument_list|,
name|V_KEYW
argument_list|)
operator|&&
name|v_curword
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
name|GC_ERR
operator|)
return|;
return|return
operator|(
name|GC_OK
operator|)
return|;
name|esc
label|:
switch|switch
condition|(
name|cpart
condition|)
block|{
case|case
name|COMMANDMODE
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"211|Already in command mode"
argument_list|)
expr_stmt|;
return|return
operator|(
name|GC_ERR_NOFLUSH
operator|)
return|;
case|case
name|ISPARTIAL
case|:
break|break;
case|case
name|NOTPARTIAL
case|:
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_bell
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|GC_ERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_motion --  *  * Get resulting motion mark.  */
end_comment

begin_function
specifier|static
name|int
name|v_motion
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|VICMD
modifier|*
name|dm
parameter_list|,
name|VICMD
modifier|*
name|vp
parameter_list|,
name|int
modifier|*
name|mappedp
parameter_list|)
block|{
name|VICMD
name|motion
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|u_long
name|cnt
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
name|int
name|tilde_reset
decl_stmt|,
name|notused
decl_stmt|;
comment|/* 	 * If '.' command, use the dot motion, else get the motion command. 	 * Clear any line motion flags, the subsequent motion isn't always 	 * the same, i.e. "/aaa" may or may not be a line motion. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_ISDOT
argument_list|)
condition|)
block|{
name|motion
operator|=
operator|*
name|dm
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|motion
argument_list|,
name|VC_ISDOT
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
operator|&
name|motion
argument_list|,
name|VM_COMMASK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|motion
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|VICMD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v_cmd
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
operator|&
name|motion
argument_list|,
name|vp
argument_list|,
operator|&
name|notused
argument_list|,
name|mappedp
argument_list|)
operator|!=
name|GC_OK
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * A count may be provided both to the command and to the motion, in 	 * which case the count is multiplicative.  For example, "3y4y" is the 	 * same as "12yy".  This count is provided to the motion command and 	 * not to the regular function. 	 */
name|cnt
operator|=
name|motion
operator|.
name|count
operator|=
name|F_ISSET
argument_list|(
operator|&
name|motion
argument_list|,
name|VC_C1SET
argument_list|)
condition|?
name|motion
operator|.
name|count
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
condition|)
block|{
name|motion
operator|.
name|count
operator|*=
name|vp
operator|->
name|count
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|motion
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
comment|/* 		 * Set flags to restore the original values of the command 		 * structure so dot commands can change the count values, 		 * e.g. "2dw" "3." deletes a total of five words. 		 */
name|F_CLR
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_C1RESET
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Some commands can be repeated to indicate the current line.  In 	 * this case, or if the command is a "line command", set the flags 	 * appropriately.  If not a doubled command, run the function to get 	 * the resulting mark.  	 */
if|if
condition|(
name|vp
operator|->
name|key
operator|==
name|motion
operator|.
name|key
condition|)
block|{
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VM_LDOUBLE
operator||
name|VM_LMODE
argument_list|)
expr_stmt|;
comment|/* Set the origin of the command. */
name|vp
operator|->
name|m_start
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|vp
operator|->
name|m_start
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Set the end of the command. 		 * 		 * If the current line is missing, i.e. the file is empty, 		 * historic vi permitted a "cc" or "!!" command to insert 		 * text. 		 */
name|vp
operator|->
name|m_stop
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
operator|+
name|motion
operator|.
name|count
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|db_get
argument_list|(
name|sp
argument_list|,
name|vp
operator|->
name|m_stop
operator|.
name|lno
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|m_stop
operator|.
name|lno
operator|!=
literal|1
operator|||
operator|(
name|vp
operator|->
name|key
operator|!=
literal|'c'
operator|&&
name|vp
operator|->
name|key
operator|!=
literal|'!'
operator|)
condition|)
block|{
name|v_emsg
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|VIM_EMPTY
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|vp
operator|->
name|m_stop
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|vp
operator|->
name|m_stop
operator|.
name|cno
operator|=
name|len
condition|?
name|len
operator|-
literal|1
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Motion commands change the underlying movement (*snarl*). 		 * For example, "l" is illegal at the end of a line, but "dl" 		 * is not.  Set flags so the function knows the situation. 		 */
name|motion
operator|.
name|rkp
operator|=
name|vp
operator|->
name|kp
expr_stmt|;
comment|/* 		 * XXX 		 * Use yank instead of creating a new motion command, it's a 		 * lot easier for now. 		 */
if|if
condition|(
name|vp
operator|->
name|kp
operator|==
operator|&
name|tmotion
condition|)
block|{
name|tilde_reset
operator|=
literal|1
expr_stmt|;
name|vp
operator|->
name|kp
operator|=
operator|&
name|vikeys
index|[
literal|'y'
index|]
expr_stmt|;
block|}
else|else
name|tilde_reset
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Copy the key flags into the local structure, except for the 		 * RCM flags -- the motion command will set the RCM flags in 		 * the vp structure if necessary.  This means that the motion 		 * command is expected to determine where the cursor ends up! 		 * However, we save off the current RCM mask and restore it if 		 * it no RCM flags are set by the motion command, with a small 		 * modification. 		 * 		 * We replace the VM_RCM_SET flag with the VM_RCM flag.  This 		 * is so that cursor movement doesn't set the relative position 		 * unless the motion command explicitly specified it.  This 		 * appears to match historic practice, but I've never been able 		 * to develop a hard-and-fast rule. 		 */
name|flags
operator|=
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VM_RCM_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|VM_RCM_SET
argument_list|)
condition|)
block|{
name|LF_SET
argument_list|(
name|VM_RCM
argument_list|)
expr_stmt|;
name|LF_CLR
argument_list|(
name|VM_RCM_SET
argument_list|)
expr_stmt|;
block|}
name|F_CLR
argument_list|(
name|vp
argument_list|,
name|VM_RCM_MASK
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|motion
argument_list|,
name|motion
operator|.
name|kp
operator|->
name|flags
operator|&
operator|~
name|VM_RCM_MASK
argument_list|)
expr_stmt|;
comment|/* 		 * Set the three cursor locations to the current cursor.  This 		 * permits commands like 'j' and 'k', that are line oriented 		 * motions and have special cursor suck semantics when they are 		 * used as standalone commands, to ignore column positioning. 		 */
name|motion
operator|.
name|m_final
operator|.
name|lno
operator|=
name|motion
operator|.
name|m_stop
operator|.
name|lno
operator|=
name|motion
operator|.
name|m_start
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|motion
operator|.
name|m_final
operator|.
name|cno
operator|=
name|motion
operator|.
name|m_stop
operator|.
name|cno
operator|=
name|motion
operator|.
name|m_start
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* Run the function. */
if|if
condition|(
call|(
name|motion
operator|.
name|kp
operator|->
name|func
call|)
argument_list|(
name|sp
argument_list|,
operator|&
name|motion
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 		 * If the current line is missing, i.e. the file is empty, 		 * historic vi allowed "c<motion>" or "!<motion>" to insert 		 * text.  Otherwise fail -- most motion commands will have 		 * already failed, but some, e.g. G, succeed in empty files. 		 */
if|if
condition|(
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
name|vp
operator|->
name|m_stop
operator|.
name|lno
argument_list|)
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|m_stop
operator|.
name|lno
operator|!=
literal|1
operator|||
operator|(
name|vp
operator|->
name|key
operator|!=
literal|'c'
operator|&&
name|vp
operator|->
name|key
operator|!=
literal|'!'
operator|)
condition|)
block|{
name|v_emsg
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|VIM_EMPTY
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|vp
operator|->
name|m_stop
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * XXX 		 * See above. 		 */
if|if
condition|(
name|tilde_reset
condition|)
name|vp
operator|->
name|kp
operator|=
operator|&
name|tmotion
expr_stmt|;
comment|/* 		 * Copy cut buffer, line mode and cursor position information 		 * from the motion command structure, i.e. anything that the 		 * motion command can set for us.  The commands can flag the 		 * movement as a line motion (see v_sentence) as well as set 		 * the VM_RCM_* flags explicitly. 		 */
name|F_SET
argument_list|(
name|vp
argument_list|,
name|F_ISSET
argument_list|(
operator|&
name|motion
argument_list|,
name|VM_COMMASK
operator||
name|VM_RCM_MASK
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If the motion command set no relative motion flags, use 		 * the (slightly) modified previous values. 		 */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VM_RCM_MASK
argument_list|)
condition|)
name|F_SET
argument_list|(
name|vp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 		 * Commands can change behaviors based on the motion command 		 * used, for example, the ! command repeated the last bang 		 * command if N or n was used as the motion. 		 */
name|vp
operator|->
name|rkp
operator|=
name|motion
operator|.
name|kp
expr_stmt|;
comment|/* 		 * Motion commands can reset all of the cursor information. 		 * If the motion is in the reverse direction, switch the 		 * from and to MARK's so that it's in a forward direction. 		 * Motions are from the from MARK to the to MARK (inclusive). 		 */
if|if
condition|(
name|motion
operator|.
name|m_start
operator|.
name|lno
operator|>
name|motion
operator|.
name|m_stop
operator|.
name|lno
operator|||
operator|(
name|motion
operator|.
name|m_start
operator|.
name|lno
operator|==
name|motion
operator|.
name|m_stop
operator|.
name|lno
operator|&&
name|motion
operator|.
name|m_start
operator|.
name|cno
operator|>
name|motion
operator|.
name|m_stop
operator|.
name|cno
operator|)
condition|)
block|{
name|vp
operator|->
name|m_start
operator|=
name|motion
operator|.
name|m_stop
expr_stmt|;
name|vp
operator|->
name|m_stop
operator|=
name|motion
operator|.
name|m_start
expr_stmt|;
block|}
else|else
block|{
name|vp
operator|->
name|m_start
operator|=
name|motion
operator|.
name|m_start
expr_stmt|;
name|vp
operator|->
name|m_stop
operator|=
name|motion
operator|.
name|m_stop
expr_stmt|;
block|}
name|vp
operator|->
name|m_final
operator|=
name|motion
operator|.
name|m_final
expr_stmt|;
block|}
comment|/* 	 * If the command sets dot, save the motion structure.  The motion 	 * count was changed above and needs to be reset, that's why this 	 * is done here, and not in the calling routine. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
operator|->
name|kp
argument_list|,
name|V_DOT
argument_list|)
condition|)
block|{
operator|*
name|dm
operator|=
name|motion
expr_stmt|;
name|dm
operator|->
name|count
operator|=
name|cnt
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_init --  *	Initialize the vi screen.  */
end_comment

begin_function
specifier|static
name|int
name|v_init
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* Switch into vi. */
if|if
condition|(
name|gp
operator|->
name|scr_screen
argument_list|(
name|sp
argument_list|,
name|SC_VI
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_attr
argument_list|(
name|sp
argument_list|,
name|SA_ALTERNATE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_EX
operator||
name|SC_SCR_EX
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_VI
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize screen values. 	 * 	 * Small windows: see vs_refresh(), section 6a. 	 * 	 * Setup: 	 *	t_minrows is the minimum rows to display 	 *	t_maxrows is the maximum rows to display (rows - 1) 	 *	t_rows is the rows currently being displayed 	 */
name|sp
operator|->
name|rows
operator|=
name|vip
operator|->
name|srows
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_LINES
argument_list|)
expr_stmt|;
name|sp
operator|->
name|cols
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_COLUMNS
argument_list|)
expr_stmt|;
name|sp
operator|->
name|t_rows
operator|=
name|sp
operator|->
name|t_minrows
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_WINDOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|rows
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|t_rows
operator|>
name|sp
operator|->
name|rows
operator|-
literal|1
condition|)
block|{
name|sp
operator|->
name|t_minrows
operator|=
name|sp
operator|->
name|t_rows
operator|=
name|sp
operator|->
name|rows
operator|-
literal|1
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"214|Windows option value is too large, max is %u"
argument_list|,
operator|(
name|u_int
operator|)
name|sp
operator|->
name|t_rows
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|t_maxrows
operator|=
name|sp
operator|->
name|rows
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|sp
operator|->
name|t_maxrows
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|roff
operator|=
name|sp
operator|->
name|coff
operator|=
literal|0
expr_stmt|;
comment|/* Create a screen map. */
name|CALLOC_RET
argument_list|(
name|sp
argument_list|,
name|HMAP
argument_list|,
name|SMAP
operator|*
argument_list|,
name|SIZE_HMAP
argument_list|(
name|sp
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
name|TMAP
operator|=
name|HMAP
operator|+
operator|(
name|sp
operator|->
name|t_rows
operator|-
literal|1
operator|)
expr_stmt|;
name|HMAP
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|HMAP
operator|->
name|coff
operator|=
literal|0
expr_stmt|;
name|HMAP
operator|->
name|soff
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Fill the screen map from scratch -- try and center the line.  That 	 * way if we're starting with a file we've seen before, we'll put the 	 * line in the middle, otherwise, it won't work and we'll end up with 	 * the line at the top. 	 */
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REFORMAT
operator||
name|SC_SCR_CENTER
argument_list|)
expr_stmt|;
comment|/* Invalidate the cursor. */
name|F_SET
argument_list|(
name|vip
argument_list|,
name|VIP_CUR_INVALID
argument_list|)
expr_stmt|;
comment|/* Paint the screen image from scratch. */
name|F_SET
argument_list|(
name|vip
argument_list|,
name|VIP_N_EX_PAINT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_dtoh --  *	Move all but the current screen to the hidden queue.  */
end_comment

begin_function
specifier|static
name|void
name|v_dtoh
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|SCR
modifier|*
name|tsp
decl_stmt|;
name|int
name|hidden
decl_stmt|;
comment|/* Move all screens to the hidden queue, tossing screen maps. */
for|for
control|(
name|hidden
operator|=
literal|0
operator|,
name|gp
operator|=
name|sp
operator|->
name|gp
init|;
operator|(
name|tsp
operator|=
name|TAILQ_FIRST
argument_list|(
name|gp
operator|->
name|dq
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
operator|++
name|hidden
control|)
block|{
if|if
condition|(
name|_HMAP
argument_list|(
name|tsp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|_HMAP
argument_list|(
name|tsp
argument_list|)
argument_list|)
expr_stmt|;
name|_HMAP
argument_list|(
name|tsp
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
name|gp
operator|->
name|dq
argument_list|,
name|tsp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|gp
operator|->
name|hq
argument_list|,
name|tsp
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* XXXX Change if hidden screens per window */
name|gp
operator|->
name|scr_discard
argument_list|(
name|tsp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Move current screen back to the display queue. */
name|TAILQ_REMOVE
argument_list|(
name|gp
operator|->
name|hq
argument_list|,
name|sp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|gp
operator|->
name|dq
argument_list|,
name|sp
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|hidden
operator|>
literal|1
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"319|%d screens backgrounded; use :display to list them"
argument_list|,
name|hidden
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * v_curword --  *	Get the word (tagstring, actually) the cursor is on.  *  * PUBLIC: int v_curword __P((SCR *));  */
end_comment

begin_function
name|int
name|v_curword
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
name|size_t
name|beg
decl_stmt|,
name|end
decl_stmt|,
name|len
decl_stmt|;
name|int
name|moved
decl_stmt|;
name|CHAR_T
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|db_get
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
name|DBG_FATAL
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * !!! 	 * Historically, tag commands skipped over any leading whitespace 	 * characters.  Make this true in general when using cursor words. 	 * If movement, getting a cursor word implies moving the cursor to 	 * its beginning.  Refresh now. 	 * 	 * !!! 	 * Find the beginning/end of the keyword.  Keywords are currently 	 * used for cursor-word searching and for tags.  Historical vi 	 * only used the word in a tag search from the cursor to the end 	 * of the word, i.e. if the cursor was on the 'b' in " abc ", the 	 * tag was "bc".  For consistency, we make cursor word searches 	 * follow the same rule. 	 */
for|for
control|(
name|moved
operator|=
literal|0
operator|,
name|beg
operator|=
name|sp
operator|->
name|cno
init|;
name|beg
operator|<
name|len
operator|&&
name|ISSPACE
argument_list|(
name|p
index|[
name|beg
index|]
argument_list|)
condition|;
name|moved
operator|=
literal|1
operator|,
operator|++
name|beg
control|)
empty_stmt|;
if|if
condition|(
name|beg
operator|>=
name|len
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"212|Cursor not in a word"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|moved
condition|)
block|{
name|sp
operator|->
name|cno
operator|=
name|beg
expr_stmt|;
operator|(
name|void
operator|)
name|vs_refresh
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Find the end of the word. 	 * 	 * !!! 	 * Historically, vi accepted any non-blank as initial character 	 * when building up a tagstring.  Required by IEEE 1003.1-2001. 	 */
for|for
control|(
name|end
operator|=
name|beg
init|;
operator|++
name|end
operator|<
name|len
operator|&&
name|inword
argument_list|(
name|p
index|[
name|end
index|]
argument_list|)
condition|;
control|)
empty_stmt|;
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|vip
operator|->
name|klen
operator|=
name|len
operator|=
operator|(
name|end
operator|-
name|beg
operator|)
expr_stmt|;
name|BINC_RETW
argument_list|(
name|sp
argument_list|,
name|vip
operator|->
name|keyw
argument_list|,
name|vip
operator|->
name|keywlen
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|MEMMOVE
argument_list|(
name|vip
operator|->
name|keyw
argument_list|,
name|p
operator|+
name|beg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|vip
operator|->
name|keyw
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* XXX */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_alias --  *	Check for a command alias.  */
end_comment

begin_function
specifier|static
name|VIKEYS
specifier|const
modifier|*
name|v_alias
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|VICMD
modifier|*
name|vp
parameter_list|,
name|VIKEYS
specifier|const
modifier|*
name|kp
parameter_list|)
block|{
name|CHAR_T
name|push
decl_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|key
condition|)
block|{
case|case
literal|'C'
case|:
comment|/* C -> c$ */
name|push
operator|=
literal|'$'
expr_stmt|;
name|vp
operator|->
name|key
operator|=
literal|'c'
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* D -> d$ */
name|push
operator|=
literal|'$'
expr_stmt|;
name|vp
operator|->
name|key
operator|=
literal|'d'
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* S -> c_ */
name|push
operator|=
literal|'_'
expr_stmt|;
name|vp
operator|->
name|key
operator|=
literal|'c'
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
comment|/* Y -> y_ */
name|push
operator|=
literal|'_'
expr_stmt|;
name|vp
operator|->
name|key
operator|=
literal|'y'
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|kp
operator|)
return|;
block|}
return|return
operator|(
name|v_event_push
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
operator|&
name|push
argument_list|,
literal|1
argument_list|,
name|CH_NOMAP
operator||
name|CH_QUOTED
argument_list|)
condition|?
name|NULL
else|:
operator|&
name|vikeys
index|[
name|vp
operator|->
name|key
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_count --  *	Return the next count.  */
end_comment

begin_function
specifier|static
name|int
name|v_count
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|ARG_CHAR_T
name|fkey
parameter_list|,
name|u_long
modifier|*
name|countp
parameter_list|)
block|{
name|EVENT
name|ev
decl_stmt|;
name|u_long
name|count
decl_stmt|,
name|tc
decl_stmt|;
name|ev
operator|.
name|e_c
operator|=
name|fkey
expr_stmt|;
name|count
operator|=
name|tc
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* 		 * XXX 		 * Assume that overflow results in a smaller number. 		 */
name|tc
operator|=
name|count
operator|*
literal|10
operator|+
name|ev
operator|.
name|e_c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|tc
condition|)
block|{
comment|/* Toss to the next non-digit. */
do|do
block|{
if|if
condition|(
name|v_key
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|,
operator|&
name|ev
argument_list|,
name|EC_MAPCOMMAND
operator||
name|EC_MAPNODIGIT
argument_list|)
operator|!=
name|GC_OK
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
name|ISDIGIT
argument_list|(
name|ev
operator|.
name|e_c
argument_list|)
condition|)
do|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"235|Number larger than %lu"
argument_list|,
name|ULONG_MAX
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|count
operator|=
name|tc
expr_stmt|;
if|if
condition|(
name|v_key
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|,
operator|&
name|ev
argument_list|,
name|EC_MAPCOMMAND
operator||
name|EC_MAPNODIGIT
argument_list|)
operator|!=
name|GC_OK
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
name|ISDIGIT
argument_list|(
name|ev
operator|.
name|e_c
argument_list|)
condition|)
do|;
operator|*
name|countp
operator|=
name|count
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * v_key --  *	Return the next event.  */
end_comment

begin_function
specifier|static
name|gcret_t
name|v_key
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|int
name|command_events
parameter_list|,
name|EVENT
modifier|*
name|evp
parameter_list|,
name|u_int32_t
name|ec_flags
parameter_list|)
block|{
name|u_int32_t
name|quote
decl_stmt|;
for|for
control|(
name|quote
operator|=
literal|0
init|;
condition|;
control|)
block|{
if|if
condition|(
name|v_event_get
argument_list|(
name|sp
argument_list|,
name|evp
argument_list|,
literal|0
argument_list|,
name|ec_flags
operator||
name|quote
argument_list|)
condition|)
return|return
operator|(
name|GC_FATAL
operator|)
return|;
name|quote
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|evp
operator|->
name|e_event
condition|)
block|{
case|case
name|E_CHARACTER
case|:
comment|/* 			 * !!! 			 * Historically, ^V was ignored in the command stream, 			 * although it had a useful side-effect of interrupting 			 * mappings.  Adding a quoting bit to the call probably 			 * extends historic practice, but it feels right. 			 */
if|if
condition|(
name|evp
operator|->
name|e_value
operator|==
name|K_VLNEXT
condition|)
block|{
name|quote
operator|=
name|EC_QUOTED
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|GC_OK
operator|)
return|;
case|case
name|E_ERR
case|:
case|case
name|E_EOF
case|:
return|return
operator|(
name|GC_FATAL
operator|)
return|;
case|case
name|E_INTERRUPT
case|:
comment|/* 			 * !!! 			 * Historically, vi beeped on command level interrupts. 			 * 			 * Historically, vi exited to ex mode if no file was 			 * named on the command line, and two interrupts were 			 * generated in a row.  (Just figured you might want 			 * to know that.) 			 */
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_bell
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|GC_INTERRUPT
operator|)
return|;
case|case
name|E_REPAINT
case|:
if|if
condition|(
name|vs_repaint
argument_list|(
name|sp
argument_list|,
name|evp
argument_list|)
condition|)
return|return
operator|(
name|GC_FATAL
operator|)
return|;
break|break;
case|case
name|E_WRESIZE
case|:
return|return
operator|(
name|GC_ERR
operator|)
return|;
comment|/* FALLTHROUGH */
default|default:
name|v_event_err
argument_list|(
name|sp
argument_list|,
name|evp
argument_list|)
expr_stmt|;
return|return
operator|(
name|GC_ERR
operator|)
return|;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|COMLOG
argument_list|)
end_if

begin_comment
comment|/*  * v_comlog --  *	Log the contents of the command structure.  */
end_comment

begin_function
specifier|static
name|void
name|v_comlog
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|VICMD
modifier|*
name|vp
parameter_list|)
block|{
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"vcmd: "
name|WC
argument_list|,
name|vp
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_BUFFER
argument_list|)
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|" buffer: "
name|WC
argument_list|,
name|vp
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|" c1: %lu"
argument_list|,
name|vp
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C2SET
argument_list|)
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|" c2: %lu"
argument_list|,
name|vp
operator|->
name|count2
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|" flags: 0x%x\n"
argument_list|,
name|vp
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

