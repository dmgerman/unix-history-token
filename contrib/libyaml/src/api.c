begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"yaml_private.h"
end_include

begin_comment
comment|/*  * Get the library version.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|const char *
argument_list|)
end_macro

begin_macro
name|yaml_get_version_string
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
return|return
name|YAML_VERSION_STRING
return|;
block|}
end_block

begin_comment
comment|/*  * Get the library version numbers.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_get_version
argument_list|(
argument|int *major
argument_list|,
argument|int *minor
argument_list|,
argument|int *patch
argument_list|)
end_macro

begin_block
block|{
operator|*
name|major
operator|=
name|YAML_VERSION_MAJOR
expr_stmt|;
operator|*
name|minor
operator|=
name|YAML_VERSION_MINOR
expr_stmt|;
operator|*
name|patch
operator|=
name|YAML_VERSION_PATCH
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Allocate a dynamic memory block.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void *
argument_list|)
end_macro

begin_macro
name|yaml_malloc
argument_list|(
argument|size_t size
argument_list|)
end_macro

begin_block
block|{
return|return
name|malloc
argument_list|(
name|size
condition|?
name|size
else|:
literal|1
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Reallocate a dynamic memory block.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void *
argument_list|)
end_macro

begin_macro
name|yaml_realloc
argument_list|(
argument|void *ptr
argument_list|,
argument|size_t size
argument_list|)
end_macro

begin_block
block|{
return|return
name|ptr
condition|?
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
condition|?
name|size
else|:
literal|1
argument_list|)
else|:
name|malloc
argument_list|(
name|size
condition|?
name|size
else|:
literal|1
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Free a dynamic memory block.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_free
argument_list|(
argument|void *ptr
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|ptr
condition|)
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Duplicate a string.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|yaml_char_t *
argument_list|)
end_macro

begin_macro
name|yaml_strdup
argument_list|(
argument|const yaml_char_t *str
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|str
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|yaml_char_t
operator|*
operator|)
name|strdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|str
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Extend a string.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_string_extend
argument_list|(
argument|yaml_char_t **start
argument_list|,
argument|yaml_char_t **pointer
argument_list|,
argument|yaml_char_t **end
argument_list|)
end_macro

begin_block
block|{
name|yaml_char_t
modifier|*
name|new_start
init|=
name|yaml_realloc
argument_list|(
operator|*
name|start
argument_list|,
operator|(
operator|*
name|end
operator|-
operator|*
name|start
operator|)
operator|*
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new_start
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
name|new_start
operator|+
operator|(
operator|*
name|end
operator|-
operator|*
name|start
operator|)
argument_list|,
literal|0
argument_list|,
operator|*
name|end
operator|-
operator|*
name|start
argument_list|)
expr_stmt|;
operator|*
name|pointer
operator|=
name|new_start
operator|+
operator|(
operator|*
name|pointer
operator|-
operator|*
name|start
operator|)
expr_stmt|;
operator|*
name|end
operator|=
name|new_start
operator|+
operator|(
operator|*
name|end
operator|-
operator|*
name|start
operator|)
operator|*
literal|2
expr_stmt|;
operator|*
name|start
operator|=
name|new_start
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * Append a string B to a string A.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_string_join
argument_list|(
argument|yaml_char_t **a_start
argument_list|,
argument|yaml_char_t **a_pointer
argument_list|,
argument|yaml_char_t **a_end
argument_list|,
argument|yaml_char_t **b_start
argument_list|,
argument|yaml_char_t **b_pointer
argument_list|,
argument|yaml_char_t **b_end
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|*
name|b_start
operator|==
operator|*
name|b_pointer
condition|)
return|return
literal|1
return|;
while|while
condition|(
operator|*
name|a_end
operator|-
operator|*
name|a_pointer
operator|<=
operator|*
name|b_pointer
operator|-
operator|*
name|b_start
condition|)
block|{
if|if
condition|(
operator|!
name|yaml_string_extend
argument_list|(
name|a_start
argument_list|,
name|a_pointer
argument_list|,
name|a_end
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
operator|*
name|a_pointer
argument_list|,
operator|*
name|b_start
argument_list|,
operator|*
name|b_pointer
operator|-
operator|*
name|b_start
argument_list|)
expr_stmt|;
operator|*
name|a_pointer
operator|+=
operator|*
name|b_pointer
operator|-
operator|*
name|b_start
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * Extend a stack.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_stack_extend
argument_list|(
argument|void **start
argument_list|,
argument|void **top
argument_list|,
argument|void **end
argument_list|)
end_macro

begin_block
block|{
name|void
modifier|*
name|new_start
decl_stmt|;
if|if
condition|(
operator|(
name|char
operator|*
operator|)
operator|*
name|end
operator|-
operator|(
name|char
operator|*
operator|)
operator|*
name|start
operator|>=
name|INT_MAX
operator|/
literal|2
condition|)
return|return
literal|0
return|;
name|new_start
operator|=
name|yaml_realloc
argument_list|(
operator|*
name|start
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|*
name|end
operator|-
operator|(
name|char
operator|*
operator|)
operator|*
name|start
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_start
condition|)
return|return
literal|0
return|;
operator|*
name|top
operator|=
operator|(
name|char
operator|*
operator|)
name|new_start
operator|+
operator|(
operator|(
name|char
operator|*
operator|)
operator|*
name|top
operator|-
operator|(
name|char
operator|*
operator|)
operator|*
name|start
operator|)
expr_stmt|;
operator|*
name|end
operator|=
operator|(
name|char
operator|*
operator|)
name|new_start
operator|+
operator|(
operator|(
name|char
operator|*
operator|)
operator|*
name|end
operator|-
operator|(
name|char
operator|*
operator|)
operator|*
name|start
operator|)
operator|*
literal|2
expr_stmt|;
operator|*
name|start
operator|=
name|new_start
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * Extend or move a queue.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_queue_extend
argument_list|(
argument|void **start
argument_list|,
argument|void **head
argument_list|,
argument|void **tail
argument_list|,
argument|void **end
argument_list|)
end_macro

begin_block
block|{
comment|/* Check if we need to resize the queue. */
if|if
condition|(
operator|*
name|start
operator|==
operator|*
name|head
operator|&&
operator|*
name|tail
operator|==
operator|*
name|end
condition|)
block|{
name|void
modifier|*
name|new_start
init|=
name|yaml_realloc
argument_list|(
operator|*
name|start
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|*
name|end
operator|-
operator|(
name|char
operator|*
operator|)
operator|*
name|start
operator|)
operator|*
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new_start
condition|)
return|return
literal|0
return|;
operator|*
name|head
operator|=
operator|(
name|char
operator|*
operator|)
name|new_start
operator|+
operator|(
operator|(
name|char
operator|*
operator|)
operator|*
name|head
operator|-
operator|(
name|char
operator|*
operator|)
operator|*
name|start
operator|)
expr_stmt|;
operator|*
name|tail
operator|=
operator|(
name|char
operator|*
operator|)
name|new_start
operator|+
operator|(
operator|(
name|char
operator|*
operator|)
operator|*
name|tail
operator|-
operator|(
name|char
operator|*
operator|)
operator|*
name|start
operator|)
expr_stmt|;
operator|*
name|end
operator|=
operator|(
name|char
operator|*
operator|)
name|new_start
operator|+
operator|(
operator|(
name|char
operator|*
operator|)
operator|*
name|end
operator|-
operator|(
name|char
operator|*
operator|)
operator|*
name|start
operator|)
operator|*
literal|2
expr_stmt|;
operator|*
name|start
operator|=
name|new_start
expr_stmt|;
block|}
comment|/* Check if we need to move the queue at the beginning of the buffer. */
if|if
condition|(
operator|*
name|tail
operator|==
operator|*
name|end
condition|)
block|{
if|if
condition|(
operator|*
name|head
operator|!=
operator|*
name|tail
condition|)
block|{
name|memmove
argument_list|(
operator|*
name|start
argument_list|,
operator|*
name|head
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|*
name|tail
operator|-
operator|(
name|char
operator|*
operator|)
operator|*
name|head
argument_list|)
expr_stmt|;
block|}
operator|*
name|tail
operator|=
operator|(
name|char
operator|*
operator|)
operator|*
name|tail
operator|-
operator|(
name|char
operator|*
operator|)
operator|*
name|head
operator|+
operator|(
name|char
operator|*
operator|)
operator|*
name|start
expr_stmt|;
operator|*
name|head
operator|=
operator|*
name|start
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * Create a new parser object.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_parser_initialize
argument_list|(
argument|yaml_parser_t *parser
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Non-NULL parser object expected. */
name|memset
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|yaml_parser_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BUFFER_INIT
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|raw_buffer
argument_list|,
name|INPUT_RAW_BUFFER_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|BUFFER_INIT
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|buffer
argument_list|,
name|INPUT_BUFFER_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|QUEUE_INIT
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|INITIAL_QUEUE_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|STACK_INIT
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|indents
argument_list|,
name|INITIAL_STACK_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|STACK_INIT
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|simple_keys
argument_list|,
name|INITIAL_STACK_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|STACK_INIT
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|,
name|INITIAL_STACK_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|STACK_INIT
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|marks
argument_list|,
name|INITIAL_STACK_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|STACK_INIT
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tag_directives
argument_list|,
name|INITIAL_STACK_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
return|return
literal|1
return|;
name|error
label|:
name|BUFFER_DEL
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|raw_buffer
argument_list|)
expr_stmt|;
name|BUFFER_DEL
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|QUEUE_DEL
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|)
expr_stmt|;
name|STACK_DEL
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|indents
argument_list|)
expr_stmt|;
name|STACK_DEL
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|simple_keys
argument_list|)
expr_stmt|;
name|STACK_DEL
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|)
expr_stmt|;
name|STACK_DEL
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|marks
argument_list|)
expr_stmt|;
name|STACK_DEL
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tag_directives
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Destroy a parser object.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_parser_delete
argument_list|(
argument|yaml_parser_t *parser
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Non-NULL parser object expected. */
name|BUFFER_DEL
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|raw_buffer
argument_list|)
expr_stmt|;
name|BUFFER_DEL
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|buffer
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|QUEUE_EMPTY
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|)
condition|)
block|{
name|yaml_token_delete
argument_list|(
operator|&
name|DEQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|QUEUE_DEL
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|)
expr_stmt|;
name|STACK_DEL
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|indents
argument_list|)
expr_stmt|;
name|STACK_DEL
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|simple_keys
argument_list|)
expr_stmt|;
name|STACK_DEL
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|)
expr_stmt|;
name|STACK_DEL
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|marks
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|STACK_EMPTY
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tag_directives
argument_list|)
condition|)
block|{
name|yaml_tag_directive_t
name|tag_directive
init|=
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tag_directives
argument_list|)
decl_stmt|;
name|yaml_free
argument_list|(
name|tag_directive
operator|.
name|handle
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|tag_directive
operator|.
name|prefix
argument_list|)
expr_stmt|;
block|}
name|STACK_DEL
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tag_directives
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|yaml_parser_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * String read handler.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_string_read_handler
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|size_read
parameter_list|)
block|{
name|yaml_parser_t
modifier|*
name|parser
init|=
name|data
decl_stmt|;
if|if
condition|(
name|parser
operator|->
name|input
operator|.
name|string
operator|.
name|current
operator|==
name|parser
operator|->
name|input
operator|.
name|string
operator|.
name|end
condition|)
block|{
operator|*
name|size_read
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|size
operator|>
call|(
name|size_t
call|)
argument_list|(
name|parser
operator|->
name|input
operator|.
name|string
operator|.
name|end
operator|-
name|parser
operator|->
name|input
operator|.
name|string
operator|.
name|current
argument_list|)
condition|)
block|{
name|size
operator|=
name|parser
operator|->
name|input
operator|.
name|string
operator|.
name|end
operator|-
name|parser
operator|->
name|input
operator|.
name|string
operator|.
name|current
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|parser
operator|->
name|input
operator|.
name|string
operator|.
name|current
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|parser
operator|->
name|input
operator|.
name|string
operator|.
name|current
operator|+=
name|size
expr_stmt|;
operator|*
name|size_read
operator|=
name|size
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * File read handler.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_file_read_handler
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|size_read
parameter_list|)
block|{
name|yaml_parser_t
modifier|*
name|parser
init|=
name|data
decl_stmt|;
operator|*
name|size_read
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|parser
operator|->
name|input
operator|.
name|file
argument_list|)
expr_stmt|;
return|return
operator|!
name|ferror
argument_list|(
name|parser
operator|->
name|input
operator|.
name|file
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set a string input.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_parser_set_input_string
argument_list|(
argument|yaml_parser_t *parser
argument_list|,
argument|const unsigned char *input
argument_list|,
argument|size_t size
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Non-NULL parser object expected. */
name|assert
argument_list|(
operator|!
name|parser
operator|->
name|read_handler
argument_list|)
expr_stmt|;
comment|/* You can set the source only once. */
name|assert
argument_list|(
name|input
argument_list|)
expr_stmt|;
comment|/* Non-NULL input string expected. */
name|parser
operator|->
name|read_handler
operator|=
name|yaml_string_read_handler
expr_stmt|;
name|parser
operator|->
name|read_handler_data
operator|=
name|parser
expr_stmt|;
name|parser
operator|->
name|input
operator|.
name|string
operator|.
name|start
operator|=
name|input
expr_stmt|;
name|parser
operator|->
name|input
operator|.
name|string
operator|.
name|current
operator|=
name|input
expr_stmt|;
name|parser
operator|->
name|input
operator|.
name|string
operator|.
name|end
operator|=
name|input
operator|+
name|size
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set a file input.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_parser_set_input_file
argument_list|(
argument|yaml_parser_t *parser
argument_list|,
argument|FILE *file
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Non-NULL parser object expected. */
name|assert
argument_list|(
operator|!
name|parser
operator|->
name|read_handler
argument_list|)
expr_stmt|;
comment|/* You can set the source only once. */
name|assert
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Non-NULL file object expected. */
name|parser
operator|->
name|read_handler
operator|=
name|yaml_file_read_handler
expr_stmt|;
name|parser
operator|->
name|read_handler_data
operator|=
name|parser
expr_stmt|;
name|parser
operator|->
name|input
operator|.
name|file
operator|=
name|file
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set a generic input.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_parser_set_input
argument_list|(
argument|yaml_parser_t *parser
argument_list|,
argument|yaml_read_handler_t *handler
argument_list|,
argument|void *data
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Non-NULL parser object expected. */
name|assert
argument_list|(
operator|!
name|parser
operator|->
name|read_handler
argument_list|)
expr_stmt|;
comment|/* You can set the source only once. */
name|assert
argument_list|(
name|handler
argument_list|)
expr_stmt|;
comment|/* Non-NULL read handler expected. */
name|parser
operator|->
name|read_handler
operator|=
name|handler
expr_stmt|;
name|parser
operator|->
name|read_handler_data
operator|=
name|data
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set the source encoding.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_parser_set_encoding
argument_list|(
argument|yaml_parser_t *parser
argument_list|,
argument|yaml_encoding_t encoding
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Non-NULL parser object expected. */
name|assert
argument_list|(
operator|!
name|parser
operator|->
name|encoding
argument_list|)
expr_stmt|;
comment|/* Encoding is already set or detected. */
name|parser
operator|->
name|encoding
operator|=
name|encoding
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Create a new emitter object.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_emitter_initialize
argument_list|(
argument|yaml_emitter_t *emitter
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|emitter
argument_list|)
expr_stmt|;
comment|/* Non-NULL emitter object expected. */
name|memset
argument_list|(
name|emitter
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|yaml_emitter_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BUFFER_INIT
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|buffer
argument_list|,
name|OUTPUT_BUFFER_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|BUFFER_INIT
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|raw_buffer
argument_list|,
name|OUTPUT_RAW_BUFFER_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|STACK_INIT
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|states
argument_list|,
name|INITIAL_STACK_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|QUEUE_INIT
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|events
argument_list|,
name|INITIAL_QUEUE_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|STACK_INIT
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|indents
argument_list|,
name|INITIAL_STACK_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|STACK_INIT
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|tag_directives
argument_list|,
name|INITIAL_STACK_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
return|return
literal|1
return|;
name|error
label|:
name|BUFFER_DEL
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|BUFFER_DEL
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|raw_buffer
argument_list|)
expr_stmt|;
name|STACK_DEL
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|states
argument_list|)
expr_stmt|;
name|QUEUE_DEL
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|events
argument_list|)
expr_stmt|;
name|STACK_DEL
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|indents
argument_list|)
expr_stmt|;
name|STACK_DEL
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|tag_directives
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Destroy an emitter object.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_emitter_delete
argument_list|(
argument|yaml_emitter_t *emitter
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|emitter
argument_list|)
expr_stmt|;
comment|/* Non-NULL emitter object expected. */
name|BUFFER_DEL
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|BUFFER_DEL
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|raw_buffer
argument_list|)
expr_stmt|;
name|STACK_DEL
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|states
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|QUEUE_EMPTY
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|events
argument_list|)
condition|)
block|{
name|yaml_event_delete
argument_list|(
operator|&
name|DEQUEUE
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|events
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|QUEUE_DEL
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|events
argument_list|)
expr_stmt|;
name|STACK_DEL
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|indents
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|STACK_EMPTY
argument_list|(
name|empty
argument_list|,
name|emitter
operator|->
name|tag_directives
argument_list|)
condition|)
block|{
name|yaml_tag_directive_t
name|tag_directive
init|=
name|POP
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|tag_directives
argument_list|)
decl_stmt|;
name|yaml_free
argument_list|(
name|tag_directive
operator|.
name|handle
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|tag_directive
operator|.
name|prefix
argument_list|)
expr_stmt|;
block|}
name|STACK_DEL
argument_list|(
name|emitter
argument_list|,
name|emitter
operator|->
name|tag_directives
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|emitter
operator|->
name|anchors
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|emitter
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|yaml_emitter_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * String write handler.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_string_write_handler
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|yaml_emitter_t
modifier|*
name|emitter
init|=
name|data
decl_stmt|;
if|if
condition|(
name|emitter
operator|->
name|output
operator|.
name|string
operator|.
name|size
operator|+
operator|*
name|emitter
operator|->
name|output
operator|.
name|string
operator|.
name|size_written
operator|<
name|size
condition|)
block|{
name|memcpy
argument_list|(
name|emitter
operator|->
name|output
operator|.
name|string
operator|.
name|buffer
operator|+
operator|*
name|emitter
operator|->
name|output
operator|.
name|string
operator|.
name|size_written
argument_list|,
name|buffer
argument_list|,
name|emitter
operator|->
name|output
operator|.
name|string
operator|.
name|size
operator|-
operator|*
name|emitter
operator|->
name|output
operator|.
name|string
operator|.
name|size_written
argument_list|)
expr_stmt|;
operator|*
name|emitter
operator|->
name|output
operator|.
name|string
operator|.
name|size_written
operator|=
name|emitter
operator|->
name|output
operator|.
name|string
operator|.
name|size
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|emitter
operator|->
name|output
operator|.
name|string
operator|.
name|buffer
operator|+
operator|*
name|emitter
operator|->
name|output
operator|.
name|string
operator|.
name|size_written
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|*
name|emitter
operator|->
name|output
operator|.
name|string
operator|.
name|size_written
operator|+=
name|size
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * File write handler.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_file_write_handler
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|yaml_emitter_t
modifier|*
name|emitter
init|=
name|data
decl_stmt|;
return|return
operator|(
name|fwrite
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|emitter
operator|->
name|output
operator|.
name|file
argument_list|)
operator|==
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set a string output.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_emitter_set_output_string
argument_list|(
argument|yaml_emitter_t *emitter
argument_list|,
argument|unsigned char *output
argument_list|,
argument|size_t size
argument_list|,
argument|size_t *size_written
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|emitter
argument_list|)
expr_stmt|;
comment|/* Non-NULL emitter object expected. */
name|assert
argument_list|(
operator|!
name|emitter
operator|->
name|write_handler
argument_list|)
expr_stmt|;
comment|/* You can set the output only once. */
name|assert
argument_list|(
name|output
argument_list|)
expr_stmt|;
comment|/* Non-NULL output string expected. */
name|emitter
operator|->
name|write_handler
operator|=
name|yaml_string_write_handler
expr_stmt|;
name|emitter
operator|->
name|write_handler_data
operator|=
name|emitter
expr_stmt|;
name|emitter
operator|->
name|output
operator|.
name|string
operator|.
name|buffer
operator|=
name|output
expr_stmt|;
name|emitter
operator|->
name|output
operator|.
name|string
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|emitter
operator|->
name|output
operator|.
name|string
operator|.
name|size_written
operator|=
name|size_written
expr_stmt|;
operator|*
name|size_written
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set a file output.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_emitter_set_output_file
argument_list|(
argument|yaml_emitter_t *emitter
argument_list|,
argument|FILE *file
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|emitter
argument_list|)
expr_stmt|;
comment|/* Non-NULL emitter object expected. */
name|assert
argument_list|(
operator|!
name|emitter
operator|->
name|write_handler
argument_list|)
expr_stmt|;
comment|/* You can set the output only once. */
name|assert
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Non-NULL file object expected. */
name|emitter
operator|->
name|write_handler
operator|=
name|yaml_file_write_handler
expr_stmt|;
name|emitter
operator|->
name|write_handler_data
operator|=
name|emitter
expr_stmt|;
name|emitter
operator|->
name|output
operator|.
name|file
operator|=
name|file
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set a generic output handler.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_emitter_set_output
argument_list|(
argument|yaml_emitter_t *emitter
argument_list|,
argument|yaml_write_handler_t *handler
argument_list|,
argument|void *data
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|emitter
argument_list|)
expr_stmt|;
comment|/* Non-NULL emitter object expected. */
name|assert
argument_list|(
operator|!
name|emitter
operator|->
name|write_handler
argument_list|)
expr_stmt|;
comment|/* You can set the output only once. */
name|assert
argument_list|(
name|handler
argument_list|)
expr_stmt|;
comment|/* Non-NULL handler object expected. */
name|emitter
operator|->
name|write_handler
operator|=
name|handler
expr_stmt|;
name|emitter
operator|->
name|write_handler_data
operator|=
name|data
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set the output encoding.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_emitter_set_encoding
argument_list|(
argument|yaml_emitter_t *emitter
argument_list|,
argument|yaml_encoding_t encoding
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|emitter
argument_list|)
expr_stmt|;
comment|/* Non-NULL emitter object expected. */
name|assert
argument_list|(
operator|!
name|emitter
operator|->
name|encoding
argument_list|)
expr_stmt|;
comment|/* You can set encoding only once. */
name|emitter
operator|->
name|encoding
operator|=
name|encoding
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set the canonical output style.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_emitter_set_canonical
argument_list|(
argument|yaml_emitter_t *emitter
argument_list|,
argument|int canonical
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|emitter
argument_list|)
expr_stmt|;
comment|/* Non-NULL emitter object expected. */
name|emitter
operator|->
name|canonical
operator|=
operator|(
name|canonical
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set the indentation increment.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_emitter_set_indent
argument_list|(
argument|yaml_emitter_t *emitter
argument_list|,
argument|int indent
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|emitter
argument_list|)
expr_stmt|;
comment|/* Non-NULL emitter object expected. */
name|emitter
operator|->
name|best_indent
operator|=
operator|(
literal|1
operator|<
name|indent
operator|&&
name|indent
operator|<
literal|10
operator|)
condition|?
name|indent
else|:
literal|2
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set the preferred line width.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_emitter_set_width
argument_list|(
argument|yaml_emitter_t *emitter
argument_list|,
argument|int width
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|emitter
argument_list|)
expr_stmt|;
comment|/* Non-NULL emitter object expected. */
name|emitter
operator|->
name|best_width
operator|=
operator|(
name|width
operator|>=
literal|0
operator|)
condition|?
name|width
else|:
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set if unescaped non-ASCII characters are allowed.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_emitter_set_unicode
argument_list|(
argument|yaml_emitter_t *emitter
argument_list|,
argument|int unicode
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|emitter
argument_list|)
expr_stmt|;
comment|/* Non-NULL emitter object expected. */
name|emitter
operator|->
name|unicode
operator|=
operator|(
name|unicode
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set the preferred line break character.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_emitter_set_break
argument_list|(
argument|yaml_emitter_t *emitter
argument_list|,
argument|yaml_break_t line_break
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|emitter
argument_list|)
expr_stmt|;
comment|/* Non-NULL emitter object expected. */
name|emitter
operator|->
name|line_break
operator|=
name|line_break
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Destroy a token object.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_token_delete
argument_list|(
argument|yaml_token_t *token
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|token
argument_list|)
expr_stmt|;
comment|/* Non-NULL token object expected. */
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|YAML_TAG_DIRECTIVE_TOKEN
case|:
name|yaml_free
argument_list|(
name|token
operator|->
name|data
operator|.
name|tag_directive
operator|.
name|handle
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|token
operator|->
name|data
operator|.
name|tag_directive
operator|.
name|prefix
argument_list|)
expr_stmt|;
break|break;
case|case
name|YAML_ALIAS_TOKEN
case|:
name|yaml_free
argument_list|(
name|token
operator|->
name|data
operator|.
name|alias
operator|.
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|YAML_ANCHOR_TOKEN
case|:
name|yaml_free
argument_list|(
name|token
operator|->
name|data
operator|.
name|anchor
operator|.
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|YAML_TAG_TOKEN
case|:
name|yaml_free
argument_list|(
name|token
operator|->
name|data
operator|.
name|tag
operator|.
name|handle
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|token
operator|->
name|data
operator|.
name|tag
operator|.
name|suffix
argument_list|)
expr_stmt|;
break|break;
case|case
name|YAML_SCALAR_TOKEN
case|:
name|yaml_free
argument_list|(
name|token
operator|->
name|data
operator|.
name|scalar
operator|.
name|value
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|memset
argument_list|(
name|token
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|yaml_token_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Check if a string is a valid UTF-8 sequence.  *  * Check 'reader.c' for more details on UTF-8 encoding.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_check_utf8
parameter_list|(
name|yaml_char_t
modifier|*
name|start
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|yaml_char_t
modifier|*
name|end
init|=
name|start
operator|+
name|length
decl_stmt|;
name|yaml_char_t
modifier|*
name|pointer
init|=
name|start
decl_stmt|;
while|while
condition|(
name|pointer
operator|<
name|end
condition|)
block|{
name|unsigned
name|char
name|octet
decl_stmt|;
name|unsigned
name|int
name|width
decl_stmt|;
name|unsigned
name|int
name|value
decl_stmt|;
name|size_t
name|k
decl_stmt|;
name|octet
operator|=
name|pointer
index|[
literal|0
index|]
expr_stmt|;
name|width
operator|=
operator|(
name|octet
operator|&
literal|0x80
operator|)
operator|==
literal|0x00
condition|?
literal|1
else|:
operator|(
name|octet
operator|&
literal|0xE0
operator|)
operator|==
literal|0xC0
condition|?
literal|2
else|:
operator|(
name|octet
operator|&
literal|0xF0
operator|)
operator|==
literal|0xE0
condition|?
literal|3
else|:
operator|(
name|octet
operator|&
literal|0xF8
operator|)
operator|==
literal|0xF0
condition|?
literal|4
else|:
literal|0
expr_stmt|;
name|value
operator|=
operator|(
name|octet
operator|&
literal|0x80
operator|)
operator|==
literal|0x00
condition|?
name|octet
operator|&
literal|0x7F
else|:
operator|(
name|octet
operator|&
literal|0xE0
operator|)
operator|==
literal|0xC0
condition|?
name|octet
operator|&
literal|0x1F
else|:
operator|(
name|octet
operator|&
literal|0xF0
operator|)
operator|==
literal|0xE0
condition|?
name|octet
operator|&
literal|0x0F
else|:
operator|(
name|octet
operator|&
literal|0xF8
operator|)
operator|==
literal|0xF0
condition|?
name|octet
operator|&
literal|0x07
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|width
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pointer
operator|+
name|width
operator|>
name|end
condition|)
return|return
literal|0
return|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|width
condition|;
name|k
operator|++
control|)
block|{
name|octet
operator|=
name|pointer
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|octet
operator|&
literal|0xC0
operator|)
operator|!=
literal|0x80
condition|)
return|return
literal|0
return|;
name|value
operator|=
operator|(
name|value
operator|<<
literal|6
operator|)
operator|+
operator|(
name|octet
operator|&
literal|0x3F
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
name|width
operator|==
literal|1
operator|)
operator|||
operator|(
name|width
operator|==
literal|2
operator|&&
name|value
operator|>=
literal|0x80
operator|)
operator|||
operator|(
name|width
operator|==
literal|3
operator|&&
name|value
operator|>=
literal|0x800
operator|)
operator|||
operator|(
name|width
operator|==
literal|4
operator|&&
name|value
operator|>=
literal|0x10000
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|pointer
operator|+=
name|width
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Create STREAM-START.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_stream_start_event_initialize
argument_list|(
argument|yaml_event_t *event
argument_list|,
argument|yaml_encoding_t encoding
argument_list|)
end_macro

begin_block
block|{
name|yaml_mark_t
name|mark
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|assert
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|/* Non-NULL event object is expected. */
name|STREAM_START_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|encoding
argument_list|,
name|mark
argument_list|,
name|mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * Create STREAM-END.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_stream_end_event_initialize
argument_list|(
argument|yaml_event_t *event
argument_list|)
end_macro

begin_block
block|{
name|yaml_mark_t
name|mark
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|assert
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|/* Non-NULL event object is expected. */
name|STREAM_END_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|mark
argument_list|,
name|mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * Create DOCUMENT-START.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_document_start_event_initialize
argument_list|(
argument|yaml_event_t *event
argument_list|,
argument|yaml_version_directive_t *version_directive
argument_list|,
argument|yaml_tag_directive_t *tag_directives_start
argument_list|,
argument|yaml_tag_directive_t *tag_directives_end
argument_list|,
argument|int implicit
argument_list|)
end_macro

begin_block
block|{
struct|struct
block|{
name|yaml_error_type_t
name|error
decl_stmt|;
block|}
name|context
struct|;
name|yaml_mark_t
name|mark
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|yaml_version_directive_t
modifier|*
name|version_directive_copy
init|=
name|NULL
decl_stmt|;
struct|struct
block|{
name|yaml_tag_directive_t
modifier|*
name|start
decl_stmt|;
name|yaml_tag_directive_t
modifier|*
name|end
decl_stmt|;
name|yaml_tag_directive_t
modifier|*
name|top
decl_stmt|;
block|}
name|tag_directives_copy
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
struct|;
name|yaml_tag_directive_t
name|value
init|=
block|{
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|assert
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|/* Non-NULL event object is expected. */
name|assert
argument_list|(
operator|(
name|tag_directives_start
operator|&&
name|tag_directives_end
operator|)
operator|||
operator|(
name|tag_directives_start
operator|==
name|tag_directives_end
operator|)
argument_list|)
expr_stmt|;
comment|/* Valid tag directives are expected. */
if|if
condition|(
name|version_directive
condition|)
block|{
name|version_directive_copy
operator|=
name|yaml_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|yaml_version_directive_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|version_directive_copy
condition|)
goto|goto
name|error
goto|;
name|version_directive_copy
operator|->
name|major
operator|=
name|version_directive
operator|->
name|major
expr_stmt|;
name|version_directive_copy
operator|->
name|minor
operator|=
name|version_directive
operator|->
name|minor
expr_stmt|;
block|}
if|if
condition|(
name|tag_directives_start
operator|!=
name|tag_directives_end
condition|)
block|{
name|yaml_tag_directive_t
modifier|*
name|tag_directive
decl_stmt|;
if|if
condition|(
operator|!
name|STACK_INIT
argument_list|(
operator|&
name|context
argument_list|,
name|tag_directives_copy
argument_list|,
name|INITIAL_STACK_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
for|for
control|(
name|tag_directive
operator|=
name|tag_directives_start
init|;
name|tag_directive
operator|!=
name|tag_directives_end
condition|;
name|tag_directive
operator|++
control|)
block|{
name|assert
argument_list|(
name|tag_directive
operator|->
name|handle
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tag_directive
operator|->
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yaml_check_utf8
argument_list|(
name|tag_directive
operator|->
name|handle
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tag_directive
operator|->
name|handle
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|yaml_check_utf8
argument_list|(
name|tag_directive
operator|->
name|prefix
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tag_directive
operator|->
name|prefix
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|value
operator|.
name|handle
operator|=
name|yaml_strdup
argument_list|(
name|tag_directive
operator|->
name|handle
argument_list|)
expr_stmt|;
name|value
operator|.
name|prefix
operator|=
name|yaml_strdup
argument_list|(
name|tag_directive
operator|->
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
operator|.
name|handle
operator|||
operator|!
name|value
operator|.
name|prefix
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|PUSH
argument_list|(
operator|&
name|context
argument_list|,
name|tag_directives_copy
argument_list|,
name|value
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|value
operator|.
name|handle
operator|=
name|NULL
expr_stmt|;
name|value
operator|.
name|prefix
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|DOCUMENT_START_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|version_directive_copy
argument_list|,
name|tag_directives_copy
operator|.
name|start
argument_list|,
name|tag_directives_copy
operator|.
name|top
argument_list|,
name|implicit
argument_list|,
name|mark
argument_list|,
name|mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|error
label|:
name|yaml_free
argument_list|(
name|version_directive_copy
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|STACK_EMPTY
argument_list|(
name|context
argument_list|,
name|tag_directives_copy
argument_list|)
condition|)
block|{
name|yaml_tag_directive_t
name|value
init|=
name|POP
argument_list|(
name|context
argument_list|,
name|tag_directives_copy
argument_list|)
decl_stmt|;
name|yaml_free
argument_list|(
name|value
operator|.
name|handle
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|value
operator|.
name|prefix
argument_list|)
expr_stmt|;
block|}
name|STACK_DEL
argument_list|(
name|context
argument_list|,
name|tag_directives_copy
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|value
operator|.
name|handle
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|value
operator|.
name|prefix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Create DOCUMENT-END.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_document_end_event_initialize
argument_list|(
argument|yaml_event_t *event
argument_list|,
argument|int implicit
argument_list|)
end_macro

begin_block
block|{
name|yaml_mark_t
name|mark
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|assert
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|/* Non-NULL emitter object is expected. */
name|DOCUMENT_END_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|implicit
argument_list|,
name|mark
argument_list|,
name|mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * Create ALIAS.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_alias_event_initialize
argument_list|(
argument|yaml_event_t *event
argument_list|,
argument|yaml_char_t *anchor
argument_list|)
end_macro

begin_block
block|{
name|yaml_mark_t
name|mark
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|yaml_char_t
modifier|*
name|anchor_copy
init|=
name|NULL
decl_stmt|;
name|assert
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|/* Non-NULL event object is expected. */
name|assert
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
comment|/* Non-NULL anchor is expected. */
if|if
condition|(
operator|!
name|yaml_check_utf8
argument_list|(
name|anchor
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|anchor
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|anchor_copy
operator|=
name|yaml_strdup
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anchor_copy
condition|)
return|return
literal|0
return|;
name|ALIAS_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|anchor_copy
argument_list|,
name|mark
argument_list|,
name|mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * Create SCALAR.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_scalar_event_initialize
argument_list|(
argument|yaml_event_t *event
argument_list|,
argument|yaml_char_t *anchor
argument_list|,
argument|yaml_char_t *tag
argument_list|,
argument|yaml_char_t *value
argument_list|,
argument|int length
argument_list|,
argument|int plain_implicit
argument_list|,
argument|int quoted_implicit
argument_list|,
argument|yaml_scalar_style_t style
argument_list|)
end_macro

begin_block
block|{
name|yaml_mark_t
name|mark
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|yaml_char_t
modifier|*
name|anchor_copy
init|=
name|NULL
decl_stmt|;
name|yaml_char_t
modifier|*
name|tag_copy
init|=
name|NULL
decl_stmt|;
name|yaml_char_t
modifier|*
name|value_copy
init|=
name|NULL
decl_stmt|;
name|assert
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|/* Non-NULL event object is expected. */
name|assert
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Non-NULL anchor is expected. */
if|if
condition|(
name|anchor
condition|)
block|{
if|if
condition|(
operator|!
name|yaml_check_utf8
argument_list|(
name|anchor
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|anchor
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|anchor_copy
operator|=
name|yaml_strdup
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anchor_copy
condition|)
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|tag
condition|)
block|{
if|if
condition|(
operator|!
name|yaml_check_utf8
argument_list|(
name|tag
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tag
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|tag_copy
operator|=
name|yaml_strdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tag_copy
condition|)
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|length
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|yaml_check_utf8
argument_list|(
name|value
argument_list|,
name|length
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|value_copy
operator|=
name|yaml_malloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value_copy
condition|)
goto|goto
name|error
goto|;
name|memcpy
argument_list|(
name|value_copy
argument_list|,
name|value
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|value_copy
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SCALAR_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|anchor_copy
argument_list|,
name|tag_copy
argument_list|,
name|value_copy
argument_list|,
name|length
argument_list|,
name|plain_implicit
argument_list|,
name|quoted_implicit
argument_list|,
name|style
argument_list|,
name|mark
argument_list|,
name|mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|error
label|:
name|yaml_free
argument_list|(
name|anchor_copy
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|tag_copy
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|value_copy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Create SEQUENCE-START.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_sequence_start_event_initialize
argument_list|(
argument|yaml_event_t *event
argument_list|,
argument|yaml_char_t *anchor
argument_list|,
argument|yaml_char_t *tag
argument_list|,
argument|int implicit
argument_list|,
argument|yaml_sequence_style_t style
argument_list|)
end_macro

begin_block
block|{
name|yaml_mark_t
name|mark
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|yaml_char_t
modifier|*
name|anchor_copy
init|=
name|NULL
decl_stmt|;
name|yaml_char_t
modifier|*
name|tag_copy
init|=
name|NULL
decl_stmt|;
name|assert
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|/* Non-NULL event object is expected. */
if|if
condition|(
name|anchor
condition|)
block|{
if|if
condition|(
operator|!
name|yaml_check_utf8
argument_list|(
name|anchor
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|anchor
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|anchor_copy
operator|=
name|yaml_strdup
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anchor_copy
condition|)
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|tag
condition|)
block|{
if|if
condition|(
operator|!
name|yaml_check_utf8
argument_list|(
name|tag
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tag
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|tag_copy
operator|=
name|yaml_strdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tag_copy
condition|)
goto|goto
name|error
goto|;
block|}
name|SEQUENCE_START_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|anchor_copy
argument_list|,
name|tag_copy
argument_list|,
name|implicit
argument_list|,
name|style
argument_list|,
name|mark
argument_list|,
name|mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|error
label|:
name|yaml_free
argument_list|(
name|anchor_copy
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|tag_copy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Create SEQUENCE-END.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_sequence_end_event_initialize
argument_list|(
argument|yaml_event_t *event
argument_list|)
end_macro

begin_block
block|{
name|yaml_mark_t
name|mark
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|assert
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|/* Non-NULL event object is expected. */
name|SEQUENCE_END_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|mark
argument_list|,
name|mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * Create MAPPING-START.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_mapping_start_event_initialize
argument_list|(
argument|yaml_event_t *event
argument_list|,
argument|yaml_char_t *anchor
argument_list|,
argument|yaml_char_t *tag
argument_list|,
argument|int implicit
argument_list|,
argument|yaml_mapping_style_t style
argument_list|)
end_macro

begin_block
block|{
name|yaml_mark_t
name|mark
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|yaml_char_t
modifier|*
name|anchor_copy
init|=
name|NULL
decl_stmt|;
name|yaml_char_t
modifier|*
name|tag_copy
init|=
name|NULL
decl_stmt|;
name|assert
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|/* Non-NULL event object is expected. */
if|if
condition|(
name|anchor
condition|)
block|{
if|if
condition|(
operator|!
name|yaml_check_utf8
argument_list|(
name|anchor
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|anchor
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|anchor_copy
operator|=
name|yaml_strdup
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anchor_copy
condition|)
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|tag
condition|)
block|{
if|if
condition|(
operator|!
name|yaml_check_utf8
argument_list|(
name|tag
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tag
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|tag_copy
operator|=
name|yaml_strdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tag_copy
condition|)
goto|goto
name|error
goto|;
block|}
name|MAPPING_START_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|anchor_copy
argument_list|,
name|tag_copy
argument_list|,
name|implicit
argument_list|,
name|style
argument_list|,
name|mark
argument_list|,
name|mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|error
label|:
name|yaml_free
argument_list|(
name|anchor_copy
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|tag_copy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Create MAPPING-END.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_mapping_end_event_initialize
argument_list|(
argument|yaml_event_t *event
argument_list|)
end_macro

begin_block
block|{
name|yaml_mark_t
name|mark
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|assert
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|/* Non-NULL event object is expected. */
name|MAPPING_END_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|mark
argument_list|,
name|mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * Destroy an event object.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_event_delete
argument_list|(
argument|yaml_event_t *event
argument_list|)
end_macro

begin_block
block|{
name|yaml_tag_directive_t
modifier|*
name|tag_directive
decl_stmt|;
name|assert
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|/* Non-NULL event object expected. */
switch|switch
condition|(
name|event
operator|->
name|type
condition|)
block|{
case|case
name|YAML_DOCUMENT_START_EVENT
case|:
name|yaml_free
argument_list|(
name|event
operator|->
name|data
operator|.
name|document_start
operator|.
name|version_directive
argument_list|)
expr_stmt|;
for|for
control|(
name|tag_directive
operator|=
name|event
operator|->
name|data
operator|.
name|document_start
operator|.
name|tag_directives
operator|.
name|start
init|;
name|tag_directive
operator|!=
name|event
operator|->
name|data
operator|.
name|document_start
operator|.
name|tag_directives
operator|.
name|end
condition|;
name|tag_directive
operator|++
control|)
block|{
name|yaml_free
argument_list|(
name|tag_directive
operator|->
name|handle
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|tag_directive
operator|->
name|prefix
argument_list|)
expr_stmt|;
block|}
name|yaml_free
argument_list|(
name|event
operator|->
name|data
operator|.
name|document_start
operator|.
name|tag_directives
operator|.
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
name|YAML_ALIAS_EVENT
case|:
name|yaml_free
argument_list|(
name|event
operator|->
name|data
operator|.
name|alias
operator|.
name|anchor
argument_list|)
expr_stmt|;
break|break;
case|case
name|YAML_SCALAR_EVENT
case|:
name|yaml_free
argument_list|(
name|event
operator|->
name|data
operator|.
name|scalar
operator|.
name|anchor
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|event
operator|->
name|data
operator|.
name|scalar
operator|.
name|tag
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|event
operator|->
name|data
operator|.
name|scalar
operator|.
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|YAML_SEQUENCE_START_EVENT
case|:
name|yaml_free
argument_list|(
name|event
operator|->
name|data
operator|.
name|sequence_start
operator|.
name|anchor
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|event
operator|->
name|data
operator|.
name|sequence_start
operator|.
name|tag
argument_list|)
expr_stmt|;
break|break;
case|case
name|YAML_MAPPING_START_EVENT
case|:
name|yaml_free
argument_list|(
name|event
operator|->
name|data
operator|.
name|mapping_start
operator|.
name|anchor
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|event
operator|->
name|data
operator|.
name|mapping_start
operator|.
name|tag
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|memset
argument_list|(
name|event
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|yaml_event_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Create a document object.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_document_initialize
argument_list|(
argument|yaml_document_t *document
argument_list|,
argument|yaml_version_directive_t *version_directive
argument_list|,
argument|yaml_tag_directive_t *tag_directives_start
argument_list|,
argument|yaml_tag_directive_t *tag_directives_end
argument_list|,
argument|int start_implicit
argument_list|,
argument|int end_implicit
argument_list|)
end_macro

begin_block
block|{
struct|struct
block|{
name|yaml_error_type_t
name|error
decl_stmt|;
block|}
name|context
struct|;
struct|struct
block|{
name|yaml_node_t
modifier|*
name|start
decl_stmt|;
name|yaml_node_t
modifier|*
name|end
decl_stmt|;
name|yaml_node_t
modifier|*
name|top
decl_stmt|;
block|}
name|nodes
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
struct|;
name|yaml_version_directive_t
modifier|*
name|version_directive_copy
init|=
name|NULL
decl_stmt|;
struct|struct
block|{
name|yaml_tag_directive_t
modifier|*
name|start
decl_stmt|;
name|yaml_tag_directive_t
modifier|*
name|end
decl_stmt|;
name|yaml_tag_directive_t
modifier|*
name|top
decl_stmt|;
block|}
name|tag_directives_copy
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
struct|;
name|yaml_tag_directive_t
name|value
init|=
block|{
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|yaml_mark_t
name|mark
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|assert
argument_list|(
name|document
argument_list|)
expr_stmt|;
comment|/* Non-NULL document object is expected. */
name|assert
argument_list|(
operator|(
name|tag_directives_start
operator|&&
name|tag_directives_end
operator|)
operator|||
operator|(
name|tag_directives_start
operator|==
name|tag_directives_end
operator|)
argument_list|)
expr_stmt|;
comment|/* Valid tag directives are expected. */
if|if
condition|(
operator|!
name|STACK_INIT
argument_list|(
operator|&
name|context
argument_list|,
name|nodes
argument_list|,
name|INITIAL_STACK_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|version_directive
condition|)
block|{
name|version_directive_copy
operator|=
name|yaml_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|yaml_version_directive_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|version_directive_copy
condition|)
goto|goto
name|error
goto|;
name|version_directive_copy
operator|->
name|major
operator|=
name|version_directive
operator|->
name|major
expr_stmt|;
name|version_directive_copy
operator|->
name|minor
operator|=
name|version_directive
operator|->
name|minor
expr_stmt|;
block|}
if|if
condition|(
name|tag_directives_start
operator|!=
name|tag_directives_end
condition|)
block|{
name|yaml_tag_directive_t
modifier|*
name|tag_directive
decl_stmt|;
if|if
condition|(
operator|!
name|STACK_INIT
argument_list|(
operator|&
name|context
argument_list|,
name|tag_directives_copy
argument_list|,
name|INITIAL_STACK_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
for|for
control|(
name|tag_directive
operator|=
name|tag_directives_start
init|;
name|tag_directive
operator|!=
name|tag_directives_end
condition|;
name|tag_directive
operator|++
control|)
block|{
name|assert
argument_list|(
name|tag_directive
operator|->
name|handle
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tag_directive
operator|->
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yaml_check_utf8
argument_list|(
name|tag_directive
operator|->
name|handle
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tag_directive
operator|->
name|handle
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|yaml_check_utf8
argument_list|(
name|tag_directive
operator|->
name|prefix
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tag_directive
operator|->
name|prefix
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|value
operator|.
name|handle
operator|=
name|yaml_strdup
argument_list|(
name|tag_directive
operator|->
name|handle
argument_list|)
expr_stmt|;
name|value
operator|.
name|prefix
operator|=
name|yaml_strdup
argument_list|(
name|tag_directive
operator|->
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
operator|.
name|handle
operator|||
operator|!
name|value
operator|.
name|prefix
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|PUSH
argument_list|(
operator|&
name|context
argument_list|,
name|tag_directives_copy
argument_list|,
name|value
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|value
operator|.
name|handle
operator|=
name|NULL
expr_stmt|;
name|value
operator|.
name|prefix
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|DOCUMENT_INIT
argument_list|(
operator|*
name|document
argument_list|,
name|nodes
operator|.
name|start
argument_list|,
name|nodes
operator|.
name|end
argument_list|,
name|version_directive_copy
argument_list|,
name|tag_directives_copy
operator|.
name|start
argument_list|,
name|tag_directives_copy
operator|.
name|top
argument_list|,
name|start_implicit
argument_list|,
name|end_implicit
argument_list|,
name|mark
argument_list|,
name|mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|error
label|:
name|STACK_DEL
argument_list|(
operator|&
name|context
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|version_directive_copy
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|STACK_EMPTY
argument_list|(
operator|&
name|context
argument_list|,
name|tag_directives_copy
argument_list|)
condition|)
block|{
name|yaml_tag_directive_t
name|value
init|=
name|POP
argument_list|(
operator|&
name|context
argument_list|,
name|tag_directives_copy
argument_list|)
decl_stmt|;
name|yaml_free
argument_list|(
name|value
operator|.
name|handle
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|value
operator|.
name|prefix
argument_list|)
expr_stmt|;
block|}
name|STACK_DEL
argument_list|(
operator|&
name|context
argument_list|,
name|tag_directives_copy
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|value
operator|.
name|handle
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|value
operator|.
name|prefix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Destroy a document object.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|yaml_document_delete
argument_list|(
argument|yaml_document_t *document
argument_list|)
end_macro

begin_block
block|{
struct|struct
block|{
name|yaml_error_type_t
name|error
decl_stmt|;
block|}
name|context
struct|;
name|yaml_tag_directive_t
modifier|*
name|tag_directive
decl_stmt|;
name|context
operator|.
name|error
operator|=
name|YAML_NO_ERROR
expr_stmt|;
comment|/* Eliminate a compliler warning. */
name|assert
argument_list|(
name|document
argument_list|)
expr_stmt|;
comment|/* Non-NULL document object is expected. */
while|while
condition|(
operator|!
name|STACK_EMPTY
argument_list|(
operator|&
name|context
argument_list|,
name|document
operator|->
name|nodes
argument_list|)
condition|)
block|{
name|yaml_node_t
name|node
init|=
name|POP
argument_list|(
operator|&
name|context
argument_list|,
name|document
operator|->
name|nodes
argument_list|)
decl_stmt|;
name|yaml_free
argument_list|(
name|node
operator|.
name|tag
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|node
operator|.
name|type
condition|)
block|{
case|case
name|YAML_SCALAR_NODE
case|:
name|yaml_free
argument_list|(
name|node
operator|.
name|data
operator|.
name|scalar
operator|.
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|YAML_SEQUENCE_NODE
case|:
name|STACK_DEL
argument_list|(
operator|&
name|context
argument_list|,
name|node
operator|.
name|data
operator|.
name|sequence
operator|.
name|items
argument_list|)
expr_stmt|;
break|break;
case|case
name|YAML_MAPPING_NODE
case|:
name|STACK_DEL
argument_list|(
operator|&
name|context
argument_list|,
name|node
operator|.
name|data
operator|.
name|mapping
operator|.
name|pairs
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Should not happen. */
block|}
block|}
name|STACK_DEL
argument_list|(
operator|&
name|context
argument_list|,
name|document
operator|->
name|nodes
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|document
operator|->
name|version_directive
argument_list|)
expr_stmt|;
for|for
control|(
name|tag_directive
operator|=
name|document
operator|->
name|tag_directives
operator|.
name|start
init|;
name|tag_directive
operator|!=
name|document
operator|->
name|tag_directives
operator|.
name|end
condition|;
name|tag_directive
operator|++
control|)
block|{
name|yaml_free
argument_list|(
name|tag_directive
operator|->
name|handle
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|tag_directive
operator|->
name|prefix
argument_list|)
expr_stmt|;
block|}
name|yaml_free
argument_list|(
name|document
operator|->
name|tag_directives
operator|.
name|start
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|document
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|yaml_document_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/**  * Get a document node.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|yaml_node_t *
argument_list|)
end_macro

begin_macro
name|yaml_document_get_node
argument_list|(
argument|yaml_document_t *document
argument_list|,
argument|int index
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|document
argument_list|)
expr_stmt|;
comment|/* Non-NULL document object is expected. */
if|if
condition|(
name|index
operator|>
literal|0
operator|&&
name|document
operator|->
name|nodes
operator|.
name|start
operator|+
name|index
operator|<=
name|document
operator|->
name|nodes
operator|.
name|top
condition|)
block|{
return|return
name|document
operator|->
name|nodes
operator|.
name|start
operator|+
name|index
operator|-
literal|1
return|;
block|}
return|return
name|NULL
return|;
block|}
end_block

begin_comment
comment|/**  * Get the root object.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|yaml_node_t *
argument_list|)
end_macro

begin_macro
name|yaml_document_get_root_node
argument_list|(
argument|yaml_document_t *document
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|document
argument_list|)
expr_stmt|;
comment|/* Non-NULL document object is expected. */
if|if
condition|(
name|document
operator|->
name|nodes
operator|.
name|top
operator|!=
name|document
operator|->
name|nodes
operator|.
name|start
condition|)
block|{
return|return
name|document
operator|->
name|nodes
operator|.
name|start
return|;
block|}
return|return
name|NULL
return|;
block|}
end_block

begin_comment
comment|/*  * Add a scalar node to a document.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_document_add_scalar
argument_list|(
argument|yaml_document_t *document
argument_list|,
argument|yaml_char_t *tag
argument_list|,
argument|yaml_char_t *value
argument_list|,
argument|int length
argument_list|,
argument|yaml_scalar_style_t style
argument_list|)
end_macro

begin_block
block|{
struct|struct
block|{
name|yaml_error_type_t
name|error
decl_stmt|;
block|}
name|context
struct|;
name|yaml_mark_t
name|mark
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|yaml_char_t
modifier|*
name|tag_copy
init|=
name|NULL
decl_stmt|;
name|yaml_char_t
modifier|*
name|value_copy
init|=
name|NULL
decl_stmt|;
name|yaml_node_t
name|node
decl_stmt|;
name|assert
argument_list|(
name|document
argument_list|)
expr_stmt|;
comment|/* Non-NULL document object is expected. */
name|assert
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Non-NULL value is expected. */
if|if
condition|(
operator|!
name|tag
condition|)
block|{
name|tag
operator|=
operator|(
name|yaml_char_t
operator|*
operator|)
name|YAML_DEFAULT_SCALAR_TAG
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|yaml_check_utf8
argument_list|(
name|tag
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tag
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|tag_copy
operator|=
name|yaml_strdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tag_copy
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|length
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|yaml_check_utf8
argument_list|(
name|value
argument_list|,
name|length
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|value_copy
operator|=
name|yaml_malloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value_copy
condition|)
goto|goto
name|error
goto|;
name|memcpy
argument_list|(
name|value_copy
argument_list|,
name|value
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|value_copy
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SCALAR_NODE_INIT
argument_list|(
name|node
argument_list|,
name|tag_copy
argument_list|,
name|value_copy
argument_list|,
name|length
argument_list|,
name|style
argument_list|,
name|mark
argument_list|,
name|mark
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PUSH
argument_list|(
operator|&
name|context
argument_list|,
name|document
operator|->
name|nodes
argument_list|,
name|node
argument_list|)
condition|)
goto|goto
name|error
goto|;
return|return
name|document
operator|->
name|nodes
operator|.
name|top
operator|-
name|document
operator|->
name|nodes
operator|.
name|start
return|;
name|error
label|:
name|yaml_free
argument_list|(
name|tag_copy
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|value_copy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Add a sequence node to a document.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_document_add_sequence
argument_list|(
argument|yaml_document_t *document
argument_list|,
argument|yaml_char_t *tag
argument_list|,
argument|yaml_sequence_style_t style
argument_list|)
end_macro

begin_block
block|{
struct|struct
block|{
name|yaml_error_type_t
name|error
decl_stmt|;
block|}
name|context
struct|;
name|yaml_mark_t
name|mark
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|yaml_char_t
modifier|*
name|tag_copy
init|=
name|NULL
decl_stmt|;
struct|struct
block|{
name|yaml_node_item_t
modifier|*
name|start
decl_stmt|;
name|yaml_node_item_t
modifier|*
name|end
decl_stmt|;
name|yaml_node_item_t
modifier|*
name|top
decl_stmt|;
block|}
name|items
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
struct|;
name|yaml_node_t
name|node
decl_stmt|;
name|assert
argument_list|(
name|document
argument_list|)
expr_stmt|;
comment|/* Non-NULL document object is expected. */
if|if
condition|(
operator|!
name|tag
condition|)
block|{
name|tag
operator|=
operator|(
name|yaml_char_t
operator|*
operator|)
name|YAML_DEFAULT_SEQUENCE_TAG
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|yaml_check_utf8
argument_list|(
name|tag
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tag
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|tag_copy
operator|=
name|yaml_strdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tag_copy
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|STACK_INIT
argument_list|(
operator|&
name|context
argument_list|,
name|items
argument_list|,
name|INITIAL_STACK_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|SEQUENCE_NODE_INIT
argument_list|(
name|node
argument_list|,
name|tag_copy
argument_list|,
name|items
operator|.
name|start
argument_list|,
name|items
operator|.
name|end
argument_list|,
name|style
argument_list|,
name|mark
argument_list|,
name|mark
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PUSH
argument_list|(
operator|&
name|context
argument_list|,
name|document
operator|->
name|nodes
argument_list|,
name|node
argument_list|)
condition|)
goto|goto
name|error
goto|;
return|return
name|document
operator|->
name|nodes
operator|.
name|top
operator|-
name|document
operator|->
name|nodes
operator|.
name|start
return|;
name|error
label|:
name|STACK_DEL
argument_list|(
operator|&
name|context
argument_list|,
name|items
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|tag_copy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Add a mapping node to a document.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_document_add_mapping
argument_list|(
argument|yaml_document_t *document
argument_list|,
argument|yaml_char_t *tag
argument_list|,
argument|yaml_mapping_style_t style
argument_list|)
end_macro

begin_block
block|{
struct|struct
block|{
name|yaml_error_type_t
name|error
decl_stmt|;
block|}
name|context
struct|;
name|yaml_mark_t
name|mark
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|yaml_char_t
modifier|*
name|tag_copy
init|=
name|NULL
decl_stmt|;
struct|struct
block|{
name|yaml_node_pair_t
modifier|*
name|start
decl_stmt|;
name|yaml_node_pair_t
modifier|*
name|end
decl_stmt|;
name|yaml_node_pair_t
modifier|*
name|top
decl_stmt|;
block|}
name|pairs
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
struct|;
name|yaml_node_t
name|node
decl_stmt|;
name|assert
argument_list|(
name|document
argument_list|)
expr_stmt|;
comment|/* Non-NULL document object is expected. */
if|if
condition|(
operator|!
name|tag
condition|)
block|{
name|tag
operator|=
operator|(
name|yaml_char_t
operator|*
operator|)
name|YAML_DEFAULT_MAPPING_TAG
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|yaml_check_utf8
argument_list|(
name|tag
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tag
argument_list|)
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|tag_copy
operator|=
name|yaml_strdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tag_copy
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|STACK_INIT
argument_list|(
operator|&
name|context
argument_list|,
name|pairs
argument_list|,
name|INITIAL_STACK_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|MAPPING_NODE_INIT
argument_list|(
name|node
argument_list|,
name|tag_copy
argument_list|,
name|pairs
operator|.
name|start
argument_list|,
name|pairs
operator|.
name|end
argument_list|,
name|style
argument_list|,
name|mark
argument_list|,
name|mark
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PUSH
argument_list|(
operator|&
name|context
argument_list|,
name|document
operator|->
name|nodes
argument_list|,
name|node
argument_list|)
condition|)
goto|goto
name|error
goto|;
return|return
name|document
operator|->
name|nodes
operator|.
name|top
operator|-
name|document
operator|->
name|nodes
operator|.
name|start
return|;
name|error
label|:
name|STACK_DEL
argument_list|(
operator|&
name|context
argument_list|,
name|pairs
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|tag_copy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Append an item to a sequence node.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_document_append_sequence_item
argument_list|(
argument|yaml_document_t *document
argument_list|,
argument|int sequence
argument_list|,
argument|int item
argument_list|)
end_macro

begin_block
block|{
struct|struct
block|{
name|yaml_error_type_t
name|error
decl_stmt|;
block|}
name|context
struct|;
name|assert
argument_list|(
name|document
argument_list|)
expr_stmt|;
comment|/* Non-NULL document is required. */
name|assert
argument_list|(
name|sequence
operator|>
literal|0
operator|&&
name|document
operator|->
name|nodes
operator|.
name|start
operator|+
name|sequence
operator|<=
name|document
operator|->
name|nodes
operator|.
name|top
argument_list|)
expr_stmt|;
comment|/* Valid sequence id is required. */
name|assert
argument_list|(
name|document
operator|->
name|nodes
operator|.
name|start
index|[
name|sequence
operator|-
literal|1
index|]
operator|.
name|type
operator|==
name|YAML_SEQUENCE_NODE
argument_list|)
expr_stmt|;
comment|/* A sequence node is required. */
name|assert
argument_list|(
name|item
operator|>
literal|0
operator|&&
name|document
operator|->
name|nodes
operator|.
name|start
operator|+
name|item
operator|<=
name|document
operator|->
name|nodes
operator|.
name|top
argument_list|)
expr_stmt|;
comment|/* Valid item id is required. */
if|if
condition|(
operator|!
name|PUSH
argument_list|(
operator|&
name|context
argument_list|,
name|document
operator|->
name|nodes
operator|.
name|start
index|[
name|sequence
operator|-
literal|1
index|]
operator|.
name|data
operator|.
name|sequence
operator|.
name|items
argument_list|,
name|item
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * Append a pair of a key and a value to a mapping node.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_document_append_mapping_pair
argument_list|(
argument|yaml_document_t *document
argument_list|,
argument|int mapping
argument_list|,
argument|int key
argument_list|,
argument|int value
argument_list|)
end_macro

begin_block
block|{
struct|struct
block|{
name|yaml_error_type_t
name|error
decl_stmt|;
block|}
name|context
struct|;
name|yaml_node_pair_t
name|pair
decl_stmt|;
name|assert
argument_list|(
name|document
argument_list|)
expr_stmt|;
comment|/* Non-NULL document is required. */
name|assert
argument_list|(
name|mapping
operator|>
literal|0
operator|&&
name|document
operator|->
name|nodes
operator|.
name|start
operator|+
name|mapping
operator|<=
name|document
operator|->
name|nodes
operator|.
name|top
argument_list|)
expr_stmt|;
comment|/* Valid mapping id is required. */
name|assert
argument_list|(
name|document
operator|->
name|nodes
operator|.
name|start
index|[
name|mapping
operator|-
literal|1
index|]
operator|.
name|type
operator|==
name|YAML_MAPPING_NODE
argument_list|)
expr_stmt|;
comment|/* A mapping node is required. */
name|assert
argument_list|(
name|key
operator|>
literal|0
operator|&&
name|document
operator|->
name|nodes
operator|.
name|start
operator|+
name|key
operator|<=
name|document
operator|->
name|nodes
operator|.
name|top
argument_list|)
expr_stmt|;
comment|/* Valid key id is required. */
name|assert
argument_list|(
name|value
operator|>
literal|0
operator|&&
name|document
operator|->
name|nodes
operator|.
name|start
operator|+
name|value
operator|<=
name|document
operator|->
name|nodes
operator|.
name|top
argument_list|)
expr_stmt|;
comment|/* Valid value id is required. */
name|pair
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|pair
operator|.
name|value
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|PUSH
argument_list|(
operator|&
name|context
argument_list|,
name|document
operator|->
name|nodes
operator|.
name|start
index|[
name|mapping
operator|-
literal|1
index|]
operator|.
name|data
operator|.
name|mapping
operator|.
name|pairs
argument_list|,
name|pair
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_block

end_unit

