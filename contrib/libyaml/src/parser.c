begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The parser implements the following grammar:  *  * stream               ::= STREAM-START implicit_document? explicit_document* STREAM-END  * implicit_document    ::= block_node DOCUMENT-END*  * explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*  * block_node_or_indentless_sequence    ::=  *                          ALIAS  *                          | properties (block_content | indentless_block_sequence)?  *                          | block_content  *                          | indentless_block_sequence  * block_node           ::= ALIAS  *                          | properties block_content?  *                          | block_content  * flow_node            ::= ALIAS  *                          | properties flow_content?  *                          | flow_content  * properties           ::= TAG ANCHOR? | ANCHOR TAG?  * block_content        ::= block_collection | flow_collection | SCALAR  * flow_content         ::= flow_collection | SCALAR  * block_collection     ::= block_sequence | block_mapping  * flow_collection      ::= flow_sequence | flow_mapping  * block_sequence       ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END  * indentless_sequence  ::= (BLOCK-ENTRY block_node?)+  * block_mapping        ::= BLOCK-MAPPING_START  *                          ((KEY block_node_or_indentless_sequence?)?  *                          (VALUE block_node_or_indentless_sequence?)?)*  *                          BLOCK-END  * flow_sequence        ::= FLOW-SEQUENCE-START  *                          (flow_sequence_entry FLOW-ENTRY)*  *                          flow_sequence_entry?  *                          FLOW-SEQUENCE-END  * flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?  * flow_mapping         ::= FLOW-MAPPING-START  *                          (flow_mapping_entry FLOW-ENTRY)*  *                          flow_mapping_entry?  *                          FLOW-MAPPING-END  * flow_mapping_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?  */
end_comment

begin_include
include|#
directive|include
file|"yaml_private.h"
end_include

begin_comment
comment|/*  * Peek the next token in the token queue.  */
end_comment

begin_define
define|#
directive|define
name|PEEK_TOKEN
parameter_list|(
name|parser
parameter_list|)
define|\
value|((parser->token_available || yaml_parser_fetch_more_tokens(parser)) ?       \         parser->tokens.head : NULL)
end_define

begin_comment
comment|/*  * Remove the next token from the queue (must be called after PEEK_TOKEN).  */
end_comment

begin_define
define|#
directive|define
name|SKIP_TOKEN
parameter_list|(
name|parser
parameter_list|)
define|\
value|(parser->token_available = 0,                                               \      parser->tokens_parsed ++,                                                  \      parser->stream_end_produced =                                              \         (parser->tokens.head->type == YAML_STREAM_END_TOKEN),                   \      parser->tokens.head ++)
end_define

begin_comment
comment|/*  * Public API declarations.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_expr_stmt
name|yaml_parser_parse
argument_list|(
name|yaml_parser_t
operator|*
name|parser
argument_list|,
name|yaml_event_t
operator|*
name|event
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Error handling.  */
end_comment

begin_function_decl
specifier|static
name|int
name|yaml_parser_set_parser_error
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|problem
parameter_list|,
name|yaml_mark_t
name|problem_mark
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_set_parser_error_context
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|context
parameter_list|,
name|yaml_mark_t
name|context_mark
parameter_list|,
specifier|const
name|char
modifier|*
name|problem
parameter_list|,
name|yaml_mark_t
name|problem_mark
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * State functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|yaml_parser_state_machine
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_parse_stream_start
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_parse_document_start
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|,
name|int
name|implicit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_parse_document_content
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_parse_document_end
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_parse_node
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|,
name|int
name|block
parameter_list|,
name|int
name|indentless_sequence
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_parse_block_sequence_entry
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|,
name|int
name|first
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_parse_indentless_sequence_entry
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_parse_block_mapping_key
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|,
name|int
name|first
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_parse_block_mapping_value
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_parse_flow_sequence_entry
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|,
name|int
name|first
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_parse_flow_sequence_entry_mapping_key
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_parse_flow_sequence_entry_mapping_value
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_parse_flow_sequence_entry_mapping_end
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_parse_flow_mapping_key
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|,
name|int
name|first
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_parse_flow_mapping_value
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|,
name|int
name|empty
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Utility functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|yaml_parser_process_empty_scalar
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|,
name|yaml_mark_t
name|mark
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_process_directives
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_version_directive_t
modifier|*
modifier|*
name|version_directive_ref
parameter_list|,
name|yaml_tag_directive_t
modifier|*
modifier|*
name|tag_directives_start_ref
parameter_list|,
name|yaml_tag_directive_t
modifier|*
modifier|*
name|tag_directives_end_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_append_tag_directive
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_tag_directive_t
name|value
parameter_list|,
name|int
name|allow_duplicates
parameter_list|,
name|yaml_mark_t
name|mark
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Get the next event.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_parser_parse
argument_list|(
argument|yaml_parser_t *parser
argument_list|,
argument|yaml_event_t *event
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Non-NULL parser object is expected. */
name|assert
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|/* Non-NULL event object is expected. */
comment|/* Erase the event object. */
name|memset
argument_list|(
name|event
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|yaml_event_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No events after the end of the stream or error. */
if|if
condition|(
name|parser
operator|->
name|stream_end_produced
operator|||
name|parser
operator|->
name|error
operator|||
name|parser
operator|->
name|state
operator|==
name|YAML_PARSE_END_STATE
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* Generate the next event. */
return|return
name|yaml_parser_state_machine
argument_list|(
name|parser
argument_list|,
name|event
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Set parser error.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_set_parser_error
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|problem
parameter_list|,
name|yaml_mark_t
name|problem_mark
parameter_list|)
block|{
name|parser
operator|->
name|error
operator|=
name|YAML_PARSER_ERROR
expr_stmt|;
name|parser
operator|->
name|problem
operator|=
name|problem
expr_stmt|;
name|parser
operator|->
name|problem_mark
operator|=
name|problem_mark
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|yaml_parser_set_parser_error_context
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|context
parameter_list|,
name|yaml_mark_t
name|context_mark
parameter_list|,
specifier|const
name|char
modifier|*
name|problem
parameter_list|,
name|yaml_mark_t
name|problem_mark
parameter_list|)
block|{
name|parser
operator|->
name|error
operator|=
name|YAML_PARSER_ERROR
expr_stmt|;
name|parser
operator|->
name|context
operator|=
name|context
expr_stmt|;
name|parser
operator|->
name|context_mark
operator|=
name|context_mark
expr_stmt|;
name|parser
operator|->
name|problem
operator|=
name|problem
expr_stmt|;
name|parser
operator|->
name|problem_mark
operator|=
name|problem_mark
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * State dispatcher.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_state_machine
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|)
block|{
switch|switch
condition|(
name|parser
operator|->
name|state
condition|)
block|{
case|case
name|YAML_PARSE_STREAM_START_STATE
case|:
return|return
name|yaml_parser_parse_stream_start
argument_list|(
name|parser
argument_list|,
name|event
argument_list|)
return|;
case|case
name|YAML_PARSE_IMPLICIT_DOCUMENT_START_STATE
case|:
return|return
name|yaml_parser_parse_document_start
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|YAML_PARSE_DOCUMENT_START_STATE
case|:
return|return
name|yaml_parser_parse_document_start
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|YAML_PARSE_DOCUMENT_CONTENT_STATE
case|:
return|return
name|yaml_parser_parse_document_content
argument_list|(
name|parser
argument_list|,
name|event
argument_list|)
return|;
case|case
name|YAML_PARSE_DOCUMENT_END_STATE
case|:
return|return
name|yaml_parser_parse_document_end
argument_list|(
name|parser
argument_list|,
name|event
argument_list|)
return|;
case|case
name|YAML_PARSE_BLOCK_NODE_STATE
case|:
return|return
name|yaml_parser_parse_node
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|YAML_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE
case|:
return|return
name|yaml_parser_parse_node
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|YAML_PARSE_FLOW_NODE_STATE
case|:
return|return
name|yaml_parser_parse_node
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|YAML_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE
case|:
return|return
name|yaml_parser_parse_block_sequence_entry
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|YAML_PARSE_BLOCK_SEQUENCE_ENTRY_STATE
case|:
return|return
name|yaml_parser_parse_block_sequence_entry
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|YAML_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE
case|:
return|return
name|yaml_parser_parse_indentless_sequence_entry
argument_list|(
name|parser
argument_list|,
name|event
argument_list|)
return|;
case|case
name|YAML_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE
case|:
return|return
name|yaml_parser_parse_block_mapping_key
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|YAML_PARSE_BLOCK_MAPPING_KEY_STATE
case|:
return|return
name|yaml_parser_parse_block_mapping_key
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|YAML_PARSE_BLOCK_MAPPING_VALUE_STATE
case|:
return|return
name|yaml_parser_parse_block_mapping_value
argument_list|(
name|parser
argument_list|,
name|event
argument_list|)
return|;
case|case
name|YAML_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE
case|:
return|return
name|yaml_parser_parse_flow_sequence_entry
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|YAML_PARSE_FLOW_SEQUENCE_ENTRY_STATE
case|:
return|return
name|yaml_parser_parse_flow_sequence_entry
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE
case|:
return|return
name|yaml_parser_parse_flow_sequence_entry_mapping_key
argument_list|(
name|parser
argument_list|,
name|event
argument_list|)
return|;
case|case
name|YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE
case|:
return|return
name|yaml_parser_parse_flow_sequence_entry_mapping_value
argument_list|(
name|parser
argument_list|,
name|event
argument_list|)
return|;
case|case
name|YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE
case|:
return|return
name|yaml_parser_parse_flow_sequence_entry_mapping_end
argument_list|(
name|parser
argument_list|,
name|event
argument_list|)
return|;
case|case
name|YAML_PARSE_FLOW_MAPPING_FIRST_KEY_STATE
case|:
return|return
name|yaml_parser_parse_flow_mapping_key
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|YAML_PARSE_FLOW_MAPPING_KEY_STATE
case|:
return|return
name|yaml_parser_parse_flow_mapping_key
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|YAML_PARSE_FLOW_MAPPING_VALUE_STATE
case|:
return|return
name|yaml_parser_parse_flow_mapping_value
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|YAML_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE
case|:
return|return
name|yaml_parser_parse_flow_mapping_value
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|1
argument_list|)
return|;
default|default:
name|assert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Invalid state. */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the production:  * stream   ::= STREAM-START implicit_document? explicit_document* STREAM-END  *              ************  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_parse_stream_start
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|)
block|{
name|yaml_token_t
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|YAML_STREAM_START_TOKEN
condition|)
block|{
return|return
name|yaml_parser_set_parser_error
argument_list|(
name|parser
argument_list|,
literal|"did not find expected<stream-start>"
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
return|;
block|}
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_IMPLICIT_DOCUMENT_START_STATE
expr_stmt|;
name|STREAM_START_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|token
operator|->
name|data
operator|.
name|stream_start
operator|.
name|encoding
argument_list|,
name|token
operator|->
name|start_mark
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
expr_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the productions:  * implicit_document    ::= block_node DOCUMENT-END*  *                          *  * explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*  *                          *************************  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_parse_document_start
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|,
name|int
name|implicit
parameter_list|)
block|{
name|yaml_token_t
modifier|*
name|token
decl_stmt|;
name|yaml_version_directive_t
modifier|*
name|version_directive
init|=
name|NULL
decl_stmt|;
struct|struct
block|{
name|yaml_tag_directive_t
modifier|*
name|start
decl_stmt|;
name|yaml_tag_directive_t
modifier|*
name|end
decl_stmt|;
block|}
name|tag_directives
init|=
block|{
name|NULL
block|,
name|NULL
block|}
struct|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
comment|/* Parse extra document end indicators. */
if|if
condition|(
operator|!
name|implicit
condition|)
block|{
while|while
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_DOCUMENT_END_TOKEN
condition|)
block|{
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
block|}
block|}
comment|/* Parse an implicit document. */
if|if
condition|(
name|implicit
operator|&&
name|token
operator|->
name|type
operator|!=
name|YAML_VERSION_DIRECTIVE_TOKEN
operator|&&
name|token
operator|->
name|type
operator|!=
name|YAML_TAG_DIRECTIVE_TOKEN
operator|&&
name|token
operator|->
name|type
operator|!=
name|YAML_DOCUMENT_START_TOKEN
operator|&&
name|token
operator|->
name|type
operator|!=
name|YAML_STREAM_END_TOKEN
condition|)
block|{
if|if
condition|(
operator|!
name|yaml_parser_process_directives
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|,
name|YAML_PARSE_DOCUMENT_END_STATE
argument_list|)
condition|)
return|return
literal|0
return|;
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_BLOCK_NODE_STATE
expr_stmt|;
name|DOCUMENT_START_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|token
operator|->
name|start_mark
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Parse an explicit document. */
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|YAML_STREAM_END_TOKEN
condition|)
block|{
name|yaml_mark_t
name|start_mark
decl_stmt|,
name|end_mark
decl_stmt|;
name|start_mark
operator|=
name|token
operator|->
name|start_mark
expr_stmt|;
if|if
condition|(
operator|!
name|yaml_parser_process_directives
argument_list|(
name|parser
argument_list|,
operator|&
name|version_directive
argument_list|,
operator|&
name|tag_directives
operator|.
name|start
argument_list|,
operator|&
name|tag_directives
operator|.
name|end
argument_list|)
condition|)
return|return
literal|0
return|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|YAML_DOCUMENT_START_TOKEN
condition|)
block|{
name|yaml_parser_set_parser_error
argument_list|(
name|parser
argument_list|,
literal|"did not find expected<document start>"
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|,
name|YAML_PARSE_DOCUMENT_END_STATE
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_DOCUMENT_CONTENT_STATE
expr_stmt|;
name|end_mark
operator|=
name|token
operator|->
name|end_mark
expr_stmt|;
name|DOCUMENT_START_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|version_directive
argument_list|,
name|tag_directives
operator|.
name|start
argument_list|,
name|tag_directives
operator|.
name|end
argument_list|,
literal|0
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|version_directive
operator|=
name|NULL
expr_stmt|;
name|tag_directives
operator|.
name|start
operator|=
name|tag_directives
operator|.
name|end
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Parse the stream end. */
else|else
block|{
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_END_STATE
expr_stmt|;
name|STREAM_END_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|token
operator|->
name|start_mark
argument_list|,
name|token
operator|->
name|end_mark
argument_list|)
expr_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|error
label|:
name|yaml_free
argument_list|(
name|version_directive
argument_list|)
expr_stmt|;
while|while
condition|(
name|tag_directives
operator|.
name|start
operator|!=
name|tag_directives
operator|.
name|end
condition|)
block|{
name|yaml_free
argument_list|(
name|tag_directives
operator|.
name|end
index|[
operator|-
literal|1
index|]
operator|.
name|handle
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|tag_directives
operator|.
name|end
index|[
operator|-
literal|1
index|]
operator|.
name|prefix
argument_list|)
expr_stmt|;
name|tag_directives
operator|.
name|end
operator|--
expr_stmt|;
block|}
name|yaml_free
argument_list|(
name|tag_directives
operator|.
name|start
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the productions:  * explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*  *                                                    ***********  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_parse_document_content
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|)
block|{
name|yaml_token_t
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_VERSION_DIRECTIVE_TOKEN
operator|||
name|token
operator|->
name|type
operator|==
name|YAML_TAG_DIRECTIVE_TOKEN
operator|||
name|token
operator|->
name|type
operator|==
name|YAML_DOCUMENT_START_TOKEN
operator|||
name|token
operator|->
name|type
operator|==
name|YAML_DOCUMENT_END_TOKEN
operator|||
name|token
operator|->
name|type
operator|==
name|YAML_STREAM_END_TOKEN
condition|)
block|{
name|parser
operator|->
name|state
operator|=
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|)
expr_stmt|;
return|return
name|yaml_parser_process_empty_scalar
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|yaml_parser_parse_node
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse the productions:  * implicit_document    ::= block_node DOCUMENT-END*  *                                     *************  * explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*  *                                                                *************  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_parse_document_end
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|)
block|{
name|yaml_token_t
modifier|*
name|token
decl_stmt|;
name|yaml_mark_t
name|start_mark
decl_stmt|,
name|end_mark
decl_stmt|;
name|int
name|implicit
init|=
literal|1
decl_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
name|start_mark
operator|=
name|end_mark
operator|=
name|token
operator|->
name|start_mark
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_DOCUMENT_END_TOKEN
condition|)
block|{
name|end_mark
operator|=
name|token
operator|->
name|end_mark
expr_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|implicit
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|STACK_EMPTY
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tag_directives
argument_list|)
condition|)
block|{
name|yaml_tag_directive_t
name|tag_directive
init|=
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tag_directives
argument_list|)
decl_stmt|;
name|yaml_free
argument_list|(
name|tag_directive
operator|.
name|handle
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|tag_directive
operator|.
name|prefix
argument_list|)
expr_stmt|;
block|}
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_DOCUMENT_START_STATE
expr_stmt|;
name|DOCUMENT_END_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|implicit
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the productions:  * block_node_or_indentless_sequence    ::=  *                          ALIAS  *                          *****  *                          | properties (block_content | indentless_block_sequence)?  *                            **********  *  *                          | block_content | indentless_block_sequence  *                            *  * block_node           ::= ALIAS  *                          *****  *                          | properties block_content?  *                            ********** *  *                          | block_content  *                            *  * flow_node            ::= ALIAS  *                          *****  *                          | properties flow_content?  *                            ********** *  *                          | flow_content  *                            *  * properties           ::= TAG ANCHOR? | ANCHOR TAG?  *                          *************************  * block_content        ::= block_collection | flow_collection | SCALAR  *                                                               ******  * flow_content         ::= flow_collection | SCALAR  *                                            ******  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_parse_node
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|,
name|int
name|block
parameter_list|,
name|int
name|indentless_sequence
parameter_list|)
block|{
name|yaml_token_t
modifier|*
name|token
decl_stmt|;
name|yaml_char_t
modifier|*
name|anchor
init|=
name|NULL
decl_stmt|;
name|yaml_char_t
modifier|*
name|tag_handle
init|=
name|NULL
decl_stmt|;
name|yaml_char_t
modifier|*
name|tag_suffix
init|=
name|NULL
decl_stmt|;
name|yaml_char_t
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
name|yaml_mark_t
name|start_mark
decl_stmt|,
name|end_mark
decl_stmt|,
name|tag_mark
decl_stmt|;
name|int
name|implicit
decl_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_ALIAS_TOKEN
condition|)
block|{
name|parser
operator|->
name|state
operator|=
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|)
expr_stmt|;
name|ALIAS_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|token
operator|->
name|data
operator|.
name|alias
operator|.
name|value
argument_list|,
name|token
operator|->
name|start_mark
argument_list|,
name|token
operator|->
name|end_mark
argument_list|)
expr_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|start_mark
operator|=
name|end_mark
operator|=
name|token
operator|->
name|start_mark
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_ANCHOR_TOKEN
condition|)
block|{
name|anchor
operator|=
name|token
operator|->
name|data
operator|.
name|anchor
operator|.
name|value
expr_stmt|;
name|start_mark
operator|=
name|token
operator|->
name|start_mark
expr_stmt|;
name|end_mark
operator|=
name|token
operator|->
name|end_mark
expr_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_TAG_TOKEN
condition|)
block|{
name|tag_handle
operator|=
name|token
operator|->
name|data
operator|.
name|tag
operator|.
name|handle
expr_stmt|;
name|tag_suffix
operator|=
name|token
operator|->
name|data
operator|.
name|tag
operator|.
name|suffix
expr_stmt|;
name|tag_mark
operator|=
name|token
operator|->
name|start_mark
expr_stmt|;
name|end_mark
operator|=
name|token
operator|->
name|end_mark
expr_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_TAG_TOKEN
condition|)
block|{
name|tag_handle
operator|=
name|token
operator|->
name|data
operator|.
name|tag
operator|.
name|handle
expr_stmt|;
name|tag_suffix
operator|=
name|token
operator|->
name|data
operator|.
name|tag
operator|.
name|suffix
expr_stmt|;
name|start_mark
operator|=
name|tag_mark
operator|=
name|token
operator|->
name|start_mark
expr_stmt|;
name|end_mark
operator|=
name|token
operator|->
name|end_mark
expr_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_ANCHOR_TOKEN
condition|)
block|{
name|anchor
operator|=
name|token
operator|->
name|data
operator|.
name|anchor
operator|.
name|value
expr_stmt|;
name|end_mark
operator|=
name|token
operator|->
name|end_mark
expr_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
goto|goto
name|error
goto|;
block|}
block|}
if|if
condition|(
name|tag_handle
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|tag_handle
condition|)
block|{
name|tag
operator|=
name|tag_suffix
expr_stmt|;
name|yaml_free
argument_list|(
name|tag_handle
argument_list|)
expr_stmt|;
name|tag_handle
operator|=
name|tag_suffix
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|yaml_tag_directive_t
modifier|*
name|tag_directive
decl_stmt|;
for|for
control|(
name|tag_directive
operator|=
name|parser
operator|->
name|tag_directives
operator|.
name|start
init|;
name|tag_directive
operator|!=
name|parser
operator|->
name|tag_directives
operator|.
name|top
condition|;
name|tag_directive
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tag_directive
operator|->
name|handle
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tag_handle
argument_list|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|prefix_len
init|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tag_directive
operator|->
name|prefix
argument_list|)
decl_stmt|;
name|size_t
name|suffix_len
init|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tag_suffix
argument_list|)
decl_stmt|;
name|tag
operator|=
name|yaml_malloc
argument_list|(
name|prefix_len
operator|+
name|suffix_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tag
condition|)
block|{
name|parser
operator|->
name|error
operator|=
name|YAML_MEMORY_ERROR
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|memcpy
argument_list|(
name|tag
argument_list|,
name|tag_directive
operator|->
name|prefix
argument_list|,
name|prefix_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tag
operator|+
name|prefix_len
argument_list|,
name|tag_suffix
argument_list|,
name|suffix_len
argument_list|)
expr_stmt|;
name|tag
index|[
name|prefix_len
operator|+
name|suffix_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|yaml_free
argument_list|(
name|tag_handle
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|tag_suffix
argument_list|)
expr_stmt|;
name|tag_handle
operator|=
name|tag_suffix
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|tag
condition|)
block|{
name|yaml_parser_set_parser_error_context
argument_list|(
name|parser
argument_list|,
literal|"while parsing a node"
argument_list|,
name|start_mark
argument_list|,
literal|"found undefined tag handle"
argument_list|,
name|tag_mark
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
block|}
name|implicit
operator|=
operator|(
operator|!
name|tag
operator|||
operator|!
operator|*
name|tag
operator|)
expr_stmt|;
if|if
condition|(
name|indentless_sequence
operator|&&
name|token
operator|->
name|type
operator|==
name|YAML_BLOCK_ENTRY_TOKEN
condition|)
block|{
name|end_mark
operator|=
name|token
operator|->
name|end_mark
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE
expr_stmt|;
name|SEQUENCE_START_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|anchor
argument_list|,
name|tag
argument_list|,
name|implicit
argument_list|,
name|YAML_BLOCK_SEQUENCE_STYLE
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_SCALAR_TOKEN
condition|)
block|{
name|int
name|plain_implicit
init|=
literal|0
decl_stmt|;
name|int
name|quoted_implicit
init|=
literal|0
decl_stmt|;
name|end_mark
operator|=
name|token
operator|->
name|end_mark
expr_stmt|;
if|if
condition|(
operator|(
name|token
operator|->
name|data
operator|.
name|scalar
operator|.
name|style
operator|==
name|YAML_PLAIN_SCALAR_STYLE
operator|&&
operator|!
name|tag
operator|)
operator|||
operator|(
name|tag
operator|&&
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tag
argument_list|,
literal|"!"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|plain_implicit
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|tag
condition|)
block|{
name|quoted_implicit
operator|=
literal|1
expr_stmt|;
block|}
name|parser
operator|->
name|state
operator|=
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|)
expr_stmt|;
name|SCALAR_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|anchor
argument_list|,
name|tag
argument_list|,
name|token
operator|->
name|data
operator|.
name|scalar
operator|.
name|value
argument_list|,
name|token
operator|->
name|data
operator|.
name|scalar
operator|.
name|length
argument_list|,
name|plain_implicit
argument_list|,
name|quoted_implicit
argument_list|,
name|token
operator|->
name|data
operator|.
name|scalar
operator|.
name|style
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_FLOW_SEQUENCE_START_TOKEN
condition|)
block|{
name|end_mark
operator|=
name|token
operator|->
name|end_mark
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE
expr_stmt|;
name|SEQUENCE_START_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|anchor
argument_list|,
name|tag
argument_list|,
name|implicit
argument_list|,
name|YAML_FLOW_SEQUENCE_STYLE
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_FLOW_MAPPING_START_TOKEN
condition|)
block|{
name|end_mark
operator|=
name|token
operator|->
name|end_mark
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_FLOW_MAPPING_FIRST_KEY_STATE
expr_stmt|;
name|MAPPING_START_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|anchor
argument_list|,
name|tag
argument_list|,
name|implicit
argument_list|,
name|YAML_FLOW_MAPPING_STYLE
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|block
operator|&&
name|token
operator|->
name|type
operator|==
name|YAML_BLOCK_SEQUENCE_START_TOKEN
condition|)
block|{
name|end_mark
operator|=
name|token
operator|->
name|end_mark
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE
expr_stmt|;
name|SEQUENCE_START_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|anchor
argument_list|,
name|tag
argument_list|,
name|implicit
argument_list|,
name|YAML_BLOCK_SEQUENCE_STYLE
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|block
operator|&&
name|token
operator|->
name|type
operator|==
name|YAML_BLOCK_MAPPING_START_TOKEN
condition|)
block|{
name|end_mark
operator|=
name|token
operator|->
name|end_mark
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE
expr_stmt|;
name|MAPPING_START_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|anchor
argument_list|,
name|tag
argument_list|,
name|implicit
argument_list|,
name|YAML_BLOCK_MAPPING_STYLE
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|anchor
operator|||
name|tag
condition|)
block|{
name|yaml_char_t
modifier|*
name|value
init|=
name|yaml_malloc
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
block|{
name|parser
operator|->
name|error
operator|=
name|YAML_MEMORY_ERROR
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|value
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|)
expr_stmt|;
name|SCALAR_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|anchor
argument_list|,
name|tag
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|implicit
argument_list|,
literal|0
argument_list|,
name|YAML_PLAIN_SCALAR_STYLE
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|yaml_parser_set_parser_error_context
argument_list|(
name|parser
argument_list|,
operator|(
name|block
condition|?
literal|"while parsing a block node"
else|:
literal|"while parsing a flow node"
operator|)
argument_list|,
name|start_mark
argument_list|,
literal|"did not find expected node content"
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
block|}
name|error
label|:
name|yaml_free
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|tag_handle
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|tag_suffix
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the productions:  * block_sequence ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END  *                    ********************  *********** *             *********  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_parse_block_sequence_entry
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|yaml_token_t
modifier|*
name|token
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|marks
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
condition|)
return|return
literal|0
return|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_BLOCK_ENTRY_TOKEN
condition|)
block|{
name|yaml_mark_t
name|mark
init|=
name|token
operator|->
name|end_mark
decl_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|YAML_BLOCK_ENTRY_TOKEN
operator|&&
name|token
operator|->
name|type
operator|!=
name|YAML_BLOCK_END_TOKEN
condition|)
block|{
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|,
name|YAML_PARSE_BLOCK_SEQUENCE_ENTRY_STATE
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|yaml_parser_parse_node
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
block|{
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_BLOCK_SEQUENCE_ENTRY_STATE
expr_stmt|;
return|return
name|yaml_parser_process_empty_scalar
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
name|mark
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_BLOCK_END_TOKEN
condition|)
block|{
name|yaml_mark_t
name|dummy_mark
decl_stmt|;
comment|/* Used to eliminate a compiler warning. */
name|parser
operator|->
name|state
operator|=
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|)
expr_stmt|;
name|dummy_mark
operator|=
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|marks
argument_list|)
expr_stmt|;
name|SEQUENCE_END_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|token
operator|->
name|start_mark
argument_list|,
name|token
operator|->
name|end_mark
argument_list|)
expr_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
name|yaml_parser_set_parser_error_context
argument_list|(
name|parser
argument_list|,
literal|"while parsing a block collection"
argument_list|,
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|marks
argument_list|)
argument_list|,
literal|"did not find expected '-' indicator"
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse the productions:  * indentless_sequence  ::= (BLOCK-ENTRY block_node?)+  *                           *********** *  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_parse_indentless_sequence_entry
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|)
block|{
name|yaml_token_t
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_BLOCK_ENTRY_TOKEN
condition|)
block|{
name|yaml_mark_t
name|mark
init|=
name|token
operator|->
name|end_mark
decl_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|YAML_BLOCK_ENTRY_TOKEN
operator|&&
name|token
operator|->
name|type
operator|!=
name|YAML_KEY_TOKEN
operator|&&
name|token
operator|->
name|type
operator|!=
name|YAML_VALUE_TOKEN
operator|&&
name|token
operator|->
name|type
operator|!=
name|YAML_BLOCK_END_TOKEN
condition|)
block|{
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|,
name|YAML_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|yaml_parser_parse_node
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
block|{
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE
expr_stmt|;
return|return
name|yaml_parser_process_empty_scalar
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
name|mark
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|parser
operator|->
name|state
operator|=
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|)
expr_stmt|;
name|SEQUENCE_END_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|token
operator|->
name|start_mark
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse the productions:  * block_mapping        ::= BLOCK-MAPPING_START  *                          *******************  *                          ((KEY block_node_or_indentless_sequence?)?  *                            *** *  *                          (VALUE block_node_or_indentless_sequence?)?)*  *  *                          BLOCK-END  *                          *********  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_parse_block_mapping_key
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|yaml_token_t
modifier|*
name|token
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|marks
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
condition|)
return|return
literal|0
return|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_KEY_TOKEN
condition|)
block|{
name|yaml_mark_t
name|mark
init|=
name|token
operator|->
name|end_mark
decl_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|YAML_KEY_TOKEN
operator|&&
name|token
operator|->
name|type
operator|!=
name|YAML_VALUE_TOKEN
operator|&&
name|token
operator|->
name|type
operator|!=
name|YAML_BLOCK_END_TOKEN
condition|)
block|{
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|,
name|YAML_PARSE_BLOCK_MAPPING_VALUE_STATE
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|yaml_parser_parse_node
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
else|else
block|{
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_BLOCK_MAPPING_VALUE_STATE
expr_stmt|;
return|return
name|yaml_parser_process_empty_scalar
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
name|mark
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_BLOCK_END_TOKEN
condition|)
block|{
name|yaml_mark_t
name|dummy_mark
decl_stmt|;
comment|/* Used to eliminate a compiler warning. */
name|parser
operator|->
name|state
operator|=
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|)
expr_stmt|;
name|dummy_mark
operator|=
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|marks
argument_list|)
expr_stmt|;
name|MAPPING_END_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|token
operator|->
name|start_mark
argument_list|,
name|token
operator|->
name|end_mark
argument_list|)
expr_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
name|yaml_parser_set_parser_error_context
argument_list|(
name|parser
argument_list|,
literal|"while parsing a block mapping"
argument_list|,
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|marks
argument_list|)
argument_list|,
literal|"did not find expected key"
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse the productions:  * block_mapping        ::= BLOCK-MAPPING_START  *  *                          ((KEY block_node_or_indentless_sequence?)?  *  *                          (VALUE block_node_or_indentless_sequence?)?)*  *                           ***** *  *                          BLOCK-END  *  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_parse_block_mapping_value
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|)
block|{
name|yaml_token_t
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_VALUE_TOKEN
condition|)
block|{
name|yaml_mark_t
name|mark
init|=
name|token
operator|->
name|end_mark
decl_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|YAML_KEY_TOKEN
operator|&&
name|token
operator|->
name|type
operator|!=
name|YAML_VALUE_TOKEN
operator|&&
name|token
operator|->
name|type
operator|!=
name|YAML_BLOCK_END_TOKEN
condition|)
block|{
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|,
name|YAML_PARSE_BLOCK_MAPPING_KEY_STATE
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|yaml_parser_parse_node
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
else|else
block|{
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_BLOCK_MAPPING_KEY_STATE
expr_stmt|;
return|return
name|yaml_parser_process_empty_scalar
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
name|mark
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_BLOCK_MAPPING_KEY_STATE
expr_stmt|;
return|return
name|yaml_parser_process_empty_scalar
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse the productions:  * flow_sequence        ::= FLOW-SEQUENCE-START  *                          *******************  *                          (flow_sequence_entry FLOW-ENTRY)*  *                           *                   **********  *                          flow_sequence_entry?  *                          *  *                          FLOW-SEQUENCE-END  *                          *****************  * flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?  *                          *  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_parse_flow_sequence_entry
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|yaml_token_t
modifier|*
name|token
decl_stmt|;
name|yaml_mark_t
name|dummy_mark
decl_stmt|;
comment|/* Used to eliminate a compiler warning. */
if|if
condition|(
name|first
condition|)
block|{
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|marks
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
condition|)
return|return
literal|0
return|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|YAML_FLOW_SEQUENCE_END_TOKEN
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_FLOW_ENTRY_TOKEN
condition|)
block|{
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|yaml_parser_set_parser_error_context
argument_list|(
name|parser
argument_list|,
literal|"while parsing a flow sequence"
argument_list|,
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|marks
argument_list|)
argument_list|,
literal|"did not find expected ',' or ']'"
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_KEY_TOKEN
condition|)
block|{
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE
expr_stmt|;
name|MAPPING_START_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|YAML_FLOW_MAPPING_STYLE
argument_list|,
name|token
operator|->
name|start_mark
argument_list|,
name|token
operator|->
name|end_mark
argument_list|)
expr_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|YAML_FLOW_SEQUENCE_END_TOKEN
condition|)
block|{
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|,
name|YAML_PARSE_FLOW_SEQUENCE_ENTRY_STATE
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|yaml_parser_parse_node
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
name|parser
operator|->
name|state
operator|=
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|)
expr_stmt|;
name|dummy_mark
operator|=
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|marks
argument_list|)
expr_stmt|;
name|SEQUENCE_END_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|token
operator|->
name|start_mark
argument_list|,
name|token
operator|->
name|end_mark
argument_list|)
expr_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the productions:  * flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?  *                                      *** *  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_parse_flow_sequence_entry_mapping_key
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|)
block|{
name|yaml_token_t
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|YAML_VALUE_TOKEN
operator|&&
name|token
operator|->
name|type
operator|!=
name|YAML_FLOW_ENTRY_TOKEN
operator|&&
name|token
operator|->
name|type
operator|!=
name|YAML_FLOW_SEQUENCE_END_TOKEN
condition|)
block|{
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|,
name|YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|yaml_parser_parse_node
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
block|{
name|yaml_mark_t
name|mark
init|=
name|token
operator|->
name|end_mark
decl_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE
expr_stmt|;
return|return
name|yaml_parser_process_empty_scalar
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
name|mark
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse the productions:  * flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?  *                                                      ***** *  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_parse_flow_sequence_entry_mapping_value
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|)
block|{
name|yaml_token_t
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_VALUE_TOKEN
condition|)
block|{
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|YAML_FLOW_ENTRY_TOKEN
operator|&&
name|token
operator|->
name|type
operator|!=
name|YAML_FLOW_SEQUENCE_END_TOKEN
condition|)
block|{
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|,
name|YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|yaml_parser_parse_node
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE
expr_stmt|;
return|return
name|yaml_parser_process_empty_scalar
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the productions:  * flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?  *                                                                      *  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_parse_flow_sequence_entry_mapping_end
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|)
block|{
name|yaml_token_t
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_FLOW_SEQUENCE_ENTRY_STATE
expr_stmt|;
name|MAPPING_END_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|token
operator|->
name|start_mark
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the productions:  * flow_mapping         ::= FLOW-MAPPING-START  *                          ******************  *                          (flow_mapping_entry FLOW-ENTRY)*  *                           *                  **********  *                          flow_mapping_entry?  *                          ******************  *                          FLOW-MAPPING-END  *                          ****************  * flow_mapping_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?  *                          *           *** *  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_parse_flow_mapping_key
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|yaml_token_t
modifier|*
name|token
decl_stmt|;
name|yaml_mark_t
name|dummy_mark
decl_stmt|;
comment|/* Used to eliminate a compiler warning. */
if|if
condition|(
name|first
condition|)
block|{
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|marks
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
condition|)
return|return
literal|0
return|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|YAML_FLOW_MAPPING_END_TOKEN
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_FLOW_ENTRY_TOKEN
condition|)
block|{
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|yaml_parser_set_parser_error_context
argument_list|(
name|parser
argument_list|,
literal|"while parsing a flow mapping"
argument_list|,
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|marks
argument_list|)
argument_list|,
literal|"did not find expected ',' or '}'"
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_KEY_TOKEN
condition|)
block|{
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|YAML_VALUE_TOKEN
operator|&&
name|token
operator|->
name|type
operator|!=
name|YAML_FLOW_ENTRY_TOKEN
operator|&&
name|token
operator|->
name|type
operator|!=
name|YAML_FLOW_MAPPING_END_TOKEN
condition|)
block|{
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|,
name|YAML_PARSE_FLOW_MAPPING_VALUE_STATE
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|yaml_parser_parse_node
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
block|{
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_FLOW_MAPPING_VALUE_STATE
expr_stmt|;
return|return
name|yaml_parser_process_empty_scalar
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|YAML_FLOW_MAPPING_END_TOKEN
condition|)
block|{
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|,
name|YAML_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|yaml_parser_parse_node
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
name|parser
operator|->
name|state
operator|=
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|)
expr_stmt|;
name|dummy_mark
operator|=
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|marks
argument_list|)
expr_stmt|;
name|MAPPING_END_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|token
operator|->
name|start_mark
argument_list|,
name|token
operator|->
name|end_mark
argument_list|)
expr_stmt|;
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the productions:  * flow_mapping_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?  *                                   *                  ***** *  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_parse_flow_mapping_value
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|,
name|int
name|empty
parameter_list|)
block|{
name|yaml_token_t
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|empty
condition|)
block|{
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_FLOW_MAPPING_KEY_STATE
expr_stmt|;
return|return
name|yaml_parser_process_empty_scalar
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
return|;
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_VALUE_TOKEN
condition|)
block|{
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|YAML_FLOW_ENTRY_TOKEN
operator|&&
name|token
operator|->
name|type
operator|!=
name|YAML_FLOW_MAPPING_END_TOKEN
condition|)
block|{
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|states
argument_list|,
name|YAML_PARSE_FLOW_MAPPING_KEY_STATE
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|yaml_parser_parse_node
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
name|parser
operator|->
name|state
operator|=
name|YAML_PARSE_FLOW_MAPPING_KEY_STATE
expr_stmt|;
return|return
name|yaml_parser_process_empty_scalar
argument_list|(
name|parser
argument_list|,
name|event
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate an empty scalar event.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_process_empty_scalar
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_event_t
modifier|*
name|event
parameter_list|,
name|yaml_mark_t
name|mark
parameter_list|)
block|{
name|yaml_char_t
modifier|*
name|value
decl_stmt|;
name|value
operator|=
name|yaml_malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
block|{
name|parser
operator|->
name|error
operator|=
name|YAML_MEMORY_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|value
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SCALAR_EVENT_INIT
argument_list|(
operator|*
name|event
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|YAML_PLAIN_SCALAR_STYLE
argument_list|,
name|mark
argument_list|,
name|mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Parse directives.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_process_directives
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_version_directive_t
modifier|*
modifier|*
name|version_directive_ref
parameter_list|,
name|yaml_tag_directive_t
modifier|*
modifier|*
name|tag_directives_start_ref
parameter_list|,
name|yaml_tag_directive_t
modifier|*
modifier|*
name|tag_directives_end_ref
parameter_list|)
block|{
name|yaml_tag_directive_t
name|default_tag_directives
index|[]
init|=
block|{
block|{
operator|(
name|yaml_char_t
operator|*
operator|)
literal|"!"
block|,
operator|(
name|yaml_char_t
operator|*
operator|)
literal|"!"
block|}
block|,
block|{
operator|(
name|yaml_char_t
operator|*
operator|)
literal|"!!"
block|,
operator|(
name|yaml_char_t
operator|*
operator|)
literal|"tag:yaml.org,2002:"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
name|yaml_tag_directive_t
modifier|*
name|default_tag_directive
decl_stmt|;
name|yaml_version_directive_t
modifier|*
name|version_directive
init|=
name|NULL
decl_stmt|;
struct|struct
block|{
name|yaml_tag_directive_t
modifier|*
name|start
decl_stmt|;
name|yaml_tag_directive_t
modifier|*
name|end
decl_stmt|;
name|yaml_tag_directive_t
modifier|*
name|top
decl_stmt|;
block|}
name|tag_directives
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
struct|;
name|yaml_token_t
modifier|*
name|token
decl_stmt|;
if|if
condition|(
operator|!
name|STACK_INIT
argument_list|(
name|parser
argument_list|,
name|tag_directives
argument_list|,
name|INITIAL_STACK_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
goto|goto
name|error
goto|;
while|while
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_VERSION_DIRECTIVE_TOKEN
operator|||
name|token
operator|->
name|type
operator|==
name|YAML_TAG_DIRECTIVE_TOKEN
condition|)
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_VERSION_DIRECTIVE_TOKEN
condition|)
block|{
if|if
condition|(
name|version_directive
condition|)
block|{
name|yaml_parser_set_parser_error
argument_list|(
name|parser
argument_list|,
literal|"found duplicate %YAML directive"
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|token
operator|->
name|data
operator|.
name|version_directive
operator|.
name|major
operator|!=
literal|1
operator|||
name|token
operator|->
name|data
operator|.
name|version_directive
operator|.
name|minor
operator|!=
literal|1
condition|)
block|{
name|yaml_parser_set_parser_error
argument_list|(
name|parser
argument_list|,
literal|"found incompatible YAML document"
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|version_directive
operator|=
name|yaml_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|yaml_version_directive_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|version_directive
condition|)
block|{
name|parser
operator|->
name|error
operator|=
name|YAML_MEMORY_ERROR
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|version_directive
operator|->
name|major
operator|=
name|token
operator|->
name|data
operator|.
name|version_directive
operator|.
name|major
expr_stmt|;
name|version_directive
operator|->
name|minor
operator|=
name|token
operator|->
name|data
operator|.
name|version_directive
operator|.
name|minor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_TAG_DIRECTIVE_TOKEN
condition|)
block|{
name|yaml_tag_directive_t
name|value
decl_stmt|;
name|value
operator|.
name|handle
operator|=
name|token
operator|->
name|data
operator|.
name|tag_directive
operator|.
name|handle
expr_stmt|;
name|value
operator|.
name|prefix
operator|=
name|token
operator|->
name|data
operator|.
name|tag_directive
operator|.
name|prefix
expr_stmt|;
if|if
condition|(
operator|!
name|yaml_parser_append_tag_directive
argument_list|(
name|parser
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|tag_directives
argument_list|,
name|value
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
name|SKIP_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|token
operator|=
name|PEEK_TOKEN
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
condition|)
goto|goto
name|error
goto|;
block|}
for|for
control|(
name|default_tag_directive
operator|=
name|default_tag_directives
init|;
name|default_tag_directive
operator|->
name|handle
condition|;
name|default_tag_directive
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|yaml_parser_append_tag_directive
argument_list|(
name|parser
argument_list|,
operator|*
name|default_tag_directive
argument_list|,
literal|1
argument_list|,
name|token
operator|->
name|start_mark
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|version_directive_ref
condition|)
block|{
operator|*
name|version_directive_ref
operator|=
name|version_directive
expr_stmt|;
block|}
if|if
condition|(
name|tag_directives_start_ref
condition|)
block|{
if|if
condition|(
name|STACK_EMPTY
argument_list|(
name|parser
argument_list|,
name|tag_directives
argument_list|)
condition|)
block|{
operator|*
name|tag_directives_start_ref
operator|=
operator|*
name|tag_directives_end_ref
operator|=
name|NULL
expr_stmt|;
name|STACK_DEL
argument_list|(
name|parser
argument_list|,
name|tag_directives
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tag_directives_start_ref
operator|=
name|tag_directives
operator|.
name|start
expr_stmt|;
operator|*
name|tag_directives_end_ref
operator|=
name|tag_directives
operator|.
name|top
expr_stmt|;
block|}
block|}
else|else
block|{
name|STACK_DEL
argument_list|(
name|parser
argument_list|,
name|tag_directives
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
name|error
label|:
name|yaml_free
argument_list|(
name|version_directive
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|STACK_EMPTY
argument_list|(
name|parser
argument_list|,
name|tag_directives
argument_list|)
condition|)
block|{
name|yaml_tag_directive_t
name|tag_directive
init|=
name|POP
argument_list|(
name|parser
argument_list|,
name|tag_directives
argument_list|)
decl_stmt|;
name|yaml_free
argument_list|(
name|tag_directive
operator|.
name|handle
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|tag_directive
operator|.
name|prefix
argument_list|)
expr_stmt|;
block|}
name|STACK_DEL
argument_list|(
name|parser
argument_list|,
name|tag_directives
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Append a tag directive to the directives stack.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_append_tag_directive
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_tag_directive_t
name|value
parameter_list|,
name|int
name|allow_duplicates
parameter_list|,
name|yaml_mark_t
name|mark
parameter_list|)
block|{
name|yaml_tag_directive_t
modifier|*
name|tag_directive
decl_stmt|;
name|yaml_tag_directive_t
name|copy
init|=
block|{
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
for|for
control|(
name|tag_directive
operator|=
name|parser
operator|->
name|tag_directives
operator|.
name|start
init|;
name|tag_directive
operator|!=
name|parser
operator|->
name|tag_directives
operator|.
name|top
condition|;
name|tag_directive
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|value
operator|.
name|handle
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tag_directive
operator|->
name|handle
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|allow_duplicates
condition|)
return|return
literal|1
return|;
return|return
name|yaml_parser_set_parser_error
argument_list|(
name|parser
argument_list|,
literal|"found duplicate %TAG directive"
argument_list|,
name|mark
argument_list|)
return|;
block|}
block|}
name|copy
operator|.
name|handle
operator|=
name|yaml_strdup
argument_list|(
name|value
operator|.
name|handle
argument_list|)
expr_stmt|;
name|copy
operator|.
name|prefix
operator|=
name|yaml_strdup
argument_list|(
name|value
operator|.
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copy
operator|.
name|handle
operator|||
operator|!
name|copy
operator|.
name|prefix
condition|)
block|{
name|parser
operator|->
name|error
operator|=
name|YAML_MEMORY_ERROR
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tag_directives
argument_list|,
name|copy
argument_list|)
condition|)
goto|goto
name|error
goto|;
return|return
literal|1
return|;
name|error
label|:
name|yaml_free
argument_list|(
name|copy
operator|.
name|handle
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|copy
operator|.
name|prefix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

