begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"yaml_private.h"
end_include

begin_comment
comment|/*  * Declarations.  */
end_comment

begin_function_decl
specifier|static
name|int
name|yaml_parser_set_reader_error
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|problem
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_update_raw_buffer
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_determine_encoding
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_parser_update_buffer
argument_list|(
argument|yaml_parser_t *parser
argument_list|,
argument|size_t length
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * Set the reader error and return 0.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_set_reader_error
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|problem
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|parser
operator|->
name|error
operator|=
name|YAML_READER_ERROR
expr_stmt|;
name|parser
operator|->
name|problem
operator|=
name|problem
expr_stmt|;
name|parser
operator|->
name|problem_offset
operator|=
name|offset
expr_stmt|;
name|parser
operator|->
name|problem_value
operator|=
name|value
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Byte order marks.  */
end_comment

begin_define
define|#
directive|define
name|BOM_UTF8
value|"\xef\xbb\xbf"
end_define

begin_define
define|#
directive|define
name|BOM_UTF16LE
value|"\xff\xfe"
end_define

begin_define
define|#
directive|define
name|BOM_UTF16BE
value|"\xfe\xff"
end_define

begin_comment
comment|/*  * Determine the input stream encoding by checking the BOM symbol. If no BOM is  * found, the UTF-8 encoding is assumed. Return 1 on success, 0 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_determine_encoding
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Ensure that we had enough bytes in the raw buffer. */
while|while
condition|(
operator|!
name|parser
operator|->
name|eof
operator|&&
name|parser
operator|->
name|raw_buffer
operator|.
name|last
operator|-
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
operator|<
literal|3
condition|)
block|{
if|if
condition|(
operator|!
name|yaml_parser_update_raw_buffer
argument_list|(
name|parser
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/* Determine the encoding. */
if|if
condition|(
name|parser
operator|->
name|raw_buffer
operator|.
name|last
operator|-
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
operator|>=
literal|2
operator|&&
operator|!
name|memcmp
argument_list|(
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
argument_list|,
name|BOM_UTF16LE
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|parser
operator|->
name|encoding
operator|=
name|YAML_UTF16LE_ENCODING
expr_stmt|;
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
operator|+=
literal|2
expr_stmt|;
name|parser
operator|->
name|offset
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parser
operator|->
name|raw_buffer
operator|.
name|last
operator|-
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
operator|>=
literal|2
operator|&&
operator|!
name|memcmp
argument_list|(
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
argument_list|,
name|BOM_UTF16BE
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|parser
operator|->
name|encoding
operator|=
name|YAML_UTF16BE_ENCODING
expr_stmt|;
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
operator|+=
literal|2
expr_stmt|;
name|parser
operator|->
name|offset
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parser
operator|->
name|raw_buffer
operator|.
name|last
operator|-
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
operator|>=
literal|3
operator|&&
operator|!
name|memcmp
argument_list|(
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
argument_list|,
name|BOM_UTF8
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|parser
operator|->
name|encoding
operator|=
name|YAML_UTF8_ENCODING
expr_stmt|;
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
operator|+=
literal|3
expr_stmt|;
name|parser
operator|->
name|offset
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|parser
operator|->
name|encoding
operator|=
name|YAML_UTF8_ENCODING
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Update the raw buffer.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_update_raw_buffer
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
block|{
name|size_t
name|size_read
init|=
literal|0
decl_stmt|;
comment|/* Return if the raw buffer is full. */
if|if
condition|(
name|parser
operator|->
name|raw_buffer
operator|.
name|start
operator|==
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
operator|&&
name|parser
operator|->
name|raw_buffer
operator|.
name|last
operator|==
name|parser
operator|->
name|raw_buffer
operator|.
name|end
condition|)
return|return
literal|1
return|;
comment|/* Return on EOF. */
if|if
condition|(
name|parser
operator|->
name|eof
condition|)
return|return
literal|1
return|;
comment|/* Move the remaining bytes in the raw buffer to the beginning. */
if|if
condition|(
name|parser
operator|->
name|raw_buffer
operator|.
name|start
operator|<
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
operator|&&
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
operator|<
name|parser
operator|->
name|raw_buffer
operator|.
name|last
condition|)
block|{
name|memmove
argument_list|(
name|parser
operator|->
name|raw_buffer
operator|.
name|start
argument_list|,
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
argument_list|,
name|parser
operator|->
name|raw_buffer
operator|.
name|last
operator|-
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
argument_list|)
expr_stmt|;
block|}
name|parser
operator|->
name|raw_buffer
operator|.
name|last
operator|-=
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
operator|-
name|parser
operator|->
name|raw_buffer
operator|.
name|start
expr_stmt|;
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
operator|=
name|parser
operator|->
name|raw_buffer
operator|.
name|start
expr_stmt|;
comment|/* Call the read handler to fill the buffer. */
if|if
condition|(
operator|!
name|parser
operator|->
name|read_handler
argument_list|(
name|parser
operator|->
name|read_handler_data
argument_list|,
name|parser
operator|->
name|raw_buffer
operator|.
name|last
argument_list|,
name|parser
operator|->
name|raw_buffer
operator|.
name|end
operator|-
name|parser
operator|->
name|raw_buffer
operator|.
name|last
argument_list|,
operator|&
name|size_read
argument_list|)
condition|)
block|{
return|return
name|yaml_parser_set_reader_error
argument_list|(
name|parser
argument_list|,
literal|"input error"
argument_list|,
name|parser
operator|->
name|offset
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
name|parser
operator|->
name|raw_buffer
operator|.
name|last
operator|+=
name|size_read
expr_stmt|;
if|if
condition|(
operator|!
name|size_read
condition|)
block|{
name|parser
operator|->
name|eof
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Ensure that the buffer contains at least `length` characters.  * Return 1 on success, 0 on failure.  *  * The length is supposed to be significantly less that the buffer size.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_parser_update_buffer
argument_list|(
argument|yaml_parser_t *parser
argument_list|,
argument|size_t length
argument_list|)
end_macro

begin_block
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
name|assert
argument_list|(
name|parser
operator|->
name|read_handler
argument_list|)
expr_stmt|;
comment|/* Read handler must be set. */
comment|/* If the EOF flag is set and the raw buffer is empty, do nothing. */
if|if
condition|(
name|parser
operator|->
name|eof
operator|&&
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
operator|==
name|parser
operator|->
name|raw_buffer
operator|.
name|last
condition|)
return|return
literal|1
return|;
comment|/* Return if the buffer contains enough characters. */
if|if
condition|(
name|parser
operator|->
name|unread
operator|>=
name|length
condition|)
return|return
literal|1
return|;
comment|/* Determine the input encoding if it is not known yet. */
if|if
condition|(
operator|!
name|parser
operator|->
name|encoding
condition|)
block|{
if|if
condition|(
operator|!
name|yaml_parser_determine_encoding
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Move the unread characters to the beginning of the buffer. */
if|if
condition|(
name|parser
operator|->
name|buffer
operator|.
name|start
operator|<
name|parser
operator|->
name|buffer
operator|.
name|pointer
operator|&&
name|parser
operator|->
name|buffer
operator|.
name|pointer
operator|<
name|parser
operator|->
name|buffer
operator|.
name|last
condition|)
block|{
name|size_t
name|size
init|=
name|parser
operator|->
name|buffer
operator|.
name|last
operator|-
name|parser
operator|->
name|buffer
operator|.
name|pointer
decl_stmt|;
name|memmove
argument_list|(
name|parser
operator|->
name|buffer
operator|.
name|start
argument_list|,
name|parser
operator|->
name|buffer
operator|.
name|pointer
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|parser
operator|->
name|buffer
operator|.
name|pointer
operator|=
name|parser
operator|->
name|buffer
operator|.
name|start
expr_stmt|;
name|parser
operator|->
name|buffer
operator|.
name|last
operator|=
name|parser
operator|->
name|buffer
operator|.
name|start
operator|+
name|size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parser
operator|->
name|buffer
operator|.
name|pointer
operator|==
name|parser
operator|->
name|buffer
operator|.
name|last
condition|)
block|{
name|parser
operator|->
name|buffer
operator|.
name|pointer
operator|=
name|parser
operator|->
name|buffer
operator|.
name|start
expr_stmt|;
name|parser
operator|->
name|buffer
operator|.
name|last
operator|=
name|parser
operator|->
name|buffer
operator|.
name|start
expr_stmt|;
block|}
comment|/* Fill the buffer until it has enough characters. */
while|while
condition|(
name|parser
operator|->
name|unread
operator|<
name|length
condition|)
block|{
comment|/* Fill the raw buffer if necessary. */
if|if
condition|(
operator|!
name|first
operator|||
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
operator|==
name|parser
operator|->
name|raw_buffer
operator|.
name|last
condition|)
block|{
if|if
condition|(
operator|!
name|yaml_parser_update_raw_buffer
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|first
operator|=
literal|0
expr_stmt|;
comment|/* Decode the raw buffer. */
while|while
condition|(
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
operator|!=
name|parser
operator|->
name|raw_buffer
operator|.
name|last
condition|)
block|{
name|unsigned
name|int
name|value
init|=
literal|0
decl_stmt|,
name|value2
init|=
literal|0
decl_stmt|;
name|int
name|incomplete
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|octet
decl_stmt|;
name|unsigned
name|int
name|width
init|=
literal|0
decl_stmt|;
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
name|size_t
name|k
decl_stmt|;
name|size_t
name|raw_unread
init|=
name|parser
operator|->
name|raw_buffer
operator|.
name|last
operator|-
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
decl_stmt|;
comment|/* Decode the next character. */
switch|switch
condition|(
name|parser
operator|->
name|encoding
condition|)
block|{
case|case
name|YAML_UTF8_ENCODING
case|:
comment|/*                      * Decode a UTF-8 character.  Check RFC 3629                      * (http://www.ietf.org/rfc/rfc3629.txt) for more details.                      *                      * The following table (taken from the RFC) is used for                      * decoding.                      *                      *    Char. number range |        UTF-8 octet sequence                      *      (hexadecimal)    |              (binary)                      *   --------------------+------------------------------------                      *   0000 0000-0000 007F | 0xxxxxxx                      *   0000 0080-0000 07FF | 110xxxxx 10xxxxxx                      *   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx                      *   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx                      *                      * Additionally, the characters in the range 0xD800-0xDFFF                      * are prohibited as they are reserved for use with UTF-16                      * surrogate pairs.                      */
comment|/* Determine the length of the UTF-8 sequence. */
name|octet
operator|=
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
index|[
literal|0
index|]
expr_stmt|;
name|width
operator|=
operator|(
name|octet
operator|&
literal|0x80
operator|)
operator|==
literal|0x00
condition|?
literal|1
else|:
operator|(
name|octet
operator|&
literal|0xE0
operator|)
operator|==
literal|0xC0
condition|?
literal|2
else|:
operator|(
name|octet
operator|&
literal|0xF0
operator|)
operator|==
literal|0xE0
condition|?
literal|3
else|:
operator|(
name|octet
operator|&
literal|0xF8
operator|)
operator|==
literal|0xF0
condition|?
literal|4
else|:
literal|0
expr_stmt|;
comment|/* Check if the leading octet is valid. */
if|if
condition|(
operator|!
name|width
condition|)
return|return
name|yaml_parser_set_reader_error
argument_list|(
name|parser
argument_list|,
literal|"invalid leading UTF-8 octet"
argument_list|,
name|parser
operator|->
name|offset
argument_list|,
name|octet
argument_list|)
return|;
comment|/* Check if the raw buffer contains an incomplete character. */
if|if
condition|(
name|width
operator|>
name|raw_unread
condition|)
block|{
if|if
condition|(
name|parser
operator|->
name|eof
condition|)
block|{
return|return
name|yaml_parser_set_reader_error
argument_list|(
name|parser
argument_list|,
literal|"incomplete UTF-8 octet sequence"
argument_list|,
name|parser
operator|->
name|offset
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
name|incomplete
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Decode the leading octet. */
name|value
operator|=
operator|(
name|octet
operator|&
literal|0x80
operator|)
operator|==
literal|0x00
condition|?
name|octet
operator|&
literal|0x7F
else|:
operator|(
name|octet
operator|&
literal|0xE0
operator|)
operator|==
literal|0xC0
condition|?
name|octet
operator|&
literal|0x1F
else|:
operator|(
name|octet
operator|&
literal|0xF0
operator|)
operator|==
literal|0xE0
condition|?
name|octet
operator|&
literal|0x0F
else|:
operator|(
name|octet
operator|&
literal|0xF8
operator|)
operator|==
literal|0xF0
condition|?
name|octet
operator|&
literal|0x07
else|:
literal|0
expr_stmt|;
comment|/* Check and decode the trailing octets. */
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|width
condition|;
name|k
operator|++
control|)
block|{
name|octet
operator|=
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
index|[
name|k
index|]
expr_stmt|;
comment|/* Check if the octet is valid. */
if|if
condition|(
operator|(
name|octet
operator|&
literal|0xC0
operator|)
operator|!=
literal|0x80
condition|)
return|return
name|yaml_parser_set_reader_error
argument_list|(
name|parser
argument_list|,
literal|"invalid trailing UTF-8 octet"
argument_list|,
name|parser
operator|->
name|offset
operator|+
name|k
argument_list|,
name|octet
argument_list|)
return|;
comment|/* Decode the octet. */
name|value
operator|=
operator|(
name|value
operator|<<
literal|6
operator|)
operator|+
operator|(
name|octet
operator|&
literal|0x3F
operator|)
expr_stmt|;
block|}
comment|/* Check the length of the sequence against the value. */
if|if
condition|(
operator|!
operator|(
operator|(
name|width
operator|==
literal|1
operator|)
operator|||
operator|(
name|width
operator|==
literal|2
operator|&&
name|value
operator|>=
literal|0x80
operator|)
operator|||
operator|(
name|width
operator|==
literal|3
operator|&&
name|value
operator|>=
literal|0x800
operator|)
operator|||
operator|(
name|width
operator|==
literal|4
operator|&&
name|value
operator|>=
literal|0x10000
operator|)
operator|)
condition|)
return|return
name|yaml_parser_set_reader_error
argument_list|(
name|parser
argument_list|,
literal|"invalid length of a UTF-8 sequence"
argument_list|,
name|parser
operator|->
name|offset
argument_list|,
operator|-
literal|1
argument_list|)
return|;
comment|/* Check the range of the value. */
if|if
condition|(
operator|(
name|value
operator|>=
literal|0xD800
operator|&&
name|value
operator|<=
literal|0xDFFF
operator|)
operator|||
name|value
operator|>
literal|0x10FFFF
condition|)
return|return
name|yaml_parser_set_reader_error
argument_list|(
name|parser
argument_list|,
literal|"invalid Unicode character"
argument_list|,
name|parser
operator|->
name|offset
argument_list|,
name|value
argument_list|)
return|;
break|break;
case|case
name|YAML_UTF16LE_ENCODING
case|:
case|case
name|YAML_UTF16BE_ENCODING
case|:
name|low
operator|=
operator|(
name|parser
operator|->
name|encoding
operator|==
name|YAML_UTF16LE_ENCODING
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
name|high
operator|=
operator|(
name|parser
operator|->
name|encoding
operator|==
name|YAML_UTF16LE_ENCODING
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/*                      * The UTF-16 encoding is not as simple as one might                      * naively think.  Check RFC 2781                      * (http://www.ietf.org/rfc/rfc2781.txt).                      *                      * Normally, two subsequent bytes describe a Unicode                      * character.  However a special technique (called a                      * surrogate pair) is used for specifying character                      * values larger than 0xFFFF.                      *                      * A surrogate pair consists of two pseudo-characters:                      *      high surrogate area (0xD800-0xDBFF)                      *      low surrogate area (0xDC00-0xDFFF)                      *                      * The following formulas are used for decoding                      * and encoding characters using surrogate pairs:                      *                       *  U  = U' + 0x10000   (0x01 00 00<= U<= 0x10 FF FF)                      *  U' = yyyyyyyyyyxxxxxxxxxx   (0<= U'<= 0x0F FF FF)                      *  W1 = 110110yyyyyyyyyy                      *  W2 = 110111xxxxxxxxxx                      *                      * where U is the character value, W1 is the high surrogate                      * area, W2 is the low surrogate area.                      */
comment|/* Check for incomplete UTF-16 character. */
if|if
condition|(
name|raw_unread
operator|<
literal|2
condition|)
block|{
if|if
condition|(
name|parser
operator|->
name|eof
condition|)
block|{
return|return
name|yaml_parser_set_reader_error
argument_list|(
name|parser
argument_list|,
literal|"incomplete UTF-16 character"
argument_list|,
name|parser
operator|->
name|offset
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
name|incomplete
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Get the character. */
name|value
operator|=
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
index|[
name|low
index|]
operator|+
operator|(
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
index|[
name|high
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* Check for unexpected low surrogate area. */
if|if
condition|(
operator|(
name|value
operator|&
literal|0xFC00
operator|)
operator|==
literal|0xDC00
condition|)
return|return
name|yaml_parser_set_reader_error
argument_list|(
name|parser
argument_list|,
literal|"unexpected low surrogate area"
argument_list|,
name|parser
operator|->
name|offset
argument_list|,
name|value
argument_list|)
return|;
comment|/* Check for a high surrogate area. */
if|if
condition|(
operator|(
name|value
operator|&
literal|0xFC00
operator|)
operator|==
literal|0xD800
condition|)
block|{
name|width
operator|=
literal|4
expr_stmt|;
comment|/* Check for incomplete surrogate pair. */
if|if
condition|(
name|raw_unread
operator|<
literal|4
condition|)
block|{
if|if
condition|(
name|parser
operator|->
name|eof
condition|)
block|{
return|return
name|yaml_parser_set_reader_error
argument_list|(
name|parser
argument_list|,
literal|"incomplete UTF-16 surrogate pair"
argument_list|,
name|parser
operator|->
name|offset
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
name|incomplete
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Get the next character. */
name|value2
operator|=
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
index|[
name|low
operator|+
literal|2
index|]
operator|+
operator|(
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
index|[
name|high
operator|+
literal|2
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* Check for a low surrogate area. */
if|if
condition|(
operator|(
name|value2
operator|&
literal|0xFC00
operator|)
operator|!=
literal|0xDC00
condition|)
return|return
name|yaml_parser_set_reader_error
argument_list|(
name|parser
argument_list|,
literal|"expected low surrogate area"
argument_list|,
name|parser
operator|->
name|offset
operator|+
literal|2
argument_list|,
name|value2
argument_list|)
return|;
comment|/* Generate the value of the surrogate pair. */
name|value
operator|=
literal|0x10000
operator|+
operator|(
operator|(
name|value
operator|&
literal|0x3FF
operator|)
operator|<<
literal|10
operator|)
operator|+
operator|(
name|value2
operator|&
literal|0x3FF
operator|)
expr_stmt|;
block|}
else|else
block|{
name|width
operator|=
literal|2
expr_stmt|;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Impossible. */
block|}
comment|/* Check if the raw buffer contains enough bytes to form a character. */
if|if
condition|(
name|incomplete
condition|)
break|break;
comment|/*              * Check if the character is in the allowed range:              *      #x9 | #xA | #xD | [#x20-#x7E]               (8 bit)              *      | #x85 | [#xA0-#xD7FF] | [#xE000-#xFFFD]    (16 bit)              *      | [#x10000-#x10FFFF]                        (32 bit)              */
if|if
condition|(
operator|!
operator|(
name|value
operator|==
literal|0x09
operator|||
name|value
operator|==
literal|0x0A
operator|||
name|value
operator|==
literal|0x0D
operator|||
operator|(
name|value
operator|>=
literal|0x20
operator|&&
name|value
operator|<=
literal|0x7E
operator|)
operator|||
operator|(
name|value
operator|==
literal|0x85
operator|)
operator|||
operator|(
name|value
operator|>=
literal|0xA0
operator|&&
name|value
operator|<=
literal|0xD7FF
operator|)
operator|||
operator|(
name|value
operator|>=
literal|0xE000
operator|&&
name|value
operator|<=
literal|0xFFFD
operator|)
operator|||
operator|(
name|value
operator|>=
literal|0x10000
operator|&&
name|value
operator|<=
literal|0x10FFFF
operator|)
operator|)
condition|)
return|return
name|yaml_parser_set_reader_error
argument_list|(
name|parser
argument_list|,
literal|"control characters are not allowed"
argument_list|,
name|parser
operator|->
name|offset
argument_list|,
name|value
argument_list|)
return|;
comment|/* Move the raw pointers. */
name|parser
operator|->
name|raw_buffer
operator|.
name|pointer
operator|+=
name|width
expr_stmt|;
name|parser
operator|->
name|offset
operator|+=
name|width
expr_stmt|;
comment|/* Finally put the character into the buffer. */
comment|/* 0000 0000-0000 007F -> 0xxxxxxx */
if|if
condition|(
name|value
operator|<=
literal|0x7F
condition|)
block|{
operator|*
operator|(
name|parser
operator|->
name|buffer
operator|.
name|last
operator|++
operator|)
operator|=
name|value
expr_stmt|;
block|}
comment|/* 0000 0080-0000 07FF -> 110xxxxx 10xxxxxx */
elseif|else
if|if
condition|(
name|value
operator|<=
literal|0x7FF
condition|)
block|{
operator|*
operator|(
name|parser
operator|->
name|buffer
operator|.
name|last
operator|++
operator|)
operator|=
literal|0xC0
operator|+
operator|(
name|value
operator|>>
literal|6
operator|)
expr_stmt|;
operator|*
operator|(
name|parser
operator|->
name|buffer
operator|.
name|last
operator|++
operator|)
operator|=
literal|0x80
operator|+
operator|(
name|value
operator|&
literal|0x3F
operator|)
expr_stmt|;
block|}
comment|/* 0000 0800-0000 FFFF -> 1110xxxx 10xxxxxx 10xxxxxx */
elseif|else
if|if
condition|(
name|value
operator|<=
literal|0xFFFF
condition|)
block|{
operator|*
operator|(
name|parser
operator|->
name|buffer
operator|.
name|last
operator|++
operator|)
operator|=
literal|0xE0
operator|+
operator|(
name|value
operator|>>
literal|12
operator|)
expr_stmt|;
operator|*
operator|(
name|parser
operator|->
name|buffer
operator|.
name|last
operator|++
operator|)
operator|=
literal|0x80
operator|+
operator|(
operator|(
name|value
operator|>>
literal|6
operator|)
operator|&
literal|0x3F
operator|)
expr_stmt|;
operator|*
operator|(
name|parser
operator|->
name|buffer
operator|.
name|last
operator|++
operator|)
operator|=
literal|0x80
operator|+
operator|(
name|value
operator|&
literal|0x3F
operator|)
expr_stmt|;
block|}
comment|/* 0001 0000-0010 FFFF -> 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
else|else
block|{
operator|*
operator|(
name|parser
operator|->
name|buffer
operator|.
name|last
operator|++
operator|)
operator|=
literal|0xF0
operator|+
operator|(
name|value
operator|>>
literal|18
operator|)
expr_stmt|;
operator|*
operator|(
name|parser
operator|->
name|buffer
operator|.
name|last
operator|++
operator|)
operator|=
literal|0x80
operator|+
operator|(
operator|(
name|value
operator|>>
literal|12
operator|)
operator|&
literal|0x3F
operator|)
expr_stmt|;
operator|*
operator|(
name|parser
operator|->
name|buffer
operator|.
name|last
operator|++
operator|)
operator|=
literal|0x80
operator|+
operator|(
operator|(
name|value
operator|>>
literal|6
operator|)
operator|&
literal|0x3F
operator|)
expr_stmt|;
operator|*
operator|(
name|parser
operator|->
name|buffer
operator|.
name|last
operator|++
operator|)
operator|=
literal|0x80
operator|+
operator|(
name|value
operator|&
literal|0x3F
operator|)
expr_stmt|;
block|}
name|parser
operator|->
name|unread
operator|++
expr_stmt|;
block|}
comment|/* On EOF, put NUL into the buffer and return. */
if|if
condition|(
name|parser
operator|->
name|eof
condition|)
block|{
operator|*
operator|(
name|parser
operator|->
name|buffer
operator|.
name|last
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|parser
operator|->
name|unread
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_block

end_unit

