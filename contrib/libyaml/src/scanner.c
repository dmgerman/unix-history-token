begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Introduction  * ************  *  * The following notes assume that you are familiar with the YAML specification  * (http://yaml.org/spec/cvs/current.html).  We mostly follow it, although in  * some cases we are less restrictive that it requires.  *  * The process of transforming a YAML stream into a sequence of events is  * divided on two steps: Scanning and Parsing.  *  * The Scanner transforms the input stream into a sequence of tokens, while the  * parser transform the sequence of tokens produced by the Scanner into a  * sequence of parsing events.  *  * The Scanner is rather clever and complicated. The Parser, on the contrary,  * is a straightforward implementation of a recursive-descendant parser (or,  * LL(1) parser, as it is usually called).  *  * Actually there are two issues of Scanning that might be called "clever", the  * rest is quite straightforward.  The issues are "block collection start" and  * "simple keys".  Both issues are explained below in details.  *  * Here the Scanning step is explained and implemented.  We start with the list  * of all the tokens produced by the Scanner together with short descriptions.  *  * Now, tokens:  *  *      STREAM-START(encoding)          # The stream start.  *      STREAM-END                      # The stream end.  *      VERSION-DIRECTIVE(major,minor)  # The '%YAML' directive.  *      TAG-DIRECTIVE(handle,prefix)    # The '%TAG' directive.  *      DOCUMENT-START                  # '---'  *      DOCUMENT-END                    # '...'  *      BLOCK-SEQUENCE-START            # Indentation increase denoting a block  *      BLOCK-MAPPING-START             # sequence or a block mapping.  *      BLOCK-END                       # Indentation decrease.  *      FLOW-SEQUENCE-START             # '['  *      FLOW-SEQUENCE-END               # ']'  *      BLOCK-SEQUENCE-START            # '{'  *      BLOCK-SEQUENCE-END              # '}'  *      BLOCK-ENTRY                     # '-'  *      FLOW-ENTRY                      # ','  *      KEY                             # '?' or nothing (simple keys).  *      VALUE                           # ':'  *      ALIAS(anchor)                   # '*anchor'  *      ANCHOR(anchor)                  # '&anchor'  *      TAG(handle,suffix)              # '!handle!suffix'  *      SCALAR(value,style)             # A scalar.  *  * The following two tokens are "virtual" tokens denoting the beginning and the  * end of the stream:  *  *      STREAM-START(encoding)  *      STREAM-END  *  * We pass the information about the input stream encoding with the  * STREAM-START token.  *  * The next two tokens are responsible for tags:  *  *      VERSION-DIRECTIVE(major,minor)  *      TAG-DIRECTIVE(handle,prefix)  *  * Example:  *  *      %YAML   1.1  *      %TAG    !   !foo  *      %TAG    !yaml!  tag:yaml.org,2002:  *      ---  *  * The correspoding sequence of tokens:  *  *      STREAM-START(utf-8)  *      VERSION-DIRECTIVE(1,1)  *      TAG-DIRECTIVE("!","!foo")  *      TAG-DIRECTIVE("!yaml","tag:yaml.org,2002:")  *      DOCUMENT-START  *      STREAM-END  *  * Note that the VERSION-DIRECTIVE and TAG-DIRECTIVE tokens occupy a whole  * line.  *  * The document start and end indicators are represented by:  *  *      DOCUMENT-START  *      DOCUMENT-END  *  * Note that if a YAML stream contains an implicit document (without '---'  * and '...' indicators), no DOCUMENT-START and DOCUMENT-END tokens will be  * produced.  *  * In the following examples, we present whole documents together with the  * produced tokens.  *  *      1. An implicit document:  *  *          'a scalar'  *  *      Tokens:  *  *          STREAM-START(utf-8)  *          SCALAR("a scalar",single-quoted)  *          STREAM-END  *  *      2. An explicit document:  *  *          ---  *          'a scalar'  *          ...  *  *      Tokens:  *  *          STREAM-START(utf-8)  *          DOCUMENT-START  *          SCALAR("a scalar",single-quoted)  *          DOCUMENT-END  *          STREAM-END  *  *      3. Several documents in a stream:  *  *          'a scalar'  *          ---  *          'another scalar'  *          ---  *          'yet another scalar'  *  *      Tokens:  *  *          STREAM-START(utf-8)  *          SCALAR("a scalar",single-quoted)  *          DOCUMENT-START  *          SCALAR("another scalar",single-quoted)  *          DOCUMENT-START  *          SCALAR("yet another scalar",single-quoted)  *          STREAM-END  *  * We have already introduced the SCALAR token above.  The following tokens are  * used to describe aliases, anchors, tag, and scalars:  *  *      ALIAS(anchor)  *      ANCHOR(anchor)  *      TAG(handle,suffix)  *      SCALAR(value,style)  *  * The following series of examples illustrate the usage of these tokens:  *  *      1. A recursive sequence:  *  *&A [ *A ]  *  *      Tokens:  *  *          STREAM-START(utf-8)  *          ANCHOR("A")  *          FLOW-SEQUENCE-START  *          ALIAS("A")  *          FLOW-SEQUENCE-END  *          STREAM-END  *  *      2. A tagged scalar:  *  *          !!float "3.14"  # A good approximation.  *  *      Tokens:  *  *          STREAM-START(utf-8)  *          TAG("!!","float")  *          SCALAR("3.14",double-quoted)  *          STREAM-END  *  *      3. Various scalar styles:  *  *          --- # Implicit empty plain scalars do not produce tokens.  *          --- a plain scalar  *          --- 'a single-quoted scalar'  *          --- "a double-quoted scalar"  *          --- |-  *            a literal scalar  *          --->-  *            a folded  *            scalar  *  *      Tokens:  *  *          STREAM-START(utf-8)  *          DOCUMENT-START  *          DOCUMENT-START  *          SCALAR("a plain scalar",plain)  *          DOCUMENT-START  *          SCALAR("a single-quoted scalar",single-quoted)  *          DOCUMENT-START  *          SCALAR("a double-quoted scalar",double-quoted)  *          DOCUMENT-START  *          SCALAR("a literal scalar",literal)  *          DOCUMENT-START  *          SCALAR("a folded scalar",folded)  *          STREAM-END  *  * Now it's time to review collection-related tokens. We will start with  * flow collections:  *  *      FLOW-SEQUENCE-START  *      FLOW-SEQUENCE-END  *      FLOW-MAPPING-START  *      FLOW-MAPPING-END  *      FLOW-ENTRY  *      KEY  *      VALUE  *  * The tokens FLOW-SEQUENCE-START, FLOW-SEQUENCE-END, FLOW-MAPPING-START, and  * FLOW-MAPPING-END represent the indicators '[', ']', '{', and '}'  * correspondingly.  FLOW-ENTRY represent the ',' indicator.  Finally the  * indicators '?' and ':', which are used for denoting mapping keys and values,  * are represented by the KEY and VALUE tokens.  *  * The following examples show flow collections:  *  *      1. A flow sequence:  *  *          [item 1, item 2, item 3]  *  *      Tokens:  *  *          STREAM-START(utf-8)  *          FLOW-SEQUENCE-START  *          SCALAR("item 1",plain)  *          FLOW-ENTRY  *          SCALAR("item 2",plain)  *          FLOW-ENTRY  *          SCALAR("item 3",plain)  *          FLOW-SEQUENCE-END  *          STREAM-END  *  *      2. A flow mapping:  *  *          {  *              a simple key: a value,  # Note that the KEY token is produced.  *              ? a complex key: another value,  *          }  *  *      Tokens:  *  *          STREAM-START(utf-8)  *          FLOW-MAPPING-START  *          KEY  *          SCALAR("a simple key",plain)  *          VALUE  *          SCALAR("a value",plain)  *          FLOW-ENTRY  *          KEY  *          SCALAR("a complex key",plain)  *          VALUE  *          SCALAR("another value",plain)  *          FLOW-ENTRY  *          FLOW-MAPPING-END  *          STREAM-END  *  * A simple key is a key which is not denoted by the '?' indicator.  Note that  * the Scanner still produce the KEY token whenever it encounters a simple key.  *  * For scanning block collections, the following tokens are used (note that we  * repeat KEY and VALUE here):  *  *      BLOCK-SEQUENCE-START  *      BLOCK-MAPPING-START  *      BLOCK-END  *      BLOCK-ENTRY  *      KEY  *      VALUE  *  * The tokens BLOCK-SEQUENCE-START and BLOCK-MAPPING-START denote indentation  * increase that precedes a block collection (cf. the INDENT token in Python).  * The token BLOCK-END denote indentation decrease that ends a block collection  * (cf. the DEDENT token in Python).  However YAML has some syntax pecularities  * that makes detections of these tokens more complex.  *  * The tokens BLOCK-ENTRY, KEY, and VALUE are used to represent the indicators  * '-', '?', and ':' correspondingly.  *  * The following examples show how the tokens BLOCK-SEQUENCE-START,  * BLOCK-MAPPING-START, and BLOCK-END are emitted by the Scanner:  *  *      1. Block sequences:  *  *          - item 1  *          - item 2  *          -  *            - item 3.1  *            - item 3.2  *          -  *            key 1: value 1  *            key 2: value 2  *  *      Tokens:  *  *          STREAM-START(utf-8)  *          BLOCK-SEQUENCE-START  *          BLOCK-ENTRY  *          SCALAR("item 1",plain)  *          BLOCK-ENTRY  *          SCALAR("item 2",plain)  *          BLOCK-ENTRY  *          BLOCK-SEQUENCE-START  *          BLOCK-ENTRY  *          SCALAR("item 3.1",plain)  *          BLOCK-ENTRY  *          SCALAR("item 3.2",plain)  *          BLOCK-END  *          BLOCK-ENTRY  *          BLOCK-MAPPING-START  *          KEY  *          SCALAR("key 1",plain)  *          VALUE  *          SCALAR("value 1",plain)  *          KEY  *          SCALAR("key 2",plain)  *          VALUE  *          SCALAR("value 2",plain)  *          BLOCK-END  *          BLOCK-END  *          STREAM-END  *  *      2. Block mappings:  *  *          a simple key: a value   # The KEY token is produced here.  *          ? a complex key  *          : another value  *          a mapping:  *            key 1: value 1  *            key 2: value 2  *          a sequence:  *            - item 1  *            - item 2  *  *      Tokens:  *  *          STREAM-START(utf-8)  *          BLOCK-MAPPING-START  *          KEY  *          SCALAR("a simple key",plain)  *          VALUE  *          SCALAR("a value",plain)  *          KEY  *          SCALAR("a complex key",plain)  *          VALUE  *          SCALAR("another value",plain)  *          KEY  *          SCALAR("a mapping",plain)  *          BLOCK-MAPPING-START  *          KEY  *          SCALAR("key 1",plain)  *          VALUE  *          SCALAR("value 1",plain)  *          KEY  *          SCALAR("key 2",plain)  *          VALUE  *          SCALAR("value 2",plain)  *          BLOCK-END  *          KEY  *          SCALAR("a sequence",plain)  *          VALUE  *          BLOCK-SEQUENCE-START  *          BLOCK-ENTRY  *          SCALAR("item 1",plain)  *          BLOCK-ENTRY  *          SCALAR("item 2",plain)  *          BLOCK-END  *          BLOCK-END  *          STREAM-END  *  * YAML does not always require to start a new block collection from a new  * line.  If the current line contains only '-', '?', and ':' indicators, a new  * block collection may start at the current line.  The following examples  * illustrate this case:  *  *      1. Collections in a sequence:  *  *          - - item 1  *            - item 2  *          - key 1: value 1  *            key 2: value 2  *          - ? complex key  *            : complex value  *  *      Tokens:  *  *          STREAM-START(utf-8)  *          BLOCK-SEQUENCE-START  *          BLOCK-ENTRY  *          BLOCK-SEQUENCE-START  *          BLOCK-ENTRY  *          SCALAR("item 1",plain)  *          BLOCK-ENTRY  *          SCALAR("item 2",plain)  *          BLOCK-END  *          BLOCK-ENTRY  *          BLOCK-MAPPING-START  *          KEY  *          SCALAR("key 1",plain)  *          VALUE  *          SCALAR("value 1",plain)  *          KEY  *          SCALAR("key 2",plain)  *          VALUE  *          SCALAR("value 2",plain)  *          BLOCK-END  *          BLOCK-ENTRY  *          BLOCK-MAPPING-START  *          KEY  *          SCALAR("complex key")  *          VALUE  *          SCALAR("complex value")  *          BLOCK-END  *          BLOCK-END  *          STREAM-END  *  *      2. Collections in a mapping:  *  *          ? a sequence  *          : - item 1  *            - item 2  *          ? a mapping  *          : key 1: value 1  *            key 2: value 2  *  *      Tokens:  *  *          STREAM-START(utf-8)  *          BLOCK-MAPPING-START  *          KEY  *          SCALAR("a sequence",plain)  *          VALUE  *          BLOCK-SEQUENCE-START  *          BLOCK-ENTRY  *          SCALAR("item 1",plain)  *          BLOCK-ENTRY  *          SCALAR("item 2",plain)  *          BLOCK-END  *          KEY  *          SCALAR("a mapping",plain)  *          VALUE  *          BLOCK-MAPPING-START  *          KEY  *          SCALAR("key 1",plain)  *          VALUE  *          SCALAR("value 1",plain)  *          KEY  *          SCALAR("key 2",plain)  *          VALUE  *          SCALAR("value 2",plain)  *          BLOCK-END  *          BLOCK-END  *          STREAM-END  *  * YAML also permits non-indented sequences if they are included into a block  * mapping.  In this case, the token BLOCK-SEQUENCE-START is not produced:  *  *      key:  *      - item 1    # BLOCK-SEQUENCE-START is NOT produced here.  *      - item 2  *  * Tokens:  *  *      STREAM-START(utf-8)  *      BLOCK-MAPPING-START  *      KEY  *      SCALAR("key",plain)  *      VALUE  *      BLOCK-ENTRY  *      SCALAR("item 1",plain)  *      BLOCK-ENTRY  *      SCALAR("item 2",plain)  *      BLOCK-END  */
end_comment

begin_include
include|#
directive|include
file|"yaml_private.h"
end_include

begin_comment
comment|/*  * Ensure that the buffer contains the required number of characters.  * Return 1 on success, 0 on failure (reader error or memory error).  */
end_comment

begin_define
define|#
directive|define
name|CACHE
parameter_list|(
name|parser
parameter_list|,
name|length
parameter_list|)
define|\
value|(parser->unread>= (length)                                                 \         ? 1                                                                     \         : yaml_parser_update_buffer(parser, (length)))
end_define

begin_comment
comment|/*  * Advance the buffer pointer.  */
end_comment

begin_define
define|#
directive|define
name|SKIP
parameter_list|(
name|parser
parameter_list|)
define|\
value|(parser->mark.index ++,                                                    \       parser->mark.column ++,                                                   \       parser->unread --,                                                        \       parser->buffer.pointer += WIDTH(parser->buffer))
end_define

begin_define
define|#
directive|define
name|SKIP_LINE
parameter_list|(
name|parser
parameter_list|)
define|\
value|(IS_CRLF(parser->buffer) ?                                                 \       (parser->mark.index += 2,                                                 \        parser->mark.column = 0,                                                 \        parser->mark.line ++,                                                    \        parser->unread -= 2,                                                     \        parser->buffer.pointer += 2) :                                           \       IS_BREAK(parser->buffer) ?                                                \       (parser->mark.index ++,                                                   \        parser->mark.column = 0,                                                 \        parser->mark.line ++,                                                    \        parser->unread --,                                                       \        parser->buffer.pointer += WIDTH(parser->buffer)) : 0)
end_define

begin_comment
comment|/*  * Copy a character to a string buffer and advance pointers.  */
end_comment

begin_define
define|#
directive|define
name|READ
parameter_list|(
name|parser
parameter_list|,
name|string
parameter_list|)
define|\
value|(STRING_EXTEND(parser,string) ?                                            \          (COPY(string,parser->buffer),                                          \           parser->mark.index ++,                                                \           parser->mark.column ++,                                               \           parser->unread --,                                                    \           1) : 0)
end_define

begin_comment
comment|/*  * Copy a line break character to a string buffer and advance pointers.  */
end_comment

begin_define
define|#
directive|define
name|READ_LINE
parameter_list|(
name|parser
parameter_list|,
name|string
parameter_list|)
define|\
value|(STRING_EXTEND(parser,string) ?                                             \     (((CHECK_AT(parser->buffer,'\r',0)                                          \&& CHECK_AT(parser->buffer,'\n',1)) ?
comment|/* CR LF -> LF */
value|\      (*((string).pointer++) = (yaml_char_t) '\n',                               \       parser->buffer.pointer += 2,                                              \       parser->mark.index += 2,                                                  \       parser->mark.column = 0,                                                  \       parser->mark.line ++,                                                     \       parser->unread -= 2) :                                                    \      (CHECK_AT(parser->buffer,'\r',0)                                           \       || CHECK_AT(parser->buffer,'\n',0)) ?
comment|/* CR|LF -> LF */
value|\      (*((string).pointer++) = (yaml_char_t) '\n',                               \       parser->buffer.pointer ++,                                                \       parser->mark.index ++,                                                    \       parser->mark.column = 0,                                                  \       parser->mark.line ++,                                                     \       parser->unread --) :                                                      \      (CHECK_AT(parser->buffer,'\xC2',0)                                         \&& CHECK_AT(parser->buffer,'\x85',1)) ?
comment|/* NEL -> LF */
value|\      (*((string).pointer++) = (yaml_char_t) '\n',                               \       parser->buffer.pointer += 2,                                              \       parser->mark.index ++,                                                    \       parser->mark.column = 0,                                                  \       parser->mark.line ++,                                                     \       parser->unread --) :                                                      \      (CHECK_AT(parser->buffer,'\xE2',0)&&                                      \       CHECK_AT(parser->buffer,'\x80',1)&&                                      \       (CHECK_AT(parser->buffer,'\xA8',2) ||                                     \        CHECK_AT(parser->buffer,'\xA9',2))) ?
comment|/* LS|PS -> LS|PS */
value|\      (*((string).pointer++) = *(parser->buffer.pointer++),                      \       *((string).pointer++) = *(parser->buffer.pointer++),                      \       *((string).pointer++) = *(parser->buffer.pointer++),                      \       parser->mark.index ++,                                                    \       parser->mark.column = 0,                                                  \       parser->mark.line ++,                                                     \       parser->unread --) : 0),                                                  \     1) : 0)
end_define

begin_comment
comment|/*  * Public API declarations.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_expr_stmt
name|yaml_parser_scan
argument_list|(
name|yaml_parser_t
operator|*
name|parser
argument_list|,
name|yaml_token_t
operator|*
name|token
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Error handling.  */
end_comment

begin_function_decl
specifier|static
name|int
name|yaml_parser_set_scanner_error
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|context
parameter_list|,
name|yaml_mark_t
name|context_mark
parameter_list|,
specifier|const
name|char
modifier|*
name|problem
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * High-level token API.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_expr_stmt
name|yaml_parser_fetch_more_tokens
argument_list|(
name|yaml_parser_t
operator|*
name|parser
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|yaml_parser_fetch_next_token
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Potential simple keys.  */
end_comment

begin_function_decl
specifier|static
name|int
name|yaml_parser_stale_simple_keys
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_save_simple_key
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_remove_simple_key
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_increase_flow_level
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_decrease_flow_level
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Indentation treatment.  */
end_comment

begin_function_decl
specifier|static
name|int
name|yaml_parser_roll_indent
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|size_t
name|column
parameter_list|,
name|int
name|number
parameter_list|,
name|yaml_token_type_t
name|type
parameter_list|,
name|yaml_mark_t
name|mark
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_unroll_indent
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|size_t
name|column
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_reset_indent
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Token fetchers.  */
end_comment

begin_function_decl
specifier|static
name|int
name|yaml_parser_fetch_stream_start
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_fetch_stream_end
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_fetch_directive
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_fetch_document_indicator
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_type_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_fetch_flow_collection_start
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_type_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_fetch_flow_collection_end
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_type_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_fetch_flow_entry
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_fetch_block_entry
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_fetch_key
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_fetch_value
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_fetch_anchor
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_type_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_fetch_tag
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_fetch_block_scalar
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|int
name|literal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_fetch_flow_scalar
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|int
name|single
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_fetch_plain_scalar
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Token scanners.  */
end_comment

begin_function_decl
specifier|static
name|int
name|yaml_parser_scan_to_next_token
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_scan_directive
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_t
modifier|*
name|token
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_scan_directive_name
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_mark_t
name|start_mark
parameter_list|,
name|yaml_char_t
modifier|*
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_scan_version_directive_value
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_mark_t
name|start_mark
parameter_list|,
name|int
modifier|*
name|major
parameter_list|,
name|int
modifier|*
name|minor
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_scan_version_directive_number
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_mark_t
name|start_mark
parameter_list|,
name|int
modifier|*
name|number
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_scan_tag_directive_value
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_mark_t
name|mark
parameter_list|,
name|yaml_char_t
modifier|*
modifier|*
name|handle
parameter_list|,
name|yaml_char_t
modifier|*
modifier|*
name|prefix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_scan_anchor
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_t
modifier|*
name|token
parameter_list|,
name|yaml_token_type_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_scan_tag
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_t
modifier|*
name|token
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_scan_tag_handle
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|int
name|directive
parameter_list|,
name|yaml_mark_t
name|start_mark
parameter_list|,
name|yaml_char_t
modifier|*
modifier|*
name|handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_scan_tag_uri
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|int
name|directive
parameter_list|,
name|yaml_char_t
modifier|*
name|head
parameter_list|,
name|yaml_mark_t
name|start_mark
parameter_list|,
name|yaml_char_t
modifier|*
modifier|*
name|uri
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_scan_uri_escapes
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|int
name|directive
parameter_list|,
name|yaml_mark_t
name|start_mark
parameter_list|,
name|yaml_string_t
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_scan_block_scalar
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_t
modifier|*
name|token
parameter_list|,
name|int
name|literal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_scan_block_scalar_breaks
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|int
modifier|*
name|indent
parameter_list|,
name|yaml_string_t
modifier|*
name|breaks
parameter_list|,
name|yaml_mark_t
name|start_mark
parameter_list|,
name|yaml_mark_t
modifier|*
name|end_mark
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_scan_flow_scalar
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_t
modifier|*
name|token
parameter_list|,
name|int
name|single
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yaml_parser_scan_plain_scalar
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_t
modifier|*
name|token
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Get the next token.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_parser_scan
argument_list|(
argument|yaml_parser_t *parser
argument_list|,
argument|yaml_token_t *token
argument_list|)
end_macro

begin_block
block|{
name|assert
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Non-NULL parser object is expected. */
name|assert
argument_list|(
name|token
argument_list|)
expr_stmt|;
comment|/* Non-NULL token object is expected. */
comment|/* Erase the token object. */
name|memset
argument_list|(
name|token
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|yaml_token_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No tokens after STREAM-END or error. */
if|if
condition|(
name|parser
operator|->
name|stream_end_produced
operator|||
name|parser
operator|->
name|error
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* Ensure that the tokens queue contains enough tokens. */
if|if
condition|(
operator|!
name|parser
operator|->
name|token_available
condition|)
block|{
if|if
condition|(
operator|!
name|yaml_parser_fetch_more_tokens
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Fetch the next token from the queue. */
operator|*
name|token
operator|=
name|DEQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|)
expr_stmt|;
name|parser
operator|->
name|token_available
operator|=
literal|0
expr_stmt|;
name|parser
operator|->
name|tokens_parsed
operator|++
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|YAML_STREAM_END_TOKEN
condition|)
block|{
name|parser
operator|->
name|stream_end_produced
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * Set the scanner error and return 0.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_set_scanner_error
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|context
parameter_list|,
name|yaml_mark_t
name|context_mark
parameter_list|,
specifier|const
name|char
modifier|*
name|problem
parameter_list|)
block|{
name|parser
operator|->
name|error
operator|=
name|YAML_SCANNER_ERROR
expr_stmt|;
name|parser
operator|->
name|context
operator|=
name|context
expr_stmt|;
name|parser
operator|->
name|context_mark
operator|=
name|context_mark
expr_stmt|;
name|parser
operator|->
name|problem
operator|=
name|problem
expr_stmt|;
name|parser
operator|->
name|problem_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Ensure that the tokens queue contains at least one token which can be  * returned to the Parser.  */
end_comment

begin_macro
name|YAML_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|yaml_parser_fetch_more_tokens
argument_list|(
argument|yaml_parser_t *parser
argument_list|)
end_macro

begin_block
block|{
name|int
name|need_more_tokens
decl_stmt|;
comment|/* While we need more tokens to fetch, do it. */
while|while
condition|(
literal|1
condition|)
block|{
comment|/*          * Check if we really need to fetch more tokens.          */
name|need_more_tokens
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|tokens
operator|.
name|head
operator|==
name|parser
operator|->
name|tokens
operator|.
name|tail
condition|)
block|{
comment|/* Queue is empty. */
name|need_more_tokens
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|yaml_simple_key_t
modifier|*
name|simple_key
decl_stmt|;
comment|/* Check if any potential simple key may occupy the head position. */
if|if
condition|(
operator|!
name|yaml_parser_stale_simple_keys
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|simple_key
operator|=
name|parser
operator|->
name|simple_keys
operator|.
name|start
init|;
name|simple_key
operator|!=
name|parser
operator|->
name|simple_keys
operator|.
name|top
condition|;
name|simple_key
operator|++
control|)
block|{
if|if
condition|(
name|simple_key
operator|->
name|possible
operator|&&
name|simple_key
operator|->
name|token_number
operator|==
name|parser
operator|->
name|tokens_parsed
condition|)
block|{
name|need_more_tokens
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* We are finished. */
if|if
condition|(
operator|!
name|need_more_tokens
condition|)
break|break;
comment|/* Fetch the next token. */
if|if
condition|(
operator|!
name|yaml_parser_fetch_next_token
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|parser
operator|->
name|token_available
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * The dispatcher for token fetchers.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_fetch_next_token
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Ensure that the buffer is initialized. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check if we just started scanning.  Fetch STREAM-START then. */
if|if
condition|(
operator|!
name|parser
operator|->
name|stream_start_produced
condition|)
return|return
name|yaml_parser_fetch_stream_start
argument_list|(
name|parser
argument_list|)
return|;
comment|/* Eat whitespaces and comments until we reach the next token. */
if|if
condition|(
operator|!
name|yaml_parser_scan_to_next_token
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Remove obsolete potential simple keys. */
if|if
condition|(
operator|!
name|yaml_parser_stale_simple_keys
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check the indentation level against the current column. */
if|if
condition|(
operator|!
name|yaml_parser_unroll_indent
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|mark
operator|.
name|column
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/*      * Ensure that the buffer contains at least 4 characters.  4 is the length      * of the longest indicators ('--- ' and '... ').      */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|4
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Is it the end of the stream? */
if|if
condition|(
name|IS_Z
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
return|return
name|yaml_parser_fetch_stream_end
argument_list|(
name|parser
argument_list|)
return|;
comment|/* Is it a directive? */
if|if
condition|(
name|parser
operator|->
name|mark
operator|.
name|column
operator|==
literal|0
operator|&&
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'%'
argument_list|)
condition|)
return|return
name|yaml_parser_fetch_directive
argument_list|(
name|parser
argument_list|)
return|;
comment|/* Is it the document start indicator? */
if|if
condition|(
name|parser
operator|->
name|mark
operator|.
name|column
operator|==
literal|0
operator|&&
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'-'
argument_list|,
literal|0
argument_list|)
operator|&&
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'-'
argument_list|,
literal|1
argument_list|)
operator|&&
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'-'
argument_list|,
literal|2
argument_list|)
operator|&&
name|IS_BLANKZ_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|yaml_parser_fetch_document_indicator
argument_list|(
name|parser
argument_list|,
name|YAML_DOCUMENT_START_TOKEN
argument_list|)
return|;
comment|/* Is it the document end indicator? */
if|if
condition|(
name|parser
operator|->
name|mark
operator|.
name|column
operator|==
literal|0
operator|&&
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'.'
argument_list|,
literal|0
argument_list|)
operator|&&
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'.'
argument_list|,
literal|1
argument_list|)
operator|&&
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'.'
argument_list|,
literal|2
argument_list|)
operator|&&
name|IS_BLANKZ_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|yaml_parser_fetch_document_indicator
argument_list|(
name|parser
argument_list|,
name|YAML_DOCUMENT_END_TOKEN
argument_list|)
return|;
comment|/* Is it the flow sequence start indicator? */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'['
argument_list|)
condition|)
return|return
name|yaml_parser_fetch_flow_collection_start
argument_list|(
name|parser
argument_list|,
name|YAML_FLOW_SEQUENCE_START_TOKEN
argument_list|)
return|;
comment|/* Is it the flow mapping start indicator? */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'{'
argument_list|)
condition|)
return|return
name|yaml_parser_fetch_flow_collection_start
argument_list|(
name|parser
argument_list|,
name|YAML_FLOW_MAPPING_START_TOKEN
argument_list|)
return|;
comment|/* Is it the flow sequence end indicator? */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|']'
argument_list|)
condition|)
return|return
name|yaml_parser_fetch_flow_collection_end
argument_list|(
name|parser
argument_list|,
name|YAML_FLOW_SEQUENCE_END_TOKEN
argument_list|)
return|;
comment|/* Is it the flow mapping end indicator? */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'}'
argument_list|)
condition|)
return|return
name|yaml_parser_fetch_flow_collection_end
argument_list|(
name|parser
argument_list|,
name|YAML_FLOW_MAPPING_END_TOKEN
argument_list|)
return|;
comment|/* Is it the flow entry indicator? */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|','
argument_list|)
condition|)
return|return
name|yaml_parser_fetch_flow_entry
argument_list|(
name|parser
argument_list|)
return|;
comment|/* Is it the block entry indicator? */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'-'
argument_list|)
operator|&&
name|IS_BLANKZ_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|yaml_parser_fetch_block_entry
argument_list|(
name|parser
argument_list|)
return|;
comment|/* Is it the key indicator? */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'?'
argument_list|)
operator|&&
operator|(
name|parser
operator|->
name|flow_level
operator|||
name|IS_BLANKZ_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|yaml_parser_fetch_key
argument_list|(
name|parser
argument_list|)
return|;
comment|/* Is it the value indicator? */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|':'
argument_list|)
operator|&&
operator|(
name|parser
operator|->
name|flow_level
operator|||
name|IS_BLANKZ_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|yaml_parser_fetch_value
argument_list|(
name|parser
argument_list|)
return|;
comment|/* Is it an alias? */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'*'
argument_list|)
condition|)
return|return
name|yaml_parser_fetch_anchor
argument_list|(
name|parser
argument_list|,
name|YAML_ALIAS_TOKEN
argument_list|)
return|;
comment|/* Is it an anchor? */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'&'
argument_list|)
condition|)
return|return
name|yaml_parser_fetch_anchor
argument_list|(
name|parser
argument_list|,
name|YAML_ANCHOR_TOKEN
argument_list|)
return|;
comment|/* Is it a tag? */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'!'
argument_list|)
condition|)
return|return
name|yaml_parser_fetch_tag
argument_list|(
name|parser
argument_list|)
return|;
comment|/* Is it a literal scalar? */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'|'
argument_list|)
operator|&&
operator|!
name|parser
operator|->
name|flow_level
condition|)
return|return
name|yaml_parser_fetch_block_scalar
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
return|;
comment|/* Is it a folded scalar? */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'>'
argument_list|)
operator|&&
operator|!
name|parser
operator|->
name|flow_level
condition|)
return|return
name|yaml_parser_fetch_block_scalar
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Is it a single-quoted scalar? */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'\''
argument_list|)
condition|)
return|return
name|yaml_parser_fetch_flow_scalar
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
return|;
comment|/* Is it a double-quoted scalar? */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'"'
argument_list|)
condition|)
return|return
name|yaml_parser_fetch_flow_scalar
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|)
return|;
comment|/*      * Is it a plain scalar?      *      * A plain scalar may start with any non-blank characters except      *      *      '-', '?', ':', ',', '[', ']', '{', '}',      *      '#', '&', '*', '!', '|', '>', '\'', '\"',      *      '%', '@', '`'.      *      * In the block context (and, for the '-' indicator, in the flow context      * too), it may also start with the characters      *      *      '-', '?', ':'      *      * if it is followed by a non-space character.      *      * The last rule is more restrictive than the specification requires.      */
if|if
condition|(
operator|!
operator|(
name|IS_BLANKZ
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'-'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'?'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|':'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|','
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'['
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|']'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'{'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'}'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'#'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'&'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'*'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'!'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'|'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'>'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'\''
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'"'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'%'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'@'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'`'
argument_list|)
operator|)
operator|||
operator|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'-'
argument_list|)
operator|&&
operator|!
name|IS_BLANK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|1
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|parser
operator|->
name|flow_level
operator|&&
operator|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'?'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|':'
argument_list|)
operator|)
operator|&&
operator|!
name|IS_BLANKZ_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|yaml_parser_fetch_plain_scalar
argument_list|(
name|parser
argument_list|)
return|;
comment|/*      * If we don't determine the token type so far, it is an error.      */
return|return
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning for the next token"
argument_list|,
name|parser
operator|->
name|mark
argument_list|,
literal|"found character that cannot start any token"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check the list of potential simple keys and remove the positions that  * cannot contain simple keys anymore.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_stale_simple_keys
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
block|{
name|yaml_simple_key_t
modifier|*
name|simple_key
decl_stmt|;
comment|/* Check for a potential simple key for each flow level. */
for|for
control|(
name|simple_key
operator|=
name|parser
operator|->
name|simple_keys
operator|.
name|start
init|;
name|simple_key
operator|!=
name|parser
operator|->
name|simple_keys
operator|.
name|top
condition|;
name|simple_key
operator|++
control|)
block|{
comment|/*          * The specification requires that a simple key          *          *  - is limited to a single line,          *  - is shorter than 1024 characters.          */
if|if
condition|(
name|simple_key
operator|->
name|possible
operator|&&
operator|(
name|simple_key
operator|->
name|mark
operator|.
name|line
operator|<
name|parser
operator|->
name|mark
operator|.
name|line
operator|||
name|simple_key
operator|->
name|mark
operator|.
name|index
operator|+
literal|1024
operator|<
name|parser
operator|->
name|mark
operator|.
name|index
operator|)
condition|)
block|{
comment|/* Check if the potential simple key to be removed is required. */
if|if
condition|(
name|simple_key
operator|->
name|required
condition|)
block|{
return|return
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a simple key"
argument_list|,
name|simple_key
operator|->
name|mark
argument_list|,
literal|"could not find expected ':'"
argument_list|)
return|;
block|}
name|simple_key
operator|->
name|possible
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Check if a simple key may start at the current position and add it if  * needed.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_save_simple_key
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
block|{
comment|/*      * A simple key is required at the current position if the scanner is in      * the block context and the current column coincides with the indentation      * level.      */
name|int
name|required
init|=
operator|(
operator|!
name|parser
operator|->
name|flow_level
operator|&&
name|parser
operator|->
name|indent
operator|==
operator|(
name|int
operator|)
name|parser
operator|->
name|mark
operator|.
name|column
operator|)
decl_stmt|;
comment|/*      * A simple key is required only when it is the first token in the current      * line.  Therefore it is always allowed.  But we add a check anyway.      */
name|assert
argument_list|(
name|parser
operator|->
name|simple_key_allowed
operator|||
operator|!
name|required
argument_list|)
expr_stmt|;
comment|/* Impossible. */
comment|/*      * If the current position may start a simple key, save it.      */
if|if
condition|(
name|parser
operator|->
name|simple_key_allowed
condition|)
block|{
name|yaml_simple_key_t
name|simple_key
decl_stmt|;
name|simple_key
operator|.
name|possible
operator|=
literal|1
expr_stmt|;
name|simple_key
operator|.
name|required
operator|=
name|required
expr_stmt|;
name|simple_key
operator|.
name|token_number
operator|=
name|parser
operator|->
name|tokens_parsed
operator|+
operator|(
name|parser
operator|->
name|tokens
operator|.
name|tail
operator|-
name|parser
operator|->
name|tokens
operator|.
name|head
operator|)
expr_stmt|;
name|simple_key
operator|.
name|mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
if|if
condition|(
operator|!
name|yaml_parser_remove_simple_key
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
operator|(
name|parser
operator|->
name|simple_keys
operator|.
name|top
operator|-
literal|1
operator|)
operator|=
name|simple_key
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a potential simple key at the current flow level.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_remove_simple_key
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
block|{
name|yaml_simple_key_t
modifier|*
name|simple_key
init|=
name|parser
operator|->
name|simple_keys
operator|.
name|top
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|simple_key
operator|->
name|possible
condition|)
block|{
comment|/* If the key is required, it is an error. */
if|if
condition|(
name|simple_key
operator|->
name|required
condition|)
block|{
return|return
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a simple key"
argument_list|,
name|simple_key
operator|->
name|mark
argument_list|,
literal|"could not find expected ':'"
argument_list|)
return|;
block|}
block|}
comment|/* Remove the key from the stack. */
name|simple_key
operator|->
name|possible
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Increase the flow level and resize the simple key list if needed.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_increase_flow_level
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
block|{
name|yaml_simple_key_t
name|empty_simple_key
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
comment|/* Reset the simple key on the next level. */
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|simple_keys
argument_list|,
name|empty_simple_key
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Increase the flow level. */
name|parser
operator|->
name|flow_level
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Decrease the flow level.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_decrease_flow_level
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
block|{
name|yaml_simple_key_t
name|dummy_key
decl_stmt|;
comment|/* Used to eliminate a compiler warning. */
if|if
condition|(
name|parser
operator|->
name|flow_level
condition|)
block|{
name|parser
operator|->
name|flow_level
operator|--
expr_stmt|;
name|dummy_key
operator|=
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|simple_keys
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Push the current indentation level to the stack and set the new level  * the current column is greater than the indentation level.  In this case,  * append or insert the specified token into the token queue.  *   */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_roll_indent
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|size_t
name|column
parameter_list|,
name|int
name|number
parameter_list|,
name|yaml_token_type_t
name|type
parameter_list|,
name|yaml_mark_t
name|mark
parameter_list|)
block|{
name|yaml_token_t
name|token
decl_stmt|;
comment|/* In the flow context, do nothing. */
if|if
condition|(
name|parser
operator|->
name|flow_level
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|parser
operator|->
name|indent
operator|==
operator|-
literal|1
operator|||
name|parser
operator|->
name|indent
operator|<
name|column
condition|)
block|{
comment|/*          * Push the current indentation level to the stack and set the new          * indentation level.          */
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|indents
argument_list|,
name|parser
operator|->
name|indent
argument_list|)
condition|)
return|return
literal|0
return|;
name|parser
operator|->
name|indent
operator|=
name|column
expr_stmt|;
comment|/* Create a token and insert it into the queue. */
name|TOKEN_INIT
argument_list|(
name|token
argument_list|,
name|type
argument_list|,
name|mark
argument_list|,
name|mark
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|ENQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|token
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|QUEUE_INSERT
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|number
operator|-
name|parser
operator|->
name|tokens_parsed
argument_list|,
name|token
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Pop indentation levels from the indents stack until the current level  * becomes less or equal to the column.  For each intendation level, append  * the BLOCK-END token.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_unroll_indent
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|size_t
name|column
parameter_list|)
block|{
name|yaml_token_t
name|token
decl_stmt|;
comment|/* In the flow context, do nothing. */
if|if
condition|(
name|parser
operator|->
name|flow_level
condition|)
return|return
literal|1
return|;
comment|/*      * column is unsigned and parser->indent is signed, so if      * parser->indent is less than zero the conditional in the while      * loop below is incorrect.  Guard against that.      */
if|if
condition|(
name|parser
operator|->
name|indent
operator|<
literal|0
condition|)
return|return
literal|1
return|;
comment|/* Loop through the intendation levels in the stack. */
while|while
condition|(
name|parser
operator|->
name|indent
operator|>
name|column
condition|)
block|{
comment|/* Create a token and append it to the queue. */
name|TOKEN_INIT
argument_list|(
name|token
argument_list|,
name|YAML_BLOCK_END_TOKEN
argument_list|,
name|parser
operator|->
name|mark
argument_list|,
name|parser
operator|->
name|mark
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ENQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|token
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Pop the indentation level. */
name|parser
operator|->
name|indent
operator|=
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|indents
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Pop indentation levels from the indents stack until the current  * level resets to -1.  For each intendation level, append the  * BLOCK-END token.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_reset_indent
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
block|{
name|yaml_token_t
name|token
decl_stmt|;
comment|/* In the flow context, do nothing. */
if|if
condition|(
name|parser
operator|->
name|flow_level
condition|)
return|return
literal|1
return|;
comment|/* Loop through the intendation levels in the stack. */
while|while
condition|(
name|parser
operator|->
name|indent
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* Create a token and append it to the queue. */
name|TOKEN_INIT
argument_list|(
name|token
argument_list|,
name|YAML_BLOCK_END_TOKEN
argument_list|,
name|parser
operator|->
name|mark
argument_list|,
name|parser
operator|->
name|mark
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ENQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|token
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Pop the indentation level. */
name|parser
operator|->
name|indent
operator|=
name|POP
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|indents
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the scanner and produce the STREAM-START token.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_fetch_stream_start
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
block|{
name|yaml_simple_key_t
name|simple_key
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|yaml_token_t
name|token
decl_stmt|;
comment|/* Set the initial indentation. */
name|parser
operator|->
name|indent
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Initialize the simple key stack. */
if|if
condition|(
operator|!
name|PUSH
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|simple_keys
argument_list|,
name|simple_key
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* A simple key is allowed at the beginning of the stream. */
name|parser
operator|->
name|simple_key_allowed
operator|=
literal|1
expr_stmt|;
comment|/* We have started. */
name|parser
operator|->
name|stream_start_produced
operator|=
literal|1
expr_stmt|;
comment|/* Create the STREAM-START token and append it to the queue. */
name|STREAM_START_TOKEN_INIT
argument_list|(
name|token
argument_list|,
name|parser
operator|->
name|encoding
argument_list|,
name|parser
operator|->
name|mark
argument_list|,
name|parser
operator|->
name|mark
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ENQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|token
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Produce the STREAM-END token and shut down the scanner.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_fetch_stream_end
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
block|{
name|yaml_token_t
name|token
decl_stmt|;
comment|/* Force new line. */
if|if
condition|(
name|parser
operator|->
name|mark
operator|.
name|column
operator|!=
literal|0
condition|)
block|{
name|parser
operator|->
name|mark
operator|.
name|column
operator|=
literal|0
expr_stmt|;
name|parser
operator|->
name|mark
operator|.
name|line
operator|++
expr_stmt|;
block|}
comment|/* Reset the indentation level. */
if|if
condition|(
operator|!
name|yaml_parser_reset_indent
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Reset simple keys. */
if|if
condition|(
operator|!
name|yaml_parser_remove_simple_key
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
name|parser
operator|->
name|simple_key_allowed
operator|=
literal|0
expr_stmt|;
comment|/* Create the STREAM-END token and append it to the queue. */
name|STREAM_END_TOKEN_INIT
argument_list|(
name|token
argument_list|,
name|parser
operator|->
name|mark
argument_list|,
name|parser
operator|->
name|mark
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ENQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|token
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Produce a VERSION-DIRECTIVE or TAG-DIRECTIVE token.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_fetch_directive
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
block|{
name|yaml_token_t
name|token
decl_stmt|;
comment|/* Reset the indentation level. */
if|if
condition|(
operator|!
name|yaml_parser_reset_indent
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Reset simple keys. */
if|if
condition|(
operator|!
name|yaml_parser_remove_simple_key
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
name|parser
operator|->
name|simple_key_allowed
operator|=
literal|0
expr_stmt|;
comment|/* Create the YAML-DIRECTIVE or TAG-DIRECTIVE token. */
if|if
condition|(
operator|!
name|yaml_parser_scan_directive
argument_list|(
name|parser
argument_list|,
operator|&
name|token
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Append the token to the queue. */
if|if
condition|(
operator|!
name|ENQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|token
argument_list|)
condition|)
block|{
name|yaml_token_delete
argument_list|(
operator|&
name|token
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Produce the DOCUMENT-START or DOCUMENT-END token.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_fetch_document_indicator
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_type_t
name|type
parameter_list|)
block|{
name|yaml_mark_t
name|start_mark
decl_stmt|,
name|end_mark
decl_stmt|;
name|yaml_token_t
name|token
decl_stmt|;
comment|/* Reset the indentation level. */
if|if
condition|(
operator|!
name|yaml_parser_reset_indent
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Reset simple keys. */
if|if
condition|(
operator|!
name|yaml_parser_remove_simple_key
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
name|parser
operator|->
name|simple_key_allowed
operator|=
literal|0
expr_stmt|;
comment|/* Consume the token. */
name|start_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|end_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
comment|/* Create the DOCUMENT-START or DOCUMENT-END token. */
name|TOKEN_INIT
argument_list|(
name|token
argument_list|,
name|type
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
comment|/* Append the token to the queue. */
if|if
condition|(
operator|!
name|ENQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|token
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Produce the FLOW-SEQUENCE-START or FLOW-MAPPING-START token.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_fetch_flow_collection_start
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_type_t
name|type
parameter_list|)
block|{
name|yaml_mark_t
name|start_mark
decl_stmt|,
name|end_mark
decl_stmt|;
name|yaml_token_t
name|token
decl_stmt|;
comment|/* The indicators '[' and '{' may start a simple key. */
if|if
condition|(
operator|!
name|yaml_parser_save_simple_key
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Increase the flow level. */
if|if
condition|(
operator|!
name|yaml_parser_increase_flow_level
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* A simple key may follow the indicators '[' and '{'. */
name|parser
operator|->
name|simple_key_allowed
operator|=
literal|1
expr_stmt|;
comment|/* Consume the token. */
name|start_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|end_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
comment|/* Create the FLOW-SEQUENCE-START of FLOW-MAPPING-START token. */
name|TOKEN_INIT
argument_list|(
name|token
argument_list|,
name|type
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
comment|/* Append the token to the queue. */
if|if
condition|(
operator|!
name|ENQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|token
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Produce the FLOW-SEQUENCE-END or FLOW-MAPPING-END token.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_fetch_flow_collection_end
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_type_t
name|type
parameter_list|)
block|{
name|yaml_mark_t
name|start_mark
decl_stmt|,
name|end_mark
decl_stmt|;
name|yaml_token_t
name|token
decl_stmt|;
comment|/* Reset any potential simple key on the current flow level. */
if|if
condition|(
operator|!
name|yaml_parser_remove_simple_key
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Decrease the flow level. */
if|if
condition|(
operator|!
name|yaml_parser_decrease_flow_level
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* No simple keys after the indicators ']' and '}'. */
name|parser
operator|->
name|simple_key_allowed
operator|=
literal|0
expr_stmt|;
comment|/* Consume the token. */
name|start_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|end_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
comment|/* Create the FLOW-SEQUENCE-END of FLOW-MAPPING-END token. */
name|TOKEN_INIT
argument_list|(
name|token
argument_list|,
name|type
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
comment|/* Append the token to the queue. */
if|if
condition|(
operator|!
name|ENQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|token
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Produce the FLOW-ENTRY token.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_fetch_flow_entry
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
block|{
name|yaml_mark_t
name|start_mark
decl_stmt|,
name|end_mark
decl_stmt|;
name|yaml_token_t
name|token
decl_stmt|;
comment|/* Reset any potential simple keys on the current flow level. */
if|if
condition|(
operator|!
name|yaml_parser_remove_simple_key
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Simple keys are allowed after ','. */
name|parser
operator|->
name|simple_key_allowed
operator|=
literal|1
expr_stmt|;
comment|/* Consume the token. */
name|start_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|end_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
comment|/* Create the FLOW-ENTRY token and append it to the queue. */
name|TOKEN_INIT
argument_list|(
name|token
argument_list|,
name|YAML_FLOW_ENTRY_TOKEN
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ENQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|token
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Produce the BLOCK-ENTRY token.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_fetch_block_entry
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
block|{
name|yaml_mark_t
name|start_mark
decl_stmt|,
name|end_mark
decl_stmt|;
name|yaml_token_t
name|token
decl_stmt|;
comment|/* Check if the scanner is in the block context. */
if|if
condition|(
operator|!
name|parser
operator|->
name|flow_level
condition|)
block|{
comment|/* Check if we are allowed to start a new entry. */
if|if
condition|(
operator|!
name|parser
operator|->
name|simple_key_allowed
condition|)
block|{
return|return
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|,
name|parser
operator|->
name|mark
argument_list|,
literal|"block sequence entries are not allowed in this context"
argument_list|)
return|;
block|}
comment|/* Add the BLOCK-SEQUENCE-START token if needed. */
if|if
condition|(
operator|!
name|yaml_parser_roll_indent
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|mark
operator|.
name|column
argument_list|,
operator|-
literal|1
argument_list|,
name|YAML_BLOCK_SEQUENCE_START_TOKEN
argument_list|,
name|parser
operator|->
name|mark
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/*          * It is an error for the '-' indicator to occur in the flow context,          * but we let the Parser detect and report about it because the Parser          * is able to point to the context.          */
block|}
comment|/* Reset any potential simple keys on the current flow level. */
if|if
condition|(
operator|!
name|yaml_parser_remove_simple_key
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Simple keys are allowed after '-'. */
name|parser
operator|->
name|simple_key_allowed
operator|=
literal|1
expr_stmt|;
comment|/* Consume the token. */
name|start_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|end_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
comment|/* Create the BLOCK-ENTRY token and append it to the queue. */
name|TOKEN_INIT
argument_list|(
name|token
argument_list|,
name|YAML_BLOCK_ENTRY_TOKEN
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ENQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|token
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Produce the KEY token.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_fetch_key
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
block|{
name|yaml_mark_t
name|start_mark
decl_stmt|,
name|end_mark
decl_stmt|;
name|yaml_token_t
name|token
decl_stmt|;
comment|/* In the block context, additional checks are required. */
if|if
condition|(
operator|!
name|parser
operator|->
name|flow_level
condition|)
block|{
comment|/* Check if we are allowed to start a new key (not nessesary simple). */
if|if
condition|(
operator|!
name|parser
operator|->
name|simple_key_allowed
condition|)
block|{
return|return
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|,
name|parser
operator|->
name|mark
argument_list|,
literal|"mapping keys are not allowed in this context"
argument_list|)
return|;
block|}
comment|/* Add the BLOCK-MAPPING-START token if needed. */
if|if
condition|(
operator|!
name|yaml_parser_roll_indent
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|mark
operator|.
name|column
argument_list|,
operator|-
literal|1
argument_list|,
name|YAML_BLOCK_MAPPING_START_TOKEN
argument_list|,
name|parser
operator|->
name|mark
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Reset any potential simple keys on the current flow level. */
if|if
condition|(
operator|!
name|yaml_parser_remove_simple_key
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Simple keys are allowed after '?' in the block context. */
name|parser
operator|->
name|simple_key_allowed
operator|=
operator|(
operator|!
name|parser
operator|->
name|flow_level
operator|)
expr_stmt|;
comment|/* Consume the token. */
name|start_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|end_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
comment|/* Create the KEY token and append it to the queue. */
name|TOKEN_INIT
argument_list|(
name|token
argument_list|,
name|YAML_KEY_TOKEN
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ENQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|token
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Produce the VALUE token.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_fetch_value
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
block|{
name|yaml_mark_t
name|start_mark
decl_stmt|,
name|end_mark
decl_stmt|;
name|yaml_token_t
name|token
decl_stmt|;
name|yaml_simple_key_t
modifier|*
name|simple_key
init|=
name|parser
operator|->
name|simple_keys
operator|.
name|top
operator|-
literal|1
decl_stmt|;
comment|/* Have we found a simple key? */
if|if
condition|(
name|simple_key
operator|->
name|possible
condition|)
block|{
comment|/* Create the KEY token and insert it into the queue. */
name|TOKEN_INIT
argument_list|(
name|token
argument_list|,
name|YAML_KEY_TOKEN
argument_list|,
name|simple_key
operator|->
name|mark
argument_list|,
name|simple_key
operator|->
name|mark
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QUEUE_INSERT
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|simple_key
operator|->
name|token_number
operator|-
name|parser
operator|->
name|tokens_parsed
argument_list|,
name|token
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* In the block context, we may need to add the BLOCK-MAPPING-START token. */
if|if
condition|(
operator|!
name|yaml_parser_roll_indent
argument_list|(
name|parser
argument_list|,
name|simple_key
operator|->
name|mark
operator|.
name|column
argument_list|,
name|simple_key
operator|->
name|token_number
argument_list|,
name|YAML_BLOCK_MAPPING_START_TOKEN
argument_list|,
name|simple_key
operator|->
name|mark
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Remove the simple key. */
name|simple_key
operator|->
name|possible
operator|=
literal|0
expr_stmt|;
comment|/* A simple key cannot follow another simple key. */
name|parser
operator|->
name|simple_key_allowed
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* The ':' indicator follows a complex key. */
comment|/* In the block context, extra checks are required. */
if|if
condition|(
operator|!
name|parser
operator|->
name|flow_level
condition|)
block|{
comment|/* Check if we are allowed to start a complex value. */
if|if
condition|(
operator|!
name|parser
operator|->
name|simple_key_allowed
condition|)
block|{
return|return
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|,
name|parser
operator|->
name|mark
argument_list|,
literal|"mapping values are not allowed in this context"
argument_list|)
return|;
block|}
comment|/* Add the BLOCK-MAPPING-START token if needed. */
if|if
condition|(
operator|!
name|yaml_parser_roll_indent
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|mark
operator|.
name|column
argument_list|,
operator|-
literal|1
argument_list|,
name|YAML_BLOCK_MAPPING_START_TOKEN
argument_list|,
name|parser
operator|->
name|mark
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Simple keys after ':' are allowed in the block context. */
name|parser
operator|->
name|simple_key_allowed
operator|=
operator|(
operator|!
name|parser
operator|->
name|flow_level
operator|)
expr_stmt|;
block|}
comment|/* Consume the token. */
name|start_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|end_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
comment|/* Create the VALUE token and append it to the queue. */
name|TOKEN_INIT
argument_list|(
name|token
argument_list|,
name|YAML_VALUE_TOKEN
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ENQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|token
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Produce the ALIAS or ANCHOR token.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_fetch_anchor
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_type_t
name|type
parameter_list|)
block|{
name|yaml_token_t
name|token
decl_stmt|;
comment|/* An anchor or an alias could be a simple key. */
if|if
condition|(
operator|!
name|yaml_parser_save_simple_key
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* A simple key cannot follow an anchor or an alias. */
name|parser
operator|->
name|simple_key_allowed
operator|=
literal|0
expr_stmt|;
comment|/* Create the ALIAS or ANCHOR token and append it to the queue. */
if|if
condition|(
operator|!
name|yaml_parser_scan_anchor
argument_list|(
name|parser
argument_list|,
operator|&
name|token
argument_list|,
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ENQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|token
argument_list|)
condition|)
block|{
name|yaml_token_delete
argument_list|(
operator|&
name|token
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Produce the TAG token.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_fetch_tag
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
block|{
name|yaml_token_t
name|token
decl_stmt|;
comment|/* A tag could be a simple key. */
if|if
condition|(
operator|!
name|yaml_parser_save_simple_key
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* A simple key cannot follow a tag. */
name|parser
operator|->
name|simple_key_allowed
operator|=
literal|0
expr_stmt|;
comment|/* Create the TAG token and append it to the queue. */
if|if
condition|(
operator|!
name|yaml_parser_scan_tag
argument_list|(
name|parser
argument_list|,
operator|&
name|token
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ENQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|token
argument_list|)
condition|)
block|{
name|yaml_token_delete
argument_list|(
operator|&
name|token
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Produce the SCALAR(...,literal) or SCALAR(...,folded) tokens.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_fetch_block_scalar
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|int
name|literal
parameter_list|)
block|{
name|yaml_token_t
name|token
decl_stmt|;
comment|/* Remove any potential simple keys. */
if|if
condition|(
operator|!
name|yaml_parser_remove_simple_key
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* A simple key may follow a block scalar. */
name|parser
operator|->
name|simple_key_allowed
operator|=
literal|1
expr_stmt|;
comment|/* Create the SCALAR token and append it to the queue. */
if|if
condition|(
operator|!
name|yaml_parser_scan_block_scalar
argument_list|(
name|parser
argument_list|,
operator|&
name|token
argument_list|,
name|literal
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ENQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|token
argument_list|)
condition|)
block|{
name|yaml_token_delete
argument_list|(
operator|&
name|token
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Produce the SCALAR(...,single-quoted) or SCALAR(...,double-quoted) tokens.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_fetch_flow_scalar
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|int
name|single
parameter_list|)
block|{
name|yaml_token_t
name|token
decl_stmt|;
comment|/* A plain scalar could be a simple key. */
if|if
condition|(
operator|!
name|yaml_parser_save_simple_key
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* A simple key cannot follow a flow scalar. */
name|parser
operator|->
name|simple_key_allowed
operator|=
literal|0
expr_stmt|;
comment|/* Create the SCALAR token and append it to the queue. */
if|if
condition|(
operator|!
name|yaml_parser_scan_flow_scalar
argument_list|(
name|parser
argument_list|,
operator|&
name|token
argument_list|,
name|single
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ENQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|token
argument_list|)
condition|)
block|{
name|yaml_token_delete
argument_list|(
operator|&
name|token
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Produce the SCALAR(...,plain) token.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_fetch_plain_scalar
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
block|{
name|yaml_token_t
name|token
decl_stmt|;
comment|/* A plain scalar could be a simple key. */
if|if
condition|(
operator|!
name|yaml_parser_save_simple_key
argument_list|(
name|parser
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* A simple key cannot follow a flow scalar. */
name|parser
operator|->
name|simple_key_allowed
operator|=
literal|0
expr_stmt|;
comment|/* Create the SCALAR token and append it to the queue. */
if|if
condition|(
operator|!
name|yaml_parser_scan_plain_scalar
argument_list|(
name|parser
argument_list|,
operator|&
name|token
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ENQUEUE
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|tokens
argument_list|,
name|token
argument_list|)
condition|)
block|{
name|yaml_token_delete
argument_list|(
operator|&
name|token
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Eat whitespaces and comments until the next token is found.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_scan_to_next_token
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Until the next token is not found. */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Allow the BOM mark to start a line. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|parser
operator|->
name|mark
operator|.
name|column
operator|==
literal|0
operator|&&
name|IS_BOM
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/*          * Eat whitespaces.          *          * Tabs are allowed:          *          *  - in the flow context;          *  - in the block context, but not at the beginning of the line or          *  after '-', '?', or ':' (complex value).            */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|' '
argument_list|)
operator|||
operator|(
operator|(
name|parser
operator|->
name|flow_level
operator|||
operator|!
name|parser
operator|->
name|simple_key_allowed
operator|)
operator|&&
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'\t'
argument_list|)
operator|)
condition|)
block|{
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Eat a comment until a line break. */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'#'
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|IS_BREAKZ
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
comment|/* If it is a line break, eat it. */
if|if
condition|(
name|IS_BREAK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|2
argument_list|)
condition|)
return|return
literal|0
return|;
name|SKIP_LINE
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* In the block context, a new line may start a simple key. */
if|if
condition|(
operator|!
name|parser
operator|->
name|flow_level
condition|)
block|{
name|parser
operator|->
name|simple_key_allowed
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We have found a token. */
break|break;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Scan a YAML-DIRECTIVE or TAG-DIRECTIVE token.  *  * Scope:  *      %YAML    1.1    # a comment \n  *      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  *      %TAG    !yaml!  tag:yaml.org,2002:  \n  *      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  */
end_comment

begin_function
name|int
name|yaml_parser_scan_directive
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_t
modifier|*
name|token
parameter_list|)
block|{
name|yaml_mark_t
name|start_mark
decl_stmt|,
name|end_mark
decl_stmt|;
name|yaml_char_t
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|;
name|yaml_char_t
modifier|*
name|handle
init|=
name|NULL
decl_stmt|,
modifier|*
name|prefix
init|=
name|NULL
decl_stmt|;
comment|/* Eat '%'. */
name|start_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Scan the directive name. */
if|if
condition|(
operator|!
name|yaml_parser_scan_directive_name
argument_list|(
name|parser
argument_list|,
name|start_mark
argument_list|,
operator|&
name|name
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Is it a YAML directive? */
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
literal|"YAML"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Scan the VERSION directive value. */
if|if
condition|(
operator|!
name|yaml_parser_scan_version_directive_value
argument_list|(
name|parser
argument_list|,
name|start_mark
argument_list|,
operator|&
name|major
argument_list|,
operator|&
name|minor
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|end_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
comment|/* Create a VERSION-DIRECTIVE token. */
name|VERSION_DIRECTIVE_TOKEN_INIT
argument_list|(
operator|*
name|token
argument_list|,
name|major
argument_list|,
name|minor
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
block|}
comment|/* Is it a TAG directive? */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
literal|"TAG"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Scan the TAG directive value. */
if|if
condition|(
operator|!
name|yaml_parser_scan_tag_directive_value
argument_list|(
name|parser
argument_list|,
name|start_mark
argument_list|,
operator|&
name|handle
argument_list|,
operator|&
name|prefix
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|end_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
comment|/* Create a TAG-DIRECTIVE token. */
name|TAG_DIRECTIVE_TOKEN_INIT
argument_list|(
operator|*
name|token
argument_list|,
name|handle
argument_list|,
name|prefix
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
block|}
comment|/* Unknown directive. */
else|else
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a directive"
argument_list|,
name|start_mark
argument_list|,
literal|"found uknown directive name"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Eat the rest of the line including any comments. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
while|while
condition|(
name|IS_BLANK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'#'
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|IS_BREAKZ
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
block|}
comment|/* Check if we are at the end of the line. */
if|if
condition|(
operator|!
name|IS_BREAKZ
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a directive"
argument_list|,
name|start_mark
argument_list|,
literal|"did not find expected comment or line break"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Eat a line break. */
if|if
condition|(
name|IS_BREAK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|SKIP_LINE
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|yaml_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|error
label|:
name|yaml_free
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Scan the directive name.  *  * Scope:  *      %YAML   1.1     # a comment \n  *       ^^^^  *      %TAG    !yaml!  tag:yaml.org,2002:  \n  *       ^^^  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_scan_directive_name
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_mark_t
name|start_mark
parameter_list|,
name|yaml_char_t
modifier|*
modifier|*
name|name
parameter_list|)
block|{
name|yaml_string_t
name|string
init|=
name|NULL_STRING
decl_stmt|;
if|if
condition|(
operator|!
name|STRING_INIT
argument_list|(
name|parser
argument_list|,
name|string
argument_list|,
name|INITIAL_STRING_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Consume the directive name. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
while|while
condition|(
name|IS_ALPHA
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|READ
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* Check if the name is empty. */
if|if
condition|(
name|string
operator|.
name|start
operator|==
name|string
operator|.
name|pointer
condition|)
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a directive"
argument_list|,
name|start_mark
argument_list|,
literal|"could not find expected directive name"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Check for an blank character after the name. */
if|if
condition|(
operator|!
name|IS_BLANKZ
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a directive"
argument_list|,
name|start_mark
argument_list|,
literal|"found unexpected non-alphabetical character"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|name
operator|=
name|string
operator|.
name|start
expr_stmt|;
return|return
literal|1
return|;
name|error
label|:
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Scan the value of VERSION-DIRECTIVE.  *  * Scope:  *      %YAML   1.1     # a comment \n  *           ^^^^^^  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_scan_version_directive_value
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_mark_t
name|start_mark
parameter_list|,
name|int
modifier|*
name|major
parameter_list|,
name|int
modifier|*
name|minor
parameter_list|)
block|{
comment|/* Eat whitespaces. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|IS_BLANK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Consume the major version number. */
if|if
condition|(
operator|!
name|yaml_parser_scan_version_directive_number
argument_list|(
name|parser
argument_list|,
name|start_mark
argument_list|,
name|major
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Eat '.'. */
if|if
condition|(
operator|!
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
return|return
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a %YAML directive"
argument_list|,
name|start_mark
argument_list|,
literal|"did not find expected digit or '.' character"
argument_list|)
return|;
block|}
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Consume the minor version number. */
if|if
condition|(
operator|!
name|yaml_parser_scan_version_directive_number
argument_list|(
name|parser
argument_list|,
name|start_mark
argument_list|,
name|minor
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_NUMBER_LENGTH
value|9
end_define

begin_comment
comment|/*  * Scan the version number of VERSION-DIRECTIVE.  *  * Scope:  *      %YAML   1.1     # a comment \n  *              ^  *      %YAML   1.1     # a comment \n  *                ^  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_scan_version_directive_number
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_mark_t
name|start_mark
parameter_list|,
name|int
modifier|*
name|number
parameter_list|)
block|{
name|int
name|value
init|=
literal|0
decl_stmt|;
name|size_t
name|length
init|=
literal|0
decl_stmt|;
comment|/* Repeat while the next character is digit. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|IS_DIGIT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
comment|/* Check if the number is too long. */
if|if
condition|(
operator|++
name|length
operator|>
name|MAX_NUMBER_LENGTH
condition|)
block|{
return|return
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a %YAML directive"
argument_list|,
name|start_mark
argument_list|,
literal|"found extremely long version number"
argument_list|)
return|;
block|}
name|value
operator|=
name|value
operator|*
literal|10
operator|+
name|AS_DIGIT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Check if the number was present. */
if|if
condition|(
operator|!
name|length
condition|)
block|{
return|return
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a %YAML directive"
argument_list|,
name|start_mark
argument_list|,
literal|"did not find expected version number"
argument_list|)
return|;
block|}
operator|*
name|number
operator|=
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Scan the value of a TAG-DIRECTIVE token.  *  * Scope:  *      %TAG    !yaml!  tag:yaml.org,2002:  \n  *          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_scan_tag_directive_value
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_mark_t
name|start_mark
parameter_list|,
name|yaml_char_t
modifier|*
modifier|*
name|handle
parameter_list|,
name|yaml_char_t
modifier|*
modifier|*
name|prefix
parameter_list|)
block|{
name|yaml_char_t
modifier|*
name|handle_value
init|=
name|NULL
decl_stmt|;
name|yaml_char_t
modifier|*
name|prefix_value
init|=
name|NULL
decl_stmt|;
comment|/* Eat whitespaces. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
while|while
condition|(
name|IS_BLANK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* Scan a handle. */
if|if
condition|(
operator|!
name|yaml_parser_scan_tag_handle
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|,
name|start_mark
argument_list|,
operator|&
name|handle_value
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Expect a whitespace. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|IS_BLANK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a %TAG directive"
argument_list|,
name|start_mark
argument_list|,
literal|"did not find expected whitespace"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Eat whitespaces. */
while|while
condition|(
name|IS_BLANK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* Scan a prefix. */
if|if
condition|(
operator|!
name|yaml_parser_scan_tag_uri
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|start_mark
argument_list|,
operator|&
name|prefix_value
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Expect a whitespace or line break. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|IS_BLANKZ
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a %TAG directive"
argument_list|,
name|start_mark
argument_list|,
literal|"did not find expected whitespace or line break"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|handle
operator|=
name|handle_value
expr_stmt|;
operator|*
name|prefix
operator|=
name|prefix_value
expr_stmt|;
return|return
literal|1
return|;
name|error
label|:
name|yaml_free
argument_list|(
name|handle_value
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|prefix_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|yaml_parser_scan_anchor
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_t
modifier|*
name|token
parameter_list|,
name|yaml_token_type_t
name|type
parameter_list|)
block|{
name|int
name|length
init|=
literal|0
decl_stmt|;
name|yaml_mark_t
name|start_mark
decl_stmt|,
name|end_mark
decl_stmt|;
name|yaml_string_t
name|string
init|=
name|NULL_STRING
decl_stmt|;
if|if
condition|(
operator|!
name|STRING_INIT
argument_list|(
name|parser
argument_list|,
name|string
argument_list|,
name|INITIAL_STRING_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Eat the indicator character. */
name|start_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Consume the value. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
while|while
condition|(
name|IS_ALPHA
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|READ
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|length
operator|++
expr_stmt|;
block|}
name|end_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
comment|/*      * Check if length of the anchor is greater than 0 and it is followed by      * a whitespace character or one of the indicators:      *      *      '?', ':', ',', ']', '}', '%', '@', '`'.      */
if|if
condition|(
operator|!
name|length
operator|||
operator|!
operator|(
name|IS_BLANKZ
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'?'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|':'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|','
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|']'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'}'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'%'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'@'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'`'
argument_list|)
operator|)
condition|)
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
name|type
operator|==
name|YAML_ANCHOR_TOKEN
condition|?
literal|"while scanning an anchor"
else|:
literal|"while scanning an alias"
argument_list|,
name|start_mark
argument_list|,
literal|"did not find expected alphabetic or numeric character"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Create a token. */
if|if
condition|(
name|type
operator|==
name|YAML_ANCHOR_TOKEN
condition|)
block|{
name|ANCHOR_TOKEN_INIT
argument_list|(
operator|*
name|token
argument_list|,
name|string
operator|.
name|start
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ALIAS_TOKEN_INIT
argument_list|(
operator|*
name|token
argument_list|,
name|string
operator|.
name|start
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
name|error
label|:
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Scan a TAG token.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_scan_tag
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_t
modifier|*
name|token
parameter_list|)
block|{
name|yaml_char_t
modifier|*
name|handle
init|=
name|NULL
decl_stmt|;
name|yaml_char_t
modifier|*
name|suffix
init|=
name|NULL
decl_stmt|;
name|yaml_mark_t
name|start_mark
decl_stmt|,
name|end_mark
decl_stmt|;
name|start_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
comment|/* Check if the tag is in the canonical form. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'<'
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* Set the handle to '' */
name|handle
operator|=
name|yaml_malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle
condition|)
goto|goto
name|error
goto|;
name|handle
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Eat '!<' */
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Consume the tag value. */
if|if
condition|(
operator|!
name|yaml_parser_scan_tag_uri
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|start_mark
argument_list|,
operator|&
name|suffix
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Check for '>' and eat it. */
if|if
condition|(
operator|!
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'>'
argument_list|)
condition|)
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a tag"
argument_list|,
name|start_mark
argument_list|,
literal|"did not find the expected '>'"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The tag has either the '!suffix' or the '!handle!suffix' form. */
comment|/* First, try to scan a handle. */
if|if
condition|(
operator|!
name|yaml_parser_scan_tag_handle
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|,
name|start_mark
argument_list|,
operator|&
name|handle
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Check if it is, indeed, handle. */
if|if
condition|(
name|handle
index|[
literal|0
index|]
operator|==
literal|'!'
operator|&&
name|handle
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|&&
name|handle
index|[
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|handle
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'!'
condition|)
block|{
comment|/* Scan the suffix now. */
if|if
condition|(
operator|!
name|yaml_parser_scan_tag_uri
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|start_mark
argument_list|,
operator|&
name|suffix
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
else|else
block|{
comment|/* It wasn't a handle after all.  Scan the rest of the tag. */
if|if
condition|(
operator|!
name|yaml_parser_scan_tag_uri
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|,
name|handle
argument_list|,
name|start_mark
argument_list|,
operator|&
name|suffix
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Set the handle to '!'. */
name|yaml_free
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|handle
operator|=
name|yaml_malloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle
condition|)
goto|goto
name|error
goto|;
name|handle
index|[
literal|0
index|]
operator|=
literal|'!'
expr_stmt|;
name|handle
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*              * A special case: the '!' tag.  Set the handle to '' and the              * suffix to '!'.              */
if|if
condition|(
name|suffix
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|yaml_char_t
modifier|*
name|tmp
init|=
name|handle
decl_stmt|;
name|handle
operator|=
name|suffix
expr_stmt|;
name|suffix
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
comment|/* Check the character which ends the tag. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|IS_BLANKZ
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a tag"
argument_list|,
name|start_mark
argument_list|,
literal|"did not find expected whitespace or line break"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|end_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
comment|/* Create a token. */
name|TAG_TOKEN_INIT
argument_list|(
operator|*
name|token
argument_list|,
name|handle
argument_list|,
name|suffix
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|error
label|:
name|yaml_free
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|yaml_free
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Scan a tag handle.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_scan_tag_handle
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|int
name|directive
parameter_list|,
name|yaml_mark_t
name|start_mark
parameter_list|,
name|yaml_char_t
modifier|*
modifier|*
name|handle
parameter_list|)
block|{
name|yaml_string_t
name|string
init|=
name|NULL_STRING
decl_stmt|;
if|if
condition|(
operator|!
name|STRING_INIT
argument_list|(
name|parser
argument_list|,
name|string
argument_list|,
name|INITIAL_STRING_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Check the initial '!' character. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'!'
argument_list|)
condition|)
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
name|directive
condition|?
literal|"while scanning a tag directive"
else|:
literal|"while scanning a tag"
argument_list|,
name|start_mark
argument_list|,
literal|"did not find expected '!'"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Copy the '!' character. */
if|if
condition|(
operator|!
name|READ
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Copy all subsequent alphabetical and numerical characters. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
while|while
condition|(
name|IS_ALPHA
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|READ
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* Check if the trailing character is '!' and copy it. */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'!'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|READ
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
else|else
block|{
comment|/*          * It's either the '!' tag or not really a tag handle.  If it's a %TAG          * directive, it's an error.  If it's a tag token, it must be a part of          * URI.          */
if|if
condition|(
name|directive
operator|&&
operator|!
operator|(
name|string
operator|.
name|start
index|[
literal|0
index|]
operator|==
literal|'!'
operator|&&
name|string
operator|.
name|start
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while parsing a tag directive"
argument_list|,
name|start_mark
argument_list|,
literal|"did not find expected '!'"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
operator|*
name|handle
operator|=
name|string
operator|.
name|start
expr_stmt|;
return|return
literal|1
return|;
name|error
label|:
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Scan a tag.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_scan_tag_uri
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|int
name|directive
parameter_list|,
name|yaml_char_t
modifier|*
name|head
parameter_list|,
name|yaml_mark_t
name|start_mark
parameter_list|,
name|yaml_char_t
modifier|*
modifier|*
name|uri
parameter_list|)
block|{
name|size_t
name|length
init|=
name|head
condition|?
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|head
argument_list|)
else|:
literal|0
decl_stmt|;
name|yaml_string_t
name|string
init|=
name|NULL_STRING
decl_stmt|;
if|if
condition|(
operator|!
name|STRING_INIT
argument_list|(
name|parser
argument_list|,
name|string
argument_list|,
name|INITIAL_STRING_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Resize the string to include the head. */
while|while
condition|(
name|string
operator|.
name|end
operator|-
name|string
operator|.
name|start
operator|<=
operator|(
name|int
operator|)
name|length
condition|)
block|{
if|if
condition|(
operator|!
name|yaml_string_extend
argument_list|(
operator|&
name|string
operator|.
name|start
argument_list|,
operator|&
name|string
operator|.
name|pointer
argument_list|,
operator|&
name|string
operator|.
name|end
argument_list|)
condition|)
block|{
name|parser
operator|->
name|error
operator|=
name|YAML_MEMORY_ERROR
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
comment|/*      * Copy the head if needed.      *      * Note that we don't copy the leading '!' character.      */
if|if
condition|(
name|length
operator|>
literal|1
condition|)
block|{
name|memcpy
argument_list|(
name|string
operator|.
name|start
argument_list|,
name|head
operator|+
literal|1
argument_list|,
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
name|string
operator|.
name|pointer
operator|+=
name|length
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Scan the tag. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/*      * The set of characters that may appear in URI is as follows:      *      *      '0'-'9', 'A'-'Z', 'a'-'z', '_', '-', ';', '/', '?', ':', '@', '&',      *      '=', '+', '$', ',', '.', '!', '~', '*', '\'', '(', ')', '[', ']',      *      '%'.      */
while|while
condition|(
name|IS_ALPHA
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|';'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'/'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'?'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|':'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'@'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'&'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'='
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'+'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'$'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|','
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'.'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'!'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'~'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'*'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'\''
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'('
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|')'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'['
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|']'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'%'
argument_list|)
condition|)
block|{
comment|/* Check if it is a URI-escape sequence. */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'%'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|yaml_parser_scan_uri_escapes
argument_list|(
name|parser
argument_list|,
name|directive
argument_list|,
name|start_mark
argument_list|,
operator|&
name|string
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|READ
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
name|length
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* Check if the tag is non-empty. */
if|if
condition|(
operator|!
name|length
condition|)
block|{
if|if
condition|(
operator|!
name|STRING_EXTEND
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
name|directive
condition|?
literal|"while parsing a %TAG directive"
else|:
literal|"while parsing a tag"
argument_list|,
name|start_mark
argument_list|,
literal|"did not find expected tag URI"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|uri
operator|=
name|string
operator|.
name|start
expr_stmt|;
return|return
literal|1
return|;
name|error
label|:
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Decode an URI-escape sequence corresponding to a single UTF-8 character.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_scan_uri_escapes
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|int
name|directive
parameter_list|,
name|yaml_mark_t
name|start_mark
parameter_list|,
name|yaml_string_t
modifier|*
name|string
parameter_list|)
block|{
name|int
name|width
init|=
literal|0
decl_stmt|;
comment|/* Decode the required number of characters. */
do|do
block|{
name|unsigned
name|char
name|octet
init|=
literal|0
decl_stmt|;
comment|/* Check for a URI-escaped octet. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|3
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'%'
argument_list|)
operator|&&
name|IS_HEX_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|1
argument_list|)
operator|&&
name|IS_HEX_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
block|{
return|return
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
name|directive
condition|?
literal|"while parsing a %TAG directive"
else|:
literal|"while parsing a tag"
argument_list|,
name|start_mark
argument_list|,
literal|"did not find URI escaped octet"
argument_list|)
return|;
block|}
comment|/* Get the octet. */
name|octet
operator|=
operator|(
name|AS_HEX_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|1
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|AS_HEX_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* If it is the leading octet, determine the length of the UTF-8 sequence. */
if|if
condition|(
operator|!
name|width
condition|)
block|{
name|width
operator|=
operator|(
name|octet
operator|&
literal|0x80
operator|)
operator|==
literal|0x00
condition|?
literal|1
else|:
operator|(
name|octet
operator|&
literal|0xE0
operator|)
operator|==
literal|0xC0
condition|?
literal|2
else|:
operator|(
name|octet
operator|&
literal|0xF0
operator|)
operator|==
literal|0xE0
condition|?
literal|3
else|:
operator|(
name|octet
operator|&
literal|0xF8
operator|)
operator|==
literal|0xF0
condition|?
literal|4
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|width
condition|)
block|{
return|return
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
name|directive
condition|?
literal|"while parsing a %TAG directive"
else|:
literal|"while parsing a tag"
argument_list|,
name|start_mark
argument_list|,
literal|"found an incorrect leading UTF-8 octet"
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|/* Check if the trailing octet is correct. */
if|if
condition|(
operator|(
name|octet
operator|&
literal|0xC0
operator|)
operator|!=
literal|0x80
condition|)
block|{
return|return
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
name|directive
condition|?
literal|"while parsing a %TAG directive"
else|:
literal|"while parsing a tag"
argument_list|,
name|start_mark
argument_list|,
literal|"found an incorrect trailing UTF-8 octet"
argument_list|)
return|;
block|}
block|}
comment|/* Copy the octet and move the pointers. */
operator|*
operator|(
name|string
operator|->
name|pointer
operator|++
operator|)
operator|=
name|octet
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|width
condition|)
do|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Scan a block scalar.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_scan_block_scalar
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_t
modifier|*
name|token
parameter_list|,
name|int
name|literal
parameter_list|)
block|{
name|yaml_mark_t
name|start_mark
decl_stmt|;
name|yaml_mark_t
name|end_mark
decl_stmt|;
name|yaml_string_t
name|string
init|=
name|NULL_STRING
decl_stmt|;
name|yaml_string_t
name|leading_break
init|=
name|NULL_STRING
decl_stmt|;
name|yaml_string_t
name|trailing_breaks
init|=
name|NULL_STRING
decl_stmt|;
name|int
name|chomping
init|=
literal|0
decl_stmt|;
name|int
name|increment
init|=
literal|0
decl_stmt|;
name|int
name|indent
init|=
literal|0
decl_stmt|;
name|int
name|leading_blank
init|=
literal|0
decl_stmt|;
name|int
name|trailing_blank
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|STRING_INIT
argument_list|(
name|parser
argument_list|,
name|string
argument_list|,
name|INITIAL_STRING_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|STRING_INIT
argument_list|(
name|parser
argument_list|,
name|leading_break
argument_list|,
name|INITIAL_STRING_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|STRING_INIT
argument_list|(
name|parser
argument_list|,
name|trailing_breaks
argument_list|,
name|INITIAL_STRING_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Eat the indicator '|' or '>'. */
name|start_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Scan the additional block scalar indicators. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Check for a chomping indicator. */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'+'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'-'
argument_list|)
condition|)
block|{
comment|/* Set the chomping method and eat the indicator. */
name|chomping
operator|=
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'+'
argument_list|)
condition|?
operator|+
literal|1
else|:
operator|-
literal|1
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Check for an indentation indicator. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|IS_DIGIT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
comment|/* Check that the intendation is greater than 0. */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'0'
argument_list|)
condition|)
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a block scalar"
argument_list|,
name|start_mark
argument_list|,
literal|"found an intendation indicator equal to 0"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Get the intendation level and eat the indicator. */
name|increment
operator|=
name|AS_DIGIT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Do the same as above, but in the opposite order. */
elseif|else
if|if
condition|(
name|IS_DIGIT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'0'
argument_list|)
condition|)
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a block scalar"
argument_list|,
name|start_mark
argument_list|,
literal|"found an intendation indicator equal to 0"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|increment
operator|=
name|AS_DIGIT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'+'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'-'
argument_list|)
condition|)
block|{
name|chomping
operator|=
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'+'
argument_list|)
condition|?
operator|+
literal|1
else|:
operator|-
literal|1
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Eat whitespaces and comments to the end of the line. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
while|while
condition|(
name|IS_BLANK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'#'
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|IS_BREAKZ
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
block|}
comment|/* Check if we are at the end of the line. */
if|if
condition|(
operator|!
name|IS_BREAKZ
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a block scalar"
argument_list|,
name|start_mark
argument_list|,
literal|"did not find expected comment or line break"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Eat a line break. */
if|if
condition|(
name|IS_BREAK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|SKIP_LINE
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|end_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
comment|/* Set the intendation level if it was specified. */
if|if
condition|(
name|increment
condition|)
block|{
name|indent
operator|=
name|parser
operator|->
name|indent
operator|>=
literal|0
condition|?
name|parser
operator|->
name|indent
operator|+
name|increment
else|:
name|increment
expr_stmt|;
block|}
comment|/* Scan the leading line breaks and determine the indentation level if needed. */
if|if
condition|(
operator|!
name|yaml_parser_scan_block_scalar_breaks
argument_list|(
name|parser
argument_list|,
operator|&
name|indent
argument_list|,
operator|&
name|trailing_breaks
argument_list|,
name|start_mark
argument_list|,
operator|&
name|end_mark
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Scan the block scalar content. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
while|while
condition|(
operator|(
name|int
operator|)
name|parser
operator|->
name|mark
operator|.
name|column
operator|==
name|indent
operator|&&
operator|!
name|IS_Z
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
comment|/*          * We are at the beginning of a non-empty line.          */
comment|/* Is it a trailing whitespace? */
name|trailing_blank
operator|=
name|IS_BLANK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
expr_stmt|;
comment|/* Check if we need to fold the leading line break. */
if|if
condition|(
operator|!
name|literal
operator|&&
operator|(
operator|*
name|leading_break
operator|.
name|start
operator|==
literal|'\n'
operator|)
operator|&&
operator|!
name|leading_blank
operator|&&
operator|!
name|trailing_blank
condition|)
block|{
comment|/* Do we need to join the lines by space? */
if|if
condition|(
operator|*
name|trailing_breaks
operator|.
name|start
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|STRING_EXTEND
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
condition|)
goto|goto
name|error
goto|;
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|' '
expr_stmt|;
block|}
name|CLEAR
argument_list|(
name|parser
argument_list|,
name|leading_break
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|JOIN
argument_list|(
name|parser
argument_list|,
name|string
argument_list|,
name|leading_break
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|CLEAR
argument_list|(
name|parser
argument_list|,
name|leading_break
argument_list|)
expr_stmt|;
block|}
comment|/* Append the remaining line breaks. */
if|if
condition|(
operator|!
name|JOIN
argument_list|(
name|parser
argument_list|,
name|string
argument_list|,
name|trailing_breaks
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|CLEAR
argument_list|(
name|parser
argument_list|,
name|trailing_breaks
argument_list|)
expr_stmt|;
comment|/* Is it a leading whitespace? */
name|leading_blank
operator|=
name|IS_BLANK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
expr_stmt|;
comment|/* Consume the current line. */
while|while
condition|(
operator|!
name|IS_BREAKZ
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|READ
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* Consume the line break. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|READ_LINE
argument_list|(
name|parser
argument_list|,
name|leading_break
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Eat the following intendation spaces and line breaks. */
if|if
condition|(
operator|!
name|yaml_parser_scan_block_scalar_breaks
argument_list|(
name|parser
argument_list|,
operator|&
name|indent
argument_list|,
operator|&
name|trailing_breaks
argument_list|,
name|start_mark
argument_list|,
operator|&
name|end_mark
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* Chomp the tail. */
if|if
condition|(
name|chomping
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|JOIN
argument_list|(
name|parser
argument_list|,
name|string
argument_list|,
name|leading_break
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|chomping
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|JOIN
argument_list|(
name|parser
argument_list|,
name|string
argument_list|,
name|trailing_breaks
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* Create a token. */
name|SCALAR_TOKEN_INIT
argument_list|(
operator|*
name|token
argument_list|,
name|string
operator|.
name|start
argument_list|,
name|string
operator|.
name|pointer
operator|-
name|string
operator|.
name|start
argument_list|,
name|literal
condition|?
name|YAML_LITERAL_SCALAR_STYLE
else|:
name|YAML_FOLDED_SCALAR_STYLE
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|leading_break
argument_list|)
expr_stmt|;
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|trailing_breaks
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|error
label|:
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|leading_break
argument_list|)
expr_stmt|;
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|trailing_breaks
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Scan intendation spaces and line breaks for a block scalar.  Determine the  * intendation level if needed.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_scan_block_scalar_breaks
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|int
modifier|*
name|indent
parameter_list|,
name|yaml_string_t
modifier|*
name|breaks
parameter_list|,
name|yaml_mark_t
name|start_mark
parameter_list|,
name|yaml_mark_t
modifier|*
name|end_mark
parameter_list|)
block|{
name|int
name|max_indent
init|=
literal|0
decl_stmt|;
operator|*
name|end_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
comment|/* Eat the intendation spaces and line breaks. */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Eat the intendation spaces. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|(
operator|!
operator|*
name|indent
operator|||
operator|(
name|int
operator|)
name|parser
operator|->
name|mark
operator|.
name|column
operator|<
operator|*
name|indent
operator|)
operator|&&
name|IS_SPACE
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|parser
operator|->
name|mark
operator|.
name|column
operator|>
name|max_indent
condition|)
name|max_indent
operator|=
operator|(
name|int
operator|)
name|parser
operator|->
name|mark
operator|.
name|column
expr_stmt|;
comment|/* Check for a tab character messing the intendation. */
if|if
condition|(
operator|(
operator|!
operator|*
name|indent
operator|||
operator|(
name|int
operator|)
name|parser
operator|->
name|mark
operator|.
name|column
operator|<
operator|*
name|indent
operator|)
operator|&&
name|IS_TAB
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
return|return
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a block scalar"
argument_list|,
name|start_mark
argument_list|,
literal|"found a tab character where an intendation space is expected"
argument_list|)
return|;
block|}
comment|/* Have we found a non-empty line? */
if|if
condition|(
operator|!
name|IS_BREAK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
break|break;
comment|/* Consume the line break. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|READ_LINE
argument_list|(
name|parser
argument_list|,
operator|*
name|breaks
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|end_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
block|}
comment|/* Determine the indentation level if needed. */
if|if
condition|(
operator|!
operator|*
name|indent
condition|)
block|{
operator|*
name|indent
operator|=
name|max_indent
expr_stmt|;
if|if
condition|(
operator|*
name|indent
operator|<
name|parser
operator|->
name|indent
operator|+
literal|1
condition|)
operator|*
name|indent
operator|=
name|parser
operator|->
name|indent
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|indent
operator|<
literal|1
condition|)
operator|*
name|indent
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Scan a quoted scalar.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_scan_flow_scalar
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_t
modifier|*
name|token
parameter_list|,
name|int
name|single
parameter_list|)
block|{
name|yaml_mark_t
name|start_mark
decl_stmt|;
name|yaml_mark_t
name|end_mark
decl_stmt|;
name|yaml_string_t
name|string
init|=
name|NULL_STRING
decl_stmt|;
name|yaml_string_t
name|leading_break
init|=
name|NULL_STRING
decl_stmt|;
name|yaml_string_t
name|trailing_breaks
init|=
name|NULL_STRING
decl_stmt|;
name|yaml_string_t
name|whitespaces
init|=
name|NULL_STRING
decl_stmt|;
name|int
name|leading_blanks
decl_stmt|;
if|if
condition|(
operator|!
name|STRING_INIT
argument_list|(
name|parser
argument_list|,
name|string
argument_list|,
name|INITIAL_STRING_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|STRING_INIT
argument_list|(
name|parser
argument_list|,
name|leading_break
argument_list|,
name|INITIAL_STRING_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|STRING_INIT
argument_list|(
name|parser
argument_list|,
name|trailing_breaks
argument_list|,
name|INITIAL_STRING_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|STRING_INIT
argument_list|(
name|parser
argument_list|,
name|whitespaces
argument_list|,
name|INITIAL_STRING_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Eat the left quote. */
name|start_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Consume the content of the quoted scalar. */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Check that there are no document indicators at the beginning of the line. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|4
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|parser
operator|->
name|mark
operator|.
name|column
operator|==
literal|0
operator|&&
operator|(
operator|(
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'-'
argument_list|,
literal|0
argument_list|)
operator|&&
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'-'
argument_list|,
literal|1
argument_list|)
operator|&&
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'-'
argument_list|,
literal|2
argument_list|)
operator|)
operator|||
operator|(
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'.'
argument_list|,
literal|0
argument_list|)
operator|&&
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'.'
argument_list|,
literal|1
argument_list|)
operator|&&
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'.'
argument_list|,
literal|2
argument_list|)
operator|)
operator|)
operator|&&
name|IS_BLANKZ_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a quoted scalar"
argument_list|,
name|start_mark
argument_list|,
literal|"found unexpected document indicator"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Check for EOF. */
if|if
condition|(
name|IS_Z
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a quoted scalar"
argument_list|,
name|start_mark
argument_list|,
literal|"found unexpected end of stream"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Consume non-blank characters. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|leading_blanks
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|IS_BLANKZ
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
comment|/* Check for an escaped single quote. */
if|if
condition|(
name|single
operator|&&
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'\''
argument_list|,
literal|0
argument_list|)
operator|&&
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'\''
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|STRING_EXTEND
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
condition|)
goto|goto
name|error
goto|;
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\''
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* Check for the right quote. */
elseif|else
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
name|single
condition|?
literal|'\''
else|:
literal|'"'
argument_list|)
condition|)
block|{
break|break;
block|}
comment|/* Check for an escaped line break. */
elseif|else
if|if
condition|(
operator|!
name|single
operator|&&
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'\\'
argument_list|)
operator|&&
name|IS_BREAK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|3
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|SKIP_LINE
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|leading_blanks
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Check for an escape sequence. */
elseif|else
if|if
condition|(
operator|!
name|single
operator|&&
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'\\'
argument_list|)
condition|)
block|{
name|size_t
name|code_length
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|STRING_EXTEND
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Check the escape character. */
switch|switch
condition|(
name|parser
operator|->
name|buffer
operator|.
name|pointer
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'0'
case|:
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\x07'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\x08'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
case|case
literal|'\t'
case|:
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\x09'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\x0A'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\x0B'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\x0C'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\x0D'
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\x1B'
expr_stmt|;
break|break;
case|case
literal|' '
case|:
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\x20'
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'"'
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\''
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* NEL (#x85) */
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\xC2'
expr_stmt|;
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\x85'
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
comment|/* #xA0 */
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\xC2'
expr_stmt|;
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\xA0'
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* LS (#x2028) */
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\xE2'
expr_stmt|;
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\x80'
expr_stmt|;
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\xA8'
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* PS (#x2029) */
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\xE2'
expr_stmt|;
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\x80'
expr_stmt|;
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|'\xA9'
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|code_length
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|code_length
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|code_length
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while parsing a quoted scalar"
argument_list|,
name|start_mark
argument_list|,
literal|"found unknown escape character"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Consume an arbitrary escape code. */
if|if
condition|(
name|code_length
condition|)
block|{
name|unsigned
name|int
name|value
init|=
literal|0
decl_stmt|;
name|size_t
name|k
decl_stmt|;
comment|/* Scan the character value. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
name|code_length
argument_list|)
condition|)
goto|goto
name|error
goto|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|code_length
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|IS_HEX_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
name|k
argument_list|)
condition|)
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while parsing a quoted scalar"
argument_list|,
name|start_mark
argument_list|,
literal|"did not find expected hexdecimal number"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|value
operator|=
operator|(
name|value
operator|<<
literal|4
operator|)
operator|+
name|AS_HEX_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
comment|/* Check the value and write the character. */
if|if
condition|(
operator|(
name|value
operator|>=
literal|0xD800
operator|&&
name|value
operator|<=
literal|0xDFFF
operator|)
operator|||
name|value
operator|>
literal|0x10FFFF
condition|)
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while parsing a quoted scalar"
argument_list|,
name|start_mark
argument_list|,
literal|"found invalid Unicode character escape code"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|value
operator|<=
literal|0x7F
condition|)
block|{
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|<=
literal|0x7FF
condition|)
block|{
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|0xC0
operator|+
operator|(
name|value
operator|>>
literal|6
operator|)
expr_stmt|;
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|0x80
operator|+
operator|(
name|value
operator|&
literal|0x3F
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|<=
literal|0xFFFF
condition|)
block|{
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|0xE0
operator|+
operator|(
name|value
operator|>>
literal|12
operator|)
expr_stmt|;
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|0x80
operator|+
operator|(
operator|(
name|value
operator|>>
literal|6
operator|)
operator|&
literal|0x3F
operator|)
expr_stmt|;
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|0x80
operator|+
operator|(
name|value
operator|&
literal|0x3F
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|0xF0
operator|+
operator|(
name|value
operator|>>
literal|18
operator|)
expr_stmt|;
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|0x80
operator|+
operator|(
operator|(
name|value
operator|>>
literal|12
operator|)
operator|&
literal|0x3F
operator|)
expr_stmt|;
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|0x80
operator|+
operator|(
operator|(
name|value
operator|>>
literal|6
operator|)
operator|&
literal|0x3F
operator|)
expr_stmt|;
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|0x80
operator|+
operator|(
name|value
operator|&
literal|0x3F
operator|)
expr_stmt|;
block|}
comment|/* Advance the pointer. */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|code_length
condition|;
name|k
operator|++
control|)
block|{
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* It is a non-escaped non-blank character. */
if|if
condition|(
operator|!
name|READ
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* Check if we are at the end of the scalar. */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
name|single
condition|?
literal|'\''
else|:
literal|'"'
argument_list|)
condition|)
break|break;
comment|/* Consume blank characters. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
while|while
condition|(
name|IS_BLANK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
operator|||
name|IS_BREAK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_BLANK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
comment|/* Consume a space or a tab character. */
if|if
condition|(
operator|!
name|leading_blanks
condition|)
block|{
if|if
condition|(
operator|!
name|READ
argument_list|(
name|parser
argument_list|,
name|whitespaces
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
else|else
block|{
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Check if it is a first line break. */
if|if
condition|(
operator|!
name|leading_blanks
condition|)
block|{
name|CLEAR
argument_list|(
name|parser
argument_list|,
name|whitespaces
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|READ_LINE
argument_list|(
name|parser
argument_list|,
name|leading_break
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|leading_blanks
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|READ_LINE
argument_list|(
name|parser
argument_list|,
name|trailing_breaks
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* Join the whitespaces or fold line breaks. */
if|if
condition|(
name|leading_blanks
condition|)
block|{
comment|/* Do we need to fold line breaks? */
if|if
condition|(
name|leading_break
operator|.
name|start
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|trailing_breaks
operator|.
name|start
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|STRING_EXTEND
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
condition|)
goto|goto
name|error
goto|;
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|JOIN
argument_list|(
name|parser
argument_list|,
name|string
argument_list|,
name|trailing_breaks
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|CLEAR
argument_list|(
name|parser
argument_list|,
name|trailing_breaks
argument_list|)
expr_stmt|;
block|}
name|CLEAR
argument_list|(
name|parser
argument_list|,
name|leading_break
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|JOIN
argument_list|(
name|parser
argument_list|,
name|string
argument_list|,
name|leading_break
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|JOIN
argument_list|(
name|parser
argument_list|,
name|string
argument_list|,
name|trailing_breaks
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|CLEAR
argument_list|(
name|parser
argument_list|,
name|leading_break
argument_list|)
expr_stmt|;
name|CLEAR
argument_list|(
name|parser
argument_list|,
name|trailing_breaks
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|JOIN
argument_list|(
name|parser
argument_list|,
name|string
argument_list|,
name|whitespaces
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|CLEAR
argument_list|(
name|parser
argument_list|,
name|whitespaces
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Eat the right quote. */
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|end_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
comment|/* Create a token. */
name|SCALAR_TOKEN_INIT
argument_list|(
operator|*
name|token
argument_list|,
name|string
operator|.
name|start
argument_list|,
name|string
operator|.
name|pointer
operator|-
name|string
operator|.
name|start
argument_list|,
name|single
condition|?
name|YAML_SINGLE_QUOTED_SCALAR_STYLE
else|:
name|YAML_DOUBLE_QUOTED_SCALAR_STYLE
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|leading_break
argument_list|)
expr_stmt|;
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|trailing_breaks
argument_list|)
expr_stmt|;
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|whitespaces
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|error
label|:
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|leading_break
argument_list|)
expr_stmt|;
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|trailing_breaks
argument_list|)
expr_stmt|;
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|whitespaces
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Scan a plain scalar.  */
end_comment

begin_function
specifier|static
name|int
name|yaml_parser_scan_plain_scalar
parameter_list|(
name|yaml_parser_t
modifier|*
name|parser
parameter_list|,
name|yaml_token_t
modifier|*
name|token
parameter_list|)
block|{
name|yaml_mark_t
name|start_mark
decl_stmt|;
name|yaml_mark_t
name|end_mark
decl_stmt|;
name|yaml_string_t
name|string
init|=
name|NULL_STRING
decl_stmt|;
name|yaml_string_t
name|leading_break
init|=
name|NULL_STRING
decl_stmt|;
name|yaml_string_t
name|trailing_breaks
init|=
name|NULL_STRING
decl_stmt|;
name|yaml_string_t
name|whitespaces
init|=
name|NULL_STRING
decl_stmt|;
name|int
name|leading_blanks
init|=
literal|0
decl_stmt|;
name|int
name|indent
init|=
name|parser
operator|->
name|indent
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|STRING_INIT
argument_list|(
name|parser
argument_list|,
name|string
argument_list|,
name|INITIAL_STRING_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|STRING_INIT
argument_list|(
name|parser
argument_list|,
name|leading_break
argument_list|,
name|INITIAL_STRING_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|STRING_INIT
argument_list|(
name|parser
argument_list|,
name|trailing_breaks
argument_list|,
name|INITIAL_STRING_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|STRING_INIT
argument_list|(
name|parser
argument_list|,
name|whitespaces
argument_list|,
name|INITIAL_STRING_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|start_mark
operator|=
name|end_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
comment|/* Consume the content of the plain scalar. */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Check for a document indicator. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|4
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|parser
operator|->
name|mark
operator|.
name|column
operator|==
literal|0
operator|&&
operator|(
operator|(
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'-'
argument_list|,
literal|0
argument_list|)
operator|&&
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'-'
argument_list|,
literal|1
argument_list|)
operator|&&
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'-'
argument_list|,
literal|2
argument_list|)
operator|)
operator|||
operator|(
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'.'
argument_list|,
literal|0
argument_list|)
operator|&&
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'.'
argument_list|,
literal|1
argument_list|)
operator|&&
name|CHECK_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'.'
argument_list|,
literal|2
argument_list|)
operator|)
operator|)
operator|&&
name|IS_BLANKZ_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|3
argument_list|)
condition|)
break|break;
comment|/* Check for a comment. */
if|if
condition|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'#'
argument_list|)
condition|)
break|break;
comment|/* Consume non-blank characters. */
while|while
condition|(
operator|!
name|IS_BLANKZ
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
comment|/* Check for 'x:x' in the flow context. TODO: Fix the test "spec-08-13". */
if|if
condition|(
name|parser
operator|->
name|flow_level
operator|&&
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|':'
argument_list|)
operator|&&
operator|!
name|IS_BLANKZ_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a plain scalar"
argument_list|,
name|start_mark
argument_list|,
literal|"found unexpected ':'"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Check for indicators that may end a plain scalar. */
if|if
condition|(
operator|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|':'
argument_list|)
operator|&&
name|IS_BLANKZ_AT
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|1
argument_list|)
operator|)
operator|||
operator|(
name|parser
operator|->
name|flow_level
operator|&&
operator|(
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|','
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|':'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'?'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'['
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|']'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'{'
argument_list|)
operator|||
name|CHECK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|,
literal|'}'
argument_list|)
operator|)
operator|)
condition|)
break|break;
comment|/* Check if we need to join whitespaces and breaks. */
if|if
condition|(
name|leading_blanks
operator|||
name|whitespaces
operator|.
name|start
operator|!=
name|whitespaces
operator|.
name|pointer
condition|)
block|{
if|if
condition|(
name|leading_blanks
condition|)
block|{
comment|/* Do we need to fold line breaks? */
if|if
condition|(
name|leading_break
operator|.
name|start
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|trailing_breaks
operator|.
name|start
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|STRING_EXTEND
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
condition|)
goto|goto
name|error
goto|;
operator|*
operator|(
name|string
operator|.
name|pointer
operator|++
operator|)
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|JOIN
argument_list|(
name|parser
argument_list|,
name|string
argument_list|,
name|trailing_breaks
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|CLEAR
argument_list|(
name|parser
argument_list|,
name|trailing_breaks
argument_list|)
expr_stmt|;
block|}
name|CLEAR
argument_list|(
name|parser
argument_list|,
name|leading_break
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|JOIN
argument_list|(
name|parser
argument_list|,
name|string
argument_list|,
name|leading_break
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|JOIN
argument_list|(
name|parser
argument_list|,
name|string
argument_list|,
name|trailing_breaks
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|CLEAR
argument_list|(
name|parser
argument_list|,
name|leading_break
argument_list|)
expr_stmt|;
name|CLEAR
argument_list|(
name|parser
argument_list|,
name|trailing_breaks
argument_list|)
expr_stmt|;
block|}
name|leading_blanks
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|JOIN
argument_list|(
name|parser
argument_list|,
name|string
argument_list|,
name|whitespaces
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|CLEAR
argument_list|(
name|parser
argument_list|,
name|whitespaces
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Copy the character. */
if|if
condition|(
operator|!
name|READ
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|end_mark
operator|=
name|parser
operator|->
name|mark
expr_stmt|;
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* Is it the end? */
if|if
condition|(
operator|!
operator|(
name|IS_BLANK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
operator|||
name|IS_BREAK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
operator|)
condition|)
break|break;
comment|/* Consume blank characters. */
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
while|while
condition|(
name|IS_BLANK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
operator|||
name|IS_BREAK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_BLANK
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
comment|/* Check for tab character that abuse intendation. */
if|if
condition|(
name|leading_blanks
operator|&&
operator|(
name|int
operator|)
name|parser
operator|->
name|mark
operator|.
name|column
operator|<
name|indent
operator|&&
name|IS_TAB
argument_list|(
name|parser
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|yaml_parser_set_scanner_error
argument_list|(
name|parser
argument_list|,
literal|"while scanning a plain scalar"
argument_list|,
name|start_mark
argument_list|,
literal|"found a tab character that violate intendation"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Consume a space or a tab character. */
if|if
condition|(
operator|!
name|leading_blanks
condition|)
block|{
if|if
condition|(
operator|!
name|READ
argument_list|(
name|parser
argument_list|,
name|whitespaces
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
else|else
block|{
name|SKIP
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Check if it is a first line break. */
if|if
condition|(
operator|!
name|leading_blanks
condition|)
block|{
name|CLEAR
argument_list|(
name|parser
argument_list|,
name|whitespaces
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|READ_LINE
argument_list|(
name|parser
argument_list|,
name|leading_break
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|leading_blanks
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|READ_LINE
argument_list|(
name|parser
argument_list|,
name|trailing_breaks
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|CACHE
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* Check intendation level. */
if|if
condition|(
operator|!
name|parser
operator|->
name|flow_level
operator|&&
operator|(
name|int
operator|)
name|parser
operator|->
name|mark
operator|.
name|column
operator|<
name|indent
condition|)
break|break;
block|}
comment|/* Create a token. */
name|SCALAR_TOKEN_INIT
argument_list|(
operator|*
name|token
argument_list|,
name|string
operator|.
name|start
argument_list|,
name|string
operator|.
name|pointer
operator|-
name|string
operator|.
name|start
argument_list|,
name|YAML_PLAIN_SCALAR_STYLE
argument_list|,
name|start_mark
argument_list|,
name|end_mark
argument_list|)
expr_stmt|;
comment|/* Note that we change the 'simple_key_allowed' flag. */
if|if
condition|(
name|leading_blanks
condition|)
block|{
name|parser
operator|->
name|simple_key_allowed
operator|=
literal|1
expr_stmt|;
block|}
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|leading_break
argument_list|)
expr_stmt|;
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|trailing_breaks
argument_list|)
expr_stmt|;
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|whitespaces
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|error
label|:
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|leading_break
argument_list|)
expr_stmt|;
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|trailing_breaks
argument_list|)
expr_stmt|;
name|STRING_DEL
argument_list|(
name|parser
argument_list|,
name|whitespaces
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

