begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  $Id: util.c,v 1.211 2011/01/19 00:31:43 tom Exp $  *  *  util.c -- miscellaneous utilities for dialog  *  *  Copyright 2000-2010,2011	Thomas E. Dickey  *  *  This program is free software; you can redistribute it and/or modify  *  it under the terms of the GNU Lesser General Public License, version 2.1  *  as published by the Free Software Foundation.  *  *  This program is distributed in the hope that it will be useful, but  *  WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *  Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public  *  License along with this program; if not, write to  *	Free Software Foundation, Inc.  *	51 Franklin St., Fifth Floor  *	Boston, MA 02110, USA.  *  *  An earlier version of this program lists as authors  *	Savio Lam (lam836@cs.cuhk.hk)  */
end_comment

begin_include
include|#
directive|include
file|<dialog.h>
end_include

begin_include
include|#
directive|include
file|<dlg_keys.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NCURSES_VERSION
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_NCURSESW_TERM_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<ncursesw/term.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_NCURSES_TERM_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<ncurses/term.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* globals */
end_comment

begin_decl_stmt
name|DIALOG_STATE
name|dialog_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DIALOG_VARS
name|dialog_vars
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|concat
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a##b
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_RC_FILE
end_ifdef

begin_define
define|#
directive|define
name|RC_DATA
parameter_list|(
name|name
parameter_list|,
name|comment
parameter_list|)
value|, #name "_color", comment " color"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RC_DATA
parameter_list|(
name|name
parameter_list|,
name|comment
parameter_list|)
end_define

begin_comment
comment|/*nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_COLOR
end_ifdef

begin_include
include|#
directive|include
file|<dlg_colors.h>
end_include

begin_define
define|#
directive|define
name|COLOR_DATA
parameter_list|(
name|upr
parameter_list|)
value|, \ 	concat(DLGC_FG_,upr), \ 	concat(DLGC_BG_,upr), \ 	concat(DLGC_HL_,upr)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|COLOR_DATA
parameter_list|(
name|upr
parameter_list|)
end_define

begin_comment
comment|/*nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DATA
parameter_list|(
name|atr
parameter_list|,
name|upr
parameter_list|,
name|lwr
parameter_list|,
name|cmt
parameter_list|)
value|{ atr COLOR_DATA(upr) RC_DATA(lwr,cmt) }
end_define

begin_comment
comment|/*  * Table of color and attribute values, default is for mono display.  */
end_comment

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_decl_stmt
name|DIALOG_COLORS
name|dlg_color_table
index|[]
init|=
block|{
name|DATA
argument_list|(
name|A_NORMAL
argument_list|,
name|SCREEN
argument_list|,
name|screen
argument_list|,
literal|"Screen"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_NORMAL
argument_list|,
name|SHADOW
argument_list|,
name|shadow
argument_list|,
literal|"Shadow"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_REVERSE
argument_list|,
name|DIALOG
argument_list|,
name|dialog
argument_list|,
literal|"Dialog box"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_REVERSE
argument_list|,
name|TITLE
argument_list|,
name|title
argument_list|,
literal|"Dialog box title"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_REVERSE
argument_list|,
name|BORDER
argument_list|,
name|border
argument_list|,
literal|"Dialog box border"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_BOLD
argument_list|,
name|BUTTON_ACTIVE
argument_list|,
name|button_active
argument_list|,
literal|"Active button"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_DIM
argument_list|,
name|BUTTON_INACTIVE
argument_list|,
name|button_inactive
argument_list|,
literal|"Inactive button"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_UNDERLINE
argument_list|,
name|BUTTON_KEY_ACTIVE
argument_list|,
name|button_key_active
argument_list|,
literal|"Active button key"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_UNDERLINE
argument_list|,
name|BUTTON_KEY_INACTIVE
argument_list|,
name|button_key_inactive
argument_list|,
literal|"Inactive button key"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_NORMAL
argument_list|,
name|BUTTON_LABEL_ACTIVE
argument_list|,
name|button_label_active
argument_list|,
literal|"Active button label"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_NORMAL
argument_list|,
name|BUTTON_LABEL_INACTIVE
argument_list|,
name|button_label_inactive
argument_list|,
literal|"Inactive button label"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_REVERSE
argument_list|,
name|INPUTBOX
argument_list|,
name|inputbox
argument_list|,
literal|"Input box"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_REVERSE
argument_list|,
name|INPUTBOX_BORDER
argument_list|,
name|inputbox_border
argument_list|,
literal|"Input box border"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_REVERSE
argument_list|,
name|SEARCHBOX
argument_list|,
name|searchbox
argument_list|,
literal|"Search box"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_REVERSE
argument_list|,
name|SEARCHBOX_TITLE
argument_list|,
name|searchbox_title
argument_list|,
literal|"Search box title"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_REVERSE
argument_list|,
name|SEARCHBOX_BORDER
argument_list|,
name|searchbox_border
argument_list|,
literal|"Search box border"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_REVERSE
argument_list|,
name|POSITION_INDICATOR
argument_list|,
name|position_indicator
argument_list|,
literal|"File position indicator"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_REVERSE
argument_list|,
name|MENUBOX
argument_list|,
name|menubox
argument_list|,
literal|"Menu box"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_REVERSE
argument_list|,
name|MENUBOX_BORDER
argument_list|,
name|menubox_border
argument_list|,
literal|"Menu box border"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_REVERSE
argument_list|,
name|ITEM
argument_list|,
name|item
argument_list|,
literal|"Item"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_NORMAL
argument_list|,
name|ITEM_SELECTED
argument_list|,
name|item_selected
argument_list|,
literal|"Selected item"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_REVERSE
argument_list|,
name|TAG
argument_list|,
name|tag
argument_list|,
literal|"Tag"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_REVERSE
argument_list|,
name|TAG_SELECTED
argument_list|,
name|tag_selected
argument_list|,
literal|"Selected tag"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_NORMAL
argument_list|,
name|TAG_KEY
argument_list|,
name|tag_key
argument_list|,
literal|"Tag key"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_BOLD
argument_list|,
name|TAG_KEY_SELECTED
argument_list|,
name|tag_key_selected
argument_list|,
literal|"Selected tag key"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_REVERSE
argument_list|,
name|CHECK
argument_list|,
name|check
argument_list|,
literal|"Check box"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_REVERSE
argument_list|,
name|CHECK_SELECTED
argument_list|,
name|check_selected
argument_list|,
literal|"Selected check box"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_REVERSE
argument_list|,
name|UARROW
argument_list|,
name|uarrow
argument_list|,
literal|"Up arrow"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_REVERSE
argument_list|,
name|DARROW
argument_list|,
name|darrow
argument_list|,
literal|"Down arrow"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_NORMAL
argument_list|,
name|ITEMHELP
argument_list|,
name|itemhelp
argument_list|,
literal|"Item help-text"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_BOLD
argument_list|,
name|FORM_ACTIVE_TEXT
argument_list|,
name|form_active_text
argument_list|,
literal|"Active form text"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_REVERSE
argument_list|,
name|FORM_TEXT
argument_list|,
name|form_text
argument_list|,
literal|"Form text"
argument_list|)
block|,
name|DATA
argument_list|(
name|A_NORMAL
argument_list|,
name|FORM_ITEM_READONLY
argument_list|,
name|form_item_readonly
argument_list|,
literal|"Readonly form item"
argument_list|)
block|,
name|DATA
argument_list|(
argument|A_REVERSE
argument_list|,
argument|GAUGE
argument_list|,
argument|gauge
argument_list|,
literal|"Dialog box gauge"
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_comment
comment|/*  * Display background title if it exists ...  */
end_comment

begin_function
name|void
name|dlg_put_backtitle
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|backtitle
operator|!=
name|NULL
condition|)
block|{
name|chtype
name|attr
init|=
name|A_NORMAL
decl_stmt|;
name|int
name|backwidth
init|=
name|dlg_count_columns
argument_list|(
name|dialog_vars
operator|.
name|backtitle
argument_list|)
decl_stmt|;
name|wattrset
argument_list|(
name|stdscr
argument_list|,
name|screen_attr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|stdscr
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dlg_print_text
argument_list|(
name|stdscr
argument_list|,
name|dialog_vars
operator|.
name|backtitle
argument_list|,
name|COLS
operator|-
literal|2
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLS
operator|-
name|backwidth
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|stdscr
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|stdscr
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLS
operator|-
literal|2
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|stdscr
argument_list|,
name|dlg_boxchar
argument_list|(
name|ACS_HLINE
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|wnoutrefresh
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set window to attribute 'attr'.  There are more efficient ways to do this,  * but will not work on older/buggy ncurses versions.  */
end_comment

begin_function
name|void
name|dlg_attr_clear
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|,
name|chtype
name|attr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|wattrset
argument_list|(
name|win
argument_list|,
name|attr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|win
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|width
condition|;
name|j
operator|++
control|)
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|win
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|touchwin
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dlg_clear
parameter_list|(
name|void
parameter_list|)
block|{
name|dlg_attr_clear
argument_list|(
name|stdscr
argument_list|,
name|LINES
argument_list|,
name|COLS
argument_list|,
name|screen_attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|isprivate
parameter_list|(
name|s
parameter_list|)
value|((s) != 0&& strstr(s, "\033[?") != 0)
end_define

begin_define
define|#
directive|define
name|TTY_DEVICE
value|"/dev/tty"
end_define

begin_comment
comment|/*  * If $DIALOG_TTY exists, allow the program to try to open the terminal  * directly when stdout is redirected.  By default we require the "--stdout"  * option to be given, but some scripts were written making use of the  * behavior of dialog which tried opening the terminal anyway.   */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dialog_tty
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|result
init|=
name|getenv
argument_list|(
literal|"DIALOG_TTY"
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
operator|&&
name|atoi
argument_list|(
name|result
argument_list|)
operator|==
literal|0
condition|)
name|result
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Open the terminal directly.  If one of stdin, stdout or stderr really points  * to a tty, use it.  Otherwise give up and open /dev/tty.  */
end_comment

begin_function
specifier|static
name|int
name|open_terminal
parameter_list|(
name|char
modifier|*
modifier|*
name|result
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|device
init|=
name|TTY_DEVICE
decl_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
operator|||
operator|(
name|device
operator|=
name|ttyname
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
operator|||
operator|(
name|device
operator|=
name|ttyname
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
operator|||
operator|(
name|device
operator|=
name|ttyname
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|device
operator|=
name|TTY_DEVICE
expr_stmt|;
block|}
block|}
block|}
operator|*
name|result
operator|=
name|dlg_strclone
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
name|open
argument_list|(
name|device
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do some initialization for dialog.  *  * 'input' is the real tty input of dialog.  Usually it is stdin, but if  * --input-fd option is used, it may be anything.  *  * 'output' is where dialog will send its result.  Usually it is stderr, but  * if --stdout or --output-fd is used, it may be anything.  We are concerned  * mainly with the case where it happens to be the same as stdout.  */
end_comment

begin_function
name|void
name|init_dialog
parameter_list|(
name|FILE
modifier|*
name|input
parameter_list|,
name|FILE
modifier|*
name|output
parameter_list|)
block|{
name|int
name|fd1
decl_stmt|,
name|fd2
decl_stmt|;
name|char
modifier|*
name|device
init|=
literal|0
decl_stmt|;
name|dialog_state
operator|.
name|output
operator|=
name|output
expr_stmt|;
name|dialog_state
operator|.
name|tab_len
operator|=
name|TAB_LEN
expr_stmt|;
name|dialog_state
operator|.
name|aspect_ratio
operator|=
name|DEFAULT_ASPECT_RATIO
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_COLOR
name|dialog_state
operator|.
name|use_colors
operator|=
name|USE_COLORS
expr_stmt|;
comment|/* use colors by default? */
name|dialog_state
operator|.
name|use_shadow
operator|=
name|USE_SHADOW
expr_stmt|;
comment|/* shadow dialog boxes by default? */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_RC_FILE
if|if
condition|(
name|dlg_parse_rc
argument_list|()
operator|==
operator|-
literal|1
condition|)
comment|/* Read the configuration file */
name|dlg_exiterr
argument_list|(
literal|"init_dialog: dlg_parse_rc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Some widgets (such as gauge) may read from the standard input.  Pipes      * only connect stdout/stdin, so there is not much choice.  But reading a      * pipe would get in the way of curses' normal reading stdin for getch.      *      * As in the --stdout (see below), reopening the terminal does not always      * work properly.  dialog provides a --pipe-fd option for this purpose.  We      * test that case first (differing fileno's for input/stdin).  If the      * fileno's are equal, but we're not reading from a tty, see if we can open      * /dev/tty.      */
name|dialog_state
operator|.
name|pipe_input
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
name|fileno
argument_list|(
name|input
argument_list|)
operator|!=
name|fileno
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|fd1
operator|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|input
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|fd2
operator|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fileno
argument_list|(
name|input
argument_list|)
argument_list|,
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
name|dialog_state
operator|.
name|pipe_input
operator|=
name|fdopen
argument_list|(
name|fd2
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileno
argument_list|(
name|stdin
argument_list|)
operator|!=
literal|0
condition|)
comment|/* some functions may read fd #0 */
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|dlg_exiterr
argument_list|(
literal|"cannot open tty-input"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|fd1
operator|=
name|open_terminal
argument_list|(
operator|&
name|device
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|fd2
operator|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|dialog_state
operator|.
name|pipe_input
operator|=
name|fdopen
argument_list|(
name|fd2
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
name|device
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
literal|0
condition|)
name|dlg_exiterr
argument_list|(
literal|"cannot open tty-input"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileno
argument_list|(
name|stdin
argument_list|)
operator|!=
literal|0
condition|)
comment|/* some functions may read fd #0 */
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|device
argument_list|)
expr_stmt|;
block|}
comment|/*      * If stdout is not a tty and dialog is called with the --stdout option, we      * have to provide for a way to write to the screen.      *      * The curses library normally writes its output to stdout, leaving stderr      * free for scripting.  Scripts are simpler when stdout is redirected.  The      * newterm function is useful; it allows us to specify where the output      * goes.  Reopening the terminal is not portable since several      * configurations do not allow this to work properly:      *      * a) some getty implementations (and possibly broken tty drivers, e.g., on      *    HPUX 10 and 11) cause stdin to act as if it is still in cooked mode      *    even though results from ioctl's state that it is successfully      *    altered to raw mode.  Broken is the proper term.      *      * b) the user may not have permissions on the device, e.g., if one su's      *    from the login user to another non-privileged user.      */
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
operator|&&
operator|(
name|fileno
argument_list|(
name|stdout
argument_list|)
operator|==
name|fileno
argument_list|(
name|output
argument_list|)
operator|||
name|dialog_tty
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|fd1
operator|=
name|open_terminal
argument_list|(
operator|&
name|device
argument_list|,
name|O_WRONLY
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|dialog_state
operator|.
name|screen_output
operator|=
name|fdopen
argument_list|(
name|fd1
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|newterm
argument_list|(
name|NULL
argument_list|,
name|dialog_state
operator|.
name|screen_output
argument_list|,
name|stdin
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dlg_exiterr
argument_list|(
literal|"cannot initialize curses"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|device
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dlg_exiterr
argument_list|(
literal|"cannot open tty-output"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dialog_state
operator|.
name|screen_output
operator|=
name|stdout
expr_stmt|;
operator|(
name|void
operator|)
name|initscr
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NCURSES_VERSION
comment|/*      * Cancel xterm's alternate-screen mode.      */
if|if
condition|(
operator|!
name|dialog_vars
operator|.
name|keep_tite
operator|&&
operator|(
name|dialog_state
operator|.
name|screen_output
operator|!=
name|stdout
operator|||
name|isatty
argument_list|(
name|fileno
argument_list|(
name|dialog_state
operator|.
name|screen_output
argument_list|)
argument_list|)
operator|)
operator|&&
name|key_mouse
operator|!=
literal|0
comment|/* xterm and kindred */
operator|&&
name|isprivate
argument_list|(
name|enter_ca_mode
argument_list|)
operator|&&
name|isprivate
argument_list|(
name|exit_ca_mode
argument_list|)
condition|)
block|{
comment|/* 	 * initscr() or newterm() already did putp(enter_ca_mode) as a side 	 * effect of initializing the screen.  It would be nice to not even 	 * do that, but we do not really have access to the correct copy of 	 * the terminfo description until those functions have been invoked. 	 */
operator|(
name|void
operator|)
name|putp
argument_list|(
name|exit_ca_mode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putp
argument_list|(
name|clear_screen
argument_list|)
expr_stmt|;
comment|/* 	 * Prevent ncurses from switching "back" to the normal screen when 	 * exiting from dialog.  That would move the cursor to the original 	 * location saved in xterm.  Normally curses sets the cursor position 	 * to the first line after the display, but the alternate screen 	 * switching is done after that point. 	 * 	 * Cancelling the strings altogether also works around the buggy 	 * implementation of alternate-screen in rxvt, etc., which clear 	 * more of the display than they should. 	 */
name|enter_ca_mode
operator|=
literal|0
expr_stmt|;
name|exit_ca_mode
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_FLUSHINP
operator|(
name|void
operator|)
name|flushinp
argument_list|()
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cbreak
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|noecho
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|dialog_state
operator|.
name|no_mouse
condition|)
block|{
name|mouse_open
argument_list|()
expr_stmt|;
block|}
name|dialog_state
operator|.
name|screen_initialized
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_COLOR
if|if
condition|(
name|dialog_state
operator|.
name|use_colors
operator|||
name|dialog_state
operator|.
name|use_shadow
condition|)
name|dlg_color_setup
argument_list|()
expr_stmt|;
comment|/* Set up colors */
endif|#
directive|endif
comment|/* Set screen to screen attribute */
name|dlg_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_COLOR
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|defined_colors
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pair-0 is reserved */
end_comment

begin_comment
comment|/*  * Setup for color display  */
end_comment

begin_function
name|void
name|dlg_color_setup
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
comment|/* Terminal supports color? */
operator|(
name|void
operator|)
name|start_color
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_USE_DEFAULT_COLORS
argument_list|)
name|use_default_colors
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_CURSES_
argument_list|)
define|#
directive|define
name|C_ATTR
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x) != 0 ? A_BOLD :  0) | COLOR_PAIR((y)))
comment|/* work around bug in NetBSD curses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|dlg_color_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dlg_color_table
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* Initialize color pairs */
operator|(
name|void
operator|)
name|init_pair
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|dlg_color_table
index|[
name|i
index|]
operator|.
name|fg
argument_list|,
name|dlg_color_table
index|[
name|i
index|]
operator|.
name|bg
argument_list|)
expr_stmt|;
comment|/* Setup color attributes */
name|dlg_color_table
index|[
name|i
index|]
operator|.
name|atr
operator|=
name|C_ATTR
argument_list|(
name|dlg_color_table
index|[
name|i
index|]
operator|.
name|hilite
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|defined_colors
operator|=
name|i
operator|+
literal|1
expr_stmt|;
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|dlg_color_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dlg_color_table
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* Initialize color pairs */
name|chtype
name|color
init|=
name|dlg_color_pair
argument_list|(
name|dlg_color_table
index|[
name|i
index|]
operator|.
name|fg
argument_list|,
name|dlg_color_table
index|[
name|i
index|]
operator|.
name|bg
argument_list|)
decl_stmt|;
comment|/* Setup color attributes */
name|dlg_color_table
index|[
name|i
index|]
operator|.
name|atr
operator|=
operator|(
operator|(
name|dlg_color_table
index|[
name|i
index|]
operator|.
name|hilite
condition|?
name|A_BOLD
else|:
literal|0
operator|)
operator||
name|color
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|dialog_state
operator|.
name|use_colors
operator|=
name|FALSE
expr_stmt|;
name|dialog_state
operator|.
name|use_shadow
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|dlg_color_count
parameter_list|(
name|void
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|dlg_color_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dlg_color_table
index|[
literal|0
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wrapper for getattrs(), or the more cumbersome X/Open wattr_get().  */
end_comment

begin_function
name|chtype
name|dlg_get_attrs
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|chtype
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETATTRS
name|result
operator|=
name|getattrs
argument_list|(
name|win
argument_list|)
expr_stmt|;
else|#
directive|else
name|attr_t
name|my_result
decl_stmt|;
name|short
name|my_pair
decl_stmt|;
name|wattr_get
argument_list|(
name|win
argument_list|,
operator|&
name|my_result
argument_list|,
operator|&
name|my_pair
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|my_result
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Reuse color pairs (they are limited), returning a COLOR_PAIR() value if we  * have (or can) define a pair with the given color as foreground on the  * window's defined background.  */
end_comment

begin_function
name|chtype
name|dlg_color_pair
parameter_list|(
name|int
name|foreground
parameter_list|,
name|int
name|background
parameter_list|)
block|{
name|chtype
name|result
init|=
literal|0
decl_stmt|;
name|int
name|pair
decl_stmt|;
name|short
name|fg
decl_stmt|,
name|bg
decl_stmt|;
name|bool
name|found
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|pair
operator|=
literal|1
init|;
name|pair
operator|<
name|defined_colors
condition|;
operator|++
name|pair
control|)
block|{
if|if
condition|(
name|pair_content
argument_list|(
operator|(
name|short
operator|)
name|pair
argument_list|,
operator|&
name|fg
argument_list|,
operator|&
name|bg
argument_list|)
operator|!=
name|ERR
operator|&&
name|fg
operator|==
name|foreground
operator|&&
name|bg
operator|==
name|background
condition|)
block|{
name|result
operator|=
operator|(
name|chtype
operator|)
name|COLOR_PAIR
argument_list|(
name|pair
argument_list|)
expr_stmt|;
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
operator|&&
operator|(
name|defined_colors
operator|+
literal|1
operator|)
operator|<
name|COLOR_PAIRS
condition|)
block|{
name|pair
operator|=
name|defined_colors
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|init_pair
argument_list|(
operator|(
name|short
operator|)
name|pair
argument_list|,
operator|(
name|short
operator|)
name|foreground
argument_list|,
operator|(
name|short
operator|)
name|background
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|chtype
operator|)
name|COLOR_PAIR
argument_list|(
name|pair
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Reuse color pairs (they are limited), returning a COLOR_PAIR() value if we  * have (or can) define a pair with the given color as foreground on the  * window's defined background.  */
end_comment

begin_function
specifier|static
name|chtype
name|define_color
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|foreground
parameter_list|)
block|{
name|chtype
name|attrs
init|=
name|dlg_get_attrs
argument_list|(
name|win
argument_list|)
decl_stmt|;
name|int
name|pair
decl_stmt|;
name|short
name|fg
decl_stmt|,
name|bg
decl_stmt|,
name|background
decl_stmt|;
if|if
condition|(
operator|(
name|pair
operator|=
name|PAIR_NUMBER
argument_list|(
name|attrs
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|pair_content
argument_list|(
operator|(
name|short
operator|)
name|pair
argument_list|,
operator|&
name|fg
argument_list|,
operator|&
name|bg
argument_list|)
operator|!=
name|ERR
condition|)
block|{
name|background
operator|=
name|bg
expr_stmt|;
block|}
else|else
block|{
name|background
operator|=
name|COLOR_BLACK
expr_stmt|;
block|}
return|return
name|dlg_color_pair
argument_list|(
name|foreground
argument_list|,
name|background
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * End using dialog functions.  */
end_comment

begin_function
name|void
name|end_dialog
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|dialog_state
operator|.
name|screen_initialized
condition|)
block|{
name|dialog_state
operator|.
name|screen_initialized
operator|=
name|FALSE
expr_stmt|;
name|mouse_close
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|endwin
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|isOurEscape
parameter_list|(
name|p
parameter_list|)
value|(((p)[0] == '\\')&& ((p)[1] == 'Z')&& ((p)[2] != 0))
end_define

begin_function
specifier|static
name|int
name|centered
parameter_list|(
name|int
name|width
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|int
name|len
init|=
name|dlg_count_columns
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|left
decl_stmt|;
name|int
name|hide
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|colors
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|len
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
name|isOurEscape
argument_list|(
name|string
operator|+
name|n
argument_list|)
condition|)
block|{
name|hide
operator|+=
literal|3
expr_stmt|;
block|}
block|}
block|}
name|left
operator|=
operator|(
name|width
operator|-
operator|(
name|len
operator|-
name|hide
operator|)
operator|)
operator|/
literal|2
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|left
operator|<
literal|0
condition|)
name|left
operator|=
literal|0
expr_stmt|;
return|return
name|left
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WIDE_CURSES
end_ifdef

begin_function
specifier|static
name|bool
name|is_combining
parameter_list|(
specifier|const
name|char
modifier|*
name|txt
parameter_list|,
name|int
modifier|*
name|combined
parameter_list|)
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|*
name|combined
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|UCH
argument_list|(
operator|*
name|txt
argument_list|)
operator|>=
literal|128
condition|)
block|{
name|wchar_t
name|wch
decl_stmt|;
name|mbstate_t
name|state
decl_stmt|;
name|size_t
name|given
init|=
name|strlen
argument_list|(
name|txt
argument_list|)
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wch
argument_list|,
name|txt
argument_list|,
name|given
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|len
operator|>
literal|0
operator|&&
name|wcwidth
argument_list|(
name|wch
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|combined
operator|=
operator|(
name|int
operator|)
name|len
operator|-
literal|1
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
operator|*
name|combined
operator|-=
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Print up to 'cols' columns from 'text', optionally rendering our escape  * sequence for attributes and color.  */
end_comment

begin_function
name|void
name|dlg_print_text
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
specifier|const
name|char
modifier|*
name|txt
parameter_list|,
name|int
name|cols
parameter_list|,
name|chtype
modifier|*
name|attr
parameter_list|)
block|{
name|int
name|y_origin
decl_stmt|,
name|x_origin
decl_stmt|;
name|int
name|y_before
decl_stmt|,
name|x_before
init|=
literal|0
decl_stmt|;
name|int
name|y_after
decl_stmt|,
name|x_after
decl_stmt|;
name|int
name|tabbed
init|=
literal|0
decl_stmt|;
name|bool
name|thisTab
decl_stmt|;
name|bool
name|ended
init|=
name|FALSE
decl_stmt|;
name|chtype
name|useattr
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_WIDE_CURSES
name|int
name|combined
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|getyx
argument_list|(
name|win
argument_list|,
name|y_origin
argument_list|,
name|x_origin
argument_list|)
expr_stmt|;
while|while
condition|(
name|cols
operator|>
literal|0
operator|&&
operator|(
operator|*
name|txt
operator|!=
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|dialog_vars
operator|.
name|colors
condition|)
block|{
while|while
condition|(
name|isOurEscape
argument_list|(
name|txt
argument_list|)
condition|)
block|{
name|int
name|code
decl_stmt|;
name|txt
operator|+=
literal|2
expr_stmt|;
switch|switch
condition|(
name|code
operator|=
name|CharOf
argument_list|(
operator|*
name|txt
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_COLOR
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
operator|*
name|attr
operator|&=
operator|~
name|A_COLOR
expr_stmt|;
operator|*
name|attr
operator||=
name|define_color
argument_list|(
name|win
argument_list|,
name|code
operator|-
literal|'0'
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'B'
case|:
operator|*
name|attr
operator|&=
operator|~
name|A_BOLD
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|attr
operator||=
name|A_BOLD
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
operator|*
name|attr
operator|&=
operator|~
name|A_REVERSE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|attr
operator||=
name|A_REVERSE
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
operator|*
name|attr
operator|&=
operator|~
name|A_UNDERLINE
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
operator|*
name|attr
operator||=
name|A_UNDERLINE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|attr
operator|=
name|A_NORMAL
expr_stmt|;
break|break;
block|}
operator|++
name|txt
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ended
operator|||
operator|*
name|txt
operator|==
literal|'\n'
operator|||
operator|*
name|txt
operator|==
literal|'\0'
condition|)
break|break;
name|useattr
operator|=
operator|(
operator|*
name|attr
operator|)
operator|&
name|A_ATTRIBUTES
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_COLOR
comment|/* 	 * Prevent this from making text invisible when the foreground and 	 * background colors happen to be the same, and there's no bold 	 * attribute. 	 */
if|if
condition|(
operator|(
name|useattr
operator|&
name|A_COLOR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|useattr
operator|&
name|A_BOLD
operator|)
operator|==
literal|0
condition|)
block|{
name|short
name|pair
init|=
operator|(
name|short
operator|)
name|PAIR_NUMBER
argument_list|(
name|useattr
argument_list|)
decl_stmt|;
name|short
name|fg
decl_stmt|,
name|bg
decl_stmt|;
if|if
condition|(
name|pair_content
argument_list|(
name|pair
argument_list|,
operator|&
name|fg
argument_list|,
operator|&
name|bg
argument_list|)
operator|!=
name|ERR
operator|&&
name|fg
operator|==
name|bg
condition|)
block|{
name|useattr
operator|&=
operator|~
name|A_COLOR
expr_stmt|;
name|useattr
operator||=
name|dlg_color_pair
argument_list|(
name|fg
argument_list|,
operator|(
operator|(
name|bg
operator|==
name|COLOR_BLACK
operator|)
condition|?
name|COLOR_WHITE
else|:
name|COLOR_BLACK
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Write the character, using curses to tell exactly how wide it 	 * is.  If it is a tab, discount that, since the caller thinks 	 * tabs are nonprinting, and curses will expand tabs to one or 	 * more blanks. 	 */
name|thisTab
operator|=
operator|(
name|CharOf
argument_list|(
operator|*
name|txt
argument_list|)
operator|==
name|TAB
operator|)
expr_stmt|;
if|if
condition|(
name|thisTab
condition|)
name|getyx
argument_list|(
name|win
argument_list|,
name|y_before
argument_list|,
name|x_before
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|win
argument_list|,
name|CharOf
argument_list|(
operator|*
name|txt
operator|++
argument_list|)
operator||
name|useattr
argument_list|)
expr_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|y_after
argument_list|,
name|x_after
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisTab
operator|&&
operator|(
name|y_after
operator|==
name|y_origin
operator|)
condition|)
name|tabbed
operator|+=
operator|(
name|x_after
operator|-
name|x_before
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|y_after
operator|!=
name|y_origin
operator|)
operator|||
operator|(
name|x_after
operator|>=
operator|(
name|cols
operator|+
name|tabbed
operator|+
name|x_origin
operator|)
ifdef|#
directive|ifdef
name|USE_WIDE_CURSES
operator|&&
operator|!
name|is_combining
argument_list|(
name|txt
argument_list|,
operator|&
name|combined
argument_list|)
endif|#
directive|endif
operator|)
condition|)
block|{
name|ended
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Print one line of the prompt in the window within the limits of the  * specified right margin.  The line will end on a word boundary and a pointer  * to the start of the next line is returned, or a NULL pointer if the end of  * *prompt is reached.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|dlg_print_line
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|chtype
modifier|*
name|attr
parameter_list|,
specifier|const
name|char
modifier|*
name|prompt
parameter_list|,
name|int
name|lm
parameter_list|,
name|int
name|rm
parameter_list|,
name|int
modifier|*
name|x
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|wrap_ptr
init|=
name|prompt
decl_stmt|;
specifier|const
name|char
modifier|*
name|test_ptr
init|=
name|prompt
decl_stmt|;
specifier|const
name|int
modifier|*
name|cols
init|=
name|dlg_index_columns
argument_list|(
name|prompt
argument_list|)
decl_stmt|;
specifier|const
name|int
modifier|*
name|indx
init|=
name|dlg_index_wchars
argument_list|(
name|prompt
argument_list|)
decl_stmt|;
name|int
name|wrap_inx
init|=
literal|0
decl_stmt|;
name|int
name|test_inx
init|=
literal|0
decl_stmt|;
name|int
name|cur_x
init|=
name|lm
decl_stmt|;
name|int
name|hidden
init|=
literal|0
decl_stmt|;
name|int
name|limit
init|=
name|dlg_count_wchars
argument_list|(
name|prompt
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|tabbed
init|=
literal|0
decl_stmt|;
operator|*
name|x
operator|=
literal|1
expr_stmt|;
comment|/*      * Set *test_ptr to the end of the line or the right margin (rm), whichever      * is less, and set wrap_ptr to the end of the last word in the line.      */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|limit
condition|;
operator|++
name|n
control|)
block|{
name|test_ptr
operator|=
name|prompt
operator|+
name|indx
index|[
name|test_inx
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|test_ptr
operator|==
literal|'\n'
operator|||
operator|*
name|test_ptr
operator|==
literal|'\0'
operator|||
name|cur_x
operator|>=
operator|(
name|rm
operator|+
name|hidden
operator|)
condition|)
break|break;
if|if
condition|(
operator|*
name|test_ptr
operator|==
name|TAB
operator|&&
name|n
operator|==
literal|0
condition|)
block|{
name|tabbed
operator|=
literal|8
expr_stmt|;
comment|/* workaround for leading tabs */
block|}
elseif|else
if|if
condition|(
operator|*
name|test_ptr
operator|==
literal|' '
operator|&&
name|n
operator|!=
literal|0
operator|&&
name|prompt
index|[
name|indx
index|[
name|n
operator|-
literal|1
index|]
index|]
operator|!=
literal|' '
condition|)
block|{
name|wrap_inx
operator|=
name|n
expr_stmt|;
operator|*
name|x
operator|=
name|cur_x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isOurEscape
argument_list|(
name|test_ptr
argument_list|)
condition|)
block|{
name|hidden
operator|+=
literal|3
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
block|}
name|cur_x
operator|=
name|lm
operator|+
name|tabbed
operator|+
name|cols
index|[
name|n
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|cur_x
operator|>
operator|(
name|rm
operator|+
name|hidden
operator|)
condition|)
break|break;
name|test_inx
operator|=
name|n
operator|+
literal|1
expr_stmt|;
block|}
comment|/*      * If the line doesn't reach the right margin in the middle of a word, then      * we don't have to wrap it at the end of the previous word.      */
name|test_ptr
operator|=
name|prompt
operator|+
name|indx
index|[
name|test_inx
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|test_ptr
operator|==
literal|'\n'
operator|||
operator|*
name|test_ptr
operator|==
literal|' '
operator|||
operator|*
name|test_ptr
operator|==
literal|'\0'
condition|)
block|{
name|wrap_inx
operator|=
name|test_inx
expr_stmt|;
while|while
condition|(
name|wrap_inx
operator|>
literal|0
operator|&&
name|prompt
index|[
name|indx
index|[
name|wrap_inx
operator|-
literal|1
index|]
index|]
operator|==
literal|' '
condition|)
block|{
name|wrap_inx
operator|--
expr_stmt|;
block|}
operator|*
name|x
operator|=
name|lm
operator|+
name|indx
index|[
name|wrap_inx
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|x
operator|==
literal|1
operator|&&
name|cur_x
operator|>=
name|rm
condition|)
block|{
comment|/* 	 * If the line has no spaces, then wrap it anyway at the right margin 	 */
operator|*
name|x
operator|=
name|rm
expr_stmt|;
name|wrap_inx
operator|=
name|test_inx
expr_stmt|;
block|}
name|wrap_ptr
operator|=
name|prompt
operator|+
name|indx
index|[
name|wrap_inx
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WIDE_CURSES
if|if
condition|(
name|UCH
argument_list|(
operator|*
name|wrap_ptr
argument_list|)
operator|>=
literal|128
condition|)
block|{
name|int
name|combined
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|is_combining
argument_list|(
name|wrap_ptr
argument_list|,
operator|&
name|combined
argument_list|)
condition|)
block|{
operator|++
name|wrap_ptr
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/*      * Print the line if we have a window pointer.  Otherwise this routine      * is just being called for sizing the window.      */
if|if
condition|(
name|win
condition|)
block|{
name|dlg_print_text
argument_list|(
name|win
argument_list|,
name|prompt
argument_list|,
operator|(
name|cols
index|[
name|wrap_inx
index|]
operator|-
name|hidden
operator|)
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
comment|/* *x tells the calling function how long the line was */
if|if
condition|(
operator|*
name|x
operator|==
literal|1
condition|)
operator|*
name|x
operator|=
name|rm
expr_stmt|;
comment|/* Find the start of the next line and return a pointer to it */
name|test_ptr
operator|=
name|wrap_ptr
expr_stmt|;
while|while
condition|(
operator|*
name|test_ptr
operator|==
literal|' '
condition|)
name|test_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|test_ptr
operator|==
literal|'\n'
condition|)
name|test_ptr
operator|++
expr_stmt|;
return|return
operator|(
name|test_ptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|justify_text
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
specifier|const
name|char
modifier|*
name|prompt
parameter_list|,
name|int
name|limit_y
parameter_list|,
name|int
name|limit_x
parameter_list|,
name|int
modifier|*
name|high
parameter_list|,
name|int
modifier|*
name|wide
parameter_list|)
block|{
name|chtype
name|attr
init|=
name|A_NORMAL
decl_stmt|;
name|int
name|x
init|=
operator|(
literal|2
operator|*
name|MARGIN
operator|)
decl_stmt|;
name|int
name|y
init|=
name|MARGIN
decl_stmt|;
name|int
name|max_x
init|=
literal|2
decl_stmt|;
name|int
name|lm
init|=
operator|(
literal|2
operator|*
name|MARGIN
operator|)
decl_stmt|;
comment|/* left margin (box-border plus a space) */
name|int
name|rm
init|=
name|limit_x
decl_stmt|;
comment|/* right margin */
name|int
name|bm
init|=
name|limit_y
decl_stmt|;
comment|/* bottom margin */
name|int
name|last_y
init|=
literal|0
decl_stmt|,
name|last_x
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|win
condition|)
block|{
name|rm
operator|-=
operator|(
literal|2
operator|*
name|MARGIN
operator|)
expr_stmt|;
name|bm
operator|-=
operator|(
literal|2
operator|*
name|MARGIN
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|prompt
operator|==
literal|0
condition|)
name|prompt
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|win
operator|!=
literal|0
condition|)
name|getyx
argument_list|(
name|win
argument_list|,
name|last_y
argument_list|,
name|last_x
argument_list|)
expr_stmt|;
while|while
condition|(
name|y
operator|<=
name|bm
operator|&&
operator|*
name|prompt
condition|)
block|{
name|x
operator|=
name|lm
expr_stmt|;
if|if
condition|(
operator|*
name|prompt
operator|==
literal|'\n'
condition|)
block|{
while|while
condition|(
operator|*
name|prompt
operator|==
literal|'\n'
operator|&&
name|y
operator|<
name|bm
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|prompt
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
block|{
operator|++
name|y
expr_stmt|;
if|if
condition|(
name|win
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|lm
argument_list|)
expr_stmt|;
block|}
name|prompt
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|win
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|lm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|prompt
condition|)
block|{
name|prompt
operator|=
name|dlg_print_line
argument_list|(
name|win
argument_list|,
operator|&
name|attr
argument_list|,
name|prompt
argument_list|,
name|lm
argument_list|,
name|rm
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|!=
literal|0
condition|)
name|getyx
argument_list|(
name|win
argument_list|,
name|last_y
argument_list|,
name|last_x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|prompt
condition|)
block|{
operator|++
name|y
expr_stmt|;
if|if
condition|(
name|win
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|lm
argument_list|)
expr_stmt|;
block|}
name|max_x
operator|=
name|MAX
argument_list|(
name|max_x
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Move back to the last position after drawing prompt, for msgbox. */
if|if
condition|(
name|win
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|win
argument_list|,
name|last_y
argument_list|,
name|last_x
argument_list|)
expr_stmt|;
comment|/* Set the final height and width for the calling function */
if|if
condition|(
name|high
operator|!=
literal|0
condition|)
operator|*
name|high
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|wide
operator|!=
literal|0
condition|)
operator|*
name|wide
operator|=
name|max_x
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a string of text in a window, automatically wrap around to the next  * line if the string is too long to fit on one line.  Note that the string may  * contain embedded newlines.  */
end_comment

begin_function
name|void
name|dlg_print_autowrap
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
specifier|const
name|char
modifier|*
name|prompt
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|justify_text
argument_list|(
name|win
argument_list|,
name|prompt
argument_list|,
name|height
argument_list|,
name|width
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display the message in a scrollable window.  Actually the way it works is  * that we create a "tall" window of the proper width, let the text wrap within  * that, and copy a slice of the result to the dialog.  *  * It works for ncurses.  Other curses implementations show only blanks (Tru64)  * or garbage (NetBSD).  */
end_comment

begin_function
name|int
name|dlg_print_scrolled
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
specifier|const
name|char
modifier|*
name|prompt
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|pauseopt
parameter_list|)
block|{
name|int
name|oldy
decl_stmt|,
name|oldx
decl_stmt|;
name|int
name|last
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|pauseopt
expr_stmt|;
comment|/* used only for ncurses */
name|getyx
argument_list|(
name|win
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_VERSION
if|if
condition|(
name|pauseopt
condition|)
block|{
name|int
name|wide
init|=
name|width
operator|-
operator|(
literal|2
operator|*
name|MARGIN
operator|)
decl_stmt|;
name|int
name|high
init|=
name|LINES
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|percent
decl_stmt|;
name|WINDOW
modifier|*
name|dummy
decl_stmt|;
name|char
name|buffer
index|[
literal|5
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NCURSES_VERSION_PATCH
argument_list|)
operator|&&
name|NCURSES_VERSION_PATCH
operator|>=
literal|20040417
comment|/* 	 * If we're not limited by the screensize, allow text to possibly be 	 * one character per line. 	 */
if|if
condition|(
operator|(
name|len
operator|=
name|dlg_count_columns
argument_list|(
name|prompt
argument_list|)
operator|)
operator|>
name|high
condition|)
name|high
operator|=
name|len
expr_stmt|;
endif|#
directive|endif
name|dummy
operator|=
name|newwin
argument_list|(
name|high
argument_list|,
name|width
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wbkgdset
argument_list|(
name|dummy
argument_list|,
name|dialog_attr
operator||
literal|' '
argument_list|)
expr_stmt|;
name|wattrset
argument_list|(
name|dummy
argument_list|,
name|dialog_attr
argument_list|)
expr_stmt|;
name|werase
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|dlg_print_autowrap
argument_list|(
name|dummy
argument_list|,
name|prompt
argument_list|,
name|high
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|getyx
argument_list|(
name|dummy
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|copywin
argument_list|(
name|dummy
argument_list|,
comment|/* srcwin */
name|win
argument_list|,
comment|/* dstwin */
name|offset
operator|+
name|MARGIN
argument_list|,
comment|/* sminrow */
name|MARGIN
argument_list|,
comment|/* smincol */
name|MARGIN
argument_list|,
comment|/* dminrow */
name|MARGIN
argument_list|,
comment|/* dmincol */
name|height
argument_list|,
comment|/* dmaxrow */
name|wide
argument_list|,
comment|/* dmaxcol */
name|FALSE
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
comment|/* if the text is incomplete, or we have scrolled, show the percentage */
if|if
condition|(
name|y
operator|>
literal|0
operator|&&
name|wide
operator|>
literal|4
condition|)
block|{
name|percent
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|height
operator|+
name|offset
operator|)
operator|*
literal|100.0
operator|/
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|percent
operator|<
literal|0
condition|)
name|percent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|percent
operator|>
literal|100
condition|)
name|percent
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
operator|||
name|percent
operator|!=
literal|100
condition|)
block|{
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|win
argument_list|,
name|position_indicator_attr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|win
argument_list|,
name|MARGIN
operator|+
name|height
argument_list|,
name|wide
operator|-
literal|4
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d%%"
argument_list|,
name|percent
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|waddstr
argument_list|(
name|win
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|)
operator|<
literal|4
condition|)
block|{
name|wattrset
argument_list|(
name|win
argument_list|,
name|border_attr
argument_list|)
expr_stmt|;
name|whline
argument_list|(
name|win
argument_list|,
name|dlg_boxchar
argument_list|(
name|ACS_HLINE
argument_list|)
argument_list|,
literal|4
operator|-
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|last
operator|=
operator|(
name|y
operator|-
name|height
operator|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
operator|(
name|void
operator|)
name|offset
expr_stmt|;
name|wattrset
argument_list|(
name|win
argument_list|,
name|dialog_attr
argument_list|)
expr_stmt|;
name|dlg_print_autowrap
argument_list|(
name|win
argument_list|,
name|prompt
argument_list|,
name|height
operator|+
literal|1
operator|+
operator|(
literal|3
operator|*
name|MARGIN
operator|)
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
block|}
name|wmove
argument_list|(
name|win
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
return|return
name|last
return|;
block|}
end_function

begin_function
name|int
name|dlg_check_scrolled
parameter_list|(
name|int
name|key
parameter_list|,
name|int
name|last
parameter_list|,
name|int
name|page
parameter_list|,
name|bool
modifier|*
name|show
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|)
block|{
name|int
name|code
init|=
literal|0
decl_stmt|;
operator|*
name|show
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|DLGK_PAGE_FIRST
case|:
if|if
condition|(
operator|*
name|offset
operator|>
literal|0
condition|)
block|{
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
operator|*
name|show
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|DLGK_PAGE_LAST
case|:
if|if
condition|(
operator|*
name|offset
operator|<
name|last
condition|)
block|{
operator|*
name|offset
operator|=
name|last
expr_stmt|;
operator|*
name|show
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|DLGK_GRID_UP
case|:
if|if
condition|(
operator|*
name|offset
operator|>
literal|0
condition|)
block|{
operator|--
operator|(
operator|*
name|offset
operator|)
expr_stmt|;
operator|*
name|show
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|DLGK_GRID_DOWN
case|:
if|if
condition|(
operator|*
name|offset
operator|<
name|last
condition|)
block|{
operator|++
operator|(
operator|*
name|offset
operator|)
expr_stmt|;
operator|*
name|show
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|DLGK_PAGE_PREV
case|:
if|if
condition|(
operator|*
name|offset
operator|>
literal|0
condition|)
block|{
operator|*
name|offset
operator|-=
name|page
expr_stmt|;
if|if
condition|(
operator|*
name|offset
operator|<
literal|0
condition|)
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
operator|*
name|show
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|DLGK_PAGE_NEXT
case|:
if|if
condition|(
operator|*
name|offset
operator|<
name|last
condition|)
block|{
operator|*
name|offset
operator|+=
name|page
expr_stmt|;
if|if
condition|(
operator|*
name|offset
operator|>
name|last
condition|)
operator|*
name|offset
operator|=
name|last
expr_stmt|;
operator|*
name|show
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
default|default:
name|code
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the window size for preformatted text.  This will calculate box  * dimensions that are at or close to the specified aspect ratio for the prompt  * string with all spaces and newlines preserved and additional newlines added  * as necessary.  */
end_comment

begin_function
specifier|static
name|void
name|auto_size_preformatted
parameter_list|(
specifier|const
name|char
modifier|*
name|prompt
parameter_list|,
name|int
modifier|*
name|height
parameter_list|,
name|int
modifier|*
name|width
parameter_list|)
block|{
name|int
name|high
init|=
literal|0
decl_stmt|,
name|wide
init|=
literal|0
decl_stmt|;
name|float
name|car
decl_stmt|;
comment|/* Calculated Aspect Ratio */
name|float
name|diff
decl_stmt|;
name|int
name|max_y
init|=
name|SLINES
operator|-
literal|1
decl_stmt|;
name|int
name|max_x
init|=
name|SCOLS
operator|-
literal|2
decl_stmt|;
name|int
name|max_width
init|=
name|max_x
decl_stmt|;
name|int
name|ar
init|=
name|dialog_state
operator|.
name|aspect_ratio
decl_stmt|;
comment|/* Get the initial dimensions */
name|justify_text
argument_list|(
operator|(
name|WINDOW
operator|*
operator|)
literal|0
argument_list|,
name|prompt
argument_list|,
name|max_y
argument_list|,
name|max_x
argument_list|,
operator|&
name|high
argument_list|,
operator|&
name|wide
argument_list|)
expr_stmt|;
name|car
operator|=
call|(
name|float
call|)
argument_list|(
name|wide
operator|/
name|high
argument_list|)
expr_stmt|;
comment|/*      * If the aspect ratio is greater than it should be, then decrease the      * width proportionately.      */
if|if
condition|(
name|car
operator|>
name|ar
condition|)
block|{
name|diff
operator|=
name|car
operator|/
operator|(
name|float
operator|)
name|ar
expr_stmt|;
name|max_x
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|float
operator|)
name|wide
operator|/
name|diff
operator|+
literal|4
argument_list|)
expr_stmt|;
name|justify_text
argument_list|(
operator|(
name|WINDOW
operator|*
operator|)
literal|0
argument_list|,
name|prompt
argument_list|,
name|max_y
argument_list|,
name|max_x
argument_list|,
operator|&
name|high
argument_list|,
operator|&
name|wide
argument_list|)
expr_stmt|;
name|car
operator|=
operator|(
name|float
operator|)
name|wide
operator|/
operator|(
name|float
operator|)
name|high
expr_stmt|;
block|}
comment|/*      * If the aspect ratio is too small after decreasing the width, then      * incrementally increase the width until the aspect ratio is equal to or      * greater than the specified aspect ratio.      */
while|while
condition|(
name|car
operator|<
name|ar
operator|&&
name|max_x
operator|<
name|max_width
condition|)
block|{
name|max_x
operator|+=
literal|4
expr_stmt|;
name|justify_text
argument_list|(
operator|(
name|WINDOW
operator|*
operator|)
literal|0
argument_list|,
name|prompt
argument_list|,
name|max_y
argument_list|,
name|max_x
argument_list|,
operator|&
name|high
argument_list|,
operator|&
name|wide
argument_list|)
expr_stmt|;
name|car
operator|=
call|(
name|float
call|)
argument_list|(
name|wide
operator|/
name|high
argument_list|)
expr_stmt|;
block|}
operator|*
name|height
operator|=
name|high
expr_stmt|;
operator|*
name|width
operator|=
name|wide
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the length of the longest "word" in the given string.  By setting the  * widget width at least this long, we can avoid splitting a word on the  * margin.  */
end_comment

begin_function
specifier|static
name|int
name|longest_word
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|int
name|length
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|string
operator|!=
literal|'\0'
condition|)
block|{
name|length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|string
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
name|UCH
argument_list|(
operator|*
name|string
argument_list|)
argument_list|)
condition|)
block|{
name|length
operator|++
expr_stmt|;
name|string
operator|++
expr_stmt|;
block|}
name|result
operator|=
name|MAX
argument_list|(
name|result
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|!=
literal|'\0'
condition|)
name|string
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * if (height or width == -1) Maximize()  * if (height or width == 0), justify and return actual limits.  */
end_comment

begin_function
specifier|static
name|void
name|real_auto_size
parameter_list|(
specifier|const
name|char
modifier|*
name|title
parameter_list|,
specifier|const
name|char
modifier|*
name|prompt
parameter_list|,
name|int
modifier|*
name|height
parameter_list|,
name|int
modifier|*
name|width
parameter_list|,
name|int
name|boxlines
parameter_list|,
name|int
name|mincols
parameter_list|)
block|{
name|int
name|x
init|=
operator|(
name|dialog_vars
operator|.
name|begin_set
condition|?
name|dialog_vars
operator|.
name|begin_x
else|:
literal|2
operator|)
decl_stmt|;
name|int
name|y
init|=
operator|(
name|dialog_vars
operator|.
name|begin_set
condition|?
name|dialog_vars
operator|.
name|begin_y
else|:
literal|1
operator|)
decl_stmt|;
name|int
name|title_length
init|=
name|title
condition|?
name|dlg_count_columns
argument_list|(
name|title
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|nc
init|=
literal|4
decl_stmt|;
name|int
name|high
decl_stmt|;
name|int
name|wide
decl_stmt|;
name|int
name|save_high
init|=
operator|*
name|height
decl_stmt|;
name|int
name|save_wide
init|=
operator|*
name|width
decl_stmt|;
if|if
condition|(
name|prompt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|height
operator|==
literal|0
condition|)
operator|*
name|height
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|width
operator|==
literal|0
condition|)
operator|*
name|width
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|height
operator|>
literal|0
condition|)
block|{
name|high
operator|=
operator|*
name|height
expr_stmt|;
block|}
else|else
block|{
name|high
operator|=
name|SLINES
operator|-
name|y
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|width
operator|>
literal|0
condition|)
block|{
name|wide
operator|=
operator|*
name|width
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prompt
operator|!=
literal|0
condition|)
block|{
name|wide
operator|=
name|MAX
argument_list|(
name|title_length
argument_list|,
name|mincols
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|prompt
argument_list|,
literal|'\n'
argument_list|)
operator|==
literal|0
condition|)
block|{
name|double
name|val
init|=
name|dialog_state
operator|.
name|aspect_ratio
operator|*
name|dlg_count_columns
argument_list|(
name|prompt
argument_list|)
decl_stmt|;
name|double
name|xxx
init|=
name|sqrt
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|int
name|tmp
init|=
operator|(
name|int
operator|)
name|xxx
decl_stmt|;
name|wide
operator|=
name|MAX
argument_list|(
name|wide
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|wide
operator|=
name|MAX
argument_list|(
name|wide
argument_list|,
name|longest_word
argument_list|(
name|prompt
argument_list|)
argument_list|)
expr_stmt|;
name|justify_text
argument_list|(
operator|(
name|WINDOW
operator|*
operator|)
literal|0
argument_list|,
name|prompt
argument_list|,
name|high
argument_list|,
name|wide
argument_list|,
name|height
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|auto_size_preformatted
argument_list|(
name|prompt
argument_list|,
name|height
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|wide
operator|=
name|SCOLS
operator|-
name|x
expr_stmt|;
name|justify_text
argument_list|(
operator|(
name|WINDOW
operator|*
operator|)
literal|0
argument_list|,
name|prompt
argument_list|,
name|high
argument_list|,
name|wide
argument_list|,
name|height
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|width
operator|<
name|title_length
condition|)
block|{
name|justify_text
argument_list|(
operator|(
name|WINDOW
operator|*
operator|)
literal|0
argument_list|,
name|prompt
argument_list|,
name|high
argument_list|,
name|title_length
argument_list|,
name|height
argument_list|,
name|width
argument_list|)
expr_stmt|;
operator|*
name|width
operator|=
name|title_length
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|width
operator|<
name|mincols
operator|&&
name|save_wide
operator|==
literal|0
condition|)
operator|*
name|width
operator|=
name|mincols
expr_stmt|;
if|if
condition|(
name|prompt
operator|!=
literal|0
condition|)
block|{
operator|*
name|width
operator|+=
name|nc
expr_stmt|;
operator|*
name|height
operator|+=
name|boxlines
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|save_high
operator|>
literal|0
condition|)
operator|*
name|height
operator|=
name|save_high
expr_stmt|;
if|if
condition|(
name|save_wide
operator|>
literal|0
condition|)
operator|*
name|width
operator|=
name|save_wide
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End of real_auto_size() */
end_comment

begin_function
name|void
name|dlg_auto_size
parameter_list|(
specifier|const
name|char
modifier|*
name|title
parameter_list|,
specifier|const
name|char
modifier|*
name|prompt
parameter_list|,
name|int
modifier|*
name|height
parameter_list|,
name|int
modifier|*
name|width
parameter_list|,
name|int
name|boxlines
parameter_list|,
name|int
name|mincols
parameter_list|)
block|{
name|real_auto_size
argument_list|(
name|title
argument_list|,
name|prompt
argument_list|,
name|height
argument_list|,
name|width
argument_list|,
name|boxlines
argument_list|,
name|mincols
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|width
operator|>
name|SCOLS
condition|)
block|{
operator|(
operator|*
name|height
operator|)
operator|++
expr_stmt|;
operator|*
name|width
operator|=
name|SCOLS
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|height
operator|>
name|SLINES
condition|)
operator|*
name|height
operator|=
name|SLINES
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * if (height or width == -1) Maximize()  * if (height or width == 0)  *    height=MIN(SLINES, num.lines in fd+n);  *    width=MIN(SCOLS, MAX(longer line+n, mincols));  */
end_comment

begin_function
name|void
name|dlg_auto_sizefile
parameter_list|(
specifier|const
name|char
modifier|*
name|title
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
modifier|*
name|height
parameter_list|,
name|int
modifier|*
name|width
parameter_list|,
name|int
name|boxlines
parameter_list|,
name|int
name|mincols
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
name|title
condition|?
name|dlg_count_columns
argument_list|(
name|title
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|nc
init|=
literal|4
decl_stmt|;
name|int
name|numlines
init|=
literal|2
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
comment|/* Open input file for reading */
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"rb"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|dlg_exiterr
argument_list|(
literal|"dlg_auto_sizefile: Cannot open input file %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|height
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
operator|*
name|width
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
operator|*
name|height
operator|=
name|SLINES
operator|-
operator|(
name|dialog_vars
operator|.
name|begin_set
condition|?
name|dialog_vars
operator|.
name|begin_y
else|:
literal|0
operator|)
expr_stmt|;
operator|*
name|width
operator|=
name|SCOLS
operator|-
operator|(
name|dialog_vars
operator|.
name|begin_set
condition|?
name|dialog_vars
operator|.
name|begin_x
else|:
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|height
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|width
operator|!=
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|width
operator|>
name|SCOLS
condition|)
operator|*
name|width
operator|=
name|SCOLS
expr_stmt|;
if|if
condition|(
operator|*
name|height
operator|>
name|SLINES
condition|)
operator|*
name|height
operator|=
name|SLINES
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fd
argument_list|)
condition|)
block|{
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|fd
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|)
operator|&&
operator|!
name|feof
argument_list|(
name|fd
argument_list|)
condition|)
if|if
condition|(
operator|(
name|ch
operator|==
name|TAB
operator|)
operator|&&
operator|(
name|dialog_vars
operator|.
name|tab_correct
operator|)
condition|)
name|offset
operator|+=
name|dialog_state
operator|.
name|tab_len
operator|-
operator|(
name|offset
operator|%
name|dialog_state
operator|.
name|tab_len
operator|)
expr_stmt|;
else|else
name|offset
operator|++
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|len
condition|)
name|len
operator|=
operator|(
name|int
operator|)
name|offset
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|/* now 'count' has the number of lines of fd and 'len' the max length */
operator|*
name|height
operator|=
name|MIN
argument_list|(
name|SLINES
argument_list|,
name|count
operator|+
name|numlines
operator|+
name|boxlines
argument_list|)
expr_stmt|;
operator|*
name|width
operator|=
name|MIN
argument_list|(
name|SCOLS
argument_list|,
name|MAX
argument_list|(
operator|(
name|len
operator|+
name|nc
operator|)
argument_list|,
name|mincols
argument_list|)
argument_list|)
expr_stmt|;
comment|/* here width and height can be maximized if> SCOLS|SLINES because        textbox-like widgets don't put all<file> on the screen.        Msgbox-like widget instead have to put all<text> correctly. */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Draw a rectangular box with line drawing characters.  *  * borderchar is used to color the upper/left edges.  *  * boxchar is used to color the right/lower edges.  It also is fill-color used  * for the box contents.  *  * Normally, if you are drawing a scrollable box, use menubox_border_attr for  * boxchar, and menubox_attr for borderchar since the scroll-arrows are drawn  * with menubox_attr at the top, and menubox_border_attr at the bottom.  That  * also (given the default color choices) produces a recessed effect.  *  * If you want a raised effect (and are not going to use the scroll-arrows),  * reverse this choice.  */
end_comment

begin_function
name|void
name|dlg_draw_box
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|,
name|chtype
name|boxchar
parameter_list|,
name|chtype
name|borderchar
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|chtype
name|save
init|=
name|dlg_get_attrs
argument_list|(
name|win
argument_list|)
decl_stmt|;
name|wattrset
argument_list|(
name|win
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|win
argument_list|,
name|y
operator|+
name|i
argument_list|,
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|width
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|i
operator|&&
operator|!
name|j
condition|)
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|win
argument_list|,
name|borderchar
operator||
name|dlg_boxchar
argument_list|(
name|ACS_ULCORNER
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|height
operator|-
literal|1
operator|&&
operator|!
name|j
condition|)
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|win
argument_list|,
name|borderchar
operator||
name|dlg_boxchar
argument_list|(
name|ACS_LLCORNER
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|i
operator|&&
name|j
operator|==
name|width
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|win
argument_list|,
name|boxchar
operator||
name|dlg_boxchar
argument_list|(
name|ACS_URCORNER
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|height
operator|-
literal|1
operator|&&
name|j
operator|==
name|width
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|win
argument_list|,
name|boxchar
operator||
name|dlg_boxchar
argument_list|(
name|ACS_LRCORNER
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|i
condition|)
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|win
argument_list|,
name|borderchar
operator||
name|dlg_boxchar
argument_list|(
name|ACS_HLINE
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|height
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|win
argument_list|,
name|boxchar
operator||
name|dlg_boxchar
argument_list|(
name|ACS_HLINE
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|j
condition|)
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|win
argument_list|,
name|borderchar
operator||
name|dlg_boxchar
argument_list|(
name|ACS_VLINE
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|==
name|width
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|win
argument_list|,
name|boxchar
operator||
name|dlg_boxchar
argument_list|(
name|ACS_VLINE
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|win
argument_list|,
name|boxchar
operator||
literal|' '
argument_list|)
expr_stmt|;
block|}
name|wattrset
argument_list|(
name|win
argument_list|,
name|save
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_COLOR
end_ifdef

begin_comment
comment|/*  * Draw a shadow on the parent window corresponding to the right- and  * bottom-edge of the child window, to give a 3-dimensional look.  */
end_comment

begin_function
specifier|static
name|void
name|draw_childs_shadow
parameter_list|(
name|WINDOW
modifier|*
name|parent
parameter_list|,
name|WINDOW
modifier|*
name|child
parameter_list|)
block|{
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
comment|/* Whether terminal supports color? */
name|chtype
name|save
init|=
name|dlg_get_attrs
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|dlg_draw_shadow
argument_list|(
name|parent
argument_list|,
name|getbegy
argument_list|(
name|child
argument_list|)
operator|-
name|getbegy
argument_list|(
name|parent
argument_list|)
argument_list|,
name|getbegx
argument_list|(
name|child
argument_list|)
operator|-
name|getbegx
argument_list|(
name|parent
argument_list|)
argument_list|,
name|getmaxy
argument_list|(
name|child
argument_list|)
argument_list|,
name|getmaxx
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|wattrset
argument_list|(
name|parent
argument_list|,
name|save
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Draw shadows along the right and bottom edge to give a more 3D look  * to the boxes  */
end_comment

begin_function
name|void
name|dlg_draw_shadow
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
comment|/* Whether terminal supports color? */
name|wattrset
argument_list|(
name|win
argument_list|,
name|shadow_attr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SHADOW_ROWS
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|width
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|wmove
argument_list|(
name|win
argument_list|,
name|i
operator|+
name|y
operator|+
name|height
argument_list|,
name|j
operator|+
name|x
operator|+
name|SHADOW_COLS
argument_list|)
operator|!=
name|ERR
condition|)
block|{
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|win
argument_list|,
name|winch
argument_list|(
name|win
argument_list|)
operator|&
call|(
name|chtype
call|)
argument_list|(
operator|~
name|A_COLOR
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SHADOW_COLS
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|wmove
argument_list|(
name|win
argument_list|,
name|i
operator|+
name|y
operator|+
name|SHADOW_ROWS
argument_list|,
name|j
operator|+
name|x
operator|+
name|width
argument_list|)
operator|!=
name|ERR
condition|)
block|{
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|win
argument_list|,
name|winch
argument_list|(
name|win
argument_list|)
operator|&
call|(
name|chtype
call|)
argument_list|(
operator|~
name|A_COLOR
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|wnoutrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_COLOR */
end_comment

begin_comment
comment|/*  * Allow shell scripts to remap the exit codes so they can distinguish ESC  * from ERROR.  */
end_comment

begin_function
name|void
name|dlg_exit
parameter_list|(
name|int
name|code
parameter_list|)
block|{
comment|/* *INDENT-OFF* */
specifier|static
specifier|const
struct|struct
block|{
name|int
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|table
index|[]
init|=
block|{
block|{
name|DLG_EXIT_CANCEL
block|,
literal|"DIALOG_CANCEL"
block|}
block|,
block|{
name|DLG_EXIT_ERROR
block|,
literal|"DIALOG_ERROR"
block|}
block|,
block|{
name|DLG_EXIT_ESC
block|,
literal|"DIALOG_ESC"
block|}
block|,
block|{
name|DLG_EXIT_EXTRA
block|,
literal|"DIALOG_EXTRA"
block|}
block|,
block|{
name|DLG_EXIT_HELP
block|,
literal|"DIALOG_HELP"
block|}
block|,
block|{
name|DLG_EXIT_OK
block|,
literal|"DIALOG_OK"
block|}
block|,
block|{
name|DLG_EXIT_ITEM_HELP
block|,
literal|"DIALOG_ITEM_HELP"
block|}
block|,     }
struct|;
comment|/* *INDENT-ON* */
name|unsigned
name|n
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|long
name|value
decl_stmt|;
name|bool
name|overridden
init|=
name|FALSE
decl_stmt|;
name|retry
label|:
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
sizeof|sizeof
argument_list|(
name|table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|table
index|[
literal|0
index|]
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|table
index|[
name|n
index|]
operator|.
name|code
operator|==
name|code
condition|)
block|{
if|if
condition|(
operator|(
name|name
operator|=
name|getenv
argument_list|(
name|table
index|[
name|n
index|]
operator|.
name|name
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|value
operator|=
name|strtol
argument_list|(
name|name
argument_list|,
operator|&
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
operator|&&
name|temp
operator|!=
name|name
operator|&&
operator|*
name|temp
operator|==
literal|'\0'
condition|)
block|{
name|code
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
name|overridden
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
comment|/*      * Prior to 2004/12/19, a widget using --item-help would exit with "OK"      * if the help button were selected.  Now we want to exit with "HELP",      * but allow the environment variable to override.      */
if|if
condition|(
name|code
operator|==
name|DLG_EXIT_ITEM_HELP
operator|&&
operator|!
name|overridden
condition|)
block|{
name|code
operator|=
name|DLG_EXIT_HELP
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
ifdef|#
directive|ifdef
name|NO_LEAKS
name|_dlg_inputstr_leaks
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NCURSES_VERSION
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE__NC_FREE_AND_EXIT
argument_list|)
name|_nc_free_and_exit
argument_list|(
name|code
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|dialog_state
operator|.
name|input
operator|==
name|stdin
condition|)
block|{
name|exit
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Just in case of using --input-fd option, do not 	 * call atexit functions of ncurses which may hang. 	 */
if|if
condition|(
name|dialog_state
operator|.
name|input
condition|)
block|{
name|fclose
argument_list|(
name|dialog_state
operator|.
name|input
argument_list|)
expr_stmt|;
name|dialog_state
operator|.
name|input
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dialog_state
operator|.
name|pipe_input
condition|)
block|{
if|if
condition|(
name|dialog_state
operator|.
name|pipe_input
operator|!=
name|stdin
condition|)
block|{
name|fclose
argument_list|(
name|dialog_state
operator|.
name|pipe_input
argument_list|)
expr_stmt|;
name|dialog_state
operator|.
name|pipe_input
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|_exit
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* quit program killing all tailbg */
end_comment

begin_function
name|void
name|dlg_exiterr
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|end_dialog
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|dlg_killall_bg
argument_list|(
operator|&
name|retval
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|dlg_exit
argument_list|(
name|DLG_EXIT_ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dlg_beeping
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|dialog_vars
operator|.
name|beep_signal
condition|)
block|{
operator|(
name|void
operator|)
name|beep
argument_list|()
expr_stmt|;
name|dialog_vars
operator|.
name|beep_signal
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dlg_print_size
parameter_list|(
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|)
block|{
if|if
condition|(
name|dialog_vars
operator|.
name|print_siz
condition|)
name|fprintf
argument_list|(
name|dialog_state
operator|.
name|output
argument_list|,
literal|"Size: %d, %d\n"
argument_list|,
name|height
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dlg_ctl_size
parameter_list|(
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|)
block|{
if|if
condition|(
name|dialog_vars
operator|.
name|size_err
condition|)
block|{
if|if
condition|(
operator|(
name|width
operator|>
name|COLS
operator|)
operator|||
operator|(
name|height
operator|>
name|LINES
operator|)
condition|)
block|{
name|dlg_exiterr
argument_list|(
literal|"Window too big. (height, width) = (%d, %d). Max allowed (%d, %d)."
argument_list|,
name|height
argument_list|,
name|width
argument_list|,
name|LINES
argument_list|,
name|COLS
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_COLOR
elseif|else
if|if
condition|(
operator|(
name|dialog_state
operator|.
name|use_shadow
operator|)
operator|&&
operator|(
operator|(
name|width
operator|>
name|SCOLS
operator|||
name|height
operator|>
name|SLINES
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|width
operator|<=
name|COLS
operator|)
operator|&&
operator|(
name|height
operator|<=
name|LINES
operator|)
condition|)
block|{
comment|/* try again, without shadows */
name|dialog_state
operator|.
name|use_shadow
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dlg_exiterr
argument_list|(
literal|"Window+Shadow too big. (height, width) = (%d, %d). Max allowed (%d, %d)."
argument_list|,
name|height
argument_list|,
name|width
argument_list|,
name|SLINES
argument_list|,
name|SCOLS
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * If the --tab-correct was not selected, convert tabs to single spaces.  */
end_comment

begin_function
name|void
name|dlg_tab_correct_str
parameter_list|(
name|char
modifier|*
name|prompt
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|tab_correct
condition|)
block|{
while|while
condition|(
operator|(
name|ptr
operator|=
name|strchr
argument_list|(
name|prompt
argument_list|,
name|TAB
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptr
operator|=
literal|' '
expr_stmt|;
name|prompt
operator|=
name|ptr
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|dlg_calc_listh
parameter_list|(
name|int
modifier|*
name|height
parameter_list|,
name|int
modifier|*
name|list_height
parameter_list|,
name|int
name|item_no
parameter_list|)
block|{
comment|/* calculate new height and list_height */
name|int
name|rows
init|=
name|SLINES
operator|-
operator|(
name|dialog_vars
operator|.
name|begin_set
condition|?
name|dialog_vars
operator|.
name|begin_y
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|rows
operator|-
operator|(
operator|*
name|height
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rows
operator|-
operator|(
operator|*
name|height
operator|)
operator|>
name|item_no
condition|)
operator|*
name|list_height
operator|=
name|item_no
expr_stmt|;
else|else
operator|*
name|list_height
operator|=
name|rows
operator|-
operator|(
operator|*
name|height
operator|)
expr_stmt|;
block|}
operator|(
operator|*
name|height
operator|)
operator|+=
operator|(
operator|*
name|list_height
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* obsolete */
end_comment

begin_function
name|int
name|dlg_calc_listw
parameter_list|(
name|int
name|item_no
parameter_list|,
name|char
modifier|*
modifier|*
name|items
parameter_list|,
name|int
name|group
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|len1
init|=
literal|0
decl_stmt|,
name|len2
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|item_no
operator|*
name|group
operator|)
condition|;
name|i
operator|+=
name|group
control|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|dlg_count_columns
argument_list|(
name|items
index|[
name|i
index|]
argument_list|)
operator|)
operator|>
name|len1
condition|)
name|len1
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dlg_count_columns
argument_list|(
name|items
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|)
operator|>
name|len2
condition|)
name|len2
operator|=
name|n
expr_stmt|;
block|}
return|return
name|len1
operator|+
name|len2
return|;
block|}
end_function

begin_function
name|int
name|dlg_calc_list_width
parameter_list|(
name|int
name|item_no
parameter_list|,
name|DIALOG_LISTITEM
modifier|*
name|items
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|len1
init|=
literal|0
decl_stmt|,
name|len2
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|item_no
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|dlg_count_columns
argument_list|(
name|items
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|)
operator|>
name|len1
condition|)
name|len1
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dlg_count_columns
argument_list|(
name|items
index|[
name|i
index|]
operator|.
name|text
argument_list|)
operator|)
operator|>
name|len2
condition|)
name|len2
operator|=
name|n
expr_stmt|;
block|}
return|return
name|len1
operator|+
name|len2
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|dlg_strempty
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|empty
index|[]
init|=
literal|""
decl_stmt|;
return|return
name|empty
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|dlg_strclone
parameter_list|(
specifier|const
name|char
modifier|*
name|cprompt
parameter_list|)
block|{
name|char
modifier|*
name|prompt
init|=
name|dlg_malloc
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|cprompt
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|assert_ptr
argument_list|(
name|prompt
argument_list|,
literal|"dlg_strclone"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|prompt
argument_list|,
name|cprompt
argument_list|)
expr_stmt|;
return|return
name|prompt
return|;
block|}
end_function

begin_function
name|chtype
name|dlg_asciibox
parameter_list|(
name|chtype
name|ch
parameter_list|)
block|{
name|chtype
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|ACS_ULCORNER
condition|)
name|result
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|ACS_LLCORNER
condition|)
name|result
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|ACS_URCORNER
condition|)
name|result
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|ACS_LRCORNER
condition|)
name|result
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|ACS_HLINE
condition|)
name|result
operator|=
literal|'-'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|ACS_VLINE
condition|)
name|result
operator|=
literal|'|'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|ACS_LTEE
condition|)
name|result
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|ACS_RTEE
condition|)
name|result
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|ACS_UARROW
condition|)
name|result
operator|=
literal|'^'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|ACS_DARROW
condition|)
name|result
operator|=
literal|'v'
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|chtype
name|dlg_boxchar
parameter_list|(
name|chtype
name|ch
parameter_list|)
block|{
name|chtype
name|result
init|=
name|dlg_asciibox
argument_list|(
name|ch
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dialog_vars
operator|.
name|ascii_lines
condition|)
name|ch
operator|=
name|result
expr_stmt|;
elseif|else
if|if
condition|(
name|dialog_vars
operator|.
name|no_lines
condition|)
name|ch
operator|=
literal|' '
expr_stmt|;
block|}
return|return
name|ch
return|;
block|}
end_function

begin_function
name|int
name|dlg_box_x_ordinate
parameter_list|(
name|int
name|width
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|begin_set
operator|==
literal|1
condition|)
block|{
name|x
operator|=
name|dialog_vars
operator|.
name|begin_x
expr_stmt|;
block|}
else|else
block|{
comment|/* center dialog box on screen unless --begin-set */
name|x
operator|=
operator|(
name|SCOLS
operator|-
name|width
operator|)
operator|/
literal|2
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_function
name|int
name|dlg_box_y_ordinate
parameter_list|(
name|int
name|height
parameter_list|)
block|{
name|int
name|y
decl_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|begin_set
operator|==
literal|1
condition|)
block|{
name|y
operator|=
name|dialog_vars
operator|.
name|begin_y
expr_stmt|;
block|}
else|else
block|{
comment|/* center dialog box on screen unless --begin-set */
name|y
operator|=
operator|(
name|SLINES
operator|-
name|height
operator|)
operator|/
literal|2
expr_stmt|;
block|}
return|return
name|y
return|;
block|}
end_function

begin_function
name|void
name|dlg_draw_title
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
specifier|const
name|char
modifier|*
name|title
parameter_list|)
block|{
if|if
condition|(
name|title
operator|!=
name|NULL
condition|)
block|{
name|chtype
name|attr
init|=
name|A_NORMAL
decl_stmt|;
name|chtype
name|save
init|=
name|dlg_get_attrs
argument_list|(
name|win
argument_list|)
decl_stmt|;
name|int
name|x
init|=
name|centered
argument_list|(
name|getmaxx
argument_list|(
name|win
argument_list|)
argument_list|,
name|title
argument_list|)
decl_stmt|;
name|wattrset
argument_list|(
name|win
argument_list|,
name|title_attr
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|dlg_print_text
argument_list|(
name|win
argument_list|,
name|title
argument_list|,
name|getmaxx
argument_list|(
name|win
argument_list|)
operator|-
name|x
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
name|wattrset
argument_list|(
name|win
argument_list|,
name|save
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dlg_draw_bottom_box
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|int
name|width
init|=
name|getmaxx
argument_list|(
name|win
argument_list|)
decl_stmt|;
name|int
name|height
init|=
name|getmaxy
argument_list|(
name|win
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|wattrset
argument_list|(
name|win
argument_list|,
name|border_attr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|win
argument_list|,
name|height
operator|-
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|win
argument_list|,
name|dlg_boxchar
argument_list|(
name|ACS_LTEE
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
operator|-
literal|2
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|win
argument_list|,
name|dlg_boxchar
argument_list|(
name|ACS_HLINE
argument_list|)
argument_list|)
expr_stmt|;
name|wattrset
argument_list|(
name|win
argument_list|,
name|dialog_attr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|win
argument_list|,
name|dlg_boxchar
argument_list|(
name|ACS_RTEE
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|win
argument_list|,
name|height
operator|-
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
operator|-
literal|2
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|win
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a window, repainting everything else.  This would be simpler if we  * used the panel library, but that is not _always_ available.  */
end_comment

begin_function
name|void
name|dlg_del_window
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|DIALOG_WINDOWS
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
comment|/*      * If --keep-window was set, do not delete/repaint the windows.      */
if|if
condition|(
name|dialog_vars
operator|.
name|keep_window
condition|)
return|return;
comment|/* Leave the main window untouched if there are no background windows.      * We do this so the current window will not be cleared on exit, allowing      * things like the infobox demo to run without flicker.      */
if|if
condition|(
name|dialog_state
operator|.
name|getc_callbacks
operator|!=
literal|0
condition|)
block|{
name|touchwin
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|dialog_state
operator|.
name|all_windows
operator|,
name|q
operator|=
name|r
operator|=
literal|0
init|;
name|p
operator|!=
literal|0
condition|;
name|r
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|normal
operator|==
name|win
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
comment|/* found a match - should be only one */
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|dialog_state
operator|.
name|all_windows
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|shadow
operator|!=
literal|0
condition|)
block|{
name|touchwin
argument_list|(
name|p
operator|->
name|shadow
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|p
operator|->
name|shadow
argument_list|)
expr_stmt|;
block|}
name|touchwin
argument_list|(
name|p
operator|->
name|normal
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|p
operator|->
name|normal
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|q
condition|)
block|{
name|delwin
argument_list|(
name|q
operator|->
name|normal
argument_list|)
expr_stmt|;
name|dlg_unregister_window
argument_list|(
name|q
operator|->
name|normal
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|doupdate
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a window, optionally with a shadow.  */
end_comment

begin_function
name|WINDOW
modifier|*
name|dlg_new_window
parameter_list|(
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|DIALOG_WINDOWS
modifier|*
name|p
init|=
name|dlg_calloc
argument_list|(
name|DIALOG_WINDOWS
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|win
operator|=
name|newwin
argument_list|(
name|height
argument_list|,
name|width
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|dlg_exiterr
argument_list|(
literal|"Can't make new window at (%d,%d), size (%d,%d).\n"
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|height
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|next
operator|=
name|dialog_state
operator|.
name|all_windows
expr_stmt|;
name|p
operator|->
name|normal
operator|=
name|win
expr_stmt|;
name|dialog_state
operator|.
name|all_windows
operator|=
name|p
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_COLOR
if|if
condition|(
name|dialog_state
operator|.
name|use_shadow
condition|)
block|{
name|draw_childs_shadow
argument_list|(
name|p
operator|->
name|shadow
operator|=
name|stdscr
argument_list|,
name|win
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|keypad
argument_list|(
name|win
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_function
name|WINDOW
modifier|*
name|dlg_new_modal_window
parameter_list|(
name|WINDOW
modifier|*
name|parent
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|DIALOG_WINDOWS
modifier|*
name|p
init|=
name|dlg_calloc
argument_list|(
name|DIALOG_WINDOWS
argument_list|,
literal|1
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|parent
expr_stmt|;
if|if
condition|(
operator|(
name|win
operator|=
name|newwin
argument_list|(
name|height
argument_list|,
name|width
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|dlg_exiterr
argument_list|(
literal|"Can't make new window at (%d,%d), size (%d,%d).\n"
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|height
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|next
operator|=
name|dialog_state
operator|.
name|all_windows
expr_stmt|;
name|p
operator|->
name|normal
operator|=
name|win
expr_stmt|;
name|dialog_state
operator|.
name|all_windows
operator|=
name|p
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_COLOR
if|if
condition|(
name|dialog_state
operator|.
name|use_shadow
condition|)
block|{
name|draw_childs_shadow
argument_list|(
name|p
operator|->
name|shadow
operator|=
name|parent
argument_list|,
name|win
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|keypad
argument_list|(
name|win
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/*  * Move/Resize a window, optionally with a shadow.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KEY_RESIZE
end_ifdef

begin_function
name|void
name|dlg_move_window
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|DIALOG_WINDOWS
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|win
operator|!=
literal|0
condition|)
block|{
name|dlg_ctl_size
argument_list|(
name|height
argument_list|,
name|width
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|dialog_state
operator|.
name|all_windows
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|q
control|)
block|{
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|normal
operator|==
name|win
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|wresize
argument_list|(
name|win
argument_list|,
name|height
argument_list|,
name|width
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvwin
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_COLOR
if|if
condition|(
name|p
operator|->
name|shadow
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dialog_state
operator|.
name|use_shadow
condition|)
block|{
operator|(
name|void
operator|)
name|mvwin
argument_list|(
name|p
operator|->
name|shadow
argument_list|,
name|y
operator|+
name|SHADOW_ROWS
argument_list|,
name|x
operator|+
name|SHADOW_COLS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|shadow
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_COLOR
if|if
condition|(
name|p
operator|->
name|shadow
condition|)
name|draw_childs_shadow
argument_list|(
name|p
operator|->
name|shadow
argument_list|,
name|win
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KEY_RESIZE */
end_comment

begin_function
name|WINDOW
modifier|*
name|dlg_sub_window
parameter_list|(
name|WINDOW
modifier|*
name|parent
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|;
if|if
condition|(
operator|(
name|win
operator|=
name|subwin
argument_list|(
name|parent
argument_list|,
name|height
argument_list|,
name|width
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|dlg_exiterr
argument_list|(
literal|"Can't make sub-window at (%d,%d), size (%d,%d).\n"
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|height
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|keypad
argument_list|(
name|win
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/* obsolete */
end_comment

begin_function
name|int
name|dlg_default_item
parameter_list|(
name|char
modifier|*
modifier|*
name|items
parameter_list|,
name|int
name|llen
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|default_item
operator|!=
literal|0
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|items
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dialog_vars
operator|.
name|default_item
argument_list|,
operator|*
name|items
argument_list|)
condition|)
block|{
name|result
operator|=
name|count
expr_stmt|;
break|break;
block|}
name|items
operator|+=
name|llen
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|dlg_default_listitem
parameter_list|(
name|DIALOG_LISTITEM
modifier|*
name|items
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|default_item
operator|!=
literal|0
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|items
operator|->
name|name
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dialog_vars
operator|.
name|default_item
argument_list|,
name|items
operator|->
name|name
argument_list|)
condition|)
block|{
name|result
operator|=
name|count
expr_stmt|;
break|break;
block|}
operator|++
name|items
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Draw the string for item_help  */
end_comment

begin_function
name|void
name|dlg_item_help
parameter_list|(
specifier|const
name|char
modifier|*
name|txt
parameter_list|)
block|{
if|if
condition|(
name|USE_ITEM_HELP
argument_list|(
name|txt
argument_list|)
condition|)
block|{
name|chtype
name|attr
init|=
name|A_NORMAL
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|wattrset
argument_list|(
name|stdscr
argument_list|,
name|itemhelp_attr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|stdscr
argument_list|,
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wclrtoeol
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|dlg_print_text
argument_list|(
name|stdscr
argument_list|,
name|txt
argument_list|,
name|COLS
operator|-
literal|1
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|itemhelp_attr
operator|&
name|A_COLOR
condition|)
block|{
comment|/* fill the remainder of the line with the window's attributes */
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
while|while
condition|(
name|x
operator|<
name|COLS
condition|)
block|{
operator|(
name|void
operator|)
name|addch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
operator|++
name|x
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|wnoutrefresh
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRCASECMP
end_ifndef

begin_function
name|int
name|dlg_strcmp
parameter_list|(
specifier|const
name|char
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|b
parameter_list|)
block|{
name|int
name|ac
decl_stmt|,
name|bc
decl_stmt|,
name|cmp
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ac
operator|=
name|UCH
argument_list|(
operator|*
name|a
operator|++
argument_list|)
expr_stmt|;
name|bc
operator|=
name|UCH
argument_list|(
operator|*
name|b
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|ac
argument_list|)
operator|&&
name|islower
argument_list|(
name|ac
argument_list|)
condition|)
name|ac
operator|=
name|_toupper
argument_list|(
name|ac
argument_list|)
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|bc
argument_list|)
operator|&&
name|islower
argument_list|(
name|bc
argument_list|)
condition|)
name|bc
operator|=
name|_toupper
argument_list|(
name|bc
argument_list|)
expr_stmt|;
name|cmp
operator|=
name|ac
operator|-
name|bc
expr_stmt|;
if|if
condition|(
name|ac
operator|==
literal|0
operator|||
name|bc
operator|==
literal|0
operator|||
name|cmp
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
name|cmp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Returns true if 'dst' points to a blank which follows another blank which  * is not a leading blank on a line.  */
end_comment

begin_function
specifier|static
name|bool
name|trim_blank
parameter_list|(
name|char
modifier|*
name|base
parameter_list|,
name|char
modifier|*
name|dst
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|dst
operator|--
operator|!=
name|base
condition|)
block|{
if|if
condition|(
operator|*
name|dst
operator|==
literal|'\n'
condition|)
block|{
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|dst
operator|!=
literal|' '
condition|)
block|{
return|return
operator|(
name|count
operator|>
literal|1
operator|)
return|;
block|}
else|else
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Change embedded "\n" substrings to '\n' characters and tabs to single  * spaces.  If there are no "\n"s, it will strip all extra spaces, for  * justification.  If it has "\n"'s, it will preserve extra spaces.  If cr_wrap  * is set, it will preserve '\n's.  */
end_comment

begin_function
name|void
name|dlg_trim_string
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|base
init|=
name|s
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|s
decl_stmt|;
name|int
name|has_newlines
init|=
operator|(
name|strstr
argument_list|(
name|s
argument_list|,
literal|"\\n"
argument_list|)
operator|!=
literal|0
operator|)
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|TAB
operator|&&
operator|!
name|dialog_vars
operator|.
name|nocollapse
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|has_newlines
condition|)
block|{
comment|/* If prompt contains "\n" strings */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'n'
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|p1
operator|=
name|p
expr_stmt|;
comment|/* 		 * Handle end of lines intelligently.  If '\n' follows "\n" 		 * then ignore the '\n'.  This eliminates the need to escape 		 * the '\n' character (no need to use "\n\"). 		 */
while|while
condition|(
operator|*
name|p1
operator|==
literal|' '
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|==
literal|'\n'
condition|)
name|p
operator|=
name|p1
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|dialog_vars
operator|.
name|cr_wrap
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
else|else
block|{
comment|/* Replace the '\n' with a space if cr_wrap is not set */
if|if
condition|(
operator|!
name|trim_blank
argument_list|(
name|base
argument_list|,
name|s
argument_list|)
condition|)
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
else|else
comment|/* If *p != '\n' */
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dialog_vars
operator|.
name|trim_whitespace
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|!=
literal|' '
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|dialog_vars
operator|.
name|cr_wrap
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|!=
literal|' '
condition|)
block|{
comment|/* Strip '\n's if cr_wrap is not set. */
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
name|p
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* If there are no "\n" strings */
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
operator|&&
operator|!
name|dialog_vars
operator|.
name|nocollapse
condition|)
block|{
if|if
condition|(
operator|!
name|trim_blank
argument_list|(
name|base
argument_list|,
name|s
argument_list|)
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dlg_set_focus
parameter_list|(
name|WINDOW
modifier|*
name|parent
parameter_list|,
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
if|if
condition|(
name|win
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|parent
argument_list|,
name|getpary
argument_list|(
name|win
argument_list|)
operator|+
name|getcury
argument_list|(
name|win
argument_list|)
argument_list|,
name|getparx
argument_list|(
name|win
argument_list|)
operator|+
name|getcurx
argument_list|(
name|win
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wnoutrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|doupdate
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Returns the nominal maximum buffer size.  */
end_comment

begin_function
name|int
name|dlg_max_input
parameter_list|(
name|int
name|max_len
parameter_list|)
block|{
if|if
condition|(
name|dialog_vars
operator|.
name|max_input
operator|!=
literal|0
operator|&&
name|dialog_vars
operator|.
name|max_input
operator|<
name|MAX_LEN
condition|)
name|max_len
operator|=
name|dialog_vars
operator|.
name|max_input
expr_stmt|;
return|return
name|max_len
return|;
block|}
end_function

begin_comment
comment|/*  * Free storage used for the result buffer.  */
end_comment

begin_function
name|void
name|dlg_clr_result
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|dialog_vars
operator|.
name|input_length
condition|)
block|{
name|dialog_vars
operator|.
name|input_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|input_result
condition|)
name|free
argument_list|(
name|dialog_vars
operator|.
name|input_result
argument_list|)
expr_stmt|;
block|}
name|dialog_vars
operator|.
name|input_result
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup a fixed-buffer for the result.  */
end_comment

begin_function
name|char
modifier|*
name|dlg_set_result
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|unsigned
name|need
init|=
name|string
condition|?
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
else|:
literal|0
decl_stmt|;
comment|/* inputstr.c needs a fixed buffer */
if|if
condition|(
name|need
operator|<
name|MAX_LEN
condition|)
name|need
operator|=
name|MAX_LEN
expr_stmt|;
comment|/*      * If the buffer is not big enough, allocate a new one.      */
if|if
condition|(
name|dialog_vars
operator|.
name|input_length
operator|!=
literal|0
operator|||
name|dialog_vars
operator|.
name|input_result
operator|==
literal|0
operator|||
name|need
operator|>
name|MAX_LEN
condition|)
block|{
name|dlg_clr_result
argument_list|()
expr_stmt|;
name|dialog_vars
operator|.
name|input_length
operator|=
name|need
expr_stmt|;
name|dialog_vars
operator|.
name|input_result
operator|=
name|dlg_malloc
argument_list|(
name|char
argument_list|,
name|need
argument_list|)
expr_stmt|;
name|assert_ptr
argument_list|(
name|dialog_vars
operator|.
name|input_result
argument_list|,
literal|"dlg_set_result"
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|dialog_vars
operator|.
name|input_result
argument_list|,
name|string
condition|?
name|string
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
name|dialog_vars
operator|.
name|input_result
return|;
block|}
end_function

begin_comment
comment|/*  * Accumulate results in dynamically allocated buffer.  * If input_length is zero, it is a MAX_LEN buffer belonging to the caller.  */
end_comment

begin_function
name|void
name|dlg_add_result
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|unsigned
name|have
init|=
operator|(
name|dialog_vars
operator|.
name|input_result
condition|?
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|dialog_vars
operator|.
name|input_result
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
name|unsigned
name|want
init|=
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
operator|+
name|have
decl_stmt|;
if|if
condition|(
operator|(
name|want
operator|>=
name|MAX_LEN
operator|)
operator|||
operator|(
name|dialog_vars
operator|.
name|input_length
operator|!=
literal|0
operator|)
operator|||
operator|(
name|dialog_vars
operator|.
name|input_result
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|dialog_vars
operator|.
name|input_length
operator|==
literal|0
operator|||
name|dialog_vars
operator|.
name|input_result
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|save_result
init|=
name|dialog_vars
operator|.
name|input_result
decl_stmt|;
name|dialog_vars
operator|.
name|input_length
operator|=
name|want
operator|*
literal|2
expr_stmt|;
name|dialog_vars
operator|.
name|input_result
operator|=
name|dlg_malloc
argument_list|(
name|char
argument_list|,
name|dialog_vars
operator|.
name|input_length
argument_list|)
expr_stmt|;
name|assert_ptr
argument_list|(
name|dialog_vars
operator|.
name|input_result
argument_list|,
literal|"dlg_add_result malloc"
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|input_result
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|save_result
operator|!=
literal|0
condition|)
name|strcpy
argument_list|(
name|dialog_vars
operator|.
name|input_result
argument_list|,
name|save_result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|want
operator|>=
name|dialog_vars
operator|.
name|input_length
condition|)
block|{
name|dialog_vars
operator|.
name|input_length
operator|=
name|want
operator|*
literal|2
expr_stmt|;
name|dialog_vars
operator|.
name|input_result
operator|=
name|dlg_realloc
argument_list|(
name|char
argument_list|,
name|dialog_vars
operator|.
name|input_length
argument_list|,
name|dialog_vars
operator|.
name|input_result
argument_list|)
expr_stmt|;
name|assert_ptr
argument_list|(
name|dialog_vars
operator|.
name|input_result
argument_list|,
literal|"dlg_add_result realloc"
argument_list|)
expr_stmt|;
block|}
block|}
name|strcat
argument_list|(
name|dialog_vars
operator|.
name|input_result
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * These are characters that (aside from the quote-delimiter) will have to  * be escaped in a single- or double-quoted string.  */
end_comment

begin_define
define|#
directive|define
name|FIX_SINGLE
value|"\n\\"
end_define

begin_define
define|#
directive|define
name|FIX_DOUBLE
value|FIX_SINGLE "[]{}?*;`~#$^&()|<>"
end_define

begin_comment
comment|/*  * Returns the quote-delimiter.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|quote_delimiter
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|dialog_vars
operator|.
name|single_quoted
condition|?
literal|"'"
else|:
literal|"\""
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if we should quote the given string.  */
end_comment

begin_function
specifier|static
name|bool
name|must_quote
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
name|bool
name|code
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|*
name|string
operator|!=
literal|'\0'
condition|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcspn
argument_list|(
name|string
argument_list|,
name|quote_delimiter
argument_list|()
argument_list|)
operator|!=
name|len
condition|)
name|code
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcspn
argument_list|(
name|string
argument_list|,
literal|"\n\t "
argument_list|)
operator|!=
name|len
condition|)
name|code
operator|=
name|TRUE
expr_stmt|;
else|else
name|code
operator|=
operator|(
name|strcspn
argument_list|(
name|string
argument_list|,
name|FIX_DOUBLE
argument_list|)
operator|!=
name|len
operator|)
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/*  * Add a quoted string to the result buffer.  */
end_comment

begin_function
name|void
name|dlg_add_quoted
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
name|char
name|temp
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|my_quote
init|=
name|quote_delimiter
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|must_fix
init|=
operator|(
name|dialog_vars
operator|.
name|single_quoted
condition|?
name|FIX_SINGLE
else|:
name|FIX_DOUBLE
operator|)
decl_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|quoted
operator|||
name|must_quote
argument_list|(
name|string
argument_list|)
condition|)
block|{
name|temp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dlg_add_result
argument_list|(
name|my_quote
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|string
operator|!=
literal|'\0'
condition|)
block|{
name|temp
index|[
literal|0
index|]
operator|=
operator|*
name|string
operator|++
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|my_quote
argument_list|,
operator|*
name|temp
argument_list|)
operator|||
name|strchr
argument_list|(
name|must_fix
argument_list|,
operator|*
name|temp
argument_list|)
condition|)
name|dlg_add_result
argument_list|(
literal|"\\"
argument_list|)
expr_stmt|;
name|dlg_add_result
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|dlg_add_result
argument_list|(
name|my_quote
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dlg_add_result
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * When adding a result, make that depend on whether "--quoted" is used.  */
end_comment

begin_function
name|void
name|dlg_add_string
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
if|if
condition|(
name|dialog_vars
operator|.
name|quoted
condition|)
block|{
name|dlg_add_quoted
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dlg_add_result
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bool
name|dlg_need_separator
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|output_separator
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dialog_vars
operator|.
name|input_result
operator|&&
operator|*
operator|(
name|dialog_vars
operator|.
name|input_result
operator|)
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|dlg_add_separator
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|separator
init|=
operator|(
name|dialog_vars
operator|.
name|separate_output
operator|)
condition|?
literal|"\n"
else|:
literal|" "
decl_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|output_separator
condition|)
name|separator
operator|=
name|dialog_vars
operator|.
name|output_separator
expr_stmt|;
name|dlg_add_result
argument_list|(
name|separator
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Some widgets support only one value of a given variable - save/restore the  * global dialog_vars so we can override it consistently.  */
end_comment

begin_function
name|void
name|dlg_save_vars
parameter_list|(
name|DIALOG_VARS
modifier|*
name|vars
parameter_list|)
block|{
operator|*
name|vars
operator|=
name|dialog_vars
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Most of the data in DIALOG_VARS is normally set by command-line options.  * The input_result member is an exception; it is normally set by the dialog  * library to return result values.  */
end_comment

begin_function
name|void
name|dlg_restore_vars
parameter_list|(
name|DIALOG_VARS
modifier|*
name|vars
parameter_list|)
block|{
name|char
modifier|*
name|save_result
init|=
name|dialog_vars
operator|.
name|input_result
decl_stmt|;
name|unsigned
name|save_length
init|=
name|dialog_vars
operator|.
name|input_length
decl_stmt|;
name|dialog_vars
operator|=
operator|*
name|vars
expr_stmt|;
name|dialog_vars
operator|.
name|input_result
operator|=
name|save_result
expr_stmt|;
name|dialog_vars
operator|.
name|input_length
operator|=
name|save_length
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called each time a widget is invoked which may do output, increment a count.  */
end_comment

begin_function
name|void
name|dlg_does_output
parameter_list|(
name|void
parameter_list|)
block|{
name|dialog_state
operator|.
name|output_count
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compatibility for different versions of curses.  */
end_comment

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|HAVE_GETBEGX
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_GETBEGY
argument_list|)
operator|)
end_if

begin_function
name|int
name|getbegx
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|getbegyx
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
name|int
name|getbegy
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|getbegyx
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|HAVE_GETCURX
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_GETCURY
argument_list|)
operator|)
end_if

begin_function
name|int
name|getcurx
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
name|int
name|getcury
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|HAVE_GETMAXX
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_GETMAXY
argument_list|)
operator|)
end_if

begin_function
name|int
name|getmaxx
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|getmaxyx
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
name|int
name|getmaxy
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|getmaxyx
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|HAVE_GETPARX
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_GETPARY
argument_list|)
operator|)
end_if

begin_function
name|int
name|getparx
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|getparyx
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
name|int
name|getpary
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|getparyx
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

