begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  $Id: buttons.c,v 1.94 2012/12/30 20:51:01 tom Exp $  *  *  buttons.c -- draw buttons, e.g., OK/Cancel  *  *  Copyright 2000-2011,2012	Thomas E. Dickey  *  *  This program is free software; you can redistribute it and/or modify  *  it under the terms of the GNU Lesser General Public License, version 2.1  *  as published by the Free Software Foundation.  *  *  This program is distributed in the hope that it will be useful, but  *  WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *  Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public  *  License along with this program; if not, write to  *	Free Software Foundation, Inc.  *	51 Franklin St., Fifth Floor  *	Boston, MA 02110, USA.  */
end_comment

begin_include
include|#
directive|include
file|<dialog.h>
end_include

begin_include
include|#
directive|include
file|<dlg_keys.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_WCHAR_H
end_ifdef

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MIN_BUTTON
value|(-dialog_state.visit_cols)
end_define

begin_function
specifier|static
name|void
name|center_label
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|longest
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|)
block|{
name|int
name|len
init|=
name|dlg_count_columns
argument_list|(
name|label
argument_list|)
decl_stmt|;
name|int
name|left
init|=
literal|0
decl_stmt|,
name|right
init|=
literal|0
decl_stmt|;
operator|*
name|buffer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|longest
condition|)
block|{
name|left
operator|=
operator|(
name|longest
operator|-
name|len
operator|)
operator|/
literal|2
expr_stmt|;
name|right
operator|=
operator|(
name|longest
operator|-
name|len
operator|-
name|left
operator|)
expr_stmt|;
if|if
condition|(
name|left
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%*s"
argument_list|,
name|left
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|buffer
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%*s"
argument_list|,
name|right
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse a multibyte character out of the string, set it past the parsed  * character.  */
end_comment

begin_function
specifier|static
name|int
name|string_to_char
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|stringp
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_WIDE_CURSES
specifier|const
name|char
modifier|*
name|string
init|=
operator|*
name|stringp
decl_stmt|;
name|size_t
name|have
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|size_t
name|check
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|wchar_t
name|cmp2
index|[
literal|2
index|]
decl_stmt|;
name|mbstate_t
name|state
decl_stmt|;
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|mbrlen
argument_list|(
name|string
argument_list|,
name|have
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|len
operator|>
literal|0
operator|&&
name|len
operator|<=
name|have
condition|)
block|{
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cmp2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmp2
argument_list|)
argument_list|)
expr_stmt|;
name|check
operator|=
name|mbrtowc
argument_list|(
name|cmp2
argument_list|,
name|string
argument_list|,
name|len
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|check
operator|<=
literal|0
condition|)
name|cmp2
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|stringp
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|cmp2
index|[
literal|0
index|]
operator|=
name|UCH
argument_list|(
operator|*
name|string
argument_list|)
expr_stmt|;
operator|*
name|stringp
operator|+=
literal|1
expr_stmt|;
block|}
name|result
operator|=
name|cmp2
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
specifier|const
name|char
modifier|*
name|string
init|=
operator|*
name|stringp
decl_stmt|;
name|result
operator|=
name|UCH
argument_list|(
operator|*
name|string
argument_list|)
expr_stmt|;
operator|*
name|stringp
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|count_labels
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|labels
parameter_list|)
block|{
name|size_t
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|labels
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|labels
operator|++
operator|!=
literal|0
condition|)
block|{
operator|++
name|result
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the latest key should be added to the hotkey list.  */
end_comment

begin_function
specifier|static
name|int
name|was_hotkey
parameter_list|(
name|int
name|this_key
parameter_list|,
name|int
modifier|*
name|used_keys
parameter_list|,
name|size_t
name|next
parameter_list|)
block|{
name|int
name|result
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|next
operator|!=
literal|0
condition|)
block|{
name|size_t
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|next
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
name|used_keys
index|[
name|n
index|]
operator|==
name|this_key
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Determine the hot-keys for a set of button-labels.  Normally these are  * the first uppercase character in each label.  However, if more than one  * button has the same first-uppercase, then we will (attempt to) look for  * an alternate.  *  * This allocates data which must be freed by the caller.  */
end_comment

begin_function
specifier|static
name|int
modifier|*
name|get_hotkeys
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|labels
parameter_list|)
block|{
name|int
modifier|*
name|result
init|=
literal|0
decl_stmt|;
name|size_t
name|count
init|=
name|count_labels
argument_list|(
name|labels
argument_list|)
decl_stmt|;
name|size_t
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|dlg_calloc
argument_list|(
name|int
argument_list|,
name|count
operator|+
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
operator|++
name|n
control|)
block|{
specifier|const
name|char
modifier|*
name|label
init|=
name|labels
index|[
name|n
index|]
decl_stmt|;
specifier|const
name|int
modifier|*
name|indx
init|=
name|dlg_index_wchars
argument_list|(
name|label
argument_list|)
decl_stmt|;
name|int
name|limit
init|=
name|dlg_count_wchars
argument_list|(
name|label
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
operator|++
name|i
control|)
block|{
name|int
name|first
init|=
name|indx
index|[
name|i
index|]
decl_stmt|;
name|int
name|check
init|=
name|UCH
argument_list|(
name|label
index|[
name|first
index|]
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_WIDE_CURSES
name|int
name|last
init|=
name|indx
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|last
operator|-
name|first
operator|)
operator|!=
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|temp
init|=
operator|(
name|label
operator|+
name|first
operator|)
decl_stmt|;
name|check
operator|=
name|string_to_char
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|dlg_isupper
argument_list|(
name|check
argument_list|)
operator|&&
operator|!
name|was_hotkey
argument_list|(
name|check
argument_list|,
name|result
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|result
index|[
name|n
index|]
operator|=
name|check
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Print a button  */
end_comment

begin_function
specifier|static
name|void
name|print_button
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|char
modifier|*
name|label
parameter_list|,
name|int
name|hotkey
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|selected
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|state
init|=
literal|0
decl_stmt|;
specifier|const
name|int
modifier|*
name|indx
init|=
name|dlg_index_wchars
argument_list|(
name|label
argument_list|)
decl_stmt|;
name|int
name|limit
init|=
name|dlg_count_wchars
argument_list|(
name|label
argument_list|)
decl_stmt|;
name|chtype
name|key_attr
init|=
operator|(
name|selected
condition|?
name|button_key_active_attr
else|:
name|button_key_inactive_attr
operator|)
decl_stmt|;
name|chtype
name|label_attr
init|=
operator|(
name|selected
condition|?
name|button_label_active_attr
else|:
name|button_label_inactive_attr
operator|)
decl_stmt|;
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|win
argument_list|,
name|selected
condition|?
name|button_active_attr
else|:
name|button_inactive_attr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|waddstr
argument_list|(
name|win
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|win
argument_list|,
name|label_attr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
operator|++
name|i
control|)
block|{
name|int
name|check
decl_stmt|;
name|int
name|first
init|=
name|indx
index|[
name|i
index|]
decl_stmt|;
name|int
name|last
init|=
name|indx
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
name|check
operator|=
name|UCH
argument_list|(
name|label
index|[
name|first
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WIDE_CURSES
if|if
condition|(
operator|(
name|last
operator|-
name|first
operator|)
operator|!=
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|temp
init|=
operator|(
name|label
operator|+
name|first
operator|)
decl_stmt|;
name|check
operator|=
name|string_to_char
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|check
operator|==
name|hotkey
condition|)
block|{
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|win
argument_list|,
name|key_attr
argument_list|)
expr_stmt|;
name|state
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
name|wattrset
argument_list|(
name|win
argument_list|,
name|label_attr
argument_list|)
expr_stmt|;
name|state
operator|=
literal|2
expr_stmt|;
break|break;
block|}
name|waddnstr
argument_list|(
name|win
argument_list|,
name|label
operator|+
name|first
argument_list|,
name|last
operator|-
name|first
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|win
argument_list|,
name|selected
condition|?
name|button_active_attr
else|:
name|button_inactive_attr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|waddstr
argument_list|(
name|win
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
operator|+
operator|(
operator|(
name|int
operator|)
name|strspn
argument_list|(
name|label
argument_list|,
literal|" "
argument_list|)
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Count the buttons in the list.  */
end_comment

begin_function
name|int
name|dlg_button_count
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|labels
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|labels
operator|++
operator|!=
literal|0
condition|)
operator|++
name|result
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the size of the button array in columns.  Return the total number of  * columns in *length, and the longest button's columns in *longest  */
end_comment

begin_function
name|void
name|dlg_button_sizes
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|labels
parameter_list|,
name|int
name|vertical
parameter_list|,
name|int
modifier|*
name|longest
parameter_list|,
name|int
modifier|*
name|length
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
operator|*
name|length
operator|=
literal|0
expr_stmt|;
operator|*
name|longest
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|labels
index|[
name|n
index|]
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|vertical
condition|)
block|{
operator|*
name|length
operator|+=
literal|1
expr_stmt|;
operator|*
name|longest
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|len
init|=
name|dlg_count_columns
argument_list|(
name|labels
index|[
name|n
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
operator|*
name|longest
condition|)
operator|*
name|longest
operator|=
name|len
expr_stmt|;
operator|*
name|length
operator|+=
name|len
expr_stmt|;
block|}
block|}
comment|/*      * If we can, make all of the buttons the same size.  This is only optional      * for buttons laid out horizontally.      */
if|if
condition|(
operator|*
name|longest
operator|<
literal|6
operator|-
operator|(
operator|*
name|longest
operator|&
literal|1
operator|)
condition|)
operator|*
name|longest
operator|=
literal|6
operator|-
operator|(
operator|*
name|longest
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|vertical
condition|)
operator|*
name|length
operator|=
operator|*
name|longest
operator|*
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute the size of the button array.  */
end_comment

begin_function
name|int
name|dlg_button_x_step
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|labels
parameter_list|,
name|int
name|limit
parameter_list|,
name|int
modifier|*
name|gap
parameter_list|,
name|int
modifier|*
name|margin
parameter_list|,
name|int
modifier|*
name|step
parameter_list|)
block|{
name|int
name|count
init|=
name|dlg_button_count
argument_list|(
name|labels
argument_list|)
decl_stmt|;
name|int
name|longest
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|unused
decl_stmt|;
name|int
name|used
decl_stmt|;
name|int
name|result
decl_stmt|;
operator|*
name|margin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|dlg_button_sizes
argument_list|(
name|labels
argument_list|,
name|FALSE
argument_list|,
operator|&
name|longest
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|used
operator|=
operator|(
name|length
operator|+
operator|(
name|count
operator|*
literal|2
operator|)
operator|)
expr_stmt|;
name|unused
operator|=
name|limit
operator|-
name|used
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|gap
operator|=
name|unused
operator|/
operator|(
name|count
operator|+
literal|3
operator|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|gap
operator|=
name|unused
operator|/
operator|(
name|count
operator|+
literal|1
operator|)
operator|)
operator|<=
literal|0
condition|)
operator|*
name|gap
operator|=
literal|1
expr_stmt|;
operator|*
name|margin
operator|=
operator|*
name|gap
expr_stmt|;
block|}
else|else
block|{
operator|*
name|margin
operator|=
operator|*
name|gap
operator|*
literal|2
expr_stmt|;
block|}
operator|*
name|step
operator|=
operator|*
name|gap
operator|+
operator|(
name|used
operator|+
name|count
operator|-
literal|1
operator|)
operator|/
name|count
expr_stmt|;
name|result
operator|=
operator|(
operator|*
name|gap
operator|>
literal|0
operator|)
operator|&&
operator|(
name|unused
operator|>=
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Make sure there is enough space for the buttons  */
end_comment

begin_function
name|void
name|dlg_button_layout
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|labels
parameter_list|,
name|int
modifier|*
name|limit
parameter_list|)
block|{
name|int
name|width
init|=
literal|1
decl_stmt|;
name|int
name|gap
decl_stmt|,
name|margin
decl_stmt|,
name|step
decl_stmt|;
if|if
condition|(
name|labels
operator|!=
literal|0
operator|&&
name|dlg_button_count
argument_list|(
name|labels
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|dlg_button_x_step
argument_list|(
name|labels
argument_list|,
name|width
argument_list|,
operator|&
name|gap
argument_list|,
operator|&
name|margin
argument_list|,
operator|&
name|step
argument_list|)
condition|)
operator|++
name|width
expr_stmt|;
name|width
operator|+=
operator|(
literal|4
operator|*
name|MARGIN
operator|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
name|COLS
condition|)
name|width
operator|=
name|COLS
expr_stmt|;
if|if
condition|(
name|width
operator|>
operator|*
name|limit
condition|)
operator|*
name|limit
operator|=
name|width
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print a list of buttons at the given position.  */
end_comment

begin_function
name|void
name|dlg_draw_buttons
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|labels
parameter_list|,
name|int
name|selected
parameter_list|,
name|int
name|vertical
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|chtype
name|save
init|=
name|dlg_get_attrs
argument_list|(
name|win
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|step
init|=
literal|0
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|longest
decl_stmt|;
name|int
name|final_x
decl_stmt|;
name|int
name|final_y
decl_stmt|;
name|int
name|gap
decl_stmt|;
name|int
name|margin
decl_stmt|;
name|size_t
name|need
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|dlg_mouse_setbase
argument_list|(
name|getbegx
argument_list|(
name|win
argument_list|)
argument_list|,
name|getbegy
argument_list|(
name|win
argument_list|)
argument_list|)
expr_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|final_y
argument_list|,
name|final_x
argument_list|)
expr_stmt|;
name|dlg_button_sizes
argument_list|(
name|labels
argument_list|,
name|vertical
argument_list|,
operator|&
name|longest
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|vertical
condition|)
block|{
name|y
operator|+=
literal|1
expr_stmt|;
name|step
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dlg_button_x_step
argument_list|(
name|labels
argument_list|,
name|limit
argument_list|,
operator|&
name|gap
argument_list|,
operator|&
name|margin
argument_list|,
operator|&
name|step
argument_list|)
expr_stmt|;
name|x
operator|+=
name|margin
expr_stmt|;
block|}
comment|/*      * Allocate a buffer big enough for any label.      */
name|need
operator|=
operator|(
name|size_t
operator|)
name|longest
expr_stmt|;
if|if
condition|(
name|need
operator|!=
literal|0
condition|)
block|{
name|int
modifier|*
name|hotkeys
init|=
name|get_hotkeys
argument_list|(
name|labels
argument_list|)
decl_stmt|;
name|assert_ptr
argument_list|(
name|hotkeys
argument_list|,
literal|"dlg_draw_buttons"
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|labels
index|[
name|n
index|]
operator|!=
literal|0
condition|;
operator|++
name|n
control|)
block|{
name|need
operator|+=
name|strlen
argument_list|(
name|labels
index|[
name|n
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|buffer
operator|=
name|dlg_malloc
argument_list|(
name|char
argument_list|,
name|need
argument_list|)
expr_stmt|;
name|assert_ptr
argument_list|(
name|buffer
argument_list|,
literal|"dlg_draw_buttons"
argument_list|)
expr_stmt|;
comment|/* 	 * Draw the labels. 	 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|labels
index|[
name|n
index|]
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
block|{
name|center_label
argument_list|(
name|buffer
argument_list|,
name|longest
argument_list|,
name|labels
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|mouse_mkbutton
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
name|dlg_count_columns
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|print_button
argument_list|(
name|win
argument_list|,
name|buffer
argument_list|,
name|hotkeys
index|[
name|n
index|]
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
operator|(
name|selected
operator|==
name|n
operator|)
operator|||
operator|(
name|n
operator|==
literal|0
operator|&&
name|selected
operator|<
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|selected
operator|==
name|n
condition|)
name|getyx
argument_list|(
name|win
argument_list|,
name|final_y
argument_list|,
name|final_x
argument_list|)
expr_stmt|;
if|if
condition|(
name|vertical
condition|)
block|{
if|if
condition|(
operator|(
name|y
operator|+=
name|step
operator|)
operator|>
name|limit
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|x
operator|+=
name|step
operator|)
operator|>
name|limit
condition|)
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|win
argument_list|,
name|final_y
argument_list|,
name|final_x
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|win
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hotkeys
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Match a given character against the beginning of the string, ignoring case  * of the given character.  The matching string must begin with an uppercase  * character.  */
end_comment

begin_function
name|int
name|dlg_match_char
parameter_list|(
name|int
name|ch
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
if|if
condition|(
name|string
operator|!=
literal|0
condition|)
block|{
name|int
name|cmp2
init|=
name|string_to_char
argument_list|(
operator|&
name|string
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_WIDE_CURSES
name|wint_t
name|cmp1
init|=
name|dlg_toupper
argument_list|(
name|ch
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp2
operator|!=
literal|0
operator|&&
operator|(
name|wchar_t
operator|)
name|cmp1
operator|==
operator|(
name|wchar_t
operator|)
name|dlg_toupper
argument_list|(
name|cmp2
argument_list|)
condition|)
block|{
return|return
name|TRUE
return|;
block|}
else|#
directive|else
if|if
condition|(
name|ch
operator|>
literal|0
operator|&&
name|ch
operator|<
literal|256
condition|)
block|{
if|if
condition|(
name|dlg_toupper
argument_list|(
name|ch
argument_list|)
operator|==
name|dlg_toupper
argument_list|(
name|cmp2
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
endif|#
directive|endif
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Find the first uppercase character in the label, which we may use for an  * abbreviation.  */
end_comment

begin_function
name|int
name|dlg_button_to_char
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|)
block|{
name|int
name|cmp
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|label
operator|!=
literal|0
condition|)
block|{
name|cmp
operator|=
name|string_to_char
argument_list|(
operator|&
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlg_isupper
argument_list|(
name|cmp
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
return|return
name|cmp
return|;
block|}
end_function

begin_comment
comment|/*  * Given a list of button labels, and a character which may be the abbreviation  * for one, find it, if it exists.  An abbreviation will be the first character  * which happens to be capitalized in the label.  */
end_comment

begin_function
name|int
name|dlg_char_to_button
parameter_list|(
name|int
name|ch
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|labels
parameter_list|)
block|{
name|int
name|result
init|=
name|DLG_EXIT_UNKNOWN
decl_stmt|;
if|if
condition|(
name|labels
operator|!=
literal|0
condition|)
block|{
name|int
modifier|*
name|hotkeys
init|=
name|get_hotkeys
argument_list|(
name|labels
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
name|ch
operator|=
operator|(
name|int
operator|)
name|dlg_toupper
argument_list|(
name|dlg_last_getc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|hotkeys
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|labels
index|[
name|j
index|]
operator|!=
literal|0
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|ch
operator|==
name|hotkeys
index|[
name|j
index|]
condition|)
block|{
name|dlg_flush_getc
argument_list|()
expr_stmt|;
name|result
operator|=
name|j
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|hotkeys
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|my_yes_label
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|dialog_vars
operator|.
name|yes_label
operator|!=
name|NULL
operator|)
condition|?
name|dialog_vars
operator|.
name|yes_label
else|:
name|_
argument_list|(
literal|"Yes"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|my_no_label
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|dialog_vars
operator|.
name|no_label
operator|!=
name|NULL
operator|)
condition|?
name|dialog_vars
operator|.
name|no_label
else|:
name|_
argument_list|(
literal|"No"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|my_ok_label
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|dialog_vars
operator|.
name|ok_label
operator|!=
name|NULL
operator|)
condition|?
name|dialog_vars
operator|.
name|ok_label
else|:
name|_
argument_list|(
literal|"OK"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|my_cancel_label
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|dialog_vars
operator|.
name|cancel_label
operator|!=
name|NULL
operator|)
condition|?
name|dialog_vars
operator|.
name|cancel_label
else|:
name|_
argument_list|(
literal|"Cancel"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|my_exit_label
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|dialog_vars
operator|.
name|exit_label
operator|!=
name|NULL
operator|)
condition|?
name|dialog_vars
operator|.
name|exit_label
else|:
name|_
argument_list|(
literal|"EXIT"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|my_extra_label
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|dialog_vars
operator|.
name|extra_label
operator|!=
name|NULL
operator|)
condition|?
name|dialog_vars
operator|.
name|extra_label
else|:
name|_
argument_list|(
literal|"Extra"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|my_help_label
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|dialog_vars
operator|.
name|help_label
operator|!=
name|NULL
operator|)
condition|?
name|dialog_vars
operator|.
name|help_label
else|:
name|_
argument_list|(
literal|"Help"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a list of button labels.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
modifier|*
name|dlg_exit_label
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
name|DIALOG_VARS
name|save
decl_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|extra_button
condition|)
block|{
name|dlg_save_vars
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|nocancel
operator|=
name|TRUE
expr_stmt|;
name|result
operator|=
name|dlg_ok_labels
argument_list|()
expr_stmt|;
name|dlg_restore_vars
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|static
specifier|const
name|char
modifier|*
name|labels
index|[
literal|3
index|]
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|dialog_vars
operator|.
name|nook
condition|)
name|labels
index|[
name|n
operator|++
index|]
operator|=
name|my_exit_label
argument_list|()
expr_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|help_button
condition|)
name|labels
index|[
name|n
operator|++
index|]
operator|=
name|my_help_label
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|labels
index|[
name|n
operator|++
index|]
operator|=
name|my_exit_label
argument_list|()
expr_stmt|;
name|labels
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|labels
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Map the given button index for dlg_exit_label() into our exit-code.  */
end_comment

begin_function
name|int
name|dlg_exit_buttoncode
parameter_list|(
name|int
name|button
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|DIALOG_VARS
name|save
decl_stmt|;
name|dlg_save_vars
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|nocancel
operator|=
name|TRUE
expr_stmt|;
name|result
operator|=
name|dlg_ok_buttoncode
argument_list|(
name|button
argument_list|)
expr_stmt|;
name|dlg_restore_vars
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
modifier|*
name|dlg_ok_label
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|labels
index|[
literal|4
index|]
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|labels
index|[
name|n
operator|++
index|]
operator|=
name|my_ok_label
argument_list|()
expr_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|extra_button
condition|)
name|labels
index|[
name|n
operator|++
index|]
operator|=
name|my_extra_label
argument_list|()
expr_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|help_button
condition|)
name|labels
index|[
name|n
operator|++
index|]
operator|=
name|my_help_label
argument_list|()
expr_stmt|;
name|labels
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|labels
return|;
block|}
end_function

begin_comment
comment|/*  * Return a list of button labels for the OK/Cancel group.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
modifier|*
name|dlg_ok_labels
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|labels
index|[
literal|5
index|]
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|dialog_vars
operator|.
name|nook
condition|)
name|labels
index|[
name|n
operator|++
index|]
operator|=
name|my_ok_label
argument_list|()
expr_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|extra_button
condition|)
name|labels
index|[
name|n
operator|++
index|]
operator|=
name|my_extra_label
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|dialog_vars
operator|.
name|nocancel
condition|)
name|labels
index|[
name|n
operator|++
index|]
operator|=
name|my_cancel_label
argument_list|()
expr_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|help_button
condition|)
name|labels
index|[
name|n
operator|++
index|]
operator|=
name|my_help_label
argument_list|()
expr_stmt|;
name|labels
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|labels
return|;
block|}
end_function

begin_comment
comment|/*  * Map the given button index for dlg_ok_labels() into our exit-code  */
end_comment

begin_function
name|int
name|dlg_ok_buttoncode
parameter_list|(
name|int
name|button
parameter_list|)
block|{
name|int
name|result
init|=
name|DLG_EXIT_ERROR
decl_stmt|;
name|int
name|n
init|=
operator|!
name|dialog_vars
operator|.
name|nook
decl_stmt|;
if|if
condition|(
operator|!
name|dialog_vars
operator|.
name|nook
operator|&&
operator|(
name|button
operator|<=
literal|0
operator|)
condition|)
block|{
name|result
operator|=
name|DLG_EXIT_OK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dialog_vars
operator|.
name|extra_button
operator|&&
operator|(
name|button
operator|==
name|n
operator|++
operator|)
condition|)
block|{
name|result
operator|=
name|DLG_EXIT_EXTRA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|dialog_vars
operator|.
name|nocancel
operator|&&
operator|(
name|button
operator|==
name|n
operator|++
operator|)
condition|)
block|{
name|result
operator|=
name|DLG_EXIT_CANCEL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dialog_vars
operator|.
name|help_button
operator|&&
operator|(
name|button
operator|==
name|n
operator|)
condition|)
block|{
name|result
operator|=
name|DLG_EXIT_HELP
expr_stmt|;
block|}
name|dlg_trace_msg
argument_list|(
literal|"# dlg_ok_buttoncode(%d) = %d\n"
argument_list|,
name|button
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Given that we're using dlg_ok_labels() to list buttons, find the next index  * in the list of buttons.  The 'extra' parameter if negative provides a way to  * enumerate extra active areas on the widget.  */
end_comment

begin_function
name|int
name|dlg_next_ok_buttonindex
parameter_list|(
name|int
name|current
parameter_list|,
name|int
name|extra
parameter_list|)
block|{
name|int
name|result
init|=
name|current
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|current
operator|>=
literal|0
operator|&&
name|dlg_ok_buttoncode
argument_list|(
name|result
argument_list|)
operator|<
literal|0
condition|)
name|result
operator|=
name|extra
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Similarly, find the previous button index.  */
end_comment

begin_function
name|int
name|dlg_prev_ok_buttonindex
parameter_list|(
name|int
name|current
parameter_list|,
name|int
name|extra
parameter_list|)
block|{
name|int
name|result
init|=
name|current
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|result
operator|<
name|extra
condition|)
block|{
for|for
control|(
name|result
operator|=
literal|0
init|;
name|dlg_ok_buttoncode
argument_list|(
name|result
operator|+
literal|1
argument_list|)
operator|>=
literal|0
condition|;
operator|++
name|result
control|)
block|{
empty_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Find the button-index for the "OK" or "Cancel" button, according to  * whether --defaultno is given.  If --nocancel was given, we always return  * the index for the first button (usually "OK" unless --nook was used).  */
end_comment

begin_function
name|int
name|dlg_defaultno_button
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|defaultno
operator|&&
operator|!
name|dialog_vars
operator|.
name|nocancel
condition|)
block|{
while|while
condition|(
name|dlg_ok_buttoncode
argument_list|(
name|result
argument_list|)
operator|!=
name|DLG_EXIT_CANCEL
condition|)
operator|++
name|result
expr_stmt|;
block|}
name|dlg_trace_msg
argument_list|(
literal|"# dlg_defaultno_button() = %d\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Find the button-index for a button named with --default-button. If the  * option was not specified, or if the selected button does not exist, return  * the index of the first button (usually "OK" unless --nook was used).  */
end_comment

begin_function
name|int
name|dlg_default_button
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|default_button
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|n
operator|=
name|dlg_ok_buttoncode
argument_list|(
name|i
argument_list|)
operator|)
operator|>=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|==
name|dialog_vars
operator|.
name|default_button
condition|)
block|{
name|result
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
name|dlg_trace_msg
argument_list|(
literal|"# dlg_default_button() = %d\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Return a list of buttons for Yes/No labels.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
modifier|*
name|dlg_yes_labels
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|extra_button
condition|)
block|{
name|result
operator|=
name|dlg_ok_labels
argument_list|()
expr_stmt|;
block|}
else|else
block|{
specifier|static
specifier|const
name|char
modifier|*
name|labels
index|[
literal|4
index|]
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|labels
index|[
name|n
operator|++
index|]
operator|=
name|my_yes_label
argument_list|()
expr_stmt|;
name|labels
index|[
name|n
operator|++
index|]
operator|=
name|my_no_label
argument_list|()
expr_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|help_button
condition|)
name|labels
index|[
name|n
operator|++
index|]
operator|=
name|my_help_label
argument_list|()
expr_stmt|;
name|labels
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|labels
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Map the given button index for dlg_yes_labels() into our exit-code.  */
end_comment

begin_function
name|int
name|dlg_yes_buttoncode
parameter_list|(
name|int
name|button
parameter_list|)
block|{
name|int
name|result
init|=
name|DLG_EXIT_ERROR
decl_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|extra_button
condition|)
block|{
name|result
operator|=
name|dlg_ok_buttoncode
argument_list|(
name|button
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|button
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|DLG_EXIT_OK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|button
operator|==
literal|1
condition|)
block|{
name|result
operator|=
name|DLG_EXIT_CANCEL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|button
operator|==
literal|2
operator|&&
name|dialog_vars
operator|.
name|help_button
condition|)
block|{
name|result
operator|=
name|DLG_EXIT_HELP
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Return the next index in labels[];  */
end_comment

begin_function
name|int
name|dlg_next_button
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|labels
parameter_list|,
name|int
name|button
parameter_list|)
block|{
if|if
condition|(
name|button
operator|<
operator|-
literal|1
condition|)
name|button
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|labels
index|[
name|button
operator|+
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
operator|++
name|button
expr_stmt|;
block|}
else|else
block|{
name|button
operator|=
name|MIN_BUTTON
expr_stmt|;
block|}
return|return
name|button
return|;
block|}
end_function

begin_comment
comment|/*  * Return the previous index in labels[];  */
end_comment

begin_function
name|int
name|dlg_prev_button
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|labels
parameter_list|,
name|int
name|button
parameter_list|)
block|{
if|if
condition|(
name|button
operator|>
name|MIN_BUTTON
condition|)
block|{
operator|--
name|button
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|button
operator|<
operator|-
literal|1
condition|)
name|button
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|labels
index|[
name|button
operator|+
literal|1
index|]
operator|!=
literal|0
condition|)
operator|++
name|button
expr_stmt|;
block|}
return|return
name|button
return|;
block|}
end_function

end_unit

