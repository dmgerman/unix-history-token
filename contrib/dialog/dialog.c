begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $Id: dialog.c,v 1.202 2012/07/01 20:20:39 tom Exp $  *  *  cdialog - Display simple dialog boxes from shell scripts  *  *  Copyright 2000-2011,2012	Thomas E. Dickey  *  *  This program is free software; you can redistribute it and/or modify  *  it under the terms of the GNU Lesser General Public License, version 2.1  *  as published by the Free Software Foundation.  *  *  This program is distributed in the hope that it will be useful, but  *  WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *  Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public  *  License along with this program; if not, write to  *	Free Software Foundation, Inc.  *	51 Franklin St., Fifth Floor  *	Boston, MA 02110, USA.  *  *  An earlier version of this program lists as authors  *	Savio Lam (lam836@cs.cuhk.hk)  */
end_comment

begin_include
include|#
directive|include
file|<dialog.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SETLOCALE
end_ifdef

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PASSARGS
value|t,       av,        offset_add
end_define

begin_define
define|#
directive|define
name|CALLARGS
value|const char *t, char *av[], int *offset_add
end_define

begin_typedef
typedef|typedef
name|int
function_decl|(
name|callerFn
function_decl|)
parameter_list|(
name|CALLARGS
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|o_unknown
init|=
literal|0
block|,
name|o_allow_close
block|,
name|o_and_widget
block|,
name|o_ascii_lines
block|,
name|o_aspect
block|,
name|o_auto_placement
block|,
name|o_backtitle
block|,
name|o_beep
block|,
name|o_beep_after
block|,
name|o_begin
block|,
name|o_calendar
block|,
name|o_cancel_label
block|,
name|o_checklist
block|,
name|o_clear
block|,
name|o_colors
block|,
name|o_column_separator
block|,
name|o_cr_wrap
block|,
name|o_create_rc
block|,
name|o_date_format
block|,
name|o_default_button
block|,
name|o_default_item
block|,
name|o_defaultno
block|,
name|o_dselect
block|,
name|o_editbox
block|,
name|o_exit_label
block|,
name|o_extra_button
block|,
name|o_extra_label
block|,
name|o_fixed_font
block|,
name|o_form
block|,
name|o_fselect
block|,
name|o_fullbutton
block|,
name|o_gauge
block|,
name|o_help
block|,
name|o_help_button
block|,
name|o_help_file
block|,
name|o_help_label
block|,
name|o_help_line
block|,
name|o_help_status
block|,
name|o_icon
block|,
name|o_ignore
block|,
name|o_infobox
block|,
name|o_input_fd
block|,
name|o_inputbox
block|,
name|o_inputmenu
block|,
name|o_insecure
block|,
name|o_item_help
block|,
name|o_keep_colors
block|,
name|o_keep_tite
block|,
name|o_keep_window
block|,
name|o_max_input
block|,
name|o_menu
block|,
name|o_mixedform
block|,
name|o_mixedgauge
block|,
name|o_msgbox
block|,
name|o_no_close
block|,
name|o_no_collapse
block|,
name|o_no_cr_wrap
block|,
name|o_no_kill
block|,
name|o_no_label
block|,
name|o_no_lines
block|,
name|o_no_mouse
block|,
name|o_no_nl_expand
block|,
name|o_no_shadow
block|,
name|o_nocancel
block|,
name|o_noitem
block|,
name|o_nook
block|,
name|o_ok_label
block|,
name|o_output_fd
block|,
name|o_output_separator
block|,
name|o_passwordbox
block|,
name|o_passwordform
block|,
name|o_pause
block|,
name|o_prgbox
block|,
name|o_print_maxsize
block|,
name|o_print_size
block|,
name|o_print_version
block|,
name|o_programbox
block|,
name|o_progressbox
block|,
name|o_quoted
block|,
name|o_radiolist
block|,
name|o_screen_center
block|,
name|o_scrollbar
block|,
name|o_separate_output
block|,
name|o_separate_widget
block|,
name|o_separator
block|,
name|o_shadow
block|,
name|o_single_quoted
block|,
name|o_size_err
block|,
name|o_sleep
block|,
name|o_smooth
block|,
name|o_stderr
block|,
name|o_stdout
block|,
name|o_tab_correct
block|,
name|o_tab_len
block|,
name|o_tailbox
block|,
name|o_tailboxbg
block|,
name|o_textbox
block|,
name|o_time_format
block|,
name|o_timebox
block|,
name|o_timeout
block|,
name|o_title
block|,
name|o_trim
block|,
name|o_under_mouse
block|,
name|o_version
block|,
name|o_visit_items
block|,
name|o_wmclass
block|,
name|o_yes_label
block|,
name|o_yesno
ifdef|#
directive|ifdef
name|HAVE_DLG_TRACE
block|,
name|o_trace
endif|#
directive|endif
block|}
name|eOptions
typedef|;
end_typedef

begin_comment
comment|/*  * The bits in 'pass' are used to decide which options are applicable at  * different stages in the program:  *	1 flags before widgets  *	2 widgets  *	4 non-widget options  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|eOptions
name|code
decl_stmt|;
name|int
name|pass
decl_stmt|;
comment|/* 1,2,4 or combination */
specifier|const
name|char
modifier|*
name|help
decl_stmt|;
comment|/* NULL to suppress, non-empty to display params */
block|}
name|Options
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|eOptions
name|code
decl_stmt|;
name|int
name|argmin
decl_stmt|,
name|argmax
decl_stmt|;
name|callerFn
modifier|*
name|jumper
decl_stmt|;
block|}
name|Mode
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|bool
modifier|*
name|dialog_opts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|dialog_argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|ignore_unknown
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|program
init|=
literal|"dialog"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The options[] table is organized this way to make it simple to maintain  * a sorted list of options for the help-message.  */
end_comment

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|Options
name|options
index|[]
init|=
block|{
block|{
literal|"allow-close"
block|,
name|o_allow_close
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"and-widget"
block|,
name|o_and_widget
block|,
literal|4
block|,
name|NULL
block|}
block|,
block|{
literal|"ascii-lines"
block|,
name|o_ascii_lines
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"aspect"
block|,
name|o_aspect
block|,
literal|1
block|,
literal|"<ratio>"
block|}
block|,
block|{
literal|"auto-placement"
block|,
name|o_auto_placement
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"backtitle"
block|,
name|o_backtitle
block|,
literal|1
block|,
literal|"<backtitle>"
block|}
block|,
block|{
literal|"beep"
block|,
name|o_beep
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"beep-after"
block|,
name|o_beep_after
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"begin"
block|,
name|o_begin
block|,
literal|1
block|,
literal|"<y><x>"
block|}
block|,
block|{
literal|"calendar"
block|,
name|o_calendar
block|,
literal|2
block|,
literal|"<text><height><width><day><month><year>"
block|}
block|,
block|{
literal|"cancel-label"
block|,
name|o_cancel_label
block|,
literal|1
block|,
literal|"<str>"
block|}
block|,
block|{
literal|"checklist"
block|,
name|o_checklist
block|,
literal|2
block|,
literal|"<text><height><width><list height><tag1><item1><status1>..."
block|}
block|,
block|{
literal|"clear"
block|,
name|o_clear
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"colors"
block|,
name|o_colors
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"column-separator"
block|,
name|o_column_separator
block|,
literal|1
block|,
literal|"<str>"
block|}
block|,
block|{
literal|"cr-wrap"
block|,
name|o_cr_wrap
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"create-rc"
block|,
name|o_create_rc
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"date-format"
block|,
name|o_date_format
block|,
literal|1
block|,
literal|"<str>"
block|}
block|,
block|{
literal|"default-button"
block|,
name|o_default_button
block|,
literal|1
block|,
literal|"<str>"
block|}
block|,
block|{
literal|"default-item"
block|,
name|o_default_item
block|,
literal|1
block|,
literal|"<str>"
block|}
block|,
block|{
literal|"defaultno"
block|,
name|o_defaultno
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"dselect"
block|,
name|o_dselect
block|,
literal|2
block|,
literal|"<directory><height><width>"
block|}
block|,
block|{
literal|"editbox"
block|,
name|o_editbox
block|,
literal|2
block|,
literal|"<file><height><width>"
block|}
block|,
block|{
literal|"exit-label"
block|,
name|o_exit_label
block|,
literal|1
block|,
literal|"<str>"
block|}
block|,
block|{
literal|"extra-button"
block|,
name|o_extra_button
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"extra-label"
block|,
name|o_extra_label
block|,
literal|1
block|,
literal|"<str>"
block|}
block|,
block|{
literal|"fb"
block|,
name|o_fullbutton
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"fixed-font"
block|,
name|o_fixed_font
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"form"
block|,
name|o_form
block|,
literal|2
block|,
literal|"<text><height><width><form height><label1><l_y1><l_x1><item1><i_y1><i_x1><flen1><ilen1>..."
block|}
block|,
block|{
literal|"fselect"
block|,
name|o_fselect
block|,
literal|2
block|,
literal|"<filepath><height><width>"
block|}
block|,
block|{
literal|"fullbutton"
block|,
name|o_fullbutton
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"gauge"
block|,
name|o_gauge
block|,
literal|2
block|,
literal|"<text><height><width> [<percent>]"
block|}
block|,
block|{
literal|"guage"
block|,
name|o_gauge
block|,
literal|2
block|,
name|NULL
block|}
block|,
block|{
literal|"help"
block|,
name|o_help
block|,
literal|4
block|,
literal|""
block|}
block|,
block|{
literal|"help-button"
block|,
name|o_help_button
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"help-label"
block|,
name|o_help_label
block|,
literal|1
block|,
literal|"<str>"
block|}
block|,
block|{
literal|"help-status"
block|,
name|o_help_status
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"hfile"
block|,
name|o_help_file
block|,
literal|1
block|,
literal|"<str>"
block|}
block|,
block|{
literal|"hline"
block|,
name|o_help_line
block|,
literal|1
block|,
literal|"<str>"
block|}
block|,
block|{
literal|"icon"
block|,
name|o_icon
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"ignore"
block|,
name|o_ignore
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"infobox"
block|,
name|o_infobox
block|,
literal|2
block|,
literal|"<text><height><width>"
block|}
block|,
block|{
literal|"input-fd"
block|,
name|o_input_fd
block|,
literal|1
block|,
literal|"<fd>"
block|}
block|,
block|{
literal|"inputbox"
block|,
name|o_inputbox
block|,
literal|2
block|,
literal|"<text><height><width> [<init>]"
block|}
block|,
block|{
literal|"inputmenu"
block|,
name|o_inputmenu
block|,
literal|2
block|,
literal|"<text><height><width><menu height><tag1><item1>..."
block|}
block|,
block|{
literal|"insecure"
block|,
name|o_insecure
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"item-help"
block|,
name|o_item_help
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"keep-colors"
block|,
name|o_keep_colors
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"keep-tite"
block|,
name|o_keep_tite
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"keep-window"
block|,
name|o_keep_window
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"max-input"
block|,
name|o_max_input
block|,
literal|1
block|,
literal|"<n>"
block|}
block|,
block|{
literal|"menu"
block|,
name|o_menu
block|,
literal|2
block|,
literal|"<text><height><width><menu height><tag1><item1>..."
block|}
block|,
block|{
literal|"mixedform"
block|,
name|o_mixedform
block|,
literal|2
block|,
literal|"<text><height><width><form height><label1><l_y1><l_x1><item1><i_y1><i_x1><flen1><ilen1><itype>..."
block|}
block|,
block|{
literal|"mixedgauge"
block|,
name|o_mixedgauge
block|,
literal|2
block|,
literal|"<text><height><width><percent><tag1><item1>..."
block|}
block|,
block|{
literal|"msgbox"
block|,
name|o_msgbox
block|,
literal|2
block|,
literal|"<text><height><width>"
block|}
block|,
block|{
literal|"no-cancel"
block|,
name|o_nocancel
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"no-close"
block|,
name|o_no_close
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"no-collapse"
block|,
name|o_no_collapse
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"no-cr-wrap"
block|,
name|o_no_cr_wrap
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"no-kill"
block|,
name|o_no_kill
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"no-label"
block|,
name|o_no_label
block|,
literal|1
block|,
literal|"<str>"
block|}
block|,
block|{
literal|"no-lines"
block|,
name|o_no_lines
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"no-mouse"
block|,
name|o_no_mouse
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"no-nl-expand"
block|,
name|o_no_nl_expand
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"no-ok"
block|,
name|o_nook
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"no-shadow"
block|,
name|o_no_shadow
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"nocancel"
block|,
name|o_nocancel
block|,
literal|1
block|,
name|NULL
block|}
block|,
comment|/* see --no-cancel */
block|{
literal|"noitem"
block|,
name|o_noitem
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"nook"
block|,
name|o_nook
block|,
literal|1
block|,
literal|""
block|}
block|,
comment|/* See no-ok */
block|{
literal|"ok-label"
block|,
name|o_ok_label
block|,
literal|1
block|,
literal|"<str>"
block|}
block|,
block|{
literal|"output-fd"
block|,
name|o_output_fd
block|,
literal|1
block|,
literal|"<fd>"
block|}
block|,
block|{
literal|"output-separator"
block|,
name|o_output_separator
block|,
literal|1
block|,
literal|"<str>"
block|}
block|,
block|{
literal|"passwordbox"
block|,
name|o_passwordbox
block|,
literal|2
block|,
literal|"<text><height><width> [<init>]"
block|}
block|,
block|{
literal|"passwordform"
block|,
name|o_passwordform
block|,
literal|2
block|,
literal|"<text><height><width><form height><label1><l_y1><l_x1><item1><i_y1><i_x1><flen1><ilen1>..."
block|}
block|,
block|{
literal|"pause"
block|,
name|o_pause
block|,
literal|2
block|,
literal|"<text><height><width><seconds>"
block|}
block|,
block|{
literal|"prgbox"
block|,
name|o_prgbox
block|,
literal|2
block|,
literal|"<text><command><height><width>"
block|}
block|,
block|{
literal|"print-maxsize"
block|,
name|o_print_maxsize
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"print-size"
block|,
name|o_print_size
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"print-version"
block|,
name|o_print_version
block|,
literal|5
block|,
literal|""
block|}
block|,
block|{
literal|"programbox"
block|,
name|o_programbox
block|,
literal|2
block|,
literal|"<text><height><width>"
block|}
block|,
block|{
literal|"progressbox"
block|,
name|o_progressbox
block|,
literal|2
block|,
literal|"<text><height><width>"
block|}
block|,
block|{
literal|"quoted"
block|,
name|o_quoted
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"radiolist"
block|,
name|o_radiolist
block|,
literal|2
block|,
literal|"<text><height><width><list height><tag1><item1><status1>..."
block|}
block|,
block|{
literal|"screen-center"
block|,
name|o_screen_center
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"scrollbar"
block|,
name|o_scrollbar
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"separate-output"
block|,
name|o_separate_output
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"separate-widget"
block|,
name|o_separate_widget
block|,
literal|1
block|,
literal|"<str>"
block|}
block|,
block|{
literal|"separator"
block|,
name|o_separator
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"shadow"
block|,
name|o_shadow
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"single-quoted"
block|,
name|o_single_quoted
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"size-err"
block|,
name|o_size_err
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"sleep"
block|,
name|o_sleep
block|,
literal|1
block|,
literal|"<secs>"
block|}
block|,
block|{
literal|"smooth"
block|,
name|o_smooth
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"stderr"
block|,
name|o_stderr
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"stdout"
block|,
name|o_stdout
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"tab-correct"
block|,
name|o_tab_correct
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"tab-len"
block|,
name|o_tab_len
block|,
literal|1
block|,
literal|"<n>"
block|}
block|,
block|{
literal|"tailbox"
block|,
name|o_tailbox
block|,
literal|2
block|,
literal|"<file><height><width>"
block|}
block|,
block|{
literal|"tailboxbg"
block|,
name|o_tailboxbg
block|,
literal|2
block|,
literal|"<file><height><width>"
block|}
block|,
block|{
literal|"textbox"
block|,
name|o_textbox
block|,
literal|2
block|,
literal|"<file><height><width>"
block|}
block|,
block|{
literal|"time-format"
block|,
name|o_time_format
block|,
literal|1
block|,
literal|"<str>"
block|}
block|,
block|{
literal|"timebox"
block|,
name|o_timebox
block|,
literal|2
block|,
literal|"<text><height><width><hour><minute><second>"
block|}
block|,
block|{
literal|"timeout"
block|,
name|o_timeout
block|,
literal|1
block|,
literal|"<secs>"
block|}
block|,
block|{
literal|"title"
block|,
name|o_title
block|,
literal|1
block|,
literal|"<title>"
block|}
block|,
block|{
literal|"trim"
block|,
name|o_trim
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"under-mouse"
block|,
name|o_under_mouse
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"version"
block|,
name|o_version
block|,
literal|5
block|,
literal|""
block|}
block|,
block|{
literal|"visit-items"
block|,
name|o_visit_items
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"wmclass"
block|,
name|o_wmclass
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"yes-label"
block|,
name|o_yes_label
block|,
literal|1
block|,
literal|"<str>"
block|}
block|,
block|{
literal|"yesno"
block|,
name|o_yesno
block|,
literal|2
block|,
literal|"<text><height><width>"
block|}
block|,
ifdef|#
directive|ifdef
name|HAVE_DLG_TRACE
block|{
literal|"trace"
block|,
name|o_trace
block|,
literal|1
block|,
literal|"<file>"
block|}
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_comment
comment|/*  * Make an array showing which argv[] entries are options.  Use "--" as a  * special token to escape the next argument, allowing it to begin with "--".  * When we find a "--" argument, also remove it from argv[] and adjust argc.  * That appears to be an undocumented feature of the popt library.  *  * Also, if we see a "--file", expand it into the parameter list by reading the  * text from the given file and stripping quotes, treating whitespace outside  * quotes as a parameter delimiter.  *  * Finally, if we see a "--args", dump the current list of arguments to the  * standard error.  This is used for debugging complex --file combinations.  */
end_comment

begin_function
specifier|static
name|void
name|unescape_argv
parameter_list|(
name|int
modifier|*
name|argcp
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|argvp
parameter_list|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|limit_includes
init|=
literal|20
operator|+
operator|*
name|argcp
decl_stmt|;
name|int
name|count_includes
init|=
literal|0
decl_stmt|;
name|bool
name|changed
init|=
name|FALSE
decl_stmt|;
name|bool
name|doalloc
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|dialog_opts
operator|=
name|dlg_calloc
argument_list|(
name|bool
argument_list|,
operator|(
name|size_t
operator|)
operator|*
name|argcp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|assert_ptr
argument_list|(
name|dialog_opts
argument_list|,
literal|"unescape_argv"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
operator|*
name|argcp
condition|;
name|j
operator|++
control|)
block|{
name|bool
name|escaped
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|*
name|argvp
operator|)
index|[
name|j
index|]
argument_list|,
literal|"--"
argument_list|)
condition|)
block|{
name|escaped
operator|=
name|TRUE
expr_stmt|;
name|changed
operator|=
name|dlg_eat_argv
argument_list|(
name|argcp
argument_list|,
name|argvp
argument_list|,
name|j
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|*
name|argvp
operator|)
index|[
name|j
index|]
argument_list|,
literal|"--args"
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Showing arguments at arg%d\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|*
name|argcp
condition|;
operator|++
name|k
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" arg%d:%s\n"
argument_list|,
name|k
argument_list|,
operator|(
operator|*
name|argvp
operator|)
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
name|changed
operator|=
name|dlg_eat_argv
argument_list|(
name|argcp
argument_list|,
name|argvp
argument_list|,
name|j
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|*
name|argvp
operator|)
index|[
name|j
index|]
argument_list|,
literal|"--file"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|count_includes
operator|>
name|limit_includes
condition|)
name|dlg_exiterr
argument_list|(
literal|"Too many --file options"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|filename
operator|=
operator|(
operator|*
name|argvp
operator|)
index|[
name|j
operator|+
literal|1
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|blob
decl_stmt|;
name|int
name|added
decl_stmt|;
name|size_t
name|bytes_read
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|*
name|filename
operator|==
literal|'&'
condition|)
block|{
name|fp
operator|=
name|fdopen
argument_list|(
name|atoi
argument_list|(
name|filename
operator|+
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
condition|)
block|{
name|blob
operator|=
name|NULL
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|blob
operator|=
name|dlg_realloc
argument_list|(
name|char
argument_list|,
name|length
operator|+
name|BUFSIZ
operator|+
literal|1
argument_list|,
name|blob
argument_list|)
expr_stmt|;
name|assert_ptr
argument_list|(
name|blob
argument_list|,
literal|"unescape_argv"
argument_list|)
expr_stmt|;
name|bytes_read
operator|=
name|fread
argument_list|(
name|blob
operator|+
name|length
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|BUFSIZ
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|length
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|dlg_exiterr
argument_list|(
literal|"error on filehandle in unescape_argv"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|bytes_read
operator|==
name|BUFSIZ
condition|)
do|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|blob
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|list
operator|=
name|dlg_string_to_argv
argument_list|(
name|blob
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|added
operator|=
name|dlg_count_argv
argument_list|(
name|list
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|added
operator|>
literal|2
condition|)
block|{
name|size_t
name|need
init|=
call|(
name|size_t
call|)
argument_list|(
operator|*
name|argcp
operator|+
name|added
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|doalloc
condition|)
block|{
operator|*
name|argvp
operator|=
name|dlg_realloc
argument_list|(
name|char
operator|*
argument_list|,
name|need
argument_list|,
operator|*
name|argvp
argument_list|)
expr_stmt|;
name|assert_ptr
argument_list|(
operator|*
name|argvp
argument_list|,
literal|"unescape_argv"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
modifier|*
name|newp
init|=
name|dlg_malloc
argument_list|(
name|char
operator|*
argument_list|,
name|need
argument_list|)
decl_stmt|;
name|assert_ptr
argument_list|(
name|newp
argument_list|,
literal|"unescape_argv"
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|*
name|argcp
condition|;
operator|++
name|n
control|)
block|{
name|newp
index|[
name|n
index|]
operator|=
operator|(
operator|*
name|argvp
operator|)
index|[
name|n
index|]
expr_stmt|;
block|}
operator|*
name|argvp
operator|=
name|newp
expr_stmt|;
name|doalloc
operator|=
name|TRUE
expr_stmt|;
block|}
name|dialog_opts
operator|=
name|dlg_realloc
argument_list|(
name|bool
argument_list|,
name|need
argument_list|,
name|dialog_opts
argument_list|)
expr_stmt|;
name|assert_ptr
argument_list|(
name|dialog_opts
argument_list|,
literal|"unescape_argv"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
operator|*
name|argcp
init|;
name|n
operator|>=
name|j
operator|+
literal|2
condition|;
operator|--
name|n
control|)
block|{
operator|(
operator|*
name|argvp
operator|)
index|[
name|n
operator|+
name|added
operator|-
literal|2
index|]
operator|=
operator|(
operator|*
name|argvp
operator|)
index|[
name|n
index|]
expr_stmt|;
name|dialog_opts
index|[
name|n
operator|+
name|added
operator|-
literal|2
index|]
operator|=
name|dialog_opts
index|[
name|n
index|]
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|added
condition|;
operator|++
name|n
control|)
block|{
operator|(
operator|*
name|argvp
operator|)
index|[
name|n
operator|+
name|j
index|]
operator|=
name|list
index|[
name|n
index|]
expr_stmt|;
name|dialog_opts
index|[
name|n
operator|+
name|j
index|]
operator|=
name|FALSE
expr_stmt|;
block|}
operator|*
name|argcp
operator|+=
name|added
operator|-
literal|2
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dlg_exiterr
argument_list|(
literal|"Cannot open --file %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|argvp
operator|)
index|[
operator|*
name|argcp
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|j
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|dlg_exiterr
argument_list|(
literal|"No value given for --file"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|escaped
operator|&&
operator|(
operator|*
name|argvp
operator|)
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
operator|!
name|strncmp
argument_list|(
operator|(
operator|*
name|argvp
operator|)
index|[
name|j
index|]
argument_list|,
literal|"--"
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
operator|&&
name|isalpha
argument_list|(
name|UCH
argument_list|(
operator|(
operator|*
name|argvp
operator|)
index|[
name|j
index|]
index|[
literal|2
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|dialog_opts
index|[
name|j
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* if we didn't find any "--" tokens, there's no reason to do the table      * lookup in isOption()      */
if|if
condition|(
operator|!
name|changed
condition|)
block|{
name|free
argument_list|(
name|dialog_opts
argument_list|)
expr_stmt|;
name|dialog_opts
operator|=
literal|0
expr_stmt|;
block|}
name|dialog_argv
operator|=
operator|(
operator|*
name|argvp
operator|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|OptionChars
value|"\ 0123456789\ -\ abcdefghijklmnopqrstuvwxyz\ "
end_define

begin_comment
comment|/*  * Check if the given string from main's argv is an option.  */
end_comment

begin_function
specifier|static
name|bool
name|isOption
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|arg
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dialog_opts
operator|!=
literal|0
condition|)
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|dialog_argv
index|[
name|n
index|]
operator|!=
literal|0
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
name|dialog_argv
index|[
name|n
index|]
operator|==
name|arg
condition|)
block|{
name|result
operator|=
name|dialog_opts
index|[
name|n
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"--"
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
operator|&&
name|isalpha
argument_list|(
name|UCH
argument_list|(
name|arg
index|[
literal|2
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|==
name|strspn
argument_list|(
name|arg
argument_list|,
name|OptionChars
argument_list|)
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|dlg_exiterr
argument_list|(
literal|"Invalid option \"%s\""
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|eOptions
name|lookupOption
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|unsigned
name|n
decl_stmt|;
name|eOptions
name|result
init|=
name|o_unknown
decl_stmt|;
if|if
condition|(
name|isOption
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|name
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
sizeof|sizeof
argument_list|(
name|options
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|options
index|[
literal|0
index|]
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pass
operator|&
name|options
index|[
name|n
index|]
operator|.
name|pass
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|options
index|[
name|n
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|result
operator|=
name|options
index|[
name|n
index|]
operator|.
name|code
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|Usage
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|dlg_exiterr
argument_list|(
literal|"Error: %s.\nUse --help to list options.\n\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Count arguments, stopping at the end of the argument list, or on any of our  * "--" tokens.  */
end_comment

begin_function
specifier|static
name|int
name|arg_rest
parameter_list|(
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
comment|/* argv[0] points to a "--" token */
while|while
condition|(
name|argv
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|isOption
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|||
name|lookupOption
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|7
argument_list|)
operator|==
name|o_unknown
operator|)
condition|)
name|i
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*  * In MultiWidget this function is needed to count how many tags  * a widget (menu, checklist, radiolist) has  */
end_comment

begin_function
specifier|static
name|int
name|howmany_tags
parameter_list|(
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|int
name|group
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|int
name|have
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
init|=
literal|"Expected %d arguments, found only %d"
decl_stmt|;
name|char
name|temp
index|[
literal|80
index|]
decl_stmt|;
while|while
condition|(
name|argv
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|isOption
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|have
operator|=
name|arg_rest
argument_list|(
name|argv
argument_list|)
operator|)
operator|<
name|group
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
name|format
argument_list|,
name|group
argument_list|,
name|have
argument_list|)
expr_stmt|;
name|Usage
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|argv
operator|+=
name|group
expr_stmt|;
name|result
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|numeric_arg
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|char
modifier|*
name|last
init|=
literal|0
decl_stmt|;
name|int
name|result
init|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|av
index|[
name|n
index|]
argument_list|,
operator|&
name|last
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|char
name|msg
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|last
operator|==
literal|0
operator|||
operator|*
name|last
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"Expected a number for token %d of %.20s"
argument_list|,
name|n
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|Usage
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|optional_str
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|,
name|int
name|n
parameter_list|,
name|char
modifier|*
name|dft
parameter_list|)
block|{
name|char
modifier|*
name|ret
init|=
name|dft
decl_stmt|;
if|if
condition|(
name|arg_rest
argument_list|(
name|av
argument_list|)
operator|>
name|n
condition|)
name|ret
operator|=
name|av
index|[
name|n
index|]
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_DLG_GAUGE
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_XDIALOG
argument_list|)
end_if

begin_function
specifier|static
name|int
name|optional_num
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|dft
parameter_list|)
block|{
name|int
name|ret
init|=
name|dft
decl_stmt|;
if|if
condition|(
name|arg_rest
argument_list|(
name|av
argument_list|)
operator|>
name|n
condition|)
name|ret
operator|=
name|numeric_arg
argument_list|(
name|av
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * On AIX 4.x, we have to flush the output right away since there is a bug in  * the curses package which discards stdout even when we've used newterm to  * redirect output to /dev/tty.  */
end_comment

begin_function
specifier|static
name|int
name|show_result
parameter_list|(
name|int
name|ret
parameter_list|)
block|{
name|bool
name|either
init|=
name|FALSE
decl_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|DLG_EXIT_OK
case|:
case|case
name|DLG_EXIT_EXTRA
case|:
case|case
name|DLG_EXIT_HELP
case|:
case|case
name|DLG_EXIT_ITEM_HELP
case|:
if|if
condition|(
operator|(
name|dialog_state
operator|.
name|output_count
operator|>
literal|1
operator|)
operator|&&
operator|!
name|dialog_vars
operator|.
name|separate_output
condition|)
block|{
name|fputs
argument_list|(
operator|(
name|dialog_state
operator|.
name|separate_str
condition|?
name|dialog_state
operator|.
name|separate_str
else|:
name|DEFAULT_SEPARATE_STR
operator|)
argument_list|,
name|dialog_state
operator|.
name|output
argument_list|)
expr_stmt|;
name|either
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|dialog_vars
operator|.
name|input_result
operator|!=
literal|0
operator|&&
name|dialog_vars
operator|.
name|input_result
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|fputs
argument_list|(
name|dialog_vars
operator|.
name|input_result
argument_list|,
name|dialog_state
operator|.
name|output
argument_list|)
expr_stmt|;
name|either
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|either
condition|)
block|{
name|fflush
argument_list|(
name|dialog_state
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * These are the widget callers.  */
end_comment

begin_function
specifier|static
name|int
name|call_yesno
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
operator|*
name|offset_add
operator|=
literal|4
expr_stmt|;
return|return
name|dialog_yesno
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_msgbox
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
operator|*
name|offset_add
operator|=
literal|4
expr_stmt|;
return|return
name|dialog_msgbox
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_infobox
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
operator|*
name|offset_add
operator|=
literal|4
expr_stmt|;
return|return
name|dialog_msgbox
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_textbox
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
operator|*
name|offset_add
operator|=
literal|4
expr_stmt|;
return|return
name|dialog_textbox
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_menu
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
name|int
name|tags
init|=
name|howmany_tags
argument_list|(
name|av
operator|+
literal|5
argument_list|,
name|MENUBOX_TAGS
argument_list|)
decl_stmt|;
operator|*
name|offset_add
operator|=
literal|5
operator|+
name|tags
operator|*
name|MENUBOX_TAGS
expr_stmt|;
return|return
name|dialog_menu
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|4
argument_list|)
argument_list|,
name|tags
argument_list|,
name|av
operator|+
literal|5
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_inputmenu
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
name|int
name|tags
init|=
name|howmany_tags
argument_list|(
name|av
operator|+
literal|5
argument_list|,
name|MENUBOX_TAGS
argument_list|)
decl_stmt|;
name|bool
name|free_extra_label
init|=
name|FALSE
decl_stmt|;
name|int
name|result
decl_stmt|;
name|dialog_vars
operator|.
name|input_menu
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|max_input
operator|==
literal|0
condition|)
name|dialog_vars
operator|.
name|max_input
operator|=
name|MAX_LEN
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|extra_label
operator|==
literal|0
condition|)
block|{
name|free_extra_label
operator|=
name|TRUE
expr_stmt|;
name|dialog_vars
operator|.
name|extra_label
operator|=
name|dlg_strclone
argument_list|(
name|_
argument_list|(
literal|"Rename"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dialog_vars
operator|.
name|extra_button
operator|=
name|TRUE
expr_stmt|;
operator|*
name|offset_add
operator|=
literal|5
operator|+
name|tags
operator|*
name|MENUBOX_TAGS
expr_stmt|;
name|result
operator|=
name|dialog_menu
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|4
argument_list|)
argument_list|,
name|tags
argument_list|,
name|av
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_extra_label
condition|)
block|{
name|free
argument_list|(
name|dialog_vars
operator|.
name|extra_label
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|extra_label
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_checklist
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
name|int
name|tags
init|=
name|howmany_tags
argument_list|(
name|av
operator|+
literal|5
argument_list|,
name|CHECKBOX_TAGS
argument_list|)
decl_stmt|;
name|int
name|code
decl_stmt|;
operator|*
name|offset_add
operator|=
literal|5
operator|+
name|tags
operator|*
name|CHECKBOX_TAGS
expr_stmt|;
name|code
operator|=
name|dialog_checklist
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|4
argument_list|)
argument_list|,
name|tags
argument_list|,
name|av
operator|+
literal|5
argument_list|,
name|FLAG_CHECK
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_radiolist
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
name|int
name|tags
init|=
name|howmany_tags
argument_list|(
name|av
operator|+
literal|5
argument_list|,
name|CHECKBOX_TAGS
argument_list|)
decl_stmt|;
operator|*
name|offset_add
operator|=
literal|5
operator|+
name|tags
operator|*
name|CHECKBOX_TAGS
expr_stmt|;
return|return
name|dialog_checklist
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|4
argument_list|)
argument_list|,
name|tags
argument_list|,
name|av
operator|+
literal|5
argument_list|,
name|FLAG_RADIO
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_inputbox
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
operator|*
name|offset_add
operator|=
name|arg_rest
argument_list|(
name|av
argument_list|)
expr_stmt|;
return|return
name|dialog_inputbox
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
name|optional_str
argument_list|(
name|av
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_passwordbox
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
operator|*
name|offset_add
operator|=
name|arg_rest
argument_list|(
name|av
argument_list|)
expr_stmt|;
return|return
name|dialog_inputbox
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
name|optional_str
argument_list|(
name|av
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_XDIALOG
end_ifdef

begin_function
specifier|static
name|int
name|call_calendar
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
operator|*
name|offset_add
operator|=
name|arg_rest
argument_list|(
name|av
argument_list|)
expr_stmt|;
return|return
name|dialog_calendar
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
name|optional_num
argument_list|(
name|av
argument_list|,
literal|4
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|optional_num
argument_list|(
name|av
argument_list|,
literal|5
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|optional_num
argument_list|(
name|av
argument_list|,
literal|6
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_dselect
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
operator|*
name|offset_add
operator|=
name|arg_rest
argument_list|(
name|av
argument_list|)
expr_stmt|;
return|return
name|dialog_dselect
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_editbox
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
operator|*
name|offset_add
operator|=
literal|4
expr_stmt|;
return|return
name|dialog_editbox
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_fselect
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
operator|*
name|offset_add
operator|=
name|arg_rest
argument_list|(
name|av
argument_list|)
expr_stmt|;
return|return
name|dialog_fselect
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_timebox
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
operator|*
name|offset_add
operator|=
name|arg_rest
argument_list|(
name|av
argument_list|)
expr_stmt|;
return|return
name|dialog_timebox
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
name|optional_num
argument_list|(
name|av
argument_list|,
literal|4
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|optional_num
argument_list|(
name|av
argument_list|,
literal|5
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|optional_num
argument_list|(
name|av
argument_list|,
literal|6
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_XDIALOG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DLG_FORMBOX
end_ifdef

begin_function
specifier|static
name|int
name|call_form
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
name|int
name|group
init|=
name|FORMBOX_TAGS
decl_stmt|;
name|int
name|tags
init|=
name|howmany_tags
argument_list|(
name|av
operator|+
literal|5
argument_list|,
name|group
argument_list|)
decl_stmt|;
operator|*
name|offset_add
operator|=
literal|5
operator|+
name|tags
operator|*
name|group
expr_stmt|;
return|return
name|dialog_form
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|4
argument_list|)
argument_list|,
name|tags
argument_list|,
name|av
operator|+
literal|5
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_password_form
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
name|unsigned
name|save
init|=
name|dialog_vars
operator|.
name|formitem_type
decl_stmt|;
name|int
name|result
decl_stmt|;
name|dialog_vars
operator|.
name|formitem_type
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|call_form
argument_list|(
name|PASSARGS
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|formitem_type
operator|=
name|save
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_DLG_FORMBOX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DLG_MIXEDFORM
end_ifdef

begin_function
specifier|static
name|int
name|call_mixed_form
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
name|int
name|group
init|=
name|MIXEDFORM_TAGS
decl_stmt|;
name|int
name|tags
init|=
name|howmany_tags
argument_list|(
name|av
operator|+
literal|5
argument_list|,
name|group
argument_list|)
decl_stmt|;
operator|*
name|offset_add
operator|=
literal|5
operator|+
name|tags
operator|*
name|group
expr_stmt|;
return|return
name|dialog_mixedform
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|4
argument_list|)
argument_list|,
name|tags
argument_list|,
name|av
operator|+
literal|5
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_DLG_MIXEDFORM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DLG_GAUGE
end_ifdef

begin_function
specifier|static
name|int
name|call_gauge
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
operator|*
name|offset_add
operator|=
name|arg_rest
argument_list|(
name|av
argument_list|)
expr_stmt|;
return|return
name|dialog_gauge
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
name|optional_num
argument_list|(
name|av
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_pause
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
operator|*
name|offset_add
operator|=
name|arg_rest
argument_list|(
name|av
argument_list|)
expr_stmt|;
return|return
name|dialog_pause
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|4
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MIXEDGAUGE
end_ifdef

begin_function
specifier|static
name|int
name|call_mixed_gauge
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
define|#
directive|define
name|MIXEDGAUGE_BASE
value|5
name|int
name|tags
init|=
name|howmany_tags
argument_list|(
name|av
operator|+
name|MIXEDGAUGE_BASE
argument_list|,
name|MIXEDGAUGE_TAGS
argument_list|)
decl_stmt|;
operator|*
name|offset_add
operator|=
name|MIXEDGAUGE_BASE
operator|+
name|tags
operator|*
name|MIXEDGAUGE_TAGS
expr_stmt|;
return|return
name|dialog_mixedgauge
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|4
argument_list|)
argument_list|,
name|tags
argument_list|,
name|av
operator|+
name|MIXEDGAUGE_BASE
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DLG_GAUGE
end_ifdef

begin_function
specifier|static
name|int
name|call_prgbox
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
operator|*
name|offset_add
operator|=
name|arg_rest
argument_list|(
name|av
argument_list|)
expr_stmt|;
comment|/* the original version does not accept a prompt string, but for      * consistency we allow it.      */
return|return
operator|(
operator|(
operator|*
name|offset_add
operator|==
literal|5
operator|)
condition|?
name|dialog_prgbox
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|av
index|[
literal|2
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|4
argument_list|)
argument_list|,
name|TRUE
argument_list|)
else|:
name|dialog_prgbox
argument_list|(
name|t
argument_list|,
literal|""
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
name|TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DLG_GAUGE
end_ifdef

begin_function
specifier|static
name|int
name|call_programbox
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
operator|*
name|offset_add
operator|=
name|arg_rest
argument_list|(
name|av
argument_list|)
expr_stmt|;
comment|/* this function is a compromise between --prgbox and --progressbox.      */
name|result
operator|=
operator|(
operator|(
operator|*
name|offset_add
operator|==
literal|4
operator|)
condition|?
name|dlg_progressbox
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|dialog_state
operator|.
name|pipe_input
argument_list|)
else|:
name|dlg_progressbox
argument_list|(
name|t
argument_list|,
literal|""
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|1
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|dialog_state
operator|.
name|pipe_input
argument_list|)
operator|)
expr_stmt|;
name|dialog_state
operator|.
name|pipe_input
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DLG_GAUGE
end_ifdef

begin_function
specifier|static
name|int
name|call_progressbox
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
operator|*
name|offset_add
operator|=
name|arg_rest
argument_list|(
name|av
argument_list|)
expr_stmt|;
comment|/* the original version does not accept a prompt string, but for      * consistency we allow it.      */
return|return
operator|(
operator|(
operator|*
name|offset_add
operator|==
literal|4
operator|)
condition|?
name|dialog_progressbox
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|)
else|:
name|dialog_progressbox
argument_list|(
name|t
argument_list|,
literal|""
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|1
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DLG_TAILBOX
end_ifdef

begin_function
specifier|static
name|int
name|call_tailbox
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
operator|*
name|offset_add
operator|=
literal|4
expr_stmt|;
return|return
name|dialog_tailbox
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_tailboxbg
parameter_list|(
name|CALLARGS
parameter_list|)
block|{
operator|*
name|offset_add
operator|=
literal|4
expr_stmt|;
return|return
name|dialog_tailbox
argument_list|(
name|t
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|2
argument_list|)
argument_list|,
name|numeric_arg
argument_list|(
name|av
argument_list|,
literal|3
argument_list|)
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|Mode
name|modes
index|[]
init|=
block|{
block|{
name|o_yesno
block|,
literal|4
block|,
literal|4
block|,
name|call_yesno
block|}
block|,
block|{
name|o_msgbox
block|,
literal|4
block|,
literal|4
block|,
name|call_msgbox
block|}
block|,
block|{
name|o_infobox
block|,
literal|4
block|,
literal|4
block|,
name|call_infobox
block|}
block|,
block|{
name|o_textbox
block|,
literal|4
block|,
literal|4
block|,
name|call_textbox
block|}
block|,
block|{
name|o_menu
block|,
literal|7
block|,
literal|0
block|,
name|call_menu
block|}
block|,
block|{
name|o_inputmenu
block|,
literal|7
block|,
literal|0
block|,
name|call_inputmenu
block|}
block|,
block|{
name|o_checklist
block|,
literal|8
block|,
literal|0
block|,
name|call_checklist
block|}
block|,
block|{
name|o_radiolist
block|,
literal|8
block|,
literal|0
block|,
name|call_radiolist
block|}
block|,
block|{
name|o_inputbox
block|,
literal|4
block|,
literal|5
block|,
name|call_inputbox
block|}
block|,
block|{
name|o_passwordbox
block|,
literal|4
block|,
literal|5
block|,
name|call_passwordbox
block|}
block|,
ifdef|#
directive|ifdef
name|HAVE_DLG_GAUGE
block|{
name|o_gauge
block|,
literal|4
block|,
literal|5
block|,
name|call_gauge
block|}
block|,
block|{
name|o_pause
block|,
literal|5
block|,
literal|5
block|,
name|call_pause
block|}
block|,
block|{
name|o_prgbox
block|,
literal|4
block|,
literal|5
block|,
name|call_prgbox
block|}
block|,
block|{
name|o_programbox
block|,
literal|3
block|,
literal|4
block|,
name|call_programbox
block|}
block|,
block|{
name|o_progressbox
block|,
literal|3
block|,
literal|4
block|,
name|call_progressbox
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_DLG_FORMBOX
block|{
name|o_passwordform
block|,
literal|13
block|,
literal|0
block|,
name|call_password_form
block|}
block|,
block|{
name|o_form
block|,
literal|13
block|,
literal|0
block|,
name|call_form
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_MIXEDGAUGE
block|{
name|o_mixedgauge
block|,
name|MIXEDGAUGE_BASE
block|,
literal|0
block|,
name|call_mixed_gauge
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_DLG_MIXEDFORM
block|{
name|o_mixedform
block|,
literal|13
block|,
literal|0
block|,
name|call_mixed_form
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_DLG_TAILBOX
block|{
name|o_tailbox
block|,
literal|4
block|,
literal|4
block|,
name|call_tailbox
block|}
block|,
block|{
name|o_tailboxbg
block|,
literal|4
block|,
literal|4
block|,
name|call_tailboxbg
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_XDIALOG
block|{
name|o_calendar
block|,
literal|4
block|,
literal|7
block|,
name|call_calendar
block|}
block|,
block|{
name|o_dselect
block|,
literal|4
block|,
literal|5
block|,
name|call_dselect
block|}
block|,
block|{
name|o_editbox
block|,
literal|4
block|,
literal|4
block|,
name|call_editbox
block|}
block|,
block|{
name|o_fselect
block|,
literal|4
block|,
literal|5
block|,
name|call_fselect
block|}
block|,
block|{
name|o_timebox
block|,
literal|4
block|,
literal|7
block|,
name|call_timebox
block|}
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|optionString
parameter_list|(
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
modifier|*
name|num
parameter_list|)
block|{
name|int
name|next
init|=
operator|*
name|num
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|result
init|=
name|argv
index|[
name|next
index|]
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|char
name|temp
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Expected a string-parameter for %.20s"
argument_list|,
name|argv
index|[
operator|*
name|num
index|]
argument_list|)
expr_stmt|;
name|Usage
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
operator|*
name|num
operator|=
name|next
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|optionValue
parameter_list|(
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
modifier|*
name|num
parameter_list|)
block|{
name|int
name|next
init|=
operator|*
name|num
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|src
init|=
name|argv
index|[
name|next
index|]
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
literal|0
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|src
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|src
argument_list|,
operator|&
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
operator|||
operator|*
name|tmp
operator|!=
literal|0
condition|)
name|src
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|==
literal|0
condition|)
block|{
name|char
name|temp
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Expected a numeric-parameter for %.20s"
argument_list|,
name|argv
index|[
operator|*
name|num
index|]
argument_list|)
expr_stmt|;
name|Usage
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
operator|*
name|num
operator|=
name|next
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return exit-code for a named button */
end_comment

begin_function
specifier|static
name|int
name|button_code
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* *INDENT-OFF* */
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|code
decl_stmt|;
block|}
name|table
index|[]
init|=
block|{
block|{
literal|"ok"
block|,
name|DLG_EXIT_OK
block|}
block|,
block|{
literal|"yes"
block|,
name|DLG_EXIT_OK
block|}
block|,
block|{
literal|"cancel"
block|,
name|DLG_EXIT_CANCEL
block|}
block|,
block|{
literal|"no"
block|,
name|DLG_EXIT_CANCEL
block|}
block|,
block|{
literal|"help"
block|,
name|DLG_EXIT_HELP
block|}
block|,
block|{
literal|"extra"
block|,
name|DLG_EXIT_EXTRA
block|}
block|,     }
struct|;
comment|/* *INDENT-ON* */
name|int
name|code
init|=
name|DLG_EXIT_ERROR
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|table
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|dlg_strcmp
argument_list|(
name|name
argument_list|,
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|code
operator|=
name|table
index|[
name|i
index|]
operator|.
name|code
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|code
operator|==
name|DLG_EXIT_ERROR
condition|)
block|{
name|char
name|temp
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Button name \"%.20s\" unknown"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|Usage
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/*  * Print parts of a message  */
end_comment

begin_function
specifier|static
name|void
name|PrintList
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|list
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|leaf
init|=
name|strrchr
argument_list|(
name|program
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|unsigned
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|leaf
operator|!=
literal|0
condition|)
name|leaf
operator|++
expr_stmt|;
else|else
name|leaf
operator|=
name|program
expr_stmt|;
while|while
condition|(
operator|*
name|list
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|dialog_state
operator|.
name|output
argument_list|,
operator|*
name|list
argument_list|,
name|n
condition|?
name|leaf
else|:
name|dialog_version
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dialog_state
operator|.
name|output
argument_list|)
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
name|list
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|Mode
modifier|*
name|lookupMode
parameter_list|(
name|eOptions
name|code
parameter_list|)
block|{
specifier|const
name|Mode
modifier|*
name|modePtr
init|=
literal|0
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
sizeof|sizeof
argument_list|(
name|modes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|modes
index|[
literal|0
index|]
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|modes
index|[
name|n
index|]
operator|.
name|code
operator|==
name|code
condition|)
block|{
name|modePtr
operator|=
operator|&
name|modes
index|[
name|n
index|]
expr_stmt|;
break|break;
block|}
block|}
return|return
name|modePtr
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|compare_opts
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|Options
modifier|*
specifier|const
modifier|*
name|p
init|=
operator|(
name|Options
operator|*
specifier|const
operator|*
operator|)
name|a
decl_stmt|;
name|Options
modifier|*
specifier|const
modifier|*
name|q
init|=
operator|(
name|Options
operator|*
specifier|const
operator|*
operator|)
name|b
decl_stmt|;
return|return
name|strcmp
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|->
name|name
argument_list|,
operator|(
operator|*
name|q
operator|)
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print program's version.  */
end_comment

begin_function
specifier|static
name|void
name|PrintVersion
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Version: %s\n"
argument_list|,
name|dialog_version
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print program help-message  */
end_comment

begin_function
specifier|static
name|void
name|Help
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tbl_1
index|[]
init|=
block|{
literal|"cdialog (ComeOn Dialog!) version %s"
block|,
literal|"Copyright 2000-2011,2012 Thomas E. Dickey"
block|,
literal|"This is free software; see the source for copying conditions.  There is NO"
block|,
literal|"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
block|,
literal|""
block|,
literal|"* Display dialog boxes from shell scripts *"
block|,
literal|""
block|,
literal|"Usage: %s<options> { --and-widget<options> }"
block|,
literal|"where options are \"common\" options, followed by \"box\" options"
block|,
literal|""
block|,
ifdef|#
directive|ifdef
name|HAVE_RC_FILE
literal|"Special options:"
block|,
literal|"  [--create-rc \"file\"]"
block|,
endif|#
directive|endif
literal|0
block|}
decl_stmt|,
modifier|*
decl_stmt|const
name|tbl_3
index|[]
init|=
block|{
literal|""
block|,
literal|"Auto-size with height and width = 0. Maximize with height and width = -1."
block|,
literal|"Global-auto-size if also menu_height/list_height = 0."
block|,
literal|0
block|}
decl_stmt|;
name|size_t
name|limit
init|=
sizeof|sizeof
argument_list|(
name|options
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|options
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|size_t
name|j
decl_stmt|,
name|k
decl_stmt|;
specifier|const
name|Options
modifier|*
modifier|*
name|opts
decl_stmt|;
name|end_dialog
argument_list|()
expr_stmt|;
name|dialog_state
operator|.
name|output
operator|=
name|stdout
expr_stmt|;
name|opts
operator|=
name|dlg_calloc
argument_list|(
specifier|const
name|Options
operator|*
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|assert_ptr
argument_list|(
name|opts
argument_list|,
literal|"Help"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|limit
condition|;
operator|++
name|j
control|)
block|{
name|opts
index|[
name|j
index|]
operator|=
operator|&
operator|(
name|options
index|[
name|j
index|]
operator|)
expr_stmt|;
block|}
name|qsort
argument_list|(
name|opts
argument_list|,
name|limit
argument_list|,
sizeof|sizeof
argument_list|(
name|Options
operator|*
argument_list|)
argument_list|,
name|compare_opts
argument_list|)
expr_stmt|;
name|PrintList
argument_list|(
name|tbl_1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dialog_state
operator|.
name|output
argument_list|,
literal|"Common options:\n "
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|k
operator|=
literal|0
init|;
name|j
operator|<
name|limit
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|opts
index|[
name|j
index|]
operator|->
name|pass
operator|&
literal|1
operator|)
operator|&&
name|opts
index|[
name|j
index|]
operator|->
name|help
operator|!=
literal|0
condition|)
block|{
name|size_t
name|len
init|=
literal|6
operator|+
name|strlen
argument_list|(
name|opts
index|[
name|j
index|]
operator|->
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|opts
index|[
name|j
index|]
operator|->
name|help
argument_list|)
decl_stmt|;
name|k
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|75
condition|)
block|{
name|fprintf
argument_list|(
name|dialog_state
operator|.
name|output
argument_list|,
literal|"\n "
argument_list|)
expr_stmt|;
name|k
operator|=
name|len
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dialog_state
operator|.
name|output
argument_list|,
literal|" [--%s%s%s]"
argument_list|,
name|opts
index|[
name|j
index|]
operator|->
name|name
argument_list|,
operator|*
operator|(
name|opts
index|[
name|j
index|]
operator|->
name|help
operator|)
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|opts
index|[
name|j
index|]
operator|->
name|help
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|dialog_state
operator|.
name|output
argument_list|,
literal|"\nBox options:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|limit
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|opts
index|[
name|j
index|]
operator|->
name|pass
operator|&
literal|2
operator|)
operator|!=
literal|0
operator|&&
name|opts
index|[
name|j
index|]
operator|->
name|help
operator|!=
literal|0
operator|&&
name|lookupMode
argument_list|(
name|opts
index|[
name|j
index|]
operator|->
name|code
argument_list|)
condition|)
name|fprintf
argument_list|(
name|dialog_state
operator|.
name|output
argument_list|,
literal|"  --%-12s %s\n"
argument_list|,
name|opts
index|[
name|j
index|]
operator|->
name|name
argument_list|,
name|opts
index|[
name|j
index|]
operator|->
name|help
argument_list|)
expr_stmt|;
block|}
name|PrintList
argument_list|(
name|tbl_3
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|dlg_exit
argument_list|(
name|DLG_EXIT_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DLG_TRACE
end_ifdef

begin_comment
comment|/*  * Only the first call to dlg_trace will open a trace file.  But each time  * --trace is parsed, we show the whole parameter list as it is at that moment,  * counting discarded parameters.  The only way to capture the whole parameter  * list is if --trace is the first option.  */
end_comment

begin_function
specifier|static
name|void
name|process_trace_option
parameter_list|(
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|dialog_state
operator|.
name|trace_output
operator|==
literal|0
condition|)
name|dlg_trace
argument_list|(
name|optionString
argument_list|(
name|argv
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|dlg_trace_msg
argument_list|(
literal|"# Parameters:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|argv
index|[
name|j
index|]
operator|!=
literal|0
condition|;
operator|++
name|j
control|)
block|{
name|dlg_trace_msg
argument_list|(
literal|"# argv[%d] = %s\n"
argument_list|,
name|j
argument_list|,
name|argv
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
operator|*
name|offset
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * "Common" options apply to all widgets more/less.  Most of the common options  * set values in dialog_vars, a few set dialog_state and a couple write to the  * output stream.  */
end_comment

begin_function
specifier|static
name|int
name|process_common_options
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|offset
parameter_list|,
name|bool
name|output
parameter_list|)
block|{
name|bool
name|done
init|=
name|FALSE
decl_stmt|;
name|dlg_trace_msg
argument_list|(
literal|"# process_common_options, offset %d\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
while|while
condition|(
name|offset
operator|<
name|argc
operator|&&
operator|!
name|done
condition|)
block|{
comment|/* Common options */
name|dlg_trace_msg
argument_list|(
literal|"#\targv[%d] = %s\n"
argument_list|,
name|offset
argument_list|,
name|argv
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lookupOption
argument_list|(
name|argv
index|[
name|offset
index|]
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|o_title
case|:
name|dialog_vars
operator|.
name|title
operator|=
name|optionString
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_backtitle
case|:
name|dialog_vars
operator|.
name|backtitle
operator|=
name|optionString
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_separate_widget
case|:
name|dialog_state
operator|.
name|separate_str
operator|=
name|optionString
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_separate_output
case|:
name|dialog_vars
operator|.
name|separate_output
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_colors
case|:
name|dialog_vars
operator|.
name|colors
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_cr_wrap
case|:
name|dialog_vars
operator|.
name|cr_wrap
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_no_nl_expand
case|:
name|dialog_vars
operator|.
name|no_nl_expand
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_no_collapse
case|:
name|dialog_vars
operator|.
name|nocollapse
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_no_kill
case|:
name|dialog_vars
operator|.
name|cant_kill
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_nocancel
case|:
name|dialog_vars
operator|.
name|nocancel
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_nook
case|:
name|dialog_vars
operator|.
name|nook
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_quoted
case|:
name|dialog_vars
operator|.
name|quoted
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_single_quoted
case|:
name|dialog_vars
operator|.
name|single_quoted
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_size_err
case|:
name|dialog_vars
operator|.
name|size_err
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_beep
case|:
name|dialog_vars
operator|.
name|beep_signal
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_beep_after
case|:
name|dialog_vars
operator|.
name|beep_after_signal
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_scrollbar
case|:
name|dialog_state
operator|.
name|use_scrollbar
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_shadow
case|:
name|dialog_state
operator|.
name|use_shadow
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_defaultno
case|:
name|dialog_vars
operator|.
name|defaultno
operator|=
name|TRUE
expr_stmt|;
name|dialog_vars
operator|.
name|default_button
operator|=
name|DLG_EXIT_CANCEL
expr_stmt|;
break|break;
case|case
name|o_default_button
case|:
name|dialog_vars
operator|.
name|default_button
operator|=
name|button_code
argument_list|(
name|optionString
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|defaultno
operator|=
name|dialog_vars
operator|.
name|default_button
operator|==
name|DLG_EXIT_CANCEL
expr_stmt|;
break|break;
case|case
name|o_default_item
case|:
name|dialog_vars
operator|.
name|default_item
operator|=
name|optionString
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_insecure
case|:
name|dialog_vars
operator|.
name|insecure
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_item_help
case|:
name|dialog_vars
operator|.
name|item_help
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_help_line
case|:
name|dialog_vars
operator|.
name|help_line
operator|=
name|optionString
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_help_file
case|:
name|dialog_vars
operator|.
name|help_file
operator|=
name|optionString
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_help_button
case|:
name|dialog_vars
operator|.
name|help_button
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_help_status
case|:
name|dialog_vars
operator|.
name|help_status
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_extra_button
case|:
name|dialog_vars
operator|.
name|extra_button
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_ignore
case|:
name|ignore_unknown
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_keep_window
case|:
name|dialog_vars
operator|.
name|keep_window
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_no_shadow
case|:
name|dialog_state
operator|.
name|use_shadow
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|o_print_size
case|:
name|dialog_vars
operator|.
name|print_siz
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_print_maxsize
case|:
if|if
condition|(
name|output
condition|)
block|{
comment|/* 		 * If this is the last option, we do not want any error 		 * messages - just our output.  Calling end_dialog() cancels 		 * the refresh() at the end of the program as well. 		 */
if|if
condition|(
name|argv
index|[
name|offset
operator|+
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|ignore_unknown
operator|=
name|TRUE
expr_stmt|;
name|end_dialog
argument_list|()
expr_stmt|;
block|}
name|fflush
argument_list|(
name|dialog_state
operator|.
name|output
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dialog_state
operator|.
name|output
argument_list|,
literal|"MaxSize: %d, %d\n"
argument_list|,
name|SLINES
argument_list|,
name|SCOLS
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|o_print_version
case|:
if|if
condition|(
name|output
condition|)
block|{
name|PrintVersion
argument_list|(
name|dialog_state
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|o_separator
case|:
case|case
name|o_output_separator
case|:
name|dialog_vars
operator|.
name|output_separator
operator|=
name|optionString
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_column_separator
case|:
name|dialog_vars
operator|.
name|column_separator
operator|=
name|optionString
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_tab_correct
case|:
name|dialog_vars
operator|.
name|tab_correct
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_sleep
case|:
name|dialog_vars
operator|.
name|sleep_secs
operator|=
name|optionValue
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_timeout
case|:
name|dialog_vars
operator|.
name|timeout_secs
operator|=
name|optionValue
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_max_input
case|:
name|dialog_vars
operator|.
name|max_input
operator|=
name|optionValue
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_tab_len
case|:
name|dialog_state
operator|.
name|tab_len
operator|=
name|optionValue
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_trim
case|:
name|dialog_vars
operator|.
name|trim_whitespace
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_visit_items
case|:
name|dialog_state
operator|.
name|visit_items
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_aspect
case|:
name|dialog_state
operator|.
name|aspect_ratio
operator|=
name|optionValue
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_begin
case|:
name|dialog_vars
operator|.
name|begin_set
operator|=
name|TRUE
expr_stmt|;
name|dialog_vars
operator|.
name|begin_y
operator|=
name|optionValue
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|begin_x
operator|=
name|optionValue
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_clear
case|:
name|dialog_vars
operator|.
name|dlg_clear_screen
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_yes_label
case|:
name|dialog_vars
operator|.
name|yes_label
operator|=
name|optionString
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_no_label
case|:
name|dialog_vars
operator|.
name|no_label
operator|=
name|optionString
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_ok_label
case|:
name|dialog_vars
operator|.
name|ok_label
operator|=
name|optionString
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_cancel_label
case|:
name|dialog_vars
operator|.
name|cancel_label
operator|=
name|optionString
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_extra_label
case|:
name|dialog_vars
operator|.
name|extra_label
operator|=
name|optionString
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_exit_label
case|:
name|dialog_vars
operator|.
name|exit_label
operator|=
name|optionString
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_help_label
case|:
name|dialog_vars
operator|.
name|help_label
operator|=
name|optionString
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_date_format
case|:
name|dialog_vars
operator|.
name|date_format
operator|=
name|optionString
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_time_format
case|:
name|dialog_vars
operator|.
name|time_format
operator|=
name|optionString
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_keep_tite
case|:
name|dialog_vars
operator|.
name|keep_tite
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_ascii_lines
case|:
name|dialog_vars
operator|.
name|ascii_lines
operator|=
name|TRUE
expr_stmt|;
name|dialog_vars
operator|.
name|no_lines
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|o_no_lines
case|:
name|dialog_vars
operator|.
name|no_lines
operator|=
name|TRUE
expr_stmt|;
name|dialog_vars
operator|.
name|ascii_lines
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|o_no_mouse
case|:
name|dialog_state
operator|.
name|no_mouse
operator|=
name|TRUE
expr_stmt|;
name|mouse_close
argument_list|()
expr_stmt|;
break|break;
case|case
name|o_noitem
case|:
case|case
name|o_fullbutton
case|:
comment|/* ignore */
break|break;
comment|/* options of Xdialog which we ignore */
case|case
name|o_icon
case|:
case|case
name|o_wmclass
case|:
operator|(
name|void
operator|)
name|optionString
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|o_allow_close
case|:
case|case
name|o_auto_placement
case|:
case|case
name|o_fixed_font
case|:
case|case
name|o_keep_colors
case|:
case|case
name|o_no_close
case|:
case|case
name|o_no_cr_wrap
case|:
case|case
name|o_screen_center
case|:
case|case
name|o_smooth
case|:
case|case
name|o_under_mouse
case|:
break|break;
case|case
name|o_unknown
case|:
if|if
condition|(
name|ignore_unknown
condition|)
break|break;
comment|/* FALLTHRU */
default|default:
comment|/* no more common options */
name|done
operator|=
name|TRUE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_DLG_TRACE
case|case
name|o_trace
case|:
name|process_trace_option
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|done
condition|)
name|offset
operator|++
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize options at the start of a series of common options culminating  * in a widget.  */
end_comment

begin_function
specifier|static
name|void
name|init_result
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|)
block|{
specifier|static
name|bool
name|first
init|=
name|TRUE
decl_stmt|;
specifier|static
name|char
modifier|*
modifier|*
name|special_argv
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|special_argc
init|=
literal|0
decl_stmt|;
name|dlg_trace_msg
argument_list|(
literal|"# init_result\n"
argument_list|)
expr_stmt|;
comment|/* clear everything we do not save for the next widget */
name|memset
argument_list|(
operator|&
name|dialog_vars
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dialog_vars
argument_list|)
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|input_result
operator|=
name|buffer
expr_stmt|;
name|dialog_vars
operator|.
name|input_result
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dialog_vars
operator|.
name|default_button
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*      * The first time this is called, check for common options given by an      * environment variable.      */
if|if
condition|(
name|first
condition|)
block|{
name|char
modifier|*
name|env
init|=
name|getenv
argument_list|(
literal|"DIALOGOPTS"
argument_list|)
decl_stmt|;
if|if
condition|(
name|env
operator|!=
literal|0
condition|)
name|env
operator|=
name|dlg_strclone
argument_list|(
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|!=
literal|0
condition|)
block|{
name|special_argv
operator|=
name|dlg_string_to_argv
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|special_argc
operator|=
name|dlg_count_argv
argument_list|(
name|special_argv
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*      * If we are not checking memory leaks, just do the parse of the      * environment once.      */
if|if
condition|(
name|special_argv
operator|!=
literal|0
condition|)
block|{
name|process_common_options
argument_list|(
name|special_argc
argument_list|,
name|special_argv
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_LEAKS
name|free
argument_list|(
name|special_argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|special_argv
argument_list|)
expr_stmt|;
name|special_argv
operator|=
literal|0
expr_stmt|;
name|special_argc
operator|=
literal|0
expr_stmt|;
name|first
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
name|temp
index|[
literal|256
index|]
decl_stmt|;
name|bool
name|esc_pressed
init|=
name|FALSE
decl_stmt|;
name|bool
name|keep_tite
init|=
name|FALSE
decl_stmt|;
name|int
name|offset
init|=
literal|1
decl_stmt|;
name|int
name|offset_add
decl_stmt|;
name|int
name|retval
init|=
name|DLG_EXIT_OK
decl_stmt|;
name|int
name|j
decl_stmt|,
name|have
decl_stmt|;
name|eOptions
name|code
decl_stmt|;
specifier|const
name|Mode
modifier|*
name|modePtr
decl_stmt|;
name|char
name|my_buffer
index|[
name|MAX_LEN
operator|+
literal|1
index|]
decl_stmt|;
name|memset
argument_list|(
operator|&
name|dialog_state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dialog_state
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|dialog_vars
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dialog_vars
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ENABLE_NLS
argument_list|)
comment|/* initialize locale support */
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|bindtextdomain
argument_list|(
name|NLS_TEXTDOMAIN
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|NLS_TEXTDOMAIN
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|unescape_argv
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|program
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|dialog_state
operator|.
name|output
operator|=
name|stderr
expr_stmt|;
name|dialog_state
operator|.
name|input
operator|=
name|stdin
expr_stmt|;
comment|/*      * Look for the last --stdout, --stderr or --output-fd option, and use      * that.  We can only write to one of them.  If --stdout is used, that      * can interfere with initializing the curses library, so we want to      * know explicitly if it is used.      *      * Also, look for any --version or --help message, processing those      * immediately.      */
while|while
condition|(
name|offset
operator|<
name|argc
condition|)
block|{
name|int
name|base
init|=
name|offset
decl_stmt|;
switch|switch
condition|(
name|lookupOption
argument_list|(
name|argv
index|[
name|offset
index|]
argument_list|,
literal|7
argument_list|)
condition|)
block|{
case|case
name|o_stdout
case|:
name|dialog_state
operator|.
name|output
operator|=
name|stdout
expr_stmt|;
break|break;
case|case
name|o_stderr
case|:
name|dialog_state
operator|.
name|output
operator|=
name|stderr
expr_stmt|;
break|break;
case|case
name|o_input_fd
case|:
if|if
condition|(
operator|(
name|j
operator|=
name|optionValue
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|dialog_state
operator|.
name|input
operator|=
name|fdopen
argument_list|(
name|j
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|dlg_exiterr
argument_list|(
literal|"Cannot open input-fd\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_output_fd
case|:
if|if
condition|(
operator|(
name|j
operator|=
name|optionValue
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|dialog_state
operator|.
name|output
operator|=
name|fdopen
argument_list|(
name|j
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|dlg_exiterr
argument_list|(
literal|"Cannot open output-fd\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_keep_tite
case|:
name|keep_tite
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|o_version
case|:
name|dialog_state
operator|.
name|output
operator|=
name|stdout
expr_stmt|;
name|PrintVersion
argument_list|(
name|dialog_state
operator|.
name|output
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|DLG_EXIT_OK
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_help
case|:
name|Help
argument_list|()
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_DLG_TRACE
case|case
name|o_trace
case|:
comment|/* 	     * Process/remove the --trace option if it is the first option. 	     * Otherwise, process it in more/less expected order as a 	     * "common" option. 	     */
if|if
condition|(
name|base
operator|==
literal|1
condition|)
block|{
name|process_trace_option
argument_list|(
name|argv
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|++
name|offset
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
default|default:
operator|++
name|offset
expr_stmt|;
continue|continue;
block|}
name|dlg_trace_msg
argument_list|(
literal|"# discarding %d parameters starting with argv[%d] (%s)\n"
argument_list|,
literal|1
operator|+
name|offset
operator|-
name|base
argument_list|,
name|base
argument_list|,
name|argv
index|[
name|base
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|base
init|;
name|j
operator|<
name|argc
condition|;
operator|++
name|j
control|)
block|{
name|dialog_argv
index|[
name|j
index|]
operator|=
name|dialog_argv
index|[
name|j
operator|+
literal|1
operator|+
operator|(
name|offset
operator|-
name|base
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|dialog_opts
operator|!=
literal|0
condition|)
name|dialog_opts
index|[
name|j
index|]
operator|=
name|dialog_opts
index|[
name|j
operator|+
literal|1
operator|+
operator|(
name|offset
operator|-
name|base
operator|)
index|]
expr_stmt|;
block|}
name|argc
operator|-=
operator|(
literal|1
operator|+
name|offset
operator|-
name|base
operator|)
expr_stmt|;
name|offset
operator|=
name|base
expr_stmt|;
block|}
name|offset
operator|=
literal|1
expr_stmt|;
name|init_result
argument_list|(
name|my_buffer
argument_list|)
expr_stmt|;
comment|/*      * Dialog's output may be redirected (see above).  Handle the special      * case of options that only report information without interaction.      */
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
switch|switch
condition|(
name|lookupOption
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|7
argument_list|)
condition|)
block|{
case|case
name|o_print_maxsize
case|:
operator|(
name|void
operator|)
name|initscr
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|dialog_state
operator|.
name|output
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dialog_state
operator|.
name|output
argument_list|,
literal|"MaxSize: %d, %d\n"
argument_list|,
name|SLINES
argument_list|,
name|SCOLS
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_print_version
case|:
name|PrintVersion
argument_list|(
name|dialog_state
operator|.
name|output
argument_list|)
expr_stmt|;
break|break;
case|case
name|o_clear
case|:
name|initscr
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
break|break;
case|case
name|o_ignore
case|:
break|break;
default|default:
name|Help
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|DLG_EXIT_OK
return|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|Help
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_RC_FILE
if|if
condition|(
name|lookupOption
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|7
argument_list|)
operator|==
name|o_create_rc
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Expected a filename for %.50s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|Usage
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dlg_parse_rc
argument_list|()
operator|==
operator|-
literal|1
condition|)
comment|/* Read the configuration file */
name|dlg_exiterr
argument_list|(
literal|"dialog: dlg_parse_rc"
argument_list|)
expr_stmt|;
name|dlg_create_rc
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|DLG_EXIT_OK
return|;
block|}
endif|#
directive|endif
name|dialog_vars
operator|.
name|keep_tite
operator|=
name|keep_tite
expr_stmt|;
comment|/* init_result() cleared global */
name|init_dialog
argument_list|(
name|dialog_state
operator|.
name|input
argument_list|,
name|dialog_state
operator|.
name|output
argument_list|)
expr_stmt|;
while|while
condition|(
name|offset
operator|<
name|argc
operator|&&
operator|!
name|esc_pressed
condition|)
block|{
name|init_result
argument_list|(
name|my_buffer
argument_list|)
expr_stmt|;
name|offset
operator|=
name|process_common_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|offset
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|offset
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ignore_unknown
condition|)
break|break;
name|Usage
argument_list|(
literal|"Expected a box option"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lookupOption
argument_list|(
name|argv
index|[
name|offset
index|]
argument_list|,
literal|2
argument_list|)
operator|!=
name|o_checklist
operator|&&
name|dialog_vars
operator|.
name|separate_output
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Expected --checklist, not %.20s"
argument_list|,
name|argv
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
name|Usage
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dialog_state
operator|.
name|aspect_ratio
operator|==
literal|0
condition|)
name|dialog_state
operator|.
name|aspect_ratio
operator|=
name|DEFAULT_ASPECT_RATIO
expr_stmt|;
name|dlg_put_backtitle
argument_list|()
expr_stmt|;
comment|/* use a table to look for the requested mode, to avoid code duplication */
name|modePtr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|lookupOption
argument_list|(
name|argv
index|[
name|offset
index|]
argument_list|,
literal|2
argument_list|)
operator|)
operator|!=
name|o_unknown
condition|)
name|modePtr
operator|=
name|lookupMode
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|modePtr
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s option %.20s"
argument_list|,
name|lookupOption
argument_list|(
name|argv
index|[
name|offset
index|]
argument_list|,
literal|7
argument_list|)
operator|!=
name|o_unknown
condition|?
literal|"Unexpected"
else|:
literal|"Unknown"
argument_list|,
name|argv
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
name|Usage
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|have
operator|=
name|arg_rest
argument_list|(
operator|&
name|argv
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|have
operator|<
name|modePtr
operator|->
name|argmin
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Expected at least %d tokens for %.20s, have %d"
argument_list|,
name|modePtr
operator|->
name|argmin
operator|-
literal|1
argument_list|,
name|argv
index|[
name|offset
index|]
argument_list|,
name|have
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Usage
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|modePtr
operator|->
name|argmax
operator|&&
name|have
operator|>
name|modePtr
operator|->
name|argmax
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Expected no more than %d tokens for %.20s, have %d"
argument_list|,
name|modePtr
operator|->
name|argmax
operator|-
literal|1
argument_list|,
name|argv
index|[
name|offset
index|]
argument_list|,
name|have
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Usage
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Trim whitespace from non-title option values, e.g., the ones that 	 * will be used as captions or prompts.   Do that only for the widget 	 * we are about to process, since the "--trim" option is reset before 	 * accumulating options for each widget. 	 */
for|for
control|(
name|j
operator|=
name|offset
operator|+
literal|1
init|;
name|j
operator|<=
name|offset
operator|+
name|have
condition|;
name|j
operator|++
control|)
block|{
switch|switch
condition|(
name|lookupOption
argument_list|(
name|argv
index|[
name|j
operator|-
literal|1
index|]
argument_list|,
literal|7
argument_list|)
condition|)
block|{
case|case
name|o_unknown
case|:
case|case
name|o_title
case|:
case|case
name|o_backtitle
case|:
case|case
name|o_help_line
case|:
case|case
name|o_help_file
case|:
break|break;
default|default:
if|if
condition|(
name|argv
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
name|dlg_trim_string
argument_list|(
name|argv
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|retval
operator|=
name|show_result
argument_list|(
operator|(
operator|*
operator|(
name|modePtr
operator|->
name|jumper
operator|)
operator|)
operator|(
name|dialog_vars
operator|.
name|title
operator|,
name|argv
operator|+
name|offset
operator|,
operator|&
name|offset_add
operator|)
argument_list|)
expr_stmt|;
name|dlg_trace_msg
argument_list|(
literal|"# widget returns %d\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|offset_add
expr_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|input_result
operator|!=
name|my_buffer
condition|)
block|{
name|free
argument_list|(
name|dialog_vars
operator|.
name|input_result
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|input_result
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|==
name|DLG_EXIT_ESC
condition|)
block|{
name|esc_pressed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dialog_vars
operator|.
name|beep_after_signal
condition|)
operator|(
name|void
operator|)
name|beep
argument_list|()
expr_stmt|;
if|if
condition|(
name|dialog_vars
operator|.
name|sleep_secs
condition|)
operator|(
name|void
operator|)
name|napms
argument_list|(
name|dialog_vars
operator|.
name|sleep_secs
operator|*
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|argc
condition|)
block|{
switch|switch
condition|(
name|lookupOption
argument_list|(
name|argv
index|[
name|offset
index|]
argument_list|,
literal|7
argument_list|)
condition|)
block|{
case|case
name|o_and_widget
case|:
name|offset
operator|++
expr_stmt|;
break|break;
case|case
name|o_unknown
case|:
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Expected --and-widget, not %.20s"
argument_list|,
name|argv
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
name|Usage
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* if we got a cancel, etc., stop chaining */
if|if
condition|(
name|retval
operator|!=
name|DLG_EXIT_OK
condition|)
name|esc_pressed
operator|=
name|TRUE
expr_stmt|;
else|else
name|dialog_vars
operator|.
name|dlg_clear_screen
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|dialog_vars
operator|.
name|dlg_clear_screen
condition|)
name|dlg_clear
argument_list|()
expr_stmt|;
block|}
block|}
name|dlg_killall_bg
argument_list|(
operator|&
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|dialog_state
operator|.
name|screen_initialized
condition|)
block|{
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
name|end_dialog
argument_list|()
expr_stmt|;
block|}
name|dlg_exit
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

