begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  $Id: inputstr.c,v 1.83 2013/09/23 23:19:26 tom Exp $  *  *  inputstr.c -- functions for input/display of a string  *  *  Copyright 2000-2012,2013	Thomas E. Dickey  *  *  This program is free software; you can redistribute it and/or modify  *  it under the terms of the GNU Lesser General Public License, version 2.1  *  as published by the Free Software Foundation.  *  *  This program is distributed in the hope that it will be useful, but  *  WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *  Lesser General Public License for more details.  *  *  You should have received a copy of the GNU Lesser General Public  *  License along with this program; if not, write to  *	Free Software Foundation, Inc.  *	51 Franklin St., Fifth Floor  *	Boston, MA 02110, USA.  */
end_comment

begin_include
include|#
directive|include
file|<dialog.h>
end_include

begin_include
include|#
directive|include
file|<dlg_keys.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SETLOCALE
end_ifdef

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SEARCH_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_TSEARCH
argument_list|)
end_if

begin_include
include|#
directive|include
file|<search.h>
end_include

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|HAVE_TSEARCH
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_WCHAR_H
end_ifdef

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_WIDE_CURSES
argument_list|)
end_if

begin_define
define|#
directive|define
name|USE_CACHING
value|1
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_XDIALOG
argument_list|)
end_elif

begin_define
define|#
directive|define
name|USE_CACHING
value|1
end_define

begin_comment
comment|/* editbox really needs caching! */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USE_CACHING
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|_cache
block|{
name|struct
name|_cache
modifier|*
name|next
decl_stmt|;
if|#
directive|if
name|USE_CACHING
name|int
name|cache_num
decl_stmt|;
comment|/* tells what type of data is in list[] */
specifier|const
name|char
modifier|*
name|string_at
decl_stmt|;
comment|/* unique: associate caches by char* */
endif|#
directive|endif
name|size_t
name|s_len
decl_stmt|;
comment|/* strlen(string) - we add 1 for EOS */
name|size_t
name|i_len
decl_stmt|;
comment|/* length(list) - we add 1 for EOS */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* a copy of the last-processed string */
name|int
modifier|*
name|list
decl_stmt|;
comment|/* indices into the string */
block|}
name|CACHE
typedef|;
end_typedef

begin_if
if|#
directive|if
name|USE_CACHING
end_if

begin_define
define|#
directive|define
name|SAME_CACHE
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|,
name|l
parameter_list|)
value|(c->string != 0&& memcmp(c->string,s,l) == 0)
end_define

begin_decl_stmt
specifier|static
name|CACHE
modifier|*
name|cache_list
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|cInxCols
block|,
name|cCntWideBytes
block|,
name|cCntWideChars
block|,
name|cInxWideChars
block|,
name|cMAX
block|}
name|CACHE_USED
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TSEARCH
end_ifdef

begin_decl_stmt
specifier|static
name|void
modifier|*
name|sorted_cache
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WIDE_CURSES
end_ifdef

begin_function
specifier|static
name|int
name|have_locale
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|test
init|=
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|test
operator|==
literal|0
operator|||
operator|*
name|test
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|test
argument_list|,
literal|"C"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|test
argument_list|,
literal|"POSIX"
argument_list|)
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TSEARCH
end_ifdef

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|static void show_tsearch(const void *nodep, const VISIT which, const int depth) {     const CACHE *p = *(CACHE * const *) nodep;     (void) depth;     if (which == postorder || which == leaf) { 	dlg_trace_msg("\tcache %p %p:%s\n", p, p->string, p->string);     } }  static void trace_cache(const char *fn, int ln) {     dlg_trace_msg("trace_cache %s@%d\n", fn, ln);     twalk(sorted_cache, show_tsearch); }
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|trace_cache
parameter_list|(
name|fn
parameter_list|,
name|ln
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|compare_cache
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|CACHE
modifier|*
name|p
init|=
operator|(
specifier|const
name|CACHE
operator|*
operator|)
name|a
decl_stmt|;
specifier|const
name|CACHE
modifier|*
name|q
init|=
operator|(
specifier|const
name|CACHE
operator|*
operator|)
name|b
decl_stmt|;
name|int
name|result
init|=
operator|(
name|p
operator|->
name|cache_num
operator|-
name|q
operator|->
name|cache_num
operator|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|result
operator|=
call|(
name|int
call|)
argument_list|(
name|p
operator|->
name|string_at
operator|-
name|q
operator|->
name|string_at
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|CACHE
modifier|*
name|find_cache
parameter_list|(
name|int
name|cache_num
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|CACHE
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TSEARCH
name|void
modifier|*
name|pp
decl_stmt|;
name|CACHE
name|find
decl_stmt|;
name|memset
argument_list|(
operator|&
name|find
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|find
argument_list|)
argument_list|)
expr_stmt|;
name|find
operator|.
name|cache_num
operator|=
name|cache_num
expr_stmt|;
name|find
operator|.
name|string_at
operator|=
name|string
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|tfind
argument_list|(
operator|&
name|find
argument_list|,
operator|&
name|sorted_cache
argument_list|,
name|compare_cache
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
operator|*
operator|(
name|CACHE
operator|*
operator|*
operator|)
name|pp
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
for|for
control|(
name|p
operator|=
name|cache_list
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|string_at
operator|==
name|string
condition|)
block|{
break|break;
block|}
block|}
endif|#
directive|endif
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|CACHE
modifier|*
name|make_cache
parameter_list|(
name|int
name|cache_num
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|CACHE
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|dlg_calloc
argument_list|(
name|CACHE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assert_ptr
argument_list|(
name|p
argument_list|,
literal|"load_cache"
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|cache_list
expr_stmt|;
name|cache_list
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|cache_num
operator|=
name|cache_num
expr_stmt|;
name|p
operator|->
name|string_at
operator|=
name|string
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TSEARCH
operator|(
name|void
operator|)
name|tsearch
argument_list|(
name|p
argument_list|,
operator|&
name|sorted_cache
argument_list|,
name|compare_cache
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|CACHE
modifier|*
name|load_cache
parameter_list|(
name|int
name|cache_num
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|CACHE
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|find_cache
argument_list|(
name|cache_num
argument_list|,
name|string
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|make_cache
argument_list|(
name|cache_num
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|CACHE
name|my_cache
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SAME_CACHE
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|,
name|l
parameter_list|)
value|(c->string != 0)
end_define

begin_define
define|#
directive|define
name|load_cache
parameter_list|(
name|cache
parameter_list|,
name|string
parameter_list|)
value|&my_cache
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_CACHING */
end_comment

begin_comment
comment|/*  * If the given string has not changed, we do not need to update the index.  * If we need to update the index, allocate enough memory for it.  */
end_comment

begin_function
specifier|static
name|bool
name|same_cache2
parameter_list|(
name|CACHE
modifier|*
name|cache
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|unsigned
name|i_len
parameter_list|)
block|{
name|unsigned
name|need
decl_stmt|;
name|size_t
name|s_len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|bool
name|result
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|cache
operator|->
name|s_len
operator|==
literal|0
operator|||
name|cache
operator|->
name|s_len
operator|<
name|s_len
operator|||
name|cache
operator|->
name|list
operator|==
literal|0
operator|||
operator|!
name|SAME_CACHE
argument_list|(
name|cache
argument_list|,
name|string
argument_list|,
operator|(
name|size_t
operator|)
name|s_len
argument_list|)
condition|)
block|{
name|need
operator|=
operator|(
name|i_len
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|list
operator|==
literal|0
condition|)
block|{
name|cache
operator|->
name|list
operator|=
name|dlg_malloc
argument_list|(
name|int
argument_list|,
name|need
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cache
operator|->
name|i_len
operator|<
name|i_len
condition|)
block|{
name|cache
operator|->
name|list
operator|=
name|dlg_realloc
argument_list|(
name|int
argument_list|,
name|need
argument_list|,
name|cache
operator|->
name|list
argument_list|)
expr_stmt|;
block|}
name|assert_ptr
argument_list|(
name|cache
operator|->
name|list
argument_list|,
literal|"load_cache"
argument_list|)
expr_stmt|;
name|cache
operator|->
name|i_len
operator|=
name|i_len
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|s_len
operator|>=
name|s_len
operator|&&
name|cache
operator|->
name|string
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|cache
operator|->
name|string
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cache
operator|->
name|string
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|cache
operator|->
name|string
argument_list|)
expr_stmt|;
name|cache
operator|->
name|string
operator|=
name|dlg_strclone
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
name|cache
operator|->
name|s_len
operator|=
name|s_len
expr_stmt|;
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WIDE_CURSES
end_ifdef

begin_comment
comment|/*  * Like same_cache2(), but we are only concerned about caching a copy of the  * string and its associated length.  */
end_comment

begin_function
specifier|static
name|bool
name|same_cache1
parameter_list|(
name|CACHE
modifier|*
name|cache
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|size_t
name|i_len
parameter_list|)
block|{
name|size_t
name|s_len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|bool
name|result
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|cache
operator|->
name|s_len
operator|!=
name|s_len
operator|||
operator|!
name|SAME_CACHE
argument_list|(
name|cache
argument_list|,
name|string
argument_list|,
operator|(
name|size_t
operator|)
name|s_len
argument_list|)
condition|)
block|{
if|if
condition|(
name|cache
operator|->
name|s_len
operator|>=
name|s_len
operator|&&
name|cache
operator|->
name|string
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|cache
operator|->
name|string
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cache
operator|->
name|string
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|cache
operator|->
name|string
argument_list|)
expr_stmt|;
name|cache
operator|->
name|string
operator|=
name|dlg_strclone
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
name|cache
operator|->
name|s_len
operator|=
name|s_len
expr_stmt|;
name|cache
operator|->
name|i_len
operator|=
name|i_len
expr_stmt|;
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_CACHING */
end_comment

begin_comment
comment|/*  * Counts the number of bytes that make up complete wide-characters, up to byte  * 'len'.  If there is no locale set, simply return the original length.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WIDE_CURSES
end_ifdef

begin_function
specifier|static
name|int
name|dlg_count_wcbytes
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|have_locale
argument_list|()
condition|)
block|{
name|CACHE
modifier|*
name|cache
init|=
name|load_cache
argument_list|(
name|cCntWideBytes
argument_list|,
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|same_cache1
argument_list|(
name|cache
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
condition|)
block|{
while|while
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|size_t
name|code
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
init|=
name|cache
operator|->
name|string
decl_stmt|;
name|mbstate_t
name|state
decl_stmt|;
name|char
name|save
init|=
name|cache
operator|->
name|string
index|[
name|len
index|]
decl_stmt|;
name|cache
operator|->
name|string
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|mbsrtowcs
argument_list|(
operator|(
name|wchar_t
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|src
argument_list|,
name|len
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|cache
operator|->
name|string
index|[
name|len
index|]
operator|=
name|save
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|code
operator|>=
literal|0
condition|)
block|{
break|break;
block|}
operator|--
name|len
expr_stmt|;
block|}
name|cache
operator|->
name|i_len
operator|=
name|len
expr_stmt|;
block|}
name|result
operator|=
operator|(
name|int
operator|)
name|cache
operator|->
name|i_len
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
operator|(
name|int
operator|)
name|len
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_WIDE_CURSES */
end_comment

begin_comment
comment|/*  * Counts the number of wide-characters in the string.  */
end_comment

begin_function
name|int
name|dlg_count_wchars
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_WIDE_CURSES
if|if
condition|(
name|have_locale
argument_list|()
condition|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|CACHE
modifier|*
name|cache
init|=
name|load_cache
argument_list|(
name|cCntWideChars
argument_list|,
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|same_cache1
argument_list|(
name|cache
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|src
init|=
name|cache
operator|->
name|string
decl_stmt|;
name|mbstate_t
name|state
decl_stmt|;
name|int
name|part
init|=
name|dlg_count_wcbytes
argument_list|(
name|cache
operator|->
name|string
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|char
name|save
init|=
name|cache
operator|->
name|string
index|[
name|part
index|]
decl_stmt|;
name|size_t
name|code
decl_stmt|;
name|wchar_t
modifier|*
name|temp
init|=
name|dlg_calloc
argument_list|(
name|wchar_t
argument_list|,
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
name|cache
operator|->
name|string
index|[
name|part
index|]
operator|=
literal|'\0'
expr_stmt|;
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|mbsrtowcs
argument_list|(
name|temp
argument_list|,
operator|&
name|src
argument_list|,
operator|(
name|size_t
operator|)
name|part
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|cache
operator|->
name|i_len
operator|=
operator|(
operator|(
name|int
operator|)
name|code
operator|>=
literal|0
operator|)
condition|?
name|wcslen
argument_list|(
name|temp
argument_list|)
else|:
literal|0
expr_stmt|;
name|cache
operator|->
name|string
index|[
name|part
index|]
operator|=
name|save
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cache
operator|->
name|i_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|result
operator|=
operator|(
name|int
operator|)
name|cache
operator|->
name|i_len
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* USE_WIDE_CURSES */
block|{
name|result
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Build an index of the wide-characters in the string, so we can easily tell  * which byte-offset begins a given wide-character.  */
end_comment

begin_function
specifier|const
name|int
modifier|*
name|dlg_index_wchars
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|unsigned
name|len
init|=
operator|(
name|unsigned
operator|)
name|dlg_count_wchars
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|unsigned
name|inx
decl_stmt|;
name|CACHE
modifier|*
name|cache
init|=
name|load_cache
argument_list|(
name|cInxWideChars
argument_list|,
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|same_cache2
argument_list|(
name|cache
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|current
init|=
name|string
decl_stmt|;
name|cache
operator|->
name|list
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|inx
operator|=
literal|1
init|;
name|inx
operator|<=
name|len
condition|;
operator|++
name|inx
control|)
block|{
ifdef|#
directive|ifdef
name|USE_WIDE_CURSES
if|if
condition|(
name|have_locale
argument_list|()
condition|)
block|{
name|mbstate_t
name|state
decl_stmt|;
name|int
name|width
decl_stmt|;
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|width
operator|=
operator|(
name|int
operator|)
name|mbrlen
argument_list|(
name|current
argument_list|,
name|strlen
argument_list|(
name|current
argument_list|)
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
condition|)
name|width
operator|=
literal|1
expr_stmt|;
comment|/* FIXME: what if we have a control-char? */
name|current
operator|+=
name|width
expr_stmt|;
name|cache
operator|->
name|list
index|[
name|inx
index|]
operator|=
name|cache
operator|->
name|list
index|[
name|inx
operator|-
literal|1
index|]
operator|+
name|width
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* USE_WIDE_CURSES */
block|{
operator|(
name|void
operator|)
name|current
expr_stmt|;
name|cache
operator|->
name|list
index|[
name|inx
index|]
operator|=
operator|(
name|int
operator|)
name|inx
expr_stmt|;
block|}
block|}
block|}
return|return
name|cache
operator|->
name|list
return|;
block|}
end_function

begin_comment
comment|/*  * Given the character-offset to find in the list, return the corresponding  * array index.  */
end_comment

begin_function
name|int
name|dlg_find_index
parameter_list|(
specifier|const
name|int
modifier|*
name|list
parameter_list|,
name|int
name|limit
parameter_list|,
name|int
name|to_find
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
for|for
control|(
name|result
operator|=
literal|0
init|;
name|result
operator|<=
name|limit
condition|;
operator|++
name|result
control|)
block|{
if|if
condition|(
name|to_find
operator|==
name|list
index|[
name|result
index|]
operator|||
name|result
operator|==
name|limit
operator|||
operator|(
operator|(
name|result
operator|<
name|limit
operator|)
operator|&&
operator|(
name|to_find
operator|<
name|list
index|[
name|result
operator|+
literal|1
index|]
operator|)
operator|)
condition|)
block|{
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Build a list of the display-columns for the given string's characters.  */
end_comment

begin_function
specifier|const
name|int
modifier|*
name|dlg_index_columns
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|unsigned
name|len
init|=
operator|(
name|unsigned
operator|)
name|dlg_count_wchars
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|unsigned
name|inx
decl_stmt|;
name|CACHE
modifier|*
name|cache
init|=
name|load_cache
argument_list|(
name|cInxCols
argument_list|,
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|same_cache2
argument_list|(
name|cache
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|cache
operator|->
name|list
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WIDE_CURSES
if|if
condition|(
name|have_locale
argument_list|()
condition|)
block|{
name|size_t
name|num_bytes
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
specifier|const
name|int
modifier|*
name|inx_wchars
init|=
name|dlg_index_wchars
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|mbstate_t
name|state
decl_stmt|;
for|for
control|(
name|inx
operator|=
literal|0
init|;
name|inx
operator|<
name|len
condition|;
operator|++
name|inx
control|)
block|{
name|wchar_t
name|temp
index|[
literal|2
index|]
decl_stmt|;
name|size_t
name|check
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|string
index|[
name|inx_wchars
index|[
name|inx
index|]
index|]
operator|==
name|TAB
condition|)
block|{
name|result
operator|=
operator|(
operator|(
name|cache
operator|->
name|list
index|[
name|inx
index|]
operator||
literal|7
operator|)
operator|+
literal|1
operator|)
operator|-
name|cache
operator|->
name|list
index|[
name|inx
index|]
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|check
operator|=
name|mbrtowc
argument_list|(
name|temp
argument_list|,
name|string
operator|+
name|inx_wchars
index|[
name|inx
index|]
argument_list|,
name|num_bytes
operator|-
operator|(
name|size_t
operator|)
name|inx_wchars
index|[
name|inx
index|]
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|check
operator|<=
literal|0
condition|)
block|{
name|result
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|wcwidth
argument_list|(
name|temp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
specifier|const
name|wchar_t
modifier|*
name|printable
decl_stmt|;
name|cchar_t
name|temp2
decl_stmt|,
modifier|*
name|temp2p
init|=
operator|&
name|temp2
decl_stmt|;
name|setcchar
argument_list|(
name|temp2p
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printable
operator|=
name|wunctrl
argument_list|(
name|temp2p
argument_list|)
expr_stmt|;
name|result
operator|=
name|printable
condition|?
operator|(
name|int
operator|)
name|wcslen
argument_list|(
name|printable
argument_list|)
else|:
literal|1
expr_stmt|;
block|}
block|}
name|cache
operator|->
name|list
index|[
name|inx
operator|+
literal|1
index|]
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|inx
operator|!=
literal|0
condition|)
name|cache
operator|->
name|list
index|[
name|inx
operator|+
literal|1
index|]
operator|+=
name|cache
operator|->
name|list
index|[
name|inx
index|]
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* USE_WIDE_CURSES */
block|{
for|for
control|(
name|inx
operator|=
literal|0
init|;
name|inx
operator|<
name|len
condition|;
operator|++
name|inx
control|)
block|{
name|chtype
name|ch
init|=
name|UCH
argument_list|(
name|string
index|[
name|inx
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|TAB
condition|)
name|cache
operator|->
name|list
index|[
name|inx
operator|+
literal|1
index|]
operator|=
operator|(
operator|(
name|cache
operator|->
name|list
index|[
name|inx
index|]
operator||
literal|7
operator|)
operator|+
literal|1
operator|)
operator|-
name|cache
operator|->
name|list
index|[
name|inx
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
name|cache
operator|->
name|list
index|[
name|inx
operator|+
literal|1
index|]
operator|=
literal|1
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|printable
decl_stmt|;
name|printable
operator|=
name|unctrl
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|cache
operator|->
name|list
index|[
name|inx
operator|+
literal|1
index|]
operator|=
operator|(
name|printable
condition|?
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|printable
argument_list|)
else|:
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|inx
operator|!=
literal|0
condition|)
name|cache
operator|->
name|list
index|[
name|inx
operator|+
literal|1
index|]
operator|+=
name|cache
operator|->
name|list
index|[
name|inx
index|]
expr_stmt|;
block|}
block|}
block|}
return|return
name|cache
operator|->
name|list
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the number of columns used for a string.  That happens to be the  * end-value of the cols[] array.  */
end_comment

begin_function
name|int
name|dlg_count_columns
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|int
name|limit
init|=
name|dlg_count_wchars
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|limit
operator|>
literal|0
condition|)
block|{
specifier|const
name|int
modifier|*
name|cols
init|=
name|dlg_index_columns
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|result
operator|=
name|cols
index|[
name|limit
index|]
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
name|dlg_finish_string
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Given a column limit, count the number of wide characters that can fit  * into that limit.  The offset is used to skip over a leading character  * that was already written.  */
end_comment

begin_function
name|int
name|dlg_limit_columns
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|limit
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
specifier|const
name|int
modifier|*
name|cols
init|=
name|dlg_index_columns
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|result
init|=
name|dlg_count_wchars
argument_list|(
name|string
argument_list|)
decl_stmt|;
while|while
condition|(
name|result
operator|>
literal|0
operator|&&
operator|(
name|cols
index|[
name|result
index|]
operator|-
name|cols
index|[
name|offset
index|]
operator|)
operator|>
name|limit
condition|)
operator|--
name|result
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Updates the string and character-offset, given various editing characters  * or literal characters which are inserted at the character-offset.  */
end_comment

begin_function
name|bool
name|dlg_edit_string
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|int
modifier|*
name|chr_offset
parameter_list|,
name|int
name|key
parameter_list|,
name|int
name|fkey
parameter_list|,
name|bool
name|force
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|len
init|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|limit
init|=
name|dlg_count_wchars
argument_list|(
name|string
argument_list|)
decl_stmt|;
specifier|const
name|int
modifier|*
name|indx
init|=
name|dlg_index_wchars
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|dlg_find_index
argument_list|(
name|indx
argument_list|,
name|limit
argument_list|,
operator|*
name|chr_offset
argument_list|)
decl_stmt|;
name|int
name|max_len
init|=
name|dlg_max_input
argument_list|(
name|MAX_LEN
argument_list|)
decl_stmt|;
name|bool
name|edit
init|=
name|TRUE
decl_stmt|;
comment|/* transform editing characters into equivalent function-keys */
if|if
condition|(
operator|!
name|fkey
condition|)
block|{
name|fkey
operator|=
name|TRUE
expr_stmt|;
comment|/* assume we transform */
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
name|ESC
case|:
case|case
name|TAB
case|:
name|fkey
operator|=
name|FALSE
expr_stmt|;
comment|/* this is used for navigation */
break|break;
default|default:
name|fkey
operator|=
name|FALSE
expr_stmt|;
comment|/* ...no, we did not transform */
break|break;
block|}
block|}
if|if
condition|(
name|fkey
condition|)
block|{
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|0
case|:
comment|/* special case for loop entry */
name|edit
operator|=
name|force
expr_stmt|;
break|break;
case|case
name|DLGK_GRID_LEFT
case|:
if|if
condition|(
operator|*
name|chr_offset
operator|&&
name|offset
operator|>
literal|0
condition|)
operator|*
name|chr_offset
operator|=
name|indx
index|[
name|offset
operator|-
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|DLGK_GRID_RIGHT
case|:
if|if
condition|(
name|offset
operator|<
name|limit
condition|)
operator|*
name|chr_offset
operator|=
name|indx
index|[
name|offset
operator|+
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|DLGK_BEGIN
case|:
if|if
condition|(
operator|*
name|chr_offset
condition|)
operator|*
name|chr_offset
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DLGK_FINAL
case|:
if|if
condition|(
name|offset
operator|<
name|limit
condition|)
operator|*
name|chr_offset
operator|=
name|indx
index|[
name|limit
index|]
expr_stmt|;
break|break;
case|case
name|DLGK_DELETE_LEFT
case|:
if|if
condition|(
name|offset
condition|)
block|{
name|int
name|gap
init|=
name|indx
index|[
name|offset
index|]
operator|-
name|indx
index|[
name|offset
operator|-
literal|1
index|]
decl_stmt|;
operator|*
name|chr_offset
operator|=
name|indx
index|[
name|offset
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|gap
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
operator|*
name|chr_offset
init|;
operator|(
name|string
index|[
name|i
index|]
operator|=
name|string
index|[
name|i
operator|+
name|gap
index|]
operator|)
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
empty_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|DLGK_DELETE_RIGHT
case|:
if|if
condition|(
name|limit
condition|)
block|{
if|if
condition|(
operator|--
name|limit
operator|==
literal|0
condition|)
block|{
name|string
index|[
operator|*
name|chr_offset
operator|=
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|int
name|gap
init|=
operator|(
operator|(
name|offset
operator|<=
name|limit
operator|)
condition|?
operator|(
name|indx
index|[
name|offset
operator|+
literal|1
index|]
operator|-
name|indx
index|[
name|offset
index|]
operator|)
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|gap
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|indx
index|[
name|offset
index|]
init|;
operator|(
name|string
index|[
name|i
index|]
operator|=
name|string
index|[
name|i
operator|+
name|gap
index|]
operator|)
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
empty_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
name|string
index|[
name|indx
index|[
name|offset
operator|-
literal|1
index|]
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|chr_offset
operator|>
name|indx
index|[
name|limit
index|]
condition|)
operator|*
name|chr_offset
operator|=
name|indx
index|[
name|limit
index|]
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DLGK_DELETE_ALL
case|:
name|string
index|[
operator|*
name|chr_offset
operator|=
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|DLGK_ENTER
case|:
name|edit
operator|=
literal|0
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|KEY_RESIZE
case|case
name|KEY_RESIZE
case|:
name|edit
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|DLGK_GRID_UP
case|:
case|case
name|DLGK_GRID_DOWN
case|:
case|case
name|DLGK_FIELD_NEXT
case|:
case|case
name|DLGK_FIELD_PREV
case|:
name|edit
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ERR
case|:
name|edit
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|key
operator|==
name|ESC
operator|||
name|key
operator|==
name|ERR
condition|)
block|{
name|edit
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|<
name|max_len
condition|)
block|{
for|for
control|(
name|i
operator|=
operator|++
name|len
init|;
name|i
operator|>
operator|*
name|chr_offset
condition|;
name|i
operator|--
control|)
name|string
index|[
name|i
index|]
operator|=
name|string
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|string
index|[
operator|*
name|chr_offset
index|]
operator|=
operator|(
name|char
operator|)
name|key
expr_stmt|;
operator|*
name|chr_offset
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|beep
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|edit
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|compute_edit_offset
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|chr_offset
parameter_list|,
name|int
name|x_last
parameter_list|,
name|int
modifier|*
name|p_dpy_column
parameter_list|,
name|int
modifier|*
name|p_scroll_amt
parameter_list|)
block|{
specifier|const
name|int
modifier|*
name|cols
init|=
name|dlg_index_columns
argument_list|(
name|string
argument_list|)
decl_stmt|;
specifier|const
name|int
modifier|*
name|indx
init|=
name|dlg_index_wchars
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|limit
init|=
name|dlg_count_wchars
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|dlg_find_index
argument_list|(
name|indx
argument_list|,
name|limit
argument_list|,
name|chr_offset
argument_list|)
decl_stmt|;
name|int
name|offset2
decl_stmt|;
name|int
name|dpy_column
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|offset2
operator|=
literal|0
init|;
name|n
operator|<=
name|offset
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
operator|(
name|cols
index|[
name|offset
index|]
operator|-
name|cols
index|[
name|n
index|]
operator|)
operator|<
name|x_last
operator|&&
operator|(
name|offset
operator|==
name|limit
operator|||
operator|(
name|cols
index|[
name|offset
operator|+
literal|1
index|]
operator|-
name|cols
index|[
name|n
index|]
operator|)
operator|<
name|x_last
operator|)
condition|)
block|{
name|offset2
operator|=
name|n
expr_stmt|;
break|break;
block|}
block|}
name|dpy_column
operator|=
name|cols
index|[
name|offset
index|]
operator|-
name|cols
index|[
name|offset2
index|]
expr_stmt|;
if|if
condition|(
name|p_dpy_column
operator|!=
literal|0
condition|)
operator|*
name|p_dpy_column
operator|=
name|dpy_column
expr_stmt|;
if|if
condition|(
name|p_scroll_amt
operator|!=
literal|0
condition|)
operator|*
name|p_scroll_amt
operator|=
name|offset2
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given the character-offset in the string, returns the display-offset where  * we will position the cursor.  */
end_comment

begin_function
name|int
name|dlg_edit_offset
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|int
name|chr_offset
parameter_list|,
name|int
name|x_last
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|compute_edit_offset
argument_list|(
name|string
argument_list|,
name|chr_offset
argument_list|,
name|x_last
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Displays the string, shifted as necessary, to fit within the box and show  * the current character-offset.  */
end_comment

begin_function
name|void
name|dlg_show_string
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
comment|/* string to display (may be multibyte) */
name|int
name|chr_offset
parameter_list|,
comment|/* character (not bytes) offset */
name|chtype
name|attr
parameter_list|,
comment|/* window-attributes */
name|int
name|y_base
parameter_list|,
comment|/* beginning row on screen */
name|int
name|x_base
parameter_list|,
comment|/* beginning column on screen */
name|int
name|x_last
parameter_list|,
comment|/* number of columns on screen */
name|bool
name|hidden
parameter_list|,
comment|/* if true, do not echo */
name|bool
name|force
parameter_list|)
comment|/* if true, force repaint */
block|{
name|x_last
operator|=
name|MIN
argument_list|(
name|x_last
operator|+
name|x_base
argument_list|,
name|getmaxx
argument_list|(
name|win
argument_list|)
argument_list|)
operator|-
name|x_base
expr_stmt|;
if|if
condition|(
name|hidden
operator|&&
operator|!
name|dialog_vars
operator|.
name|insecure
condition|)
block|{
if|if
condition|(
name|force
condition|)
block|{
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|win
argument_list|,
name|y_base
argument_list|,
name|x_base
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|int
modifier|*
name|cols
init|=
name|dlg_index_columns
argument_list|(
name|string
argument_list|)
decl_stmt|;
specifier|const
name|int
modifier|*
name|indx
init|=
name|dlg_index_wchars
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|limit
init|=
name|dlg_count_wchars
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|input_x
decl_stmt|;
name|int
name|scrollamt
decl_stmt|;
name|compute_edit_offset
argument_list|(
name|string
argument_list|,
name|chr_offset
argument_list|,
name|x_last
argument_list|,
operator|&
name|input_x
argument_list|,
operator|&
name|scrollamt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wattrset
argument_list|(
name|win
argument_list|,
name|attr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|win
argument_list|,
name|y_base
argument_list|,
name|x_base
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|scrollamt
operator|,
name|k
operator|=
literal|0
init|;
name|i
operator|<
name|limit
operator|&&
name|k
operator|<
name|x_last
condition|;
operator|++
name|i
control|)
block|{
name|int
name|check
init|=
name|cols
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|cols
index|[
name|scrollamt
index|]
decl_stmt|;
if|if
condition|(
name|check
operator|<=
name|x_last
condition|)
block|{
for|for
control|(
name|j
operator|=
name|indx
index|[
name|i
index|]
init|;
name|j
operator|<
name|indx
index|[
name|i
operator|+
literal|1
index|]
condition|;
operator|++
name|j
control|)
block|{
name|chtype
name|ch
init|=
name|UCH
argument_list|(
name|string
index|[
name|j
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|hidden
operator|&&
name|dialog_vars
operator|.
name|insecure
condition|)
block|{
name|waddch
argument_list|(
name|win
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|TAB
condition|)
block|{
name|int
name|count
init|=
name|cols
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|cols
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
operator|--
name|count
operator|>=
literal|0
condition|)
name|waddch
argument_list|(
name|win
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|waddch
argument_list|(
name|win
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
name|k
operator|=
name|check
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
while|while
condition|(
name|k
operator|++
operator|<
name|x_last
condition|)
name|waddch
argument_list|(
name|win
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wmove
argument_list|(
name|win
argument_list|,
name|y_base
argument_list|,
name|x_base
operator|+
name|input_x
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Discard cached data for the given string.  */
end_comment

begin_function
name|void
name|dlg_finish_string
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
if|#
directive|if
name|USE_CACHING
if|if
condition|(
operator|(
name|string
operator|!=
literal|0
operator|)
operator|&&
name|dialog_state
operator|.
name|finish_string
condition|)
block|{
name|CACHE
modifier|*
name|p
init|=
name|cache_list
decl_stmt|;
name|CACHE
modifier|*
name|q
init|=
literal|0
decl_stmt|;
name|CACHE
modifier|*
name|r
decl_stmt|;
while|while
condition|(
name|p
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|string_at
operator|==
name|string
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TSEARCH
if|if
condition|(
name|tdelete
argument_list|(
name|p
argument_list|,
operator|&
name|sorted_cache
argument_list|,
name|compare_cache
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|trace_cache
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|string
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|p
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|list
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|p
operator|->
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|cache_list
condition|)
block|{
name|cache_list
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|r
operator|=
name|cache_list
expr_stmt|;
block|}
else|else
block|{
name|q
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|r
operator|=
name|q
expr_stmt|;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|r
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|string
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NO_LEAKS
end_ifdef

begin_function
name|void
name|_dlg_inputstr_leaks
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|USE_CACHING
name|dialog_state
operator|.
name|finish_string
operator|=
name|TRUE
expr_stmt|;
name|trace_cache
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
while|while
condition|(
name|cache_list
operator|!=
literal|0
condition|)
block|{
name|dlg_finish_string
argument_list|(
name|cache_list
operator|->
name|string_at
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_CACHING */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_LEAKS */
end_comment

end_unit

