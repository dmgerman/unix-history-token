begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* filter - postprocessing of flex output through filters */
end_comment

begin_comment
comment|/*  This file is part of flex. */
end_comment

begin_comment
comment|/*  Redistribution and use in source and binary forms, with or without */
end_comment

begin_comment
comment|/*  modification, are permitted provided that the following conditions */
end_comment

begin_comment
comment|/*  are met: */
end_comment

begin_comment
comment|/*  1. Redistributions of source code must retain the above copyright */
end_comment

begin_comment
comment|/*     notice, this list of conditions and the following disclaimer. */
end_comment

begin_comment
comment|/*  2. Redistributions in binary form must reproduce the above copyright */
end_comment

begin_comment
comment|/*     notice, this list of conditions and the following disclaimer in the */
end_comment

begin_comment
comment|/*     documentation and/or other materials provided with the distribution. */
end_comment

begin_comment
comment|/*  Neither the name of the University nor the names of its contributors */
end_comment

begin_comment
comment|/*  may be used to endorse or promote products derived from this software */
end_comment

begin_comment
comment|/*  without specific prior written permission. */
end_comment

begin_comment
comment|/*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR */
end_comment

begin_comment
comment|/*  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED */
end_comment

begin_comment
comment|/*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR */
end_comment

begin_comment
comment|/*  PURPOSE. */
end_comment

begin_include
include|#
directive|include
file|"flexdef.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|check_4_gnu_m4
init|=
literal|"m4_dnl ifdef(`__gnu__', ,"
literal|"`errprint(Flex requires GNU M4. Set the PATH or set the M4 environment variable to its path name.)"
literal|" m4exit(2)')\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** global chain. */
end_comment

begin_decl_stmt
name|struct
name|filter
modifier|*
name|output_chain
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate and initialize an external filter.  * @param chain the current chain or NULL for new chain  * @param cmd the command to execute.  * @param ... a NULL terminated list of (const char*) arguments to command,  *            not including argv[0].  * @return newest filter in chain  */
end_comment

begin_function
name|struct
name|filter
modifier|*
name|filter_create_ext
parameter_list|(
name|struct
name|filter
modifier|*
name|chain
parameter_list|,
specifier|const
name|char
modifier|*
name|cmd
parameter_list|,
modifier|...
parameter_list|)
block|{
name|struct
name|filter
modifier|*
name|f
decl_stmt|;
name|int
name|max_args
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
comment|/* allocate and initialize new filter */
name|f
operator|=
operator|(
expr|struct
name|filter
operator|*
operator|)
name|flex_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|filter
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"flex_alloc failed (f) in filter_create_ext"
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|filter_func
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|extra
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|argc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chain
operator|!=
name|NULL
condition|)
block|{
comment|/* append f to end of chain */
while|while
condition|(
name|chain
operator|->
name|next
condition|)
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
name|chain
operator|->
name|next
operator|=
name|f
expr_stmt|;
block|}
comment|/* allocate argv, and populate it with the argument list. */
name|max_args
operator|=
literal|8
expr_stmt|;
name|f
operator|->
name|argv
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|flex_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|max_args
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
operator|->
name|argv
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"flex_alloc failed (f->argv) in filter_create_ext"
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|argv
index|[
name|f
operator|->
name|argc
operator|++
index|]
operator|=
name|cmd
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|argc
operator|>=
name|max_args
condition|)
block|{
name|max_args
operator|+=
literal|8
expr_stmt|;
name|f
operator|->
name|argv
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|flex_realloc
argument_list|(
name|f
operator|->
name|argv
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|max_args
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|f
operator|->
name|argv
index|[
name|f
operator|->
name|argc
operator|++
index|]
operator|=
name|s
expr_stmt|;
block|}
name|f
operator|->
name|argv
index|[
name|f
operator|->
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/* Allocate and initialize an internal filter.  * @param chain the current chain or NULL for new chain  * @param filter_func The function that will perform the filtering.  *        filter_func should return 0 if successful, and -1  *        if an error occurs -- or it can simply exit().  * @param extra optional user-defined data to pass to the filter.  * @return newest filter in chain  */
end_comment

begin_function
name|struct
name|filter
modifier|*
name|filter_create_int
parameter_list|(
name|struct
name|filter
modifier|*
name|chain
parameter_list|,
name|int
function_decl|(
modifier|*
name|filter_func
function_decl|)
parameter_list|(
name|struct
name|filter
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|extra
parameter_list|)
block|{
name|struct
name|filter
modifier|*
name|f
decl_stmt|;
comment|/* allocate and initialize new filter */
name|f
operator|=
operator|(
expr|struct
name|filter
operator|*
operator|)
name|flex_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|filter
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"flex_alloc failed in filter_create_int"
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|argc
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|argv
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|filter_func
operator|=
name|filter_func
expr_stmt|;
name|f
operator|->
name|extra
operator|=
name|extra
expr_stmt|;
if|if
condition|(
name|chain
operator|!=
name|NULL
condition|)
block|{
comment|/* append f to end of chain */
while|while
condition|(
name|chain
operator|->
name|next
condition|)
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
name|chain
operator|->
name|next
operator|=
name|f
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/** Fork and exec entire filter chain.  *  @param chain The head of the chain.  *  @return true on success.  */
end_comment

begin_function
name|bool
name|filter_apply_chain
parameter_list|(
name|struct
name|filter
modifier|*
name|chain
parameter_list|)
block|{
name|int
name|pid
decl_stmt|,
name|pipes
index|[
literal|2
index|]
decl_stmt|;
comment|/* Tricky recursion, since we want to begin the chain 	 * at the END. Why? Because we need all the forked processes 	 * to be children of the main flex process. 	 */
if|if
condition|(
name|chain
condition|)
name|filter_apply_chain
argument_list|(
name|chain
operator|->
name|next
argument_list|)
expr_stmt|;
else|else
return|return
name|true
return|;
comment|/* Now we are the right-most unprocessed link in the chain. 	 */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pipes
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"pipe failed"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"fork failed"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* child */
comment|/* We need stdin (the FILE* stdin) to connect to this new pipe.          * There is no portable way to set stdin to a new file descriptor,          * as stdin is not an lvalue on some systems (BSD).          * So we dup the new pipe onto the stdin descriptor and use a no-op fseek          * to sync the stream. This is a Hail Mary situation. It seems to work.          */
name|close
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|,
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|flexfatal
argument_list|(
name|_
argument_list|(
literal|"dup2(pipes[0],0)"
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|stdin
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
comment|/* run as a filter, either internally or by exec */
if|if
condition|(
name|chain
operator|->
name|filter_func
condition|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|chain
operator|->
name|filter_func
argument_list|(
name|chain
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|flexfatal
argument_list|(
name|_
argument_list|(
literal|"filter_func failed"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execvp
argument_list|(
name|chain
operator|->
name|argv
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|*
specifier|const
operator|)
operator|(
name|chain
operator|->
name|argv
operator|)
argument_list|)
expr_stmt|;
name|lerrsf_fatal
argument_list|(
name|_
argument_list|(
literal|"exec of %s failed"
argument_list|)
argument_list|,
name|chain
operator|->
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Parent */
name|close
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|flexfatal
argument_list|(
name|_
argument_list|(
literal|"dup2(pipes[1],1)"
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/** Truncate the chain to max_len number of filters.  * @param chain the current chain.  * @param max_len the maximum length of the chain.  * @return the resulting length of the chain.  */
end_comment

begin_function
name|int
name|filter_truncate
parameter_list|(
name|struct
name|filter
modifier|*
name|chain
parameter_list|,
name|int
name|max_len
parameter_list|)
block|{
name|int
name|len
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|chain
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|chain
operator|->
name|next
operator|&&
name|len
operator|<
name|max_len
condition|)
block|{
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|chain
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/** Splits the chain in order to write to a header file.  *  Similar in spirit to the 'tee' program.  *  The header file name is in extra.  *  @return 0 (zero) on success, and -1 on failure.  */
end_comment

begin_function
name|int
name|filter_tee_header
parameter_list|(
name|struct
name|filter
modifier|*
name|chain
parameter_list|)
block|{
comment|/* This function reads from stdin and writes to both the C file and the 	 * header file at the same time. 	 */
specifier|const
name|int
name|readsz
init|=
literal|512
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|to_cfd
init|=
operator|-
literal|1
decl_stmt|;
name|FILE
modifier|*
name|to_c
init|=
name|NULL
decl_stmt|,
modifier|*
name|to_h
init|=
name|NULL
decl_stmt|;
name|bool
name|write_header
decl_stmt|;
name|write_header
operator|=
operator|(
name|chain
operator|->
name|extra
operator|!=
name|NULL
operator|)
expr_stmt|;
comment|/* Store a copy of the stdout pipe, which is already piped to C file 	 * through the running chain. Then create a new pipe to the H file as 	 * stdout, and fork the rest of the chain again. 	 */
if|if
condition|(
operator|(
name|to_cfd
operator|=
name|dup
argument_list|(
literal|1
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|flexfatal
argument_list|(
name|_
argument_list|(
literal|"dup(1) failed"
argument_list|)
argument_list|)
expr_stmt|;
name|to_c
operator|=
name|fdopen
argument_list|(
name|to_cfd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_header
condition|)
block|{
if|if
condition|(
name|freopen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|chain
operator|->
name|extra
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
name|flexfatal
argument_list|(
name|_
argument_list|(
literal|"freopen(headerfilename) failed"
argument_list|)
argument_list|)
expr_stmt|;
name|filter_apply_chain
argument_list|(
name|chain
operator|->
name|next
argument_list|)
expr_stmt|;
name|to_h
operator|=
name|stdout
expr_stmt|;
block|}
comment|/* Now to_c is a pipe to the C branch, and to_h is a pipe to the H branch. 	 */
if|if
condition|(
name|write_header
condition|)
block|{
name|fputs
argument_list|(
name|check_4_gnu_m4
argument_list|,
name|to_h
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"m4_changecom`'m4_dnl\n"
argument_list|,
name|to_h
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"m4_changequote`'m4_dnl\n"
argument_list|,
name|to_h
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"m4_changequote([[,]])[[]]m4_dnl\n"
argument_list|,
name|to_h
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"m4_define([[M4_YY_NOOP]])[[]]m4_dnl\n"
argument_list|,
name|to_h
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"m4_define( [[M4_YY_IN_HEADER]],[[]])m4_dnl\n"
argument_list|,
name|to_h
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|to_h
argument_list|,
literal|"#ifndef %sHEADER_H\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|to_h
argument_list|,
literal|"#define %sHEADER_H 1\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|to_h
argument_list|,
literal|"#define %sIN_HEADER 1\n\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|to_h
argument_list|,
literal|"m4_define( [[M4_YY_OUTFILE_NAME]],[[%s]])m4_dnl\n"
argument_list|,
name|headerfilename
condition|?
name|headerfilename
else|:
literal|"<stdout>"
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
name|check_4_gnu_m4
argument_list|,
name|to_c
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"m4_changecom`'m4_dnl\n"
argument_list|,
name|to_c
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"m4_changequote`'m4_dnl\n"
argument_list|,
name|to_c
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"m4_changequote([[,]])[[]]m4_dnl\n"
argument_list|,
name|to_c
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"m4_define([[M4_YY_NOOP]])[[]]m4_dnl\n"
argument_list|,
name|to_c
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|to_c
argument_list|,
literal|"m4_define( [[M4_YY_OUTFILE_NAME]],[[%s]])m4_dnl\n"
argument_list|,
name|outfilename
condition|?
name|outfilename
else|:
literal|"<stdout>"
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|flex_alloc
argument_list|(
name|readsz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"flex_alloc failed in filter_tee_header"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|readsz
argument_list|,
name|stdin
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
name|buf
argument_list|,
name|to_c
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_header
condition|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|to_h
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write_header
condition|)
block|{
name|fprintf
argument_list|(
name|to_h
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* write a fake line number. It will get fixed by the linedir filter. */
name|fprintf
argument_list|(
name|to_h
argument_list|,
literal|"#line 4000 \"M4_YY_OUTFILE_NAME\"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|to_h
argument_list|,
literal|"#undef %sIN_HEADER\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|to_h
argument_list|,
literal|"#endif /* %sHEADER_H */\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"m4_undefine( [[M4_YY_IN_HEADER]])m4_dnl\n"
argument_list|,
name|to_h
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|to_h
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|to_h
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"error writing output file %s"
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|chain
operator|->
name|extra
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|to_h
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"error closing output file %s"
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|chain
operator|->
name|extra
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|to_c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|to_c
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"error writing output file %s"
argument_list|)
argument_list|,
name|outfilename
condition|?
name|outfilename
else|:
literal|"<stdout>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|to_c
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"error closing output file %s"
argument_list|)
argument_list|,
name|outfilename
condition|?
name|outfilename
else|:
literal|"<stdout>"
argument_list|)
expr_stmt|;
while|while
condition|(
name|wait
argument_list|(
literal|0
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** Adjust the line numbers in the #line directives of the generated scanner.  * After the m4 expansion, the line numbers are incorrect since the m4 macros  * can add or remove lines.  This only adjusts line numbers for generated code,  * not user code. This also happens to be a good place to squeeze multiple  * blank lines into a single blank line.  */
end_comment

begin_function
name|int
name|filter_fix_linedirs
parameter_list|(
name|struct
name|filter
modifier|*
name|chain
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
specifier|const
name|int
name|readsz
init|=
literal|512
decl_stmt|;
name|int
name|lineno
init|=
literal|1
decl_stmt|;
name|bool
name|in_gen
init|=
name|true
decl_stmt|;
comment|/* in generated code */
name|bool
name|last_was_blank
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|chain
condition|)
return|return
literal|0
return|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|flex_alloc
argument_list|(
name|readsz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"flex_alloc failed in filter_fix_linedirs"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|readsz
argument_list|,
name|stdin
argument_list|)
condition|)
block|{
name|regmatch_t
name|m
index|[
literal|10
index|]
decl_stmt|;
comment|/* Check for #line directive. */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|regexec
argument_list|(
operator|&
name|regex_linedir
argument_list|,
name|buf
argument_list|,
literal|3
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|num
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* extract the line number and filename */
name|num
operator|=
name|regmatch_strtol
argument_list|(
operator|&
name|m
index|[
literal|1
index|]
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fname
operator|=
name|regmatch_dup
argument_list|(
operator|&
name|m
index|[
literal|2
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fname
argument_list|,
name|outfilename
condition|?
name|outfilename
else|:
literal|"<stdout>"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|fname
argument_list|,
name|headerfilename
condition|?
name|headerfilename
else|:
literal|"<stdout>"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|char
name|filename
index|[
name|MAXLINE
index|]
decl_stmt|;
name|s1
operator|=
name|fname
expr_stmt|;
name|s2
operator|=
name|filename
expr_stmt|;
while|while
condition|(
operator|(
name|s2
operator|-
name|filename
operator|)
operator|<
operator|(
name|MAXLINE
operator|-
literal|1
operator|)
operator|&&
operator|*
name|s1
condition|)
block|{
comment|/* Escape the backslash */
if|if
condition|(
operator|*
name|s1
operator|==
literal|'\\'
condition|)
operator|*
name|s2
operator|++
operator|=
literal|'\\'
expr_stmt|;
comment|/* Escape the double quote */
if|if
condition|(
operator|*
name|s1
operator|==
literal|'\"'
condition|)
operator|*
name|s2
operator|++
operator|=
literal|'\\'
expr_stmt|;
comment|/* Copy the character as usual */
operator|*
name|s2
operator|++
operator|=
operator|*
name|s1
operator|++
expr_stmt|;
block|}
operator|*
name|s2
operator|=
literal|'\0'
expr_stmt|;
comment|/* Adjust the line directives. */
name|in_gen
operator|=
name|true
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|readsz
argument_list|,
literal|"#line %d \"%s\"\n"
argument_list|,
name|lineno
operator|+
literal|1
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* it's a #line directive for code we didn't write */
name|in_gen
operator|=
name|false
expr_stmt|;
block|}
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|last_was_blank
operator|=
name|false
expr_stmt|;
block|}
comment|/* squeeze blank lines from generated code */
elseif|else
if|if
condition|(
name|in_gen
operator|&&
name|regexec
argument_list|(
operator|&
name|regex_blank_line
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|last_was_blank
condition|)
continue|continue;
else|else
name|last_was_blank
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
comment|/* it's a line of normal, non-empty code. */
name|last_was_blank
operator|=
name|false
expr_stmt|;
block|}
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"error writing output file %s"
argument_list|)
argument_list|,
name|outfilename
condition|?
name|outfilename
else|:
literal|"<stdout>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|stdout
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"error closing output file %s"
argument_list|)
argument_list|,
name|outfilename
condition|?
name|outfilename
else|:
literal|"<stdout>"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* vim:set expandtab cindent tabstop=4 softtabstop=4 shiftwidth=4 textwidth=0: */
end_comment

end_unit

