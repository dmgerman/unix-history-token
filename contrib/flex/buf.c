begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* flex - tool to generate fast lexical analyzers */
end_comment

begin_comment
comment|/*  Copyright (c) 1990 The Regents of the University of California. */
end_comment

begin_comment
comment|/*  All rights reserved. */
end_comment

begin_comment
comment|/*  This code is derived from software contributed to Berkeley by */
end_comment

begin_comment
comment|/*  Vern Paxson. */
end_comment

begin_comment
comment|/*  The United States Government has rights in this work pursuant */
end_comment

begin_comment
comment|/*  to contract no. DE-AC03-76SF00098 between the United States */
end_comment

begin_comment
comment|/*  Department of Energy and the University of California. */
end_comment

begin_comment
comment|/*  This file is part of flex. */
end_comment

begin_comment
comment|/*  Redistribution and use in source and binary forms, with or without */
end_comment

begin_comment
comment|/*  modification, are permitted provided that the following conditions */
end_comment

begin_comment
comment|/*  are met: */
end_comment

begin_comment
comment|/*  1. Redistributions of source code must retain the above copyright */
end_comment

begin_comment
comment|/*     notice, this list of conditions and the following disclaimer. */
end_comment

begin_comment
comment|/*  2. Redistributions in binary form must reproduce the above copyright */
end_comment

begin_comment
comment|/*     notice, this list of conditions and the following disclaimer in the */
end_comment

begin_comment
comment|/*     documentation and/or other materials provided with the distribution. */
end_comment

begin_comment
comment|/*  Neither the name of the University nor the names of its contributors */
end_comment

begin_comment
comment|/*  may be used to endorse or promote products derived from this software */
end_comment

begin_comment
comment|/*  without specific prior written permission. */
end_comment

begin_comment
comment|/*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR */
end_comment

begin_comment
comment|/*  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED */
end_comment

begin_comment
comment|/*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR */
end_comment

begin_comment
comment|/*  PURPOSE. */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"flexdef.h"
end_include

begin_comment
comment|/* Take note: The buffer object is sometimes used as a String buffer (one  * continuous string), and sometimes used as a list of strings, usually line by  * line.  *   * The type is specified in buf_init by the elt_size. If the elt_size is  * sizeof(char), then the buffer should be treated as string buffer. If the  * elt_size is sizeof(char*), then the buffer should be treated as a list of  * strings.  *  * Certain functions are only appropriate for one type or the other.   */
end_comment

begin_comment
comment|/* global buffers. */
end_comment

begin_decl_stmt
name|struct
name|Buf
name|userdef_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< for user #definitions triggered by cmd-line. */
end_comment

begin_decl_stmt
name|struct
name|Buf
name|defs_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< for #define's autogenerated. List of strings. */
end_comment

begin_decl_stmt
name|struct
name|Buf
name|yydmap_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< string buffer to hold yydmap elements */
end_comment

begin_decl_stmt
name|struct
name|Buf
name|m4defs_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< m4 definitions. List of strings. */
end_comment

begin_decl_stmt
name|struct
name|Buf
name|top_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< contains %top code. String buffer. */
end_comment

begin_function
name|struct
name|Buf
modifier|*
name|buf_print_strings
parameter_list|(
name|struct
name|Buf
modifier|*
name|buf
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|buf
operator|||
operator|!
name|out
condition|)
return|return
name|buf
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buf
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|buf
operator|->
name|elts
operator|)
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|s
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Append a "%s" formatted string to a string buffer */
end_comment

begin_function
name|struct
name|Buf
modifier|*
name|buf_prints
parameter_list|(
name|struct
name|Buf
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|size_t
name|tsz
decl_stmt|;
name|t
operator|=
name|flex_alloc
argument_list|(
name|tsz
operator|=
name|strlen
argument_list|(
name|fmt
argument_list|)
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
name|flexfatal
argument_list|(
name|_
argument_list|(
literal|"Allocation of buffer to print string failed"
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|t
argument_list|,
name|tsz
argument_list|,
name|fmt
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|buf
operator|=
name|buf_strappend
argument_list|(
name|buf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|flex_free
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/** Append a line directive to the string buffer.  * @param buf A string buffer.  * @param filename file name  * @param lineno line number  * @return buf  */
end_comment

begin_function
name|struct
name|Buf
modifier|*
name|buf_linedir
parameter_list|(
name|struct
name|Buf
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|char
modifier|*
name|dst
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
name|t
operator|=
name|flex_alloc
argument_list|(
name|strlen
argument_list|(
literal|"#line \"\"\n"
argument_list|)
operator|+
comment|/* constant parts */
literal|2
operator|*
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
comment|/* filename with possibly all backslashes escaped */
name|NUMCHARLINES
operator|+
comment|/* line number */
literal|1
argument_list|)
expr_stmt|;
comment|/* NUL */
if|if
condition|(
operator|!
name|t
condition|)
name|flexfatal
argument_list|(
name|_
argument_list|(
literal|"Allocation of buffer for line directive failed"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|dst
operator|=
name|t
operator|+
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"#line %d \""
argument_list|,
name|lineno
argument_list|)
operator|,
name|src
operator|=
name|filename
init|;
operator|*
name|src
condition|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
control|)
if|if
condition|(
operator|*
name|src
operator|==
literal|'\\'
condition|)
comment|/* escape backslashes */
operator|*
name|dst
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
name|buf
operator|=
name|buf_strappend
argument_list|(
name|buf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|flex_free
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/** Append the contents of @a src to @a dest.  * @param @a dest the destination buffer  * @param @a dest the source buffer  * @return @a dest  */
end_comment

begin_function
name|struct
name|Buf
modifier|*
name|buf_concat
parameter_list|(
name|struct
name|Buf
modifier|*
name|dest
parameter_list|,
specifier|const
name|struct
name|Buf
modifier|*
name|src
parameter_list|)
block|{
name|buf_append
argument_list|(
name|dest
argument_list|,
name|src
operator|->
name|elts
argument_list|,
name|src
operator|->
name|nelts
argument_list|)
expr_stmt|;
return|return
name|dest
return|;
block|}
end_function

begin_comment
comment|/* Appends n characters in str to buf. */
end_comment

begin_function
name|struct
name|Buf
modifier|*
name|buf_strnappend
parameter_list|(
name|buf
parameter_list|,
name|str
parameter_list|,
name|n
parameter_list|)
name|struct
name|Buf
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|buf_append
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* "undo" the '\0' character that buf_append() already copied. */
name|buf
operator|->
name|nelts
operator|--
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Appends characters in str to buf. */
end_comment

begin_function
name|struct
name|Buf
modifier|*
name|buf_strappend
parameter_list|(
name|buf
parameter_list|,
name|str
parameter_list|)
name|struct
name|Buf
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
return|return
name|buf_strnappend
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* appends "#define str def\n" */
end_comment

begin_function
name|struct
name|Buf
modifier|*
name|buf_strdefine
parameter_list|(
name|buf
parameter_list|,
name|str
parameter_list|,
name|def
parameter_list|)
name|struct
name|Buf
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
specifier|const
name|char
modifier|*
name|def
decl_stmt|;
block|{
name|buf_strappend
argument_list|(
name|buf
argument_list|,
literal|"#define "
argument_list|)
expr_stmt|;
name|buf_strappend
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|buf_strappend
argument_list|(
name|buf
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|buf_strappend
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|buf_strappend
argument_list|(
name|buf
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|buf_strappend
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/** Pushes "m4_define( [[def]], [[val]])m4_dnl" to end of buffer.  * @param buf A buffer as a list of strings.  * @param def The m4 symbol to define.  * @param val The definition; may be NULL.  * @return buf  */
end_comment

begin_function
name|struct
name|Buf
modifier|*
name|buf_m4_define
parameter_list|(
name|struct
name|Buf
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|def
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
literal|"m4_define( [[%s]], [[%s]])m4_dnl\n"
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|strsz
decl_stmt|;
name|val
operator|=
name|val
condition|?
name|val
else|:
literal|""
expr_stmt|;
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|flex_alloc
argument_list|(
name|strsz
operator|=
name|strlen
argument_list|(
name|fmt
argument_list|)
operator|+
name|strlen
argument_list|(
name|def
argument_list|)
operator|+
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
name|flexfatal
argument_list|(
name|_
argument_list|(
literal|"Allocation of buffer for m4 def failed"
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|str
argument_list|,
name|strsz
argument_list|,
name|fmt
argument_list|,
name|def
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|buf_append
argument_list|(
name|buf
argument_list|,
operator|&
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/** Pushes "m4_undefine([[def]])m4_dnl" to end of buffer.  * @param buf A buffer as a list of strings.  * @param def The m4 symbol to undefine.  * @return buf  */
end_comment

begin_function
name|struct
name|Buf
modifier|*
name|buf_m4_undefine
parameter_list|(
name|struct
name|Buf
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|def
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
literal|"m4_undefine( [[%s]])m4_dnl\n"
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|strsz
decl_stmt|;
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|flex_alloc
argument_list|(
name|strsz
operator|=
name|strlen
argument_list|(
name|fmt
argument_list|)
operator|+
name|strlen
argument_list|(
name|def
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
name|flexfatal
argument_list|(
name|_
argument_list|(
literal|"Allocation of buffer for m4 undef failed"
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|str
argument_list|,
name|strsz
argument_list|,
name|fmt
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|buf_append
argument_list|(
name|buf
argument_list|,
operator|&
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* create buf with 0 elements, each of size elem_size. */
end_comment

begin_function
name|void
name|buf_init
parameter_list|(
name|buf
parameter_list|,
name|elem_size
parameter_list|)
name|struct
name|Buf
modifier|*
name|buf
decl_stmt|;
name|size_t
name|elem_size
decl_stmt|;
block|{
name|buf
operator|->
name|elts
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
name|buf
operator|->
name|nelts
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|elt_size
operator|=
name|elem_size
expr_stmt|;
name|buf
operator|->
name|nmax
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* frees memory */
end_comment

begin_function
name|void
name|buf_destroy
parameter_list|(
name|buf
parameter_list|)
name|struct
name|Buf
modifier|*
name|buf
decl_stmt|;
block|{
if|if
condition|(
name|buf
operator|&&
name|buf
operator|->
name|elts
condition|)
name|flex_free
argument_list|(
name|buf
operator|->
name|elts
argument_list|)
expr_stmt|;
name|buf
operator|->
name|elts
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* appends ptr[] to buf, grow if necessary.  * n_elem is number of elements in ptr[], NOT bytes.  * returns buf.  * We grow by mod(512) boundaries.  */
end_comment

begin_function
name|struct
name|Buf
modifier|*
name|buf_append
parameter_list|(
name|buf
parameter_list|,
name|ptr
parameter_list|,
name|n_elem
parameter_list|)
name|struct
name|Buf
modifier|*
name|buf
decl_stmt|;
specifier|const
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|n_elem
decl_stmt|;
block|{
name|int
name|n_alloc
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
operator|||
name|n_elem
operator|==
literal|0
condition|)
return|return
name|buf
return|;
comment|/* May need to alloc more. */
if|if
condition|(
name|n_elem
operator|+
name|buf
operator|->
name|nelts
operator|>
name|buf
operator|->
name|nmax
condition|)
block|{
comment|/* exact amount needed... */
name|n_alloc
operator|=
operator|(
name|n_elem
operator|+
name|buf
operator|->
name|nelts
operator|)
operator|*
name|buf
operator|->
name|elt_size
expr_stmt|;
comment|/* ...plus some extra */
if|if
condition|(
operator|(
operator|(
name|n_alloc
operator|*
name|buf
operator|->
name|elt_size
operator|)
operator|%
literal|512
operator|)
operator|!=
literal|0
operator|&&
name|buf
operator|->
name|elt_size
operator|<
literal|512
condition|)
name|n_alloc
operator|+=
operator|(
literal|512
operator|-
operator|(
operator|(
name|n_alloc
operator|*
name|buf
operator|->
name|elt_size
operator|)
operator|%
literal|512
operator|)
operator|)
operator|/
name|buf
operator|->
name|elt_size
expr_stmt|;
if|if
condition|(
operator|!
name|buf
operator|->
name|elts
condition|)
name|buf
operator|->
name|elts
operator|=
name|allocate_array
argument_list|(
name|n_alloc
argument_list|,
name|buf
operator|->
name|elt_size
argument_list|)
expr_stmt|;
else|else
name|buf
operator|->
name|elts
operator|=
name|reallocate_array
argument_list|(
name|buf
operator|->
name|elts
argument_list|,
name|n_alloc
argument_list|,
name|buf
operator|->
name|elt_size
argument_list|)
expr_stmt|;
name|buf
operator|->
name|nmax
operator|=
name|n_alloc
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|->
name|elts
operator|+
name|buf
operator|->
name|nelts
operator|*
name|buf
operator|->
name|elt_size
argument_list|,
name|ptr
argument_list|,
name|n_elem
operator|*
name|buf
operator|->
name|elt_size
argument_list|)
expr_stmt|;
name|buf
operator|->
name|nelts
operator|+=
name|n_elem
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* vim:set tabstop=8 softtabstop=4 shiftwidth=4: */
end_comment

end_unit

