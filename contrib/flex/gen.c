begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gen - actual generation (writing) of flex scanners */
end_comment

begin_comment
comment|/*  Copyright (c) 1990 The Regents of the University of California. */
end_comment

begin_comment
comment|/*  All rights reserved. */
end_comment

begin_comment
comment|/*  This code is derived from software contributed to Berkeley by */
end_comment

begin_comment
comment|/*  Vern Paxson. */
end_comment

begin_comment
comment|/*  The United States Government has rights in this work pursuant */
end_comment

begin_comment
comment|/*  to contract no. DE-AC03-76SF00098 between the United States */
end_comment

begin_comment
comment|/*  Department of Energy and the University of California. */
end_comment

begin_comment
comment|/*  This file is part of flex. */
end_comment

begin_comment
comment|/*  Redistribution and use in source and binary forms, with or without */
end_comment

begin_comment
comment|/*  modification, are permitted provided that the following conditions */
end_comment

begin_comment
comment|/*  are met: */
end_comment

begin_comment
comment|/*  1. Redistributions of source code must retain the above copyright */
end_comment

begin_comment
comment|/*     notice, this list of conditions and the following disclaimer. */
end_comment

begin_comment
comment|/*  2. Redistributions in binary form must reproduce the above copyright */
end_comment

begin_comment
comment|/*     notice, this list of conditions and the following disclaimer in the */
end_comment

begin_comment
comment|/*     documentation and/or other materials provided with the distribution. */
end_comment

begin_comment
comment|/*  Neither the name of the University nor the names of its contributors */
end_comment

begin_comment
comment|/*  may be used to endorse or promote products derived from this software */
end_comment

begin_comment
comment|/*  without specific prior written permission. */
end_comment

begin_comment
comment|/*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR */
end_comment

begin_comment
comment|/*  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED */
end_comment

begin_comment
comment|/*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR */
end_comment

begin_comment
comment|/*  PURPOSE. */
end_comment

begin_include
include|#
directive|include
file|"flexdef.h"
end_include

begin_include
include|#
directive|include
file|"tables.h"
end_include

begin_comment
comment|/* declare functions that have forward references */
end_comment

begin_decl_stmt
name|void
name|gen_next_state
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|genecs
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|indent_put2s
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|indent_puts
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|indent_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* each level is 8 spaces */
end_comment

begin_define
define|#
directive|define
name|indent_up
parameter_list|()
value|(++indent_level)
end_define

begin_define
define|#
directive|define
name|indent_down
parameter_list|()
value|(--indent_level)
end_define

begin_define
define|#
directive|define
name|set_indent
parameter_list|(
name|indent_val
parameter_list|)
value|indent_level = indent_val
end_define

begin_comment
comment|/* Almost everything is done in terms of arrays starting at 1, so provide  * a null entry for the zero element of all C arrays.  (The exception  * to this is that the fast table representation generally uses the  * 0 elements of its arrays, too.)  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_int16_decl
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|gentables
operator|)
condition|?
literal|"static yyconst flex_int16_t %s[%d] =\n    {   0,\n"
else|:
literal|"static yyconst flex_int16_t * %s = 0;\n"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_int32_decl
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|gentables
operator|)
condition|?
literal|"static yyconst flex_int32_t %s[%d] =\n    {   0,\n"
else|:
literal|"static yyconst flex_int32_t * %s = 0;\n"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_state_decl
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|gentables
operator|)
condition|?
literal|"static yyconst yy_state_type %s[%d] =\n    {   0,\n"
else|:
literal|"static yyconst yy_state_type * %s = 0;\n"
return|;
block|}
end_function

begin_comment
comment|/* Indent to the current level. */
end_comment

begin_function
name|void
name|do_indent
parameter_list|()
block|{
name|int
name|i
init|=
name|indent_level
operator|*
literal|8
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|8
condition|)
block|{
name|outc
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|i
operator|-=
literal|8
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|outc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** Make the table for possible eol matches.  *  @return the newly allocated rule_can_match_eol table  */
end_comment

begin_function
specifier|static
name|struct
name|yytbl_data
modifier|*
name|mkeoltbl
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|flex_int8_t
modifier|*
name|tdata
init|=
literal|0
decl_stmt|;
name|struct
name|yytbl_data
modifier|*
name|tbl
decl_stmt|;
name|tbl
operator|=
operator|(
expr|struct
name|yytbl_data
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|yytbl_data
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_init
argument_list|(
name|tbl
argument_list|,
name|YYTD_ID_RULE_CAN_MATCH_EOL
argument_list|)
expr_stmt|;
name|tbl
operator|->
name|td_flags
operator|=
name|YYTD_DATA8
expr_stmt|;
name|tbl
operator|->
name|td_lolen
operator|=
name|num_rules
operator|+
literal|1
expr_stmt|;
name|tbl
operator|->
name|td_data
operator|=
name|tdata
operator|=
operator|(
name|flex_int8_t
operator|*
operator|)
name|calloc
argument_list|(
name|tbl
operator|->
name|td_lolen
argument_list|,
sizeof|sizeof
argument_list|(
name|flex_int8_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|num_rules
condition|;
name|i
operator|++
control|)
name|tdata
index|[
name|i
index|]
operator|=
name|rule_has_nl
index|[
name|i
index|]
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|buf_prints
argument_list|(
operator|&
name|yydmap_buf
argument_list|,
literal|"\t{YYTD_ID_RULE_CAN_MATCH_EOL, (void**)&yy_rule_can_match_eol, sizeof(%s)},\n"
argument_list|,
literal|"flex_int32_t"
argument_list|)
expr_stmt|;
return|return
name|tbl
return|;
block|}
end_function

begin_comment
comment|/* Generate the table for possible eol matches. */
end_comment

begin_function
specifier|static
name|void
name|geneoltbl
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|outn
argument_list|(
literal|"m4_ifdef( [[M4_YY_USE_LINENO]],[["
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"/* Table of booleans, true if rule could match eol. */"
argument_list|)
expr_stmt|;
name|out_str_dec
argument_list|(
name|get_int32_decl
argument_list|()
argument_list|,
literal|"yy_rule_can_match_eol"
argument_list|,
name|num_rules
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gentables
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|num_rules
condition|;
name|i
operator|++
control|)
block|{
name|out_dec
argument_list|(
literal|"%d, "
argument_list|,
name|rule_has_nl
index|[
name|i
index|]
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* format nicely, 20 numbers per line. */
if|if
condition|(
operator|(
name|i
operator|%
literal|20
operator|)
operator|==
literal|19
condition|)
name|out
argument_list|(
literal|"\n    "
argument_list|)
expr_stmt|;
block|}
name|out
argument_list|(
literal|"    };\n"
argument_list|)
expr_stmt|;
block|}
name|outn
argument_list|(
literal|"]])"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the code to keep backing-up information. */
end_comment

begin_function
name|void
name|gen_backing_up
parameter_list|()
block|{
if|if
condition|(
name|reject
operator|||
name|num_backing_up
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|fullspd
condition|)
name|indent_puts
argument_list|(
literal|"if ( yy_current_state[-1].yy_nxt )"
argument_list|)
expr_stmt|;
else|else
name|indent_puts
argument_list|(
literal|"if ( yy_accept[yy_current_state] )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_G(yy_last_accepting_state) = yy_current_state;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_G(yy_last_accepting_cpos) = yy_cp;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the code to perform the backing up. */
end_comment

begin_function
name|void
name|gen_bu_action
parameter_list|()
block|{
if|if
condition|(
name|reject
operator|||
name|num_backing_up
operator|==
literal|0
condition|)
return|return;
name|set_indent
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"case 0: /* must back up */"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"/* undo the effects of YY_DO_BEFORE_ACTION */"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"*yy_cp = YY_G(yy_hold_char);"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullspd
operator|||
name|fulltbl
condition|)
name|indent_puts
argument_list|(
literal|"yy_cp = YY_G(yy_last_accepting_cpos) + 1;"
argument_list|)
expr_stmt|;
else|else
comment|/* Backing-up info for compressed tables is taken \after/ 		 * yy_cp has been incremented for the next state. 		 */
name|indent_puts
argument_list|(
literal|"yy_cp = YY_G(yy_last_accepting_cpos);"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = YY_G(yy_last_accepting_state);"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"goto yy_find_action;"
argument_list|)
expr_stmt|;
name|outc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|set_indent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** mkctbl - make full speed compressed transition table  * This is an array of structs; each struct a pair of integers.  * You should call mkssltbl() immediately after this.  * Then, I think, mkecstbl(). Arrrg.  * @return the newly allocated trans table  */
end_comment

begin_function
specifier|static
name|struct
name|yytbl_data
modifier|*
name|mkctbl
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|yytbl_data
modifier|*
name|tbl
init|=
literal|0
decl_stmt|;
name|flex_int32_t
modifier|*
name|tdata
init|=
literal|0
decl_stmt|,
name|curr
init|=
literal|0
decl_stmt|;
name|int
name|end_of_buffer_action
init|=
name|num_rules
operator|+
literal|1
decl_stmt|;
name|buf_prints
argument_list|(
operator|&
name|yydmap_buf
argument_list|,
literal|"\t{YYTD_ID_TRANSITION, (void**)&yy_transition, sizeof(%s)},\n"
argument_list|,
operator|(
operator|(
name|tblend
operator|+
name|numecs
operator|+
literal|1
operator|)
operator|>=
name|INT16_MAX
operator|||
name|long_align
operator|)
condition|?
literal|"flex_int32_t"
else|:
literal|"flex_int16_t"
argument_list|)
expr_stmt|;
name|tbl
operator|=
operator|(
expr|struct
name|yytbl_data
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|yytbl_data
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_init
argument_list|(
name|tbl
argument_list|,
name|YYTD_ID_TRANSITION
argument_list|)
expr_stmt|;
name|tbl
operator|->
name|td_flags
operator|=
name|YYTD_DATA32
operator||
name|YYTD_STRUCT
expr_stmt|;
name|tbl
operator|->
name|td_hilen
operator|=
literal|0
expr_stmt|;
name|tbl
operator|->
name|td_lolen
operator|=
name|tblend
operator|+
name|numecs
operator|+
literal|1
expr_stmt|;
comment|/* number of structs */
name|tbl
operator|->
name|td_data
operator|=
name|tdata
operator|=
operator|(
name|flex_int32_t
operator|*
operator|)
name|calloc
argument_list|(
name|tbl
operator|->
name|td_lolen
operator|*
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|flex_int32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We want the transition to be represented as the offset to the 	 * next state, not the actual state number, which is what it currently 	 * is.  The offset is base[nxt[i]] - (base of current state)].  That's 	 * just the difference between the starting points of the two involved 	 * states (to - from). 	 * 	 * First, though, we need to find some way to put in our end-of-buffer 	 * flags and states.  We do this by making a state with absolutely no 	 * transitions.  We put it at the end of the table. 	 */
comment|/* We need to have room in nxt/chk for two more slots: One for the 	 * action and one for the end-of-buffer transition.  We now *assume* 	 * that we're guaranteed the only character we'll try to index this 	 * nxt/chk pair with is EOB, i.e., 0, so we don't have to make sure 	 * there's room for jam entries for other characters. 	 */
while|while
condition|(
name|tblend
operator|+
literal|2
operator|>=
name|current_max_xpairs
condition|)
name|expand_nxt_chk
argument_list|()
expr_stmt|;
while|while
condition|(
name|lastdfa
operator|+
literal|1
operator|>=
name|current_max_dfas
condition|)
name|increase_max_dfas
argument_list|()
expr_stmt|;
name|base
index|[
name|lastdfa
operator|+
literal|1
index|]
operator|=
name|tblend
operator|+
literal|2
expr_stmt|;
name|nxt
index|[
name|tblend
operator|+
literal|1
index|]
operator|=
name|end_of_buffer_action
expr_stmt|;
name|chk
index|[
name|tblend
operator|+
literal|1
index|]
operator|=
name|numecs
operator|+
literal|1
expr_stmt|;
name|chk
index|[
name|tblend
operator|+
literal|2
index|]
operator|=
literal|1
expr_stmt|;
comment|/* anything but EOB */
comment|/* So that "make test" won't show arb. differences. */
name|nxt
index|[
name|tblend
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Make sure every state has an end-of-buffer transition and an 	 * action #. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
name|int
name|anum
init|=
name|dfaacc
index|[
name|i
index|]
operator|.
name|dfaacc_state
decl_stmt|;
name|int
name|offset
init|=
name|base
index|[
name|i
index|]
decl_stmt|;
name|chk
index|[
name|offset
index|]
operator|=
name|EOB_POSITION
expr_stmt|;
name|chk
index|[
name|offset
operator|-
literal|1
index|]
operator|=
name|ACTION_POSITION
expr_stmt|;
name|nxt
index|[
name|offset
operator|-
literal|1
index|]
operator|=
name|anum
expr_stmt|;
comment|/* action number */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|tblend
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|chk
index|[
name|i
index|]
operator|==
name|EOB_POSITION
condition|)
block|{
name|tdata
index|[
name|curr
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|tdata
index|[
name|curr
operator|++
index|]
operator|=
name|base
index|[
name|lastdfa
operator|+
literal|1
index|]
operator|-
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chk
index|[
name|i
index|]
operator|==
name|ACTION_POSITION
condition|)
block|{
name|tdata
index|[
name|curr
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|tdata
index|[
name|curr
operator|++
index|]
operator|=
name|nxt
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chk
index|[
name|i
index|]
operator|>
name|numecs
operator|||
name|chk
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|tdata
index|[
name|curr
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|tdata
index|[
name|curr
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* verify, transition */
name|tdata
index|[
name|curr
operator|++
index|]
operator|=
name|chk
index|[
name|i
index|]
expr_stmt|;
name|tdata
index|[
name|curr
operator|++
index|]
operator|=
name|base
index|[
name|nxt
index|[
name|i
index|]
index|]
operator|-
operator|(
name|i
operator|-
name|chk
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
block|}
comment|/* Here's the final, end-of-buffer state. */
name|tdata
index|[
name|curr
operator|++
index|]
operator|=
name|chk
index|[
name|tblend
operator|+
literal|1
index|]
expr_stmt|;
name|tdata
index|[
name|curr
operator|++
index|]
operator|=
name|nxt
index|[
name|tblend
operator|+
literal|1
index|]
expr_stmt|;
name|tdata
index|[
name|curr
operator|++
index|]
operator|=
name|chk
index|[
name|tblend
operator|+
literal|2
index|]
expr_stmt|;
name|tdata
index|[
name|curr
operator|++
index|]
operator|=
name|nxt
index|[
name|tblend
operator|+
literal|2
index|]
expr_stmt|;
return|return
name|tbl
return|;
block|}
end_function

begin_comment
comment|/** Make start_state_list table.  *  @return the newly allocated start_state_list table  */
end_comment

begin_function
specifier|static
name|struct
name|yytbl_data
modifier|*
name|mkssltbl
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|yytbl_data
modifier|*
name|tbl
init|=
literal|0
decl_stmt|;
name|flex_int32_t
modifier|*
name|tdata
init|=
literal|0
decl_stmt|;
name|flex_int32_t
name|i
decl_stmt|;
name|tbl
operator|=
operator|(
expr|struct
name|yytbl_data
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|yytbl_data
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_init
argument_list|(
name|tbl
argument_list|,
name|YYTD_ID_START_STATE_LIST
argument_list|)
expr_stmt|;
name|tbl
operator|->
name|td_flags
operator|=
name|YYTD_DATA32
operator||
name|YYTD_PTRANS
expr_stmt|;
name|tbl
operator|->
name|td_hilen
operator|=
literal|0
expr_stmt|;
name|tbl
operator|->
name|td_lolen
operator|=
name|lastsc
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|tbl
operator|->
name|td_data
operator|=
name|tdata
operator|=
operator|(
name|flex_int32_t
operator|*
operator|)
name|calloc
argument_list|(
name|tbl
operator|->
name|td_lolen
argument_list|,
sizeof|sizeof
argument_list|(
name|flex_int32_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|lastsc
operator|*
literal|2
condition|;
operator|++
name|i
control|)
name|tdata
index|[
name|i
index|]
operator|=
name|base
index|[
name|i
index|]
expr_stmt|;
name|buf_prints
argument_list|(
operator|&
name|yydmap_buf
argument_list|,
literal|"\t{YYTD_ID_START_STATE_LIST, (void**)&yy_start_state_list, sizeof(%s)},\n"
argument_list|,
literal|"struct yy_trans_info*"
argument_list|)
expr_stmt|;
return|return
name|tbl
return|;
block|}
end_function

begin_comment
comment|/* genctbl - generates full speed compressed transition table */
end_comment

begin_function
name|void
name|genctbl
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|end_of_buffer_action
init|=
name|num_rules
operator|+
literal|1
decl_stmt|;
comment|/* Table of verify for transition and offset to next state. */
if|if
condition|(
name|gentables
condition|)
name|out_dec
argument_list|(
literal|"static yyconst struct yy_trans_info yy_transition[%d] =\n    {\n"
argument_list|,
name|tblend
operator|+
name|numecs
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|outn
argument_list|(
literal|"static yyconst struct yy_trans_info *yy_transition = 0;"
argument_list|)
expr_stmt|;
comment|/* We want the transition to be represented as the offset to the 	 * next state, not the actual state number, which is what it currently 	 * is.  The offset is base[nxt[i]] - (base of current state)].  That's 	 * just the difference between the starting points of the two involved 	 * states (to - from). 	 * 	 * First, though, we need to find some way to put in our end-of-buffer 	 * flags and states.  We do this by making a state with absolutely no 	 * transitions.  We put it at the end of the table. 	 */
comment|/* We need to have room in nxt/chk for two more slots: One for the 	 * action and one for the end-of-buffer transition.  We now *assume* 	 * that we're guaranteed the only character we'll try to index this 	 * nxt/chk pair with is EOB, i.e., 0, so we don't have to make sure 	 * there's room for jam entries for other characters. 	 */
while|while
condition|(
name|tblend
operator|+
literal|2
operator|>=
name|current_max_xpairs
condition|)
name|expand_nxt_chk
argument_list|()
expr_stmt|;
while|while
condition|(
name|lastdfa
operator|+
literal|1
operator|>=
name|current_max_dfas
condition|)
name|increase_max_dfas
argument_list|()
expr_stmt|;
name|base
index|[
name|lastdfa
operator|+
literal|1
index|]
operator|=
name|tblend
operator|+
literal|2
expr_stmt|;
name|nxt
index|[
name|tblend
operator|+
literal|1
index|]
operator|=
name|end_of_buffer_action
expr_stmt|;
name|chk
index|[
name|tblend
operator|+
literal|1
index|]
operator|=
name|numecs
operator|+
literal|1
expr_stmt|;
name|chk
index|[
name|tblend
operator|+
literal|2
index|]
operator|=
literal|1
expr_stmt|;
comment|/* anything but EOB */
comment|/* So that "make test" won't show arb. differences. */
name|nxt
index|[
name|tblend
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Make sure every state has an end-of-buffer transition and an 	 * action #. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
name|int
name|anum
init|=
name|dfaacc
index|[
name|i
index|]
operator|.
name|dfaacc_state
decl_stmt|;
name|int
name|offset
init|=
name|base
index|[
name|i
index|]
decl_stmt|;
name|chk
index|[
name|offset
index|]
operator|=
name|EOB_POSITION
expr_stmt|;
name|chk
index|[
name|offset
operator|-
literal|1
index|]
operator|=
name|ACTION_POSITION
expr_stmt|;
name|nxt
index|[
name|offset
operator|-
literal|1
index|]
operator|=
name|anum
expr_stmt|;
comment|/* action number */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|tblend
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|chk
index|[
name|i
index|]
operator|==
name|EOB_POSITION
condition|)
name|transition_struct_out
argument_list|(
literal|0
argument_list|,
name|base
index|[
name|lastdfa
operator|+
literal|1
index|]
operator|-
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chk
index|[
name|i
index|]
operator|==
name|ACTION_POSITION
condition|)
name|transition_struct_out
argument_list|(
literal|0
argument_list|,
name|nxt
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chk
index|[
name|i
index|]
operator|>
name|numecs
operator|||
name|chk
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|transition_struct_out
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unused slot */
else|else
comment|/* verify, transition */
name|transition_struct_out
argument_list|(
name|chk
index|[
name|i
index|]
argument_list|,
name|base
index|[
name|nxt
index|[
name|i
index|]
index|]
operator|-
operator|(
name|i
operator|-
name|chk
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Here's the final, end-of-buffer state. */
name|transition_struct_out
argument_list|(
name|chk
index|[
name|tblend
operator|+
literal|1
index|]
argument_list|,
name|nxt
index|[
name|tblend
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|transition_struct_out
argument_list|(
name|chk
index|[
name|tblend
operator|+
literal|2
index|]
argument_list|,
name|nxt
index|[
name|tblend
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|gentables
condition|)
name|outn
argument_list|(
literal|"    };\n"
argument_list|)
expr_stmt|;
comment|/* Table of pointers to start states. */
if|if
condition|(
name|gentables
condition|)
name|out_dec
argument_list|(
literal|"static yyconst struct yy_trans_info *yy_start_state_list[%d] =\n"
argument_list|,
name|lastsc
operator|*
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|outn
argument_list|(
literal|"static yyconst struct yy_trans_info **yy_start_state_list =0;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gentables
condition|)
block|{
name|outn
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|lastsc
operator|*
literal|2
condition|;
operator|++
name|i
control|)
name|out_dec
argument_list|(
literal|"&yy_transition[%d],\n"
argument_list|,
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dataend
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|useecs
condition|)
name|genecs
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* mkecstbl - Make equivalence-class tables.  */
end_comment

begin_function
specifier|static
name|struct
name|yytbl_data
modifier|*
name|mkecstbl
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|yytbl_data
modifier|*
name|tbl
init|=
literal|0
decl_stmt|;
name|flex_int32_t
modifier|*
name|tdata
init|=
literal|0
decl_stmt|;
name|tbl
operator|=
operator|(
expr|struct
name|yytbl_data
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|yytbl_data
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_init
argument_list|(
name|tbl
argument_list|,
name|YYTD_ID_EC
argument_list|)
expr_stmt|;
name|tbl
operator|->
name|td_flags
operator||=
name|YYTD_DATA32
expr_stmt|;
name|tbl
operator|->
name|td_hilen
operator|=
literal|0
expr_stmt|;
name|tbl
operator|->
name|td_lolen
operator|=
name|csize
expr_stmt|;
name|tbl
operator|->
name|td_data
operator|=
name|tdata
operator|=
operator|(
name|flex_int32_t
operator|*
operator|)
name|calloc
argument_list|(
name|tbl
operator|->
name|td_lolen
argument_list|,
sizeof|sizeof
argument_list|(
name|flex_int32_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|csize
condition|;
operator|++
name|i
control|)
block|{
name|ecgroup
index|[
name|i
index|]
operator|=
name|ABS
argument_list|(
name|ecgroup
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tdata
index|[
name|i
index|]
operator|=
name|ecgroup
index|[
name|i
index|]
expr_stmt|;
block|}
name|buf_prints
argument_list|(
operator|&
name|yydmap_buf
argument_list|,
literal|"\t{YYTD_ID_EC, (void**)&yy_ec, sizeof(%s)},\n"
argument_list|,
literal|"flex_int32_t"
argument_list|)
expr_stmt|;
return|return
name|tbl
return|;
block|}
end_function

begin_comment
comment|/* Generate equivalence-class tables. */
end_comment

begin_function
name|void
name|genecs
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|numrows
decl_stmt|;
name|out_str_dec
argument_list|(
name|get_int32_decl
argument_list|()
argument_list|,
literal|"yy_ec"
argument_list|,
name|csize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|csize
condition|;
operator|++
name|i
control|)
block|{
name|ecgroup
index|[
name|i
index|]
operator|=
name|ABS
argument_list|(
name|ecgroup
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mkdata
argument_list|(
name|ecgroup
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\n\nEquivalence Classes:\n\n"
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|numrows
operator|=
name|csize
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numrows
condition|;
operator|++
name|j
control|)
block|{
for|for
control|(
name|i
operator|=
name|j
init|;
name|i
operator|<
name|csize
condition|;
name|i
operator|=
name|i
operator|+
name|numrows
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%4s = %-2d"
argument_list|,
name|readable_form
argument_list|(
name|i
argument_list|)
argument_list|,
name|ecgroup
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate the code to find the action number. */
end_comment

begin_function
name|void
name|gen_find_action
parameter_list|()
block|{
if|if
condition|(
name|fullspd
condition|)
name|indent_puts
argument_list|(
literal|"yy_act = yy_current_state[-1].yy_nxt;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fulltbl
condition|)
name|indent_puts
argument_list|(
literal|"yy_act = yy_accept[yy_current_state];"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reject
condition|)
block|{
name|indent_puts
argument_list|(
literal|"yy_current_state = *--YY_G(yy_state_ptr);"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_G(yy_lp) = yy_accept[yy_current_state];"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"goto find_rule; /* avoid `defined but not used' warning */"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"find_rule: /* we branch to this label when backing up */"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"for ( ; ; ) /* until we find what rule we matched */"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( YY_G(yy_lp)&& YY_G(yy_lp)< yy_accept[yy_current_state + 1] )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_act = yy_acclist[YY_G(yy_lp)];"
argument_list|)
expr_stmt|;
if|if
condition|(
name|variable_trailing_context_rules
condition|)
block|{
name|indent_puts
argument_list|(
literal|"if ( yy_act& YY_TRAILING_HEAD_MASK ||"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"     YY_G(yy_looking_for_trail_begin) )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( yy_act == YY_G(yy_looking_for_trail_begin) )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_G(yy_looking_for_trail_begin) = 0;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_act&= ~YY_TRAILING_HEAD_MASK;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"break;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"else if ( yy_act& YY_TRAILING_MASK )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_G(yy_looking_for_trail_begin) = yy_act& ~YY_TRAILING_MASK;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_G(yy_looking_for_trail_begin) |= YY_TRAILING_HEAD_MASK;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_reject
condition|)
block|{
comment|/* Remember matched text in case we back up 				 * due to REJECT. 				 */
name|indent_puts
argument_list|(
literal|"YY_G(yy_full_match) = yy_cp;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_G(yy_full_state) = YY_G(yy_state_ptr);"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_G(yy_full_lp) = YY_G(yy_lp);"
argument_list|)
expr_stmt|;
block|}
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"else"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_G(yy_full_match) = yy_cp;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_G(yy_full_state) = YY_G(yy_state_ptr);"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_G(yy_full_lp) = YY_G(yy_lp);"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"break;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"++YY_G(yy_lp);"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"goto find_rule;"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Remember matched text in case we back up due to 			 * trailing context plus REJECT. 			 */
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_G(yy_full_match) = yy_cp;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"break;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"--yy_cp;"
argument_list|)
expr_stmt|;
comment|/* We could consolidate the following two lines with those at 		 * the beginning, but at the cost of complaints that we're 		 * branching inside a loop. 		 */
name|indent_puts
argument_list|(
literal|"yy_current_state = *--YY_G(yy_state_ptr);"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_G(yy_lp) = yy_accept[yy_current_state];"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* compressed */
name|indent_puts
argument_list|(
literal|"yy_act = yy_accept[yy_current_state];"
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive
operator|&&
operator|!
name|reject
condition|)
block|{
comment|/* Do the guaranteed-needed backing up to figure out 			 * the match. 			 */
name|indent_puts
argument_list|(
literal|"if ( yy_act == 0 )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{ /* have to back up */"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_cp = YY_G(yy_last_accepting_cpos);"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = YY_G(yy_last_accepting_state);"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_act = yy_accept[yy_current_state];"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* mkftbl - make the full table and return the struct .  * you should call mkecstbl() after this.  */
end_comment

begin_function
name|struct
name|yytbl_data
modifier|*
name|mkftbl
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|end_of_buffer_action
init|=
name|num_rules
operator|+
literal|1
decl_stmt|;
name|struct
name|yytbl_data
modifier|*
name|tbl
decl_stmt|;
name|flex_int32_t
modifier|*
name|tdata
init|=
literal|0
decl_stmt|;
name|tbl
operator|=
operator|(
expr|struct
name|yytbl_data
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|yytbl_data
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_init
argument_list|(
name|tbl
argument_list|,
name|YYTD_ID_ACCEPT
argument_list|)
expr_stmt|;
name|tbl
operator|->
name|td_flags
operator||=
name|YYTD_DATA32
expr_stmt|;
name|tbl
operator|->
name|td_hilen
operator|=
literal|0
expr_stmt|;
comment|/* it's a one-dimensional array */
name|tbl
operator|->
name|td_lolen
operator|=
name|lastdfa
operator|+
literal|1
expr_stmt|;
name|tbl
operator|->
name|td_data
operator|=
name|tdata
operator|=
operator|(
name|flex_int32_t
operator|*
operator|)
name|calloc
argument_list|(
name|tbl
operator|->
name|td_lolen
argument_list|,
sizeof|sizeof
argument_list|(
name|flex_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|dfaacc
index|[
name|end_of_buffer_state
index|]
operator|.
name|dfaacc_state
operator|=
name|end_of_buffer_action
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
name|int
name|anum
init|=
name|dfaacc
index|[
name|i
index|]
operator|.
name|dfaacc_state
decl_stmt|;
name|tdata
index|[
name|i
index|]
operator|=
name|anum
expr_stmt|;
if|if
condition|(
name|trace
operator|&&
name|anum
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"state # %d accepts: [%d]\n"
argument_list|)
argument_list|,
name|i
argument_list|,
name|anum
argument_list|)
expr_stmt|;
block|}
name|buf_prints
argument_list|(
operator|&
name|yydmap_buf
argument_list|,
literal|"\t{YYTD_ID_ACCEPT, (void**)&yy_accept, sizeof(%s)},\n"
argument_list|,
name|long_align
condition|?
literal|"flex_int32_t"
else|:
literal|"flex_int16_t"
argument_list|)
expr_stmt|;
return|return
name|tbl
return|;
block|}
end_function

begin_comment
comment|/* genftbl - generate full transition table */
end_comment

begin_function
name|void
name|genftbl
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|end_of_buffer_action
init|=
name|num_rules
operator|+
literal|1
decl_stmt|;
name|out_str_dec
argument_list|(
name|long_align
condition|?
name|get_int32_decl
argument_list|()
else|:
name|get_int16_decl
argument_list|()
argument_list|,
literal|"yy_accept"
argument_list|,
name|lastdfa
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dfaacc
index|[
name|end_of_buffer_state
index|]
operator|.
name|dfaacc_state
operator|=
name|end_of_buffer_action
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
name|int
name|anum
init|=
name|dfaacc
index|[
name|i
index|]
operator|.
name|dfaacc_state
decl_stmt|;
name|mkdata
argument_list|(
name|anum
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
operator|&&
name|anum
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"state # %d accepts: [%d]\n"
argument_list|)
argument_list|,
name|i
argument_list|,
name|anum
argument_list|)
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
name|genecs
argument_list|()
expr_stmt|;
comment|/* Don't have to dump the actual full table entries - they were 	 * created on-the-fly. 	 */
block|}
end_function

begin_comment
comment|/* Generate the code to find the next compressed-table state. */
end_comment

begin_function
name|void
name|gen_next_compressed_state
parameter_list|(
name|char_map
parameter_list|)
name|char
modifier|*
name|char_map
decl_stmt|;
block|{
name|indent_put2s
argument_list|(
literal|"YY_CHAR yy_c = %s;"
argument_list|,
name|char_map
argument_list|)
expr_stmt|;
comment|/* Save the backing-up info \before/ computing the next state 	 * because we always compute one more state than needed - we 	 * always proceed until we reach a jam state 	 */
name|gen_backing_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = (int) yy_def[yy_current_state];"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usemecs
condition|)
block|{
comment|/* We've arrange it so that templates are never chained 		 * to one another.  This means we can afford to make a 		 * very simple test to see if we need to convert to 		 * yy_c's meta-equivalence class without worrying 		 * about erroneously looking up the meta-equivalence 		 * class twice 		 */
name|do_indent
argument_list|()
expr_stmt|;
comment|/* lastdfa + 2 is the beginning of the templates */
name|out_dec
argument_list|(
literal|"if ( yy_current_state>= %d )\n"
argument_list|,
name|lastdfa
operator|+
literal|2
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_c = yy_meta[(unsigned int) yy_c];"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the code to find the next match. */
end_comment

begin_function
name|void
name|gen_next_match
parameter_list|()
block|{
comment|/* NOTE - changes in here should be reflected in gen_next_state() and 	 * gen_NUL_trans(). 	 */
name|char
modifier|*
name|char_map
init|=
name|useecs
condition|?
literal|"yy_ec[YY_SC_TO_UI(*yy_cp)] "
else|:
literal|"YY_SC_TO_UI(*yy_cp)"
decl_stmt|;
name|char
modifier|*
name|char_map_2
init|=
name|useecs
condition|?
literal|"yy_ec[YY_SC_TO_UI(*++yy_cp)] "
else|:
literal|"YY_SC_TO_UI(*++yy_cp)"
decl_stmt|;
if|if
condition|(
name|fulltbl
condition|)
block|{
if|if
condition|(
name|gentables
condition|)
name|indent_put2s
argument_list|(
literal|"while ( (yy_current_state = yy_nxt[yy_current_state][ %s ])> 0 )"
argument_list|,
name|char_map
argument_list|)
expr_stmt|;
else|else
name|indent_put2s
argument_list|(
literal|"while ( (yy_current_state = yy_nxt[yy_current_state*YY_NXT_LOLEN +  %s ])> 0 )"
argument_list|,
name|char_map
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_backing_up
operator|>
literal|0
condition|)
block|{
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|gen_backing_up
argument_list|()
expr_stmt|;
name|outc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|indent_puts
argument_list|(
literal|"++yy_cp;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_backing_up
operator|>
literal|0
condition|)
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|outc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = -yy_current_state;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fullspd
condition|)
block|{
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yyconst struct yy_trans_info *yy_trans_info;\n"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_CHAR yy_c;\n"
argument_list|)
expr_stmt|;
name|indent_put2s
argument_list|(
literal|"for ( yy_c = %s;"
argument_list|,
name|char_map
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"      (yy_trans_info =&yy_current_state[(unsigned int) yy_c])->"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_verify == yy_c;"
argument_list|)
expr_stmt|;
name|indent_put2s
argument_list|(
literal|"      yy_c = %s )"
argument_list|,
name|char_map_2
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_backing_up
operator|>
literal|0
condition|)
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state += yy_trans_info->yy_nxt;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_backing_up
operator|>
literal|0
condition|)
block|{
name|outc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|gen_backing_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* compressed */
name|indent_puts
argument_list|(
literal|"do"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|gen_next_state
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"++yy_cp;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|do_indent
argument_list|()
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
name|out_dec
argument_list|(
literal|"while ( yy_base[yy_current_state] != %d );\n"
argument_list|,
name|jambase
argument_list|)
expr_stmt|;
else|else
name|out_dec
argument_list|(
literal|"while ( yy_current_state != %d );\n"
argument_list|,
name|jamstate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reject
operator|&&
operator|!
name|interactive
condition|)
block|{
comment|/* Do the guaranteed-needed backing up to figure out 			 * the match. 			 */
name|indent_puts
argument_list|(
literal|"yy_cp = YY_G(yy_last_accepting_cpos);"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = YY_G(yy_last_accepting_state);"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate the code to find the next state. */
end_comment

begin_function
name|void
name|gen_next_state
parameter_list|(
name|worry_about_NULs
parameter_list|)
name|int
name|worry_about_NULs
decl_stmt|;
block|{
comment|/* NOTE - changes in here should be reflected in gen_next_match() */
name|char
name|char_map
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|worry_about_NULs
operator|&&
operator|!
name|nultrans
condition|)
block|{
if|if
condition|(
name|useecs
condition|)
name|snprintf
argument_list|(
name|char_map
argument_list|,
sizeof|sizeof
argument_list|(
name|char_map
argument_list|)
argument_list|,
literal|"(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : %d)"
argument_list|,
name|NUL_ec
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|char_map
argument_list|,
sizeof|sizeof
argument_list|(
name|char_map
argument_list|)
argument_list|,
literal|"(*yy_cp ? YY_SC_TO_UI(*yy_cp) : %d)"
argument_list|,
name|NUL_ec
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|char_map
argument_list|,
name|useecs
condition|?
literal|"yy_ec[YY_SC_TO_UI(*yy_cp)] "
else|:
literal|"YY_SC_TO_UI(*yy_cp)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|worry_about_NULs
operator|&&
name|nultrans
condition|)
block|{
if|if
condition|(
operator|!
name|fulltbl
operator|&&
operator|!
name|fullspd
condition|)
comment|/* Compressed tables back up *before* they match. */
name|gen_backing_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( *yy_cp )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fulltbl
condition|)
block|{
if|if
condition|(
name|gentables
condition|)
name|indent_put2s
argument_list|(
literal|"yy_current_state = yy_nxt[yy_current_state][%s];"
argument_list|,
name|char_map
argument_list|)
expr_stmt|;
else|else
name|indent_put2s
argument_list|(
literal|"yy_current_state = yy_nxt[yy_current_state*YY_NXT_LOLEN + %s];"
argument_list|,
name|char_map
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fullspd
condition|)
name|indent_put2s
argument_list|(
literal|"yy_current_state += yy_current_state[%s].yy_nxt;"
argument_list|,
name|char_map
argument_list|)
expr_stmt|;
else|else
name|gen_next_compressed_state
argument_list|(
name|char_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|worry_about_NULs
operator|&&
name|nultrans
condition|)
block|{
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"else"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_NUL_trans[yy_current_state];"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fullspd
operator|||
name|fulltbl
condition|)
name|gen_backing_up
argument_list|()
expr_stmt|;
if|if
condition|(
name|reject
condition|)
name|indent_puts
argument_list|(
literal|"*YY_G(yy_state_ptr)++ = yy_current_state;"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the code to make a NUL transition. */
end_comment

begin_function
name|void
name|gen_NUL_trans
parameter_list|()
block|{
comment|/* NOTE - changes in here should be reflected in gen_next_match() */
comment|/* Only generate a definition for "yy_cp" if we'll generate code 	 * that uses it.  Otherwise lint and the like complain. 	 */
name|int
name|need_backing_up
init|=
operator|(
name|num_backing_up
operator|>
literal|0
operator|&&
operator|!
name|reject
operator|)
decl_stmt|;
if|if
condition|(
name|need_backing_up
operator|&&
operator|(
operator|!
name|nultrans
operator|||
name|fullspd
operator|||
name|fulltbl
operator|)
condition|)
comment|/* We're going to need yy_cp lying around for the call 		 * below to gen_backing_up(). 		 */
name|indent_puts
argument_list|(
literal|"char *yy_cp = YY_G(yy_c_buf_p);"
argument_list|)
expr_stmt|;
name|outc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nultrans
condition|)
block|{
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_NUL_trans[yy_current_state];"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_is_jam = (yy_current_state == 0);"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fulltbl
condition|)
block|{
name|do_indent
argument_list|()
expr_stmt|;
if|if
condition|(
name|gentables
condition|)
name|out_dec
argument_list|(
literal|"yy_current_state = yy_nxt[yy_current_state][%d];\n"
argument_list|,
name|NUL_ec
argument_list|)
expr_stmt|;
else|else
name|out_dec
argument_list|(
literal|"yy_current_state = yy_nxt[yy_current_state*YY_NXT_LOLEN + %d];\n"
argument_list|,
name|NUL_ec
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_is_jam = (yy_current_state<= 0);"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fullspd
condition|)
block|{
name|do_indent
argument_list|()
expr_stmt|;
name|out_dec
argument_list|(
literal|"int yy_c = %d;\n"
argument_list|,
name|NUL_ec
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yyconst struct yy_trans_info *yy_trans_info;\n"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_trans_info =&yy_current_state[(unsigned int) yy_c];"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state += yy_trans_info->yy_nxt;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_is_jam = (yy_trans_info->yy_verify != yy_c);"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|NUL_ec_str
index|[
literal|20
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|NUL_ec_str
argument_list|,
sizeof|sizeof
argument_list|(
name|NUL_ec_str
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|NUL_ec
argument_list|)
expr_stmt|;
name|gen_next_compressed_state
argument_list|(
name|NUL_ec_str
argument_list|)
expr_stmt|;
name|do_indent
argument_list|()
expr_stmt|;
name|out_dec
argument_list|(
literal|"yy_is_jam = (yy_current_state == %d);\n"
argument_list|,
name|jamstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|reject
condition|)
block|{
comment|/* Only stack this state if it's a transition we 			 * actually make.  If we stack it on a jam, then 			 * the state stack and yy_c_buf_p get out of sync. 			 */
name|indent_puts
argument_list|(
literal|"if ( ! yy_is_jam )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"*YY_G(yy_state_ptr)++ = yy_current_state;"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If we've entered an accepting state, back up; note that 	 * compressed tables have *already* done such backing up, so 	 * we needn't bother with it again. 	 */
if|if
condition|(
name|need_backing_up
operator|&&
operator|(
name|fullspd
operator|||
name|fulltbl
operator|)
condition|)
block|{
name|outc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( ! yy_is_jam )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|gen_backing_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the code to find the start state. */
end_comment

begin_function
name|void
name|gen_start_state
parameter_list|()
block|{
if|if
condition|(
name|fullspd
condition|)
block|{
if|if
condition|(
name|bol_needed
condition|)
block|{
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_start_state_list[YY_G(yy_start) + YY_AT_BOL()];"
argument_list|)
expr_stmt|;
block|}
else|else
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_start_state_list[YY_G(yy_start)];"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indent_puts
argument_list|(
literal|"yy_current_state = YY_G(yy_start);"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bol_needed
condition|)
name|indent_puts
argument_list|(
literal|"yy_current_state += YY_AT_BOL();"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reject
condition|)
block|{
comment|/* Set up for storing up states. */
name|outn
argument_list|(
literal|"m4_ifdef( [[M4_YY_USES_REJECT]],\n[["
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_G(yy_state_ptr) = YY_G(yy_state_buf);"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"*YY_G(yy_state_ptr)++ = yy_current_state;"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"]])"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* gentabs - generate data statements for the transition tables */
end_comment

begin_function
name|void
name|gentabs
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
modifier|*
name|accset
decl_stmt|,
name|nacc
decl_stmt|,
modifier|*
name|acc_array
decl_stmt|,
name|total_states
decl_stmt|;
name|int
name|end_of_buffer_action
init|=
name|num_rules
operator|+
literal|1
decl_stmt|;
name|struct
name|yytbl_data
modifier|*
name|yyacc_tbl
init|=
literal|0
decl_stmt|,
modifier|*
name|yymeta_tbl
init|=
literal|0
decl_stmt|,
modifier|*
name|yybase_tbl
init|=
literal|0
decl_stmt|,
modifier|*
name|yydef_tbl
init|=
literal|0
decl_stmt|,
modifier|*
name|yynxt_tbl
init|=
literal|0
decl_stmt|,
modifier|*
name|yychk_tbl
init|=
literal|0
decl_stmt|,
modifier|*
name|yyacclist_tbl
init|=
literal|0
decl_stmt|;
name|flex_int32_t
modifier|*
name|yyacc_data
init|=
literal|0
decl_stmt|,
modifier|*
name|yybase_data
init|=
literal|0
decl_stmt|,
modifier|*
name|yydef_data
init|=
literal|0
decl_stmt|,
modifier|*
name|yynxt_data
init|=
literal|0
decl_stmt|,
modifier|*
name|yychk_data
init|=
literal|0
decl_stmt|,
modifier|*
name|yyacclist_data
init|=
literal|0
decl_stmt|;
name|flex_int32_t
name|yybase_curr
init|=
literal|0
decl_stmt|,
name|yyacclist_curr
init|=
literal|0
decl_stmt|,
name|yyacc_curr
init|=
literal|0
decl_stmt|;
name|acc_array
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|nummt
operator|=
literal|0
expr_stmt|;
comment|/* The compressed table format jams by entering the "jam state", 	 * losing information about the previous state in the process. 	 * In order to recover the previous state, we effectively need 	 * to keep backing-up information. 	 */
operator|++
name|num_backing_up
expr_stmt|;
if|if
condition|(
name|reject
condition|)
block|{
comment|/* Write out accepting list and pointer list.  		 * First we generate the "yy_acclist" array.  In the process, 		 * we compute the indices that will go into the "yy_accept" 		 * array, and save the indices in the dfaacc array. 		 */
name|int
name|EOB_accepting_list
index|[
literal|2
index|]
decl_stmt|;
comment|/* Set up accepting structures for the End Of Buffer state. */
name|EOB_accepting_list
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|EOB_accepting_list
index|[
literal|1
index|]
operator|=
name|end_of_buffer_action
expr_stmt|;
name|accsiz
index|[
name|end_of_buffer_state
index|]
operator|=
literal|1
expr_stmt|;
name|dfaacc
index|[
name|end_of_buffer_state
index|]
operator|.
name|dfaacc_set
operator|=
name|EOB_accepting_list
expr_stmt|;
name|out_str_dec
argument_list|(
name|long_align
condition|?
name|get_int32_decl
argument_list|()
else|:
name|get_int16_decl
argument_list|()
argument_list|,
literal|"yy_acclist"
argument_list|,
name|MAX
argument_list|(
name|numas
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf_prints
argument_list|(
operator|&
name|yydmap_buf
argument_list|,
literal|"\t{YYTD_ID_ACCLIST, (void**)&yy_acclist, sizeof(%s)},\n"
argument_list|,
name|long_align
condition|?
literal|"flex_int32_t"
else|:
literal|"flex_int16_t"
argument_list|)
expr_stmt|;
name|yyacclist_tbl
operator|=
operator|(
expr|struct
name|yytbl_data
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|yytbl_data
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_init
argument_list|(
name|yyacclist_tbl
argument_list|,
name|YYTD_ID_ACCLIST
argument_list|)
expr_stmt|;
name|yyacclist_tbl
operator|->
name|td_lolen
operator|=
name|MAX
argument_list|(
name|numas
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|yyacclist_tbl
operator|->
name|td_data
operator|=
name|yyacclist_data
operator|=
operator|(
name|flex_int32_t
operator|*
operator|)
name|calloc
argument_list|(
name|yyacclist_tbl
operator|->
name|td_lolen
argument_list|,
sizeof|sizeof
argument_list|(
name|flex_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|yyacclist_curr
operator|=
literal|1
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
comment|/* index into "yy_acclist" array */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
name|acc_array
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|accsiz
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|accset
operator|=
name|dfaacc
index|[
name|i
index|]
operator|.
name|dfaacc_set
expr_stmt|;
name|nacc
operator|=
name|accsiz
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"state # %d accepts: "
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
name|nacc
condition|;
operator|++
name|k
control|)
block|{
name|int
name|accnum
init|=
name|accset
index|[
name|k
index|]
decl_stmt|;
operator|++
name|j
expr_stmt|;
if|if
condition|(
name|variable_trailing_context_rules
operator|&&
operator|!
operator|(
name|accnum
operator|&
name|YY_TRAILING_HEAD_MASK
operator|)
operator|&&
name|accnum
operator|>
literal|0
operator|&&
name|accnum
operator|<=
name|num_rules
operator|&&
name|rule_type
index|[
name|accnum
index|]
operator|==
name|RULE_VARIABLE
condition|)
block|{
comment|/* Special hack to flag 						 * accepting number as part 						 * of trailing context rule. 						 */
name|accnum
operator||=
name|YY_TRAILING_MASK
expr_stmt|;
block|}
name|mkdata
argument_list|(
name|accnum
argument_list|)
expr_stmt|;
name|yyacclist_data
index|[
name|yyacclist_curr
operator|++
index|]
operator|=
name|accnum
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%d]"
argument_list|,
name|accset
index|[
name|k
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
name|nacc
condition|)
name|fputs
argument_list|(
literal|", "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* add accepting number for the "jam" state */
name|acc_array
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|dataend
argument_list|()
expr_stmt|;
if|if
condition|(
name|tablesext
condition|)
block|{
name|yytbl_data_compress
argument_list|(
name|yyacclist_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytbl_data_fwrite
argument_list|(
operator|&
name|tableswr
argument_list|,
name|yyacclist_tbl
argument_list|)
operator|<
literal|0
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Could not write yyacclist_tbl"
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_destroy
argument_list|(
name|yyacclist_tbl
argument_list|)
expr_stmt|;
name|yyacclist_tbl
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|dfaacc
index|[
name|end_of_buffer_state
index|]
operator|.
name|dfaacc_state
operator|=
name|end_of_buffer_action
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
name|acc_array
index|[
name|i
index|]
operator|=
name|dfaacc
index|[
name|i
index|]
operator|.
name|dfaacc_state
expr_stmt|;
comment|/* add accepting number for jam state */
name|acc_array
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Begin generating yy_accept */
comment|/* Spit out "yy_accept" array.  If we're doing "reject", it'll be 	 * pointers into the "yy_acclist" array.  Otherwise it's actual 	 * accepting numbers.  In either case, we just dump the numbers. 	 */
comment|/* "lastdfa + 2" is the size of "yy_accept"; includes room for C arrays 	 * beginning at 0 and for "jam" state. 	 */
name|k
operator|=
name|lastdfa
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|reject
condition|)
comment|/* We put a "cap" on the table associating lists of accepting 		 * numbers with state numbers.  This is needed because we tell 		 * where the end of an accepting list is by looking at where 		 * the list for the next state starts. 		 */
operator|++
name|k
expr_stmt|;
name|out_str_dec
argument_list|(
name|long_align
condition|?
name|get_int32_decl
argument_list|()
else|:
name|get_int16_decl
argument_list|()
argument_list|,
literal|"yy_accept"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|buf_prints
argument_list|(
operator|&
name|yydmap_buf
argument_list|,
literal|"\t{YYTD_ID_ACCEPT, (void**)&yy_accept, sizeof(%s)},\n"
argument_list|,
name|long_align
condition|?
literal|"flex_int32_t"
else|:
literal|"flex_int16_t"
argument_list|)
expr_stmt|;
name|yyacc_tbl
operator|=
operator|(
expr|struct
name|yytbl_data
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|yytbl_data
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_init
argument_list|(
name|yyacc_tbl
argument_list|,
name|YYTD_ID_ACCEPT
argument_list|)
expr_stmt|;
name|yyacc_tbl
operator|->
name|td_lolen
operator|=
name|k
expr_stmt|;
name|yyacc_tbl
operator|->
name|td_data
operator|=
name|yyacc_data
operator|=
operator|(
name|flex_int32_t
operator|*
operator|)
name|calloc
argument_list|(
name|yyacc_tbl
operator|->
name|td_lolen
argument_list|,
sizeof|sizeof
argument_list|(
name|flex_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|yyacc_curr
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
name|mkdata
argument_list|(
name|acc_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|yyacc_data
index|[
name|yyacc_curr
operator|++
index|]
operator|=
name|acc_array
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|reject
operator|&&
name|trace
operator|&&
name|acc_array
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"state # %d accepts: [%d]\n"
argument_list|)
argument_list|,
name|i
argument_list|,
name|acc_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Add entry for "jam" state. */
name|mkdata
argument_list|(
name|acc_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|yyacc_data
index|[
name|yyacc_curr
operator|++
index|]
operator|=
name|acc_array
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|reject
condition|)
block|{
comment|/* Add "cap" for the list. */
name|mkdata
argument_list|(
name|acc_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|yyacc_data
index|[
name|yyacc_curr
operator|++
index|]
operator|=
name|acc_array
index|[
name|i
index|]
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
if|if
condition|(
name|tablesext
condition|)
block|{
name|yytbl_data_compress
argument_list|(
name|yyacc_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytbl_data_fwrite
argument_list|(
operator|&
name|tableswr
argument_list|,
name|yyacc_tbl
argument_list|)
operator|<
literal|0
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Could not write yyacc_tbl"
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_destroy
argument_list|(
name|yyacc_tbl
argument_list|)
expr_stmt|;
name|yyacc_tbl
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* End generating yy_accept */
if|if
condition|(
name|useecs
condition|)
block|{
name|genecs
argument_list|()
expr_stmt|;
if|if
condition|(
name|tablesext
condition|)
block|{
name|struct
name|yytbl_data
modifier|*
name|tbl
decl_stmt|;
name|tbl
operator|=
name|mkecstbl
argument_list|()
expr_stmt|;
name|yytbl_data_compress
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytbl_data_fwrite
argument_list|(
operator|&
name|tableswr
argument_list|,
name|tbl
argument_list|)
operator|<
literal|0
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Could not write ecstbl"
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_destroy
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
name|tbl
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|usemecs
condition|)
block|{
comment|/* Begin generating yy_meta */
comment|/* Write out meta-equivalence classes (used to index 		 * templates with). 		 */
name|flex_int32_t
modifier|*
name|yymecs_data
init|=
literal|0
decl_stmt|;
name|yymeta_tbl
operator|=
operator|(
expr|struct
name|yytbl_data
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|yytbl_data
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_init
argument_list|(
name|yymeta_tbl
argument_list|,
name|YYTD_ID_META
argument_list|)
expr_stmt|;
name|yymeta_tbl
operator|->
name|td_lolen
operator|=
name|numecs
operator|+
literal|1
expr_stmt|;
name|yymeta_tbl
operator|->
name|td_data
operator|=
name|yymecs_data
operator|=
operator|(
name|flex_int32_t
operator|*
operator|)
name|calloc
argument_list|(
name|yymeta_tbl
operator|->
name|td_lolen
argument_list|,
sizeof|sizeof
argument_list|(
name|flex_int32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\n\nMeta-Equivalence Classes:\n"
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|out_str_dec
argument_list|(
name|get_int32_decl
argument_list|()
argument_list|,
literal|"yy_meta"
argument_list|,
name|numecs
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf_prints
argument_list|(
operator|&
name|yydmap_buf
argument_list|,
literal|"\t{YYTD_ID_META, (void**)&yy_meta, sizeof(%s)},\n"
argument_list|,
literal|"flex_int32_t"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|numecs
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d = %d\n"
argument_list|,
name|i
argument_list|,
name|ABS
argument_list|(
name|tecbck
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|mkdata
argument_list|(
name|ABS
argument_list|(
name|tecbck
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|yymecs_data
index|[
name|i
index|]
operator|=
name|ABS
argument_list|(
name|tecbck
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
if|if
condition|(
name|tablesext
condition|)
block|{
name|yytbl_data_compress
argument_list|(
name|yymeta_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytbl_data_fwrite
argument_list|(
operator|&
name|tableswr
argument_list|,
name|yymeta_tbl
argument_list|)
operator|<
literal|0
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Could not write yymeta_tbl"
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_destroy
argument_list|(
name|yymeta_tbl
argument_list|)
expr_stmt|;
name|yymeta_tbl
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* End generating yy_meta */
block|}
name|total_states
operator|=
name|lastdfa
operator|+
name|numtemps
expr_stmt|;
comment|/* Begin generating yy_base */
name|out_str_dec
argument_list|(
operator|(
name|tblend
operator|>=
name|INT16_MAX
operator|||
name|long_align
operator|)
condition|?
name|get_int32_decl
argument_list|()
else|:
name|get_int16_decl
argument_list|()
argument_list|,
literal|"yy_base"
argument_list|,
name|total_states
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf_prints
argument_list|(
operator|&
name|yydmap_buf
argument_list|,
literal|"\t{YYTD_ID_BASE, (void**)&yy_base, sizeof(%s)},\n"
argument_list|,
operator|(
name|tblend
operator|>=
name|INT16_MAX
operator|||
name|long_align
operator|)
condition|?
literal|"flex_int32_t"
else|:
literal|"flex_int16_t"
argument_list|)
expr_stmt|;
name|yybase_tbl
operator|=
operator|(
expr|struct
name|yytbl_data
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|yytbl_data
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_init
argument_list|(
name|yybase_tbl
argument_list|,
name|YYTD_ID_BASE
argument_list|)
expr_stmt|;
name|yybase_tbl
operator|->
name|td_lolen
operator|=
name|total_states
operator|+
literal|1
expr_stmt|;
name|yybase_tbl
operator|->
name|td_data
operator|=
name|yybase_data
operator|=
operator|(
name|flex_int32_t
operator|*
operator|)
name|calloc
argument_list|(
name|yybase_tbl
operator|->
name|td_lolen
argument_list|,
sizeof|sizeof
argument_list|(
name|flex_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|yybase_curr
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
name|int
name|d
init|=
name|def
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|base
index|[
name|i
index|]
operator|==
name|JAMSTATE
condition|)
name|base
index|[
name|i
index|]
operator|=
name|jambase
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|JAMSTATE
condition|)
name|def
index|[
name|i
index|]
operator|=
name|jamstate
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|<
literal|0
condition|)
block|{
comment|/* Template reference. */
operator|++
name|tmpuses
expr_stmt|;
name|def
index|[
name|i
index|]
operator|=
name|lastdfa
operator|-
name|d
operator|+
literal|1
expr_stmt|;
block|}
name|mkdata
argument_list|(
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|yybase_data
index|[
name|yybase_curr
operator|++
index|]
operator|=
name|base
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Generate jam state's base index. */
name|mkdata
argument_list|(
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|yybase_data
index|[
name|yybase_curr
operator|++
index|]
operator|=
name|base
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
operator|++
name|i
comment|/* skip jam state */
init|;
name|i
operator|<=
name|total_states
condition|;
operator|++
name|i
control|)
block|{
name|mkdata
argument_list|(
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|yybase_data
index|[
name|yybase_curr
operator|++
index|]
operator|=
name|base
index|[
name|i
index|]
expr_stmt|;
name|def
index|[
name|i
index|]
operator|=
name|jamstate
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
if|if
condition|(
name|tablesext
condition|)
block|{
name|yytbl_data_compress
argument_list|(
name|yybase_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytbl_data_fwrite
argument_list|(
operator|&
name|tableswr
argument_list|,
name|yybase_tbl
argument_list|)
operator|<
literal|0
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Could not write yybase_tbl"
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_destroy
argument_list|(
name|yybase_tbl
argument_list|)
expr_stmt|;
name|yybase_tbl
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* End generating yy_base */
comment|/* Begin generating yy_def */
name|out_str_dec
argument_list|(
operator|(
name|total_states
operator|>=
name|INT16_MAX
operator|||
name|long_align
operator|)
condition|?
name|get_int32_decl
argument_list|()
else|:
name|get_int16_decl
argument_list|()
argument_list|,
literal|"yy_def"
argument_list|,
name|total_states
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf_prints
argument_list|(
operator|&
name|yydmap_buf
argument_list|,
literal|"\t{YYTD_ID_DEF, (void**)&yy_def, sizeof(%s)},\n"
argument_list|,
operator|(
name|total_states
operator|>=
name|INT16_MAX
operator|||
name|long_align
operator|)
condition|?
literal|"flex_int32_t"
else|:
literal|"flex_int16_t"
argument_list|)
expr_stmt|;
name|yydef_tbl
operator|=
operator|(
expr|struct
name|yytbl_data
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|yytbl_data
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_init
argument_list|(
name|yydef_tbl
argument_list|,
name|YYTD_ID_DEF
argument_list|)
expr_stmt|;
name|yydef_tbl
operator|->
name|td_lolen
operator|=
name|total_states
operator|+
literal|1
expr_stmt|;
name|yydef_tbl
operator|->
name|td_data
operator|=
name|yydef_data
operator|=
operator|(
name|flex_int32_t
operator|*
operator|)
name|calloc
argument_list|(
name|yydef_tbl
operator|->
name|td_lolen
argument_list|,
sizeof|sizeof
argument_list|(
name|flex_int32_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|total_states
condition|;
operator|++
name|i
control|)
block|{
name|mkdata
argument_list|(
name|def
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|yydef_data
index|[
name|i
index|]
operator|=
name|def
index|[
name|i
index|]
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
if|if
condition|(
name|tablesext
condition|)
block|{
name|yytbl_data_compress
argument_list|(
name|yydef_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytbl_data_fwrite
argument_list|(
operator|&
name|tableswr
argument_list|,
name|yydef_tbl
argument_list|)
operator|<
literal|0
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Could not write yydef_tbl"
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_destroy
argument_list|(
name|yydef_tbl
argument_list|)
expr_stmt|;
name|yydef_tbl
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* End generating yy_def */
comment|/* Begin generating yy_nxt */
name|out_str_dec
argument_list|(
operator|(
name|total_states
operator|>=
name|INT16_MAX
operator|||
name|long_align
operator|)
condition|?
name|get_int32_decl
argument_list|()
else|:
name|get_int16_decl
argument_list|()
argument_list|,
literal|"yy_nxt"
argument_list|,
name|tblend
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf_prints
argument_list|(
operator|&
name|yydmap_buf
argument_list|,
literal|"\t{YYTD_ID_NXT, (void**)&yy_nxt, sizeof(%s)},\n"
argument_list|,
operator|(
name|total_states
operator|>=
name|INT16_MAX
operator|||
name|long_align
operator|)
condition|?
literal|"flex_int32_t"
else|:
literal|"flex_int16_t"
argument_list|)
expr_stmt|;
name|yynxt_tbl
operator|=
operator|(
expr|struct
name|yytbl_data
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|yytbl_data
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_init
argument_list|(
name|yynxt_tbl
argument_list|,
name|YYTD_ID_NXT
argument_list|)
expr_stmt|;
name|yynxt_tbl
operator|->
name|td_lolen
operator|=
name|tblend
operator|+
literal|1
expr_stmt|;
name|yynxt_tbl
operator|->
name|td_data
operator|=
name|yynxt_data
operator|=
operator|(
name|flex_int32_t
operator|*
operator|)
name|calloc
argument_list|(
name|yynxt_tbl
operator|->
name|td_lolen
argument_list|,
sizeof|sizeof
argument_list|(
name|flex_int32_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|tblend
condition|;
operator|++
name|i
control|)
block|{
comment|/* Note, the order of the following test is important. 		 * If chk[i] is 0, then nxt[i] is undefined. 		 */
if|if
condition|(
name|chk
index|[
name|i
index|]
operator|==
literal|0
operator|||
name|nxt
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|nxt
index|[
name|i
index|]
operator|=
name|jamstate
expr_stmt|;
comment|/* new state is the JAM state */
name|mkdata
argument_list|(
name|nxt
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|yynxt_data
index|[
name|i
index|]
operator|=
name|nxt
index|[
name|i
index|]
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
if|if
condition|(
name|tablesext
condition|)
block|{
name|yytbl_data_compress
argument_list|(
name|yynxt_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytbl_data_fwrite
argument_list|(
operator|&
name|tableswr
argument_list|,
name|yynxt_tbl
argument_list|)
operator|<
literal|0
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Could not write yynxt_tbl"
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_destroy
argument_list|(
name|yynxt_tbl
argument_list|)
expr_stmt|;
name|yynxt_tbl
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* End generating yy_nxt */
comment|/* Begin generating yy_chk */
name|out_str_dec
argument_list|(
operator|(
name|total_states
operator|>=
name|INT16_MAX
operator|||
name|long_align
operator|)
condition|?
name|get_int32_decl
argument_list|()
else|:
name|get_int16_decl
argument_list|()
argument_list|,
literal|"yy_chk"
argument_list|,
name|tblend
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf_prints
argument_list|(
operator|&
name|yydmap_buf
argument_list|,
literal|"\t{YYTD_ID_CHK, (void**)&yy_chk, sizeof(%s)},\n"
argument_list|,
operator|(
name|total_states
operator|>=
name|INT16_MAX
operator|||
name|long_align
operator|)
condition|?
literal|"flex_int32_t"
else|:
literal|"flex_int16_t"
argument_list|)
expr_stmt|;
name|yychk_tbl
operator|=
operator|(
expr|struct
name|yytbl_data
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|yytbl_data
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_init
argument_list|(
name|yychk_tbl
argument_list|,
name|YYTD_ID_CHK
argument_list|)
expr_stmt|;
name|yychk_tbl
operator|->
name|td_lolen
operator|=
name|tblend
operator|+
literal|1
expr_stmt|;
name|yychk_tbl
operator|->
name|td_data
operator|=
name|yychk_data
operator|=
operator|(
name|flex_int32_t
operator|*
operator|)
name|calloc
argument_list|(
name|yychk_tbl
operator|->
name|td_lolen
argument_list|,
sizeof|sizeof
argument_list|(
name|flex_int32_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|tblend
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|chk
index|[
name|i
index|]
operator|==
literal|0
condition|)
operator|++
name|nummt
expr_stmt|;
name|mkdata
argument_list|(
name|chk
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|yychk_data
index|[
name|i
index|]
operator|=
name|chk
index|[
name|i
index|]
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
if|if
condition|(
name|tablesext
condition|)
block|{
name|yytbl_data_compress
argument_list|(
name|yychk_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytbl_data_fwrite
argument_list|(
operator|&
name|tableswr
argument_list|,
name|yychk_tbl
argument_list|)
operator|<
literal|0
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Could not write yychk_tbl"
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_destroy
argument_list|(
name|yychk_tbl
argument_list|)
expr_stmt|;
name|yychk_tbl
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* End generating yy_chk */
name|flex_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|acc_array
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out a formatted string (with a secondary string argument) at the  * current indentation level, adding a final newline.  */
end_comment

begin_function
name|void
name|indent_put2s
parameter_list|(
name|fmt
parameter_list|,
name|arg
parameter_list|)
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function

begin_block
block|{
name|do_indent
argument_list|()
expr_stmt|;
name|out_str
argument_list|(
name|fmt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Write out a string at the current indentation level, adding a final  * newline.  */
end_comment

begin_function
name|void
name|indent_puts
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_indent
argument_list|()
expr_stmt|;
name|outn
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* make_tables - generate transition tables and finishes generating output file  */
end_comment

begin_function
name|void
name|make_tables
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|did_eof_rule
init|=
name|false
decl_stmt|;
name|struct
name|yytbl_data
modifier|*
name|yynultrans_tbl
decl_stmt|;
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [2.0] - break point in skel */
comment|/* First, take care of YY_DO_BEFORE_ACTION depending on yymore 	 * being used. 	 */
name|set_indent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|yymore_used
operator|&&
operator|!
name|yytext_is_array
condition|)
block|{
name|indent_puts
argument_list|(
literal|"YY_G(yytext_ptr) -= YY_G(yy_more_len); \\"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yyleng = (size_t) (yy_cp - YY_G(yytext_ptr)); \\"
argument_list|)
expr_stmt|;
block|}
else|else
name|indent_puts
argument_list|(
literal|"yyleng = (size_t) (yy_cp - yy_bp); \\"
argument_list|)
expr_stmt|;
comment|/* Now also deal with copying yytext_ptr to yytext if needed. */
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [3.0] - break point in skel */
if|if
condition|(
name|yytext_is_array
condition|)
block|{
if|if
condition|(
name|yymore_used
condition|)
name|indent_puts
argument_list|(
literal|"if ( yyleng + YY_G(yy_more_offset)>= YYLMAX ) \\"
argument_list|)
expr_stmt|;
else|else
name|indent_puts
argument_list|(
literal|"if ( yyleng>= YYLMAX ) \\"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_FATAL_ERROR( \"token too large, exceeds YYLMAX\" ); \\"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
if|if
condition|(
name|yymore_used
condition|)
block|{
name|indent_puts
argument_list|(
literal|"yy_flex_strncpy(&yytext[YY_G(yy_more_offset)], YY_G(yytext_ptr), yyleng + 1 M4_YY_CALL_LAST_ARG); \\"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yyleng += YY_G(yy_more_offset); \\"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_G(yy_prev_more_offset) = YY_G(yy_more_offset); \\"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_G(yy_more_offset) = 0; \\"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indent_puts
argument_list|(
literal|"yy_flex_strncpy( yytext, YY_G(yytext_ptr), yyleng + 1 M4_YY_CALL_LAST_ARG); \\"
argument_list|)
expr_stmt|;
block|}
block|}
name|set_indent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [4.0] - break point in skel */
comment|/* This is where we REALLY begin generating the tables. */
name|out_dec
argument_list|(
literal|"#define YY_NUM_RULES %d\n"
argument_list|,
name|num_rules
argument_list|)
expr_stmt|;
name|out_dec
argument_list|(
literal|"#define YY_END_OF_BUFFER %d\n"
argument_list|,
name|num_rules
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullspd
condition|)
block|{
comment|/* Need to define the transet type as a size large 		 * enough to hold the biggest offset. 		 */
name|int
name|total_table_size
init|=
name|tblend
operator|+
name|numecs
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|trans_offset_type
init|=
operator|(
name|total_table_size
operator|>=
name|INT16_MAX
operator|||
name|long_align
operator|)
condition|?
literal|"flex_int32_t"
else|:
literal|"flex_int16_t"
decl_stmt|;
name|set_indent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"struct yy_trans_info"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
comment|/* We require that yy_verify and yy_nxt must be of the same size int. */
name|indent_put2s
argument_list|(
literal|"%s yy_verify;"
argument_list|,
name|trans_offset_type
argument_list|)
expr_stmt|;
comment|/* In cases where its sister yy_verify *is* a "yes, there is 		 * a transition", yy_nxt is the offset (in records) to the 		 * next state.  In most cases where there is no transition, 		 * the value of yy_nxt is irrelevant.  If yy_nxt is the -1th 		 * record of a state, though, then yy_nxt is the action number 		 * for that state. 		 */
name|indent_put2s
argument_list|(
literal|"%s yy_nxt;"
argument_list|,
name|trans_offset_type
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"};"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* We generate a bogus 'struct yy_trans_info' data type 		 * so we can guarantee that it is always declared in the skel. 		 * This is so we can compile "sizeof(struct yy_trans_info)" 		 * in any scanner. 		 */
name|indent_puts
argument_list|(
literal|"/* This struct is not used in this scanner,"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"   but its presence is necessary. */"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"struct yy_trans_info"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"flex_int32_t yy_verify;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"flex_int32_t yy_nxt;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"};"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fullspd
condition|)
block|{
name|genctbl
argument_list|()
expr_stmt|;
if|if
condition|(
name|tablesext
condition|)
block|{
name|struct
name|yytbl_data
modifier|*
name|tbl
decl_stmt|;
name|tbl
operator|=
name|mkctbl
argument_list|()
expr_stmt|;
name|yytbl_data_compress
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytbl_data_fwrite
argument_list|(
operator|&
name|tableswr
argument_list|,
name|tbl
argument_list|)
operator|<
literal|0
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Could not write ftbl"
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_destroy
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
name|tbl
operator|=
name|mkssltbl
argument_list|()
expr_stmt|;
name|yytbl_data_compress
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytbl_data_fwrite
argument_list|(
operator|&
name|tableswr
argument_list|,
name|tbl
argument_list|)
operator|<
literal|0
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Could not write ssltbl"
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_destroy
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
name|tbl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
block|{
name|tbl
operator|=
name|mkecstbl
argument_list|()
expr_stmt|;
name|yytbl_data_compress
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytbl_data_fwrite
argument_list|(
operator|&
name|tableswr
argument_list|,
name|tbl
argument_list|)
operator|<
literal|0
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Could not write ecstbl"
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_destroy
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
name|tbl
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|fulltbl
condition|)
block|{
name|genftbl
argument_list|()
expr_stmt|;
if|if
condition|(
name|tablesext
condition|)
block|{
name|struct
name|yytbl_data
modifier|*
name|tbl
decl_stmt|;
name|tbl
operator|=
name|mkftbl
argument_list|()
expr_stmt|;
name|yytbl_data_compress
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytbl_data_fwrite
argument_list|(
operator|&
name|tableswr
argument_list|,
name|tbl
argument_list|)
operator|<
literal|0
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Could not write ftbl"
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_destroy
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
name|tbl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
block|{
name|tbl
operator|=
name|mkecstbl
argument_list|()
expr_stmt|;
name|yytbl_data_compress
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytbl_data_fwrite
argument_list|(
operator|&
name|tableswr
argument_list|,
name|tbl
argument_list|)
operator|<
literal|0
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Could not write ecstbl"
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_destroy
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
name|tbl
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
name|gentabs
argument_list|()
expr_stmt|;
if|if
condition|(
name|do_yylineno
condition|)
block|{
name|geneoltbl
argument_list|()
expr_stmt|;
if|if
condition|(
name|tablesext
condition|)
block|{
name|struct
name|yytbl_data
modifier|*
name|tbl
decl_stmt|;
name|tbl
operator|=
name|mkeoltbl
argument_list|()
expr_stmt|;
name|yytbl_data_compress
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytbl_data_fwrite
argument_list|(
operator|&
name|tableswr
argument_list|,
name|tbl
argument_list|)
operator|<
literal|0
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Could not write eoltbl"
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_destroy
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
name|tbl
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Definitions for backing up.  We don't need them if REJECT 	 * is being used because then we use an alternative backin-up 	 * technique instead. 	 */
if|if
condition|(
name|num_backing_up
operator|>
literal|0
operator|&&
operator|!
name|reject
condition|)
block|{
if|if
condition|(
operator|!
name|C_plus_plus
operator|&&
operator|!
name|reentrant
condition|)
block|{
name|indent_puts
argument_list|(
literal|"static yy_state_type yy_last_accepting_state;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"static char *yy_last_accepting_cpos;\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nultrans
condition|)
block|{
name|flex_int32_t
modifier|*
name|yynultrans_data
init|=
literal|0
decl_stmt|;
comment|/* Begin generating yy_NUL_trans */
name|out_str_dec
argument_list|(
name|get_state_decl
argument_list|()
argument_list|,
literal|"yy_NUL_trans"
argument_list|,
name|lastdfa
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf_prints
argument_list|(
operator|&
name|yydmap_buf
argument_list|,
literal|"\t{YYTD_ID_NUL_TRANS, (void**)&yy_NUL_trans, sizeof(%s)},\n"
argument_list|,
operator|(
name|fullspd
operator|)
condition|?
literal|"struct yy_trans_info*"
else|:
literal|"flex_int32_t"
argument_list|)
expr_stmt|;
name|yynultrans_tbl
operator|=
operator|(
expr|struct
name|yytbl_data
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|yytbl_data
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_init
argument_list|(
name|yynultrans_tbl
argument_list|,
name|YYTD_ID_NUL_TRANS
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullspd
condition|)
name|yynultrans_tbl
operator|->
name|td_flags
operator||=
name|YYTD_PTRANS
expr_stmt|;
name|yynultrans_tbl
operator|->
name|td_lolen
operator|=
name|lastdfa
operator|+
literal|1
expr_stmt|;
name|yynultrans_tbl
operator|->
name|td_data
operator|=
name|yynultrans_data
operator|=
operator|(
name|flex_int32_t
operator|*
operator|)
name|calloc
argument_list|(
name|yynultrans_tbl
operator|->
name|td_lolen
argument_list|,
sizeof|sizeof
argument_list|(
name|flex_int32_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fullspd
condition|)
block|{
name|out_dec
argument_list|(
literal|"&yy_transition[%d],\n"
argument_list|,
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|yynultrans_data
index|[
name|i
index|]
operator|=
name|base
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|mkdata
argument_list|(
name|nultrans
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|yynultrans_data
index|[
name|i
index|]
operator|=
name|nultrans
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|dataend
argument_list|()
expr_stmt|;
if|if
condition|(
name|tablesext
condition|)
block|{
name|yytbl_data_compress
argument_list|(
name|yynultrans_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytbl_data_fwrite
argument_list|(
operator|&
name|tableswr
argument_list|,
name|yynultrans_tbl
argument_list|)
operator|<
literal|0
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Could not write yynultrans_tbl"
argument_list|)
argument_list|)
expr_stmt|;
name|yytbl_data_destroy
argument_list|(
name|yynultrans_tbl
argument_list|)
expr_stmt|;
name|yynultrans_tbl
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* End generating yy_NUL_trans */
block|}
if|if
condition|(
operator|!
name|C_plus_plus
operator|&&
operator|!
name|reentrant
condition|)
block|{
name|indent_puts
argument_list|(
literal|"extern int yy_flex_debug;"
argument_list|)
expr_stmt|;
name|indent_put2s
argument_list|(
literal|"int yy_flex_debug = %s;\n"
argument_list|,
name|ddebug
condition|?
literal|"1"
else|:
literal|"0"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ddebug
condition|)
block|{
comment|/* Spit out table mapping rules to line numbers. */
name|out_str_dec
argument_list|(
name|long_align
condition|?
name|get_int32_decl
argument_list|()
else|:
name|get_int16_decl
argument_list|()
argument_list|,
literal|"yy_rule_linenum"
argument_list|,
name|num_rules
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_rules
condition|;
operator|++
name|i
control|)
name|mkdata
argument_list|(
name|rule_linenum
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dataend
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reject
condition|)
block|{
name|outn
argument_list|(
literal|"m4_ifdef( [[M4_YY_USES_REJECT]],\n[["
argument_list|)
expr_stmt|;
comment|/* Declare state buffer variables. */
if|if
condition|(
operator|!
name|C_plus_plus
operator|&&
operator|!
name|reentrant
condition|)
block|{
name|outn
argument_list|(
literal|"static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"static char *yy_full_match;"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"static int yy_lp;"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|variable_trailing_context_rules
condition|)
block|{
if|if
condition|(
operator|!
name|C_plus_plus
operator|&&
operator|!
name|reentrant
condition|)
block|{
name|outn
argument_list|(
literal|"static int yy_looking_for_trail_begin = 0;"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"static int yy_full_lp;"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"static int *yy_full_state;"
argument_list|)
expr_stmt|;
block|}
name|out_hex
argument_list|(
literal|"#define YY_TRAILING_MASK 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|YY_TRAILING_MASK
argument_list|)
expr_stmt|;
name|out_hex
argument_list|(
literal|"#define YY_TRAILING_HEAD_MASK 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|YY_TRAILING_HEAD_MASK
argument_list|)
expr_stmt|;
block|}
name|outn
argument_list|(
literal|"#define REJECT \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"{ \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"*yy_cp = YY_G(yy_hold_char); /* undo effects of setting up yytext */ \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"yy_cp = YY_G(yy_full_match); /* restore poss. backed-over text */ \\"
argument_list|)
expr_stmt|;
if|if
condition|(
name|variable_trailing_context_rules
condition|)
block|{
name|outn
argument_list|(
literal|"YY_G(yy_lp) = YY_G(yy_full_lp); /* restore orig. accepting pos. */ \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"YY_G(yy_state_ptr) = YY_G(yy_full_state); /* restore orig. state */ \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"yy_current_state = *YY_G(yy_state_ptr); /* restore curr. state */ \\"
argument_list|)
expr_stmt|;
block|}
name|outn
argument_list|(
literal|"++YY_G(yy_lp); \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"goto find_rule; \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"]])\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outn
argument_list|(
literal|"/* The intent behind this definition is that it'll catch"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|" * any uses of REJECT which flex missed."
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|" */"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#define REJECT reject_used_but_not_detected"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yymore_used
condition|)
block|{
if|if
condition|(
operator|!
name|C_plus_plus
condition|)
block|{
if|if
condition|(
name|yytext_is_array
condition|)
block|{
if|if
condition|(
operator|!
name|reentrant
condition|)
block|{
name|indent_puts
argument_list|(
literal|"static int yy_more_offset = 0;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"static int yy_prev_more_offset = 0;"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|reentrant
condition|)
block|{
name|indent_puts
argument_list|(
literal|"static int yy_more_flag = 0;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"static int yy_more_len = 0;"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|yytext_is_array
condition|)
block|{
name|indent_puts
argument_list|(
literal|"#define yymore() (YY_G(yy_more_offset) = yy_flex_strlen( yytext M4_YY_CALL_LAST_ARG))"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"#define YY_NEED_STRLEN"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"#define YY_MORE_ADJ 0"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"#define YY_RESTORE_YY_MORE_OFFSET \\"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{ \\"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_G(yy_more_offset) = YY_G(yy_prev_more_offset); \\"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yyleng -= YY_G(yy_more_offset); \\"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|indent_puts
argument_list|(
literal|"#define yymore() (YY_G(yy_more_flag) = 1)"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"#define YY_MORE_ADJ YY_G(yy_more_len)"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"#define YY_RESTORE_YY_MORE_OFFSET"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|indent_puts
argument_list|(
literal|"#define yymore() yymore_used_but_not_detected"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"#define YY_MORE_ADJ 0"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"#define YY_RESTORE_YY_MORE_OFFSET"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|C_plus_plus
condition|)
block|{
if|if
condition|(
name|yytext_is_array
condition|)
block|{
name|outn
argument_list|(
literal|"#ifndef YYLMAX"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#define YYLMAX 8192"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#endif\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reentrant
condition|)
block|{
name|outn
argument_list|(
literal|"char yytext[YYLMAX];"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"char *yytext_ptr;"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|reentrant
condition|)
name|outn
argument_list|(
literal|"char *yytext;"
argument_list|)
expr_stmt|;
block|}
block|}
name|out
argument_list|(
operator|&
name|action_array
index|[
name|defs1_offset
index|]
argument_list|)
expr_stmt|;
name|line_directive_out
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [5.0] - break point in skel */
if|if
condition|(
operator|!
name|C_plus_plus
condition|)
block|{
if|if
condition|(
name|use_read
condition|)
block|{
name|outn
argument_list|(
literal|"\terrno=0; \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\twhile ( (result = read( fileno(yyin), (char *) buf, max_size ))< 0 ) \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t{ \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\tif( errno != EINTR) \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t{ \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t\tbreak; \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t} \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\terrno=0; \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\tclearerr(yyin); \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t}\\"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outn
argument_list|(
literal|"\tif ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t{ \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\tint c = '*'; \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\tsize_t n; \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\tfor ( n = 0; n< max_size&& \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t\t     (c = getc( yyin )) != EOF&& c != '\\n'; ++n ) \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t\tbuf[n] = (char) c; \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\tif ( c == '\\n' ) \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t\tbuf[n++] = (char) c; \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\tif ( c == EOF&& ferror( yyin ) ) \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\tresult = n; \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t} \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\telse \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t{ \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\terrno=0; \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\twhile ( (result = fread(buf, 1, max_size, yyin))==0&& ferror(yyin)) \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t\t{ \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t\tif( errno != EINTR) \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t\t\t{ \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t\t\tbreak; \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t\t\t} \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t\terrno=0; \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t\tclearerr(yyin); \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t\t} \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t}\\"
argument_list|)
expr_stmt|;
block|}
block|}
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [6.0] - break point in skel */
name|indent_puts
argument_list|(
literal|"#define YY_RULE_SETUP \\"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
if|if
condition|(
name|bol_needed
condition|)
block|{
name|indent_puts
argument_list|(
literal|"if ( yyleng> 0 ) \\"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \\"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"\t\t(yytext[yyleng - 1] == '\\n'); \\"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
name|indent_puts
argument_list|(
literal|"YY_USER_ACTION"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [7.0] - break point in skel */
comment|/* Copy prolog to output file. */
name|out
argument_list|(
operator|&
name|action_array
index|[
name|prolog_offset
index|]
argument_list|)
expr_stmt|;
name|line_directive_out
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [8.0] - break point in skel */
name|set_indent
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|yymore_used
operator|&&
operator|!
name|yytext_is_array
condition|)
block|{
name|indent_puts
argument_list|(
literal|"YY_G(yy_more_len) = 0;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( YY_G(yy_more_flag) )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_G(yy_more_len) = YY_G(yy_c_buf_p) - YY_G(yytext_ptr);"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_G(yy_more_flag) = 0;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [9.0] - break point in skel */
name|gen_start_state
argument_list|()
expr_stmt|;
comment|/* Note, don't use any indentation. */
name|outn
argument_list|(
literal|"yy_match:"
argument_list|)
expr_stmt|;
name|gen_next_match
argument_list|()
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [10.0] - break point in skel */
name|set_indent
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|gen_find_action
argument_list|()
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [11.0] - break point in skel */
name|outn
argument_list|(
literal|"m4_ifdef( [[M4_YY_USE_LINENO]],[["
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( yy_act != YY_END_OF_BUFFER&& yy_rule_can_match_eol[yy_act] )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_size_t yyl;"
argument_list|)
expr_stmt|;
name|do_indent
argument_list|()
expr_stmt|;
name|out_str
argument_list|(
literal|"for ( yyl = %s; yyl< yyleng; ++yyl )\n"
argument_list|,
name|yymore_used
condition|?
operator|(
name|yytext_is_array
condition|?
literal|"YY_G(yy_prev_more_offset)"
else|:
literal|"YY_G(yy_more_len)"
operator|)
else|:
literal|"0"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( yytext[yyl] == '\\n' )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"M4_YY_INCR_LINENO();"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|outn
argument_list|(
literal|"]])"
argument_list|)
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [12.0] - break point in skel */
if|if
condition|(
name|ddebug
condition|)
block|{
name|indent_puts
argument_list|(
literal|"if ( yy_flex_debug )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( yy_act == 0 )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
name|C_plus_plus
condition|?
literal|"std::cerr<< \"--scanner backing up\\n\";"
else|:
literal|"fprintf( stderr, \"--scanner backing up\\n\" );"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|do_indent
argument_list|()
expr_stmt|;
name|out_dec
argument_list|(
literal|"else if ( yy_act< %d )\n"
argument_list|,
name|num_rules
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
if|if
condition|(
name|C_plus_plus
condition|)
block|{
name|indent_puts
argument_list|(
literal|"std::cerr<< \"--accepting rule at line \"<< yy_rule_linenum[yy_act]<<"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"         \"(\\\"\"<< yytext<< \"\\\")\\n\";"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indent_puts
argument_list|(
literal|"fprintf( stderr, \"--accepting rule at line %ld (\\\"%s\\\")\\n\","
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"         (long)yy_rule_linenum[yy_act], yytext );"
argument_list|)
expr_stmt|;
block|}
name|indent_down
argument_list|()
expr_stmt|;
name|do_indent
argument_list|()
expr_stmt|;
name|out_dec
argument_list|(
literal|"else if ( yy_act == %d )\n"
argument_list|,
name|num_rules
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
if|if
condition|(
name|C_plus_plus
condition|)
block|{
name|indent_puts
argument_list|(
literal|"std::cerr<< \"--accepting default rule (\\\"\"<< yytext<< \"\\\")\\n\";"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indent_puts
argument_list|(
literal|"fprintf( stderr, \"--accepting default rule (\\\"%s\\\")\\n\","
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"         yytext );"
argument_list|)
expr_stmt|;
block|}
name|indent_down
argument_list|()
expr_stmt|;
name|do_indent
argument_list|()
expr_stmt|;
name|out_dec
argument_list|(
literal|"else if ( yy_act == %d )\n"
argument_list|,
name|num_rules
operator|+
literal|1
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
name|C_plus_plus
condition|?
literal|"std::cerr<< \"--(end of buffer or a NUL)\\n\";"
else|:
literal|"fprintf( stderr, \"--(end of buffer or a NUL)\\n\" );"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|do_indent
argument_list|()
expr_stmt|;
name|outn
argument_list|(
literal|"else"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
if|if
condition|(
name|C_plus_plus
condition|)
block|{
name|indent_puts
argument_list|(
literal|"std::cerr<< \"--EOF (start condition \"<< YY_START<< \")\\n\";"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indent_puts
argument_list|(
literal|"fprintf( stderr, \"--EOF (start condition %d)\\n\", YY_START );"
argument_list|)
expr_stmt|;
block|}
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
comment|/* Copy actions to output file. */
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [13.0] - break point in skel */
name|indent_up
argument_list|()
expr_stmt|;
name|gen_bu_action
argument_list|()
expr_stmt|;
name|out
argument_list|(
operator|&
name|action_array
index|[
name|action_offset
index|]
argument_list|)
expr_stmt|;
name|line_directive_out
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* generate cases for any missing EOF rules */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastsc
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|sceof
index|[
name|i
index|]
condition|)
block|{
name|do_indent
argument_list|()
expr_stmt|;
name|out_str
argument_list|(
literal|"case YY_STATE_EOF(%s):\n"
argument_list|,
name|scname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|did_eof_rule
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|did_eof_rule
condition|)
block|{
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yyterminate();"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
comment|/* Generate code for handling NUL's, if needed. */
comment|/* First, deal with backing up and setting up yy_cp if the scanner 	 * finds that it should JAM on the NUL. 	 */
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [14.0] - break point in skel */
name|set_indent
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullspd
operator|||
name|fulltbl
condition|)
name|indent_puts
argument_list|(
literal|"yy_cp = YY_G(yy_c_buf_p);"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* compressed table */
if|if
condition|(
operator|!
name|reject
operator|&&
operator|!
name|interactive
condition|)
block|{
comment|/* Do the guaranteed-needed backing up to figure 			 * out the match. 			 */
name|indent_puts
argument_list|(
literal|"yy_cp = YY_G(yy_last_accepting_cpos);"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = YY_G(yy_last_accepting_state);"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Still need to initialize yy_cp, though 			 * yy_current_state was set up by 			 * yy_get_previous_state(). 			 */
name|indent_puts
argument_list|(
literal|"yy_cp = YY_G(yy_c_buf_p);"
argument_list|)
expr_stmt|;
block|}
comment|/* Generate code for yy_get_previous_state(). */
name|set_indent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [15.0] - break point in skel */
name|gen_start_state
argument_list|()
expr_stmt|;
name|set_indent
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [16.0] - break point in skel */
name|gen_next_state
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|set_indent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [17.0] - break point in skel */
name|gen_NUL_trans
argument_list|()
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [18.0] - break point in skel */
name|skelout
argument_list|()
expr_stmt|;
comment|/* %% [19.0] - break point in skel */
comment|/* Update BOL and yylineno inside of input(). */
if|if
condition|(
name|bol_needed
condition|)
block|{
name|indent_puts
argument_list|(
literal|"YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\\n');"
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_yylineno
condition|)
block|{
name|indent_puts
argument_list|(
literal|"if ( YY_CURRENT_BUFFER_LVALUE->yy_at_bol )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"M4_YY_INCR_LINENO();"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|do_yylineno
condition|)
block|{
name|indent_puts
argument_list|(
literal|"if ( c == '\\n' )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"M4_YY_INCR_LINENO();"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
name|skelout
argument_list|()
expr_stmt|;
comment|/* Copy remainder of input to output. */
name|line_directive_out
argument_list|(
name|stdout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sectnum
operator|==
literal|3
condition|)
block|{
name|OUT_BEGIN_CODE
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|flexscan
argument_list|()
expr_stmt|;
comment|/* copy remainder of input to output */
name|OUT_END_CODE
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

