begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- sanitizer_quarantine.h ----------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Memory quarantine for AddressSanitizer and potentially other tools.
end_comment

begin_comment
comment|// Quarantine caches some specified amount of memory in per-thread caches,
end_comment

begin_comment
comment|// then evicts to global FIFO queue. When the queue reaches specified threshold,
end_comment

begin_comment
comment|// oldest memory is recycled.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SANITIZER_QUARANTINE_H
end_ifndef

begin_define
define|#
directive|define
name|SANITIZER_QUARANTINE_H
end_define

begin_include
include|#
directive|include
file|"sanitizer_internal_defs.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_mutex.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_list.h"
end_include

begin_decl_stmt
name|namespace
name|__sanitizer
block|{
name|template
operator|<
name|typename
name|Node
operator|>
name|class
name|QuarantineCache
expr_stmt|;
struct|struct
name|QuarantineBatch
block|{
specifier|static
specifier|const
name|uptr
name|kSize
init|=
literal|1021
decl_stmt|;
name|QuarantineBatch
modifier|*
name|next
decl_stmt|;
name|uptr
name|size
decl_stmt|;
name|uptr
name|count
decl_stmt|;
name|void
modifier|*
name|batch
index|[
name|kSize
index|]
decl_stmt|;
block|}
struct|;
name|COMPILER_CHECK
argument_list|(
sizeof|sizeof
argument_list|(
name|QuarantineBatch
argument_list|)
operator|<=
operator|(
literal|1
operator|<<
literal|13
operator|)
argument_list|)
expr_stmt|;
comment|// 8Kb.
comment|// The callback interface is:
comment|// void Callback::Recycle(Node *ptr);
comment|// void *cb.Allocate(uptr size);
comment|// void cb.Deallocate(void *ptr);
name|template
operator|<
name|typename
name|Callback
operator|,
name|typename
name|Node
operator|>
name|class
name|Quarantine
block|{
name|public
operator|:
typedef|typedef
name|QuarantineCache
operator|<
name|Callback
operator|>
name|Cache
expr_stmt|;
name|explicit
name|Quarantine
argument_list|(
name|LinkerInitialized
argument_list|)
operator|:
name|cache_
argument_list|(
argument|LINKER_INITIALIZED
argument_list|)
block|{   }
name|void
name|Init
argument_list|(
argument|uptr size
argument_list|,
argument|uptr cache_size
argument_list|)
block|{
comment|// Thread local quarantine size can be zero only when global quarantine size
comment|// is zero (it allows us to perform just one atomic read per Put() call).
name|CHECK
argument_list|(
operator|(
name|size
operator|==
literal|0
operator|&&
name|cache_size
operator|==
literal|0
operator|)
operator|||
name|cache_size
operator|!=
literal|0
argument_list|)
block|;
name|atomic_store
argument_list|(
operator|&
name|max_size_
argument_list|,
name|size
argument_list|,
name|memory_order_relaxed
argument_list|)
block|;
name|atomic_store
argument_list|(
operator|&
name|min_size_
argument_list|,
name|size
operator|/
literal|10
operator|*
literal|9
argument_list|,
name|memory_order_relaxed
argument_list|)
block|;
comment|// 90% of max size.
name|atomic_store
argument_list|(
operator|&
name|max_cache_size_
argument_list|,
name|cache_size
argument_list|,
name|memory_order_relaxed
argument_list|)
block|;   }
name|uptr
name|GetSize
argument_list|()
specifier|const
block|{
return|return
name|atomic_load
argument_list|(
operator|&
name|max_size_
argument_list|,
name|memory_order_relaxed
argument_list|)
return|;
block|}
name|uptr
name|GetCacheSize
argument_list|()
specifier|const
block|{
return|return
name|atomic_load
argument_list|(
operator|&
name|max_cache_size_
argument_list|,
name|memory_order_relaxed
argument_list|)
return|;
block|}
name|void
name|Put
parameter_list|(
name|Cache
modifier|*
name|c
parameter_list|,
name|Callback
name|cb
parameter_list|,
name|Node
modifier|*
name|ptr
parameter_list|,
name|uptr
name|size
parameter_list|)
block|{
name|uptr
name|cache_size
init|=
name|GetCacheSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|cache_size
condition|)
block|{
name|c
operator|->
name|Enqueue
argument_list|(
name|cb
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// cache_size == 0 only when size == 0 (see Init).
name|cb
operator|.
name|Recycle
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
comment|// Check cache size anyway to accommodate for runtime cache_size change.
if|if
condition|(
name|c
operator|->
name|Size
argument_list|()
operator|>
name|cache_size
condition|)
name|Drain
argument_list|(
name|c
argument_list|,
name|cb
argument_list|)
expr_stmt|;
block|}
name|void
name|NOINLINE
name|Drain
parameter_list|(
name|Cache
modifier|*
name|c
parameter_list|,
name|Callback
name|cb
parameter_list|)
block|{
block|{
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|cache_mutex_
argument_list|)
decl_stmt|;
name|cache_
operator|.
name|Transfer
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cache_
operator|.
name|Size
argument_list|()
operator|>
name|GetSize
argument_list|()
operator|&&
name|recycle_mutex_
operator|.
name|TryLock
argument_list|()
condition|)
name|Recycle
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
name|void
name|PrintStats
argument_list|()
specifier|const
block|{
comment|// It assumes that the world is stopped, just as the allocator's PrintStats.
name|cache_
operator|.
name|PrintStats
argument_list|()
block|;   }
name|private
operator|:
comment|// Read-only data.
name|char
name|pad0_
index|[
name|kCacheLineSize
index|]
expr_stmt|;
name|atomic_uintptr_t
name|max_size_
decl_stmt|;
name|atomic_uintptr_t
name|min_size_
decl_stmt|;
name|atomic_uintptr_t
name|max_cache_size_
decl_stmt|;
name|char
name|pad1_
index|[
name|kCacheLineSize
index|]
decl_stmt|;
name|SpinMutex
name|cache_mutex_
decl_stmt|;
name|SpinMutex
name|recycle_mutex_
decl_stmt|;
name|Cache
name|cache_
decl_stmt|;
name|char
name|pad2_
index|[
name|kCacheLineSize
index|]
decl_stmt|;
name|void
name|NOINLINE
name|Recycle
parameter_list|(
name|Callback
name|cb
parameter_list|)
block|{
name|Cache
name|tmp
decl_stmt|;
name|uptr
name|min_size
init|=
name|atomic_load
argument_list|(
operator|&
name|min_size_
argument_list|,
name|memory_order_relaxed
argument_list|)
decl_stmt|;
block|{
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|cache_mutex_
argument_list|)
decl_stmt|;
while|while
condition|(
name|cache_
operator|.
name|Size
argument_list|()
operator|>
name|min_size
condition|)
block|{
name|QuarantineBatch
modifier|*
name|b
init|=
name|cache_
operator|.
name|DequeueBatch
argument_list|()
decl_stmt|;
name|tmp
operator|.
name|EnqueueBatch
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
name|recycle_mutex_
operator|.
name|Unlock
argument_list|()
expr_stmt|;
name|DoRecycle
argument_list|(
operator|&
name|tmp
argument_list|,
name|cb
argument_list|)
expr_stmt|;
block|}
name|void
name|NOINLINE
name|DoRecycle
parameter_list|(
name|Cache
modifier|*
name|c
parameter_list|,
name|Callback
name|cb
parameter_list|)
block|{
while|while
condition|(
name|QuarantineBatch
modifier|*
name|b
init|=
name|c
operator|->
name|DequeueBatch
argument_list|()
condition|)
block|{
specifier|const
name|uptr
name|kPrefetch
init|=
literal|16
decl_stmt|;
name|CHECK
argument_list|(
name|kPrefetch
operator|<=
name|ARRAY_SIZE
argument_list|(
name|b
operator|->
name|batch
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kPrefetch
condition|;
name|i
operator|++
control|)
name|PREFETCH
argument_list|(
name|b
operator|->
name|batch
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|,
name|count
init|=
name|b
operator|->
name|count
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|+
name|kPrefetch
operator|<
name|count
condition|)
name|PREFETCH
argument_list|(
name|b
operator|->
name|batch
index|[
name|i
operator|+
name|kPrefetch
index|]
argument_list|)
expr_stmt|;
name|cb
operator|.
name|Recycle
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|b
operator|->
name|batch
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|cb
operator|.
name|Deallocate
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Per-thread cache of memory blocks.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Callback
operator|>
name|class
name|QuarantineCache
block|{
name|public
operator|:
name|explicit
name|QuarantineCache
argument_list|(
argument|LinkerInitialized
argument_list|)
block|{   }
name|QuarantineCache
argument_list|()
operator|:
name|size_
argument_list|()
block|{
name|list_
operator|.
name|clear
argument_list|()
block|;   }
name|uptr
name|Size
argument_list|()
specifier|const
block|{
return|return
name|atomic_load
argument_list|(
operator|&
name|size_
argument_list|,
name|memory_order_relaxed
argument_list|)
return|;
block|}
name|void
name|Enqueue
argument_list|(
argument|Callback cb
argument_list|,
argument|void *ptr
argument_list|,
argument|uptr size
argument_list|)
block|{
if|if
condition|(
name|list_
operator|.
name|empty
argument_list|()
operator|||
name|list_
operator|.
name|back
argument_list|()
operator|->
name|count
operator|==
name|QuarantineBatch
operator|::
name|kSize
condition|)
block|{
name|AllocBatch
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|QuarantineBatch
argument_list|)
expr_stmt|;
comment|// Count the batch in Quarantine size.
block|}
name|QuarantineBatch
operator|*
name|b
operator|=
name|list_
operator|.
name|back
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CHECK
argument_list|(
name|b
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|b
operator|->
name|batch
index|[
name|b
operator|->
name|count
operator|++
index|]
operator|=
name|ptr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|b
operator|->
name|size
operator|+=
name|size
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SizeAdd
argument_list|(
name|size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
unit|}    void
name|Transfer
argument_list|(
argument|QuarantineCache *c
argument_list|)
end_macro

begin_block
block|{
name|list_
operator|.
name|append_back
argument_list|(
operator|&
name|c
operator|->
name|list_
argument_list|)
expr_stmt|;
name|SizeAdd
argument_list|(
name|c
operator|->
name|Size
argument_list|()
argument_list|)
expr_stmt|;
name|atomic_store
argument_list|(
operator|&
name|c
operator|->
name|size_
argument_list|,
literal|0
argument_list|,
name|memory_order_relaxed
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|EnqueueBatch
parameter_list|(
name|QuarantineBatch
modifier|*
name|b
parameter_list|)
block|{
name|list_
operator|.
name|push_back
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|SizeAdd
argument_list|(
name|b
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|QuarantineBatch
modifier|*
name|DequeueBatch
parameter_list|()
block|{
if|if
condition|(
name|list_
operator|.
name|empty
argument_list|()
condition|)
return|return
name|nullptr
return|;
name|QuarantineBatch
modifier|*
name|b
init|=
name|list_
operator|.
name|front
argument_list|()
decl_stmt|;
name|list_
operator|.
name|pop_front
argument_list|()
expr_stmt|;
name|SizeSub
argument_list|(
name|b
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_expr_stmt
name|void
name|PrintStats
argument_list|()
specifier|const
block|{
name|uptr
name|batch_count
operator|=
literal|0
block|;
name|uptr
name|total_quarantine_bytes
operator|=
literal|0
block|;
name|uptr
name|total_quarantine_chunks
operator|=
literal|0
block|;
for|for
control|(
name|List
operator|::
name|ConstIterator
name|it
operator|=
name|list_
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|list_
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|batch_count
operator|++
expr_stmt|;
name|total_quarantine_bytes
operator|+=
operator|(
operator|*
name|it
operator|)
operator|.
name|size
expr_stmt|;
name|total_quarantine_chunks
operator|+=
operator|(
operator|*
name|it
operator|)
operator|.
name|count
expr_stmt|;
block|}
name|Printf
argument_list|(
literal|"Global quarantine stats: batches: %zd; bytes: %zd; chunks: %zd "
literal|"(capacity: %zd chunks)\n"
argument_list|,
name|batch_count
argument_list|,
name|total_quarantine_bytes
argument_list|,
name|total_quarantine_chunks
argument_list|,
name|batch_count
operator|*
name|QuarantineBatch
operator|::
name|kSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
unit|}   private:
typedef|typedef
name|IntrusiveList
operator|<
name|QuarantineBatch
operator|>
name|List
expr_stmt|;
end_typedef

begin_decl_stmt
name|List
name|list_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|atomic_uintptr_t
name|size_
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|SizeAdd
parameter_list|(
name|uptr
name|add
parameter_list|)
block|{
name|atomic_store
argument_list|(
operator|&
name|size_
argument_list|,
name|Size
argument_list|()
operator|+
name|add
argument_list|,
name|memory_order_relaxed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SizeSub
parameter_list|(
name|uptr
name|sub
parameter_list|)
block|{
name|atomic_store
argument_list|(
operator|&
name|size_
argument_list|,
name|Size
argument_list|()
operator|-
name|sub
argument_list|,
name|memory_order_relaxed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|NOINLINE
name|QuarantineBatch
modifier|*
name|AllocBatch
parameter_list|(
name|Callback
name|cb
parameter_list|)
block|{
name|QuarantineBatch
modifier|*
name|b
init|=
operator|(
name|QuarantineBatch
operator|*
operator|)
name|cb
operator|.
name|Allocate
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
decl_stmt|;
name|CHECK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|list_
operator|.
name|push_back
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
unit|};  }
comment|// namespace __sanitizer
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// SANITIZER_QUARANTINE_H
end_comment

end_unit

