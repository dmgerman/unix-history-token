begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- sanitizer_bitvector.h -----------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Specializer BitVector implementation.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SANITIZER_BITVECTOR_H
end_ifndef

begin_define
define|#
directive|define
name|SANITIZER_BITVECTOR_H
end_define

begin_include
include|#
directive|include
file|"sanitizer_common.h"
end_include

begin_decl_stmt
name|namespace
name|__sanitizer
block|{
comment|// Fixed size bit vector based on a single basic integer.
name|template
operator|<
name|class
name|basic_int_t
operator|=
name|uptr
operator|>
name|class
name|BasicBitVector
block|{
name|public
operator|:
expr|enum
name|SizeEnum
block|{
name|kSize
operator|=
sizeof|sizeof
argument_list|(
name|basic_int_t
argument_list|)
operator|*
literal|8
block|}
block|;
name|uptr
name|size
argument_list|()
specifier|const
block|{
return|return
name|kSize
return|;
block|}
comment|// No CTOR.
name|void
name|clear
argument_list|()
block|{
name|bits_
operator|=
literal|0
block|; }
name|void
name|setAll
argument_list|()
block|{
name|bits_
operator|=
operator|~
operator|(
name|basic_int_t
operator|)
literal|0
block|; }
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|bits_
operator|==
literal|0
return|;
block|}
comment|// Returns true if the bit has changed from 0 to 1.
name|bool
name|setBit
argument_list|(
argument|uptr idx
argument_list|)
block|{
name|basic_int_t
name|old
operator|=
name|bits_
block|;
name|bits_
operator||=
name|mask
argument_list|(
name|idx
argument_list|)
block|;
return|return
name|bits_
operator|!=
name|old
return|;
block|}
comment|// Returns true if the bit has changed from 1 to 0.
name|bool
name|clearBit
argument_list|(
argument|uptr idx
argument_list|)
block|{
name|basic_int_t
name|old
operator|=
name|bits_
block|;
name|bits_
operator|&=
operator|~
name|mask
argument_list|(
name|idx
argument_list|)
block|;
return|return
name|bits_
operator|!=
name|old
return|;
block|}
name|bool
name|getBit
argument_list|(
argument|uptr idx
argument_list|)
specifier|const
block|{
return|return
operator|(
name|bits_
operator|&
name|mask
argument_list|(
name|idx
argument_list|)
operator|)
operator|!=
literal|0
return|;
block|}
name|uptr
name|getAndClearFirstOne
argument_list|()
block|{
name|CHECK
argument_list|(
operator|!
name|empty
argument_list|()
argument_list|)
block|;
name|uptr
name|idx
operator|=
name|LeastSignificantSetBitIndex
argument_list|(
name|bits_
argument_list|)
block|;
name|clearBit
argument_list|(
name|idx
argument_list|)
block|;
return|return
name|idx
return|;
block|}
comment|// Do "this |= v" and return whether new bits have been added.
name|bool
name|setUnion
argument_list|(
argument|const BasicBitVector&v
argument_list|)
block|{
name|basic_int_t
name|old
operator|=
name|bits_
block|;
name|bits_
operator||=
name|v
operator|.
name|bits_
block|;
return|return
name|bits_
operator|!=
name|old
return|;
block|}
comment|// Do "this&= v" and return whether any bits have been removed.
name|bool
name|setIntersection
argument_list|(
argument|const BasicBitVector&v
argument_list|)
block|{
name|basic_int_t
name|old
operator|=
name|bits_
block|;
name|bits_
operator|&=
name|v
operator|.
name|bits_
block|;
return|return
name|bits_
operator|!=
name|old
return|;
block|}
comment|// Do "this&= ~v" and return whether any bits have been removed.
name|bool
name|setDifference
argument_list|(
argument|const BasicBitVector&v
argument_list|)
block|{
name|basic_int_t
name|old
operator|=
name|bits_
block|;
name|bits_
operator|&=
operator|~
name|v
operator|.
name|bits_
block|;
return|return
name|bits_
operator|!=
name|old
return|;
block|}
name|void
name|copyFrom
argument_list|(
argument|const BasicBitVector&v
argument_list|)
block|{
name|bits_
operator|=
name|v
operator|.
name|bits_
block|; }
comment|// Returns true if 'this' intersects with 'v'.
name|bool
name|intersectsWith
argument_list|(
argument|const BasicBitVector&v
argument_list|)
specifier|const
block|{
return|return
operator|(
name|bits_
operator|&
name|v
operator|.
name|bits_
operator|)
operator|!=
literal|0
return|;
block|}
comment|// for (BasicBitVector<>::Iterator it(bv); it.hasNext();) {
comment|//   uptr idx = it.next();
comment|//   use(idx);
comment|// }
name|class
name|Iterator
block|{
name|public
operator|:
name|Iterator
argument_list|()
block|{ }
name|explicit
name|Iterator
argument_list|(
specifier|const
name|BasicBitVector
operator|&
name|bv
argument_list|)
operator|:
name|bv_
argument_list|(
argument|bv
argument_list|)
block|{}
name|bool
name|hasNext
argument_list|()
specifier|const
block|{
return|return
operator|!
name|bv_
operator|.
name|empty
argument_list|()
return|;
block|}
name|uptr
name|next
argument_list|()
block|{
return|return
name|bv_
operator|.
name|getAndClearFirstOne
argument_list|()
return|;
block|}
name|void
name|clear
argument_list|()
block|{
name|bv_
operator|.
name|clear
argument_list|()
block|; }
name|private
operator|:
name|BasicBitVector
name|bv_
block|;   }
block|;
name|private
operator|:
name|basic_int_t
name|mask
argument_list|(
argument|uptr idx
argument_list|)
specifier|const
block|{
name|CHECK_LT
argument_list|(
name|idx
argument_list|,
name|size
argument_list|()
argument_list|)
block|;
return|return
operator|(
name|basic_int_t
operator|)
literal|1UL
operator|<<
name|idx
return|;
block|}
name|basic_int_t
name|bits_
block|; }
expr_stmt|;
comment|// Fixed size bit vector of (kLevel1Size*BV::kSize**2) bits.
comment|// The implementation is optimized for better performance on
comment|// sparse bit vectors, i.e. the those with few set bits.
name|template
operator|<
name|uptr
name|kLevel1Size
operator|=
literal|1
operator|,
name|class
name|BV
operator|=
name|BasicBitVector
operator|<
operator|>
expr|>
name|class
name|TwoLevelBitVector
block|{
comment|// This is essentially a 2-level bit vector.
comment|// Set bit in the first level BV indicates that there are set bits
comment|// in the corresponding BV of the second level.
comment|// This structure allows O(kLevel1Size) time for clear() and empty(),
comment|// as well fast handling of sparse BVs.
name|public
operator|:
expr|enum
name|SizeEnum
block|{
name|kSize
operator|=
name|BV
operator|::
name|kSize
operator|*
name|BV
operator|::
name|kSize
operator|*
name|kLevel1Size
block|}
block|;
comment|// No CTOR.
name|uptr
name|size
argument_list|()
specifier|const
block|{
return|return
name|kSize
return|;
block|}
name|void
name|clear
argument_list|()
block|{
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kLevel1Size
condition|;
name|i
operator|++
control|)
name|l1_
index|[
name|i
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|void
name|setAll
argument_list|()
block|{
for|for
control|(
name|uptr
name|i0
init|=
literal|0
init|;
name|i0
operator|<
name|kLevel1Size
condition|;
name|i0
operator|++
control|)
block|{
name|l1_
index|[
name|i0
index|]
operator|.
name|setAll
argument_list|()
expr_stmt|;
for|for
control|(
name|uptr
name|i1
init|=
literal|0
init|;
name|i1
operator|<
name|BV
operator|::
name|kSize
condition|;
name|i1
operator|++
control|)
name|l2_
index|[
name|i0
index|]
index|[
name|i1
index|]
operator|.
name|setAll
argument_list|()
expr_stmt|;
block|}
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kLevel1Size
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|l1_
index|[
name|i
index|]
operator|.
name|empty
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
comment|// Returns true if the bit has changed from 0 to 1.
name|bool
name|setBit
parameter_list|(
name|uptr
name|idx
parameter_list|)
block|{
name|check
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|uptr
name|i0
init|=
name|idx0
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|uptr
name|i1
init|=
name|idx1
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|uptr
name|i2
init|=
name|idx2
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|l1_
index|[
name|i0
index|]
operator|.
name|getBit
argument_list|(
name|i1
argument_list|)
condition|)
block|{
name|l1_
index|[
name|i0
index|]
operator|.
name|setBit
argument_list|(
name|i1
argument_list|)
expr_stmt|;
name|l2_
index|[
name|i0
index|]
index|[
name|i1
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|bool
name|res
init|=
name|l2_
index|[
name|i0
index|]
index|[
name|i1
index|]
operator|.
name|setBit
argument_list|(
name|i2
argument_list|)
decl_stmt|;
comment|// Printf("%s: %zd => %zd %zd %zd; %d\n", __func__,
comment|// idx, i0, i1, i2, res);
return|return
name|res
return|;
block|}
name|bool
name|clearBit
parameter_list|(
name|uptr
name|idx
parameter_list|)
block|{
name|check
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|uptr
name|i0
init|=
name|idx0
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|uptr
name|i1
init|=
name|idx1
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|uptr
name|i2
init|=
name|idx2
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|bool
name|res
init|=
name|false
decl_stmt|;
if|if
condition|(
name|l1_
index|[
name|i0
index|]
operator|.
name|getBit
argument_list|(
name|i1
argument_list|)
condition|)
block|{
name|res
operator|=
name|l2_
index|[
name|i0
index|]
index|[
name|i1
index|]
operator|.
name|clearBit
argument_list|(
name|i2
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2_
index|[
name|i0
index|]
index|[
name|i1
index|]
operator|.
name|empty
argument_list|()
condition|)
name|l1_
index|[
name|i0
index|]
operator|.
name|clearBit
argument_list|(
name|i1
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
name|bool
name|getBit
argument_list|(
name|uptr
name|idx
argument_list|)
decl|const
block|{
name|check
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|uptr
name|i0
init|=
name|idx0
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|uptr
name|i1
init|=
name|idx1
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|uptr
name|i2
init|=
name|idx2
argument_list|(
name|idx
argument_list|)
decl_stmt|;
comment|// Printf("%s: %zd => %zd %zd %zd\n", __func__, idx, i0, i1, i2);
return|return
name|l1_
index|[
name|i0
index|]
operator|.
name|getBit
argument_list|(
name|i1
argument_list|)
operator|&&
name|l2_
index|[
name|i0
index|]
index|[
name|i1
index|]
operator|.
name|getBit
argument_list|(
name|i2
argument_list|)
return|;
block|}
name|uptr
name|getAndClearFirstOne
parameter_list|()
block|{
for|for
control|(
name|uptr
name|i0
init|=
literal|0
init|;
name|i0
operator|<
name|kLevel1Size
condition|;
name|i0
operator|++
control|)
block|{
if|if
condition|(
name|l1_
index|[
name|i0
index|]
operator|.
name|empty
argument_list|()
condition|)
continue|continue;
name|uptr
name|i1
init|=
name|l1_
index|[
name|i0
index|]
operator|.
name|getAndClearFirstOne
argument_list|()
decl_stmt|;
name|uptr
name|i2
init|=
name|l2_
index|[
name|i0
index|]
index|[
name|i1
index|]
operator|.
name|getAndClearFirstOne
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|l2_
index|[
name|i0
index|]
index|[
name|i1
index|]
operator|.
name|empty
argument_list|()
condition|)
name|l1_
index|[
name|i0
index|]
operator|.
name|setBit
argument_list|(
name|i1
argument_list|)
expr_stmt|;
name|uptr
name|res
init|=
name|i0
operator|*
name|BV
operator|::
name|kSize
operator|*
name|BV
operator|::
name|kSize
operator|+
name|i1
operator|*
name|BV
operator|::
name|kSize
operator|+
name|i2
decl_stmt|;
comment|// Printf("getAndClearFirstOne: %zd %zd %zd => %zd\n", i0, i1, i2, res);
return|return
name|res
return|;
block|}
name|CHECK
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|// Do "this |= v" and return whether new bits have been added.
name|bool
name|setUnion
parameter_list|(
specifier|const
name|TwoLevelBitVector
modifier|&
name|v
parameter_list|)
block|{
name|bool
name|res
init|=
name|false
decl_stmt|;
for|for
control|(
name|uptr
name|i0
init|=
literal|0
init|;
name|i0
operator|<
name|kLevel1Size
condition|;
name|i0
operator|++
control|)
block|{
name|BV
name|t
init|=
name|v
operator|.
name|l1_
index|[
name|i0
index|]
decl_stmt|;
while|while
condition|(
operator|!
name|t
operator|.
name|empty
argument_list|()
condition|)
block|{
name|uptr
name|i1
init|=
name|t
operator|.
name|getAndClearFirstOne
argument_list|()
decl_stmt|;
if|if
condition|(
name|l1_
index|[
name|i0
index|]
operator|.
name|setBit
argument_list|(
name|i1
argument_list|)
condition|)
name|l2_
index|[
name|i0
index|]
index|[
name|i1
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|l2_
index|[
name|i0
index|]
index|[
name|i1
index|]
operator|.
name|setUnion
argument_list|(
name|v
operator|.
name|l2_
index|[
name|i0
index|]
index|[
name|i1
index|]
argument_list|)
condition|)
name|res
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
comment|// Do "this&= v" and return whether any bits have been removed.
name|bool
name|setIntersection
parameter_list|(
specifier|const
name|TwoLevelBitVector
modifier|&
name|v
parameter_list|)
block|{
name|bool
name|res
init|=
name|false
decl_stmt|;
for|for
control|(
name|uptr
name|i0
init|=
literal|0
init|;
name|i0
operator|<
name|kLevel1Size
condition|;
name|i0
operator|++
control|)
block|{
if|if
condition|(
name|l1_
index|[
name|i0
index|]
operator|.
name|setIntersection
argument_list|(
name|v
operator|.
name|l1_
index|[
name|i0
index|]
argument_list|)
condition|)
name|res
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|l1_
index|[
name|i0
index|]
operator|.
name|empty
argument_list|()
condition|)
block|{
name|BV
name|t
init|=
name|l1_
index|[
name|i0
index|]
decl_stmt|;
while|while
condition|(
operator|!
name|t
operator|.
name|empty
argument_list|()
condition|)
block|{
name|uptr
name|i1
init|=
name|t
operator|.
name|getAndClearFirstOne
argument_list|()
decl_stmt|;
if|if
condition|(
name|l2_
index|[
name|i0
index|]
index|[
name|i1
index|]
operator|.
name|setIntersection
argument_list|(
name|v
operator|.
name|l2_
index|[
name|i0
index|]
index|[
name|i1
index|]
argument_list|)
condition|)
name|res
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|l2_
index|[
name|i0
index|]
index|[
name|i1
index|]
operator|.
name|empty
argument_list|()
condition|)
name|l1_
index|[
name|i0
index|]
operator|.
name|clearBit
argument_list|(
name|i1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|res
return|;
block|}
comment|// Do "this&= ~v" and return whether any bits have been removed.
name|bool
name|setDifference
parameter_list|(
specifier|const
name|TwoLevelBitVector
modifier|&
name|v
parameter_list|)
block|{
name|bool
name|res
init|=
name|false
decl_stmt|;
for|for
control|(
name|uptr
name|i0
init|=
literal|0
init|;
name|i0
operator|<
name|kLevel1Size
condition|;
name|i0
operator|++
control|)
block|{
name|BV
name|t
init|=
name|l1_
index|[
name|i0
index|]
decl_stmt|;
name|t
operator|.
name|setIntersection
argument_list|(
name|v
operator|.
name|l1_
index|[
name|i0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|t
operator|.
name|empty
argument_list|()
condition|)
block|{
name|uptr
name|i1
init|=
name|t
operator|.
name|getAndClearFirstOne
argument_list|()
decl_stmt|;
if|if
condition|(
name|l2_
index|[
name|i0
index|]
index|[
name|i1
index|]
operator|.
name|setDifference
argument_list|(
name|v
operator|.
name|l2_
index|[
name|i0
index|]
index|[
name|i1
index|]
argument_list|)
condition|)
name|res
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|l2_
index|[
name|i0
index|]
index|[
name|i1
index|]
operator|.
name|empty
argument_list|()
condition|)
name|l1_
index|[
name|i0
index|]
operator|.
name|clearBit
argument_list|(
name|i1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
name|void
name|copyFrom
parameter_list|(
specifier|const
name|TwoLevelBitVector
modifier|&
name|v
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|setUnion
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
comment|// Returns true if 'this' intersects with 'v'.
name|bool
name|intersectsWith
argument_list|(
specifier|const
name|TwoLevelBitVector
operator|&
name|v
argument_list|)
decl|const
block|{
for|for
control|(
name|uptr
name|i0
init|=
literal|0
init|;
name|i0
operator|<
name|kLevel1Size
condition|;
name|i0
operator|++
control|)
block|{
name|BV
name|t
init|=
name|l1_
index|[
name|i0
index|]
decl_stmt|;
name|t
operator|.
name|setIntersection
argument_list|(
name|v
operator|.
name|l1_
index|[
name|i0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|t
operator|.
name|empty
argument_list|()
condition|)
block|{
name|uptr
name|i1
init|=
name|t
operator|.
name|getAndClearFirstOne
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|v
operator|.
name|l1_
index|[
name|i0
index|]
operator|.
name|getBit
argument_list|(
name|i1
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|l2_
index|[
name|i0
index|]
index|[
name|i1
index|]
operator|.
name|intersectsWith
argument_list|(
name|v
operator|.
name|l2_
index|[
name|i0
index|]
index|[
name|i1
index|]
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
comment|// for (TwoLevelBitVector<>::Iterator it(bv); it.hasNext();) {
comment|//   uptr idx = it.next();
comment|//   use(idx);
comment|// }
name|class
name|Iterator
block|{
name|public
label|:
name|Iterator
argument_list|()
block|{ }
name|explicit
name|Iterator
argument_list|(
specifier|const
name|TwoLevelBitVector
operator|&
name|bv
argument_list|)
operator|:
name|bv_
argument_list|(
name|bv
argument_list|)
operator|,
name|i0_
argument_list|(
literal|0
argument_list|)
operator|,
name|i1_
argument_list|(
literal|0
argument_list|)
block|{
name|it1_
operator|.
name|clear
argument_list|()
block|;
name|it2_
operator|.
name|clear
argument_list|()
block|;     }
name|bool
name|hasNext
argument_list|()
specifier|const
block|{
if|if
condition|(
name|it1_
operator|.
name|hasNext
argument_list|()
condition|)
return|return
name|true
return|;
for|for
control|(
name|uptr
name|i
init|=
name|i0_
init|;
name|i
operator|<
name|kLevel1Size
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|bv_
operator|.
name|l1_
index|[
name|i
index|]
operator|.
name|empty
argument_list|()
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
name|uptr
name|next
parameter_list|()
block|{
comment|// Printf("++++: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
comment|//       it2_.hasNext(), kSize);
if|if
condition|(
operator|!
name|it1_
operator|.
name|hasNext
argument_list|()
operator|&&
operator|!
name|it2_
operator|.
name|hasNext
argument_list|()
condition|)
block|{
for|for
control|(
init|;
name|i0_
operator|<
name|kLevel1Size
condition|;
name|i0_
operator|++
control|)
block|{
if|if
condition|(
name|bv_
operator|.
name|l1_
index|[
name|i0_
index|]
operator|.
name|empty
argument_list|()
condition|)
continue|continue;
name|it1_
operator|=
name|typename
name|BV
operator|::
name|Iterator
argument_list|(
name|bv_
operator|.
name|l1_
index|[
name|i0_
index|]
argument_list|)
expr_stmt|;
comment|// Printf("+i0: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
comment|//   it2_.hasNext(), kSize);
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|it2_
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|CHECK
argument_list|(
name|it1_
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|i1_
operator|=
name|it1_
operator|.
name|next
argument_list|()
expr_stmt|;
name|it2_
operator|=
name|typename
name|BV
operator|::
name|Iterator
argument_list|(
name|bv_
operator|.
name|l2_
index|[
name|i0_
index|]
index|[
name|i1_
index|]
argument_list|)
expr_stmt|;
comment|// Printf("++i1: %zd %zd; %d %d; size %zd\n", i0_, i1_, it1_.hasNext(),
comment|//       it2_.hasNext(), kSize);
block|}
name|CHECK
argument_list|(
name|it2_
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|uptr
name|i2
init|=
name|it2_
operator|.
name|next
argument_list|()
decl_stmt|;
name|uptr
name|res
init|=
name|i0_
operator|*
name|BV
operator|::
name|kSize
operator|*
name|BV
operator|::
name|kSize
operator|+
name|i1_
operator|*
name|BV
operator|::
name|kSize
operator|+
name|i2
decl_stmt|;
comment|// Printf("+ret: %zd %zd; %d %d; size %zd; res: %zd\n", i0_, i1_,
comment|//       it1_.hasNext(), it2_.hasNext(), kSize, res);
if|if
condition|(
operator|!
name|it1_
operator|.
name|hasNext
argument_list|()
operator|&&
operator|!
name|it2_
operator|.
name|hasNext
argument_list|()
condition|)
name|i0_
operator|++
expr_stmt|;
return|return
name|res
return|;
block|}
name|private
label|:
specifier|const
name|TwoLevelBitVector
modifier|&
name|bv_
decl_stmt|;
name|uptr
name|i0_
decl_stmt|,
name|i1_
decl_stmt|;
name|typename
name|BV
operator|::
name|Iterator
name|it1_
operator|,
name|it2_
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|void
name|check
argument_list|(
name|uptr
name|idx
argument_list|)
decl|const
block|{
name|CHECK_LE
argument_list|(
name|idx
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|uptr
name|idx0
argument_list|(
name|uptr
name|idx
argument_list|)
decl|const
block|{
name|uptr
name|res
init|=
name|idx
operator|/
operator|(
name|BV
operator|::
name|kSize
operator|*
name|BV
operator|::
name|kSize
operator|)
decl_stmt|;
name|CHECK_LE
argument_list|(
name|res
argument_list|,
name|kLevel1Size
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|uptr
name|idx1
argument_list|(
name|uptr
name|idx
argument_list|)
decl|const
block|{
name|uptr
name|res
init|=
operator|(
name|idx
operator|/
name|BV
operator|::
name|kSize
operator|)
operator|%
name|BV
operator|::
name|kSize
decl_stmt|;
name|CHECK_LE
argument_list|(
name|res
argument_list|,
name|BV
operator|::
name|kSize
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|uptr
name|idx2
argument_list|(
name|uptr
name|idx
argument_list|)
decl|const
block|{
name|uptr
name|res
init|=
name|idx
operator|%
name|BV
operator|::
name|kSize
decl_stmt|;
name|CHECK_LE
argument_list|(
name|res
argument_list|,
name|BV
operator|::
name|kSize
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|BV
name|l1_
index|[
name|kLevel1Size
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BV
name|l2_
index|[
name|kLevel1Size
index|]
index|[
name|BV
operator|::
name|kSize
index|]
decl_stmt|;
end_decl_stmt

begin_comment
unit|};  }
comment|// namespace __sanitizer
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// SANITIZER_BITVECTOR_H
end_comment

end_unit

