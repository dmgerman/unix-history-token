begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- sanitizer_deadlock_detector.h ---------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is a part of Sanitizer runtime.
end_comment

begin_comment
comment|// The deadlock detector maintains a directed graph of lock acquisitions.
end_comment

begin_comment
comment|// When a lock event happens, the detector checks if the locks already held by
end_comment

begin_comment
comment|// the current thread are reachable from the newly acquired lock.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The detector can handle only a fixed amount of simultaneously live locks
end_comment

begin_comment
comment|// (a lock is alive if it has been locked at least once and has not been
end_comment

begin_comment
comment|// destroyed). When the maximal number of locks is reached the entire graph
end_comment

begin_comment
comment|// is flushed and the new lock epoch is started. The node ids from the old
end_comment

begin_comment
comment|// epochs can not be used with any of the detector methods except for
end_comment

begin_comment
comment|// nodeBelongsToCurrentEpoch().
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// FIXME: this is work in progress, nothing really works yet.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SANITIZER_DEADLOCK_DETECTOR_H
end_ifndef

begin_define
define|#
directive|define
name|SANITIZER_DEADLOCK_DETECTOR_H
end_define

begin_include
include|#
directive|include
file|"sanitizer_common.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_bvgraph.h"
end_include

begin_decl_stmt
name|namespace
name|__sanitizer
block|{
comment|// Thread-local state for DeadlockDetector.
comment|// It contains the locks currently held by the owning thread.
name|template
operator|<
name|class
name|BV
operator|>
name|class
name|DeadlockDetectorTLS
block|{
name|public
operator|:
comment|// No CTOR.
name|void
name|clear
argument_list|()
block|{
name|bv_
operator|.
name|clear
argument_list|()
block|;
name|epoch_
operator|=
literal|0
block|;
name|n_recursive_locks
operator|=
literal|0
block|;
name|n_all_locks_
operator|=
literal|0
block|;   }
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|bv_
operator|.
name|empty
argument_list|()
return|;
block|}
name|void
name|ensureCurrentEpoch
argument_list|(
argument|uptr current_epoch
argument_list|)
block|{
if|if
condition|(
name|epoch_
operator|==
name|current_epoch
condition|)
return|return;
name|bv_
operator|.
name|clear
argument_list|()
block|;
name|epoch_
operator|=
name|current_epoch
block|;   }
name|uptr
name|getEpoch
argument_list|()
specifier|const
block|{
return|return
name|epoch_
return|;
block|}
comment|// Returns true if this is the first (non-recursive) acquisition of this lock.
name|bool
name|addLock
parameter_list|(
name|uptr
name|lock_id
parameter_list|,
name|uptr
name|current_epoch
parameter_list|,
name|u32
name|stk
parameter_list|)
block|{
comment|// Printf("addLock: %zx %zx stk %u\n", lock_id, current_epoch, stk);
name|CHECK_EQ
argument_list|(
name|epoch_
argument_list|,
name|current_epoch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bv_
operator|.
name|setBit
argument_list|(
name|lock_id
argument_list|)
condition|)
block|{
comment|// The lock is already held by this thread, it must be recursive.
name|CHECK_LT
argument_list|(
name|n_recursive_locks
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|recursive_locks
argument_list|)
argument_list|)
expr_stmt|;
name|recursive_locks
index|[
name|n_recursive_locks
operator|++
index|]
operator|=
name|lock_id
expr_stmt|;
return|return
name|false
return|;
block|}
name|CHECK_LT
argument_list|(
name|n_all_locks_
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|all_locks_with_contexts_
argument_list|)
argument_list|)
expr_stmt|;
comment|// lock_id< BV::kSize, can cast to a smaller int.
name|u32
name|lock_id_short
init|=
name|static_cast
operator|<
name|u32
operator|>
operator|(
name|lock_id
operator|)
decl_stmt|;
name|LockWithContext
name|l
init|=
block|{
name|lock_id_short
block|,
name|stk
block|}
decl_stmt|;
name|all_locks_with_contexts_
index|[
name|n_all_locks_
operator|++
index|]
operator|=
name|l
expr_stmt|;
return|return
name|true
return|;
block|}
name|void
name|removeLock
parameter_list|(
name|uptr
name|lock_id
parameter_list|)
block|{
if|if
condition|(
name|n_recursive_locks
condition|)
block|{
for|for
control|(
name|sptr
name|i
init|=
name|n_recursive_locks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|recursive_locks
index|[
name|i
index|]
operator|==
name|lock_id
condition|)
block|{
name|n_recursive_locks
operator|--
expr_stmt|;
name|Swap
argument_list|(
name|recursive_locks
index|[
name|i
index|]
argument_list|,
name|recursive_locks
index|[
name|n_recursive_locks
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// Printf("remLock: %zx %zx\n", lock_id, epoch_);
name|CHECK
argument_list|(
name|bv_
operator|.
name|clearBit
argument_list|(
name|lock_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_all_locks_
condition|)
block|{
for|for
control|(
name|sptr
name|i
init|=
name|n_all_locks_
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|all_locks_with_contexts_
index|[
name|i
index|]
operator|.
name|lock
operator|==
name|static_cast
operator|<
name|u32
operator|>
operator|(
name|lock_id
operator|)
condition|)
block|{
name|Swap
argument_list|(
name|all_locks_with_contexts_
index|[
name|i
index|]
argument_list|,
name|all_locks_with_contexts_
index|[
name|n_all_locks_
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|n_all_locks_
operator|--
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|u32
name|findLockContext
parameter_list|(
name|uptr
name|lock_id
parameter_list|)
block|{
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n_all_locks_
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|all_locks_with_contexts_
index|[
name|i
index|]
operator|.
name|lock
operator|==
name|static_cast
operator|<
name|u32
operator|>
operator|(
name|lock_id
operator|)
condition|)
return|return
name|all_locks_with_contexts_
index|[
name|i
index|]
operator|.
name|stk
return|;
return|return
literal|0
return|;
block|}
specifier|const
name|BV
modifier|&
name|getLocks
argument_list|(
name|uptr
name|current_epoch
argument_list|)
decl|const
block|{
name|CHECK_EQ
argument_list|(
name|epoch_
argument_list|,
name|current_epoch
argument_list|)
expr_stmt|;
return|return
name|bv_
return|;
block|}
name|uptr
name|getNumLocks
argument_list|()
specifier|const
block|{
return|return
name|n_all_locks_
return|;
block|}
name|uptr
name|getLock
argument_list|(
name|uptr
name|idx
argument_list|)
decl|const
block|{
return|return
name|all_locks_with_contexts_
index|[
name|idx
index|]
operator|.
name|lock
return|;
block|}
name|private
label|:
name|BV
name|bv_
decl_stmt|;
name|uptr
name|epoch_
decl_stmt|;
name|uptr
name|recursive_locks
index|[
literal|64
index|]
decl_stmt|;
name|uptr
name|n_recursive_locks
decl_stmt|;
struct|struct
name|LockWithContext
block|{
name|u32
name|lock
decl_stmt|;
name|u32
name|stk
decl_stmt|;
block|}
struct|;
name|LockWithContext
name|all_locks_with_contexts_
index|[
literal|64
index|]
decl_stmt|;
name|uptr
name|n_all_locks_
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// DeadlockDetector.
end_comment

begin_comment
comment|// For deadlock detection to work we need one global DeadlockDetector object
end_comment

begin_comment
comment|// and one DeadlockDetectorTLS object per evey thread.
end_comment

begin_comment
comment|// This class is not thread safe, all concurrent accesses should be guarded
end_comment

begin_comment
comment|// by an external lock.
end_comment

begin_comment
comment|// Most of the methods of this class are not thread-safe (i.e. should
end_comment

begin_comment
comment|// be protected by an external lock) unless explicitly told otherwise.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|BV
operator|>
name|class
name|DeadlockDetector
block|{
name|public
operator|:
typedef|typedef
name|BV
name|BitVector
typedef|;
name|uptr
name|size
argument_list|()
specifier|const
block|{
return|return
name|g_
operator|.
name|size
argument_list|()
return|;
block|}
comment|// No CTOR.
name|void
name|clear
argument_list|()
block|{
name|current_epoch_
operator|=
literal|0
block|;
name|available_nodes_
operator|.
name|clear
argument_list|()
block|;
name|recycled_nodes_
operator|.
name|clear
argument_list|()
block|;
name|g_
operator|.
name|clear
argument_list|()
block|;
name|n_edges_
operator|=
literal|0
block|;   }
comment|// Allocate new deadlock detector node.
comment|// If we are out of available nodes first try to recycle some.
comment|// If there is nothing to recycle, flush the graph and increment the epoch.
comment|// Associate 'data' (opaque user's object) with the new node.
name|uptr
name|newNode
argument_list|(
argument|uptr data
argument_list|)
block|{
if|if
condition|(
operator|!
name|available_nodes_
operator|.
name|empty
argument_list|()
condition|)
return|return
name|getAvailableNode
argument_list|(
name|data
argument_list|)
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|recycled_nodes_
operator|.
name|empty
argument_list|()
condition|)
block|{
comment|// Printf("recycling: n_edges_ %zd\n", n_edges_);
for|for
control|(
name|sptr
name|i
init|=
name|n_edges_
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|recycled_nodes_
operator|.
name|getBit
argument_list|(
name|edges_
index|[
name|i
index|]
operator|.
name|from
argument_list|)
operator|||
name|recycled_nodes_
operator|.
name|getBit
argument_list|(
name|edges_
index|[
name|i
index|]
operator|.
name|to
argument_list|)
condition|)
block|{
name|Swap
argument_list|(
name|edges_
index|[
name|i
index|]
argument_list|,
name|edges_
index|[
name|n_edges_
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|n_edges_
operator|--
expr_stmt|;
block|}
block|}
name|CHECK
argument_list|(
name|available_nodes_
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
comment|// removeEdgesFrom was called in removeNode.
name|g_
operator|.
name|removeEdgesTo
argument_list|(
name|recycled_nodes_
argument_list|)
expr_stmt|;
name|available_nodes_
operator|.
name|setUnion
argument_list|(
name|recycled_nodes_
argument_list|)
expr_stmt|;
name|recycled_nodes_
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|getAvailableNode
argument_list|(
name|data
argument_list|)
return|;
block|}
end_if

begin_comment
comment|// We are out of vacant nodes. Flush and increment the current_epoch_.
end_comment

begin_expr_stmt
name|current_epoch_
operator|+=
name|size
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|recycled_nodes_
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|available_nodes_
operator|.
name|setAll
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|g_
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|getAvailableNode
argument_list|(
name|data
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|// Get data associated with the node created by newNode().
end_comment

begin_macro
unit|uptr
name|getData
argument_list|(
argument|uptr node
argument_list|)
end_macro

begin_expr_stmt
specifier|const
block|{
return|return
name|data_
index|[
name|nodeToIndex
argument_list|(
name|node
argument_list|)
index|]
return|;
block|}
end_expr_stmt

begin_function
name|bool
name|nodeBelongsToCurrentEpoch
parameter_list|(
name|uptr
name|node
parameter_list|)
block|{
return|return
name|node
operator|&&
operator|(
name|node
operator|/
name|size
argument_list|()
operator|*
name|size
argument_list|()
operator|)
operator|==
name|current_epoch_
return|;
block|}
end_function

begin_function
name|void
name|removeNode
parameter_list|(
name|uptr
name|node
parameter_list|)
block|{
name|uptr
name|idx
init|=
name|nodeToIndex
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|CHECK
argument_list|(
operator|!
name|available_nodes_
operator|.
name|getBit
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|recycled_nodes_
operator|.
name|setBit
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|g_
operator|.
name|removeEdgesFrom
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|ensureCurrentEpoch
argument_list|(
name|DeadlockDetectorTLS
operator|<
name|BV
operator|>
operator|*
name|dtls
argument_list|)
block|{
name|dtls
operator|->
name|ensureCurrentEpoch
argument_list|(
name|current_epoch_
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// Returns true if there is a cycle in the graph after this lock event.
end_comment

begin_comment
comment|// Ideally should be called before the lock is acquired so that we can
end_comment

begin_comment
comment|// report a deadlock before a real deadlock happens.
end_comment

begin_decl_stmt
name|bool
name|onLockBefore
argument_list|(
name|DeadlockDetectorTLS
operator|<
name|BV
operator|>
operator|*
name|dtls
argument_list|,
name|uptr
name|cur_node
argument_list|)
block|{
name|ensureCurrentEpoch
argument_list|(
name|dtls
argument_list|)
expr_stmt|;
name|uptr
name|cur_idx
init|=
name|nodeToIndex
argument_list|(
name|cur_node
argument_list|)
decl_stmt|;
return|return
name|g_
operator|.
name|isReachable
argument_list|(
name|cur_idx
argument_list|,
name|dtls
operator|->
name|getLocks
argument_list|(
name|current_epoch_
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|u32
name|findLockContext
argument_list|(
name|DeadlockDetectorTLS
operator|<
name|BV
operator|>
operator|*
name|dtls
argument_list|,
name|uptr
name|node
argument_list|)
block|{
return|return
name|dtls
operator|->
name|findLockContext
argument_list|(
name|nodeToIndex
argument_list|(
name|node
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|// Add cur_node to the set of locks held currently by dtls.
end_comment

begin_decl_stmt
name|void
name|onLockAfter
argument_list|(
name|DeadlockDetectorTLS
operator|<
name|BV
operator|>
operator|*
name|dtls
argument_list|,
name|uptr
name|cur_node
argument_list|,
name|u32
name|stk
operator|=
literal|0
argument_list|)
block|{
name|ensureCurrentEpoch
argument_list|(
name|dtls
argument_list|)
expr_stmt|;
name|uptr
name|cur_idx
init|=
name|nodeToIndex
argument_list|(
name|cur_node
argument_list|)
decl_stmt|;
name|dtls
operator|->
name|addLock
argument_list|(
name|cur_idx
argument_list|,
name|current_epoch_
argument_list|,
name|stk
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// Experimental *racy* fast path function.
end_comment

begin_comment
comment|// Returns true if all edges from the currently held locks to cur_node exist.
end_comment

begin_decl_stmt
name|bool
name|hasAllEdges
argument_list|(
name|DeadlockDetectorTLS
operator|<
name|BV
operator|>
operator|*
name|dtls
argument_list|,
name|uptr
name|cur_node
argument_list|)
block|{
name|uptr
name|local_epoch
init|=
name|dtls
operator|->
name|getEpoch
argument_list|()
decl_stmt|;
comment|// Read from current_epoch_ is racy.
if|if
condition|(
name|cur_node
operator|&&
name|local_epoch
operator|==
name|current_epoch_
operator|&&
name|local_epoch
operator|==
name|nodeToEpoch
argument_list|(
name|cur_node
argument_list|)
condition|)
block|{
name|uptr
name|cur_idx
init|=
name|nodeToIndexUnchecked
argument_list|(
name|cur_node
argument_list|)
decl_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|,
name|n
init|=
name|dtls
operator|->
name|getNumLocks
argument_list|()
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|g_
operator|.
name|hasEdge
argument_list|(
name|dtls
operator|->
name|getLock
argument_list|(
name|i
argument_list|)
argument_list|,
name|cur_idx
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|// Adds edges from currently held locks to cur_node,
end_comment

begin_comment
comment|// returns the number of added edges, and puts the sources of added edges
end_comment

begin_comment
comment|// into added_edges[].
end_comment

begin_comment
comment|// Should be called before onLockAfter.
end_comment

begin_decl_stmt
name|uptr
name|addEdges
argument_list|(
name|DeadlockDetectorTLS
operator|<
name|BV
operator|>
operator|*
name|dtls
argument_list|,
name|uptr
name|cur_node
argument_list|,
name|u32
name|stk
argument_list|,
name|int
name|unique_tid
argument_list|)
block|{
name|ensureCurrentEpoch
argument_list|(
name|dtls
argument_list|)
expr_stmt|;
name|uptr
name|cur_idx
init|=
name|nodeToIndex
argument_list|(
name|cur_node
argument_list|)
decl_stmt|;
name|uptr
name|added_edges
index|[
literal|40
index|]
decl_stmt|;
name|uptr
name|n_added_edges
init|=
name|g_
operator|.
name|addEdges
argument_list|(
name|dtls
operator|->
name|getLocks
argument_list|(
name|current_epoch_
argument_list|)
argument_list|,
name|cur_idx
argument_list|,
name|added_edges
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|added_edges
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n_added_edges
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|n_edges_
operator|<
name|ARRAY_SIZE
argument_list|(
name|edges_
argument_list|)
condition|)
block|{
name|Edge
name|e
init|=
block|{
operator|(
name|u16
operator|)
name|added_edges
index|[
name|i
index|]
block|,
operator|(
name|u16
operator|)
name|cur_idx
block|,
name|dtls
operator|->
name|findLockContext
argument_list|(
name|added_edges
index|[
name|i
index|]
argument_list|)
block|,
name|stk
block|,
name|unique_tid
block|}
decl_stmt|;
name|edges_
index|[
name|n_edges_
operator|++
index|]
operator|=
name|e
expr_stmt|;
block|}
comment|// Printf("Edge%zd: %u %zd=>%zd in T%d\n",
comment|//        n_edges_, stk, added_edges[i], cur_idx, unique_tid);
block|}
return|return
name|n_added_edges
return|;
block|}
end_decl_stmt

begin_function
name|bool
name|findEdge
parameter_list|(
name|uptr
name|from_node
parameter_list|,
name|uptr
name|to_node
parameter_list|,
name|u32
modifier|*
name|stk_from
parameter_list|,
name|u32
modifier|*
name|stk_to
parameter_list|,
name|int
modifier|*
name|unique_tid
parameter_list|)
block|{
name|uptr
name|from_idx
init|=
name|nodeToIndex
argument_list|(
name|from_node
argument_list|)
decl_stmt|;
name|uptr
name|to_idx
init|=
name|nodeToIndex
argument_list|(
name|to_node
argument_list|)
decl_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n_edges_
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|edges_
index|[
name|i
index|]
operator|.
name|from
operator|==
name|from_idx
operator|&&
name|edges_
index|[
name|i
index|]
operator|.
name|to
operator|==
name|to_idx
condition|)
block|{
operator|*
name|stk_from
operator|=
name|edges_
index|[
name|i
index|]
operator|.
name|stk_from
expr_stmt|;
operator|*
name|stk_to
operator|=
name|edges_
index|[
name|i
index|]
operator|.
name|stk_to
expr_stmt|;
operator|*
name|unique_tid
operator|=
name|edges_
index|[
name|i
index|]
operator|.
name|unique_tid
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|// Test-only function. Handles the before/after lock events,
end_comment

begin_comment
comment|// returns true if there is a cycle.
end_comment

begin_decl_stmt
name|bool
name|onLock
argument_list|(
name|DeadlockDetectorTLS
operator|<
name|BV
operator|>
operator|*
name|dtls
argument_list|,
name|uptr
name|cur_node
argument_list|,
name|u32
name|stk
operator|=
literal|0
argument_list|)
block|{
name|ensureCurrentEpoch
argument_list|(
name|dtls
argument_list|)
expr_stmt|;
name|bool
name|is_reachable
init|=
operator|!
name|isHeld
argument_list|(
name|dtls
argument_list|,
name|cur_node
argument_list|)
operator|&&
name|onLockBefore
argument_list|(
name|dtls
argument_list|,
name|cur_node
argument_list|)
decl_stmt|;
name|addEdges
argument_list|(
name|dtls
argument_list|,
name|cur_node
argument_list|,
name|stk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|onLockAfter
argument_list|(
name|dtls
argument_list|,
name|cur_node
argument_list|,
name|stk
argument_list|)
expr_stmt|;
return|return
name|is_reachable
return|;
block|}
end_decl_stmt

begin_comment
comment|// Handles the try_lock event, returns false.
end_comment

begin_comment
comment|// When a try_lock event happens (i.e. a try_lock call succeeds) we need
end_comment

begin_comment
comment|// to add this lock to the currently held locks, but we should not try to
end_comment

begin_comment
comment|// change the lock graph or to detect a cycle.  We may want to investigate
end_comment

begin_comment
comment|// whether a more aggressive strategy is possible for try_lock.
end_comment

begin_decl_stmt
name|bool
name|onTryLock
argument_list|(
name|DeadlockDetectorTLS
operator|<
name|BV
operator|>
operator|*
name|dtls
argument_list|,
name|uptr
name|cur_node
argument_list|,
name|u32
name|stk
operator|=
literal|0
argument_list|)
block|{
name|ensureCurrentEpoch
argument_list|(
name|dtls
argument_list|)
expr_stmt|;
name|uptr
name|cur_idx
init|=
name|nodeToIndex
argument_list|(
name|cur_node
argument_list|)
decl_stmt|;
name|dtls
operator|->
name|addLock
argument_list|(
name|cur_idx
argument_list|,
name|current_epoch_
argument_list|,
name|stk
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|// Returns true iff dtls is empty (no locks are currently held) and we can
end_comment

begin_comment
comment|// add the node to the currently held locks w/o chanding the global state.
end_comment

begin_comment
comment|// This operation is thread-safe as it only touches the dtls.
end_comment

begin_decl_stmt
name|bool
name|onFirstLock
argument_list|(
name|DeadlockDetectorTLS
operator|<
name|BV
operator|>
operator|*
name|dtls
argument_list|,
name|uptr
name|node
argument_list|,
name|u32
name|stk
operator|=
literal|0
argument_list|)
block|{
if|if
condition|(
operator|!
name|dtls
operator|->
name|empty
argument_list|()
condition|)
return|return
name|false
return|;
if|if
condition|(
name|dtls
operator|->
name|getEpoch
argument_list|()
operator|&&
name|dtls
operator|->
name|getEpoch
argument_list|()
operator|==
name|nodeToEpoch
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|dtls
operator|->
name|addLock
argument_list|(
name|nodeToIndexUnchecked
argument_list|(
name|node
argument_list|)
argument_list|,
name|nodeToEpoch
argument_list|(
name|node
argument_list|)
argument_list|,
name|stk
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|// Finds a path between the lock 'cur_node' (currently not held in dtls)
end_comment

begin_comment
comment|// and some currently held lock, returns the length of the path
end_comment

begin_comment
comment|// or 0 on failure.
end_comment

begin_decl_stmt
name|uptr
name|findPathToLock
argument_list|(
name|DeadlockDetectorTLS
operator|<
name|BV
operator|>
operator|*
name|dtls
argument_list|,
name|uptr
name|cur_node
argument_list|,
name|uptr
operator|*
name|path
argument_list|,
name|uptr
name|path_size
argument_list|)
block|{
name|tmp_bv_
operator|.
name|copyFrom
argument_list|(
name|dtls
operator|->
name|getLocks
argument_list|(
name|current_epoch_
argument_list|)
argument_list|)
expr_stmt|;
name|uptr
name|idx
init|=
name|nodeToIndex
argument_list|(
name|cur_node
argument_list|)
decl_stmt|;
name|CHECK
argument_list|(
operator|!
name|tmp_bv_
operator|.
name|getBit
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|uptr
name|res
init|=
name|g_
operator|.
name|findShortestPath
argument_list|(
name|idx
argument_list|,
name|tmp_bv_
argument_list|,
name|path
argument_list|,
name|path_size
argument_list|)
decl_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res
condition|;
name|i
operator|++
control|)
name|path
index|[
name|i
index|]
operator|=
name|indexToNode
argument_list|(
name|path
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
name|CHECK_EQ
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|,
name|cur_node
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_decl_stmt

begin_comment
comment|// Handle the unlock event.
end_comment

begin_comment
comment|// This operation is thread-safe as it only touches the dtls.
end_comment

begin_decl_stmt
name|void
name|onUnlock
argument_list|(
name|DeadlockDetectorTLS
operator|<
name|BV
operator|>
operator|*
name|dtls
argument_list|,
name|uptr
name|node
argument_list|)
block|{
if|if
condition|(
name|dtls
operator|->
name|getEpoch
argument_list|()
operator|==
name|nodeToEpoch
argument_list|(
name|node
argument_list|)
condition|)
name|dtls
operator|->
name|removeLock
argument_list|(
name|nodeToIndexUnchecked
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// Tries to handle the lock event w/o writing to global state.
end_comment

begin_comment
comment|// Returns true on success.
end_comment

begin_comment
comment|// This operation is thread-safe as it only touches the dtls
end_comment

begin_comment
comment|// (modulo racy nature of hasAllEdges).
end_comment

begin_decl_stmt
name|bool
name|onLockFast
argument_list|(
name|DeadlockDetectorTLS
operator|<
name|BV
operator|>
operator|*
name|dtls
argument_list|,
name|uptr
name|node
argument_list|,
name|u32
name|stk
operator|=
literal|0
argument_list|)
block|{
if|if
condition|(
name|hasAllEdges
argument_list|(
name|dtls
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|dtls
operator|->
name|addLock
argument_list|(
name|nodeToIndexUnchecked
argument_list|(
name|node
argument_list|)
argument_list|,
name|nodeToEpoch
argument_list|(
name|node
argument_list|)
argument_list|,
name|stk
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bool
name|isHeld
argument_list|(
name|DeadlockDetectorTLS
operator|<
name|BV
operator|>
operator|*
name|dtls
argument_list|,
name|uptr
name|node
argument_list|)
decl|const
block|{
return|return
name|dtls
operator|->
name|getLocks
argument_list|(
name|current_epoch_
argument_list|)
operator|.
name|getBit
argument_list|(
name|nodeToIndex
argument_list|(
name|node
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|uptr
name|testOnlyGetEpoch
argument_list|()
specifier|const
block|{
return|return
name|current_epoch_
return|;
block|}
end_expr_stmt

begin_function
name|bool
name|testOnlyHasEdge
parameter_list|(
name|uptr
name|l1
parameter_list|,
name|uptr
name|l2
parameter_list|)
block|{
return|return
name|g_
operator|.
name|hasEdge
argument_list|(
name|nodeToIndex
argument_list|(
name|l1
argument_list|)
argument_list|,
name|nodeToIndex
argument_list|(
name|l2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// idx1 and idx2 are raw indices to g_, not lock IDs.
end_comment

begin_function
name|bool
name|testOnlyHasEdgeRaw
parameter_list|(
name|uptr
name|idx1
parameter_list|,
name|uptr
name|idx2
parameter_list|)
block|{
return|return
name|g_
operator|.
name|hasEdge
argument_list|(
name|idx1
argument_list|,
name|idx2
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|Print
parameter_list|()
block|{
for|for
control|(
name|uptr
name|from
init|=
literal|0
init|;
name|from
operator|<
name|size
argument_list|()
condition|;
name|from
operator|++
control|)
for|for
control|(
name|uptr
name|to
init|=
literal|0
init|;
name|to
operator|<
name|size
argument_list|()
condition|;
name|to
operator|++
control|)
if|if
condition|(
name|g_
operator|.
name|hasEdge
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
name|Printf
argument_list|(
literal|"  %zx => %zx\n"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|void
name|check_idx
argument_list|(
name|uptr
name|idx
argument_list|)
decl|const
block|{
name|CHECK_LT
argument_list|(
name|idx
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|check_node
argument_list|(
name|uptr
name|node
argument_list|)
decl|const
block|{
name|CHECK_GE
argument_list|(
name|node
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|CHECK_EQ
argument_list|(
name|current_epoch_
argument_list|,
name|nodeToEpoch
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|uptr
name|indexToNode
argument_list|(
name|uptr
name|idx
argument_list|)
decl|const
block|{
name|check_idx
argument_list|(
name|idx
argument_list|)
expr_stmt|;
return|return
name|idx
operator|+
name|current_epoch_
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|uptr
name|nodeToIndexUnchecked
argument_list|(
name|uptr
name|node
argument_list|)
decl|const
block|{
return|return
name|node
operator|%
name|size
argument_list|()
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|uptr
name|nodeToIndex
argument_list|(
name|uptr
name|node
argument_list|)
decl|const
block|{
name|check_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|nodeToIndexUnchecked
argument_list|(
name|node
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|uptr
name|nodeToEpoch
argument_list|(
name|uptr
name|node
argument_list|)
decl|const
block|{
return|return
name|node
operator|/
name|size
argument_list|()
operator|*
name|size
argument_list|()
return|;
block|}
end_decl_stmt

begin_function
name|uptr
name|getAvailableNode
parameter_list|(
name|uptr
name|data
parameter_list|)
block|{
name|uptr
name|idx
init|=
name|available_nodes_
operator|.
name|getAndClearFirstOne
argument_list|()
decl_stmt|;
name|data_
index|[
name|idx
index|]
operator|=
name|data
expr_stmt|;
return|return
name|indexToNode
argument_list|(
name|idx
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|Edge
block|{
name|u16
name|from
decl_stmt|;
name|u16
name|to
decl_stmt|;
name|u32
name|stk_from
decl_stmt|;
name|u32
name|stk_to
decl_stmt|;
name|int
name|unique_tid
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|uptr
name|current_epoch_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BV
name|available_nodes_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BV
name|recycled_nodes_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BV
name|tmp_bv_
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|BVGraph
operator|<
name|BV
operator|>
name|g_
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|uptr
name|data_
index|[
name|BV
operator|::
name|kSize
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Edge
name|edges_
index|[
name|BV
operator|::
name|kSize
operator|*
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uptr
name|n_edges_
decl_stmt|;
end_decl_stmt

begin_comment
unit|};  }
comment|// namespace __sanitizer
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// SANITIZER_DEADLOCK_DETECTOR_H
end_comment

end_unit

