begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- sanitizer_allocator_primary64.h -------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Part of the Sanitizer Allocator.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SANITIZER_ALLOCATOR_H
end_ifndef

begin_error
error|#
directive|error
error|This file must be included inside sanitizer_allocator.h
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|template
operator|<
name|class
name|SizeClassAllocator
operator|>
expr|struct
name|SizeClassAllocator64LocalCache
expr_stmt|;
end_expr_stmt

begin_comment
comment|// SizeClassAllocator64 -- allocator for 64-bit address space.
end_comment

begin_comment
comment|// The template parameter Params is a class containing the actual parameters.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Space: a portion of address space of kSpaceSize bytes starting at SpaceBeg.
end_comment

begin_comment
comment|// If kSpaceBeg is ~0 then SpaceBeg is chosen dynamically my mmap.
end_comment

begin_comment
comment|// Otherwise SpaceBeg=kSpaceBeg (fixed address).
end_comment

begin_comment
comment|// kSpaceSize is a power of two.
end_comment

begin_comment
comment|// At the beginning the entire space is mprotect-ed, then small parts of it
end_comment

begin_comment
comment|// are mapped on demand.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Region: a part of Space dedicated to a single size class.
end_comment

begin_comment
comment|// There are kNumClasses Regions of equal size.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// UserChunk: a piece of memory returned to user.
end_comment

begin_comment
comment|// MetaChunk: kMetadataSize bytes of metadata associated with a UserChunk.
end_comment

begin_comment
comment|// FreeArray is an array free-d chunks (stored as 4-byte offsets)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// A Region looks like this:
end_comment

begin_comment
comment|// UserChunk1 ... UserChunkN<gap> MetaChunkN ... MetaChunk1 FreeArray
end_comment

begin_struct
struct|struct
name|SizeClassAllocator64FlagMasks
block|{
comment|//  Bit masks.
enum|enum
block|{
name|kRandomShuffleChunks
init|=
literal|1
block|,   }
enum|;
block|}
struct|;
end_struct

begin_expr_stmt
name|template
operator|<
name|class
name|Params
operator|>
name|class
name|SizeClassAllocator64
block|{
name|public
operator|:
specifier|static
specifier|const
name|uptr
name|kSpaceBeg
operator|=
name|Params
operator|::
name|kSpaceBeg
block|;
specifier|static
specifier|const
name|uptr
name|kSpaceSize
operator|=
name|Params
operator|::
name|kSpaceSize
block|;
specifier|static
specifier|const
name|uptr
name|kMetadataSize
operator|=
name|Params
operator|::
name|kMetadataSize
block|;
typedef|typedef
name|typename
name|Params
operator|::
name|SizeClassMap
name|SizeClassMap
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|Params
operator|::
name|MapUnmapCallback
name|MapUnmapCallback
expr_stmt|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|bool
name|kRandomShuffleChunks
init|=
name|Params
operator|::
name|kFlags
operator|&
name|SizeClassAllocator64FlagMasks
operator|::
name|kRandomShuffleChunks
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|SizeClassAllocator64
operator|<
name|Params
operator|>
name|ThisT
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|SizeClassAllocator64LocalCache
operator|<
name|ThisT
operator|>
name|AllocatorCache
expr_stmt|;
end_typedef

begin_comment
comment|// When we know the size class (the region base) we can represent a pointer
end_comment

begin_comment
comment|// as a 4-byte integer (offset from the region start shifted right by 4).
end_comment

begin_typedef
typedef|typedef
name|u32
name|CompactPtrT
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|uptr
name|kCompactPtrScale
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_function
name|CompactPtrT
name|PointerToCompactPtr
parameter_list|(
name|uptr
name|base
parameter_list|,
name|uptr
name|ptr
parameter_list|)
block|{
return|return
name|static_cast
operator|<
name|CompactPtrT
operator|>
operator|(
operator|(
name|ptr
operator|-
name|base
operator|)
operator|>>
name|kCompactPtrScale
operator|)
return|;
block|}
end_function

begin_function
name|uptr
name|CompactPtrToPointer
parameter_list|(
name|uptr
name|base
parameter_list|,
name|CompactPtrT
name|ptr32
parameter_list|)
block|{
return|return
name|base
operator|+
operator|(
name|static_cast
operator|<
name|uptr
operator|>
operator|(
name|ptr32
operator|)
operator|<<
name|kCompactPtrScale
operator|)
return|;
block|}
end_function

begin_function
name|void
name|Init
parameter_list|(
name|s32
name|release_to_os_interval_ms
parameter_list|)
block|{
name|uptr
name|TotalSpaceSize
init|=
name|kSpaceSize
operator|+
name|AdditionalSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|kUsingConstantSpaceBeg
condition|)
block|{
name|CHECK_EQ
argument_list|(
name|kSpaceBeg
argument_list|,
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|MmapFixedNoAccess
argument_list|(
name|kSpaceBeg
argument_list|,
name|TotalSpaceSize
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NonConstSpaceBeg
operator|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|MmapNoAccess
argument_list|(
name|TotalSpaceSize
argument_list|)
operator|)
expr_stmt|;
name|CHECK_NE
argument_list|(
name|NonConstSpaceBeg
argument_list|,
operator|~
operator|(
name|uptr
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|SetReleaseToOSIntervalMs
argument_list|(
name|release_to_os_interval_ms
argument_list|)
expr_stmt|;
name|MapWithCallbackOrDie
argument_list|(
name|SpaceEnd
argument_list|()
argument_list|,
name|AdditionalSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|s32
name|ReleaseToOSIntervalMs
argument_list|()
specifier|const
block|{
return|return
name|atomic_load
argument_list|(
operator|&
name|release_to_os_interval_ms_
argument_list|,
name|memory_order_relaxed
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|SetReleaseToOSIntervalMs
parameter_list|(
name|s32
name|release_to_os_interval_ms
parameter_list|)
block|{
name|atomic_store
argument_list|(
operator|&
name|release_to_os_interval_ms_
argument_list|,
name|release_to_os_interval_ms
argument_list|,
name|memory_order_relaxed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|CanAllocate
parameter_list|(
name|uptr
name|size
parameter_list|,
name|uptr
name|alignment
parameter_list|)
block|{
return|return
name|size
operator|<=
name|SizeClassMap
operator|::
name|kMaxSize
operator|&&
name|alignment
operator|<=
name|SizeClassMap
operator|::
name|kMaxSize
return|;
block|}
end_function

begin_function
name|NOINLINE
name|void
name|ReturnToAllocator
parameter_list|(
name|AllocatorStats
modifier|*
name|stat
parameter_list|,
name|uptr
name|class_id
parameter_list|,
specifier|const
name|CompactPtrT
modifier|*
name|chunks
parameter_list|,
name|uptr
name|n_chunks
parameter_list|)
block|{
name|RegionInfo
modifier|*
name|region
init|=
name|GetRegionInfo
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|uptr
name|region_beg
init|=
name|GetRegionBeginBySizeClass
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|CompactPtrT
modifier|*
name|free_array
init|=
name|GetFreeArray
argument_list|(
name|region_beg
argument_list|)
decl_stmt|;
name|BlockingMutexLock
name|l
argument_list|(
operator|&
name|region
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|uptr
name|old_num_chunks
init|=
name|region
operator|->
name|num_freed_chunks
decl_stmt|;
name|uptr
name|new_num_freed_chunks
init|=
name|old_num_chunks
operator|+
name|n_chunks
decl_stmt|;
comment|// Failure to allocate free array space while releasing memory is non
comment|// recoverable.
if|if
condition|(
name|UNLIKELY
argument_list|(
operator|!
name|EnsureFreeArraySpace
argument_list|(
name|region
argument_list|,
name|region_beg
argument_list|,
name|new_num_freed_chunks
argument_list|)
argument_list|)
condition|)
name|DieOnFailure
operator|::
name|OnOOM
argument_list|()
expr_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n_chunks
condition|;
name|i
operator|++
control|)
name|free_array
index|[
name|old_num_chunks
operator|+
name|i
index|]
operator|=
name|chunks
index|[
name|i
index|]
expr_stmt|;
name|region
operator|->
name|num_freed_chunks
operator|=
name|new_num_freed_chunks
expr_stmt|;
name|region
operator|->
name|stats
operator|.
name|n_freed
operator|+=
name|n_chunks
expr_stmt|;
name|MaybeReleaseToOS
argument_list|(
name|class_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|NOINLINE
name|bool
name|GetFromAllocator
parameter_list|(
name|AllocatorStats
modifier|*
name|stat
parameter_list|,
name|uptr
name|class_id
parameter_list|,
name|CompactPtrT
modifier|*
name|chunks
parameter_list|,
name|uptr
name|n_chunks
parameter_list|)
block|{
name|RegionInfo
modifier|*
name|region
init|=
name|GetRegionInfo
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|uptr
name|region_beg
init|=
name|GetRegionBeginBySizeClass
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|CompactPtrT
modifier|*
name|free_array
init|=
name|GetFreeArray
argument_list|(
name|region_beg
argument_list|)
decl_stmt|;
name|BlockingMutexLock
name|l
argument_list|(
operator|&
name|region
operator|->
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
name|region
operator|->
name|num_freed_chunks
operator|<
name|n_chunks
argument_list|)
condition|)
block|{
if|if
condition|(
name|UNLIKELY
argument_list|(
operator|!
name|PopulateFreeArray
argument_list|(
name|stat
argument_list|,
name|class_id
argument_list|,
name|region
argument_list|,
name|n_chunks
operator|-
name|region
operator|->
name|num_freed_chunks
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|CHECK_GE
argument_list|(
name|region
operator|->
name|num_freed_chunks
argument_list|,
name|n_chunks
argument_list|)
expr_stmt|;
block|}
name|region
operator|->
name|num_freed_chunks
operator|-=
name|n_chunks
expr_stmt|;
name|uptr
name|base_idx
init|=
name|region
operator|->
name|num_freed_chunks
decl_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n_chunks
condition|;
name|i
operator|++
control|)
name|chunks
index|[
name|i
index|]
operator|=
name|free_array
index|[
name|base_idx
operator|+
name|i
index|]
expr_stmt|;
name|region
operator|->
name|stats
operator|.
name|n_allocated
operator|+=
name|n_chunks
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|PointerIsMine
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|uptr
name|P
init|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
decl_stmt|;
if|if
condition|(
name|kUsingConstantSpaceBeg
operator|&&
operator|(
name|kSpaceBeg
operator|%
name|kSpaceSize
operator|)
operator|==
literal|0
condition|)
return|return
name|P
operator|/
name|kSpaceSize
operator|==
name|kSpaceBeg
operator|/
name|kSpaceSize
return|;
return|return
name|P
operator|>=
name|SpaceBeg
argument_list|()
operator|&&
name|P
operator|<
name|SpaceEnd
argument_list|()
return|;
block|}
end_function

begin_function
name|uptr
name|GetRegionBegin
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|kUsingConstantSpaceBeg
condition|)
return|return
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
operator|&
operator|~
operator|(
name|kRegionSize
operator|-
literal|1
operator|)
return|;
name|uptr
name|space_beg
init|=
name|SpaceBeg
argument_list|()
decl_stmt|;
return|return
operator|(
operator|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
operator|-
name|space_beg
operator|)
operator|&
operator|~
operator|(
name|kRegionSize
operator|-
literal|1
operator|)
operator|)
operator|+
name|space_beg
return|;
block|}
end_function

begin_function
name|uptr
name|GetRegionBeginBySizeClass
parameter_list|(
name|uptr
name|class_id
parameter_list|)
block|{
return|return
name|SpaceBeg
argument_list|()
operator|+
name|kRegionSize
operator|*
name|class_id
return|;
block|}
end_function

begin_function
name|uptr
name|GetSizeClass
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|kUsingConstantSpaceBeg
operator|&&
operator|(
name|kSpaceBeg
operator|%
name|kSpaceSize
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
operator|)
operator|/
name|kRegionSize
operator|)
operator|%
name|kNumClassesRounded
return|;
return|return
operator|(
operator|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
operator|-
name|SpaceBeg
argument_list|()
operator|)
operator|/
name|kRegionSize
operator|)
operator|%
name|kNumClassesRounded
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|GetBlockBegin
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|uptr
name|class_id
init|=
name|GetSizeClass
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|uptr
name|size
init|=
name|ClassIdToSize
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
return|return
name|nullptr
return|;
name|uptr
name|chunk_idx
init|=
name|GetChunkIdx
argument_list|(
operator|(
name|uptr
operator|)
name|p
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|uptr
name|reg_beg
init|=
name|GetRegionBegin
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|uptr
name|beg
init|=
name|chunk_idx
operator|*
name|size
decl_stmt|;
name|uptr
name|next_beg
init|=
name|beg
operator|+
name|size
decl_stmt|;
if|if
condition|(
name|class_id
operator|>=
name|kNumClasses
condition|)
return|return
name|nullptr
return|;
name|RegionInfo
modifier|*
name|region
init|=
name|GetRegionInfo
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|->
name|mapped_user
operator|>=
name|next_beg
condition|)
return|return
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|reg_beg
operator|+
name|beg
operator|)
return|;
return|return
name|nullptr
return|;
block|}
end_function

begin_function
name|uptr
name|GetActuallyAllocatedSize
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|CHECK
argument_list|(
name|PointerIsMine
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ClassIdToSize
argument_list|(
name|GetSizeClass
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|uptr
name|ClassID
parameter_list|(
name|uptr
name|size
parameter_list|)
block|{
return|return
name|SizeClassMap
operator|::
name|ClassID
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|GetMetaData
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|uptr
name|class_id
init|=
name|GetSizeClass
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|uptr
name|size
init|=
name|ClassIdToSize
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|uptr
name|chunk_idx
init|=
name|GetChunkIdx
argument_list|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|uptr
name|region_beg
init|=
name|GetRegionBeginBySizeClass
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
return|return
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|GetMetadataEnd
argument_list|(
name|region_beg
argument_list|)
operator|-
operator|(
literal|1
operator|+
name|chunk_idx
operator|)
operator|*
name|kMetadataSize
operator|)
return|;
block|}
end_function

begin_function
name|uptr
name|TotalMemoryUsed
parameter_list|()
block|{
name|uptr
name|res
init|=
literal|0
decl_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kNumClasses
condition|;
name|i
operator|++
control|)
name|res
operator|+=
name|GetRegionInfo
argument_list|(
name|i
argument_list|)
operator|->
name|allocated_user
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|// Test-only.
end_comment

begin_function
name|void
name|TestOnlyUnmap
parameter_list|()
block|{
name|UnmapWithCallbackOrDie
argument_list|(
name|SpaceBeg
argument_list|()
argument_list|,
name|kSpaceSize
operator|+
name|AdditionalSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FillMemoryProfile
parameter_list|(
name|uptr
name|start
parameter_list|,
name|uptr
name|rss
parameter_list|,
name|bool
name|file
parameter_list|,
name|uptr
modifier|*
name|stats
parameter_list|,
name|uptr
name|stats_size
parameter_list|)
block|{
for|for
control|(
name|uptr
name|class_id
init|=
literal|0
init|;
name|class_id
operator|<
name|stats_size
condition|;
name|class_id
operator|++
control|)
if|if
condition|(
name|stats
index|[
name|class_id
index|]
operator|==
name|start
condition|)
name|stats
index|[
name|class_id
index|]
operator|=
name|rss
expr_stmt|;
block|}
end_function

begin_function
name|void
name|PrintStats
parameter_list|(
name|uptr
name|class_id
parameter_list|,
name|uptr
name|rss
parameter_list|)
block|{
name|RegionInfo
modifier|*
name|region
init|=
name|GetRegionInfo
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|->
name|mapped_user
operator|==
literal|0
condition|)
return|return;
name|uptr
name|in_use
init|=
name|region
operator|->
name|stats
operator|.
name|n_allocated
operator|-
name|region
operator|->
name|stats
operator|.
name|n_freed
decl_stmt|;
name|uptr
name|avail_chunks
init|=
name|region
operator|->
name|allocated_user
operator|/
name|ClassIdToSize
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|Printf
argument_list|(
literal|"%s %02zd (%6zd): mapped: %6zdK allocs: %7zd frees: %7zd inuse: %6zd "
literal|"num_freed_chunks %7zd avail: %6zd rss: %6zdK releases: %6zd\n"
argument_list|,
name|region
operator|->
name|exhausted
condition|?
literal|"F"
else|:
literal|" "
argument_list|,
name|class_id
argument_list|,
name|ClassIdToSize
argument_list|(
name|class_id
argument_list|)
argument_list|,
name|region
operator|->
name|mapped_user
operator|>>
literal|10
argument_list|,
name|region
operator|->
name|stats
operator|.
name|n_allocated
argument_list|,
name|region
operator|->
name|stats
operator|.
name|n_freed
argument_list|,
name|in_use
argument_list|,
name|region
operator|->
name|num_freed_chunks
argument_list|,
name|avail_chunks
argument_list|,
name|rss
operator|>>
literal|10
argument_list|,
name|region
operator|->
name|rtoi
operator|.
name|num_releases
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|PrintStats
parameter_list|()
block|{
name|uptr
name|total_mapped
init|=
literal|0
decl_stmt|;
name|uptr
name|n_allocated
init|=
literal|0
decl_stmt|;
name|uptr
name|n_freed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|uptr
name|class_id
init|=
literal|1
init|;
name|class_id
operator|<
name|kNumClasses
condition|;
name|class_id
operator|++
control|)
block|{
name|RegionInfo
modifier|*
name|region
init|=
name|GetRegionInfo
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|total_mapped
operator|+=
name|region
operator|->
name|mapped_user
expr_stmt|;
name|n_allocated
operator|+=
name|region
operator|->
name|stats
operator|.
name|n_allocated
expr_stmt|;
name|n_freed
operator|+=
name|region
operator|->
name|stats
operator|.
name|n_freed
expr_stmt|;
block|}
name|Printf
argument_list|(
literal|"Stats: SizeClassAllocator64: %zdM mapped in %zd allocations; "
literal|"remains %zd\n"
argument_list|,
name|total_mapped
operator|>>
literal|20
argument_list|,
name|n_allocated
argument_list|,
name|n_allocated
operator|-
name|n_freed
argument_list|)
expr_stmt|;
name|uptr
name|rss_stats
index|[
name|kNumClasses
index|]
decl_stmt|;
for|for
control|(
name|uptr
name|class_id
init|=
literal|0
init|;
name|class_id
operator|<
name|kNumClasses
condition|;
name|class_id
operator|++
control|)
name|rss_stats
index|[
name|class_id
index|]
operator|=
name|SpaceBeg
argument_list|()
operator|+
name|kRegionSize
operator|*
name|class_id
expr_stmt|;
name|GetMemoryProfile
argument_list|(
name|FillMemoryProfile
argument_list|,
name|rss_stats
argument_list|,
name|kNumClasses
argument_list|)
expr_stmt|;
for|for
control|(
name|uptr
name|class_id
init|=
literal|1
init|;
name|class_id
operator|<
name|kNumClasses
condition|;
name|class_id
operator|++
control|)
name|PrintStats
argument_list|(
name|class_id
argument_list|,
name|rss_stats
index|[
name|class_id
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone
end_comment

begin_comment
comment|// introspection API.
end_comment

begin_function
name|void
name|ForceLock
parameter_list|()
block|{
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kNumClasses
condition|;
name|i
operator|++
control|)
block|{
name|GetRegionInfo
argument_list|(
name|i
argument_list|)
operator|->
name|mutex
operator|.
name|Lock
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ForceUnlock
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
operator|(
name|int
operator|)
name|kNumClasses
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|GetRegionInfo
argument_list|(
name|i
argument_list|)
operator|->
name|mutex
operator|.
name|Unlock
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// Iterate over all existing chunks.
end_comment

begin_comment
comment|// The allocator must be locked when calling this function.
end_comment

begin_function
name|void
name|ForEachChunk
parameter_list|(
name|ForEachChunkCallback
name|callback
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
for|for
control|(
name|uptr
name|class_id
init|=
literal|1
init|;
name|class_id
operator|<
name|kNumClasses
condition|;
name|class_id
operator|++
control|)
block|{
name|RegionInfo
modifier|*
name|region
init|=
name|GetRegionInfo
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|uptr
name|chunk_size
init|=
name|ClassIdToSize
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|uptr
name|region_beg
init|=
name|SpaceBeg
argument_list|()
operator|+
name|class_id
operator|*
name|kRegionSize
decl_stmt|;
for|for
control|(
name|uptr
name|chunk
init|=
name|region_beg
init|;
name|chunk
operator|<
name|region_beg
operator|+
name|region
operator|->
name|allocated_user
condition|;
name|chunk
operator|+=
name|chunk_size
control|)
block|{
comment|// Too slow: CHECK_EQ((void *)chunk, GetBlockBegin((void *)chunk));
name|callback
argument_list|(
name|chunk
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|uptr
name|ClassIdToSize
parameter_list|(
name|uptr
name|class_id
parameter_list|)
block|{
return|return
name|SizeClassMap
operator|::
name|Size
argument_list|(
name|class_id
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|uptr
name|AdditionalSize
parameter_list|()
block|{
return|return
name|RoundUpTo
argument_list|(
sizeof|sizeof
argument_list|(
name|RegionInfo
argument_list|)
operator|*
name|kNumClassesRounded
argument_list|,
name|GetPageSizeCached
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|SizeClassMap
name|SizeClassMapT
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|uptr
name|kNumClasses
init|=
name|SizeClassMap
operator|::
name|kNumClasses
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uptr
name|kNumClassesRounded
init|=
name|SizeClassMap
operator|::
name|kNumClassesRounded
decl_stmt|;
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
specifier|static
specifier|const
name|uptr
name|kRegionSize
init|=
name|kSpaceSize
operator|/
name|kNumClassesRounded
decl_stmt|;
end_decl_stmt

begin_comment
comment|// FreeArray is the array of free-d chunks (stored as 4-byte offsets).
end_comment

begin_comment
comment|// In the worst case it may reguire kRegionSize/SizeClassMap::kMinSize
end_comment

begin_comment
comment|// elements, but in reality this will not happen. For simplicity we
end_comment

begin_comment
comment|// dedicate 1/8 of the region's virtual space to FreeArray.
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uptr
name|kFreeArraySize
init|=
name|kRegionSize
operator|/
literal|8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bool
name|kUsingConstantSpaceBeg
init|=
name|kSpaceBeg
operator|!=
operator|~
operator|(
name|uptr
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uptr
name|NonConstSpaceBeg
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|uptr
name|SpaceBeg
argument_list|()
specifier|const
block|{
return|return
name|kUsingConstantSpaceBeg
operator|?
name|kSpaceBeg
operator|:
name|NonConstSpaceBeg
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|uptr
name|SpaceEnd
argument_list|()
specifier|const
block|{
return|return
name|SpaceBeg
argument_list|()
operator|+
name|kSpaceSize
return|;
block|}
end_expr_stmt

begin_comment
comment|// kRegionSize must be>= 2^32.
end_comment

begin_expr_stmt
name|COMPILER_CHECK
argument_list|(
operator|(
name|kRegionSize
operator|)
operator|>=
operator|(
literal|1ULL
operator|<<
operator|(
name|SANITIZER_WORDSIZE
operator|/
literal|2
operator|)
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// kRegionSize must be<= 2^36, see CompactPtrT.
end_comment

begin_expr_stmt
name|COMPILER_CHECK
argument_list|(
operator|(
name|kRegionSize
operator|)
operator|<=
operator|(
literal|1ULL
operator|<<
operator|(
name|SANITIZER_WORDSIZE
operator|/
literal|2
operator|+
literal|4
operator|)
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Call mmap for user memory with at least this size.
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uptr
name|kUserMapSize
init|=
literal|1
operator|<<
literal|16
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Call mmap for metadata memory with at least this size.
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uptr
name|kMetaMapSize
init|=
literal|1
operator|<<
literal|16
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Call mmap for free array memory with at least this size.
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uptr
name|kFreeArrayMapSize
init|=
literal|1
operator|<<
literal|16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|atomic_sint32_t
name|release_to_os_interval_ms_
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|Stats
block|{
name|uptr
name|n_allocated
decl_stmt|;
name|uptr
name|n_freed
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ReleaseToOsInfo
block|{
name|uptr
name|n_freed_at_last_release
decl_stmt|;
name|uptr
name|num_releases
decl_stmt|;
name|u64
name|last_release_at_ns
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|RegionInfo
block|{
name|BlockingMutex
name|mutex
decl_stmt|;
name|uptr
name|num_freed_chunks
decl_stmt|;
comment|// Number of elements in the freearray.
name|uptr
name|mapped_free_array
decl_stmt|;
comment|// Bytes mapped for freearray.
name|uptr
name|allocated_user
decl_stmt|;
comment|// Bytes allocated for user memory.
name|uptr
name|allocated_meta
decl_stmt|;
comment|// Bytes allocated for metadata.
name|uptr
name|mapped_user
decl_stmt|;
comment|// Bytes mapped for user memory.
name|uptr
name|mapped_meta
decl_stmt|;
comment|// Bytes mapped for metadata.
name|u32
name|rand_state
decl_stmt|;
comment|// Seed for random shuffle, used if kRandomShuffleChunks.
name|bool
name|exhausted
decl_stmt|;
comment|// Whether region is out of space for new chunks.
name|Stats
name|stats
decl_stmt|;
name|ReleaseToOsInfo
name|rtoi
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|COMPILER_CHECK
argument_list|(
sizeof|sizeof
argument_list|(
name|RegionInfo
argument_list|)
operator|>=
name|kCacheLineSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|u32
name|Rand
parameter_list|(
name|u32
modifier|*
name|state
parameter_list|)
block|{
comment|// ANSI C linear congruential PRNG.
return|return
operator|(
operator|*
name|state
operator|=
operator|*
name|state
operator|*
literal|1103515245
operator|+
literal|12345
operator|)
operator|>>
literal|16
return|;
block|}
end_function

begin_function
name|u32
name|RandN
parameter_list|(
name|u32
modifier|*
name|state
parameter_list|,
name|u32
name|n
parameter_list|)
block|{
return|return
name|Rand
argument_list|(
name|state
argument_list|)
operator|%
name|n
return|;
block|}
end_function

begin_comment
comment|// [0, n)
end_comment

begin_function
name|void
name|RandomShuffle
parameter_list|(
name|u32
modifier|*
name|a
parameter_list|,
name|u32
name|n
parameter_list|,
name|u32
modifier|*
name|rand_state
parameter_list|)
block|{
if|if
condition|(
name|n
operator|<=
literal|1
condition|)
return|return;
for|for
control|(
name|u32
name|i
init|=
name|n
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|Swap
argument_list|(
name|a
index|[
name|i
index|]
argument_list|,
name|a
index|[
name|RandN
argument_list|(
name|rand_state
argument_list|,
name|i
operator|+
literal|1
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|RegionInfo
modifier|*
name|GetRegionInfo
parameter_list|(
name|uptr
name|class_id
parameter_list|)
block|{
name|CHECK_LT
argument_list|(
name|class_id
argument_list|,
name|kNumClasses
argument_list|)
expr_stmt|;
name|RegionInfo
modifier|*
name|regions
init|=
name|reinterpret_cast
operator|<
name|RegionInfo
operator|*
operator|>
operator|(
name|SpaceBeg
argument_list|()
operator|+
name|kSpaceSize
operator|)
decl_stmt|;
return|return
operator|&
name|regions
index|[
name|class_id
index|]
return|;
block|}
end_function

begin_function
name|uptr
name|GetMetadataEnd
parameter_list|(
name|uptr
name|region_beg
parameter_list|)
block|{
return|return
name|region_beg
operator|+
name|kRegionSize
operator|-
name|kFreeArraySize
return|;
block|}
end_function

begin_function
name|uptr
name|GetChunkIdx
parameter_list|(
name|uptr
name|chunk
parameter_list|,
name|uptr
name|size
parameter_list|)
block|{
if|if
condition|(
operator|!
name|kUsingConstantSpaceBeg
condition|)
name|chunk
operator|-=
name|SpaceBeg
argument_list|()
expr_stmt|;
name|uptr
name|offset
init|=
name|chunk
operator|%
name|kRegionSize
decl_stmt|;
comment|// Here we divide by a non-constant. This is costly.
comment|// size always fits into 32-bits. If the offset fits too, use 32-bit div.
if|if
condition|(
name|offset
operator|>>
operator|(
name|SANITIZER_WORDSIZE
operator|/
literal|2
operator|)
condition|)
return|return
name|offset
operator|/
name|size
return|;
return|return
operator|(
name|u32
operator|)
name|offset
operator|/
operator|(
name|u32
operator|)
name|size
return|;
block|}
end_function

begin_function
name|CompactPtrT
modifier|*
name|GetFreeArray
parameter_list|(
name|uptr
name|region_beg
parameter_list|)
block|{
return|return
name|reinterpret_cast
operator|<
name|CompactPtrT
operator|*
operator|>
operator|(
name|region_beg
operator|+
name|kRegionSize
operator|-
name|kFreeArraySize
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|MapWithCallback
parameter_list|(
name|uptr
name|beg
parameter_list|,
name|uptr
name|size
parameter_list|)
block|{
name|uptr
name|mapped
init|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|MmapFixedOrDieOnFatalError
argument_list|(
name|beg
argument_list|,
name|size
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
operator|!
name|mapped
argument_list|)
condition|)
return|return
name|false
return|;
name|CHECK_EQ
argument_list|(
name|beg
argument_list|,
name|mapped
argument_list|)
expr_stmt|;
name|MapUnmapCallback
argument_list|()
operator|.
name|OnMap
argument_list|(
name|beg
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|MapWithCallbackOrDie
parameter_list|(
name|uptr
name|beg
parameter_list|,
name|uptr
name|size
parameter_list|)
block|{
name|CHECK_EQ
argument_list|(
name|beg
argument_list|,
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|MmapFixedOrDie
argument_list|(
name|beg
argument_list|,
name|size
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|MapUnmapCallback
argument_list|()
operator|.
name|OnMap
argument_list|(
name|beg
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|UnmapWithCallbackOrDie
parameter_list|(
name|uptr
name|beg
parameter_list|,
name|uptr
name|size
parameter_list|)
block|{
name|MapUnmapCallback
argument_list|()
operator|.
name|OnUnmap
argument_list|(
name|beg
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|UnmapOrDie
argument_list|(
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|beg
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|EnsureFreeArraySpace
parameter_list|(
name|RegionInfo
modifier|*
name|region
parameter_list|,
name|uptr
name|region_beg
parameter_list|,
name|uptr
name|num_freed_chunks
parameter_list|)
block|{
name|uptr
name|needed_space
init|=
name|num_freed_chunks
operator|*
sizeof|sizeof
argument_list|(
name|CompactPtrT
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|->
name|mapped_free_array
operator|<
name|needed_space
condition|)
block|{
name|CHECK_LE
argument_list|(
name|needed_space
argument_list|,
name|kFreeArraySize
argument_list|)
expr_stmt|;
name|uptr
name|new_mapped_free_array
init|=
name|RoundUpTo
argument_list|(
name|needed_space
argument_list|,
name|kFreeArrayMapSize
argument_list|)
decl_stmt|;
name|uptr
name|current_map_end
init|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|GetFreeArray
argument_list|(
name|region_beg
argument_list|)
operator|)
operator|+
name|region
operator|->
name|mapped_free_array
decl_stmt|;
name|uptr
name|new_map_size
init|=
name|new_mapped_free_array
operator|-
name|region
operator|->
name|mapped_free_array
decl_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
operator|!
name|MapWithCallback
argument_list|(
name|current_map_end
argument_list|,
name|new_map_size
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|region
operator|->
name|mapped_free_array
operator|=
name|new_mapped_free_array
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|NOINLINE
name|bool
name|PopulateFreeArray
parameter_list|(
name|AllocatorStats
modifier|*
name|stat
parameter_list|,
name|uptr
name|class_id
parameter_list|,
name|RegionInfo
modifier|*
name|region
parameter_list|,
name|uptr
name|requested_count
parameter_list|)
block|{
comment|// region->mutex is held.
specifier|const
name|uptr
name|size
init|=
name|ClassIdToSize
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
specifier|const
name|uptr
name|new_space_beg
init|=
name|region
operator|->
name|allocated_user
decl_stmt|;
specifier|const
name|uptr
name|new_space_end
init|=
name|new_space_beg
operator|+
name|requested_count
operator|*
name|size
decl_stmt|;
specifier|const
name|uptr
name|region_beg
init|=
name|GetRegionBeginBySizeClass
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
comment|// Map more space for chunks, if necessary.
if|if
condition|(
name|new_space_end
operator|>
name|region
operator|->
name|mapped_user
condition|)
block|{
if|if
condition|(
operator|!
name|kUsingConstantSpaceBeg
operator|&&
name|region
operator|->
name|mapped_user
operator|==
literal|0
condition|)
name|region
operator|->
name|rand_state
operator|=
name|static_cast
operator|<
name|u32
operator|>
operator|(
name|region_beg
operator|>>
literal|12
operator|)
expr_stmt|;
comment|// From ASLR.
comment|// Do the mmap for the user memory.
name|uptr
name|map_size
init|=
name|kUserMapSize
decl_stmt|;
while|while
condition|(
name|new_space_end
operator|>
name|region
operator|->
name|mapped_user
operator|+
name|map_size
condition|)
name|map_size
operator|+=
name|kUserMapSize
expr_stmt|;
name|CHECK_GE
argument_list|(
name|region
operator|->
name|mapped_user
operator|+
name|map_size
argument_list|,
name|new_space_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
operator|!
name|MapWithCallback
argument_list|(
name|region_beg
operator|+
name|region
operator|->
name|mapped_user
argument_list|,
name|map_size
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|stat
operator|->
name|Add
argument_list|(
name|AllocatorStatMapped
argument_list|,
name|map_size
argument_list|)
expr_stmt|;
name|region
operator|->
name|mapped_user
operator|+=
name|map_size
expr_stmt|;
block|}
specifier|const
name|uptr
name|new_chunks_count
init|=
operator|(
name|region
operator|->
name|mapped_user
operator|-
name|new_space_beg
operator|)
operator|/
name|size
decl_stmt|;
comment|// Calculate the required space for metadata.
specifier|const
name|uptr
name|requested_allocated_meta
init|=
name|region
operator|->
name|allocated_meta
operator|+
name|new_chunks_count
operator|*
name|kMetadataSize
decl_stmt|;
name|uptr
name|requested_mapped_meta
init|=
name|region
operator|->
name|mapped_meta
decl_stmt|;
while|while
condition|(
name|requested_allocated_meta
operator|>
name|requested_mapped_meta
condition|)
name|requested_mapped_meta
operator|+=
name|kMetaMapSize
expr_stmt|;
comment|// Check whether this size class is exhausted.
if|if
condition|(
name|region
operator|->
name|mapped_user
operator|+
name|requested_mapped_meta
operator|>
name|kRegionSize
operator|-
name|kFreeArraySize
condition|)
block|{
if|if
condition|(
operator|!
name|region
operator|->
name|exhausted
condition|)
block|{
name|region
operator|->
name|exhausted
operator|=
name|true
expr_stmt|;
name|Printf
argument_list|(
literal|"%s: Out of memory. "
argument_list|,
name|SanitizerToolName
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|"The process has exhausted %zuMB for size class %zu.\n"
argument_list|,
name|kRegionSize
operator|>>
literal|20
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
comment|// Map more space for metadata, if necessary.
if|if
condition|(
name|requested_mapped_meta
operator|>
name|region
operator|->
name|mapped_meta
condition|)
block|{
if|if
condition|(
name|UNLIKELY
argument_list|(
operator|!
name|MapWithCallback
argument_list|(
name|GetMetadataEnd
argument_list|(
name|region_beg
argument_list|)
operator|-
name|requested_mapped_meta
argument_list|,
name|requested_mapped_meta
operator|-
name|region
operator|->
name|mapped_meta
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|region
operator|->
name|mapped_meta
operator|=
name|requested_mapped_meta
expr_stmt|;
block|}
comment|// If necessary, allocate more space for the free array and populate it with
comment|// newly allocated chunks.
specifier|const
name|uptr
name|total_freed_chunks
init|=
name|region
operator|->
name|num_freed_chunks
operator|+
name|new_chunks_count
decl_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
operator|!
name|EnsureFreeArraySpace
argument_list|(
name|region
argument_list|,
name|region_beg
argument_list|,
name|total_freed_chunks
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|CompactPtrT
modifier|*
name|free_array
init|=
name|GetFreeArray
argument_list|(
name|region_beg
argument_list|)
decl_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|,
name|chunk
init|=
name|new_space_beg
init|;
name|i
operator|<
name|new_chunks_count
condition|;
name|i
operator|++
operator|,
name|chunk
operator|+=
name|size
control|)
name|free_array
index|[
name|total_freed_chunks
operator|-
literal|1
operator|-
name|i
index|]
operator|=
name|PointerToCompactPtr
argument_list|(
literal|0
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|kRandomShuffleChunks
condition|)
name|RandomShuffle
argument_list|(
operator|&
name|free_array
index|[
name|region
operator|->
name|num_freed_chunks
index|]
argument_list|,
name|new_chunks_count
argument_list|,
operator|&
name|region
operator|->
name|rand_state
argument_list|)
expr_stmt|;
comment|// All necessary memory is mapped and now it is safe to advance all
comment|// 'allocated_*' counters.
name|region
operator|->
name|num_freed_chunks
operator|+=
name|new_chunks_count
expr_stmt|;
name|region
operator|->
name|allocated_user
operator|+=
name|new_chunks_count
operator|*
name|size
expr_stmt|;
name|CHECK_LE
argument_list|(
name|region
operator|->
name|allocated_user
argument_list|,
name|region
operator|->
name|mapped_user
argument_list|)
expr_stmt|;
name|region
operator|->
name|allocated_meta
operator|=
name|requested_allocated_meta
expr_stmt|;
name|CHECK_LE
argument_list|(
name|region
operator|->
name|allocated_meta
argument_list|,
name|region
operator|->
name|mapped_meta
argument_list|)
expr_stmt|;
name|region
operator|->
name|exhausted
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|MaybeReleaseChunkRange
parameter_list|(
name|uptr
name|region_beg
parameter_list|,
name|uptr
name|chunk_size
parameter_list|,
name|CompactPtrT
name|first
parameter_list|,
name|CompactPtrT
name|last
parameter_list|)
block|{
name|uptr
name|beg_ptr
init|=
name|CompactPtrToPointer
argument_list|(
name|region_beg
argument_list|,
name|first
argument_list|)
decl_stmt|;
name|uptr
name|end_ptr
init|=
name|CompactPtrToPointer
argument_list|(
name|region_beg
argument_list|,
name|last
argument_list|)
operator|+
name|chunk_size
decl_stmt|;
name|ReleaseMemoryPagesToOS
argument_list|(
name|beg_ptr
argument_list|,
name|end_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Attempts to release some RAM back to OS. The region is expected to be
end_comment

begin_comment
comment|// locked.
end_comment

begin_comment
comment|// Algorithm:
end_comment

begin_comment
comment|// * Sort the chunks.
end_comment

begin_comment
comment|// * Find ranges fully covered by free-d chunks
end_comment

begin_comment
comment|// * Release them to OS with madvise.
end_comment

begin_function
name|void
name|MaybeReleaseToOS
parameter_list|(
name|uptr
name|class_id
parameter_list|)
block|{
name|RegionInfo
modifier|*
name|region
init|=
name|GetRegionInfo
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
specifier|const
name|uptr
name|chunk_size
init|=
name|ClassIdToSize
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
specifier|const
name|uptr
name|page_size
init|=
name|GetPageSizeCached
argument_list|()
decl_stmt|;
name|uptr
name|n
init|=
name|region
operator|->
name|num_freed_chunks
decl_stmt|;
if|if
condition|(
name|n
operator|*
name|chunk_size
operator|<
name|page_size
condition|)
return|return;
comment|// No chance to release anything.
if|if
condition|(
operator|(
name|region
operator|->
name|stats
operator|.
name|n_freed
operator|-
name|region
operator|->
name|rtoi
operator|.
name|n_freed_at_last_release
operator|)
operator|*
name|chunk_size
operator|<
name|page_size
condition|)
block|{
return|return;
comment|// Nothing new to release.
block|}
name|s32
name|interval_ms
init|=
name|ReleaseToOSIntervalMs
argument_list|()
decl_stmt|;
if|if
condition|(
name|interval_ms
operator|<
literal|0
condition|)
return|return;
name|u64
name|now_ns
init|=
name|NanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|region
operator|->
name|rtoi
operator|.
name|last_release_at_ns
operator|+
name|interval_ms
operator|*
literal|1000000ULL
operator|>
name|now_ns
condition|)
return|return;
comment|// Memory was returned recently.
name|region
operator|->
name|rtoi
operator|.
name|last_release_at_ns
operator|=
name|now_ns
expr_stmt|;
name|uptr
name|region_beg
init|=
name|GetRegionBeginBySizeClass
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|CompactPtrT
modifier|*
name|free_array
init|=
name|GetFreeArray
argument_list|(
name|region_beg
argument_list|)
decl_stmt|;
name|SortArray
argument_list|(
name|free_array
argument_list|,
name|n
argument_list|)
expr_stmt|;
specifier|const
name|uptr
name|scaled_chunk_size
init|=
name|chunk_size
operator|>>
name|kCompactPtrScale
decl_stmt|;
specifier|const
name|uptr
name|kScaledGranularity
init|=
name|page_size
operator|>>
name|kCompactPtrScale
decl_stmt|;
name|uptr
name|range_beg
init|=
name|free_array
index|[
literal|0
index|]
decl_stmt|;
name|uptr
name|prev
init|=
name|free_array
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|uptr
name|chunk
init|=
name|free_array
index|[
name|i
index|]
decl_stmt|;
name|CHECK_GT
argument_list|(
name|chunk
argument_list|,
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|-
name|prev
operator|!=
name|scaled_chunk_size
condition|)
block|{
name|CHECK_GT
argument_list|(
name|chunk
operator|-
name|prev
argument_list|,
name|scaled_chunk_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|+
name|scaled_chunk_size
operator|-
name|range_beg
operator|>=
name|kScaledGranularity
condition|)
block|{
name|MaybeReleaseChunkRange
argument_list|(
name|region_beg
argument_list|,
name|chunk_size
argument_list|,
name|range_beg
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|region
operator|->
name|rtoi
operator|.
name|n_freed_at_last_release
operator|=
name|region
operator|->
name|stats
operator|.
name|n_freed
expr_stmt|;
name|region
operator|->
name|rtoi
operator|.
name|num_releases
operator|++
expr_stmt|;
block|}
name|range_beg
operator|=
name|chunk
expr_stmt|;
block|}
name|prev
operator|=
name|chunk
expr_stmt|;
block|}
block|}
end_function

unit|};
end_unit

