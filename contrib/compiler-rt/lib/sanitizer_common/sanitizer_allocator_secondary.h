begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- sanitizer_allocator_secondary.h -------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Part of the Sanitizer Allocator.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SANITIZER_ALLOCATOR_H
end_ifndef

begin_error
error|#
directive|error
error|This file must be included inside sanitizer_allocator.h
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// This class can (de)allocate only large chunks of memory using mmap/unmap.
end_comment

begin_comment
comment|// The main purpose of this allocator is to cover large and rare allocation
end_comment

begin_comment
comment|// sizes not covered by more efficient allocators (e.g. SizeClassAllocator64).
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|MapUnmapCallback
operator|=
name|NoOpMapUnmapCallback
operator|>
name|class
name|LargeMmapAllocator
block|{
name|public
operator|:
name|void
name|InitLinkerInitialized
argument_list|(
argument|bool may_return_null
argument_list|)
block|{
name|page_size_
operator|=
name|GetPageSizeCached
argument_list|()
block|;
name|atomic_store
argument_list|(
operator|&
name|may_return_null_
argument_list|,
name|may_return_null
argument_list|,
name|memory_order_relaxed
argument_list|)
block|;   }
name|void
name|Init
argument_list|(
argument|bool may_return_null
argument_list|)
block|{
name|internal_memset
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
argument_list|)
block|;
name|InitLinkerInitialized
argument_list|(
name|may_return_null
argument_list|)
block|;   }
name|void
operator|*
name|Allocate
argument_list|(
argument|AllocatorStats *stat
argument_list|,
argument|uptr size
argument_list|,
argument|uptr alignment
argument_list|)
block|{
name|CHECK
argument_list|(
name|IsPowerOfTwo
argument_list|(
name|alignment
argument_list|)
argument_list|)
block|;
name|uptr
name|map_size
operator|=
name|RoundUpMapSize
argument_list|(
name|size
argument_list|)
block|;
if|if
condition|(
name|alignment
operator|>
name|page_size_
condition|)
name|map_size
operator|+=
name|alignment
expr_stmt|;
comment|// Overflow.
if|if
condition|(
name|map_size
operator|<
name|size
condition|)
return|return
name|ReturnNullOrDieOnBadRequest
argument_list|()
return|;
name|uptr
name|map_beg
operator|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|MmapOrDie
argument_list|(
name|map_size
argument_list|,
literal|"LargeMmapAllocator"
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CHECK
argument_list|(
name|IsAligned
argument_list|(
name|map_beg
argument_list|,
name|page_size_
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MapUnmapCallback
argument_list|()
operator|.
name|OnMap
argument_list|(
name|map_beg
argument_list|,
name|map_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|uptr
name|map_end
init|=
name|map_beg
operator|+
name|map_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uptr
name|res
init|=
name|map_beg
operator|+
name|page_size_
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|res
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
condition|)
comment|// Align.
name|res
operator|+=
name|alignment
operator|-
operator|(
name|res
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
end_if

begin_expr_stmt
name|CHECK
argument_list|(
name|IsAligned
argument_list|(
name|res
argument_list|,
name|alignment
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CHECK
argument_list|(
name|IsAligned
argument_list|(
name|res
argument_list|,
name|page_size_
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CHECK_GE
argument_list|(
name|res
operator|+
name|size
argument_list|,
name|map_beg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CHECK_LE
argument_list|(
name|res
operator|+
name|size
argument_list|,
name|map_end
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Header
modifier|*
name|h
init|=
name|GetHeader
argument_list|(
name|res
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|h
operator|->
name|size
operator|=
name|size
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|h
operator|->
name|map_beg
operator|=
name|map_beg
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|h
operator|->
name|map_size
operator|=
name|map_size
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|uptr
name|size_log
init|=
name|MostSignificantSetBitIndex
argument_list|(
name|map_size
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHECK_LT
argument_list|(
name|size_log
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|stats
operator|.
name|by_size_log
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|mutex_
argument_list|)
decl_stmt|;
name|uptr
name|idx
init|=
name|n_chunks_
operator|++
decl_stmt|;
name|chunks_sorted_
operator|=
name|false
expr_stmt|;
name|CHECK_LT
argument_list|(
name|idx
argument_list|,
name|kMaxNumChunks
argument_list|)
expr_stmt|;
name|h
operator|->
name|chunk_idx
operator|=
name|idx
expr_stmt|;
name|chunks_
index|[
name|idx
index|]
operator|=
name|h
expr_stmt|;
name|stats
operator|.
name|n_allocs
operator|++
expr_stmt|;
name|stats
operator|.
name|currently_allocated
operator|+=
name|map_size
expr_stmt|;
name|stats
operator|.
name|max_allocated
operator|=
name|Max
argument_list|(
name|stats
operator|.
name|max_allocated
argument_list|,
name|stats
operator|.
name|currently_allocated
argument_list|)
expr_stmt|;
name|stats
operator|.
name|by_size_log
index|[
name|size_log
index|]
operator|++
expr_stmt|;
name|stat
operator|->
name|Add
argument_list|(
name|AllocatorStatAllocated
argument_list|,
name|map_size
argument_list|)
expr_stmt|;
name|stat
operator|->
name|Add
argument_list|(
name|AllocatorStatMapped
argument_list|,
name|map_size
argument_list|)
expr_stmt|;
block|}
end_block

begin_return
return|return
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|res
operator|)
return|;
end_return

begin_macro
unit|}    bool
name|MayReturnNull
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
return|return
name|atomic_load
argument_list|(
operator|&
name|may_return_null_
argument_list|,
name|memory_order_acquire
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
modifier|*
name|ReturnNullOrDieOnBadRequest
parameter_list|()
block|{
if|if
condition|(
name|MayReturnNull
argument_list|()
condition|)
return|return
name|nullptr
return|;
name|ReportAllocatorCannotReturnNull
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|ReturnNullOrDieOnOOM
parameter_list|()
block|{
if|if
condition|(
name|MayReturnNull
argument_list|()
condition|)
return|return
name|nullptr
return|;
name|ReportAllocatorCannotReturnNull
argument_list|(
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetMayReturnNull
parameter_list|(
name|bool
name|may_return_null
parameter_list|)
block|{
name|atomic_store
argument_list|(
operator|&
name|may_return_null_
argument_list|,
name|may_return_null
argument_list|,
name|memory_order_release
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Deallocate
parameter_list|(
name|AllocatorStats
modifier|*
name|stat
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|Header
modifier|*
name|h
init|=
name|GetHeader
argument_list|(
name|p
argument_list|)
decl_stmt|;
block|{
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|mutex_
argument_list|)
decl_stmt|;
name|uptr
name|idx
init|=
name|h
operator|->
name|chunk_idx
decl_stmt|;
name|CHECK_EQ
argument_list|(
name|chunks_
index|[
name|idx
index|]
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|CHECK_LT
argument_list|(
name|idx
argument_list|,
name|n_chunks_
argument_list|)
expr_stmt|;
name|chunks_
index|[
name|idx
index|]
operator|=
name|chunks_
index|[
name|n_chunks_
operator|-
literal|1
index|]
expr_stmt|;
name|chunks_
index|[
name|idx
index|]
operator|->
name|chunk_idx
operator|=
name|idx
expr_stmt|;
name|n_chunks_
operator|--
expr_stmt|;
name|chunks_sorted_
operator|=
name|false
expr_stmt|;
name|stats
operator|.
name|n_frees
operator|++
expr_stmt|;
name|stats
operator|.
name|currently_allocated
operator|-=
name|h
operator|->
name|map_size
expr_stmt|;
name|stat
operator|->
name|Sub
argument_list|(
name|AllocatorStatAllocated
argument_list|,
name|h
operator|->
name|map_size
argument_list|)
expr_stmt|;
name|stat
operator|->
name|Sub
argument_list|(
name|AllocatorStatMapped
argument_list|,
name|h
operator|->
name|map_size
argument_list|)
expr_stmt|;
block|}
name|MapUnmapCallback
argument_list|()
operator|.
name|OnUnmap
argument_list|(
name|h
operator|->
name|map_beg
argument_list|,
name|h
operator|->
name|map_size
argument_list|)
expr_stmt|;
name|UnmapOrDie
argument_list|(
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|h
operator|->
name|map_beg
operator|)
argument_list|,
name|h
operator|->
name|map_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uptr
name|TotalMemoryUsed
parameter_list|()
block|{
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|mutex_
argument_list|)
decl_stmt|;
name|uptr
name|res
init|=
literal|0
decl_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n_chunks_
condition|;
name|i
operator|++
control|)
block|{
name|Header
modifier|*
name|h
init|=
name|chunks_
index|[
name|i
index|]
decl_stmt|;
name|CHECK_EQ
argument_list|(
name|h
operator|->
name|chunk_idx
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|res
operator|+=
name|RoundUpMapSize
argument_list|(
name|h
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
name|bool
name|PointerIsMine
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
name|GetBlockBegin
argument_list|(
name|p
argument_list|)
operator|!=
name|nullptr
return|;
block|}
end_function

begin_function
name|uptr
name|GetActuallyAllocatedSize
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
name|RoundUpTo
argument_list|(
name|GetHeader
argument_list|(
name|p
argument_list|)
operator|->
name|size
argument_list|,
name|page_size_
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// At least page_size_/2 metadata bytes is available.
end_comment

begin_function
name|void
modifier|*
name|GetMetaData
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
comment|// Too slow: CHECK_EQ(p, GetBlockBegin(p));
if|if
condition|(
operator|!
name|IsAligned
argument_list|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
argument_list|,
name|page_size_
argument_list|)
condition|)
block|{
name|Printf
argument_list|(
literal|"%s: bad pointer %p\n"
argument_list|,
name|SanitizerToolName
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|IsAligned
argument_list|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
argument_list|,
name|page_size_
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|GetHeader
argument_list|(
name|p
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|GetBlockBegin
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|uptr
name|p
init|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|ptr
operator|)
decl_stmt|;
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|mutex_
argument_list|)
decl_stmt|;
name|uptr
name|nearest_chunk
init|=
literal|0
decl_stmt|;
comment|// Cache-friendly linear search.
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n_chunks_
condition|;
name|i
operator|++
control|)
block|{
name|uptr
name|ch
init|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|chunks_
index|[
name|i
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|p
operator|<
name|ch
condition|)
continue|continue;
comment|// p is at left to this chunk, skip it.
if|if
condition|(
name|p
operator|-
name|ch
operator|<
name|p
operator|-
name|nearest_chunk
condition|)
name|nearest_chunk
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nearest_chunk
condition|)
return|return
name|nullptr
return|;
name|Header
modifier|*
name|h
init|=
name|reinterpret_cast
operator|<
name|Header
operator|*
operator|>
operator|(
name|nearest_chunk
operator|)
decl_stmt|;
name|CHECK_GE
argument_list|(
name|nearest_chunk
argument_list|,
name|h
operator|->
name|map_beg
argument_list|)
expr_stmt|;
name|CHECK_LT
argument_list|(
name|nearest_chunk
argument_list|,
name|h
operator|->
name|map_beg
operator|+
name|h
operator|->
name|map_size
argument_list|)
expr_stmt|;
name|CHECK_LE
argument_list|(
name|nearest_chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|map_beg
operator|+
name|h
operator|->
name|map_size
operator|<=
name|p
condition|)
return|return
name|nullptr
return|;
return|return
name|GetUser
argument_list|(
name|h
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|EnsureSortedChunks
parameter_list|()
block|{
if|if
condition|(
name|chunks_sorted_
condition|)
return|return;
name|SortArray
argument_list|(
name|reinterpret_cast
operator|<
name|uptr
operator|*
operator|>
operator|(
name|chunks_
operator|)
argument_list|,
name|n_chunks_
argument_list|)
expr_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n_chunks_
condition|;
name|i
operator|++
control|)
name|chunks_
index|[
name|i
index|]
operator|->
name|chunk_idx
operator|=
name|i
expr_stmt|;
name|chunks_sorted_
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|// This function does the same as GetBlockBegin, but is much faster.
end_comment

begin_comment
comment|// Must be called with the allocator locked.
end_comment

begin_function
name|void
modifier|*
name|GetBlockBeginFastLocked
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|mutex_
operator|.
name|CheckLocked
argument_list|()
expr_stmt|;
name|uptr
name|p
init|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|ptr
operator|)
decl_stmt|;
name|uptr
name|n
init|=
name|n_chunks_
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|nullptr
return|;
name|EnsureSortedChunks
argument_list|()
expr_stmt|;
name|auto
name|min_mmap_
init|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|chunks_
index|[
literal|0
index|]
operator|)
decl_stmt|;
name|auto
name|max_mmap_
init|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|chunks_
index|[
name|n
operator|-
literal|1
index|]
operator|)
operator|+
name|chunks_
index|[
name|n
operator|-
literal|1
index|]
operator|->
name|map_size
decl_stmt|;
if|if
condition|(
name|p
operator|<
name|min_mmap_
operator|||
name|p
operator|>=
name|max_mmap_
condition|)
return|return
name|nullptr
return|;
name|uptr
name|beg
init|=
literal|0
decl_stmt|,
name|end
init|=
name|n
operator|-
literal|1
decl_stmt|;
comment|// This loop is a log(n) lower_bound. It does not check for the exact match
comment|// to avoid expensive cache-thrashing loads.
while|while
condition|(
name|end
operator|-
name|beg
operator|>=
literal|2
condition|)
block|{
name|uptr
name|mid
init|=
operator|(
name|beg
operator|+
name|end
operator|)
operator|/
literal|2
decl_stmt|;
comment|// Invariant: mid>= beg + 1
if|if
condition|(
name|p
operator|<
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|chunks_
index|[
name|mid
index|]
operator|)
condition|)
name|end
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
comment|// We are not interested in chunks_[mid].
else|else
name|beg
operator|=
name|mid
expr_stmt|;
comment|// chunks_[mid] may still be what we want.
block|}
if|if
condition|(
name|beg
operator|<
name|end
condition|)
block|{
name|CHECK_EQ
argument_list|(
name|beg
operator|+
literal|1
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|// There are 2 chunks left, choose one.
if|if
condition|(
name|p
operator|>=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|chunks_
index|[
name|end
index|]
operator|)
condition|)
name|beg
operator|=
name|end
expr_stmt|;
block|}
name|Header
modifier|*
name|h
init|=
name|chunks_
index|[
name|beg
index|]
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|map_beg
operator|+
name|h
operator|->
name|map_size
operator|<=
name|p
operator|||
name|p
operator|<
name|h
operator|->
name|map_beg
condition|)
return|return
name|nullptr
return|;
return|return
name|GetUser
argument_list|(
name|h
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|PrintStats
parameter_list|()
block|{
name|Printf
argument_list|(
literal|"Stats: LargeMmapAllocator: allocated %zd times, "
literal|"remains %zd (%zd K) max %zd M; by size logs: "
argument_list|,
name|stats
operator|.
name|n_allocs
argument_list|,
name|stats
operator|.
name|n_allocs
operator|-
name|stats
operator|.
name|n_frees
argument_list|,
name|stats
operator|.
name|currently_allocated
operator|>>
literal|10
argument_list|,
name|stats
operator|.
name|max_allocated
operator|>>
literal|20
argument_list|)
expr_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|stats
operator|.
name|by_size_log
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|uptr
name|c
init|=
name|stats
operator|.
name|by_size_log
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
continue|continue;
name|Printf
argument_list|(
literal|"%zd:%zd; "
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|Printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone
end_comment

begin_comment
comment|// introspection API.
end_comment

begin_function
name|void
name|ForceLock
parameter_list|()
block|{
name|mutex_
operator|.
name|Lock
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ForceUnlock
parameter_list|()
block|{
name|mutex_
operator|.
name|Unlock
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|// Iterate over all existing chunks.
end_comment

begin_comment
comment|// The allocator must be locked when calling this function.
end_comment

begin_function
name|void
name|ForEachChunk
parameter_list|(
name|ForEachChunkCallback
name|callback
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|EnsureSortedChunks
argument_list|()
expr_stmt|;
comment|// Avoid doing the sort while iterating.
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n_chunks_
condition|;
name|i
operator|++
control|)
block|{
name|auto
name|t
init|=
name|chunks_
index|[
name|i
index|]
decl_stmt|;
name|callback
argument_list|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|GetUser
argument_list|(
name|chunks_
index|[
name|i
index|]
argument_list|)
operator|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|// Consistency check: verify that the array did not change.
name|CHECK_EQ
argument_list|(
name|chunks_
index|[
name|i
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|CHECK_EQ
argument_list|(
name|chunks_
index|[
name|i
index|]
operator|->
name|chunk_idx
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_label
name|private
label|:
end_label

begin_decl_stmt
specifier|static
specifier|const
name|int
name|kMaxNumChunks
init|=
literal|1
operator|<<
name|FIRST_32_SECOND_64
argument_list|(
literal|15
argument_list|,
literal|18
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|Header
block|{
name|uptr
name|map_beg
decl_stmt|;
name|uptr
name|map_size
decl_stmt|;
name|uptr
name|size
decl_stmt|;
name|uptr
name|chunk_idx
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|Header
modifier|*
name|GetHeader
parameter_list|(
name|uptr
name|p
parameter_list|)
block|{
name|CHECK
argument_list|(
name|IsAligned
argument_list|(
name|p
argument_list|,
name|page_size_
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reinterpret_cast
operator|<
name|Header
operator|*
operator|>
operator|(
name|p
operator|-
name|page_size_
operator|)
return|;
block|}
end_function

begin_function
name|Header
modifier|*
name|GetHeader
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
name|GetHeader
argument_list|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|GetUser
parameter_list|(
name|Header
modifier|*
name|h
parameter_list|)
block|{
name|CHECK
argument_list|(
name|IsAligned
argument_list|(
operator|(
name|uptr
operator|)
name|h
argument_list|,
name|page_size_
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|h
operator|)
operator|+
name|page_size_
operator|)
return|;
block|}
end_function

begin_function
name|uptr
name|RoundUpMapSize
parameter_list|(
name|uptr
name|size
parameter_list|)
block|{
return|return
name|RoundUpTo
argument_list|(
name|size
argument_list|,
name|page_size_
argument_list|)
operator|+
name|page_size_
return|;
block|}
end_function

begin_decl_stmt
name|uptr
name|page_size_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Header
modifier|*
name|chunks_
index|[
name|kMaxNumChunks
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uptr
name|n_chunks_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|chunks_sorted_
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|Stats
block|{
name|uptr
name|n_allocs
decl_stmt|,
name|n_frees
decl_stmt|,
name|currently_allocated
decl_stmt|,
name|max_allocated
decl_stmt|,
name|by_size_log
index|[
literal|64
index|]
decl_stmt|;
block|}
name|stats
struct|;
end_struct

begin_decl_stmt
name|atomic_uint8_t
name|may_return_null_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SpinMutex
name|mutex_
decl_stmt|;
end_decl_stmt

unit|};
end_unit

