begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- sanitizer_bvgraph.h -------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is a part of Sanitizer runtime.
end_comment

begin_comment
comment|// BVGraph -- a directed graph.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SANITIZER_BVGRAPH_H
end_ifndef

begin_define
define|#
directive|define
name|SANITIZER_BVGRAPH_H
end_define

begin_include
include|#
directive|include
file|"sanitizer_common.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_bitvector.h"
end_include

begin_decl_stmt
name|namespace
name|__sanitizer
block|{
comment|// Directed graph of fixed size implemented as an array of bit vectors.
comment|// Not thread-safe, all accesses should be protected by an external lock.
name|template
operator|<
name|class
name|BV
operator|>
name|class
name|BVGraph
block|{
name|public
operator|:
expr|enum
name|SizeEnum
block|{
name|kSize
operator|=
name|BV
operator|::
name|kSize
block|}
block|;
name|uptr
name|size
argument_list|()
specifier|const
block|{
return|return
name|kSize
return|;
block|}
comment|// No CTOR.
name|void
name|clear
argument_list|()
block|{
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
name|v
index|[
name|i
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|v
index|[
name|i
index|]
operator|.
name|empty
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
comment|// Returns true if a new edge was added.
name|bool
name|addEdge
parameter_list|(
name|uptr
name|from
parameter_list|,
name|uptr
name|to
parameter_list|)
block|{
name|check
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
name|v
index|[
name|from
index|]
operator|.
name|setBit
argument_list|(
name|to
argument_list|)
return|;
block|}
comment|// Returns true if at least one new edge was added.
name|uptr
name|addEdges
parameter_list|(
specifier|const
name|BV
modifier|&
name|from
parameter_list|,
name|uptr
name|to
parameter_list|,
name|uptr
name|added_edges
index|[]
parameter_list|,
name|uptr
name|max_added_edges
parameter_list|)
block|{
name|uptr
name|res
init|=
literal|0
decl_stmt|;
name|t1
operator|.
name|copyFrom
argument_list|(
name|from
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|t1
operator|.
name|empty
argument_list|()
condition|)
block|{
name|uptr
name|node
init|=
name|t1
operator|.
name|getAndClearFirstOne
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
index|[
name|node
index|]
operator|.
name|setBit
argument_list|(
name|to
argument_list|)
condition|)
if|if
condition|(
name|res
operator|<
name|max_added_edges
condition|)
name|added_edges
index|[
name|res
operator|++
index|]
operator|=
name|node
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
comment|// *EXPERIMENTAL*
comment|// Returns true if an edge from=>to exist.
comment|// This function does not use any global state except for 'this' itself,
comment|// and thus can be called from different threads w/o locking.
comment|// This would be racy.
comment|// FIXME: investigate how much we can prove about this race being "benign".
name|bool
name|hasEdge
parameter_list|(
name|uptr
name|from
parameter_list|,
name|uptr
name|to
parameter_list|)
block|{
return|return
name|v
index|[
name|from
index|]
operator|.
name|getBit
argument_list|(
name|to
argument_list|)
return|;
block|}
comment|// Returns true if the edge from=>to was removed.
name|bool
name|removeEdge
parameter_list|(
name|uptr
name|from
parameter_list|,
name|uptr
name|to
parameter_list|)
block|{
return|return
name|v
index|[
name|from
index|]
operator|.
name|clearBit
argument_list|(
name|to
argument_list|)
return|;
block|}
comment|// Returns true if at least one edge *=>to was removed.
name|bool
name|removeEdgesTo
parameter_list|(
specifier|const
name|BV
modifier|&
name|to
parameter_list|)
block|{
name|bool
name|res
init|=
literal|0
decl_stmt|;
for|for
control|(
name|uptr
name|from
init|=
literal|0
init|;
name|from
operator|<
name|size
argument_list|()
condition|;
name|from
operator|++
control|)
block|{
if|if
condition|(
name|v
index|[
name|from
index|]
operator|.
name|setDifference
argument_list|(
name|to
argument_list|)
condition|)
name|res
operator|=
name|true
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
comment|// Returns true if at least one edge from=>* was removed.
name|bool
name|removeEdgesFrom
parameter_list|(
specifier|const
name|BV
modifier|&
name|from
parameter_list|)
block|{
name|bool
name|res
init|=
name|false
decl_stmt|;
name|t1
operator|.
name|copyFrom
argument_list|(
name|from
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|t1
operator|.
name|empty
argument_list|()
condition|)
block|{
name|uptr
name|idx
init|=
name|t1
operator|.
name|getAndClearFirstOne
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|v
index|[
name|idx
index|]
operator|.
name|empty
argument_list|()
condition|)
block|{
name|v
index|[
name|idx
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
name|res
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
name|void
name|removeEdgesFrom
parameter_list|(
name|uptr
name|from
parameter_list|)
block|{
return|return
name|v
index|[
name|from
index|]
operator|.
name|clear
argument_list|()
return|;
block|}
name|bool
name|hasEdge
argument_list|(
name|uptr
name|from
argument_list|,
name|uptr
name|to
argument_list|)
decl|const
block|{
name|check
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
name|v
index|[
name|from
index|]
operator|.
name|getBit
argument_list|(
name|to
argument_list|)
return|;
block|}
comment|// Returns true if there is a path from the node 'from'
comment|// to any of the nodes in 'targets'.
name|bool
name|isReachable
parameter_list|(
name|uptr
name|from
parameter_list|,
specifier|const
name|BV
modifier|&
name|targets
parameter_list|)
block|{
name|BV
modifier|&
name|to_visit
init|=
name|t1
decl_stmt|,
modifier|&
name|visited
init|=
name|t2
decl_stmt|;
name|to_visit
operator|.
name|copyFrom
argument_list|(
name|v
index|[
name|from
index|]
argument_list|)
expr_stmt|;
name|visited
operator|.
name|clear
argument_list|()
expr_stmt|;
name|visited
operator|.
name|setBit
argument_list|(
name|from
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|to_visit
operator|.
name|empty
argument_list|()
condition|)
block|{
name|uptr
name|idx
init|=
name|to_visit
operator|.
name|getAndClearFirstOne
argument_list|()
decl_stmt|;
if|if
condition|(
name|visited
operator|.
name|setBit
argument_list|(
name|idx
argument_list|)
condition|)
name|to_visit
operator|.
name|setUnion
argument_list|(
name|v
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|targets
operator|.
name|intersectsWith
argument_list|(
name|visited
argument_list|)
return|;
block|}
comment|// Finds a path from 'from' to one of the nodes in 'target',
comment|// stores up to 'path_size' items of the path into 'path',
comment|// returns the path length, or 0 if there is no path of size 'path_size'.
name|uptr
name|findPath
parameter_list|(
name|uptr
name|from
parameter_list|,
specifier|const
name|BV
modifier|&
name|targets
parameter_list|,
name|uptr
modifier|*
name|path
parameter_list|,
name|uptr
name|path_size
parameter_list|)
block|{
if|if
condition|(
name|path_size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|path
index|[
literal|0
index|]
operator|=
name|from
expr_stmt|;
if|if
condition|(
name|targets
operator|.
name|getBit
argument_list|(
name|from
argument_list|)
condition|)
return|return
literal|1
return|;
comment|// The function is recursive, so we don't want to create BV on stack.
comment|// Instead of a getAndClearFirstOne loop we use the slower iterator.
for|for
control|(
name|typename
name|BV
operator|::
name|Iterator
name|it
argument_list|(
name|v
index|[
name|from
index|]
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|uptr
name|idx
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|uptr
name|res
init|=
name|findPath
argument_list|(
name|idx
argument_list|,
name|targets
argument_list|,
name|path
operator|+
literal|1
argument_list|,
name|path_size
operator|-
literal|1
argument_list|)
condition|)
return|return
name|res
operator|+
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|// Same as findPath, but finds a shortest path.
name|uptr
name|findShortestPath
parameter_list|(
name|uptr
name|from
parameter_list|,
specifier|const
name|BV
modifier|&
name|targets
parameter_list|,
name|uptr
modifier|*
name|path
parameter_list|,
name|uptr
name|path_size
parameter_list|)
block|{
for|for
control|(
name|uptr
name|p
init|=
literal|1
init|;
name|p
operator|<=
name|path_size
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|findPath
argument_list|(
name|from
argument_list|,
name|targets
argument_list|,
name|path
argument_list|,
name|p
argument_list|)
operator|==
name|p
condition|)
return|return
name|p
return|;
return|return
literal|0
return|;
block|}
name|private
label|:
name|void
name|check
argument_list|(
name|uptr
name|idx1
argument_list|,
name|uptr
name|idx2
argument_list|)
decl|const
block|{
name|CHECK_LT
argument_list|(
name|idx1
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|CHECK_LT
argument_list|(
name|idx2
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|BV
name|v
index|[
name|kSize
index|]
decl_stmt|;
comment|// Keep temporary vectors here since we can not create large objects on stack.
name|BV
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// namespace __sanitizer
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// SANITIZER_BVGRAPH_H
end_comment

end_unit

