begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- sanitizer_common.h --------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is shared between run-time libraries of sanitizers.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// It declares common functions and classes that are used in both runtimes.
end_comment

begin_comment
comment|// Implementation of some functions are provided in sanitizer_common, while
end_comment

begin_comment
comment|// others must be defined by run-time library itself.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SANITIZER_COMMON_H
end_ifndef

begin_define
define|#
directive|define
name|SANITIZER_COMMON_H
end_define

begin_include
include|#
directive|include
file|"sanitizer_flags.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_interface_internal.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_internal_defs.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_libc.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_list.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_mutex.h"
end_include

begin_decl_stmt
name|namespace
name|__sanitizer
block|{
struct_decl|struct
name|StackTrace
struct_decl|;
comment|// Constants.
specifier|const
name|uptr
name|kWordSize
init|=
name|SANITIZER_WORDSIZE
operator|/
literal|8
decl_stmt|;
specifier|const
name|uptr
name|kWordSizeInBits
init|=
literal|8
operator|*
name|kWordSize
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__powerpc__
argument_list|)
operator|||
name|defined
argument_list|(
name|__powerpc64__
argument_list|)
specifier|const
name|uptr
name|kCacheLineSize
init|=
literal|128
decl_stmt|;
else|#
directive|else
specifier|const
name|uptr
name|kCacheLineSize
init|=
literal|64
decl_stmt|;
endif|#
directive|endif
specifier|const
name|uptr
name|kMaxPathLength
init|=
literal|4096
decl_stmt|;
specifier|const
name|uptr
name|kMaxThreadStackSize
init|=
literal|1
operator|<<
literal|30
decl_stmt|;
comment|// 1Gb
specifier|extern
specifier|const
name|char
modifier|*
name|SanitizerToolName
decl_stmt|;
comment|// Can be changed by the tool.
specifier|extern
name|atomic_uint32_t
name|current_verbosity
decl_stmt|;
name|INLINE
name|void
name|SetVerbosity
parameter_list|(
name|int
name|verbosity
parameter_list|)
block|{
name|atomic_store
argument_list|(
operator|&
name|current_verbosity
argument_list|,
name|verbosity
argument_list|,
name|memory_order_relaxed
argument_list|)
expr_stmt|;
block|}
name|INLINE
name|int
name|Verbosity
parameter_list|()
block|{
return|return
name|atomic_load
argument_list|(
operator|&
name|current_verbosity
argument_list|,
name|memory_order_relaxed
argument_list|)
return|;
block|}
name|uptr
name|GetPageSize
parameter_list|()
function_decl|;
name|uptr
name|GetPageSizeCached
parameter_list|()
function_decl|;
name|uptr
name|GetMmapGranularity
parameter_list|()
function_decl|;
name|uptr
name|GetMaxVirtualAddress
parameter_list|()
function_decl|;
comment|// Threads
name|uptr
name|GetTid
parameter_list|()
function_decl|;
name|uptr
name|GetThreadSelf
parameter_list|()
function_decl|;
name|void
name|GetThreadStackTopAndBottom
parameter_list|(
name|bool
name|at_initialization
parameter_list|,
name|uptr
modifier|*
name|stack_top
parameter_list|,
name|uptr
modifier|*
name|stack_bottom
parameter_list|)
function_decl|;
name|void
name|GetThreadStackAndTls
argument_list|(
name|bool
expr|main
argument_list|,
name|uptr
operator|*
name|stk_addr
argument_list|,
name|uptr
operator|*
name|stk_size
argument_list|,
name|uptr
operator|*
name|tls_addr
argument_list|,
name|uptr
operator|*
name|tls_size
argument_list|)
decl_stmt|;
comment|// Memory management
name|void
modifier|*
name|MmapOrDie
parameter_list|(
name|uptr
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|mem_type
parameter_list|)
function_decl|;
name|void
name|UnmapOrDie
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
name|void
modifier|*
name|MmapFixedNoReserve
parameter_list|(
name|uptr
name|fixed_addr
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
name|void
modifier|*
name|MmapNoReserveOrDie
parameter_list|(
name|uptr
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|mem_type
parameter_list|)
function_decl|;
name|void
modifier|*
name|MmapFixedOrDie
parameter_list|(
name|uptr
name|fixed_addr
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
name|void
modifier|*
name|Mprotect
parameter_list|(
name|uptr
name|fixed_addr
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
comment|// Map aligned chunk of address space; size and alignment are powers of two.
name|void
modifier|*
name|MmapAlignedOrDie
parameter_list|(
name|uptr
name|size
parameter_list|,
name|uptr
name|alignment
parameter_list|,
specifier|const
name|char
modifier|*
name|mem_type
parameter_list|)
function_decl|;
comment|// Used to check if we can map shadow memory to a fixed location.
name|bool
name|MemoryRangeIsAvailable
parameter_list|(
name|uptr
name|range_start
parameter_list|,
name|uptr
name|range_end
parameter_list|)
function_decl|;
name|void
name|FlushUnneededShadowMemory
parameter_list|(
name|uptr
name|addr
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
name|void
name|IncreaseTotalMmap
parameter_list|(
name|uptr
name|size
parameter_list|)
function_decl|;
name|void
name|DecreaseTotalMmap
parameter_list|(
name|uptr
name|size
parameter_list|)
function_decl|;
name|uptr
name|GetRSS
parameter_list|()
function_decl|;
name|void
name|NoHugePagesInRegion
parameter_list|(
name|uptr
name|addr
parameter_list|,
name|uptr
name|length
parameter_list|)
function_decl|;
name|void
name|DontDumpShadowMemory
parameter_list|(
name|uptr
name|addr
parameter_list|,
name|uptr
name|length
parameter_list|)
function_decl|;
comment|// InternalScopedBuffer can be used instead of large stack arrays to
comment|// keep frame size low.
comment|// FIXME: use InternalAlloc instead of MmapOrDie once
comment|// InternalAlloc is made libc-free.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|InternalScopedBuffer
block|{
name|public
operator|:
name|explicit
name|InternalScopedBuffer
argument_list|(
argument|uptr cnt
argument_list|)
block|{
name|cnt_
operator|=
name|cnt
block|;
name|ptr_
operator|=
operator|(
name|T
operator|*
operator|)
name|MmapOrDie
argument_list|(
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|,
literal|"InternalScopedBuffer"
argument_list|)
block|;   }
operator|~
name|InternalScopedBuffer
argument_list|()
block|{
name|UnmapOrDie
argument_list|(
name|ptr_
argument_list|,
name|cnt_
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
block|;   }
name|T
operator|&
name|operator
index|[]
operator|(
name|uptr
name|i
operator|)
block|{
return|return
name|ptr_
index|[
name|i
index|]
return|;
block|}
name|T
operator|*
name|data
argument_list|()
block|{
return|return
name|ptr_
return|;
block|}
name|uptr
name|size
argument_list|()
block|{
return|return
name|cnt_
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
return|;
block|}
name|private
operator|:
name|T
operator|*
name|ptr_
block|;
name|uptr
name|cnt_
block|;
comment|// Disallow evil constructors.
name|InternalScopedBuffer
argument_list|(
specifier|const
name|InternalScopedBuffer
operator|&
argument_list|)
block|;
name|void
name|operator
operator|=
operator|(
specifier|const
name|InternalScopedBuffer
operator|&
operator|)
block|; }
expr_stmt|;
name|class
name|InternalScopedString
range|:
name|public
name|InternalScopedBuffer
operator|<
name|char
operator|>
block|{
name|public
operator|:
name|explicit
name|InternalScopedString
argument_list|(
argument|uptr max_length
argument_list|)
operator|:
name|InternalScopedBuffer
operator|<
name|char
operator|>
operator|(
name|max_length
operator|)
block|,
name|length_
argument_list|(
literal|0
argument_list|)
block|{
operator|(
operator|*
name|this
operator|)
index|[
literal|0
index|]
operator|=
literal|'\0'
block|;   }
name|uptr
name|length
argument_list|()
block|{
return|return
name|length_
return|;
block|}
name|void
name|clear
argument_list|()
block|{
operator|(
operator|*
name|this
operator|)
index|[
literal|0
index|]
operator|=
literal|'\0'
block|;
name|length_
operator|=
literal|0
block|;   }
name|void
name|append
argument_list|(
specifier|const
name|char
operator|*
name|format
argument_list|,
operator|...
argument_list|)
block|;
name|private
operator|:
name|uptr
name|length_
block|; }
decl_stmt|;
comment|// Simple low-level (mmap-based) allocator for internal use. Doesn't have
comment|// constructor, so all instances of LowLevelAllocator should be
comment|// linker initialized.
name|class
name|LowLevelAllocator
block|{
name|public
label|:
comment|// Requires an external lock.
name|void
modifier|*
name|Allocate
parameter_list|(
name|uptr
name|size
parameter_list|)
function_decl|;
name|private
label|:
name|char
modifier|*
name|allocated_end_
decl_stmt|;
name|char
modifier|*
name|allocated_current_
decl_stmt|;
block|}
empty_stmt|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|LowLevelAllocateCallback
function_decl|)
parameter_list|(
name|uptr
name|ptr
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
comment|// Allows to register tool-specific callbacks for LowLevelAllocator.
comment|// Passing NULL removes the callback.
name|void
name|SetLowLevelAllocateCallback
parameter_list|(
name|LowLevelAllocateCallback
name|callback
parameter_list|)
function_decl|;
comment|// IO
name|void
name|RawWrite
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer
parameter_list|)
function_decl|;
name|bool
name|ColorizeReports
parameter_list|()
function_decl|;
name|void
name|Printf
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
name|void
name|Report
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
name|void
name|SetPrintfAndReportCallback
parameter_list|(
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
define|#
directive|define
name|VReport
parameter_list|(
name|level
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do {                                                                   \     if ((uptr)Verbosity()>= (level)) Report(__VA_ARGS__); \   } while (0)
define|#
directive|define
name|VPrintf
parameter_list|(
name|level
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do {                                                                   \     if ((uptr)Verbosity()>= (level)) Printf(__VA_ARGS__); \   } while (0)
comment|// Can be used to prevent mixing error reports from different sanitizers.
specifier|extern
name|StaticSpinMutex
name|CommonSanitizerReportMutex
decl_stmt|;
struct|struct
name|ReportFile
block|{
name|void
name|Write
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|uptr
name|length
parameter_list|)
function_decl|;
name|bool
name|PrintsToTty
parameter_list|()
function_decl|;
name|void
name|SetReportPath
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
function_decl|;
comment|// Don't use fields directly. They are only declared public to allow
comment|// aggregate initialization.
comment|// Protects fields below.
name|StaticSpinMutex
modifier|*
name|mu
decl_stmt|;
comment|// Opened file descriptor. Defaults to stderr. It may be equal to
comment|// kInvalidFd, in which case new file will be opened when necessary.
name|fd_t
name|fd
decl_stmt|;
comment|// Path prefix of report file, set via __sanitizer_set_report_path.
name|char
name|path_prefix
index|[
name|kMaxPathLength
index|]
decl_stmt|;
comment|// Full path to report, obtained as<path_prefix>.PID
name|char
name|full_path
index|[
name|kMaxPathLength
index|]
decl_stmt|;
comment|// PID of the process that opened fd. If a fork() occurs,
comment|// the PID of child will be different from fd_pid.
name|uptr
name|fd_pid
decl_stmt|;
name|private
label|:
name|void
name|ReopenIfNecessary
parameter_list|()
function_decl|;
block|}
struct|;
specifier|extern
name|ReportFile
name|report_file
decl_stmt|;
specifier|extern
name|uptr
name|stoptheworld_tracer_pid
decl_stmt|;
specifier|extern
name|uptr
name|stoptheworld_tracer_ppid
decl_stmt|;
name|uptr
name|OpenFile
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|bool
name|write
parameter_list|)
function_decl|;
comment|// Opens the file 'file_name" and reads up to 'max_len' bytes.
comment|// The resulting buffer is mmaped and stored in '*buff'.
comment|// The size of the mmaped region is stored in '*buff_size',
comment|// Returns the number of read bytes or 0 if file can not be opened.
name|uptr
name|ReadFileToBuffer
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|buff
parameter_list|,
name|uptr
modifier|*
name|buff_size
parameter_list|,
name|uptr
name|max_len
parameter_list|,
name|int
modifier|*
name|errno_p
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|// Maps given file to virtual memory, and returns pointer to it
comment|// (or NULL if the mapping failes). Stores the size of mmaped region
comment|// in '*buff_size'.
name|void
modifier|*
name|MapFileToMemory
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
name|uptr
modifier|*
name|buff_size
parameter_list|)
function_decl|;
name|void
modifier|*
name|MapWritableFileToMemory
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|uptr
name|size
parameter_list|,
name|uptr
name|fd
parameter_list|,
name|uptr
name|offset
parameter_list|)
function_decl|;
name|bool
name|IsAccessibleMemoryRange
parameter_list|(
name|uptr
name|beg
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
comment|// Error report formatting.
specifier|const
name|char
modifier|*
name|StripPathPrefix
parameter_list|(
specifier|const
name|char
modifier|*
name|filepath
parameter_list|,
specifier|const
name|char
modifier|*
name|strip_file_prefix
parameter_list|)
function_decl|;
comment|// Strip the directories from the module name.
specifier|const
name|char
modifier|*
name|StripModuleName
parameter_list|(
specifier|const
name|char
modifier|*
name|module
parameter_list|)
function_decl|;
comment|// OS
name|void
name|DisableCoreDumperIfNecessary
parameter_list|()
function_decl|;
name|void
name|DumpProcessMap
parameter_list|()
function_decl|;
name|bool
name|FileExists
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|GetEnv
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
name|bool
name|SetEnv
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|GetPwd
parameter_list|()
function_decl|;
name|char
modifier|*
name|FindPathToBinary
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
name|u32
name|GetUid
parameter_list|()
function_decl|;
name|void
name|ReExec
parameter_list|()
function_decl|;
name|bool
name|StackSizeIsUnlimited
parameter_list|()
function_decl|;
name|void
name|SetStackSizeLimitInBytes
parameter_list|(
name|uptr
name|limit
parameter_list|)
function_decl|;
name|bool
name|AddressSpaceIsUnlimited
parameter_list|()
function_decl|;
name|void
name|SetAddressSpaceUnlimited
parameter_list|()
function_decl|;
name|void
name|AdjustStackSize
parameter_list|(
name|void
modifier|*
name|attr
parameter_list|)
function_decl|;
name|void
name|PrepareForSandboxing
parameter_list|(
name|__sanitizer_sandbox_arguments
modifier|*
name|args
parameter_list|)
function_decl|;
name|void
name|CovPrepareForSandboxing
parameter_list|(
name|__sanitizer_sandbox_arguments
modifier|*
name|args
parameter_list|)
function_decl|;
name|void
name|SetSandboxingCallback
parameter_list|(
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
parameter_list|)
function_decl|;
name|void
name|CoverageUpdateMapping
parameter_list|()
function_decl|;
name|void
name|CovBeforeFork
parameter_list|()
function_decl|;
name|void
name|CovAfterFork
parameter_list|(
name|int
name|child_pid
parameter_list|)
function_decl|;
name|void
name|InitializeCoverage
parameter_list|(
name|bool
name|enabled
parameter_list|,
specifier|const
name|char
modifier|*
name|coverage_dir
parameter_list|)
function_decl|;
name|void
name|ReInitializeCoverage
parameter_list|(
name|bool
name|enabled
parameter_list|,
specifier|const
name|char
modifier|*
name|coverage_dir
parameter_list|)
function_decl|;
name|void
name|InitTlsSize
parameter_list|()
function_decl|;
name|uptr
name|GetTlsSize
parameter_list|()
function_decl|;
comment|// Other
name|void
name|SleepForSeconds
parameter_list|(
name|int
name|seconds
parameter_list|)
function_decl|;
name|void
name|SleepForMillis
parameter_list|(
name|int
name|millis
parameter_list|)
function_decl|;
name|u64
name|NanoTime
parameter_list|()
function_decl|;
name|int
name|Atexit
parameter_list|(
name|void
function_decl|(
modifier|*
name|function
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
function_decl|;
name|void
name|SortArray
parameter_list|(
name|uptr
modifier|*
name|array
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
name|bool
name|TemplateMatch
parameter_list|(
specifier|const
name|char
modifier|*
name|templ
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
comment|// Exit
name|void
name|NORETURN
name|Abort
parameter_list|()
function_decl|;
name|void
name|NORETURN
name|Die
parameter_list|()
function_decl|;
name|void
name|NORETURN
name|CheckFailed
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|cond
parameter_list|,
name|u64
name|v1
parameter_list|,
name|u64
name|v2
parameter_list|)
function_decl|;
comment|// Set the name of the current thread to 'name', return true on succees.
comment|// The name may be truncated to a system-dependent limit.
name|bool
name|SanitizerSetThreadName
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|// Get the name of the current thread (no more than max_len bytes),
comment|// return true on succees. name should have space for at least max_len+1 bytes.
name|bool
name|SanitizerGetThreadName
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|max_len
parameter_list|)
function_decl|;
comment|// Specific tools may override behavior of "Die" and "CheckFailed" functions
comment|// to do tool-specific job.
typedef|typedef
name|void
function_decl|(
modifier|*
name|DieCallbackType
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|SetDieCallback
parameter_list|(
name|DieCallbackType
parameter_list|)
function_decl|;
name|void
name|SetUserDieCallback
parameter_list|(
name|DieCallbackType
parameter_list|)
function_decl|;
name|DieCallbackType
name|GetDieCallback
parameter_list|()
function_decl|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|CheckFailedCallbackType
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u64
parameter_list|,
name|u64
parameter_list|)
function_decl|;
name|void
name|SetCheckFailedCallback
parameter_list|(
name|CheckFailedCallbackType
name|callback
parameter_list|)
function_decl|;
comment|// Callback will be called if soft_rss_limit_mb is given and the limit is
comment|// exceeded (exceeded==true) or if rss went down below the limit
comment|// (exceeded==false).
comment|// The callback should be registered once at the tool init time.
name|void
name|SetSoftRssLimitExceededCallback
parameter_list|(
name|void
function_decl|(
modifier|*
name|Callback
function_decl|)
parameter_list|(
name|bool
name|exceeded
parameter_list|)
parameter_list|)
function_decl|;
comment|// Functions related to signal handling.
typedef|typedef
name|void
function_decl|(
modifier|*
name|SignalHandlerType
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|bool
name|IsDeadlySignal
parameter_list|(
name|int
name|signum
parameter_list|)
function_decl|;
name|void
name|InstallDeadlySignalHandlers
parameter_list|(
name|SignalHandlerType
name|handler
parameter_list|)
function_decl|;
comment|// Alternative signal stack (POSIX-only).
name|void
name|SetAlternateSignalStack
parameter_list|()
function_decl|;
name|void
name|UnsetAlternateSignalStack
parameter_list|()
function_decl|;
comment|// We don't want a summary too long.
specifier|const
name|int
name|kMaxSummaryLength
init|=
literal|1024
decl_stmt|;
comment|// Construct a one-line string:
comment|//   SUMMARY: SanitizerToolName: error_message
comment|// and pass it to __sanitizer_report_error_summary.
name|void
name|ReportErrorSummary
parameter_list|(
specifier|const
name|char
modifier|*
name|error_message
parameter_list|)
function_decl|;
comment|// Same as above, but construct error_message as:
comment|//   error_type file:line function
name|void
name|ReportErrorSummary
parameter_list|(
specifier|const
name|char
modifier|*
name|error_type
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|function
parameter_list|)
function_decl|;
name|void
name|ReportErrorSummary
parameter_list|(
specifier|const
name|char
modifier|*
name|error_type
parameter_list|,
name|StackTrace
modifier|*
name|trace
parameter_list|)
function_decl|;
comment|// Math
if|#
directive|if
name|SANITIZER_WINDOWS
operator|&&
operator|!
name|defined
argument_list|(
name|__clang__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
extern|extern
literal|"C"
block|{
name|unsigned
name|char
name|_BitScanForward
parameter_list|(
name|unsigned
name|long
modifier|*
name|index
parameter_list|,
name|unsigned
name|long
name|mask
parameter_list|)
function_decl|;
comment|// NOLINT
name|unsigned
name|char
name|_BitScanReverse
parameter_list|(
name|unsigned
name|long
modifier|*
name|index
parameter_list|,
name|unsigned
name|long
name|mask
parameter_list|)
function_decl|;
comment|// NOLINT
if|#
directive|if
name|defined
argument_list|(
name|_WIN64
argument_list|)
name|unsigned
name|char
name|_BitScanForward64
parameter_list|(
name|unsigned
name|long
modifier|*
name|index
parameter_list|,
name|unsigned
name|__int64
name|mask
parameter_list|)
function_decl|;
comment|// NOLINT
name|unsigned
name|char
name|_BitScanReverse64
parameter_list|(
name|unsigned
name|long
modifier|*
name|index
parameter_list|,
name|unsigned
name|__int64
name|mask
parameter_list|)
function_decl|;
comment|// NOLINT
endif|#
directive|endif
block|}
endif|#
directive|endif
name|INLINE
name|uptr
name|MostSignificantSetBitIndex
parameter_list|(
name|uptr
name|x
parameter_list|)
block|{
name|CHECK_NE
argument_list|(
name|x
argument_list|,
literal|0U
argument_list|)
expr_stmt|;
name|unsigned
name|long
name|up
decl_stmt|;
comment|// NOLINT
if|#
directive|if
operator|!
name|SANITIZER_WINDOWS
operator|||
name|defined
argument_list|(
name|__clang__
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNUC__
argument_list|)
name|up
operator|=
name|SANITIZER_WORDSIZE
operator|-
literal|1
operator|-
name|__builtin_clzl
argument_list|(
name|x
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN64
argument_list|)
name|_BitScanReverse64
argument_list|(
operator|&
name|up
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|#
directive|else
name|_BitScanReverse
argument_list|(
operator|&
name|up
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|up
return|;
block|}
name|INLINE
name|uptr
name|LeastSignificantSetBitIndex
parameter_list|(
name|uptr
name|x
parameter_list|)
block|{
name|CHECK_NE
argument_list|(
name|x
argument_list|,
literal|0U
argument_list|)
expr_stmt|;
name|unsigned
name|long
name|up
decl_stmt|;
comment|// NOLINT
if|#
directive|if
operator|!
name|SANITIZER_WINDOWS
operator|||
name|defined
argument_list|(
name|__clang__
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNUC__
argument_list|)
name|up
operator|=
name|__builtin_ctzl
argument_list|(
name|x
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN64
argument_list|)
name|_BitScanForward64
argument_list|(
operator|&
name|up
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|#
directive|else
name|_BitScanForward
argument_list|(
operator|&
name|up
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|up
return|;
block|}
name|INLINE
name|bool
name|IsPowerOfTwo
parameter_list|(
name|uptr
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|&
operator|(
name|x
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
return|;
block|}
name|INLINE
name|uptr
name|RoundUpToPowerOfTwo
parameter_list|(
name|uptr
name|size
parameter_list|)
block|{
name|CHECK
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|IsPowerOfTwo
argument_list|(
name|size
argument_list|)
condition|)
return|return
name|size
return|;
name|uptr
name|up
init|=
name|MostSignificantSetBitIndex
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|CHECK
argument_list|(
name|size
operator|<
operator|(
literal|1ULL
operator|<<
operator|(
name|up
operator|+
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|size
operator|>
operator|(
literal|1ULL
operator|<<
name|up
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1UL
operator|<<
operator|(
name|up
operator|+
literal|1
operator|)
return|;
block|}
name|INLINE
name|uptr
name|RoundUpTo
parameter_list|(
name|uptr
name|size
parameter_list|,
name|uptr
name|boundary
parameter_list|)
block|{
name|CHECK
argument_list|(
name|IsPowerOfTwo
argument_list|(
name|boundary
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|+
name|boundary
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|boundary
operator|-
literal|1
operator|)
return|;
block|}
name|INLINE
name|uptr
name|RoundDownTo
parameter_list|(
name|uptr
name|x
parameter_list|,
name|uptr
name|boundary
parameter_list|)
block|{
return|return
name|x
operator|&
operator|~
operator|(
name|boundary
operator|-
literal|1
operator|)
return|;
block|}
name|INLINE
name|bool
name|IsAligned
parameter_list|(
name|uptr
name|a
parameter_list|,
name|uptr
name|alignment
parameter_list|)
block|{
return|return
operator|(
name|a
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
return|;
block|}
name|INLINE
name|uptr
name|Log2
parameter_list|(
name|uptr
name|x
parameter_list|)
block|{
name|CHECK
argument_list|(
name|IsPowerOfTwo
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|SANITIZER_WINDOWS
operator|||
name|defined
argument_list|(
name|__clang__
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNUC__
argument_list|)
return|return
name|__builtin_ctzl
argument_list|(
name|x
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN64
argument_list|)
name|unsigned
name|long
name|ret
decl_stmt|;
comment|// NOLINT
name|_BitScanForward64
argument_list|(
operator|&
name|ret
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
else|#
directive|else
name|unsigned
name|long
name|ret
decl_stmt|;
comment|// NOLINT
name|_BitScanForward
argument_list|(
operator|&
name|ret
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
endif|#
directive|endif
block|}
comment|// Don't use std::min, std::max or std::swap, to minimize dependency
comment|// on libstdc++.
name|template
operator|<
name|class
name|T
operator|>
name|T
name|Min
argument_list|(
argument|T a
argument_list|,
argument|T b
argument_list|)
block|{
return|return
name|a
operator|<
name|b
operator|?
name|a
operator|:
name|b
return|;
block|}
name|template
operator|<
name|class
name|T
operator|>
name|T
name|Max
argument_list|(
argument|T a
argument_list|,
argument|T b
argument_list|)
block|{
return|return
name|a
operator|>
name|b
operator|?
name|a
operator|:
name|b
return|;
block|}
name|template
operator|<
name|class
name|T
operator|>
name|void
name|Swap
argument_list|(
argument|T& a
argument_list|,
argument|T& b
argument_list|)
block|{
name|T
name|tmp
operator|=
name|a
block|;
name|a
operator|=
name|b
block|;
name|b
operator|=
name|tmp
block|; }
comment|// Char handling
name|INLINE
name|bool
name|IsSpace
argument_list|(
argument|int c
argument_list|)
block|{
return|return
operator|(
name|c
operator|==
literal|' '
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\t'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\f'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\r'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\v'
operator|)
return|;
block|}
name|INLINE
name|bool
name|IsDigit
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'9'
operator|)
return|;
block|}
name|INLINE
name|int
name|ToLower
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
condition|?
operator|(
name|c
operator|+
literal|'a'
operator|-
literal|'A'
operator|)
else|:
name|c
return|;
block|}
comment|// A low-level vector based on mmap. May incur a significant memory overhead for
comment|// small vectors.
comment|// WARNING: The current implementation supports only POD types.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|InternalMmapVectorNoCtor
block|{
name|public
operator|:
name|void
name|Initialize
argument_list|(
argument|uptr initial_capacity
argument_list|)
block|{
name|capacity_
operator|=
name|Max
argument_list|(
name|initial_capacity
argument_list|,
operator|(
name|uptr
operator|)
literal|1
argument_list|)
block|;
name|size_
operator|=
literal|0
block|;
name|data_
operator|=
operator|(
name|T
operator|*
operator|)
name|MmapOrDie
argument_list|(
name|capacity_
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|,
literal|"InternalMmapVectorNoCtor"
argument_list|)
block|;   }
name|void
name|Destroy
argument_list|()
block|{
name|UnmapOrDie
argument_list|(
name|data_
argument_list|,
name|capacity_
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
block|;   }
name|T
operator|&
name|operator
index|[]
operator|(
name|uptr
name|i
operator|)
block|{
name|CHECK_LT
argument_list|(
name|i
argument_list|,
name|size_
argument_list|)
block|;
return|return
name|data_
index|[
name|i
index|]
return|;
block|}
specifier|const
name|T
operator|&
name|operator
index|[]
operator|(
name|uptr
name|i
operator|)
specifier|const
block|{
name|CHECK_LT
argument_list|(
name|i
argument_list|,
name|size_
argument_list|)
block|;
return|return
name|data_
index|[
name|i
index|]
return|;
block|}
name|void
name|push_back
argument_list|(
argument|const T&element
argument_list|)
block|{
name|CHECK_LE
argument_list|(
name|size_
argument_list|,
name|capacity_
argument_list|)
block|;
if|if
condition|(
name|size_
operator|==
name|capacity_
condition|)
block|{
name|uptr
name|new_capacity
init|=
name|RoundUpToPowerOfTwo
argument_list|(
name|size_
operator|+
literal|1
argument_list|)
decl_stmt|;
name|Resize
argument_list|(
name|new_capacity
argument_list|)
expr_stmt|;
block|}
name|data_
index|[
name|size_
operator|++
index|]
operator|=
name|element
expr_stmt|;
block|}
name|T
operator|&
name|back
argument_list|()
block|{
name|CHECK_GT
argument_list|(
name|size_
argument_list|,
literal|0
argument_list|)
block|;
return|return
name|data_
index|[
name|size_
operator|-
literal|1
index|]
return|;
block|}
name|void
name|pop_back
argument_list|()
block|{
name|CHECK_GT
argument_list|(
name|size_
argument_list|,
literal|0
argument_list|)
block|;
name|size_
operator|--
block|;   }
name|uptr
name|size
argument_list|()
specifier|const
block|{
return|return
name|size_
return|;
block|}
specifier|const
name|T
operator|*
name|data
argument_list|()
specifier|const
block|{
return|return
name|data_
return|;
block|}
name|uptr
name|capacity
argument_list|()
specifier|const
block|{
return|return
name|capacity_
return|;
block|}
name|void
name|clear
argument_list|()
block|{
name|size_
operator|=
literal|0
block|; }
name|private
operator|:
name|void
name|Resize
argument_list|(
argument|uptr new_capacity
argument_list|)
block|{
name|CHECK_GT
argument_list|(
name|new_capacity
argument_list|,
literal|0
argument_list|)
block|;
name|CHECK_LE
argument_list|(
name|size_
argument_list|,
name|new_capacity
argument_list|)
block|;
name|T
operator|*
name|new_data
operator|=
operator|(
name|T
operator|*
operator|)
name|MmapOrDie
argument_list|(
name|new_capacity
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|,
literal|"InternalMmapVector"
argument_list|)
block|;
name|internal_memcpy
argument_list|(
name|new_data
argument_list|,
name|data_
argument_list|,
name|size_
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
block|;
name|T
operator|*
name|old_data
operator|=
name|data_
block|;
name|data_
operator|=
name|new_data
block|;
name|UnmapOrDie
argument_list|(
name|old_data
argument_list|,
name|capacity_
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
block|;
name|capacity_
operator|=
name|new_capacity
block|;   }
name|T
operator|*
name|data_
block|;
name|uptr
name|capacity_
block|;
name|uptr
name|size_
block|; }
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|InternalMmapVector
operator|:
name|public
name|InternalMmapVectorNoCtor
operator|<
name|T
operator|>
block|{
name|public
operator|:
name|explicit
name|InternalMmapVector
argument_list|(
argument|uptr initial_capacity
argument_list|)
block|{
name|InternalMmapVectorNoCtor
operator|<
name|T
operator|>
operator|::
name|Initialize
argument_list|(
name|initial_capacity
argument_list|)
block|;   }
operator|~
name|InternalMmapVector
argument_list|()
block|{
name|InternalMmapVectorNoCtor
operator|<
name|T
operator|>
operator|::
name|Destroy
argument_list|()
block|; }
comment|// Disallow evil constructors.
name|InternalMmapVector
argument_list|(
specifier|const
name|InternalMmapVector
operator|&
argument_list|)
block|;
name|void
name|operator
operator|=
operator|(
specifier|const
name|InternalMmapVector
operator|&
operator|)
block|; }
expr_stmt|;
comment|// HeapSort for arrays and InternalMmapVector.
name|template
operator|<
name|class
name|Container
operator|,
name|class
name|Compare
operator|>
name|void
name|InternalSort
argument_list|(
argument|Container *v
argument_list|,
argument|uptr size
argument_list|,
argument|Compare comp
argument_list|)
block|{
if|if
condition|(
name|size
operator|<
literal|2
condition|)
return|return;
comment|// Stage 1: insert elements to the heap.
for|for
control|(
name|uptr
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|uptr
name|j
decl_stmt|,
name|p
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|=
name|p
control|)
block|{
name|p
operator|=
operator|(
name|j
operator|-
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|comp
argument_list|(
operator|(
operator|*
name|v
operator|)
index|[
name|p
index|]
argument_list|,
operator|(
operator|*
name|v
operator|)
index|[
name|j
index|]
argument_list|)
condition|)
name|Swap
argument_list|(
operator|(
operator|*
name|v
operator|)
index|[
name|j
index|]
argument_list|,
operator|(
operator|*
name|v
operator|)
index|[
name|p
index|]
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
block|}
comment|// Stage 2: swap largest element with the last one,
comment|// and sink the new top.
for|for
control|(
name|uptr
name|i
init|=
name|size
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|Swap
argument_list|(
operator|(
operator|*
name|v
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|*
name|v
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|uptr
name|j
decl_stmt|,
name|max_ind
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|=
name|max_ind
control|)
block|{
name|uptr
name|left
init|=
literal|2
operator|*
name|j
operator|+
literal|1
decl_stmt|;
name|uptr
name|right
init|=
literal|2
operator|*
name|j
operator|+
literal|2
decl_stmt|;
name|max_ind
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|left
operator|<
name|i
operator|&&
name|comp
argument_list|(
operator|(
operator|*
name|v
operator|)
index|[
name|max_ind
index|]
argument_list|,
operator|(
operator|*
name|v
operator|)
index|[
name|left
index|]
argument_list|)
condition|)
name|max_ind
operator|=
name|left
expr_stmt|;
if|if
condition|(
name|right
operator|<
name|i
operator|&&
name|comp
argument_list|(
operator|(
operator|*
name|v
operator|)
index|[
name|max_ind
index|]
argument_list|,
operator|(
operator|*
name|v
operator|)
index|[
name|right
index|]
argument_list|)
condition|)
name|max_ind
operator|=
name|right
expr_stmt|;
if|if
condition|(
name|max_ind
operator|!=
name|j
condition|)
name|Swap
argument_list|(
operator|(
operator|*
name|v
operator|)
index|[
name|j
index|]
argument_list|,
operator|(
operator|*
name|v
operator|)
index|[
name|max_ind
index|]
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
block|}
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Container
operator|,
name|class
name|Value
operator|,
name|class
name|Compare
operator|>
name|uptr
name|InternalBinarySearch
argument_list|(
argument|const Container&v
argument_list|,
argument|uptr first
argument_list|,
argument|uptr last
argument_list|,
argument|const Value&val
argument_list|,
argument|Compare comp
argument_list|)
block|{
name|uptr
name|not_found
operator|=
name|last
operator|+
literal|1
block|;
while|while
condition|(
name|last
operator|>=
name|first
condition|)
block|{
name|uptr
name|mid
init|=
operator|(
name|first
operator|+
name|last
operator|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|comp
argument_list|(
name|v
index|[
name|mid
index|]
argument_list|,
name|val
argument_list|)
condition|)
name|first
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|comp
argument_list|(
name|val
argument_list|,
name|v
index|[
name|mid
index|]
argument_list|)
condition|)
name|last
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
else|else
return|return
name|mid
return|;
block|}
end_expr_stmt

begin_return
return|return
name|not_found
return|;
end_return

begin_comment
unit|}
comment|// Represents a binary loaded into virtual memory (e.g. this can be an
end_comment

begin_comment
comment|// executable or a shared object).
end_comment

begin_macro
unit|class
name|LoadedModule
end_macro

begin_block
block|{
name|public
label|:
name|LoadedModule
argument_list|(
argument|const char *module_name
argument_list|,
argument|uptr base_address
argument_list|)
empty_stmt|;
name|void
name|clear
parameter_list|()
function_decl|;
name|void
name|addAddressRange
parameter_list|(
name|uptr
name|beg
parameter_list|,
name|uptr
name|end
parameter_list|,
name|bool
name|executable
parameter_list|)
function_decl|;
name|bool
name|containsAddress
argument_list|(
name|uptr
name|address
argument_list|)
decl|const
decl_stmt|;
specifier|const
name|char
operator|*
name|full_name
argument_list|()
specifier|const
block|{
return|return
name|full_name_
return|;
block|}
name|uptr
name|base_address
argument_list|()
specifier|const
block|{
return|return
name|base_address_
return|;
block|}
struct|struct
name|AddressRange
block|{
name|AddressRange
modifier|*
name|next
decl_stmt|;
name|uptr
name|beg
decl_stmt|;
name|uptr
name|end
decl_stmt|;
name|bool
name|executable
decl_stmt|;
name|AddressRange
argument_list|(
argument|uptr beg
argument_list|,
argument|uptr end
argument_list|,
argument|bool executable
argument_list|)
block|:
name|next
argument_list|(
name|nullptr
argument_list|)
operator|,
name|beg
argument_list|(
name|beg
argument_list|)
operator|,
name|end
argument_list|(
name|end
argument_list|)
operator|,
name|executable
argument_list|(
argument|executable
argument_list|)
block|{}
block|}
struct|;
typedef|typedef
name|IntrusiveList
operator|<
name|AddressRange
operator|>
operator|::
name|ConstIterator
name|Iterator
expr_stmt|;
name|Iterator
name|ranges
argument_list|()
specifier|const
block|{
return|return
name|Iterator
argument_list|(
operator|&
name|ranges_
argument_list|)
return|;
block|}
name|private
label|:
name|char
modifier|*
name|full_name_
decl_stmt|;
comment|// Owned.
name|uptr
name|base_address_
decl_stmt|;
name|IntrusiveList
operator|<
name|AddressRange
operator|>
name|ranges_
expr_stmt|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// OS-dependent function that fills array with descriptions of at most
end_comment

begin_comment
comment|// "max_modules" currently loaded modules. Returns the number of
end_comment

begin_comment
comment|// initialized modules. If filter is nonzero, ignores modules for which
end_comment

begin_comment
comment|// filter(full_name) is false.
end_comment

begin_typedef
typedef|typedef
name|bool
function_decl|(
modifier|*
name|string_predicate_t
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
name|uptr
name|GetListOfModules
parameter_list|(
name|LoadedModule
modifier|*
name|modules
parameter_list|,
name|uptr
name|max_modules
parameter_list|,
name|string_predicate_t
name|filter
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|SANITIZER_POSIX
end_if

begin_decl_stmt
specifier|const
name|uptr
name|kPthreadDestructorIterations
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|// Unused on Windows.
end_comment

begin_decl_stmt
specifier|const
name|uptr
name|kPthreadDestructorIterations
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// Callback type for iterating over a set of memory ranges.
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|RangeIteratorCallback
function_decl|)
parameter_list|(
name|uptr
name|begin
parameter_list|,
name|uptr
name|end
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_typedef

begin_if
if|#
directive|if
name|SANITIZER_ANDROID
end_if

begin_comment
comment|// Initialize Android logging. Any writes before this are silently lost.
end_comment

begin_function_decl
name|void
name|AndroidLogInit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|AndroidLogWrite
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|GetExtraActivationFlags
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|SanitizerInitializeUnwinder
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function
name|INLINE
name|void
name|AndroidLogInit
parameter_list|()
block|{}
end_function

begin_function
name|INLINE
name|void
name|AndroidLogWrite
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer_unused
parameter_list|)
block|{}
end_function

begin_function
name|INLINE
name|void
name|GetExtraActivationFlags
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|uptr
name|size
parameter_list|)
block|{
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|INLINE
name|void
name|SanitizerInitializeUnwinder
parameter_list|()
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
modifier|*
name|internal_start_thread
parameter_list|(
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|internal_join_thread
parameter_list|(
name|void
modifier|*
name|th
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|MaybeStartBackgroudThread
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|// Make the compiler think that something is going on there.
end_comment

begin_comment
comment|// Use this inside a loop that looks like memset/memcpy/etc to prevent the
end_comment

begin_comment
comment|// compiler from recognising it and turning it into an actual call to
end_comment

begin_comment
comment|// memset/memcpy/etc.
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|SanitizerBreakOptimization
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|#
directive|if
name|_MSC_VER
comment|// FIXME: make sure this is actually enough.
asm|__asm;
else|#
directive|else
asm|__asm__
specifier|__volatile__
asm|("" : : "r" (arg) : "memory");
endif|#
directive|endif
block|}
end_function

begin_comment
unit|}
comment|// namespace __sanitizer
end_comment

begin_decl_stmt
unit|inline
name|void
modifier|*
name|operator
name|new
argument_list|(
name|__sanitizer
operator|::
name|operator_new_size_type
name|size
argument_list|,
name|__sanitizer
operator|::
name|LowLevelAllocator
operator|&
name|alloc
argument_list|)
block|{
return|return
name|alloc
operator|.
name|Allocate
argument_list|(
name|size
argument_list|)
return|;
block|}
end_decl_stmt

begin_struct
struct|struct
name|StackDepotStats
block|{
name|uptr
name|n_uniq_ids
decl_stmt|;
name|uptr
name|allocated
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// SANITIZER_COMMON_H
end_comment

end_unit

