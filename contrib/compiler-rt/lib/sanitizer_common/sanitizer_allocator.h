begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- sanitizer_allocator.h -----------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Specialized memory allocator for ThreadSanitizer, MemorySanitizer, etc.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SANITIZER_ALLOCATOR_H
end_ifndef

begin_define
define|#
directive|define
name|SANITIZER_ALLOCATOR_H
end_define

begin_include
include|#
directive|include
file|"sanitizer_internal_defs.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_common.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_libc.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_list.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_mutex.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_lfstack.h"
end_include

begin_decl_stmt
name|namespace
name|__sanitizer
block|{
comment|// Prints error message and kills the program.
name|void
name|NORETURN
name|ReportAllocatorCannotReturnNull
parameter_list|()
function_decl|;
comment|// SizeClassMap maps allocation sizes into size classes and back.
comment|// Class 0 corresponds to size 0.
comment|// Classes 1 - 16 correspond to sizes 16 to 256 (size = class_id * 16).
comment|// Next 4 classes: 256 + i * 64  (i = 1 to 4).
comment|// Next 4 classes: 512 + i * 128 (i = 1 to 4).
comment|// ...
comment|// Next 4 classes: 2^k + i * 2^(k-2) (i = 1 to 4).
comment|// Last class corresponds to kMaxSize = 1<< kMaxSizeLog.
comment|//
comment|// This structure of the size class map gives us:
comment|//   - Efficient table-free class-to-size and size-to-class functions.
comment|//   - Difference between two consequent size classes is betweed 14% and 25%
comment|//
comment|// This class also gives a hint to a thread-caching allocator about the amount
comment|// of chunks that need to be cached per-thread:
comment|//  - kMaxNumCached is the maximal number of chunks per size class.
comment|//  - (1<< kMaxBytesCachedLog) is the maximal number of bytes per size class.
comment|//
comment|// Part of output of SizeClassMap::Print():
comment|// c00 => s: 0 diff: +0 00% l 0 cached: 0 0; id 0
comment|// c01 => s: 16 diff: +16 00% l 4 cached: 256 4096; id 1
comment|// c02 => s: 32 diff: +16 100% l 5 cached: 256 8192; id 2
comment|// c03 => s: 48 diff: +16 50% l 5 cached: 256 12288; id 3
comment|// c04 => s: 64 diff: +16 33% l 6 cached: 256 16384; id 4
comment|// c05 => s: 80 diff: +16 25% l 6 cached: 256 20480; id 5
comment|// c06 => s: 96 diff: +16 20% l 6 cached: 256 24576; id 6
comment|// c07 => s: 112 diff: +16 16% l 6 cached: 256 28672; id 7
comment|//
comment|// c08 => s: 128 diff: +16 14% l 7 cached: 256 32768; id 8
comment|// c09 => s: 144 diff: +16 12% l 7 cached: 256 36864; id 9
comment|// c10 => s: 160 diff: +16 11% l 7 cached: 256 40960; id 10
comment|// c11 => s: 176 diff: +16 10% l 7 cached: 256 45056; id 11
comment|// c12 => s: 192 diff: +16 09% l 7 cached: 256 49152; id 12
comment|// c13 => s: 208 diff: +16 08% l 7 cached: 256 53248; id 13
comment|// c14 => s: 224 diff: +16 07% l 7 cached: 256 57344; id 14
comment|// c15 => s: 240 diff: +16 07% l 7 cached: 256 61440; id 15
comment|//
comment|// c16 => s: 256 diff: +16 06% l 8 cached: 256 65536; id 16
comment|// c17 => s: 320 diff: +64 25% l 8 cached: 204 65280; id 17
comment|// c18 => s: 384 diff: +64 20% l 8 cached: 170 65280; id 18
comment|// c19 => s: 448 diff: +64 16% l 8 cached: 146 65408; id 19
comment|//
comment|// c20 => s: 512 diff: +64 14% l 9 cached: 128 65536; id 20
comment|// c21 => s: 640 diff: +128 25% l 9 cached: 102 65280; id 21
comment|// c22 => s: 768 diff: +128 20% l 9 cached: 85 65280; id 22
comment|// c23 => s: 896 diff: +128 16% l 9 cached: 73 65408; id 23
comment|//
comment|// c24 => s: 1024 diff: +128 14% l 10 cached: 64 65536; id 24
comment|// c25 => s: 1280 diff: +256 25% l 10 cached: 51 65280; id 25
comment|// c26 => s: 1536 diff: +256 20% l 10 cached: 42 64512; id 26
comment|// c27 => s: 1792 diff: +256 16% l 10 cached: 36 64512; id 27
comment|//
comment|// ...
comment|//
comment|// c48 => s: 65536 diff: +8192 14% l 16 cached: 1 65536; id 48
comment|// c49 => s: 81920 diff: +16384 25% l 16 cached: 1 81920; id 49
comment|// c50 => s: 98304 diff: +16384 20% l 16 cached: 1 98304; id 50
comment|// c51 => s: 114688 diff: +16384 16% l 16 cached: 1 114688; id 51
comment|//
comment|// c52 => s: 131072 diff: +16384 14% l 17 cached: 1 131072; id 52
name|template
operator|<
name|uptr
name|kMaxSizeLog
operator|,
name|uptr
name|kMaxNumCachedT
operator|,
name|uptr
name|kMaxBytesCachedLog
operator|>
name|class
name|SizeClassMap
block|{
specifier|static
specifier|const
name|uptr
name|kMinSizeLog
operator|=
literal|4
block|;
specifier|static
specifier|const
name|uptr
name|kMidSizeLog
operator|=
name|kMinSizeLog
operator|+
literal|4
block|;
specifier|static
specifier|const
name|uptr
name|kMinSize
operator|=
literal|1
operator|<<
name|kMinSizeLog
block|;
specifier|static
specifier|const
name|uptr
name|kMidSize
operator|=
literal|1
operator|<<
name|kMidSizeLog
block|;
specifier|static
specifier|const
name|uptr
name|kMidClass
operator|=
name|kMidSize
operator|/
name|kMinSize
block|;
specifier|static
specifier|const
name|uptr
name|S
operator|=
literal|2
block|;
specifier|static
specifier|const
name|uptr
name|M
operator|=
operator|(
literal|1
operator|<<
name|S
operator|)
operator|-
literal|1
block|;
name|public
operator|:
specifier|static
specifier|const
name|uptr
name|kMaxNumCached
operator|=
name|kMaxNumCachedT
block|;
comment|// We transfer chunks between central and thread-local free lists in batches.
comment|// For small size classes we allocate batches separately.
comment|// For large size classes we use one of the chunks to store the batch.
block|struct
name|TransferBatch
block|{
name|TransferBatch
operator|*
name|next
block|;
name|uptr
name|count
block|;
name|void
operator|*
name|batch
index|[
name|kMaxNumCached
index|]
block|;   }
block|;
specifier|static
specifier|const
name|uptr
name|kMaxSize
operator|=
literal|1UL
operator|<<
name|kMaxSizeLog
block|;
specifier|static
specifier|const
name|uptr
name|kNumClasses
operator|=
name|kMidClass
operator|+
operator|(
operator|(
name|kMaxSizeLog
operator|-
name|kMidSizeLog
operator|)
operator|<<
name|S
operator|)
operator|+
literal|1
block|;
name|COMPILER_CHECK
argument_list|(
name|kNumClasses
operator|>=
literal|32
operator|&&
name|kNumClasses
operator|<=
literal|256
argument_list|)
block|;
specifier|static
specifier|const
name|uptr
name|kNumClassesRounded
operator|=
name|kNumClasses
operator|==
literal|32
condition|?
literal|32
else|:
name|kNumClasses
operator|<=
literal|64
condition|?
literal|64
else|:
name|kNumClasses
operator|<=
literal|128
condition|?
literal|128
else|:
literal|256
block|;
specifier|static
name|uptr
name|Size
argument_list|(
argument|uptr class_id
argument_list|)
block|{
if|if
condition|(
name|class_id
operator|<=
name|kMidClass
condition|)
return|return
name|kMinSize
operator|*
name|class_id
return|;
name|class_id
operator|-=
name|kMidClass
block|;
name|uptr
name|t
operator|=
name|kMidSize
operator|<<
operator|(
name|class_id
operator|>>
name|S
operator|)
block|;
return|return
name|t
operator|+
operator|(
name|t
operator|>>
name|S
operator|)
operator|*
operator|(
name|class_id
operator|&
name|M
operator|)
return|;
block|}
specifier|static
name|uptr
name|ClassID
parameter_list|(
name|uptr
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<=
name|kMidSize
condition|)
return|return
operator|(
name|size
operator|+
name|kMinSize
operator|-
literal|1
operator|)
operator|>>
name|kMinSizeLog
return|;
if|if
condition|(
name|size
operator|>
name|kMaxSize
condition|)
return|return
literal|0
return|;
name|uptr
name|l
init|=
name|MostSignificantSetBitIndex
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|uptr
name|hbits
init|=
operator|(
name|size
operator|>>
operator|(
name|l
operator|-
name|S
operator|)
operator|)
operator|&
name|M
decl_stmt|;
name|uptr
name|lbits
init|=
name|size
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|l
operator|-
name|S
operator|)
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|uptr
name|l1
init|=
name|l
operator|-
name|kMidSizeLog
decl_stmt|;
return|return
name|kMidClass
operator|+
operator|(
name|l1
operator|<<
name|S
operator|)
operator|+
name|hbits
operator|+
operator|(
name|lbits
operator|>
literal|0
operator|)
return|;
block|}
specifier|static
name|uptr
name|MaxCached
parameter_list|(
name|uptr
name|class_id
parameter_list|)
block|{
if|if
condition|(
name|class_id
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|uptr
name|n
init|=
operator|(
literal|1UL
operator|<<
name|kMaxBytesCachedLog
operator|)
operator|/
name|Size
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
return|return
name|Max
operator|<
name|uptr
operator|>
operator|(
literal|1
operator|,
name|Min
argument_list|(
name|kMaxNumCached
argument_list|,
name|n
argument_list|)
operator|)
return|;
block|}
specifier|static
name|void
name|Print
parameter_list|()
block|{
name|uptr
name|prev_s
init|=
literal|0
decl_stmt|;
name|uptr
name|total_cached
init|=
literal|0
decl_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kNumClasses
condition|;
name|i
operator|++
control|)
block|{
name|uptr
name|s
init|=
name|Size
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|>=
name|kMidSize
operator|/
literal|2
operator|&&
operator|(
name|s
operator|&
operator|(
name|s
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|Printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|uptr
name|d
init|=
name|s
operator|-
name|prev_s
decl_stmt|;
name|uptr
name|p
init|=
name|prev_s
condition|?
operator|(
name|d
operator|*
literal|100
operator|/
name|prev_s
operator|)
else|:
literal|0
decl_stmt|;
name|uptr
name|l
init|=
name|s
condition|?
name|MostSignificantSetBitIndex
argument_list|(
name|s
argument_list|)
else|:
literal|0
decl_stmt|;
name|uptr
name|cached
init|=
name|MaxCached
argument_list|(
name|i
argument_list|)
operator|*
name|s
decl_stmt|;
name|Printf
argument_list|(
literal|"c%02zd => s: %zd diff: +%zd %02zd%% l %zd "
literal|"cached: %zd %zd; id %zd\n"
argument_list|,
name|i
argument_list|,
name|Size
argument_list|(
name|i
argument_list|)
argument_list|,
name|d
argument_list|,
name|p
argument_list|,
name|l
argument_list|,
name|MaxCached
argument_list|(
name|i
argument_list|)
argument_list|,
name|cached
argument_list|,
name|ClassID
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|total_cached
operator|+=
name|cached
expr_stmt|;
name|prev_s
operator|=
name|s
expr_stmt|;
block|}
name|Printf
argument_list|(
literal|"Total cached: %zd\n"
argument_list|,
name|total_cached
argument_list|)
expr_stmt|;
block|}
specifier|static
name|bool
name|SizeClassRequiresSeparateTransferBatch
parameter_list|(
name|uptr
name|class_id
parameter_list|)
block|{
return|return
name|Size
argument_list|(
name|class_id
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|TransferBatch
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|uptr
argument_list|)
operator|*
operator|(
name|kMaxNumCached
operator|-
name|MaxCached
argument_list|(
name|class_id
argument_list|)
operator|)
return|;
block|}
specifier|static
name|void
name|Validate
parameter_list|()
block|{
for|for
control|(
name|uptr
name|c
init|=
literal|1
init|;
name|c
operator|<
name|kNumClasses
condition|;
name|c
operator|++
control|)
block|{
comment|// Printf("Validate: c%zd\n", c);
name|uptr
name|s
init|=
name|Size
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|CHECK_NE
argument_list|(
name|s
argument_list|,
literal|0U
argument_list|)
expr_stmt|;
name|CHECK_EQ
argument_list|(
name|ClassID
argument_list|(
name|s
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|kNumClasses
operator|-
literal|1
condition|)
name|CHECK_EQ
argument_list|(
name|ClassID
argument_list|(
name|s
operator|+
literal|1
argument_list|)
argument_list|,
name|c
operator|+
literal|1
argument_list|)
expr_stmt|;
name|CHECK_EQ
argument_list|(
name|ClassID
argument_list|(
name|s
operator|-
literal|1
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|CHECK_GT
argument_list|(
name|Size
argument_list|(
name|c
argument_list|)
argument_list|,
name|Size
argument_list|(
name|c
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CHECK_EQ
argument_list|(
name|ClassID
argument_list|(
name|kMaxSize
operator|+
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|uptr
name|s
init|=
literal|1
init|;
name|s
operator|<=
name|kMaxSize
condition|;
name|s
operator|++
control|)
block|{
name|uptr
name|c
init|=
name|ClassID
argument_list|(
name|s
argument_list|)
decl_stmt|;
comment|// Printf("s%zd => c%zd\n", s, c);
name|CHECK_LT
argument_list|(
name|c
argument_list|,
name|kNumClasses
argument_list|)
expr_stmt|;
name|CHECK_GE
argument_list|(
name|Size
argument_list|(
name|c
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
condition|)
name|CHECK_LT
argument_list|(
name|Size
argument_list|(
name|c
operator|-
literal|1
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_typedef
typedef|typedef
name|SizeClassMap
operator|<
literal|17
operator|,
literal|128
operator|,
literal|16
operator|>
name|DefaultSizeClassMap
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|SizeClassMap
operator|<
literal|17
operator|,
literal|64
operator|,
literal|14
operator|>
name|CompactSizeClassMap
expr_stmt|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|class
name|SizeClassAllocator
operator|>
expr|struct
name|SizeClassAllocatorLocalCache
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Memory allocator statistics
end_comment

begin_enum
enum|enum
name|AllocatorStat
block|{
name|AllocatorStatAllocated
block|,
name|AllocatorStatMapped
block|,
name|AllocatorStatCount
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
name|uptr
name|AllocatorStatCounters
index|[
name|AllocatorStatCount
index|]
typedef|;
end_typedef

begin_comment
comment|// Per-thread stats, live in per-thread cache.
end_comment

begin_decl_stmt
name|class
name|AllocatorStats
block|{
name|public
label|:
name|void
name|Init
parameter_list|()
block|{
name|internal_memset
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|InitLinkerInitialized
parameter_list|()
block|{}
name|void
name|Add
parameter_list|(
name|AllocatorStat
name|i
parameter_list|,
name|uptr
name|v
parameter_list|)
block|{
name|v
operator|+=
name|atomic_load
argument_list|(
operator|&
name|stats_
index|[
name|i
index|]
argument_list|,
name|memory_order_relaxed
argument_list|)
expr_stmt|;
name|atomic_store
argument_list|(
operator|&
name|stats_
index|[
name|i
index|]
argument_list|,
name|v
argument_list|,
name|memory_order_relaxed
argument_list|)
expr_stmt|;
block|}
name|void
name|Sub
parameter_list|(
name|AllocatorStat
name|i
parameter_list|,
name|uptr
name|v
parameter_list|)
block|{
name|v
operator|=
name|atomic_load
argument_list|(
operator|&
name|stats_
index|[
name|i
index|]
argument_list|,
name|memory_order_relaxed
argument_list|)
operator|-
name|v
expr_stmt|;
name|atomic_store
argument_list|(
operator|&
name|stats_
index|[
name|i
index|]
argument_list|,
name|v
argument_list|,
name|memory_order_relaxed
argument_list|)
expr_stmt|;
block|}
name|void
name|Set
parameter_list|(
name|AllocatorStat
name|i
parameter_list|,
name|uptr
name|v
parameter_list|)
block|{
name|atomic_store
argument_list|(
operator|&
name|stats_
index|[
name|i
index|]
argument_list|,
name|v
argument_list|,
name|memory_order_relaxed
argument_list|)
expr_stmt|;
block|}
name|uptr
name|Get
argument_list|(
name|AllocatorStat
name|i
argument_list|)
decl|const
block|{
return|return
name|atomic_load
argument_list|(
operator|&
name|stats_
index|[
name|i
index|]
argument_list|,
name|memory_order_relaxed
argument_list|)
return|;
block|}
name|private
label|:
name|friend
name|class
name|AllocatorGlobalStats
decl_stmt|;
name|AllocatorStats
modifier|*
name|next_
decl_stmt|;
name|AllocatorStats
modifier|*
name|prev_
decl_stmt|;
name|atomic_uintptr_t
name|stats_
index|[
name|AllocatorStatCount
index|]
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Global stats, used for aggregation and querying.
end_comment

begin_decl_stmt
name|class
name|AllocatorGlobalStats
range|:
name|public
name|AllocatorStats
block|{
name|public
operator|:
name|void
name|InitLinkerInitialized
argument_list|()
block|{
name|next_
operator|=
name|this
block|;
name|prev_
operator|=
name|this
block|;   }
name|void
name|Init
argument_list|()
block|{
name|internal_memset
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
argument_list|)
block|;
name|InitLinkerInitialized
argument_list|()
block|;   }
name|void
name|Register
argument_list|(
argument|AllocatorStats *s
argument_list|)
block|{
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|mu_
argument_list|)
block|;
name|s
operator|->
name|next_
operator|=
name|next_
block|;
name|s
operator|->
name|prev_
operator|=
name|this
block|;
name|next_
operator|->
name|prev_
operator|=
name|s
block|;
name|next_
operator|=
name|s
block|;   }
name|void
name|Unregister
argument_list|(
argument|AllocatorStats *s
argument_list|)
block|{
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|mu_
argument_list|)
block|;
name|s
operator|->
name|prev_
operator|->
name|next_
operator|=
name|s
operator|->
name|next_
block|;
name|s
operator|->
name|next_
operator|->
name|prev_
operator|=
name|s
operator|->
name|prev_
block|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|AllocatorStatCount
condition|;
name|i
operator|++
control|)
name|Add
argument_list|(
name|AllocatorStat
argument_list|(
name|i
argument_list|)
argument_list|,
name|s
operator|->
name|Get
argument_list|(
name|AllocatorStat
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|Get
argument_list|(
argument|AllocatorStatCounters s
argument_list|)
specifier|const
block|{
name|internal_memset
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|AllocatorStatCount
operator|*
sizeof|sizeof
argument_list|(
name|uptr
argument_list|)
argument_list|)
block|;
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|mu_
argument_list|)
block|;
specifier|const
name|AllocatorStats
operator|*
name|stats
operator|=
name|this
block|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|AllocatorStatCount
condition|;
name|i
operator|++
control|)
name|s
index|[
name|i
index|]
operator|+=
name|stats
operator|->
name|Get
argument_list|(
name|AllocatorStat
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|stats
operator|=
name|stats
operator|->
name|next_
expr_stmt|;
if|if
condition|(
name|stats
operator|==
name|this
condition|)
break|break;
block|}
comment|// All stats must be non-negative.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|AllocatorStatCount
condition|;
name|i
operator|++
control|)
name|s
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|sptr
operator|)
name|s
index|[
name|i
index|]
operator|)
operator|>=
literal|0
condition|?
name|s
index|[
name|i
index|]
else|:
literal|0
expr_stmt|;
block|}
name|private
operator|:
name|mutable
name|SpinMutex
name|mu_
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Allocators call these callbacks on mmap/munmap.
end_comment

begin_struct
struct|struct
name|NoOpMapUnmapCallback
block|{
name|void
name|OnMap
argument_list|(
name|uptr
name|p
argument_list|,
name|uptr
name|size
argument_list|)
decl|const
block|{ }
name|void
name|OnUnmap
argument_list|(
name|uptr
name|p
argument_list|,
name|uptr
name|size
argument_list|)
decl|const
block|{ }
block|}
struct|;
end_struct

begin_comment
comment|// Callback type for iterating over chunks.
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|ForEachChunkCallback
function_decl|)
parameter_list|(
name|uptr
name|chunk
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|// SizeClassAllocator64 -- allocator for 64-bit address space.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Space: a portion of address space of kSpaceSize bytes starting at
end_comment

begin_comment
comment|// a fixed address (kSpaceBeg). Both constants are powers of two and
end_comment

begin_comment
comment|// kSpaceBeg is kSpaceSize-aligned.
end_comment

begin_comment
comment|// At the beginning the entire space is mprotect-ed, then small parts of it
end_comment

begin_comment
comment|// are mapped on demand.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Region: a part of Space dedicated to a single size class.
end_comment

begin_comment
comment|// There are kNumClasses Regions of equal size.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// UserChunk: a piece of memory returned to user.
end_comment

begin_comment
comment|// MetaChunk: kMetadataSize bytes of metadata associated with a UserChunk.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// A Region looks like this:
end_comment

begin_comment
comment|// UserChunk1 ... UserChunkN<gap> MetaChunkN ... MetaChunk1
end_comment

begin_expr_stmt
name|template
operator|<
specifier|const
name|uptr
name|kSpaceBeg
operator|,
specifier|const
name|uptr
name|kSpaceSize
operator|,
specifier|const
name|uptr
name|kMetadataSize
operator|,
name|class
name|SizeClassMap
operator|,
name|class
name|MapUnmapCallback
operator|=
name|NoOpMapUnmapCallback
operator|>
name|class
name|SizeClassAllocator64
block|{
name|public
operator|:
typedef|typedef
name|typename
name|SizeClassMap
operator|::
name|TransferBatch
name|Batch
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|SizeClassAllocator64
operator|<
name|kSpaceBeg
operator|,
name|kSpaceSize
operator|,
name|kMetadataSize
operator|,
name|SizeClassMap
operator|,
name|MapUnmapCallback
operator|>
name|ThisT
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|SizeClassAllocatorLocalCache
operator|<
name|ThisT
operator|>
name|AllocatorCache
expr_stmt|;
end_typedef

begin_function
name|void
name|Init
parameter_list|()
block|{
name|CHECK_EQ
argument_list|(
name|kSpaceBeg
argument_list|,
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|MmapNoAccess
argument_list|(
name|kSpaceBeg
argument_list|,
name|kSpaceSize
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|MapWithCallback
argument_list|(
name|kSpaceEnd
argument_list|,
name|AdditionalSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|MapWithCallback
parameter_list|(
name|uptr
name|beg
parameter_list|,
name|uptr
name|size
parameter_list|)
block|{
name|CHECK_EQ
argument_list|(
name|beg
argument_list|,
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|MmapFixedOrDie
argument_list|(
name|beg
argument_list|,
name|size
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|MapUnmapCallback
argument_list|()
operator|.
name|OnMap
argument_list|(
name|beg
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|UnmapWithCallback
parameter_list|(
name|uptr
name|beg
parameter_list|,
name|uptr
name|size
parameter_list|)
block|{
name|MapUnmapCallback
argument_list|()
operator|.
name|OnUnmap
argument_list|(
name|beg
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|UnmapOrDie
argument_list|(
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|beg
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|CanAllocate
parameter_list|(
name|uptr
name|size
parameter_list|,
name|uptr
name|alignment
parameter_list|)
block|{
return|return
name|size
operator|<=
name|SizeClassMap
operator|::
name|kMaxSize
operator|&&
name|alignment
operator|<=
name|SizeClassMap
operator|::
name|kMaxSize
return|;
block|}
end_function

begin_function
name|NOINLINE
name|Batch
modifier|*
name|AllocateBatch
parameter_list|(
name|AllocatorStats
modifier|*
name|stat
parameter_list|,
name|AllocatorCache
modifier|*
name|c
parameter_list|,
name|uptr
name|class_id
parameter_list|)
block|{
name|CHECK_LT
argument_list|(
name|class_id
argument_list|,
name|kNumClasses
argument_list|)
expr_stmt|;
name|RegionInfo
modifier|*
name|region
init|=
name|GetRegionInfo
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|Batch
modifier|*
name|b
init|=
name|region
operator|->
name|free_list
operator|.
name|Pop
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
name|b
operator|=
name|PopulateFreeList
argument_list|(
name|stat
argument_list|,
name|c
argument_list|,
name|class_id
argument_list|,
name|region
argument_list|)
expr_stmt|;
name|region
operator|->
name|n_allocated
operator|+=
name|b
operator|->
name|count
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
name|NOINLINE
name|void
name|DeallocateBatch
parameter_list|(
name|AllocatorStats
modifier|*
name|stat
parameter_list|,
name|uptr
name|class_id
parameter_list|,
name|Batch
modifier|*
name|b
parameter_list|)
block|{
name|RegionInfo
modifier|*
name|region
init|=
name|GetRegionInfo
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|CHECK_GT
argument_list|(
name|b
operator|->
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|region
operator|->
name|free_list
operator|.
name|Push
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|region
operator|->
name|n_freed
operator|+=
name|b
operator|->
name|count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|PointerIsMine
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
operator|/
name|kSpaceSize
operator|==
name|kSpaceBeg
operator|/
name|kSpaceSize
return|;
block|}
end_function

begin_function
specifier|static
name|uptr
name|GetSizeClass
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
operator|/
name|kRegionSize
operator|)
operator|%
name|kNumClassesRounded
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|GetBlockBegin
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|uptr
name|class_id
init|=
name|GetSizeClass
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|uptr
name|size
init|=
name|SizeClassMap
operator|::
name|Size
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
return|return
name|nullptr
return|;
name|uptr
name|chunk_idx
init|=
name|GetChunkIdx
argument_list|(
operator|(
name|uptr
operator|)
name|p
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|uptr
name|reg_beg
init|=
operator|(
name|uptr
operator|)
name|p
operator|&
operator|~
operator|(
name|kRegionSize
operator|-
literal|1
operator|)
decl_stmt|;
name|uptr
name|beg
init|=
name|chunk_idx
operator|*
name|size
decl_stmt|;
name|uptr
name|next_beg
init|=
name|beg
operator|+
name|size
decl_stmt|;
if|if
condition|(
name|class_id
operator|>=
name|kNumClasses
condition|)
return|return
name|nullptr
return|;
name|RegionInfo
modifier|*
name|region
init|=
name|GetRegionInfo
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|->
name|mapped_user
operator|>=
name|next_beg
condition|)
return|return
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|reg_beg
operator|+
name|beg
operator|)
return|;
return|return
name|nullptr
return|;
block|}
end_function

begin_function
specifier|static
name|uptr
name|GetActuallyAllocatedSize
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|CHECK
argument_list|(
name|PointerIsMine
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SizeClassMap
operator|::
name|Size
argument_list|(
name|GetSizeClass
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|uptr
name|ClassID
parameter_list|(
name|uptr
name|size
parameter_list|)
block|{
return|return
name|SizeClassMap
operator|::
name|ClassID
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|GetMetaData
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|uptr
name|class_id
init|=
name|GetSizeClass
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|uptr
name|size
init|=
name|SizeClassMap
operator|::
name|Size
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|uptr
name|chunk_idx
init|=
name|GetChunkIdx
argument_list|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
argument_list|,
name|size
argument_list|)
decl_stmt|;
return|return
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|kSpaceBeg
operator|+
operator|(
name|kRegionSize
operator|*
operator|(
name|class_id
operator|+
literal|1
operator|)
operator|)
operator|-
operator|(
literal|1
operator|+
name|chunk_idx
operator|)
operator|*
name|kMetadataSize
operator|)
return|;
block|}
end_function

begin_function
name|uptr
name|TotalMemoryUsed
parameter_list|()
block|{
name|uptr
name|res
init|=
literal|0
decl_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kNumClasses
condition|;
name|i
operator|++
control|)
name|res
operator|+=
name|GetRegionInfo
argument_list|(
name|i
argument_list|)
operator|->
name|allocated_user
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|// Test-only.
end_comment

begin_function
name|void
name|TestOnlyUnmap
parameter_list|()
block|{
name|UnmapWithCallback
argument_list|(
name|kSpaceBeg
argument_list|,
name|kSpaceSize
operator|+
name|AdditionalSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|PrintStats
parameter_list|()
block|{
name|uptr
name|total_mapped
init|=
literal|0
decl_stmt|;
name|uptr
name|n_allocated
init|=
literal|0
decl_stmt|;
name|uptr
name|n_freed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|uptr
name|class_id
init|=
literal|1
init|;
name|class_id
operator|<
name|kNumClasses
condition|;
name|class_id
operator|++
control|)
block|{
name|RegionInfo
modifier|*
name|region
init|=
name|GetRegionInfo
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|total_mapped
operator|+=
name|region
operator|->
name|mapped_user
expr_stmt|;
name|n_allocated
operator|+=
name|region
operator|->
name|n_allocated
expr_stmt|;
name|n_freed
operator|+=
name|region
operator|->
name|n_freed
expr_stmt|;
block|}
name|Printf
argument_list|(
literal|"Stats: SizeClassAllocator64: %zdM mapped in %zd allocations; "
literal|"remains %zd\n"
argument_list|,
name|total_mapped
operator|>>
literal|20
argument_list|,
name|n_allocated
argument_list|,
name|n_allocated
operator|-
name|n_freed
argument_list|)
expr_stmt|;
for|for
control|(
name|uptr
name|class_id
init|=
literal|1
init|;
name|class_id
operator|<
name|kNumClasses
condition|;
name|class_id
operator|++
control|)
block|{
name|RegionInfo
modifier|*
name|region
init|=
name|GetRegionInfo
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|->
name|mapped_user
operator|==
literal|0
condition|)
continue|continue;
name|Printf
argument_list|(
literal|"  %02zd (%zd): total: %zd K allocs: %zd remains: %zd\n"
argument_list|,
name|class_id
argument_list|,
name|SizeClassMap
operator|::
name|Size
argument_list|(
name|class_id
argument_list|)
argument_list|,
name|region
operator|->
name|mapped_user
operator|>>
literal|10
argument_list|,
name|region
operator|->
name|n_allocated
argument_list|,
name|region
operator|->
name|n_allocated
operator|-
name|region
operator|->
name|n_freed
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone
end_comment

begin_comment
comment|// introspection API.
end_comment

begin_function
name|void
name|ForceLock
parameter_list|()
block|{
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kNumClasses
condition|;
name|i
operator|++
control|)
block|{
name|GetRegionInfo
argument_list|(
name|i
argument_list|)
operator|->
name|mutex
operator|.
name|Lock
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ForceUnlock
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
operator|(
name|int
operator|)
name|kNumClasses
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|GetRegionInfo
argument_list|(
name|i
argument_list|)
operator|->
name|mutex
operator|.
name|Unlock
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// Iterate over all existing chunks.
end_comment

begin_comment
comment|// The allocator must be locked when calling this function.
end_comment

begin_function
name|void
name|ForEachChunk
parameter_list|(
name|ForEachChunkCallback
name|callback
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
for|for
control|(
name|uptr
name|class_id
init|=
literal|1
init|;
name|class_id
operator|<
name|kNumClasses
condition|;
name|class_id
operator|++
control|)
block|{
name|RegionInfo
modifier|*
name|region
init|=
name|GetRegionInfo
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|uptr
name|chunk_size
init|=
name|SizeClassMap
operator|::
name|Size
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|uptr
name|region_beg
init|=
name|kSpaceBeg
operator|+
name|class_id
operator|*
name|kRegionSize
decl_stmt|;
for|for
control|(
name|uptr
name|chunk
init|=
name|region_beg
init|;
name|chunk
operator|<
name|region_beg
operator|+
name|region
operator|->
name|allocated_user
condition|;
name|chunk
operator|+=
name|chunk_size
control|)
block|{
comment|// Too slow: CHECK_EQ((void *)chunk, GetBlockBegin((void *)chunk));
name|callback
argument_list|(
name|chunk
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|uptr
name|AdditionalSize
parameter_list|()
block|{
return|return
name|RoundUpTo
argument_list|(
sizeof|sizeof
argument_list|(
name|RegionInfo
argument_list|)
operator|*
name|kNumClassesRounded
argument_list|,
name|GetPageSizeCached
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|SizeClassMap
name|SizeClassMapT
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|uptr
name|kNumClasses
init|=
name|SizeClassMap
operator|::
name|kNumClasses
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uptr
name|kNumClassesRounded
init|=
name|SizeClassMap
operator|::
name|kNumClassesRounded
decl_stmt|;
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
specifier|static
specifier|const
name|uptr
name|kRegionSize
init|=
name|kSpaceSize
operator|/
name|kNumClassesRounded
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uptr
name|kSpaceEnd
init|=
name|kSpaceBeg
operator|+
name|kSpaceSize
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|COMPILER_CHECK
argument_list|(
name|kSpaceBeg
operator|%
name|kSpaceSize
operator|==
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// kRegionSize must be>= 2^32.
end_comment

begin_expr_stmt
name|COMPILER_CHECK
argument_list|(
operator|(
name|kRegionSize
operator|)
operator|>=
operator|(
literal|1ULL
operator|<<
operator|(
name|SANITIZER_WORDSIZE
operator|/
literal|2
operator|)
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Populate the free list with at most this number of bytes at once
end_comment

begin_comment
comment|// or with one element if its size is greater.
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uptr
name|kPopulateSize
init|=
literal|1
operator|<<
literal|14
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Call mmap for user memory with at least this size.
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uptr
name|kUserMapSize
init|=
literal|1
operator|<<
literal|16
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Call mmap for metadata memory with at least this size.
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uptr
name|kMetaMapSize
init|=
literal|1
operator|<<
literal|16
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|RegionInfo
block|{
name|BlockingMutex
name|mutex
decl_stmt|;
name|LFStack
operator|<
name|Batch
operator|>
name|free_list
expr_stmt|;
name|uptr
name|allocated_user
decl_stmt|;
comment|// Bytes allocated for user memory.
name|uptr
name|allocated_meta
decl_stmt|;
comment|// Bytes allocated for metadata.
name|uptr
name|mapped_user
decl_stmt|;
comment|// Bytes mapped for user memory.
name|uptr
name|mapped_meta
decl_stmt|;
comment|// Bytes mapped for metadata.
name|uptr
name|n_allocated
decl_stmt|,
name|n_freed
decl_stmt|;
comment|// Just stats.
block|}
struct|;
end_struct

begin_expr_stmt
name|COMPILER_CHECK
argument_list|(
sizeof|sizeof
argument_list|(
name|RegionInfo
argument_list|)
operator|>=
name|kCacheLineSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|RegionInfo
modifier|*
name|GetRegionInfo
parameter_list|(
name|uptr
name|class_id
parameter_list|)
block|{
name|CHECK_LT
argument_list|(
name|class_id
argument_list|,
name|kNumClasses
argument_list|)
expr_stmt|;
name|RegionInfo
modifier|*
name|regions
init|=
name|reinterpret_cast
operator|<
name|RegionInfo
operator|*
operator|>
operator|(
name|kSpaceBeg
operator|+
name|kSpaceSize
operator|)
decl_stmt|;
return|return
operator|&
name|regions
index|[
name|class_id
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|uptr
name|GetChunkIdx
parameter_list|(
name|uptr
name|chunk
parameter_list|,
name|uptr
name|size
parameter_list|)
block|{
name|uptr
name|offset
init|=
name|chunk
operator|%
name|kRegionSize
decl_stmt|;
comment|// Here we divide by a non-constant. This is costly.
comment|// size always fits into 32-bits. If the offset fits too, use 32-bit div.
if|if
condition|(
name|offset
operator|>>
operator|(
name|SANITIZER_WORDSIZE
operator|/
literal|2
operator|)
condition|)
return|return
name|offset
operator|/
name|size
return|;
return|return
operator|(
name|u32
operator|)
name|offset
operator|/
operator|(
name|u32
operator|)
name|size
return|;
block|}
end_function

begin_function
name|NOINLINE
name|Batch
modifier|*
name|PopulateFreeList
parameter_list|(
name|AllocatorStats
modifier|*
name|stat
parameter_list|,
name|AllocatorCache
modifier|*
name|c
parameter_list|,
name|uptr
name|class_id
parameter_list|,
name|RegionInfo
modifier|*
name|region
parameter_list|)
block|{
name|BlockingMutexLock
name|l
argument_list|(
operator|&
name|region
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|Batch
modifier|*
name|b
init|=
name|region
operator|->
name|free_list
operator|.
name|Pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
condition|)
return|return
name|b
return|;
name|uptr
name|size
init|=
name|SizeClassMap
operator|::
name|Size
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|uptr
name|count
init|=
name|size
operator|<
name|kPopulateSize
condition|?
name|SizeClassMap
operator|::
name|MaxCached
argument_list|(
name|class_id
argument_list|)
else|:
literal|1
decl_stmt|;
name|uptr
name|beg_idx
init|=
name|region
operator|->
name|allocated_user
decl_stmt|;
name|uptr
name|end_idx
init|=
name|beg_idx
operator|+
name|count
operator|*
name|size
decl_stmt|;
name|uptr
name|region_beg
init|=
name|kSpaceBeg
operator|+
name|kRegionSize
operator|*
name|class_id
decl_stmt|;
if|if
condition|(
name|end_idx
operator|+
name|size
operator|>
name|region
operator|->
name|mapped_user
condition|)
block|{
comment|// Do the mmap for the user memory.
name|uptr
name|map_size
init|=
name|kUserMapSize
decl_stmt|;
while|while
condition|(
name|end_idx
operator|+
name|size
operator|>
name|region
operator|->
name|mapped_user
operator|+
name|map_size
condition|)
name|map_size
operator|+=
name|kUserMapSize
expr_stmt|;
name|CHECK_GE
argument_list|(
name|region
operator|->
name|mapped_user
operator|+
name|map_size
argument_list|,
name|end_idx
argument_list|)
expr_stmt|;
name|MapWithCallback
argument_list|(
name|region_beg
operator|+
name|region
operator|->
name|mapped_user
argument_list|,
name|map_size
argument_list|)
expr_stmt|;
name|stat
operator|->
name|Add
argument_list|(
name|AllocatorStatMapped
argument_list|,
name|map_size
argument_list|)
expr_stmt|;
name|region
operator|->
name|mapped_user
operator|+=
name|map_size
expr_stmt|;
block|}
name|uptr
name|total_count
init|=
operator|(
name|region
operator|->
name|mapped_user
operator|-
name|beg_idx
operator|-
name|size
operator|)
operator|/
name|size
operator|/
name|count
operator|*
name|count
decl_stmt|;
name|region
operator|->
name|allocated_meta
operator|+=
name|total_count
operator|*
name|kMetadataSize
expr_stmt|;
if|if
condition|(
name|region
operator|->
name|allocated_meta
operator|>
name|region
operator|->
name|mapped_meta
condition|)
block|{
name|uptr
name|map_size
init|=
name|kMetaMapSize
decl_stmt|;
while|while
condition|(
name|region
operator|->
name|allocated_meta
operator|>
name|region
operator|->
name|mapped_meta
operator|+
name|map_size
condition|)
name|map_size
operator|+=
name|kMetaMapSize
expr_stmt|;
comment|// Do the mmap for the metadata.
name|CHECK_GE
argument_list|(
name|region
operator|->
name|mapped_meta
operator|+
name|map_size
argument_list|,
name|region
operator|->
name|allocated_meta
argument_list|)
expr_stmt|;
name|MapWithCallback
argument_list|(
name|region_beg
operator|+
name|kRegionSize
operator|-
name|region
operator|->
name|mapped_meta
operator|-
name|map_size
argument_list|,
name|map_size
argument_list|)
expr_stmt|;
name|region
operator|->
name|mapped_meta
operator|+=
name|map_size
expr_stmt|;
block|}
name|CHECK_LE
argument_list|(
name|region
operator|->
name|allocated_meta
argument_list|,
name|region
operator|->
name|mapped_meta
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|->
name|mapped_user
operator|+
name|region
operator|->
name|mapped_meta
operator|>
name|kRegionSize
condition|)
block|{
name|Printf
argument_list|(
literal|"%s: Out of memory. Dying. "
argument_list|,
name|SanitizerToolName
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|"The process has exhausted %zuMB for size class %zu.\n"
argument_list|,
name|kRegionSize
operator|/
literal|1024
operator|/
literal|1024
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|Die
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|SizeClassMap
operator|::
name|SizeClassRequiresSeparateTransferBatch
argument_list|(
name|class_id
argument_list|)
condition|)
name|b
operator|=
operator|(
name|Batch
operator|*
operator|)
name|c
operator|->
name|Allocate
argument_list|(
name|this
argument_list|,
name|SizeClassMap
operator|::
name|ClassID
argument_list|(
sizeof|sizeof
argument_list|(
name|Batch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|b
operator|=
operator|(
name|Batch
operator|*
operator|)
operator|(
name|region_beg
operator|+
name|beg_idx
operator|)
expr_stmt|;
name|b
operator|->
name|count
operator|=
name|count
expr_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|b
operator|->
name|batch
index|[
name|i
index|]
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|region_beg
operator|+
name|beg_idx
operator|+
name|i
operator|*
name|size
operator|)
expr_stmt|;
name|region
operator|->
name|allocated_user
operator|+=
name|count
operator|*
name|size
expr_stmt|;
name|CHECK_LE
argument_list|(
name|region
operator|->
name|allocated_user
argument_list|,
name|region
operator|->
name|mapped_user
argument_list|)
expr_stmt|;
name|beg_idx
operator|+=
name|count
operator|*
name|size
expr_stmt|;
if|if
condition|(
name|beg_idx
operator|+
name|count
operator|*
name|size
operator|+
name|size
operator|>
name|region
operator|->
name|mapped_user
condition|)
break|break;
name|CHECK_GT
argument_list|(
name|b
operator|->
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|region
operator|->
name|free_list
operator|.
name|Push
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function

begin_comment
unit|};
comment|// Maps integers in rage [0, kSize) to u8 values.
end_comment

begin_expr_stmt
name|template
operator|<
name|u64
name|kSize
operator|>
name|class
name|FlatByteMap
block|{
name|public
operator|:
name|void
name|TestOnlyInit
argument_list|()
block|{
name|internal_memset
argument_list|(
name|map_
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|map_
argument_list|)
argument_list|)
block|;   }
name|void
name|set
argument_list|(
argument|uptr idx
argument_list|,
argument|u8 val
argument_list|)
block|{
name|CHECK_LT
argument_list|(
name|idx
argument_list|,
name|kSize
argument_list|)
block|;
name|CHECK_EQ
argument_list|(
literal|0U
argument_list|,
name|map_
index|[
name|idx
index|]
argument_list|)
block|;
name|map_
index|[
name|idx
index|]
operator|=
name|val
block|;   }
name|u8
name|operator
index|[]
operator|(
name|uptr
name|idx
operator|)
block|{
name|CHECK_LT
argument_list|(
name|idx
argument_list|,
name|kSize
argument_list|)
block|;
comment|// FIXME: CHECK may be too expensive here.
return|return
name|map_
index|[
name|idx
index|]
return|;
block|}
name|private
operator|:
name|u8
name|map_
index|[
name|kSize
index|]
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|// TwoLevelByteMap maps integers in range [0, kSize1*kSize2) to u8 values.
end_comment

begin_comment
comment|// It is implemented as a two-dimensional array: array of kSize1 pointers
end_comment

begin_comment
comment|// to kSize2-byte arrays. The secondary arrays are mmaped on demand.
end_comment

begin_comment
comment|// Each value is initially zero and can be set to something else only once.
end_comment

begin_comment
comment|// Setting and getting values from multiple threads is safe w/o extra locking.
end_comment

begin_expr_stmt
name|template
operator|<
name|u64
name|kSize1
operator|,
name|u64
name|kSize2
operator|,
name|class
name|MapUnmapCallback
operator|=
name|NoOpMapUnmapCallback
operator|>
name|class
name|TwoLevelByteMap
block|{
name|public
operator|:
name|void
name|TestOnlyInit
argument_list|()
block|{
name|internal_memset
argument_list|(
name|map1_
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|map1_
argument_list|)
argument_list|)
block|;
name|mu_
operator|.
name|Init
argument_list|()
block|;   }
name|void
name|TestOnlyUnmap
argument_list|()
block|{
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kSize1
condition|;
name|i
operator|++
control|)
block|{
name|u8
modifier|*
name|p
init|=
name|Get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
continue|continue;
name|MapUnmapCallback
argument_list|()
operator|.
name|OnUnmap
argument_list|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
argument_list|,
name|kSize2
argument_list|)
expr_stmt|;
name|UnmapOrDie
argument_list|(
name|p
argument_list|,
name|kSize2
argument_list|)
expr_stmt|;
block|}
block|}
name|uptr
name|size
argument_list|()
specifier|const
block|{
return|return
name|kSize1
operator|*
name|kSize2
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|uptr
name|size1
argument_list|()
specifier|const
block|{
return|return
name|kSize1
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|uptr
name|size2
argument_list|()
specifier|const
block|{
return|return
name|kSize2
return|;
block|}
end_expr_stmt

begin_function
name|void
name|set
parameter_list|(
name|uptr
name|idx
parameter_list|,
name|u8
name|val
parameter_list|)
block|{
name|CHECK_LT
argument_list|(
name|idx
argument_list|,
name|kSize1
operator|*
name|kSize2
argument_list|)
expr_stmt|;
name|u8
modifier|*
name|map2
init|=
name|GetOrCreate
argument_list|(
name|idx
operator|/
name|kSize2
argument_list|)
decl_stmt|;
name|CHECK_EQ
argument_list|(
literal|0U
argument_list|,
name|map2
index|[
name|idx
operator|%
name|kSize2
index|]
argument_list|)
expr_stmt|;
name|map2
index|[
name|idx
operator|%
name|kSize2
index|]
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|u8
name|operator
index|[]
argument_list|(
name|uptr
name|idx
argument_list|)
decl|const
block|{
name|CHECK_LT
argument_list|(
name|idx
argument_list|,
name|kSize1
operator|*
name|kSize2
argument_list|)
expr_stmt|;
name|u8
modifier|*
name|map2
init|=
name|Get
argument_list|(
name|idx
operator|/
name|kSize2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|map2
condition|)
return|return
literal|0
return|;
return|return
name|map2
index|[
name|idx
operator|%
name|kSize2
index|]
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|u8
modifier|*
name|Get
argument_list|(
name|uptr
name|idx
argument_list|)
decl|const
block|{
name|CHECK_LT
argument_list|(
name|idx
argument_list|,
name|kSize1
argument_list|)
expr_stmt|;
return|return
name|reinterpret_cast
operator|<
name|u8
operator|*
operator|>
operator|(
name|atomic_load
argument_list|(
operator|&
name|map1_
index|[
name|idx
index|]
argument_list|,
name|memory_order_acquire
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|u8
modifier|*
name|GetOrCreate
parameter_list|(
name|uptr
name|idx
parameter_list|)
block|{
name|u8
modifier|*
name|res
init|=
name|Get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
block|{
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|mu_
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|res
operator|=
name|Get
argument_list|(
name|idx
argument_list|)
operator|)
condition|)
block|{
name|res
operator|=
operator|(
name|u8
operator|*
operator|)
name|MmapOrDie
argument_list|(
name|kSize2
argument_list|,
literal|"TwoLevelByteMap"
argument_list|)
expr_stmt|;
name|MapUnmapCallback
argument_list|()
operator|.
name|OnMap
argument_list|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|res
operator|)
argument_list|,
name|kSize2
argument_list|)
expr_stmt|;
name|atomic_store
argument_list|(
operator|&
name|map1_
index|[
name|idx
index|]
argument_list|,
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|res
operator|)
argument_list|,
name|memory_order_release
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_decl_stmt
name|atomic_uintptr_t
name|map1_
index|[
name|kSize1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|StaticSpinMutex
name|mu_
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// SizeClassAllocator32 -- allocator for 32-bit address space.
end_comment

begin_comment
comment|// This allocator can theoretically be used on 64-bit arch, but there it is less
end_comment

begin_comment
comment|// efficient than SizeClassAllocator64.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// [kSpaceBeg, kSpaceBeg + kSpaceSize) is the range of addresses which can
end_comment

begin_comment
comment|// be returned by MmapOrDie().
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Region:
end_comment

begin_comment
comment|//   a result of a single call to MmapAlignedOrDie(kRegionSize, kRegionSize).
end_comment

begin_comment
comment|// Since the regions are aligned by kRegionSize, there are exactly
end_comment

begin_comment
comment|// kNumPossibleRegions possible regions in the address space and so we keep
end_comment

begin_comment
comment|// a ByteMap possible_regions to store the size classes of each Region.
end_comment

begin_comment
comment|// 0 size class means the region is not used by the allocator.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// One Region is used to allocate chunks of a single size class.
end_comment

begin_comment
comment|// A Region looks like this:
end_comment

begin_comment
comment|// UserChunk1 .. UserChunkN<gap> MetaChunkN .. MetaChunk1
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// In order to avoid false sharing the objects of this class should be
end_comment

begin_comment
comment|// chache-line aligned.
end_comment

begin_expr_stmt
name|template
operator|<
specifier|const
name|uptr
name|kSpaceBeg
operator|,
specifier|const
name|u64
name|kSpaceSize
operator|,
specifier|const
name|uptr
name|kMetadataSize
operator|,
name|class
name|SizeClassMap
operator|,
specifier|const
name|uptr
name|kRegionSizeLog
operator|,
name|class
name|ByteMap
operator|,
name|class
name|MapUnmapCallback
operator|=
name|NoOpMapUnmapCallback
operator|>
name|class
name|SizeClassAllocator32
block|{
name|public
operator|:
typedef|typedef
name|typename
name|SizeClassMap
operator|::
name|TransferBatch
name|Batch
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|SizeClassAllocator32
operator|<
name|kSpaceBeg
operator|,
name|kSpaceSize
operator|,
name|kMetadataSize
operator|,
name|SizeClassMap
operator|,
name|kRegionSizeLog
operator|,
name|ByteMap
operator|,
name|MapUnmapCallback
operator|>
name|ThisT
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|SizeClassAllocatorLocalCache
operator|<
name|ThisT
operator|>
name|AllocatorCache
expr_stmt|;
end_typedef

begin_function
name|void
name|Init
parameter_list|()
block|{
name|possible_regions
operator|.
name|TestOnlyInit
argument_list|()
expr_stmt|;
name|internal_memset
argument_list|(
name|size_class_info_array
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|size_class_info_array
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|MapWithCallback
parameter_list|(
name|uptr
name|size
parameter_list|)
block|{
name|size
operator|=
name|RoundUpTo
argument_list|(
name|size
argument_list|,
name|GetPageSizeCached
argument_list|()
argument_list|)
expr_stmt|;
name|void
modifier|*
name|res
init|=
name|MmapOrDie
argument_list|(
name|size
argument_list|,
literal|"SizeClassAllocator32"
argument_list|)
decl_stmt|;
name|MapUnmapCallback
argument_list|()
operator|.
name|OnMap
argument_list|(
operator|(
name|uptr
operator|)
name|res
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|void
name|UnmapWithCallback
parameter_list|(
name|uptr
name|beg
parameter_list|,
name|uptr
name|size
parameter_list|)
block|{
name|MapUnmapCallback
argument_list|()
operator|.
name|OnUnmap
argument_list|(
name|beg
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|UnmapOrDie
argument_list|(
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|beg
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|CanAllocate
parameter_list|(
name|uptr
name|size
parameter_list|,
name|uptr
name|alignment
parameter_list|)
block|{
return|return
name|size
operator|<=
name|SizeClassMap
operator|::
name|kMaxSize
operator|&&
name|alignment
operator|<=
name|SizeClassMap
operator|::
name|kMaxSize
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|GetMetaData
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|CHECK
argument_list|(
name|PointerIsMine
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|uptr
name|mem
init|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
decl_stmt|;
name|uptr
name|beg
init|=
name|ComputeRegionBeg
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|uptr
name|size
init|=
name|SizeClassMap
operator|::
name|Size
argument_list|(
name|GetSizeClass
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|u32
name|offset
init|=
name|mem
operator|-
name|beg
decl_stmt|;
name|uptr
name|n
init|=
name|offset
operator|/
operator|(
name|u32
operator|)
name|size
decl_stmt|;
comment|// 32-bit division
name|uptr
name|meta
init|=
operator|(
name|beg
operator|+
name|kRegionSize
operator|)
operator|-
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
name|kMetadataSize
decl_stmt|;
return|return
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|meta
operator|)
return|;
block|}
end_function

begin_function
name|NOINLINE
name|Batch
modifier|*
name|AllocateBatch
parameter_list|(
name|AllocatorStats
modifier|*
name|stat
parameter_list|,
name|AllocatorCache
modifier|*
name|c
parameter_list|,
name|uptr
name|class_id
parameter_list|)
block|{
name|CHECK_LT
argument_list|(
name|class_id
argument_list|,
name|kNumClasses
argument_list|)
expr_stmt|;
name|SizeClassInfo
modifier|*
name|sci
init|=
name|GetSizeClassInfo
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|sci
operator|->
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|sci
operator|->
name|free_list
operator|.
name|empty
argument_list|()
condition|)
name|PopulateFreeList
argument_list|(
name|stat
argument_list|,
name|c
argument_list|,
name|sci
argument_list|,
name|class_id
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
operator|!
name|sci
operator|->
name|free_list
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
name|Batch
modifier|*
name|b
init|=
name|sci
operator|->
name|free_list
operator|.
name|front
argument_list|()
decl_stmt|;
name|sci
operator|->
name|free_list
operator|.
name|pop_front
argument_list|()
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
name|NOINLINE
name|void
name|DeallocateBatch
parameter_list|(
name|AllocatorStats
modifier|*
name|stat
parameter_list|,
name|uptr
name|class_id
parameter_list|,
name|Batch
modifier|*
name|b
parameter_list|)
block|{
name|CHECK_LT
argument_list|(
name|class_id
argument_list|,
name|kNumClasses
argument_list|)
expr_stmt|;
name|SizeClassInfo
modifier|*
name|sci
init|=
name|GetSizeClassInfo
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|sci
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|CHECK_GT
argument_list|(
name|b
operator|->
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sci
operator|->
name|free_list
operator|.
name|push_front
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|PointerIsMine
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
name|GetSizeClass
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
name|uptr
name|GetSizeClass
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
name|possible_regions
index|[
name|ComputeRegionId
argument_list|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
argument_list|)
index|]
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|GetBlockBegin
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|CHECK
argument_list|(
name|PointerIsMine
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|uptr
name|mem
init|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
decl_stmt|;
name|uptr
name|beg
init|=
name|ComputeRegionBeg
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|uptr
name|size
init|=
name|SizeClassMap
operator|::
name|Size
argument_list|(
name|GetSizeClass
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|u32
name|offset
init|=
name|mem
operator|-
name|beg
decl_stmt|;
name|u32
name|n
init|=
name|offset
operator|/
operator|(
name|u32
operator|)
name|size
decl_stmt|;
comment|// 32-bit division
name|uptr
name|res
init|=
name|beg
operator|+
operator|(
name|n
operator|*
operator|(
name|u32
operator|)
name|size
operator|)
decl_stmt|;
return|return
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|uptr
name|GetActuallyAllocatedSize
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|CHECK
argument_list|(
name|PointerIsMine
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SizeClassMap
operator|::
name|Size
argument_list|(
name|GetSizeClass
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|uptr
name|ClassID
parameter_list|(
name|uptr
name|size
parameter_list|)
block|{
return|return
name|SizeClassMap
operator|::
name|ClassID
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|uptr
name|TotalMemoryUsed
parameter_list|()
block|{
comment|// No need to lock here.
name|uptr
name|res
init|=
literal|0
decl_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kNumPossibleRegions
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|possible_regions
index|[
name|i
index|]
condition|)
name|res
operator|+=
name|kRegionSize
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|void
name|TestOnlyUnmap
parameter_list|()
block|{
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kNumPossibleRegions
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|possible_regions
index|[
name|i
index|]
condition|)
name|UnmapWithCallback
argument_list|(
operator|(
name|i
operator|*
name|kRegionSize
operator|)
argument_list|,
name|kRegionSize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone
end_comment

begin_comment
comment|// introspection API.
end_comment

begin_function
name|void
name|ForceLock
parameter_list|()
block|{
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kNumClasses
condition|;
name|i
operator|++
control|)
block|{
name|GetSizeClassInfo
argument_list|(
name|i
argument_list|)
operator|->
name|mutex
operator|.
name|Lock
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ForceUnlock
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
name|kNumClasses
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|GetSizeClassInfo
argument_list|(
name|i
argument_list|)
operator|->
name|mutex
operator|.
name|Unlock
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// Iterate over all existing chunks.
end_comment

begin_comment
comment|// The allocator must be locked when calling this function.
end_comment

begin_function
name|void
name|ForEachChunk
parameter_list|(
name|ForEachChunkCallback
name|callback
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
for|for
control|(
name|uptr
name|region
init|=
literal|0
init|;
name|region
operator|<
name|kNumPossibleRegions
condition|;
name|region
operator|++
control|)
if|if
condition|(
name|possible_regions
index|[
name|region
index|]
condition|)
block|{
name|uptr
name|chunk_size
init|=
name|SizeClassMap
operator|::
name|Size
argument_list|(
name|possible_regions
index|[
name|region
index|]
argument_list|)
decl_stmt|;
name|uptr
name|max_chunks_in_region
init|=
name|kRegionSize
operator|/
operator|(
name|chunk_size
operator|+
name|kMetadataSize
operator|)
decl_stmt|;
name|uptr
name|region_beg
init|=
name|region
operator|*
name|kRegionSize
decl_stmt|;
for|for
control|(
name|uptr
name|chunk
init|=
name|region_beg
init|;
name|chunk
operator|<
name|region_beg
operator|+
name|max_chunks_in_region
operator|*
name|chunk_size
condition|;
name|chunk
operator|+=
name|chunk_size
control|)
block|{
comment|// Too slow: CHECK_EQ((void *)chunk, GetBlockBegin((void *)chunk));
name|callback
argument_list|(
name|chunk
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|PrintStats
parameter_list|()
block|{   }
end_function

begin_function
specifier|static
name|uptr
name|AdditionalSize
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|SizeClassMap
name|SizeClassMapT
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|uptr
name|kNumClasses
init|=
name|SizeClassMap
operator|::
name|kNumClasses
decl_stmt|;
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
specifier|static
specifier|const
name|uptr
name|kRegionSize
init|=
literal|1
operator|<<
name|kRegionSizeLog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uptr
name|kNumPossibleRegions
init|=
name|kSpaceSize
operator|/
name|kRegionSize
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|SizeClassInfo
block|{
name|SpinMutex
name|mutex
decl_stmt|;
name|IntrusiveList
operator|<
name|Batch
operator|>
name|free_list
expr_stmt|;
name|char
name|padding
index|[
name|kCacheLineSize
operator|-
sizeof|sizeof
argument_list|(
name|uptr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|IntrusiveList
operator|<
name|Batch
operator|>
argument_list|)
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|COMPILER_CHECK
argument_list|(
sizeof|sizeof
argument_list|(
name|SizeClassInfo
argument_list|)
operator|==
name|kCacheLineSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|uptr
name|ComputeRegionId
parameter_list|(
name|uptr
name|mem
parameter_list|)
block|{
name|uptr
name|res
init|=
name|mem
operator|>>
name|kRegionSizeLog
decl_stmt|;
name|CHECK_LT
argument_list|(
name|res
argument_list|,
name|kNumPossibleRegions
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|uptr
name|ComputeRegionBeg
parameter_list|(
name|uptr
name|mem
parameter_list|)
block|{
return|return
name|mem
operator|&
operator|~
operator|(
name|kRegionSize
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|uptr
name|AllocateRegion
parameter_list|(
name|AllocatorStats
modifier|*
name|stat
parameter_list|,
name|uptr
name|class_id
parameter_list|)
block|{
name|CHECK_LT
argument_list|(
name|class_id
argument_list|,
name|kNumClasses
argument_list|)
expr_stmt|;
name|uptr
name|res
init|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|MmapAlignedOrDie
argument_list|(
name|kRegionSize
argument_list|,
name|kRegionSize
argument_list|,
literal|"SizeClassAllocator32"
argument_list|)
operator|)
decl_stmt|;
name|MapUnmapCallback
argument_list|()
operator|.
name|OnMap
argument_list|(
name|res
argument_list|,
name|kRegionSize
argument_list|)
expr_stmt|;
name|stat
operator|->
name|Add
argument_list|(
name|AllocatorStatMapped
argument_list|,
name|kRegionSize
argument_list|)
expr_stmt|;
name|CHECK_EQ
argument_list|(
literal|0U
argument_list|,
operator|(
name|res
operator|&
operator|(
name|kRegionSize
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|possible_regions
operator|.
name|set
argument_list|(
name|ComputeRegionId
argument_list|(
name|res
argument_list|)
argument_list|,
name|static_cast
operator|<
name|u8
operator|>
operator|(
name|class_id
operator|)
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|SizeClassInfo
modifier|*
name|GetSizeClassInfo
parameter_list|(
name|uptr
name|class_id
parameter_list|)
block|{
name|CHECK_LT
argument_list|(
name|class_id
argument_list|,
name|kNumClasses
argument_list|)
expr_stmt|;
return|return
operator|&
name|size_class_info_array
index|[
name|class_id
index|]
return|;
block|}
end_function

begin_function
name|void
name|PopulateFreeList
parameter_list|(
name|AllocatorStats
modifier|*
name|stat
parameter_list|,
name|AllocatorCache
modifier|*
name|c
parameter_list|,
name|SizeClassInfo
modifier|*
name|sci
parameter_list|,
name|uptr
name|class_id
parameter_list|)
block|{
name|uptr
name|size
init|=
name|SizeClassMap
operator|::
name|Size
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|uptr
name|reg
init|=
name|AllocateRegion
argument_list|(
name|stat
argument_list|,
name|class_id
argument_list|)
decl_stmt|;
name|uptr
name|n_chunks
init|=
name|kRegionSize
operator|/
operator|(
name|size
operator|+
name|kMetadataSize
operator|)
decl_stmt|;
name|uptr
name|max_count
init|=
name|SizeClassMap
operator|::
name|MaxCached
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|Batch
modifier|*
name|b
init|=
name|nullptr
decl_stmt|;
for|for
control|(
name|uptr
name|i
init|=
name|reg
init|;
name|i
operator|<
name|reg
operator|+
name|n_chunks
operator|*
name|size
condition|;
name|i
operator|+=
name|size
control|)
block|{
if|if
condition|(
operator|!
name|b
condition|)
block|{
if|if
condition|(
name|SizeClassMap
operator|::
name|SizeClassRequiresSeparateTransferBatch
argument_list|(
name|class_id
argument_list|)
condition|)
name|b
operator|=
operator|(
name|Batch
operator|*
operator|)
name|c
operator|->
name|Allocate
argument_list|(
name|this
argument_list|,
name|SizeClassMap
operator|::
name|ClassID
argument_list|(
sizeof|sizeof
argument_list|(
name|Batch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|b
operator|=
operator|(
name|Batch
operator|*
operator|)
name|i
expr_stmt|;
name|b
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|b
operator|->
name|batch
index|[
name|b
operator|->
name|count
operator|++
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|i
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|count
operator|==
name|max_count
condition|)
block|{
name|CHECK_GT
argument_list|(
name|b
operator|->
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sci
operator|->
name|free_list
operator|.
name|push_back
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|=
name|nullptr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|b
condition|)
block|{
name|CHECK_GT
argument_list|(
name|b
operator|->
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sci
operator|->
name|free_list
operator|.
name|push_back
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|ByteMap
name|possible_regions
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SizeClassInfo
name|size_class_info_array
index|[
name|kNumClasses
index|]
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Objects of this type should be used as local caches for SizeClassAllocator64
end_comment

begin_comment
comment|// or SizeClassAllocator32. Since the typical use of this class is to have one
end_comment

begin_comment
comment|// object per thread in TLS, is has to be POD.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|SizeClassAllocator
operator|>
expr|struct
name|SizeClassAllocatorLocalCache
block|{
typedef|typedef
name|SizeClassAllocator
name|Allocator
typedef|;
specifier|static
specifier|const
name|uptr
name|kNumClasses
operator|=
name|SizeClassAllocator
operator|::
name|kNumClasses
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|Init
parameter_list|(
name|AllocatorGlobalStats
modifier|*
name|s
parameter_list|)
block|{
name|stats_
operator|.
name|Init
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|s
operator|->
name|Register
argument_list|(
operator|&
name|stats_
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Destroy
parameter_list|(
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|,
name|AllocatorGlobalStats
modifier|*
name|s
parameter_list|)
block|{
name|Drain
argument_list|(
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|s
operator|->
name|Unregister
argument_list|(
operator|&
name|stats_
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|Allocate
parameter_list|(
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|,
name|uptr
name|class_id
parameter_list|)
block|{
name|CHECK_NE
argument_list|(
name|class_id
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
name|CHECK_LT
argument_list|(
name|class_id
argument_list|,
name|kNumClasses
argument_list|)
expr_stmt|;
name|stats_
operator|.
name|Add
argument_list|(
name|AllocatorStatAllocated
argument_list|,
name|SizeClassMap
operator|::
name|Size
argument_list|(
name|class_id
argument_list|)
argument_list|)
expr_stmt|;
name|PerClass
modifier|*
name|c
init|=
operator|&
name|per_class_
index|[
name|class_id
index|]
decl_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
name|c
operator|->
name|count
operator|==
literal|0
argument_list|)
condition|)
name|Refill
argument_list|(
name|allocator
argument_list|,
name|class_id
argument_list|)
expr_stmt|;
name|void
modifier|*
name|res
init|=
name|c
operator|->
name|batch
index|[
operator|--
name|c
operator|->
name|count
index|]
decl_stmt|;
name|PREFETCH
argument_list|(
name|c
operator|->
name|batch
index|[
name|c
operator|->
name|count
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|void
name|Deallocate
parameter_list|(
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|,
name|uptr
name|class_id
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|CHECK_NE
argument_list|(
name|class_id
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
name|CHECK_LT
argument_list|(
name|class_id
argument_list|,
name|kNumClasses
argument_list|)
expr_stmt|;
comment|// If the first allocator call on a new thread is a deallocation, then
comment|// max_count will be zero, leading to check failure.
name|InitCache
argument_list|()
expr_stmt|;
name|stats_
operator|.
name|Sub
argument_list|(
name|AllocatorStatAllocated
argument_list|,
name|SizeClassMap
operator|::
name|Size
argument_list|(
name|class_id
argument_list|)
argument_list|)
expr_stmt|;
name|PerClass
modifier|*
name|c
init|=
operator|&
name|per_class_
index|[
name|class_id
index|]
decl_stmt|;
name|CHECK_NE
argument_list|(
name|c
operator|->
name|max_count
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
name|c
operator|->
name|count
operator|==
name|c
operator|->
name|max_count
argument_list|)
condition|)
name|Drain
argument_list|(
name|allocator
argument_list|,
name|class_id
argument_list|)
expr_stmt|;
name|c
operator|->
name|batch
index|[
name|c
operator|->
name|count
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Drain
parameter_list|(
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|)
block|{
for|for
control|(
name|uptr
name|class_id
init|=
literal|0
init|;
name|class_id
operator|<
name|kNumClasses
condition|;
name|class_id
operator|++
control|)
block|{
name|PerClass
modifier|*
name|c
init|=
operator|&
name|per_class_
index|[
name|class_id
index|]
decl_stmt|;
while|while
condition|(
name|c
operator|->
name|count
operator|>
literal|0
condition|)
name|Drain
argument_list|(
name|allocator
argument_list|,
name|class_id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// private:
end_comment

begin_typedef
typedef|typedef
name|typename
name|SizeClassAllocator
operator|::
name|SizeClassMapT
name|SizeClassMap
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|SizeClassMap
operator|::
name|TransferBatch
name|Batch
expr_stmt|;
end_typedef

begin_struct
struct|struct
name|PerClass
block|{
name|uptr
name|count
decl_stmt|;
name|uptr
name|max_count
decl_stmt|;
name|void
modifier|*
name|batch
index|[
literal|2
operator|*
name|SizeClassMap
operator|::
name|kMaxNumCached
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|PerClass
name|per_class_
index|[
name|kNumClasses
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|AllocatorStats
name|stats_
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|InitCache
parameter_list|()
block|{
if|if
condition|(
name|per_class_
index|[
literal|1
index|]
operator|.
name|max_count
condition|)
return|return;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kNumClasses
condition|;
name|i
operator|++
control|)
block|{
name|PerClass
modifier|*
name|c
init|=
operator|&
name|per_class_
index|[
name|i
index|]
decl_stmt|;
name|c
operator|->
name|max_count
operator|=
literal|2
operator|*
name|SizeClassMap
operator|::
name|MaxCached
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|NOINLINE
name|void
name|Refill
parameter_list|(
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|,
name|uptr
name|class_id
parameter_list|)
block|{
name|InitCache
argument_list|()
expr_stmt|;
name|PerClass
modifier|*
name|c
init|=
operator|&
name|per_class_
index|[
name|class_id
index|]
decl_stmt|;
name|Batch
modifier|*
name|b
init|=
name|allocator
operator|->
name|AllocateBatch
argument_list|(
operator|&
name|stats_
argument_list|,
name|this
argument_list|,
name|class_id
argument_list|)
decl_stmt|;
name|CHECK_GT
argument_list|(
name|b
operator|->
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|b
operator|->
name|count
condition|;
name|i
operator|++
control|)
name|c
operator|->
name|batch
index|[
name|i
index|]
operator|=
name|b
operator|->
name|batch
index|[
name|i
index|]
expr_stmt|;
name|c
operator|->
name|count
operator|=
name|b
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|SizeClassMap
operator|::
name|SizeClassRequiresSeparateTransferBatch
argument_list|(
name|class_id
argument_list|)
condition|)
name|Deallocate
argument_list|(
name|allocator
argument_list|,
name|SizeClassMap
operator|::
name|ClassID
argument_list|(
sizeof|sizeof
argument_list|(
name|Batch
argument_list|)
argument_list|)
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|NOINLINE
name|void
name|Drain
parameter_list|(
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|,
name|uptr
name|class_id
parameter_list|)
block|{
name|InitCache
argument_list|()
expr_stmt|;
name|PerClass
modifier|*
name|c
init|=
operator|&
name|per_class_
index|[
name|class_id
index|]
decl_stmt|;
name|Batch
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|SizeClassMap
operator|::
name|SizeClassRequiresSeparateTransferBatch
argument_list|(
name|class_id
argument_list|)
condition|)
name|b
operator|=
operator|(
name|Batch
operator|*
operator|)
name|Allocate
argument_list|(
name|allocator
argument_list|,
name|SizeClassMap
operator|::
name|ClassID
argument_list|(
sizeof|sizeof
argument_list|(
name|Batch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|b
operator|=
operator|(
name|Batch
operator|*
operator|)
name|c
operator|->
name|batch
index|[
literal|0
index|]
expr_stmt|;
name|uptr
name|cnt
init|=
name|Min
argument_list|(
name|c
operator|->
name|max_count
operator|/
literal|2
argument_list|,
name|c
operator|->
name|count
argument_list|)
decl_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|->
name|batch
index|[
name|i
index|]
operator|=
name|c
operator|->
name|batch
index|[
name|i
index|]
expr_stmt|;
name|c
operator|->
name|batch
index|[
name|i
index|]
operator|=
name|c
operator|->
name|batch
index|[
name|i
operator|+
name|c
operator|->
name|max_count
operator|/
literal|2
index|]
expr_stmt|;
block|}
name|b
operator|->
name|count
operator|=
name|cnt
expr_stmt|;
name|c
operator|->
name|count
operator|-=
name|cnt
expr_stmt|;
name|CHECK_GT
argument_list|(
name|b
operator|->
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|allocator
operator|->
name|DeallocateBatch
argument_list|(
operator|&
name|stats_
argument_list|,
name|class_id
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|// This class can (de)allocate only large chunks of memory using mmap/unmap.
end_comment

begin_comment
comment|// The main purpose of this allocator is to cover large and rare allocation
end_comment

begin_comment
comment|// sizes not covered by more efficient allocators (e.g. SizeClassAllocator64).
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|MapUnmapCallback
operator|=
name|NoOpMapUnmapCallback
operator|>
name|class
name|LargeMmapAllocator
block|{
name|public
operator|:
name|void
name|InitLinkerInitialized
argument_list|(
argument|bool may_return_null
argument_list|)
block|{
name|page_size_
operator|=
name|GetPageSizeCached
argument_list|()
block|;
name|atomic_store
argument_list|(
operator|&
name|may_return_null_
argument_list|,
name|may_return_null
argument_list|,
name|memory_order_relaxed
argument_list|)
block|;   }
name|void
name|Init
argument_list|(
argument|bool may_return_null
argument_list|)
block|{
name|internal_memset
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
argument_list|)
block|;
name|InitLinkerInitialized
argument_list|(
name|may_return_null
argument_list|)
block|;   }
name|void
operator|*
name|Allocate
argument_list|(
argument|AllocatorStats *stat
argument_list|,
argument|uptr size
argument_list|,
argument|uptr alignment
argument_list|)
block|{
name|CHECK
argument_list|(
name|IsPowerOfTwo
argument_list|(
name|alignment
argument_list|)
argument_list|)
block|;
name|uptr
name|map_size
operator|=
name|RoundUpMapSize
argument_list|(
name|size
argument_list|)
block|;
if|if
condition|(
name|alignment
operator|>
name|page_size_
condition|)
name|map_size
operator|+=
name|alignment
expr_stmt|;
comment|// Overflow.
if|if
condition|(
name|map_size
operator|<
name|size
condition|)
return|return
name|ReturnNullOrDie
argument_list|()
return|;
name|uptr
name|map_beg
operator|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|MmapOrDie
argument_list|(
name|map_size
argument_list|,
literal|"LargeMmapAllocator"
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CHECK
argument_list|(
name|IsAligned
argument_list|(
name|map_beg
argument_list|,
name|page_size_
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MapUnmapCallback
argument_list|()
operator|.
name|OnMap
argument_list|(
name|map_beg
argument_list|,
name|map_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|uptr
name|map_end
init|=
name|map_beg
operator|+
name|map_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uptr
name|res
init|=
name|map_beg
operator|+
name|page_size_
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|res
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
condition|)
comment|// Align.
name|res
operator|+=
name|alignment
operator|-
operator|(
name|res
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
end_if

begin_expr_stmt
name|CHECK
argument_list|(
name|IsAligned
argument_list|(
name|res
argument_list|,
name|alignment
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CHECK
argument_list|(
name|IsAligned
argument_list|(
name|res
argument_list|,
name|page_size_
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CHECK_GE
argument_list|(
name|res
operator|+
name|size
argument_list|,
name|map_beg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CHECK_LE
argument_list|(
name|res
operator|+
name|size
argument_list|,
name|map_end
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Header
modifier|*
name|h
init|=
name|GetHeader
argument_list|(
name|res
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|h
operator|->
name|size
operator|=
name|size
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|h
operator|->
name|map_beg
operator|=
name|map_beg
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|h
operator|->
name|map_size
operator|=
name|map_size
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|uptr
name|size_log
init|=
name|MostSignificantSetBitIndex
argument_list|(
name|map_size
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHECK_LT
argument_list|(
name|size_log
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|stats
operator|.
name|by_size_log
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|mutex_
argument_list|)
decl_stmt|;
name|uptr
name|idx
init|=
name|n_chunks_
operator|++
decl_stmt|;
name|chunks_sorted_
operator|=
name|false
expr_stmt|;
name|CHECK_LT
argument_list|(
name|idx
argument_list|,
name|kMaxNumChunks
argument_list|)
expr_stmt|;
name|h
operator|->
name|chunk_idx
operator|=
name|idx
expr_stmt|;
name|chunks_
index|[
name|idx
index|]
operator|=
name|h
expr_stmt|;
name|stats
operator|.
name|n_allocs
operator|++
expr_stmt|;
name|stats
operator|.
name|currently_allocated
operator|+=
name|map_size
expr_stmt|;
name|stats
operator|.
name|max_allocated
operator|=
name|Max
argument_list|(
name|stats
operator|.
name|max_allocated
argument_list|,
name|stats
operator|.
name|currently_allocated
argument_list|)
expr_stmt|;
name|stats
operator|.
name|by_size_log
index|[
name|size_log
index|]
operator|++
expr_stmt|;
name|stat
operator|->
name|Add
argument_list|(
name|AllocatorStatAllocated
argument_list|,
name|map_size
argument_list|)
expr_stmt|;
name|stat
operator|->
name|Add
argument_list|(
name|AllocatorStatMapped
argument_list|,
name|map_size
argument_list|)
expr_stmt|;
block|}
end_block

begin_return
return|return
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|res
operator|)
return|;
end_return

begin_expr_stmt
unit|}    void
operator|*
name|ReturnNullOrDie
argument_list|()
block|{
if|if
condition|(
name|atomic_load
argument_list|(
operator|&
name|may_return_null_
argument_list|,
name|memory_order_acquire
argument_list|)
condition|)
return|return
name|nullptr
return|;
name|ReportAllocatorCannotReturnNull
argument_list|()
expr_stmt|;
end_expr_stmt

begin_macro
unit|}    void
name|SetMayReturnNull
argument_list|(
argument|bool may_return_null
argument_list|)
end_macro

begin_block
block|{
name|atomic_store
argument_list|(
operator|&
name|may_return_null_
argument_list|,
name|may_return_null
argument_list|,
name|memory_order_release
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|Deallocate
parameter_list|(
name|AllocatorStats
modifier|*
name|stat
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|Header
modifier|*
name|h
init|=
name|GetHeader
argument_list|(
name|p
argument_list|)
decl_stmt|;
block|{
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|mutex_
argument_list|)
decl_stmt|;
name|uptr
name|idx
init|=
name|h
operator|->
name|chunk_idx
decl_stmt|;
name|CHECK_EQ
argument_list|(
name|chunks_
index|[
name|idx
index|]
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|CHECK_LT
argument_list|(
name|idx
argument_list|,
name|n_chunks_
argument_list|)
expr_stmt|;
name|chunks_
index|[
name|idx
index|]
operator|=
name|chunks_
index|[
name|n_chunks_
operator|-
literal|1
index|]
expr_stmt|;
name|chunks_
index|[
name|idx
index|]
operator|->
name|chunk_idx
operator|=
name|idx
expr_stmt|;
name|n_chunks_
operator|--
expr_stmt|;
name|chunks_sorted_
operator|=
name|false
expr_stmt|;
name|stats
operator|.
name|n_frees
operator|++
expr_stmt|;
name|stats
operator|.
name|currently_allocated
operator|-=
name|h
operator|->
name|map_size
expr_stmt|;
name|stat
operator|->
name|Sub
argument_list|(
name|AllocatorStatAllocated
argument_list|,
name|h
operator|->
name|map_size
argument_list|)
expr_stmt|;
name|stat
operator|->
name|Sub
argument_list|(
name|AllocatorStatMapped
argument_list|,
name|h
operator|->
name|map_size
argument_list|)
expr_stmt|;
block|}
name|MapUnmapCallback
argument_list|()
operator|.
name|OnUnmap
argument_list|(
name|h
operator|->
name|map_beg
argument_list|,
name|h
operator|->
name|map_size
argument_list|)
expr_stmt|;
name|UnmapOrDie
argument_list|(
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|h
operator|->
name|map_beg
operator|)
argument_list|,
name|h
operator|->
name|map_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uptr
name|TotalMemoryUsed
parameter_list|()
block|{
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|mutex_
argument_list|)
decl_stmt|;
name|uptr
name|res
init|=
literal|0
decl_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n_chunks_
condition|;
name|i
operator|++
control|)
block|{
name|Header
modifier|*
name|h
init|=
name|chunks_
index|[
name|i
index|]
decl_stmt|;
name|CHECK_EQ
argument_list|(
name|h
operator|->
name|chunk_idx
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|res
operator|+=
name|RoundUpMapSize
argument_list|(
name|h
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
name|bool
name|PointerIsMine
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
name|GetBlockBegin
argument_list|(
name|p
argument_list|)
operator|!=
name|nullptr
return|;
block|}
end_function

begin_function
name|uptr
name|GetActuallyAllocatedSize
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
name|RoundUpTo
argument_list|(
name|GetHeader
argument_list|(
name|p
argument_list|)
operator|->
name|size
argument_list|,
name|page_size_
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// At least page_size_/2 metadata bytes is available.
end_comment

begin_function
name|void
modifier|*
name|GetMetaData
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
comment|// Too slow: CHECK_EQ(p, GetBlockBegin(p));
if|if
condition|(
operator|!
name|IsAligned
argument_list|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
argument_list|,
name|page_size_
argument_list|)
condition|)
block|{
name|Printf
argument_list|(
literal|"%s: bad pointer %p\n"
argument_list|,
name|SanitizerToolName
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|IsAligned
argument_list|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
argument_list|,
name|page_size_
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|GetHeader
argument_list|(
name|p
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|GetBlockBegin
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|uptr
name|p
init|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|ptr
operator|)
decl_stmt|;
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|mutex_
argument_list|)
decl_stmt|;
name|uptr
name|nearest_chunk
init|=
literal|0
decl_stmt|;
comment|// Cache-friendly linear search.
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n_chunks_
condition|;
name|i
operator|++
control|)
block|{
name|uptr
name|ch
init|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|chunks_
index|[
name|i
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|p
operator|<
name|ch
condition|)
continue|continue;
comment|// p is at left to this chunk, skip it.
if|if
condition|(
name|p
operator|-
name|ch
operator|<
name|p
operator|-
name|nearest_chunk
condition|)
name|nearest_chunk
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nearest_chunk
condition|)
return|return
name|nullptr
return|;
name|Header
modifier|*
name|h
init|=
name|reinterpret_cast
operator|<
name|Header
operator|*
operator|>
operator|(
name|nearest_chunk
operator|)
decl_stmt|;
name|CHECK_GE
argument_list|(
name|nearest_chunk
argument_list|,
name|h
operator|->
name|map_beg
argument_list|)
expr_stmt|;
name|CHECK_LT
argument_list|(
name|nearest_chunk
argument_list|,
name|h
operator|->
name|map_beg
operator|+
name|h
operator|->
name|map_size
argument_list|)
expr_stmt|;
name|CHECK_LE
argument_list|(
name|nearest_chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|map_beg
operator|+
name|h
operator|->
name|map_size
operator|<=
name|p
condition|)
return|return
name|nullptr
return|;
return|return
name|GetUser
argument_list|(
name|h
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// This function does the same as GetBlockBegin, but is much faster.
end_comment

begin_comment
comment|// Must be called with the allocator locked.
end_comment

begin_function
name|void
modifier|*
name|GetBlockBeginFastLocked
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|mutex_
operator|.
name|CheckLocked
argument_list|()
expr_stmt|;
name|uptr
name|p
init|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|ptr
operator|)
decl_stmt|;
name|uptr
name|n
init|=
name|n_chunks_
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|nullptr
return|;
if|if
condition|(
operator|!
name|chunks_sorted_
condition|)
block|{
comment|// Do one-time sort. chunks_sorted_ is reset in Allocate/Deallocate.
name|SortArray
argument_list|(
name|reinterpret_cast
operator|<
name|uptr
operator|*
operator|>
operator|(
name|chunks_
operator|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|chunks_
index|[
name|i
index|]
operator|->
name|chunk_idx
operator|=
name|i
expr_stmt|;
name|chunks_sorted_
operator|=
name|true
expr_stmt|;
name|min_mmap_
operator|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|chunks_
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|max_mmap_
operator|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|chunks_
index|[
name|n
operator|-
literal|1
index|]
operator|)
operator|+
name|chunks_
index|[
name|n
operator|-
literal|1
index|]
operator|->
name|map_size
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|<
name|min_mmap_
operator|||
name|p
operator|>=
name|max_mmap_
condition|)
return|return
name|nullptr
return|;
name|uptr
name|beg
init|=
literal|0
decl_stmt|,
name|end
init|=
name|n
operator|-
literal|1
decl_stmt|;
comment|// This loop is a log(n) lower_bound. It does not check for the exact match
comment|// to avoid expensive cache-thrashing loads.
while|while
condition|(
name|end
operator|-
name|beg
operator|>=
literal|2
condition|)
block|{
name|uptr
name|mid
init|=
operator|(
name|beg
operator|+
name|end
operator|)
operator|/
literal|2
decl_stmt|;
comment|// Invariant: mid>= beg + 1
if|if
condition|(
name|p
operator|<
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|chunks_
index|[
name|mid
index|]
operator|)
condition|)
name|end
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
comment|// We are not interested in chunks_[mid].
else|else
name|beg
operator|=
name|mid
expr_stmt|;
comment|// chunks_[mid] may still be what we want.
block|}
if|if
condition|(
name|beg
operator|<
name|end
condition|)
block|{
name|CHECK_EQ
argument_list|(
name|beg
operator|+
literal|1
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|// There are 2 chunks left, choose one.
if|if
condition|(
name|p
operator|>=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|chunks_
index|[
name|end
index|]
operator|)
condition|)
name|beg
operator|=
name|end
expr_stmt|;
block|}
name|Header
modifier|*
name|h
init|=
name|chunks_
index|[
name|beg
index|]
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|map_beg
operator|+
name|h
operator|->
name|map_size
operator|<=
name|p
operator|||
name|p
operator|<
name|h
operator|->
name|map_beg
condition|)
return|return
name|nullptr
return|;
return|return
name|GetUser
argument_list|(
name|h
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|PrintStats
parameter_list|()
block|{
name|Printf
argument_list|(
literal|"Stats: LargeMmapAllocator: allocated %zd times, "
literal|"remains %zd (%zd K) max %zd M; by size logs: "
argument_list|,
name|stats
operator|.
name|n_allocs
argument_list|,
name|stats
operator|.
name|n_allocs
operator|-
name|stats
operator|.
name|n_frees
argument_list|,
name|stats
operator|.
name|currently_allocated
operator|>>
literal|10
argument_list|,
name|stats
operator|.
name|max_allocated
operator|>>
literal|20
argument_list|)
expr_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|stats
operator|.
name|by_size_log
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|uptr
name|c
init|=
name|stats
operator|.
name|by_size_log
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
continue|continue;
name|Printf
argument_list|(
literal|"%zd:%zd; "
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|Printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone
end_comment

begin_comment
comment|// introspection API.
end_comment

begin_function
name|void
name|ForceLock
parameter_list|()
block|{
name|mutex_
operator|.
name|Lock
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ForceUnlock
parameter_list|()
block|{
name|mutex_
operator|.
name|Unlock
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|// Iterate over all existing chunks.
end_comment

begin_comment
comment|// The allocator must be locked when calling this function.
end_comment

begin_function
name|void
name|ForEachChunk
parameter_list|(
name|ForEachChunkCallback
name|callback
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n_chunks_
condition|;
name|i
operator|++
control|)
name|callback
argument_list|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|GetUser
argument_list|(
name|chunks_
index|[
name|i
index|]
argument_list|)
operator|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_decl_stmt
specifier|static
specifier|const
name|int
name|kMaxNumChunks
init|=
literal|1
operator|<<
name|FIRST_32_SECOND_64
argument_list|(
literal|15
argument_list|,
literal|18
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|Header
block|{
name|uptr
name|map_beg
decl_stmt|;
name|uptr
name|map_size
decl_stmt|;
name|uptr
name|size
decl_stmt|;
name|uptr
name|chunk_idx
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|Header
modifier|*
name|GetHeader
parameter_list|(
name|uptr
name|p
parameter_list|)
block|{
name|CHECK
argument_list|(
name|IsAligned
argument_list|(
name|p
argument_list|,
name|page_size_
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reinterpret_cast
operator|<
name|Header
operator|*
operator|>
operator|(
name|p
operator|-
name|page_size_
operator|)
return|;
block|}
end_function

begin_function
name|Header
modifier|*
name|GetHeader
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
name|GetHeader
argument_list|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|GetUser
parameter_list|(
name|Header
modifier|*
name|h
parameter_list|)
block|{
name|CHECK
argument_list|(
name|IsAligned
argument_list|(
operator|(
name|uptr
operator|)
name|h
argument_list|,
name|page_size_
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|h
operator|)
operator|+
name|page_size_
operator|)
return|;
block|}
end_function

begin_function
name|uptr
name|RoundUpMapSize
parameter_list|(
name|uptr
name|size
parameter_list|)
block|{
return|return
name|RoundUpTo
argument_list|(
name|size
argument_list|,
name|page_size_
argument_list|)
operator|+
name|page_size_
return|;
block|}
end_function

begin_decl_stmt
name|uptr
name|page_size_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Header
modifier|*
name|chunks_
index|[
name|kMaxNumChunks
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uptr
name|n_chunks_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uptr
name|min_mmap_
decl_stmt|,
name|max_mmap_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|chunks_sorted_
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|Stats
block|{
name|uptr
name|n_allocs
decl_stmt|,
name|n_frees
decl_stmt|,
name|currently_allocated
decl_stmt|,
name|max_allocated
decl_stmt|,
name|by_size_log
index|[
literal|64
index|]
decl_stmt|;
block|}
name|stats
struct|;
end_struct

begin_decl_stmt
name|atomic_uint8_t
name|may_return_null_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SpinMutex
name|mutex_
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// This class implements a complete memory allocator by using two
end_comment

begin_comment
comment|// internal allocators:
end_comment

begin_comment
comment|// PrimaryAllocator is efficient, but may not allocate some sizes (alignments).
end_comment

begin_comment
comment|//  When allocating 2^x bytes it should return 2^x aligned chunk.
end_comment

begin_comment
comment|// PrimaryAllocator is used via a local AllocatorCache.
end_comment

begin_comment
comment|// SecondaryAllocator can allocate anything, but is not efficient.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|PrimaryAllocator
operator|,
name|class
name|AllocatorCache
operator|,
name|class
name|SecondaryAllocator
operator|>
comment|// NOLINT
name|class
name|CombinedAllocator
block|{
name|public
operator|:
name|void
name|InitCommon
argument_list|(
argument|bool may_return_null
argument_list|)
block|{
name|primary_
operator|.
name|Init
argument_list|()
block|;
name|atomic_store
argument_list|(
operator|&
name|may_return_null_
argument_list|,
name|may_return_null
argument_list|,
name|memory_order_relaxed
argument_list|)
block|;   }
name|void
name|InitLinkerInitialized
argument_list|(
argument|bool may_return_null
argument_list|)
block|{
name|secondary_
operator|.
name|InitLinkerInitialized
argument_list|(
name|may_return_null
argument_list|)
block|;
name|stats_
operator|.
name|InitLinkerInitialized
argument_list|()
block|;
name|InitCommon
argument_list|(
name|may_return_null
argument_list|)
block|;   }
name|void
name|Init
argument_list|(
argument|bool may_return_null
argument_list|)
block|{
name|secondary_
operator|.
name|Init
argument_list|(
name|may_return_null
argument_list|)
block|;
name|stats_
operator|.
name|Init
argument_list|()
block|;
name|InitCommon
argument_list|(
name|may_return_null
argument_list|)
block|;   }
name|void
operator|*
name|Allocate
argument_list|(
argument|AllocatorCache *cache
argument_list|,
argument|uptr size
argument_list|,
argument|uptr alignment
argument_list|,
argument|bool cleared = false
argument_list|,
argument|bool check_rss_limit = false
argument_list|)
block|{
comment|// Returning 0 on malloc(0) may break a lot of code.
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|size
operator|+
name|alignment
operator|<
name|size
condition|)
return|return
name|ReturnNullOrDie
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|check_rss_limit
operator|&&
name|RssLimitIsExceeded
argument_list|()
condition|)
return|return
name|ReturnNullOrDie
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
name|alignment
operator|>
literal|8
condition|)
name|size
operator|=
name|RoundUpTo
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
end_if

begin_decl_stmt
name|void
modifier|*
name|res
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|from_primary
init|=
name|primary_
operator|.
name|CanAllocate
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|from_primary
condition|)
name|res
operator|=
name|cache
operator|->
name|Allocate
argument_list|(
operator|&
name|primary_
argument_list|,
name|primary_
operator|.
name|ClassID
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|secondary_
operator|.
name|Allocate
argument_list|(
operator|&
name|stats_
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|alignment
operator|>
literal|8
condition|)
name|CHECK_EQ
argument_list|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|res
operator|)
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|cleared
operator|&&
name|res
operator|&&
name|from_primary
condition|)
name|internal_bzero_aligned16
argument_list|(
name|res
argument_list|,
name|RoundUpTo
argument_list|(
name|size
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|res
return|;
end_return

begin_macro
unit|}    bool
name|MayReturnNull
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
return|return
name|atomic_load
argument_list|(
operator|&
name|may_return_null_
argument_list|,
name|memory_order_acquire
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
modifier|*
name|ReturnNullOrDie
parameter_list|()
block|{
if|if
condition|(
name|MayReturnNull
argument_list|()
condition|)
return|return
name|nullptr
return|;
name|ReportAllocatorCannotReturnNull
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetMayReturnNull
parameter_list|(
name|bool
name|may_return_null
parameter_list|)
block|{
name|secondary_
operator|.
name|SetMayReturnNull
argument_list|(
name|may_return_null
argument_list|)
expr_stmt|;
name|atomic_store
argument_list|(
operator|&
name|may_return_null_
argument_list|,
name|may_return_null
argument_list|,
name|memory_order_release
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|RssLimitIsExceeded
parameter_list|()
block|{
return|return
name|atomic_load
argument_list|(
operator|&
name|rss_limit_is_exceeded_
argument_list|,
name|memory_order_acquire
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|SetRssLimitIsExceeded
parameter_list|(
name|bool
name|rss_limit_is_exceeded
parameter_list|)
block|{
name|atomic_store
argument_list|(
operator|&
name|rss_limit_is_exceeded_
argument_list|,
name|rss_limit_is_exceeded
argument_list|,
name|memory_order_release
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Deallocate
parameter_list|(
name|AllocatorCache
modifier|*
name|cache
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
condition|)
return|return;
if|if
condition|(
name|primary_
operator|.
name|PointerIsMine
argument_list|(
name|p
argument_list|)
condition|)
name|cache
operator|->
name|Deallocate
argument_list|(
operator|&
name|primary_
argument_list|,
name|primary_
operator|.
name|GetSizeClass
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|secondary_
operator|.
name|Deallocate
argument_list|(
operator|&
name|stats_
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|Reallocate
parameter_list|(
name|AllocatorCache
modifier|*
name|cache
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|uptr
name|new_size
parameter_list|,
name|uptr
name|alignment
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|Allocate
argument_list|(
name|cache
argument_list|,
name|new_size
argument_list|,
name|alignment
argument_list|)
return|;
if|if
condition|(
operator|!
name|new_size
condition|)
block|{
name|Deallocate
argument_list|(
name|cache
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|nullptr
return|;
block|}
name|CHECK
argument_list|(
name|PointerIsMine
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|uptr
name|old_size
init|=
name|GetActuallyAllocatedSize
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|uptr
name|memcpy_size
init|=
name|Min
argument_list|(
name|new_size
argument_list|,
name|old_size
argument_list|)
decl_stmt|;
name|void
modifier|*
name|new_p
init|=
name|Allocate
argument_list|(
name|cache
argument_list|,
name|new_size
argument_list|,
name|alignment
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_p
condition|)
name|internal_memcpy
argument_list|(
name|new_p
argument_list|,
name|p
argument_list|,
name|memcpy_size
argument_list|)
expr_stmt|;
name|Deallocate
argument_list|(
name|cache
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|new_p
return|;
block|}
end_function

begin_function
name|bool
name|PointerIsMine
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|primary_
operator|.
name|PointerIsMine
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|secondary_
operator|.
name|PointerIsMine
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|FromPrimary
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
name|primary_
operator|.
name|PointerIsMine
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|GetMetaData
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|primary_
operator|.
name|PointerIsMine
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|primary_
operator|.
name|GetMetaData
argument_list|(
name|p
argument_list|)
return|;
return|return
name|secondary_
operator|.
name|GetMetaData
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|GetBlockBegin
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|primary_
operator|.
name|PointerIsMine
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|primary_
operator|.
name|GetBlockBegin
argument_list|(
name|p
argument_list|)
return|;
return|return
name|secondary_
operator|.
name|GetBlockBegin
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// This function does the same as GetBlockBegin, but is much faster.
end_comment

begin_comment
comment|// Must be called with the allocator locked.
end_comment

begin_function
name|void
modifier|*
name|GetBlockBeginFastLocked
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|primary_
operator|.
name|PointerIsMine
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|primary_
operator|.
name|GetBlockBegin
argument_list|(
name|p
argument_list|)
return|;
return|return
name|secondary_
operator|.
name|GetBlockBeginFastLocked
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|uptr
name|GetActuallyAllocatedSize
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|primary_
operator|.
name|PointerIsMine
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|primary_
operator|.
name|GetActuallyAllocatedSize
argument_list|(
name|p
argument_list|)
return|;
return|return
name|secondary_
operator|.
name|GetActuallyAllocatedSize
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|uptr
name|TotalMemoryUsed
parameter_list|()
block|{
return|return
name|primary_
operator|.
name|TotalMemoryUsed
argument_list|()
operator|+
name|secondary_
operator|.
name|TotalMemoryUsed
argument_list|()
return|;
block|}
end_function

begin_function
name|void
name|TestOnlyUnmap
parameter_list|()
block|{
name|primary_
operator|.
name|TestOnlyUnmap
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|InitCache
parameter_list|(
name|AllocatorCache
modifier|*
name|cache
parameter_list|)
block|{
name|cache
operator|->
name|Init
argument_list|(
operator|&
name|stats_
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|DestroyCache
parameter_list|(
name|AllocatorCache
modifier|*
name|cache
parameter_list|)
block|{
name|cache
operator|->
name|Destroy
argument_list|(
operator|&
name|primary_
argument_list|,
operator|&
name|stats_
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SwallowCache
parameter_list|(
name|AllocatorCache
modifier|*
name|cache
parameter_list|)
block|{
name|cache
operator|->
name|Drain
argument_list|(
operator|&
name|primary_
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|GetStats
argument_list|(
name|AllocatorStatCounters
name|s
argument_list|)
decl|const
block|{
name|stats_
operator|.
name|Get
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|PrintStats
parameter_list|()
block|{
name|primary_
operator|.
name|PrintStats
argument_list|()
expr_stmt|;
name|secondary_
operator|.
name|PrintStats
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|// ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone
end_comment

begin_comment
comment|// introspection API.
end_comment

begin_function
name|void
name|ForceLock
parameter_list|()
block|{
name|primary_
operator|.
name|ForceLock
argument_list|()
expr_stmt|;
name|secondary_
operator|.
name|ForceLock
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ForceUnlock
parameter_list|()
block|{
name|secondary_
operator|.
name|ForceUnlock
argument_list|()
expr_stmt|;
name|primary_
operator|.
name|ForceUnlock
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|// Iterate over all existing chunks.
end_comment

begin_comment
comment|// The allocator must be locked when calling this function.
end_comment

begin_function
name|void
name|ForEachChunk
parameter_list|(
name|ForEachChunkCallback
name|callback
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|primary_
operator|.
name|ForEachChunk
argument_list|(
name|callback
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|secondary_
operator|.
name|ForEachChunk
argument_list|(
name|callback
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|PrimaryAllocator
name|primary_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SecondaryAllocator
name|secondary_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|AllocatorGlobalStats
name|stats_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|atomic_uint8_t
name|may_return_null_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|atomic_uint8_t
name|rss_limit_is_exceeded_
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Returns true if calloc(size, n) should return 0 due to overflow in size*n.
end_comment

begin_function_decl
name|bool
name|CallocShouldReturnNullDueToOverflow
parameter_list|(
name|uptr
name|size
parameter_list|,
name|uptr
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_comment
unit|}
comment|// namespace __sanitizer
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// SANITIZER_ALLOCATOR_H
end_comment

end_unit

