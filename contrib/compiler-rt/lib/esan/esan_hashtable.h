begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- esan_hashtable.h ----------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is a part of EfficiencySanitizer, a family of performance tuners.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Generic resizing hashtable.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_include
include|#
directive|include
file|"sanitizer_common/sanitizer_allocator_internal.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_common/sanitizer_internal_defs.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_common/sanitizer_mutex.h"
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_decl_stmt
name|namespace
name|__esan
block|{
comment|//===----------------------------------------------------------------------===//
comment|// Default hash and comparison functions
comment|//===----------------------------------------------------------------------===//
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|DefaultHash
block|{
name|size_t
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|Key
operator|)
specifier|const
block|{
return|return
operator|(
name|size_t
operator|)
name|Key
return|;
block|}
expr|}
block|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|DefaultEqual
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|Key1
operator|,
specifier|const
name|T
operator|&
name|Key2
operator|)
specifier|const
block|{
return|return
name|Key1
operator|==
name|Key2
return|;
block|}
expr|}
block|;
comment|//===----------------------------------------------------------------------===//
comment|// HashTable declaration
comment|//===----------------------------------------------------------------------===//
comment|// A simple resizing and mutex-locked hashtable.
comment|//
comment|// If the default hash functor is used, KeyTy must have an operator size_t().
comment|// If the default comparison functor is used, KeyTy must have an operator ==.
comment|//
comment|// By default all operations are internally-synchronized with a mutex, with no
comment|// synchronization for payloads once hashtable functions return.  If
comment|// ExternalLock is set to true, the caller should call the lock() and unlock()
comment|// routines around all hashtable operations and subsequent manipulation of
comment|// payloads.
name|template
operator|<
name|typename
name|KeyTy
block|,
name|typename
name|DataTy
block|,
name|bool
name|ExternalLock
operator|=
name|false
block|,
name|typename
name|HashFuncTy
operator|=
name|DefaultHash
operator|<
name|KeyTy
operator|>
block|,
name|typename
name|EqualFuncTy
operator|=
name|DefaultEqual
operator|<
name|KeyTy
operator|>
expr|>
name|class
name|HashTable
block|{
name|public
operator|:
comment|// InitialCapacity must be a power of 2.
comment|// ResizeFactor must be between 1 and 99 and indicates the
comment|// maximum percentage full that the table should ever be.
name|HashTable
argument_list|(
argument|u32 InitialCapacity =
literal|2048
argument_list|,
argument|u32 ResizeFactor =
literal|70
argument_list|)
block|;
operator|~
name|HashTable
argument_list|()
block|;
name|bool
name|lookup
argument_list|(
specifier|const
name|KeyTy
operator|&
name|Key
argument_list|,
name|DataTy
operator|&
name|Payload
argument_list|)
block|;
comment|// Const except for Mutex.
name|bool
name|add
argument_list|(
specifier|const
name|KeyTy
operator|&
name|Key
argument_list|,
specifier|const
name|DataTy
operator|&
name|Payload
argument_list|)
block|;
name|bool
name|remove
argument_list|(
specifier|const
name|KeyTy
operator|&
name|Key
argument_list|)
block|;
name|u32
name|size
argument_list|()
block|;
comment|// Const except for Mutex.
comment|// If the table is internally-synchronized, this lock must not be held
comment|// while a hashtable function is called as it will deadlock: the lock
comment|// is not recursive.  This is meant for use with externally-synchronized
comment|// tables or with an iterator.
name|void
name|lock
argument_list|()
block|;
name|void
name|unlock
argument_list|()
block|;
name|private
operator|:
expr|struct
name|HashEntry
block|{
name|KeyTy
name|Key
block|;
name|DataTy
name|Payload
block|;
name|HashEntry
operator|*
name|Next
block|;   }
block|;
name|public
operator|:
expr|struct
name|HashPair
block|{
name|HashPair
argument_list|(
argument|KeyTy Key
argument_list|,
argument|DataTy Data
argument_list|)
operator|:
name|Key
argument_list|(
name|Key
argument_list|)
block|,
name|Data
argument_list|(
argument|Data
argument_list|)
block|{}
name|KeyTy
name|Key
block|;
name|DataTy
name|Data
block|;   }
block|;
comment|// This iterator does not perform any synchronization.
comment|// It expects the caller to lock the table across the whole iteration.
comment|// Calling HashTable functions while using the iterator is not supported.
comment|// The iterator returns copies of the keys and data.
name|class
name|iterator
block|{
name|public
operator|:
name|iterator
argument_list|(
name|HashTable
operator|<
name|KeyTy
argument_list|,
name|DataTy
argument_list|,
name|ExternalLock
argument_list|,
name|HashFuncTy
argument_list|,
name|EqualFuncTy
operator|>
operator|*
name|Table
argument_list|)
block|;
name|iterator
argument_list|(
specifier|const
name|iterator
operator|&
name|Src
argument_list|)
operator|=
expr|default
block|;
name|iterator
operator|&
name|operator
operator|=
operator|(
specifier|const
name|iterator
operator|&
name|Src
operator|)
operator|=
expr|default
block|;
name|HashPair
name|operator
operator|*
operator|(
operator|)
block|;
name|iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|;
name|iterator
operator|&
name|operator
operator|++
operator|(
name|int
operator|)
block|;
name|bool
name|operator
operator|==
operator|(
specifier|const
name|iterator
operator|&
name|Cmp
operator|)
specifier|const
block|;
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|iterator
operator|&
name|Cmp
operator|)
specifier|const
block|;
name|private
operator|:
name|iterator
argument_list|(
argument|HashTable<KeyTy
argument_list|,
argument|DataTy
argument_list|,
argument|ExternalLock
argument_list|,
argument|HashFuncTy
argument_list|,
argument|EqualFuncTy> *Table
argument_list|,
argument|int Idx
argument_list|)
block|;
name|friend
name|HashTable
operator|<
name|KeyTy
block|,
name|DataTy
block|,
name|ExternalLock
block|,
name|HashFuncTy
block|,
name|EqualFuncTy
operator|>
block|;
name|HashTable
operator|<
name|KeyTy
block|,
name|DataTy
block|,
name|ExternalLock
block|,
name|HashFuncTy
block|,
name|EqualFuncTy
operator|>
operator|*
name|Table
block|;
name|int
name|Idx
block|;
name|HashTable
operator|<
name|KeyTy
block|,
name|DataTy
block|,
name|ExternalLock
block|,
name|HashFuncTy
block|,
name|EqualFuncTy
operator|>
operator|::
name|HashEntry
operator|*
name|Entry
block|;   }
block|;
comment|// No erase or insert iterator supported
name|iterator
name|begin
argument_list|()
block|;
name|iterator
name|end
argument_list|()
block|;
name|private
operator|:
name|void
name|resize
argument_list|()
block|;
name|HashEntry
operator|*
operator|*
name|Table
block|;
name|u32
name|Capacity
block|;
name|u32
name|Entries
block|;
specifier|const
name|u32
name|ResizeFactor
block|;
name|BlockingMutex
name|Mutex
block|;
specifier|const
name|HashFuncTy
name|HashFunc
block|;
specifier|const
name|EqualFuncTy
name|EqualFunc
block|; }
block|;
comment|//===----------------------------------------------------------------------===//
comment|// Hashtable implementation
comment|//===----------------------------------------------------------------------===//
name|template
operator|<
name|typename
name|KeyTy
block|,
name|typename
name|DataTy
block|,
name|bool
name|ExternalLock
block|,
name|typename
name|HashFuncTy
block|,
name|typename
name|EqualFuncTy
operator|>
name|HashTable
operator|<
name|KeyTy
block|,
name|DataTy
block|,
name|ExternalLock
block|,
name|HashFuncTy
block|,
name|EqualFuncTy
operator|>
operator|::
name|HashTable
argument_list|(
argument|u32 InitialCapacity
argument_list|,
argument|u32 ResizeFactor
argument_list|)
operator|:
name|Capacity
argument_list|(
name|InitialCapacity
argument_list|)
block|,
name|Entries
argument_list|(
literal|0
argument_list|)
block|,
name|ResizeFactor
argument_list|(
name|ResizeFactor
argument_list|)
block|,
name|HashFunc
argument_list|(
name|HashFuncTy
argument_list|()
argument_list|)
block|,
name|EqualFunc
argument_list|(
argument|EqualFuncTy()
argument_list|)
block|{
name|CHECK
argument_list|(
name|IsPowerOfTwo
argument_list|(
name|Capacity
argument_list|)
argument_list|)
block|;
name|CHECK
argument_list|(
name|ResizeFactor
operator|>=
literal|1
operator|&&
name|ResizeFactor
operator|<=
literal|99
argument_list|)
block|;
name|Table
operator|=
operator|(
name|HashEntry
operator|*
operator|*
operator|)
name|InternalAlloc
argument_list|(
name|Capacity
operator|*
sizeof|sizeof
argument_list|(
name|HashEntry
operator|*
argument_list|)
argument_list|)
block|;
name|internal_memset
argument_list|(
name|Table
argument_list|,
literal|0
argument_list|,
name|Capacity
operator|*
sizeof|sizeof
argument_list|(
name|HashEntry
operator|*
argument_list|)
argument_list|)
block|; }
name|template
operator|<
name|typename
name|KeyTy
block|,
name|typename
name|DataTy
block|,
name|bool
name|ExternalLock
block|,
name|typename
name|HashFuncTy
block|,
name|typename
name|EqualFuncTy
operator|>
name|HashTable
operator|<
name|KeyTy
block|,
name|DataTy
block|,
name|ExternalLock
block|,
name|HashFuncTy
block|,
name|EqualFuncTy
operator|>
operator|::
operator|~
name|HashTable
argument_list|()
block|{
for|for
control|(
name|u32
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Capacity
condition|;
operator|++
name|i
control|)
block|{
name|HashEntry
modifier|*
name|Entry
init|=
name|Table
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|Entry
operator|!=
name|nullptr
condition|)
block|{
name|HashEntry
modifier|*
name|Next
init|=
name|Entry
operator|->
name|Next
decl_stmt|;
name|Entry
operator|->
name|Payload
operator|.
expr|~
name|DataTy
argument_list|()
expr_stmt|;
name|InternalFree
argument_list|(
name|Entry
argument_list|)
expr_stmt|;
name|Entry
operator|=
name|Next
expr_stmt|;
block|}
block|}
name|InternalFree
argument_list|(
name|Table
argument_list|)
expr_stmt|;
block|}
name|template
operator|<
name|typename
name|KeyTy
block|,
name|typename
name|DataTy
block|,
name|bool
name|ExternalLock
block|,
name|typename
name|HashFuncTy
block|,
name|typename
name|EqualFuncTy
operator|>
name|u32
name|HashTable
operator|<
name|KeyTy
block|,
name|DataTy
block|,
name|ExternalLock
block|,
name|HashFuncTy
block|,
name|EqualFuncTy
operator|>
operator|::
name|size
argument_list|()
block|{
name|u32
name|Res
block|;
if|if
condition|(
operator|!
name|ExternalLock
condition|)
name|Mutex
operator|.
name|Lock
argument_list|()
expr_stmt|;
name|Res
operator|=
name|Entries
block|;
if|if
condition|(
operator|!
name|ExternalLock
condition|)
name|Mutex
operator|.
name|Unlock
argument_list|()
expr_stmt|;
return|return
name|Res
return|;
block|}
name|template
operator|<
name|typename
name|KeyTy
operator|,
name|typename
name|DataTy
operator|,
name|bool
name|ExternalLock
operator|,
name|typename
name|HashFuncTy
operator|,
name|typename
name|EqualFuncTy
operator|>
name|bool
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|lookup
argument_list|(
argument|const KeyTy&Key
argument_list|,
argument|DataTy&Payload
argument_list|)
block|{
if|if
condition|(
operator|!
name|ExternalLock
condition|)
name|Mutex
operator|.
name|Lock
argument_list|()
expr_stmt|;
name|bool
name|Found
operator|=
name|false
expr_stmt|;
name|size_t
name|Hash
init|=
name|HashFunc
argument_list|(
name|Key
argument_list|)
operator|%
name|Capacity
decl_stmt|;
name|HashEntry
modifier|*
name|Entry
init|=
name|Table
index|[
name|Hash
index|]
decl_stmt|;
for|for
control|(
init|;
name|Entry
operator|!=
name|nullptr
condition|;
name|Entry
operator|=
name|Entry
operator|->
name|Next
control|)
block|{
if|if
condition|(
name|EqualFunc
argument_list|(
name|Entry
operator|->
name|Key
argument_list|,
name|Key
argument_list|)
condition|)
block|{
name|Payload
operator|=
name|Entry
operator|->
name|Payload
expr_stmt|;
name|Found
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ExternalLock
condition|)
name|Mutex
operator|.
name|Unlock
argument_list|()
expr_stmt|;
return|return
name|Found
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|KeyTy
operator|,
name|typename
name|DataTy
operator|,
name|bool
name|ExternalLock
operator|,
name|typename
name|HashFuncTy
operator|,
name|typename
name|EqualFuncTy
operator|>
name|void
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|resize
argument_list|()
block|{
if|if
condition|(
operator|!
name|ExternalLock
condition|)
name|Mutex
operator|.
name|CheckLocked
argument_list|()
expr_stmt|;
name|size_t
name|OldCapacity
operator|=
name|Capacity
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|HashEntry
modifier|*
modifier|*
name|OldTable
init|=
name|Table
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|Capacity
operator|*=
literal|2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Table
operator|=
operator|(
name|HashEntry
operator|*
operator|*
operator|)
name|InternalAlloc
argument_list|(
name|Capacity
operator|*
sizeof|sizeof
argument_list|(
name|HashEntry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|internal_memset
argument_list|(
name|Table
argument_list|,
literal|0
argument_list|,
name|Capacity
operator|*
sizeof|sizeof
argument_list|(
name|HashEntry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Re-hash
end_comment

begin_for
for|for
control|(
name|u32
name|i
init|=
literal|0
init|;
name|i
operator|<
name|OldCapacity
condition|;
operator|++
name|i
control|)
block|{
name|HashEntry
modifier|*
name|OldEntry
init|=
name|OldTable
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|OldEntry
operator|!=
name|nullptr
condition|)
block|{
name|HashEntry
modifier|*
name|Next
init|=
name|OldEntry
operator|->
name|Next
decl_stmt|;
name|size_t
name|Hash
init|=
name|HashFunc
argument_list|(
name|OldEntry
operator|->
name|Key
argument_list|)
operator|%
name|Capacity
decl_stmt|;
name|OldEntry
operator|->
name|Next
operator|=
name|Table
index|[
name|Hash
index|]
expr_stmt|;
name|Table
index|[
name|Hash
index|]
operator|=
name|OldEntry
expr_stmt|;
name|OldEntry
operator|=
name|Next
expr_stmt|;
block|}
block|}
end_for

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|KeyTy
operator|,
name|typename
name|DataTy
operator|,
name|bool
name|ExternalLock
operator|,
name|typename
name|HashFuncTy
operator|,
name|typename
name|EqualFuncTy
operator|>
name|bool
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|add
argument_list|(
argument|const KeyTy&Key
argument_list|,
argument|const DataTy&Payload
argument_list|)
block|{
if|if
condition|(
operator|!
name|ExternalLock
condition|)
name|Mutex
operator|.
name|Lock
argument_list|()
expr_stmt|;
name|bool
name|Exists
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|size_t
name|Hash
init|=
name|HashFunc
argument_list|(
name|Key
argument_list|)
operator|%
name|Capacity
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HashEntry
modifier|*
name|Entry
init|=
name|Table
index|[
name|Hash
index|]
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
init|;
name|Entry
operator|!=
name|nullptr
condition|;
name|Entry
operator|=
name|Entry
operator|->
name|Next
control|)
block|{
if|if
condition|(
name|EqualFunc
argument_list|(
name|Entry
operator|->
name|Key
argument_list|,
name|Key
argument_list|)
condition|)
block|{
name|Exists
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
end_for

begin_if
if|if
condition|(
operator|!
name|Exists
condition|)
block|{
name|Entries
operator|++
expr_stmt|;
if|if
condition|(
name|Entries
operator|*
literal|100
operator|>=
name|Capacity
operator|*
name|ResizeFactor
condition|)
block|{
name|resize
argument_list|()
expr_stmt|;
name|Hash
operator|=
name|HashFunc
argument_list|(
name|Key
argument_list|)
operator|%
name|Capacity
expr_stmt|;
block|}
name|HashEntry
modifier|*
name|Add
init|=
operator|(
name|HashEntry
operator|*
operator|)
name|InternalAlloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|Add
argument_list|)
argument_list|)
decl_stmt|;
name|Add
operator|->
name|Key
operator|=
name|Key
expr_stmt|;
name|Add
operator|->
name|Payload
operator|=
name|Payload
expr_stmt|;
name|Add
operator|->
name|Next
operator|=
name|Table
index|[
name|Hash
index|]
expr_stmt|;
name|Table
index|[
name|Hash
index|]
operator|=
name|Add
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|ExternalLock
condition|)
name|Mutex
operator|.
name|Unlock
argument_list|()
expr_stmt|;
end_if

begin_return
return|return
operator|!
name|Exists
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|KeyTy
operator|,
name|typename
name|DataTy
operator|,
name|bool
name|ExternalLock
operator|,
name|typename
name|HashFuncTy
operator|,
name|typename
name|EqualFuncTy
operator|>
name|bool
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|remove
argument_list|(
argument|const KeyTy&Key
argument_list|)
block|{
if|if
condition|(
operator|!
name|ExternalLock
condition|)
name|Mutex
operator|.
name|Lock
argument_list|()
expr_stmt|;
name|bool
name|Found
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|size_t
name|Hash
init|=
name|HashFunc
argument_list|(
name|Key
argument_list|)
operator|%
name|Capacity
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HashEntry
modifier|*
name|Entry
init|=
name|Table
index|[
name|Hash
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HashEntry
modifier|*
name|Prev
init|=
name|nullptr
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
init|;
name|Entry
operator|!=
name|nullptr
condition|;
name|Prev
operator|=
name|Entry
operator|,
name|Entry
operator|=
name|Entry
operator|->
name|Next
control|)
block|{
if|if
condition|(
name|EqualFunc
argument_list|(
name|Entry
operator|->
name|Key
argument_list|,
name|Key
argument_list|)
condition|)
block|{
name|Found
operator|=
name|true
expr_stmt|;
name|Entries
operator|--
expr_stmt|;
if|if
condition|(
name|Prev
operator|==
name|nullptr
condition|)
name|Table
index|[
name|Hash
index|]
operator|=
name|Entry
operator|->
name|Next
expr_stmt|;
else|else
name|Prev
operator|->
name|Next
operator|=
name|Entry
operator|->
name|Next
expr_stmt|;
name|Entry
operator|->
name|Payload
operator|.
expr|~
name|DataTy
argument_list|()
expr_stmt|;
name|InternalFree
argument_list|(
name|Entry
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_for

begin_if
if|if
condition|(
operator|!
name|ExternalLock
condition|)
name|Mutex
operator|.
name|Unlock
argument_list|()
expr_stmt|;
end_if

begin_return
return|return
name|Found
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|KeyTy
operator|,
name|typename
name|DataTy
operator|,
name|bool
name|ExternalLock
operator|,
name|typename
name|HashFuncTy
operator|,
name|typename
name|EqualFuncTy
operator|>
name|void
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|lock
argument_list|()
block|{
name|Mutex
operator|.
name|Lock
argument_list|()
block|; }
name|template
operator|<
name|typename
name|KeyTy
operator|,
name|typename
name|DataTy
operator|,
name|bool
name|ExternalLock
operator|,
name|typename
name|HashFuncTy
operator|,
name|typename
name|EqualFuncTy
operator|>
name|void
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|unlock
argument_list|()
block|{
name|Mutex
operator|.
name|Unlock
argument_list|()
block|; }
comment|//===----------------------------------------------------------------------===//
comment|// Iterator implementation
comment|//===----------------------------------------------------------------------===//
name|template
operator|<
name|typename
name|KeyTy
operator|,
name|typename
name|DataTy
operator|,
name|bool
name|ExternalLock
operator|,
name|typename
name|HashFuncTy
operator|,
name|typename
name|EqualFuncTy
operator|>
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|iterator
operator|::
name|iterator
argument_list|(
name|HashTable
operator|<
name|KeyTy
argument_list|,
name|DataTy
argument_list|,
name|ExternalLock
argument_list|,
name|HashFuncTy
argument_list|,
name|EqualFuncTy
operator|>
operator|*
name|Table
argument_list|)
operator|:
name|Table
argument_list|(
name|Table
argument_list|)
operator|,
name|Idx
argument_list|(
operator|-
literal|1
argument_list|)
operator|,
name|Entry
argument_list|(
argument|nullptr
argument_list|)
block|{
name|operator
operator|++
operator|(
operator|)
block|; }
name|template
operator|<
name|typename
name|KeyTy
operator|,
name|typename
name|DataTy
operator|,
name|bool
name|ExternalLock
operator|,
name|typename
name|HashFuncTy
operator|,
name|typename
name|EqualFuncTy
operator|>
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|iterator
operator|::
name|iterator
argument_list|(
argument|HashTable<KeyTy
argument_list|,
argument|DataTy
argument_list|,
argument|ExternalLock
argument_list|,
argument|HashFuncTy
argument_list|,
argument|EqualFuncTy> *Table
argument_list|,
argument|int Idx
argument_list|)
operator|:
name|Table
argument_list|(
name|Table
argument_list|)
operator|,
name|Idx
argument_list|(
name|Idx
argument_list|)
operator|,
name|Entry
argument_list|(
argument|nullptr
argument_list|)
block|{
name|CHECK
argument_list|(
name|Idx
operator|>=
operator|(
name|int
operator|)
name|Table
operator|->
name|Capacity
argument_list|)
block|;
comment|// Only used to create end().
block|}
name|template
operator|<
name|typename
name|KeyTy
operator|,
name|typename
name|DataTy
operator|,
name|bool
name|ExternalLock
operator|,
name|typename
name|HashFuncTy
operator|,
name|typename
name|EqualFuncTy
operator|>
name|typename
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|HashPair
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|iterator
operator|::
name|operator
operator|*
operator|(
operator|)
block|{
name|CHECK
argument_list|(
name|Idx
operator|>=
literal|0
operator|&&
name|Idx
operator|<
operator|(
name|int
operator|)
name|Table
operator|->
name|Capacity
argument_list|)
block|;
name|CHECK
argument_list|(
name|Entry
operator|!=
name|nullptr
argument_list|)
block|;
return|return
name|HashPair
argument_list|(
name|Entry
operator|->
name|Key
argument_list|,
name|Entry
operator|->
name|Payload
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|KeyTy
operator|,
name|typename
name|DataTy
operator|,
name|bool
name|ExternalLock
operator|,
name|typename
name|HashFuncTy
operator|,
name|typename
name|EqualFuncTy
operator|>
name|typename
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|iterator
operator|&
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|iterator
operator|::
name|operator
operator|++
operator|(
operator|)
block|{
if|if
condition|(
name|Entry
operator|!=
name|nullptr
condition|)
name|Entry
operator|=
name|Entry
operator|->
name|Next
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|Entry
operator|==
name|nullptr
condition|)
block|{
operator|++
name|Idx
expr_stmt|;
if|if
condition|(
name|Idx
operator|>=
operator|(
name|int
operator|)
name|Table
operator|->
name|Capacity
condition|)
break|break;
comment|// At end().
name|Entry
operator|=
name|Table
operator|->
name|Table
index|[
name|Idx
index|]
expr_stmt|;
block|}
end_while

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|KeyTy
operator|,
name|typename
name|DataTy
operator|,
name|bool
name|ExternalLock
operator|,
name|typename
name|HashFuncTy
operator|,
name|typename
name|EqualFuncTy
operator|>
name|typename
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|iterator
operator|&
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|iterator
operator|::
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|iterator
name|Temp
argument_list|(
operator|*
name|this
argument_list|)
block|;
name|operator
operator|++
operator|(
operator|)
block|;
return|return
name|Temp
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|KeyTy
operator|,
name|typename
name|DataTy
operator|,
name|bool
name|ExternalLock
operator|,
name|typename
name|HashFuncTy
operator|,
name|typename
name|EqualFuncTy
operator|>
name|bool
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|iterator
operator|::
name|operator
operator|==
operator|(
specifier|const
name|iterator
operator|&
name|Cmp
operator|)
specifier|const
block|{
return|return
name|Cmp
operator|.
name|Table
operator|==
name|Table
operator|&&
name|Cmp
operator|.
name|Idx
operator|==
name|Idx
operator|&&
name|Cmp
operator|.
name|Entry
operator|==
name|Entry
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|KeyTy
operator|,
name|typename
name|DataTy
operator|,
name|bool
name|ExternalLock
operator|,
name|typename
name|HashFuncTy
operator|,
name|typename
name|EqualFuncTy
operator|>
name|bool
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|iterator
operator|::
name|operator
operator|!=
operator|(
specifier|const
name|iterator
operator|&
name|Cmp
operator|)
specifier|const
block|{
return|return
name|Cmp
operator|.
name|Table
operator|!=
name|Table
operator|||
name|Cmp
operator|.
name|Idx
operator|!=
name|Idx
operator|||
name|Cmp
operator|.
name|Entry
operator|!=
name|Entry
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|KeyTy
operator|,
name|typename
name|DataTy
operator|,
name|bool
name|ExternalLock
operator|,
name|typename
name|HashFuncTy
operator|,
name|typename
name|EqualFuncTy
operator|>
name|typename
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|iterator
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|begin
argument_list|()
block|{
return|return
name|iterator
argument_list|(
name|this
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|KeyTy
operator|,
name|typename
name|DataTy
operator|,
name|bool
name|ExternalLock
operator|,
name|typename
name|HashFuncTy
operator|,
name|typename
name|EqualFuncTy
operator|>
name|typename
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|iterator
name|HashTable
operator|<
name|KeyTy
operator|,
name|DataTy
operator|,
name|ExternalLock
operator|,
name|HashFuncTy
operator|,
name|EqualFuncTy
operator|>
operator|::
name|end
argument_list|()
block|{
return|return
name|iterator
argument_list|(
name|this
argument_list|,
name|Capacity
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// namespace __esan
end_comment

end_unit

