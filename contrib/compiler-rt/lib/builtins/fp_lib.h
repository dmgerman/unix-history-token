begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- lib/fp_lib.h - Floating-point utilities -------------------*- C -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is dual licensed under the MIT and the University of Illinois Open
end_comment

begin_comment
comment|// Source Licenses. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is a configuration header for soft-float routines in compiler-rt.
end_comment

begin_comment
comment|// This file does not provide any part of the compiler-rt interface, but defines
end_comment

begin_comment
comment|// many useful constants and utility routines that are used in the
end_comment

begin_comment
comment|// implementation of the soft-float routines in compiler-rt.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Assumes that float, double and long double correspond to the IEEE-754
end_comment

begin_comment
comment|// binary32, binary64 and binary 128 types, respectively, and that integer
end_comment

begin_comment
comment|// endianness matches floating point endianness on the target platform.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FP_LIB_HEADER
end_ifndef

begin_define
define|#
directive|define
name|FP_LIB_HEADER
end_define

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|"int_lib.h"
end_include

begin_comment
comment|// x86_64 FreeBSD prior v9.3 define fixed-width types incorrectly in
end_comment

begin_comment
comment|// 32-bit mode.
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|903000
end_if

begin_comment
comment|// v9.3
end_comment

begin_define
define|#
directive|define
name|uint64_t
value|unsigned long long
end_define

begin_define
define|#
directive|define
name|int64_t
value|long long
end_define

begin_undef
undef|#
directive|undef
name|UINT64_C
end_undef

begin_define
define|#
directive|define
name|UINT64_C
parameter_list|(
name|c
parameter_list|)
value|(c ## ULL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|SINGLE_PRECISION
end_if

begin_typedef
typedef|typedef
name|uint32_t
name|rep_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int32_t
name|srep_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|float
name|fp_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|REP_C
value|UINT32_C
end_define

begin_define
define|#
directive|define
name|significandBits
value|23
end_define

begin_function
specifier|static
name|__inline
name|int
name|rep_clz
parameter_list|(
name|rep_t
name|a
parameter_list|)
block|{
return|return
name|__builtin_clz
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// 32x32 --> 64 bit multiply
end_comment

begin_function
specifier|static
name|__inline
name|void
name|wideMultiply
parameter_list|(
name|rep_t
name|a
parameter_list|,
name|rep_t
name|b
parameter_list|,
name|rep_t
modifier|*
name|hi
parameter_list|,
name|rep_t
modifier|*
name|lo
parameter_list|)
block|{
specifier|const
name|uint64_t
name|product
init|=
operator|(
name|uint64_t
operator|)
name|a
operator|*
name|b
decl_stmt|;
operator|*
name|hi
operator|=
name|product
operator|>>
literal|32
expr_stmt|;
operator|*
name|lo
operator|=
name|product
expr_stmt|;
block|}
end_function

begin_function_decl
name|COMPILER_RT_ABI
name|fp_t
name|__addsf3
parameter_list|(
name|fp_t
name|a
parameter_list|,
name|fp_t
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_elif
elif|#
directive|elif
name|defined
name|DOUBLE_PRECISION
end_elif

begin_typedef
typedef|typedef
name|uint64_t
name|rep_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int64_t
name|srep_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|double
name|fp_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|REP_C
value|UINT64_C
end_define

begin_define
define|#
directive|define
name|significandBits
value|52
end_define

begin_function
specifier|static
name|__inline
name|int
name|rep_clz
parameter_list|(
name|rep_t
name|a
parameter_list|)
block|{
if|#
directive|if
name|defined
name|__LP64__
return|return
name|__builtin_clzl
argument_list|(
name|a
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
name|a
operator|&
name|REP_C
argument_list|(
literal|0xffffffff00000000
argument_list|)
condition|)
return|return
name|__builtin_clz
argument_list|(
name|a
operator|>>
literal|32
argument_list|)
return|;
else|else
return|return
literal|32
operator|+
name|__builtin_clz
argument_list|(
name|a
operator|&
name|REP_C
argument_list|(
literal|0xffffffff
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_define
define|#
directive|define
name|loWord
parameter_list|(
name|a
parameter_list|)
value|(a& 0xffffffffU)
end_define

begin_define
define|#
directive|define
name|hiWord
parameter_list|(
name|a
parameter_list|)
value|(a>> 32)
end_define

begin_comment
comment|// 64x64 -> 128 wide multiply for platforms that don't have such an operation;
end_comment

begin_comment
comment|// many 64-bit platforms have this operation, but they tend to have hardware
end_comment

begin_comment
comment|// floating-point, so we don't bother with a special case for them here.
end_comment

begin_function
specifier|static
name|__inline
name|void
name|wideMultiply
parameter_list|(
name|rep_t
name|a
parameter_list|,
name|rep_t
name|b
parameter_list|,
name|rep_t
modifier|*
name|hi
parameter_list|,
name|rep_t
modifier|*
name|lo
parameter_list|)
block|{
comment|// Each of the component 32x32 -> 64 products
specifier|const
name|uint64_t
name|plolo
init|=
name|loWord
argument_list|(
name|a
argument_list|)
operator|*
name|loWord
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|uint64_t
name|plohi
init|=
name|loWord
argument_list|(
name|a
argument_list|)
operator|*
name|hiWord
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|uint64_t
name|philo
init|=
name|hiWord
argument_list|(
name|a
argument_list|)
operator|*
name|loWord
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|uint64_t
name|phihi
init|=
name|hiWord
argument_list|(
name|a
argument_list|)
operator|*
name|hiWord
argument_list|(
name|b
argument_list|)
decl_stmt|;
comment|// Sum terms that contribute to lo in a way that allows us to get the carry
specifier|const
name|uint64_t
name|r0
init|=
name|loWord
argument_list|(
name|plolo
argument_list|)
decl_stmt|;
specifier|const
name|uint64_t
name|r1
init|=
name|hiWord
argument_list|(
name|plolo
argument_list|)
operator|+
name|loWord
argument_list|(
name|plohi
argument_list|)
operator|+
name|loWord
argument_list|(
name|philo
argument_list|)
decl_stmt|;
operator|*
name|lo
operator|=
name|r0
operator|+
operator|(
name|r1
operator|<<
literal|32
operator|)
expr_stmt|;
comment|// Sum terms contributing to hi with the carry from lo
operator|*
name|hi
operator|=
name|hiWord
argument_list|(
name|plohi
argument_list|)
operator|+
name|hiWord
argument_list|(
name|philo
argument_list|)
operator|+
name|hiWord
argument_list|(
name|r1
argument_list|)
operator|+
name|phihi
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|loWord
end_undef

begin_undef
undef|#
directive|undef
name|hiWord
end_undef

begin_function_decl
name|COMPILER_RT_ABI
name|fp_t
name|__adddf3
parameter_list|(
name|fp_t
name|a
parameter_list|,
name|fp_t
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_elif
elif|#
directive|elif
name|defined
name|QUAD_PRECISION
end_elif

begin_if
if|#
directive|if
name|__LDBL_MANT_DIG__
operator|==
literal|113
end_if

begin_define
define|#
directive|define
name|CRT_LDBL_128BIT
end_define

begin_typedef
typedef|typedef
name|__uint128_t
name|rep_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|__int128_t
name|srep_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|long
name|double
name|fp_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|REP_C
value|(__uint128_t)
end_define

begin_comment
comment|// Note: Since there is no explicit way to tell compiler the constant is a
end_comment

begin_comment
comment|// 128-bit integer, we let the constant be casted to 128-bit integer
end_comment

begin_define
define|#
directive|define
name|significandBits
value|112
end_define

begin_function
specifier|static
name|__inline
name|int
name|rep_clz
parameter_list|(
name|rep_t
name|a
parameter_list|)
block|{
specifier|const
union|union
block|{
name|__uint128_t
name|ll
decl_stmt|;
if|#
directive|if
name|_YUGA_BIG_ENDIAN
struct|struct
block|{
name|uint64_t
name|high
decl_stmt|,
name|low
decl_stmt|;
block|}
name|s
struct|;
else|#
directive|else
struct|struct
block|{
name|uint64_t
name|low
decl_stmt|,
name|high
decl_stmt|;
block|}
name|s
struct|;
endif|#
directive|endif
block|}
name|uu
init|=
block|{
operator|.
name|ll
operator|=
name|a
block|}
union|;
name|uint64_t
name|word
decl_stmt|;
name|uint64_t
name|add
decl_stmt|;
if|if
condition|(
name|uu
operator|.
name|s
operator|.
name|high
condition|)
block|{
name|word
operator|=
name|uu
operator|.
name|s
operator|.
name|high
expr_stmt|;
name|add
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|word
operator|=
name|uu
operator|.
name|s
operator|.
name|low
expr_stmt|;
name|add
operator|=
literal|64
expr_stmt|;
block|}
return|return
name|__builtin_clzll
argument_list|(
name|word
argument_list|)
operator|+
name|add
return|;
block|}
end_function

begin_define
define|#
directive|define
name|Word_LoMask
value|UINT64_C(0x00000000ffffffff)
end_define

begin_define
define|#
directive|define
name|Word_HiMask
value|UINT64_C(0xffffffff00000000)
end_define

begin_define
define|#
directive|define
name|Word_FullMask
value|UINT64_C(0xffffffffffffffff)
end_define

begin_define
define|#
directive|define
name|Word_1
parameter_list|(
name|a
parameter_list|)
value|(uint64_t)((a>> 96)& Word_LoMask)
end_define

begin_define
define|#
directive|define
name|Word_2
parameter_list|(
name|a
parameter_list|)
value|(uint64_t)((a>> 64)& Word_LoMask)
end_define

begin_define
define|#
directive|define
name|Word_3
parameter_list|(
name|a
parameter_list|)
value|(uint64_t)((a>> 32)& Word_LoMask)
end_define

begin_define
define|#
directive|define
name|Word_4
parameter_list|(
name|a
parameter_list|)
value|(uint64_t)(a& Word_LoMask)
end_define

begin_comment
comment|// 128x128 -> 256 wide multiply for platforms that don't have such an operation;
end_comment

begin_comment
comment|// many 64-bit platforms have this operation, but they tend to have hardware
end_comment

begin_comment
comment|// floating-point, so we don't bother with a special case for them here.
end_comment

begin_function
specifier|static
name|__inline
name|void
name|wideMultiply
parameter_list|(
name|rep_t
name|a
parameter_list|,
name|rep_t
name|b
parameter_list|,
name|rep_t
modifier|*
name|hi
parameter_list|,
name|rep_t
modifier|*
name|lo
parameter_list|)
block|{
specifier|const
name|uint64_t
name|product11
init|=
name|Word_1
argument_list|(
name|a
argument_list|)
operator|*
name|Word_1
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|uint64_t
name|product12
init|=
name|Word_1
argument_list|(
name|a
argument_list|)
operator|*
name|Word_2
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|uint64_t
name|product13
init|=
name|Word_1
argument_list|(
name|a
argument_list|)
operator|*
name|Word_3
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|uint64_t
name|product14
init|=
name|Word_1
argument_list|(
name|a
argument_list|)
operator|*
name|Word_4
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|uint64_t
name|product21
init|=
name|Word_2
argument_list|(
name|a
argument_list|)
operator|*
name|Word_1
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|uint64_t
name|product22
init|=
name|Word_2
argument_list|(
name|a
argument_list|)
operator|*
name|Word_2
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|uint64_t
name|product23
init|=
name|Word_2
argument_list|(
name|a
argument_list|)
operator|*
name|Word_3
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|uint64_t
name|product24
init|=
name|Word_2
argument_list|(
name|a
argument_list|)
operator|*
name|Word_4
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|uint64_t
name|product31
init|=
name|Word_3
argument_list|(
name|a
argument_list|)
operator|*
name|Word_1
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|uint64_t
name|product32
init|=
name|Word_3
argument_list|(
name|a
argument_list|)
operator|*
name|Word_2
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|uint64_t
name|product33
init|=
name|Word_3
argument_list|(
name|a
argument_list|)
operator|*
name|Word_3
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|uint64_t
name|product34
init|=
name|Word_3
argument_list|(
name|a
argument_list|)
operator|*
name|Word_4
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|uint64_t
name|product41
init|=
name|Word_4
argument_list|(
name|a
argument_list|)
operator|*
name|Word_1
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|uint64_t
name|product42
init|=
name|Word_4
argument_list|(
name|a
argument_list|)
operator|*
name|Word_2
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|uint64_t
name|product43
init|=
name|Word_4
argument_list|(
name|a
argument_list|)
operator|*
name|Word_3
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|uint64_t
name|product44
init|=
name|Word_4
argument_list|(
name|a
argument_list|)
operator|*
name|Word_4
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|__uint128_t
name|sum0
init|=
operator|(
name|__uint128_t
operator|)
name|product44
decl_stmt|;
specifier|const
name|__uint128_t
name|sum1
init|=
operator|(
name|__uint128_t
operator|)
name|product34
operator|+
operator|(
name|__uint128_t
operator|)
name|product43
decl_stmt|;
specifier|const
name|__uint128_t
name|sum2
init|=
operator|(
name|__uint128_t
operator|)
name|product24
operator|+
operator|(
name|__uint128_t
operator|)
name|product33
operator|+
operator|(
name|__uint128_t
operator|)
name|product42
decl_stmt|;
specifier|const
name|__uint128_t
name|sum3
init|=
operator|(
name|__uint128_t
operator|)
name|product14
operator|+
operator|(
name|__uint128_t
operator|)
name|product23
operator|+
operator|(
name|__uint128_t
operator|)
name|product32
operator|+
operator|(
name|__uint128_t
operator|)
name|product41
decl_stmt|;
specifier|const
name|__uint128_t
name|sum4
init|=
operator|(
name|__uint128_t
operator|)
name|product13
operator|+
operator|(
name|__uint128_t
operator|)
name|product22
operator|+
operator|(
name|__uint128_t
operator|)
name|product31
decl_stmt|;
specifier|const
name|__uint128_t
name|sum5
init|=
operator|(
name|__uint128_t
operator|)
name|product12
operator|+
operator|(
name|__uint128_t
operator|)
name|product21
decl_stmt|;
specifier|const
name|__uint128_t
name|sum6
init|=
operator|(
name|__uint128_t
operator|)
name|product11
decl_stmt|;
specifier|const
name|__uint128_t
name|r0
init|=
operator|(
name|sum0
operator|&
name|Word_FullMask
operator|)
operator|+
operator|(
operator|(
name|sum1
operator|&
name|Word_LoMask
operator|)
operator|<<
literal|32
operator|)
decl_stmt|;
specifier|const
name|__uint128_t
name|r1
init|=
operator|(
name|sum0
operator|>>
literal|64
operator|)
operator|+
operator|(
operator|(
name|sum1
operator|>>
literal|32
operator|)
operator|&
name|Word_FullMask
operator|)
operator|+
operator|(
name|sum2
operator|&
name|Word_FullMask
operator|)
operator|+
operator|(
operator|(
name|sum3
operator|<<
literal|32
operator|)
operator|&
name|Word_HiMask
operator|)
decl_stmt|;
operator|*
name|lo
operator|=
name|r0
operator|+
operator|(
name|r1
operator|<<
literal|64
operator|)
expr_stmt|;
operator|*
name|hi
operator|=
operator|(
name|r1
operator|>>
literal|64
operator|)
operator|+
operator|(
name|sum1
operator|>>
literal|96
operator|)
operator|+
operator|(
name|sum2
operator|>>
literal|64
operator|)
operator|+
operator|(
name|sum3
operator|>>
literal|32
operator|)
operator|+
name|sum4
operator|+
operator|(
name|sum5
operator|<<
literal|32
operator|)
operator|+
operator|(
name|sum6
operator|<<
literal|64
operator|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|Word_1
end_undef

begin_undef
undef|#
directive|undef
name|Word_2
end_undef

begin_undef
undef|#
directive|undef
name|Word_3
end_undef

begin_undef
undef|#
directive|undef
name|Word_4
end_undef

begin_undef
undef|#
directive|undef
name|Word_HiMask
end_undef

begin_undef
undef|#
directive|undef
name|Word_LoMask
end_undef

begin_undef
undef|#
directive|undef
name|Word_FullMask
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// __LDBL_MANT_DIG__ == 113
end_comment

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|SINGLE_PRECISION, DOUBLE_PRECISION or QUAD_PRECISION must be defined.
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SINGLE_PRECISION
argument_list|)
operator|||
name|defined
argument_list|(
name|DOUBLE_PRECISION
argument_list|)
operator|||
name|defined
argument_list|(
name|CRT_LDBL_128BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|typeWidth
value|(sizeof(rep_t)*CHAR_BIT)
end_define

begin_define
define|#
directive|define
name|exponentBits
value|(typeWidth - significandBits - 1)
end_define

begin_define
define|#
directive|define
name|maxExponent
value|((1<< exponentBits) - 1)
end_define

begin_define
define|#
directive|define
name|exponentBias
value|(maxExponent>> 1)
end_define

begin_define
define|#
directive|define
name|implicitBit
value|(REP_C(1)<< significandBits)
end_define

begin_define
define|#
directive|define
name|significandMask
value|(implicitBit - 1U)
end_define

begin_define
define|#
directive|define
name|signBit
value|(REP_C(1)<< (significandBits + exponentBits))
end_define

begin_define
define|#
directive|define
name|absMask
value|(signBit - 1U)
end_define

begin_define
define|#
directive|define
name|exponentMask
value|(absMask ^ significandMask)
end_define

begin_define
define|#
directive|define
name|oneRep
value|((rep_t)exponentBias<< significandBits)
end_define

begin_define
define|#
directive|define
name|infRep
value|exponentMask
end_define

begin_define
define|#
directive|define
name|quietBit
value|(implicitBit>> 1)
end_define

begin_define
define|#
directive|define
name|qnanRep
value|(exponentMask | quietBit)
end_define

begin_function
specifier|static
name|__inline
name|rep_t
name|toRep
parameter_list|(
name|fp_t
name|x
parameter_list|)
block|{
specifier|const
union|union
block|{
name|fp_t
name|f
decl_stmt|;
name|rep_t
name|i
decl_stmt|;
block|}
name|rep
init|=
block|{
operator|.
name|f
operator|=
name|x
block|}
union|;
return|return
name|rep
operator|.
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|fp_t
name|fromRep
parameter_list|(
name|rep_t
name|x
parameter_list|)
block|{
specifier|const
union|union
block|{
name|fp_t
name|f
decl_stmt|;
name|rep_t
name|i
decl_stmt|;
block|}
name|rep
init|=
block|{
operator|.
name|i
operator|=
name|x
block|}
union|;
return|return
name|rep
operator|.
name|f
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|normalize
parameter_list|(
name|rep_t
modifier|*
name|significand
parameter_list|)
block|{
specifier|const
name|int
name|shift
init|=
name|rep_clz
argument_list|(
operator|*
name|significand
argument_list|)
operator|-
name|rep_clz
argument_list|(
name|implicitBit
argument_list|)
decl_stmt|;
operator|*
name|significand
operator|<<=
name|shift
expr_stmt|;
return|return
literal|1
operator|-
name|shift
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|wideLeftShift
parameter_list|(
name|rep_t
modifier|*
name|hi
parameter_list|,
name|rep_t
modifier|*
name|lo
parameter_list|,
name|int
name|count
parameter_list|)
block|{
operator|*
name|hi
operator|=
operator|*
name|hi
operator|<<
name|count
operator||
operator|*
name|lo
operator|>>
operator|(
name|typeWidth
operator|-
name|count
operator|)
expr_stmt|;
operator|*
name|lo
operator|=
operator|*
name|lo
operator|<<
name|count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|wideRightShiftWithSticky
parameter_list|(
name|rep_t
modifier|*
name|hi
parameter_list|,
name|rep_t
modifier|*
name|lo
parameter_list|,
name|unsigned
name|int
name|count
parameter_list|)
block|{
if|if
condition|(
name|count
operator|<
name|typeWidth
condition|)
block|{
specifier|const
name|bool
name|sticky
init|=
operator|*
name|lo
operator|<<
operator|(
name|typeWidth
operator|-
name|count
operator|)
decl_stmt|;
operator|*
name|lo
operator|=
operator|*
name|hi
operator|<<
operator|(
name|typeWidth
operator|-
name|count
operator|)
operator||
operator|*
name|lo
operator|>>
name|count
operator||
name|sticky
expr_stmt|;
operator|*
name|hi
operator|=
operator|*
name|hi
operator|>>
name|count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|<
literal|2
operator|*
name|typeWidth
condition|)
block|{
specifier|const
name|bool
name|sticky
init|=
operator|*
name|hi
operator|<<
operator|(
literal|2
operator|*
name|typeWidth
operator|-
name|count
operator|)
operator||
operator|*
name|lo
decl_stmt|;
operator|*
name|lo
operator|=
operator|*
name|hi
operator|>>
operator|(
name|count
operator|-
name|typeWidth
operator|)
operator||
name|sticky
expr_stmt|;
operator|*
name|hi
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|bool
name|sticky
init|=
operator|*
name|hi
operator||
operator|*
name|lo
decl_stmt|;
operator|*
name|lo
operator|=
name|sticky
expr_stmt|;
operator|*
name|hi
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// FP_LIB_HEADER
end_comment

end_unit

