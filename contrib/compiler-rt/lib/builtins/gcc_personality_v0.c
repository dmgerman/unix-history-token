begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ===-- gcc_personality_v0.c - Implement __gcc_personality_v0 -------------===  *  *      	       The LLVM Compiler Infrastructure  *  * This file is dual licensed under the MIT and the University of Illinois Open  * Source Licenses. See LICENSE.TXT for details.  *  * ===----------------------------------------------------------------------===  *  */
end_comment

begin_include
include|#
directive|include
file|"int_lib.h"
end_include

begin_include
include|#
directive|include
file|<unwind.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__arm__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__ARM_DWARF_EH__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__USING_SJLJ_EXCEPTIONS__
argument_list|)
end_if

begin_comment
comment|/*  * When building with older compilers (e.g. clang<3.9), it is possible that we  * have a version of unwind.h which does not provide the EHABI declarations  * which are quired for the C personality to conform to the specification.  In  * order to provide forward compatibility for such compilers, we re-declare the  * necessary interfaces in the helper to permit a standalone compilation of the  * builtins (which contains the C unwinding personality for historical reasons).  */
end_comment

begin_include
include|#
directive|include
file|"unwind-ehabi-helpers.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Pointer encodings documented at:  *   http://refspecs.freestandards.org/LSB_1.3.0/gLSB/gLSB/ehframehdr.html  */
end_comment

begin_define
define|#
directive|define
name|DW_EH_PE_omit
value|0xff
end_define

begin_comment
comment|/* no data follows */
end_comment

begin_define
define|#
directive|define
name|DW_EH_PE_absptr
value|0x00
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_uleb128
value|0x01
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_udata2
value|0x02
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_udata4
value|0x03
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_udata8
value|0x04
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_sleb128
value|0x09
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_sdata2
value|0x0A
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_sdata4
value|0x0B
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_sdata8
value|0x0C
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_pcrel
value|0x10
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_textrel
value|0x20
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_datarel
value|0x30
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_funcrel
value|0x40
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_aligned
value|0x50
end_define

begin_define
define|#
directive|define
name|DW_EH_PE_indirect
value|0x80
end_define

begin_comment
comment|/* gcc extension */
end_comment

begin_comment
comment|/* read a uleb128 encoded value and advance pointer */
end_comment

begin_function
specifier|static
name|uintptr_t
name|readULEB128
parameter_list|(
specifier|const
name|uint8_t
modifier|*
modifier|*
name|data
parameter_list|)
block|{
name|uintptr_t
name|result
init|=
literal|0
decl_stmt|;
name|uintptr_t
name|shift
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|p
init|=
operator|*
name|data
decl_stmt|;
do|do
block|{
name|byte
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|result
operator||=
operator|(
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
name|byte
operator|&
literal|0x80
condition|)
do|;
operator|*
name|data
operator|=
name|p
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* read a pointer encoded value and advance pointer */
end_comment

begin_function
specifier|static
name|uintptr_t
name|readEncodedPointer
parameter_list|(
specifier|const
name|uint8_t
modifier|*
modifier|*
name|data
parameter_list|,
name|uint8_t
name|encoding
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|p
init|=
operator|*
name|data
decl_stmt|;
name|uintptr_t
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|encoding
operator|==
name|DW_EH_PE_omit
condition|)
return|return
literal|0
return|;
comment|/* first get value */
switch|switch
condition|(
name|encoding
operator|&
literal|0x0F
condition|)
block|{
case|case
name|DW_EH_PE_absptr
case|:
name|result
operator|=
operator|*
operator|(
operator|(
specifier|const
name|uintptr_t
operator|*
operator|)
name|p
operator|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_uleb128
case|:
name|result
operator|=
name|readULEB128
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_udata2
case|:
name|result
operator|=
operator|*
operator|(
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|p
operator|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_udata4
case|:
name|result
operator|=
operator|*
operator|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|p
operator|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_udata8
case|:
name|result
operator|=
operator|*
operator|(
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
name|p
operator|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_sdata2
case|:
name|result
operator|=
operator|*
operator|(
operator|(
specifier|const
name|int16_t
operator|*
operator|)
name|p
operator|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_sdata4
case|:
name|result
operator|=
operator|*
operator|(
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|p
operator|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_sdata8
case|:
name|result
operator|=
operator|*
operator|(
operator|(
specifier|const
name|int64_t
operator|*
operator|)
name|p
operator|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_sleb128
case|:
default|default:
comment|/* not supported */
name|compilerrt_abort
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* then add relative offset */
switch|switch
condition|(
name|encoding
operator|&
literal|0x70
condition|)
block|{
case|case
name|DW_EH_PE_absptr
case|:
comment|/* do nothing */
break|break;
case|case
name|DW_EH_PE_pcrel
case|:
name|result
operator|+=
call|(
name|uintptr_t
call|)
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_textrel
case|:
case|case
name|DW_EH_PE_datarel
case|:
case|case
name|DW_EH_PE_funcrel
case|:
case|case
name|DW_EH_PE_aligned
case|:
default|default:
comment|/* not supported */
name|compilerrt_abort
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* then apply indirection */
if|if
condition|(
name|encoding
operator|&
name|DW_EH_PE_indirect
condition|)
block|{
name|result
operator|=
operator|*
operator|(
operator|(
specifier|const
name|uintptr_t
operator|*
operator|)
name|result
operator|)
expr_stmt|;
block|}
operator|*
name|data
operator|=
name|p
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__arm__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__USING_SJLJ_EXCEPTIONS__
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|__ARM_DWARF_EH__
argument_list|)
end_if

begin_define
define|#
directive|define
name|USING_ARM_EHABI
value|1
end_define

begin_function_decl
name|_Unwind_Reason_Code
name|__gnu_unwind_frame
parameter_list|(
name|struct
name|_Unwind_Exception
modifier|*
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|_Unwind_Reason_Code
name|continueUnwind
parameter_list|(
name|struct
name|_Unwind_Exception
modifier|*
name|exceptionObject
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
if|#
directive|if
name|USING_ARM_EHABI
comment|/*      * On ARM EHABI the personality routine is responsible for actually      * unwinding a single stack frame before returning (ARM EHABI Sec. 6.1).      */
if|if
condition|(
name|__gnu_unwind_frame
argument_list|(
name|exceptionObject
argument_list|,
name|context
argument_list|)
operator|!=
name|_URC_OK
condition|)
return|return
name|_URC_FAILURE
return|;
endif|#
directive|endif
return|return
name|_URC_CONTINUE_UNWIND
return|;
block|}
end_function

begin_comment
comment|/*  * The C compiler makes references to __gcc_personality_v0 in  * the dwarf unwind information for translation units that use  * __attribute__((cleanup(xx))) on local variables.  * This personality routine is called by the system unwinder  * on each frame as the stack is unwound during a C++ exception  * throw through a C function compiled with -fexceptions.  */
end_comment

begin_if
if|#
directive|if
name|__USING_SJLJ_EXCEPTIONS__
end_if

begin_comment
comment|/* the setjump-longjump based exceptions personality routine has a  * different name */
end_comment

begin_decl_stmt
name|COMPILER_RT_ABI
name|_Unwind_Reason_Code
name|__gcc_personality_sj0
argument_list|(
name|int
name|version
argument_list|,
name|_Unwind_Action
name|actions
argument_list|,
name|uint64_t
name|exceptionClass
argument_list|,
expr|struct
name|_Unwind_Exception
operator|*
name|exceptionObject
argument_list|,
expr|struct
name|_Unwind_Context
operator|*
name|context
argument_list|)
elif|#
directive|elif
name|USING_ARM_EHABI
comment|/* The ARM EHABI personality routine has a different signature. */
name|COMPILER_RT_ABI
name|_Unwind_Reason_Code
name|__gcc_personality_v0
argument_list|(
name|_Unwind_State
name|state
argument_list|,
expr|struct
name|_Unwind_Exception
operator|*
name|exceptionObject
argument_list|,
expr|struct
name|_Unwind_Context
operator|*
name|context
argument_list|)
else|#
directive|else
name|COMPILER_RT_ABI
name|_Unwind_Reason_Code
name|__gcc_personality_v0
argument_list|(
name|int
name|version
argument_list|,
name|_Unwind_Action
name|actions
argument_list|,
name|uint64_t
name|exceptionClass
argument_list|,
expr|struct
name|_Unwind_Exception
operator|*
name|exceptionObject
argument_list|,
expr|struct
name|_Unwind_Context
operator|*
name|context
argument_list|)
endif|#
directive|endif
block|{
comment|/* Since C does not have catch clauses, there is nothing to do during */
comment|/* phase 1 (the search phase). */
if|#
directive|if
name|USING_ARM_EHABI
comment|/* After resuming from a cleanup we should also continue on to the next      * frame straight away. */
if|if
condition|(
operator|(
name|state
operator|&
name|_US_ACTION_MASK
operator|)
operator|!=
name|_US_UNWIND_FRAME_STARTING
condition|)
else|#
directive|else
if|if
condition|(
name|actions
operator|&
name|_UA_SEARCH_PHASE
condition|)
endif|#
directive|endif
return|return
name|continueUnwind
argument_list|(
name|exceptionObject
argument_list|,
name|context
argument_list|)
return|;
comment|/* There is nothing to do if there is no LSDA for this frame. */
specifier|const
name|uint8_t
modifier|*
name|lsda
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|_Unwind_GetLanguageSpecificData
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|lsda
operator|==
operator|(
name|uint8_t
operator|*
operator|)
literal|0
condition|)
return|return
name|continueUnwind
argument_list|(
name|exceptionObject
argument_list|,
name|context
argument_list|)
return|;
name|uintptr_t
name|pc
init|=
name|_Unwind_GetIP
argument_list|(
name|context
argument_list|)
operator|-
literal|1
decl_stmt|;
name|uintptr_t
name|funcStart
init|=
name|_Unwind_GetRegionStart
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|uintptr_t
name|pcOffset
init|=
name|pc
operator|-
name|funcStart
decl_stmt|;
comment|/* Parse LSDA header. */
name|uint8_t
name|lpStartEncoding
init|=
operator|*
name|lsda
operator|++
decl_stmt|;
if|if
condition|(
name|lpStartEncoding
operator|!=
name|DW_EH_PE_omit
condition|)
block|{
name|readEncodedPointer
argument_list|(
operator|&
name|lsda
argument_list|,
name|lpStartEncoding
argument_list|)
expr_stmt|;
block|}
name|uint8_t
name|ttypeEncoding
init|=
operator|*
name|lsda
operator|++
decl_stmt|;
if|if
condition|(
name|ttypeEncoding
operator|!=
name|DW_EH_PE_omit
condition|)
block|{
name|readULEB128
argument_list|(
operator|&
name|lsda
argument_list|)
expr_stmt|;
block|}
comment|/* Walk call-site table looking for range that includes current PC. */
name|uint8_t
name|callSiteEncoding
init|=
operator|*
name|lsda
operator|++
decl_stmt|;
name|uint32_t
name|callSiteTableLength
init|=
name|readULEB128
argument_list|(
operator|&
name|lsda
argument_list|)
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|callSiteTableStart
init|=
name|lsda
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|callSiteTableEnd
init|=
name|callSiteTableStart
operator|+
name|callSiteTableLength
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|p
init|=
name|callSiteTableStart
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|callSiteTableEnd
condition|)
block|{
name|uintptr_t
name|start
init|=
name|readEncodedPointer
argument_list|(
operator|&
name|p
argument_list|,
name|callSiteEncoding
argument_list|)
decl_stmt|;
name|uintptr_t
name|length
init|=
name|readEncodedPointer
argument_list|(
operator|&
name|p
argument_list|,
name|callSiteEncoding
argument_list|)
decl_stmt|;
name|uintptr_t
name|landingPad
init|=
name|readEncodedPointer
argument_list|(
operator|&
name|p
argument_list|,
name|callSiteEncoding
argument_list|)
decl_stmt|;
name|readULEB128
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* action value not used for C code */
if|if
condition|(
name|landingPad
operator|==
literal|0
condition|)
continue|continue;
comment|/* no landing pad for this entry */
if|if
condition|(
operator|(
name|start
operator|<=
name|pcOffset
operator|)
operator|&&
operator|(
name|pcOffset
operator|<
operator|(
name|start
operator|+
name|length
operator|)
operator|)
condition|)
block|{
comment|/* Found landing pad for the PC.              * Set Instruction Pointer to so we re-enter function               * at landing pad. The landing pad is created by the compiler              * to take two parameters in registers.              */
name|_Unwind_SetGR
argument_list|(
name|context
argument_list|,
name|__builtin_eh_return_data_regno
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|uintptr_t
operator|)
name|exceptionObject
argument_list|)
expr_stmt|;
name|_Unwind_SetGR
argument_list|(
name|context
argument_list|,
name|__builtin_eh_return_data_regno
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_Unwind_SetIP
argument_list|(
name|context
argument_list|,
operator|(
name|funcStart
operator|+
name|landingPad
operator|)
argument_list|)
expr_stmt|;
return|return
name|_URC_INSTALL_CONTEXT
return|;
block|}
block|}
comment|/* No landing pad found, continue unwinding. */
return|return
name|continueUnwind
argument_list|(
name|exceptionObject
argument_list|,
name|context
argument_list|)
return|;
block|}
end_decl_stmt

end_unit

