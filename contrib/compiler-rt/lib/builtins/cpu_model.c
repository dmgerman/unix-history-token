begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- cpu_model.c - Support for __cpu_model builtin  ------------*- C -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file is based on LLVM's lib/Support/Host.cpp.
end_comment

begin_comment
comment|//  It implements the operating system Host concept and builtin
end_comment

begin_comment
comment|//  __cpu_model for the compiler_rt library, for x86 only.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_IX86
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_X64
argument_list|)
operator|)
operator|&&
expr|\
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__clang__
argument_list|)
operator|||
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|)
end_if

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_define
define|#
directive|define
name|bool
value|int
end_define

begin_define
define|#
directive|define
name|true
value|1
end_define

begin_define
define|#
directive|define
name|false
value|0
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_include
include|#
directive|include
file|<intrin.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__has_attribute
end_ifndef

begin_define
define|#
directive|define
name|__has_attribute
parameter_list|(
name|attr
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|VendorSignatures
block|{
name|SIG_INTEL
init|=
literal|0x756e6547
comment|/* Genu */
block|,
name|SIG_AMD
init|=
literal|0x68747541
comment|/* Auth */
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ProcessorVendors
block|{
name|VENDOR_INTEL
init|=
literal|1
block|,
name|VENDOR_AMD
block|,
name|VENDOR_OTHER
block|,
name|VENDOR_MAX
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ProcessorTypes
block|{
name|INTEL_ATOM
init|=
literal|1
block|,
name|INTEL_CORE2
block|,
name|INTEL_COREI7
block|,
name|AMDFAM10H
block|,
name|AMDFAM15H
block|,
name|INTEL_i386
block|,
name|INTEL_i486
block|,
name|INTEL_PENTIUM
block|,
name|INTEL_PENTIUM_PRO
block|,
name|INTEL_PENTIUM_II
block|,
name|INTEL_PENTIUM_III
block|,
name|INTEL_PENTIUM_IV
block|,
name|INTEL_PENTIUM_M
block|,
name|INTEL_CORE_DUO
block|,
name|INTEL_XEONPHI
block|,
name|INTEL_X86_64
block|,
name|INTEL_NOCONA
block|,
name|INTEL_PRESCOTT
block|,
name|AMD_i486
block|,
name|AMDPENTIUM
block|,
name|AMDATHLON
block|,
name|AMDFAM14H
block|,
name|AMDFAM16H
block|,
name|CPU_TYPE_MAX
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ProcessorSubtypes
block|{
name|INTEL_COREI7_NEHALEM
init|=
literal|1
block|,
name|INTEL_COREI7_WESTMERE
block|,
name|INTEL_COREI7_SANDYBRIDGE
block|,
name|AMDFAM10H_BARCELONA
block|,
name|AMDFAM10H_SHANGHAI
block|,
name|AMDFAM10H_ISTANBUL
block|,
name|AMDFAM15H_BDVER1
block|,
name|AMDFAM15H_BDVER2
block|,
name|INTEL_PENTIUM_MMX
block|,
name|INTEL_CORE2_65
block|,
name|INTEL_CORE2_45
block|,
name|INTEL_COREI7_IVYBRIDGE
block|,
name|INTEL_COREI7_HASWELL
block|,
name|INTEL_COREI7_BROADWELL
block|,
name|INTEL_COREI7_SKYLAKE
block|,
name|INTEL_COREI7_SKYLAKE_AVX512
block|,
name|INTEL_ATOM_BONNELL
block|,
name|INTEL_ATOM_SILVERMONT
block|,
name|INTEL_KNIGHTS_LANDING
block|,
name|AMDPENTIUM_K6
block|,
name|AMDPENTIUM_K62
block|,
name|AMDPENTIUM_K63
block|,
name|AMDPENTIUM_GEODE
block|,
name|AMDATHLON_TBIRD
block|,
name|AMDATHLON_MP
block|,
name|AMDATHLON_XP
block|,
name|AMDATHLON_K8SSE3
block|,
name|AMDATHLON_OPTERON
block|,
name|AMDATHLON_FX
block|,
name|AMDATHLON_64
block|,
name|AMD_BTVER1
block|,
name|AMD_BTVER2
block|,
name|AMDFAM15H_BDVER3
block|,
name|AMDFAM15H_BDVER4
block|,
name|CPU_SUBTYPE_MAX
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ProcessorFeatures
block|{
name|FEATURE_CMOV
init|=
literal|0
block|,
name|FEATURE_MMX
block|,
name|FEATURE_POPCNT
block|,
name|FEATURE_SSE
block|,
name|FEATURE_SSE2
block|,
name|FEATURE_SSE3
block|,
name|FEATURE_SSSE3
block|,
name|FEATURE_SSE4_1
block|,
name|FEATURE_SSE4_2
block|,
name|FEATURE_AVX
block|,
name|FEATURE_AVX2
block|,
name|FEATURE_AVX512
block|,
name|FEATURE_AVX512SAVE
block|,
name|FEATURE_MOVBE
block|,
name|FEATURE_ADX
block|,
name|FEATURE_EM64T
block|}
enum|;
end_enum

begin_comment
comment|// The check below for i386 was copied from clang's cpuid.h (__get_cpuid_max).
end_comment

begin_comment
comment|// Check motivated by bug reports for OpenSSL crashing on CPUs without CPUID
end_comment

begin_comment
comment|// support. Consequently, for i386, the presence of CPUID is checked first
end_comment

begin_comment
comment|// via the corresponding eflags bit.
end_comment

begin_function
specifier|static
name|bool
name|isCpuIdSupported
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__clang__
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
name|int
name|__cpuid_supported
decl_stmt|;
asm|__asm__("  pushfl\n"           "  popl   %%eax\n"           "  movl   %%eax,%%ecx\n"           "  xorl   $0x00200000,%%eax\n"           "  pushl  %%eax\n"           "  popfl\n"           "  pushfl\n"           "  popl   %%eax\n"           "  movl   $0,%0\n"           "  cmpl   %%eax,%%ecx\n"           "  je     1f\n"           "  movl   $1,%0\n"           "1:"           : "=r"(__cpuid_supported)           :           : "eax", "ecx");
if|if
condition|(
operator|!
name|__cpuid_supported
condition|)
return|return
name|false
return|;
endif|#
directive|endif
return|return
name|true
return|;
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// This code is copied from lib/Support/Host.cpp.
end_comment

begin_comment
comment|// Changes to either file should be mirrored in the other.
end_comment

begin_comment
comment|/// getX86CpuIDAndInfo - Execute the specified cpuid and return the 4 values in
end_comment

begin_comment
comment|/// the specified arguments.  If we can't run cpuid on the host, return true.
end_comment

begin_function
specifier|static
name|void
name|getX86CpuIDAndInfo
parameter_list|(
name|unsigned
name|value
parameter_list|,
name|unsigned
modifier|*
name|rEAX
parameter_list|,
name|unsigned
modifier|*
name|rEBX
parameter_list|,
name|unsigned
modifier|*
name|rECX
parameter_list|,
name|unsigned
modifier|*
name|rEDX
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__clang__
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|__x86_64__
argument_list|)
comment|// gcc doesn't know cpuid would clobber ebx/rbx. Preseve it manually.
asm|__asm__("movq\t%%rbx, %%rsi\n\t"           "cpuid\n\t"           "xchgq\t%%rbx, %%rsi\n\t"           : "=a"(*rEAX), "=S"(*rEBX), "=c"(*rECX), "=d"(*rEDX)           : "a"(value));
elif|#
directive|elif
name|defined
argument_list|(
name|__i386__
argument_list|)
asm|__asm__("movl\t%%ebx, %%esi\n\t"           "cpuid\n\t"           "xchgl\t%%ebx, %%esi\n\t"           : "=a"(*rEAX), "=S"(*rEBX), "=c"(*rECX), "=d"(*rEDX)           : "a"(value));
comment|// pedantic #else returns to appease -Wunreachable-code (so we don't generate
comment|// postprocessed code that looks like "return true; return false;")
else|#
directive|else
name|assert
argument_list|(
literal|0
operator|&&
literal|"This method is defined only for x86."
argument_list|)
expr_stmt|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
comment|// The MSVC intrinsic is portable across x86 and x64.
name|int
name|registers
index|[
literal|4
index|]
decl_stmt|;
name|__cpuid
argument_list|(
name|registers
argument_list|,
name|value
argument_list|)
expr_stmt|;
operator|*
name|rEAX
operator|=
name|registers
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|rEBX
operator|=
name|registers
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|rECX
operator|=
name|registers
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|rEDX
operator|=
name|registers
index|[
literal|3
index|]
expr_stmt|;
else|#
directive|else
name|assert
argument_list|(
literal|0
operator|&&
literal|"This method is defined only for GNUC, Clang or MSVC."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/// getX86CpuIDAndInfoEx - Execute the specified cpuid with subleaf and return
end_comment

begin_comment
comment|/// the 4 values in the specified arguments.  If we can't run cpuid on the host,
end_comment

begin_comment
comment|/// return true.
end_comment

begin_function
specifier|static
name|void
name|getX86CpuIDAndInfoEx
parameter_list|(
name|unsigned
name|value
parameter_list|,
name|unsigned
name|subleaf
parameter_list|,
name|unsigned
modifier|*
name|rEAX
parameter_list|,
name|unsigned
modifier|*
name|rEBX
parameter_list|,
name|unsigned
modifier|*
name|rECX
parameter_list|,
name|unsigned
modifier|*
name|rEDX
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_X64
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__clang__
argument_list|)
comment|// gcc doesn't know cpuid would clobber ebx/rbx. Preserve it manually.
comment|// FIXME: should we save this for Clang?
asm|__asm__("movq\t%%rbx, %%rsi\n\t"           "cpuid\n\t"           "xchgq\t%%rbx, %%rsi\n\t"           : "=a"(*rEAX), "=S"(*rEBX), "=c"(*rECX), "=d"(*rEDX)           : "a"(value), "c"(subleaf));
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
name|int
name|registers
index|[
literal|4
index|]
decl_stmt|;
name|__cpuidex
argument_list|(
name|registers
argument_list|,
name|value
argument_list|,
name|subleaf
argument_list|)
expr_stmt|;
operator|*
name|rEAX
operator|=
name|registers
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|rEBX
operator|=
name|registers
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|rECX
operator|=
name|registers
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|rEDX
operator|=
name|registers
index|[
literal|3
index|]
expr_stmt|;
else|#
directive|else
name|assert
argument_list|(
literal|0
operator|&&
literal|"This method is defined only for GNUC, Clang or MSVC."
argument_list|)
expr_stmt|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_IX86
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__clang__
argument_list|)
asm|__asm__("movl\t%%ebx, %%esi\n\t"           "cpuid\n\t"           "xchgl\t%%ebx, %%esi\n\t"           : "=a"(*rEAX), "=S"(*rEBX), "=c"(*rECX), "=d"(*rEDX)           : "a"(value), "c"(subleaf));
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
asm|__asm {
asm|mov   eax,value
asm|mov   ecx,subleaf
asm|cpuid
asm|mov   esi,rEAX
asm|mov   dword ptr [esi],eax
asm|mov   esi,rEBX
asm|mov   dword ptr [esi],ebx
asm|mov   esi,rECX
asm|mov   dword ptr [esi],ecx
asm|mov   esi,rEDX
asm|mov   dword ptr [esi],edx
asm|}
else|#
directive|else
name|assert
argument_list|(
literal|0
operator|&&
literal|"This method is defined only for GNUC, Clang or MSVC."
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|assert
argument_list|(
literal|0
operator|&&
literal|"This method is defined only for x86."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|// Read control register 0 (XCR0). Used to detect features such as AVX.
end_comment

begin_function
specifier|static
name|bool
name|getX86XCR0
parameter_list|(
name|unsigned
modifier|*
name|rEAX
parameter_list|,
name|unsigned
modifier|*
name|rEDX
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__clang__
argument_list|)
comment|// Check xgetbv; this uses a .byte sequence instead of the instruction
comment|// directly because older assemblers do not include support for xgetbv and
comment|// there is no easy way to conditionally compile based on the assembler used.
asm|__asm__(".byte 0x0f, 0x01, 0xd0" : "=a"(*rEAX), "=d"(*rEDX) : "c"(0));
return|return
name|false
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_FULL_VER
argument_list|)
operator|&&
name|defined
argument_list|(
name|_XCR_XFEATURE_ENABLED_MASK
argument_list|)
name|unsigned
name|long
name|long
name|Result
init|=
name|_xgetbv
argument_list|(
name|_XCR_XFEATURE_ENABLED_MASK
argument_list|)
decl_stmt|;
operator|*
name|rEAX
operator|=
name|Result
expr_stmt|;
operator|*
name|rEDX
operator|=
name|Result
operator|>>
literal|32
expr_stmt|;
return|return
name|false
return|;
else|#
directive|else
return|return
name|true
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|detectX86FamilyModel
parameter_list|(
name|unsigned
name|EAX
parameter_list|,
name|unsigned
modifier|*
name|Family
parameter_list|,
name|unsigned
modifier|*
name|Model
parameter_list|)
block|{
operator|*
name|Family
operator|=
operator|(
name|EAX
operator|>>
literal|8
operator|)
operator|&
literal|0xf
expr_stmt|;
comment|// Bits 8 - 11
operator|*
name|Model
operator|=
operator|(
name|EAX
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
comment|// Bits 4 - 7
if|if
condition|(
operator|*
name|Family
operator|==
literal|6
operator|||
operator|*
name|Family
operator|==
literal|0xf
condition|)
block|{
if|if
condition|(
operator|*
name|Family
operator|==
literal|0xf
condition|)
comment|// Examine extended family ID if family ID is F.
operator|*
name|Family
operator|+=
operator|(
name|EAX
operator|>>
literal|20
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|// Bits 20 - 27
comment|// Examine extended model ID if family ID is 6 or F.
operator|*
name|Model
operator|+=
operator|(
operator|(
name|EAX
operator|>>
literal|16
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
expr_stmt|;
comment|// Bits 16 - 19
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|getIntelProcessorTypeAndSubtype
parameter_list|(
name|unsigned
name|int
name|Family
parameter_list|,
name|unsigned
name|int
name|Model
parameter_list|,
name|unsigned
name|int
name|Brand_id
parameter_list|,
name|unsigned
name|int
name|Features
parameter_list|,
name|unsigned
modifier|*
name|Type
parameter_list|,
name|unsigned
modifier|*
name|Subtype
parameter_list|)
block|{
if|if
condition|(
name|Brand_id
operator|!=
literal|0
condition|)
return|return;
switch|switch
condition|(
name|Family
condition|)
block|{
case|case
literal|3
case|:
operator|*
name|Type
operator|=
name|INTEL_i386
expr_stmt|;
break|break;
case|case
literal|4
case|:
switch|switch
condition|(
name|Model
condition|)
block|{
case|case
literal|0
case|:
comment|// Intel486 DX processors
case|case
literal|1
case|:
comment|// Intel486 DX processors
case|case
literal|2
case|:
comment|// Intel486 SX processors
case|case
literal|3
case|:
comment|// Intel487 processors, IntelDX2 OverDrive processors,
comment|// IntelDX2 processors
case|case
literal|4
case|:
comment|// Intel486 SL processor
case|case
literal|5
case|:
comment|// IntelSX2 processors
case|case
literal|7
case|:
comment|// Write-Back Enhanced IntelDX2 processors
case|case
literal|8
case|:
comment|// IntelDX4 OverDrive processors, IntelDX4 processors
default|default:
operator|*
name|Type
operator|=
name|INTEL_i486
expr_stmt|;
break|break;
block|}
case|case
literal|5
case|:
switch|switch
condition|(
name|Model
condition|)
block|{
case|case
literal|1
case|:
comment|// Pentium OverDrive processor for Pentium processor (60, 66),
comment|// Pentium processors (60, 66)
case|case
literal|2
case|:
comment|// Pentium OverDrive processor for Pentium processor (75, 90,
comment|// 100, 120, 133), Pentium processors (75, 90, 100, 120, 133,
comment|// 150, 166, 200)
case|case
literal|3
case|:
comment|// Pentium OverDrive processors for Intel486 processor-based
comment|// systems
operator|*
name|Type
operator|=
name|INTEL_PENTIUM
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|// Pentium OverDrive processor with MMX technology for Pentium
comment|// processor (75, 90, 100, 120, 133), Pentium processor with
comment|// MMX technology (166, 200)
operator|*
name|Type
operator|=
name|INTEL_PENTIUM
expr_stmt|;
operator|*
name|Subtype
operator|=
name|INTEL_PENTIUM_MMX
expr_stmt|;
break|break;
default|default:
operator|*
name|Type
operator|=
name|INTEL_PENTIUM
expr_stmt|;
break|break;
block|}
case|case
literal|6
case|:
switch|switch
condition|(
name|Model
condition|)
block|{
case|case
literal|0x01
case|:
comment|// Pentium Pro processor
operator|*
name|Type
operator|=
name|INTEL_PENTIUM_PRO
expr_stmt|;
break|break;
case|case
literal|0x03
case|:
comment|// Intel Pentium II OverDrive processor, Pentium II processor,
comment|// model 03
case|case
literal|0x05
case|:
comment|// Pentium II processor, model 05, Pentium II Xeon processor,
comment|// model 05, and Intel Celeron processor, model 05
case|case
literal|0x06
case|:
comment|// Celeron processor, model 06
operator|*
name|Type
operator|=
name|INTEL_PENTIUM_II
expr_stmt|;
break|break;
case|case
literal|0x07
case|:
comment|// Pentium III processor, model 07, and Pentium III Xeon
comment|// processor, model 07
case|case
literal|0x08
case|:
comment|// Pentium III processor, model 08, Pentium III Xeon processor,
comment|// model 08, and Celeron processor, model 08
case|case
literal|0x0a
case|:
comment|// Pentium III Xeon processor, model 0Ah
case|case
literal|0x0b
case|:
comment|// Pentium III processor, model 0Bh
operator|*
name|Type
operator|=
name|INTEL_PENTIUM_III
expr_stmt|;
break|break;
case|case
literal|0x09
case|:
comment|// Intel Pentium M processor, Intel Celeron M processor model 09.
case|case
literal|0x0d
case|:
comment|// Intel Pentium M processor, Intel Celeron M processor, model
comment|// 0Dh. All processors are manufactured using the 90 nm process.
case|case
literal|0x15
case|:
comment|// Intel EP80579 Integrated Processor and Intel EP80579
comment|// Integrated Processor with Intel QuickAssist Technology
operator|*
name|Type
operator|=
name|INTEL_PENTIUM_M
expr_stmt|;
break|break;
case|case
literal|0x0e
case|:
comment|// Intel Core Duo processor, Intel Core Solo processor, model
comment|// 0Eh. All processors are manufactured using the 65 nm process.
operator|*
name|Type
operator|=
name|INTEL_CORE_DUO
expr_stmt|;
break|break;
comment|// yonah
case|case
literal|0x0f
case|:
comment|// Intel Core 2 Duo processor, Intel Core 2 Duo mobile
comment|// processor, Intel Core 2 Quad processor, Intel Core 2 Quad
comment|// mobile processor, Intel Core 2 Extreme processor, Intel
comment|// Pentium Dual-Core processor, Intel Xeon processor, model
comment|// 0Fh. All processors are manufactured using the 65 nm process.
case|case
literal|0x16
case|:
comment|// Intel Celeron processor model 16h. All processors are
comment|// manufactured using the 65 nm process
operator|*
name|Type
operator|=
name|INTEL_CORE2
expr_stmt|;
comment|// "core2"
operator|*
name|Subtype
operator|=
name|INTEL_CORE2_65
expr_stmt|;
break|break;
case|case
literal|0x17
case|:
comment|// Intel Core 2 Extreme processor, Intel Xeon processor, model
comment|// 17h. All processors are manufactured using the 45 nm process.
comment|//
comment|// 45nm: Penryn , Wolfdale, Yorkfield (XE)
case|case
literal|0x1d
case|:
comment|// Intel Xeon processor MP. All processors are manufactured using
comment|// the 45 nm process.
operator|*
name|Type
operator|=
name|INTEL_CORE2
expr_stmt|;
comment|// "penryn"
operator|*
name|Subtype
operator|=
name|INTEL_CORE2_45
expr_stmt|;
break|break;
case|case
literal|0x1a
case|:
comment|// Intel Core i7 processor and Intel Xeon processor. All
comment|// processors are manufactured using the 45 nm process.
case|case
literal|0x1e
case|:
comment|// Intel(R) Core(TM) i7 CPU         870  @ 2.93GHz.
comment|// As found in a Summer 2010 model iMac.
case|case
literal|0x1f
case|:
case|case
literal|0x2e
case|:
comment|// Nehalem EX
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
comment|// "nehalem"
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_NEHALEM
expr_stmt|;
break|break;
case|case
literal|0x25
case|:
comment|// Intel Core i7, laptop version.
case|case
literal|0x2c
case|:
comment|// Intel Core i7 processor and Intel Xeon processor. All
comment|// processors are manufactured using the 32 nm process.
case|case
literal|0x2f
case|:
comment|// Westmere EX
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
comment|// "westmere"
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_WESTMERE
expr_stmt|;
break|break;
case|case
literal|0x2a
case|:
comment|// Intel Core i7 processor. All processors are manufactured
comment|// using the 32 nm process.
case|case
literal|0x2d
case|:
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
comment|//"sandybridge"
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_SANDYBRIDGE
expr_stmt|;
break|break;
case|case
literal|0x3a
case|:
case|case
literal|0x3e
case|:
comment|// Ivy Bridge EP
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
comment|// "ivybridge"
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_IVYBRIDGE
expr_stmt|;
break|break;
comment|// Haswell:
case|case
literal|0x3c
case|:
case|case
literal|0x3f
case|:
case|case
literal|0x45
case|:
case|case
literal|0x46
case|:
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
comment|// "haswell"
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_HASWELL
expr_stmt|;
break|break;
comment|// Broadwell:
case|case
literal|0x3d
case|:
case|case
literal|0x47
case|:
case|case
literal|0x4f
case|:
case|case
literal|0x56
case|:
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
comment|// "broadwell"
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_BROADWELL
expr_stmt|;
break|break;
comment|// Skylake:
case|case
literal|0x4e
case|:
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
comment|// "skylake-avx512"
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_SKYLAKE_AVX512
expr_stmt|;
break|break;
case|case
literal|0x5e
case|:
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
comment|// "skylake"
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_SKYLAKE
expr_stmt|;
break|break;
case|case
literal|0x1c
case|:
comment|// Most 45 nm Intel Atom processors
case|case
literal|0x26
case|:
comment|// 45 nm Atom Lincroft
case|case
literal|0x27
case|:
comment|// 32 nm Atom Medfield
case|case
literal|0x35
case|:
comment|// 32 nm Atom Midview
case|case
literal|0x36
case|:
comment|// 32 nm Atom Midview
operator|*
name|Type
operator|=
name|INTEL_ATOM
expr_stmt|;
operator|*
name|Subtype
operator|=
name|INTEL_ATOM_BONNELL
expr_stmt|;
break|break;
comment|// "bonnell"
comment|// Atom Silvermont codes from the Intel software optimization guide.
case|case
literal|0x37
case|:
case|case
literal|0x4a
case|:
case|case
literal|0x4d
case|:
case|case
literal|0x5a
case|:
case|case
literal|0x5d
case|:
case|case
literal|0x4c
case|:
comment|// really airmont
operator|*
name|Type
operator|=
name|INTEL_ATOM
expr_stmt|;
operator|*
name|Subtype
operator|=
name|INTEL_ATOM_SILVERMONT
expr_stmt|;
break|break;
comment|// "silvermont"
case|case
literal|0x57
case|:
operator|*
name|Type
operator|=
name|INTEL_XEONPHI
expr_stmt|;
comment|// knl
operator|*
name|Subtype
operator|=
name|INTEL_KNIGHTS_LANDING
expr_stmt|;
break|break;
default|default:
comment|// Unknown family 6 CPU, try to guess.
if|if
condition|(
name|Features
operator|&
operator|(
literal|1
operator|<<
name|FEATURE_AVX512
operator|)
condition|)
block|{
operator|*
name|Type
operator|=
name|INTEL_XEONPHI
expr_stmt|;
comment|// knl
operator|*
name|Subtype
operator|=
name|INTEL_KNIGHTS_LANDING
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Features
operator|&
operator|(
literal|1
operator|<<
name|FEATURE_ADX
operator|)
condition|)
block|{
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_BROADWELL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Features
operator|&
operator|(
literal|1
operator|<<
name|FEATURE_AVX2
operator|)
condition|)
block|{
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_HASWELL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Features
operator|&
operator|(
literal|1
operator|<<
name|FEATURE_AVX
operator|)
condition|)
block|{
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_SANDYBRIDGE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Features
operator|&
operator|(
literal|1
operator|<<
name|FEATURE_SSE4_2
operator|)
condition|)
block|{
if|if
condition|(
name|Features
operator|&
operator|(
literal|1
operator|<<
name|FEATURE_MOVBE
operator|)
condition|)
block|{
operator|*
name|Type
operator|=
name|INTEL_ATOM
expr_stmt|;
operator|*
name|Subtype
operator|=
name|INTEL_ATOM_SILVERMONT
expr_stmt|;
block|}
else|else
block|{
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_NEHALEM
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|Features
operator|&
operator|(
literal|1
operator|<<
name|FEATURE_SSE4_1
operator|)
condition|)
block|{
operator|*
name|Type
operator|=
name|INTEL_CORE2
expr_stmt|;
comment|// "penryn"
operator|*
name|Subtype
operator|=
name|INTEL_CORE2_45
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Features
operator|&
operator|(
literal|1
operator|<<
name|FEATURE_SSSE3
operator|)
condition|)
block|{
if|if
condition|(
name|Features
operator|&
operator|(
literal|1
operator|<<
name|FEATURE_MOVBE
operator|)
condition|)
block|{
operator|*
name|Type
operator|=
name|INTEL_ATOM
expr_stmt|;
operator|*
name|Subtype
operator|=
name|INTEL_ATOM_BONNELL
expr_stmt|;
comment|// "bonnell"
block|}
else|else
block|{
operator|*
name|Type
operator|=
name|INTEL_CORE2
expr_stmt|;
comment|// "core2"
operator|*
name|Subtype
operator|=
name|INTEL_CORE2_65
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|Features
operator|&
operator|(
literal|1
operator|<<
name|FEATURE_EM64T
operator|)
condition|)
block|{
operator|*
name|Type
operator|=
name|INTEL_X86_64
expr_stmt|;
break|break;
comment|// x86-64
block|}
if|if
condition|(
name|Features
operator|&
operator|(
literal|1
operator|<<
name|FEATURE_SSE2
operator|)
condition|)
block|{
operator|*
name|Type
operator|=
name|INTEL_PENTIUM_M
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Features
operator|&
operator|(
literal|1
operator|<<
name|FEATURE_SSE
operator|)
condition|)
block|{
operator|*
name|Type
operator|=
name|INTEL_PENTIUM_III
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Features
operator|&
operator|(
literal|1
operator|<<
name|FEATURE_MMX
operator|)
condition|)
block|{
operator|*
name|Type
operator|=
name|INTEL_PENTIUM_II
expr_stmt|;
break|break;
block|}
operator|*
name|Type
operator|=
name|INTEL_PENTIUM_PRO
expr_stmt|;
break|break;
block|}
case|case
literal|15
case|:
block|{
switch|switch
condition|(
name|Model
condition|)
block|{
case|case
literal|0
case|:
comment|// Pentium 4 processor, Intel Xeon processor. All processors are
comment|// model 00h and manufactured using the 0.18 micron process.
case|case
literal|1
case|:
comment|// Pentium 4 processor, Intel Xeon processor, Intel Xeon
comment|// processor MP, and Intel Celeron processor. All processors are
comment|// model 01h and manufactured using the 0.18 micron process.
case|case
literal|2
case|:
comment|// Pentium 4 processor, Mobile Intel Pentium 4 processor - M,
comment|// Intel Xeon processor, Intel Xeon processor MP, Intel Celeron
comment|// processor, and Mobile Intel Celeron processor. All processors
comment|// are model 02h and manufactured using the 0.13 micron process.
operator|*
name|Type
operator|=
operator|(
operator|(
name|Features
operator|&
operator|(
literal|1
operator|<<
name|FEATURE_EM64T
operator|)
operator|)
condition|?
name|INTEL_X86_64
else|:
name|INTEL_PENTIUM_IV
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|// Pentium 4 processor, Intel Xeon processor, Intel Celeron D
comment|// processor. All processors are model 03h and manufactured using
comment|// the 90 nm process.
case|case
literal|4
case|:
comment|// Pentium 4 processor, Pentium 4 processor Extreme Edition,
comment|// Pentium D processor, Intel Xeon processor, Intel Xeon
comment|// processor MP, Intel Celeron D processor. All processors are
comment|// model 04h and manufactured using the 90 nm process.
case|case
literal|6
case|:
comment|// Pentium 4 processor, Pentium D processor, Pentium processor
comment|// Extreme Edition, Intel Xeon processor, Intel Xeon processor
comment|// MP, Intel Celeron D processor. All processors are model 06h
comment|// and manufactured using the 65 nm process.
operator|*
name|Type
operator|=
operator|(
operator|(
name|Features
operator|&
operator|(
literal|1
operator|<<
name|FEATURE_EM64T
operator|)
operator|)
condition|?
name|INTEL_NOCONA
else|:
name|INTEL_PRESCOTT
operator|)
expr_stmt|;
break|break;
default|default:
operator|*
name|Type
operator|=
operator|(
operator|(
name|Features
operator|&
operator|(
literal|1
operator|<<
name|FEATURE_EM64T
operator|)
operator|)
condition|?
name|INTEL_X86_64
else|:
name|INTEL_PENTIUM_IV
operator|)
expr_stmt|;
break|break;
block|}
block|}
default|default:
break|break;
comment|/*"generic"*/
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|getAMDProcessorTypeAndSubtype
parameter_list|(
name|unsigned
name|int
name|Family
parameter_list|,
name|unsigned
name|int
name|Model
parameter_list|,
name|unsigned
name|int
name|Features
parameter_list|,
name|unsigned
modifier|*
name|Type
parameter_list|,
name|unsigned
modifier|*
name|Subtype
parameter_list|)
block|{
comment|// FIXME: this poorly matches the generated SubtargetFeatureKV table.  There
comment|// appears to be no way to generate the wide variety of AMD-specific targets
comment|// from the information returned from CPUID.
switch|switch
condition|(
name|Family
condition|)
block|{
case|case
literal|4
case|:
operator|*
name|Type
operator|=
name|AMD_i486
expr_stmt|;
case|case
literal|5
case|:
operator|*
name|Type
operator|=
name|AMDPENTIUM
expr_stmt|;
switch|switch
condition|(
name|Model
condition|)
block|{
case|case
literal|6
case|:
case|case
literal|7
case|:
operator|*
name|Subtype
operator|=
name|AMDPENTIUM_K6
expr_stmt|;
break|break;
comment|// "k6"
case|case
literal|8
case|:
operator|*
name|Subtype
operator|=
name|AMDPENTIUM_K62
expr_stmt|;
break|break;
comment|// "k6-2"
case|case
literal|9
case|:
case|case
literal|13
case|:
operator|*
name|Subtype
operator|=
name|AMDPENTIUM_K63
expr_stmt|;
break|break;
comment|// "k6-3"
case|case
literal|10
case|:
operator|*
name|Subtype
operator|=
name|AMDPENTIUM_GEODE
expr_stmt|;
break|break;
comment|// "geode"
default|default:
break|break;
block|}
case|case
literal|6
case|:
operator|*
name|Type
operator|=
name|AMDATHLON
expr_stmt|;
switch|switch
condition|(
name|Model
condition|)
block|{
case|case
literal|4
case|:
operator|*
name|Subtype
operator|=
name|AMDATHLON_TBIRD
expr_stmt|;
break|break;
comment|// "athlon-tbird"
case|case
literal|6
case|:
case|case
literal|7
case|:
case|case
literal|8
case|:
operator|*
name|Subtype
operator|=
name|AMDATHLON_MP
expr_stmt|;
break|break;
comment|// "athlon-mp"
case|case
literal|10
case|:
operator|*
name|Subtype
operator|=
name|AMDATHLON_XP
expr_stmt|;
break|break;
comment|// "athlon-xp"
default|default:
break|break;
block|}
case|case
literal|15
case|:
operator|*
name|Type
operator|=
name|AMDATHLON
expr_stmt|;
if|if
condition|(
name|Features
operator|&
operator|(
literal|1
operator|<<
name|FEATURE_SSE3
operator|)
condition|)
block|{
operator|*
name|Subtype
operator|=
name|AMDATHLON_K8SSE3
expr_stmt|;
break|break;
comment|// "k8-sse3"
block|}
switch|switch
condition|(
name|Model
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|Subtype
operator|=
name|AMDATHLON_OPTERON
expr_stmt|;
break|break;
comment|// "opteron"
case|case
literal|5
case|:
operator|*
name|Subtype
operator|=
name|AMDATHLON_FX
expr_stmt|;
break|break;
comment|// "athlon-fx"; also opteron
default|default:
operator|*
name|Subtype
operator|=
name|AMDATHLON_64
expr_stmt|;
break|break;
comment|// "athlon64"
block|}
case|case
literal|16
case|:
operator|*
name|Type
operator|=
name|AMDFAM10H
expr_stmt|;
comment|// "amdfam10"
switch|switch
condition|(
name|Model
condition|)
block|{
case|case
literal|2
case|:
operator|*
name|Subtype
operator|=
name|AMDFAM10H_BARCELONA
expr_stmt|;
break|break;
case|case
literal|4
case|:
operator|*
name|Subtype
operator|=
name|AMDFAM10H_SHANGHAI
expr_stmt|;
break|break;
case|case
literal|8
case|:
operator|*
name|Subtype
operator|=
name|AMDFAM10H_ISTANBUL
expr_stmt|;
break|break;
default|default:
break|break;
block|}
case|case
literal|20
case|:
operator|*
name|Type
operator|=
name|AMDFAM14H
expr_stmt|;
operator|*
name|Subtype
operator|=
name|AMD_BTVER1
expr_stmt|;
break|break;
comment|// "btver1";
case|case
literal|21
case|:
operator|*
name|Type
operator|=
name|AMDFAM15H
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Features
operator|&
operator|(
literal|1
operator|<<
name|FEATURE_AVX
operator|)
operator|)
condition|)
block|{
comment|// If no AVX support, provide a sane fallback.
operator|*
name|Subtype
operator|=
name|AMD_BTVER1
expr_stmt|;
break|break;
comment|// "btver1"
block|}
if|if
condition|(
name|Model
operator|>=
literal|0x50
operator|&&
name|Model
operator|<=
literal|0x6f
condition|)
block|{
operator|*
name|Subtype
operator|=
name|AMDFAM15H_BDVER4
expr_stmt|;
break|break;
comment|// "bdver4"; 50h-6Fh: Excavator
block|}
if|if
condition|(
name|Model
operator|>=
literal|0x30
operator|&&
name|Model
operator|<=
literal|0x3f
condition|)
block|{
operator|*
name|Subtype
operator|=
name|AMDFAM15H_BDVER3
expr_stmt|;
break|break;
comment|// "bdver3"; 30h-3Fh: Steamroller
block|}
if|if
condition|(
name|Model
operator|>=
literal|0x10
operator|&&
name|Model
operator|<=
literal|0x1f
condition|)
block|{
operator|*
name|Subtype
operator|=
name|AMDFAM15H_BDVER2
expr_stmt|;
break|break;
comment|// "bdver2"; 10h-1Fh: Piledriver
block|}
if|if
condition|(
name|Model
operator|<=
literal|0x0f
condition|)
block|{
operator|*
name|Subtype
operator|=
name|AMDFAM15H_BDVER1
expr_stmt|;
break|break;
comment|// "bdver1"; 00h-0Fh: Bulldozer
block|}
break|break;
case|case
literal|22
case|:
operator|*
name|Type
operator|=
name|AMDFAM16H
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Features
operator|&
operator|(
literal|1
operator|<<
name|FEATURE_AVX
operator|)
operator|)
condition|)
block|{
comment|// If no AVX support provide a sane fallback.
operator|*
name|Subtype
operator|=
name|AMD_BTVER1
expr_stmt|;
break|break;
comment|// "btver1";
block|}
operator|*
name|Subtype
operator|=
name|AMD_BTVER2
expr_stmt|;
break|break;
comment|// "btver2"
default|default:
break|break;
comment|// "generic"
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|getAvailableFeatures
parameter_list|(
name|unsigned
name|int
name|ECX
parameter_list|,
name|unsigned
name|int
name|EDX
parameter_list|,
name|unsigned
name|MaxLeaf
parameter_list|)
block|{
name|unsigned
name|Features
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|EAX
decl_stmt|,
name|EBX
decl_stmt|;
name|Features
operator||=
operator|(
operator|(
operator|(
name|EDX
operator|>>
literal|23
operator|)
operator|&
literal|1
operator|)
operator|<<
name|FEATURE_MMX
operator|)
expr_stmt|;
name|Features
operator||=
operator|(
operator|(
operator|(
name|EDX
operator|>>
literal|25
operator|)
operator|&
literal|1
operator|)
operator|<<
name|FEATURE_SSE
operator|)
expr_stmt|;
name|Features
operator||=
operator|(
operator|(
operator|(
name|EDX
operator|>>
literal|26
operator|)
operator|&
literal|1
operator|)
operator|<<
name|FEATURE_SSE2
operator|)
expr_stmt|;
name|Features
operator||=
operator|(
operator|(
operator|(
name|ECX
operator|>>
literal|0
operator|)
operator|&
literal|1
operator|)
operator|<<
name|FEATURE_SSE3
operator|)
expr_stmt|;
name|Features
operator||=
operator|(
operator|(
operator|(
name|ECX
operator|>>
literal|9
operator|)
operator|&
literal|1
operator|)
operator|<<
name|FEATURE_SSSE3
operator|)
expr_stmt|;
name|Features
operator||=
operator|(
operator|(
operator|(
name|ECX
operator|>>
literal|19
operator|)
operator|&
literal|1
operator|)
operator|<<
name|FEATURE_SSE4_1
operator|)
expr_stmt|;
name|Features
operator||=
operator|(
operator|(
operator|(
name|ECX
operator|>>
literal|20
operator|)
operator|&
literal|1
operator|)
operator|<<
name|FEATURE_SSE4_2
operator|)
expr_stmt|;
name|Features
operator||=
operator|(
operator|(
operator|(
name|ECX
operator|>>
literal|22
operator|)
operator|&
literal|1
operator|)
operator|<<
name|FEATURE_MOVBE
operator|)
expr_stmt|;
comment|// If CPUID indicates support for XSAVE, XRESTORE and AVX, and XGETBV
comment|// indicates that the AVX registers will be saved and restored on context
comment|// switch, then we have full AVX support.
specifier|const
name|unsigned
name|AVXBits
init|=
operator|(
literal|1
operator|<<
literal|27
operator|)
operator||
operator|(
literal|1
operator|<<
literal|28
operator|)
decl_stmt|;
name|bool
name|HasAVX
init|=
operator|(
operator|(
name|ECX
operator|&
name|AVXBits
operator|)
operator|==
name|AVXBits
operator|)
operator|&&
operator|!
name|getX86XCR0
argument_list|(
operator|&
name|EAX
argument_list|,
operator|&
name|EDX
argument_list|)
operator|&&
operator|(
operator|(
name|EAX
operator|&
literal|0x6
operator|)
operator|==
literal|0x6
operator|)
decl_stmt|;
name|bool
name|HasAVX512Save
init|=
name|HasAVX
operator|&&
operator|(
operator|(
name|EAX
operator|&
literal|0xe0
operator|)
operator|==
literal|0xe0
operator|)
decl_stmt|;
name|bool
name|HasLeaf7
init|=
name|MaxLeaf
operator|>=
literal|0x7
decl_stmt|;
name|getX86CpuIDAndInfoEx
argument_list|(
literal|0x7
argument_list|,
literal|0x0
argument_list|,
operator|&
name|EAX
argument_list|,
operator|&
name|EBX
argument_list|,
operator|&
name|ECX
argument_list|,
operator|&
name|EDX
argument_list|)
expr_stmt|;
name|bool
name|HasADX
init|=
name|HasLeaf7
operator|&&
operator|(
operator|(
name|EBX
operator|>>
literal|19
operator|)
operator|&
literal|1
operator|)
decl_stmt|;
name|bool
name|HasAVX2
init|=
name|HasAVX
operator|&&
name|HasLeaf7
operator|&&
operator|(
name|EBX
operator|&
literal|0x20
operator|)
decl_stmt|;
name|bool
name|HasAVX512
init|=
name|HasLeaf7
operator|&&
name|HasAVX512Save
operator|&&
operator|(
operator|(
name|EBX
operator|>>
literal|16
operator|)
operator|&
literal|1
operator|)
decl_stmt|;
name|Features
operator||=
operator|(
name|HasAVX
operator|<<
name|FEATURE_AVX
operator|)
expr_stmt|;
name|Features
operator||=
operator|(
name|HasAVX2
operator|<<
name|FEATURE_AVX2
operator|)
expr_stmt|;
name|Features
operator||=
operator|(
name|HasAVX512
operator|<<
name|FEATURE_AVX512
operator|)
expr_stmt|;
name|Features
operator||=
operator|(
name|HasAVX512Save
operator|<<
name|FEATURE_AVX512SAVE
operator|)
expr_stmt|;
name|Features
operator||=
operator|(
name|HasADX
operator|<<
name|FEATURE_ADX
operator|)
expr_stmt|;
name|getX86CpuIDAndInfo
argument_list|(
literal|0x80000001
argument_list|,
operator|&
name|EAX
argument_list|,
operator|&
name|EBX
argument_list|,
operator|&
name|ECX
argument_list|,
operator|&
name|EDX
argument_list|)
expr_stmt|;
name|Features
operator||=
operator|(
operator|(
operator|(
name|EDX
operator|>>
literal|29
operator|)
operator|&
literal|0x1
operator|)
operator|<<
name|FEATURE_EM64T
operator|)
expr_stmt|;
return|return
name|Features
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_INIT_PRIORITY
argument_list|)
end_if

begin_define
define|#
directive|define
name|CONSTRUCTOR_ATTRIBUTE
value|__attribute__((__constructor__ 101))
end_define

begin_elif
elif|#
directive|elif
name|__has_attribute
argument_list|(
name|__constructor__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CONSTRUCTOR_ATTRIBUTE
value|__attribute__((__constructor__))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|// FIXME: For MSVC, we should make a function pointer global in .CRT$X?? so that
end_comment

begin_comment
comment|// this runs during initialization.
end_comment

begin_define
define|#
directive|define
name|CONSTRUCTOR_ATTRIBUTE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|__cpu_indicator_init
argument_list|(
name|void
argument_list|)
name|CONSTRUCTOR_ATTRIBUTE
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|__processor_model
block|{
name|unsigned
name|int
name|__cpu_vendor
decl_stmt|;
name|unsigned
name|int
name|__cpu_type
decl_stmt|;
name|unsigned
name|int
name|__cpu_subtype
decl_stmt|;
name|unsigned
name|int
name|__cpu_features
index|[
literal|1
index|]
decl_stmt|;
block|}
name|__cpu_model
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* A constructor function that is sets __cpu_model and __cpu_features with    the right values.  This needs to run only once.  This constructor is    given the highest priority and it should run before constructors without    the priority set.  However, it still runs after ifunc initializers and    needs to be called explicitly there.  */
end_comment

begin_function
name|int
name|CONSTRUCTOR_ATTRIBUTE
name|__cpu_indicator_init
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|EAX
decl_stmt|,
name|EBX
decl_stmt|,
name|ECX
decl_stmt|,
name|EDX
decl_stmt|;
name|unsigned
name|int
name|MaxLeaf
init|=
literal|5
decl_stmt|;
name|unsigned
name|int
name|Vendor
decl_stmt|;
name|unsigned
name|int
name|Model
decl_stmt|,
name|Family
decl_stmt|,
name|Brand_id
decl_stmt|;
name|unsigned
name|int
name|Features
init|=
literal|0
decl_stmt|;
comment|/* This function needs to run just once.  */
if|if
condition|(
name|__cpu_model
operator|.
name|__cpu_vendor
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|isCpuIdSupported
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Assume cpuid insn present. Run in level 0 to get vendor id. */
name|getX86CpuIDAndInfo
argument_list|(
literal|0
argument_list|,
operator|&
name|MaxLeaf
argument_list|,
operator|&
name|Vendor
argument_list|,
operator|&
name|ECX
argument_list|,
operator|&
name|EDX
argument_list|)
expr_stmt|;
if|if
condition|(
name|MaxLeaf
operator|<
literal|1
condition|)
block|{
name|__cpu_model
operator|.
name|__cpu_vendor
operator|=
name|VENDOR_OTHER
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|getX86CpuIDAndInfo
argument_list|(
literal|1
argument_list|,
operator|&
name|EAX
argument_list|,
operator|&
name|EBX
argument_list|,
operator|&
name|ECX
argument_list|,
operator|&
name|EDX
argument_list|)
expr_stmt|;
name|detectX86FamilyModel
argument_list|(
name|EAX
argument_list|,
operator|&
name|Family
argument_list|,
operator|&
name|Model
argument_list|)
expr_stmt|;
name|Brand_id
operator|=
name|EBX
operator|&
literal|0xff
expr_stmt|;
comment|/* Find available features. */
name|Features
operator|=
name|getAvailableFeatures
argument_list|(
name|ECX
argument_list|,
name|EDX
argument_list|,
name|MaxLeaf
argument_list|)
expr_stmt|;
name|__cpu_model
operator|.
name|__cpu_features
index|[
literal|0
index|]
operator|=
name|Features
expr_stmt|;
if|if
condition|(
name|Vendor
operator|==
name|SIG_INTEL
condition|)
block|{
comment|/* Get CPU type.  */
name|getIntelProcessorTypeAndSubtype
argument_list|(
name|Family
argument_list|,
name|Model
argument_list|,
name|Brand_id
argument_list|,
name|Features
argument_list|,
operator|&
operator|(
name|__cpu_model
operator|.
name|__cpu_type
operator|)
argument_list|,
operator|&
operator|(
name|__cpu_model
operator|.
name|__cpu_subtype
operator|)
argument_list|)
expr_stmt|;
name|__cpu_model
operator|.
name|__cpu_vendor
operator|=
name|VENDOR_INTEL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Vendor
operator|==
name|SIG_AMD
condition|)
block|{
comment|/* Get CPU type.  */
name|getAMDProcessorTypeAndSubtype
argument_list|(
name|Family
argument_list|,
name|Model
argument_list|,
name|Features
argument_list|,
operator|&
operator|(
name|__cpu_model
operator|.
name|__cpu_type
operator|)
argument_list|,
operator|&
operator|(
name|__cpu_model
operator|.
name|__cpu_subtype
operator|)
argument_list|)
expr_stmt|;
name|__cpu_model
operator|.
name|__cpu_vendor
operator|=
name|VENDOR_AMD
expr_stmt|;
block|}
else|else
name|__cpu_model
operator|.
name|__cpu_vendor
operator|=
name|VENDOR_OTHER
expr_stmt|;
name|assert
argument_list|(
name|__cpu_model
operator|.
name|__cpu_vendor
operator|<
name|VENDOR_MAX
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|__cpu_model
operator|.
name|__cpu_type
operator|<
name|CPU_TYPE_MAX
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|__cpu_model
operator|.
name|__cpu_subtype
operator|<
name|CPU_SUBTYPE_MAX
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

