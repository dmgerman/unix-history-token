begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- lib/adddf3.c - Double-precision addition ------------------*- C -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is dual licensed under the MIT and the University of Illinois Open
end_comment

begin_comment
comment|// Source Licenses. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file implements double-precision soft-float addition with the IEEE-754
end_comment

begin_comment
comment|// default rounding (to nearest, ties to even).
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_define
define|#
directive|define
name|DOUBLE_PRECISION
end_define

begin_include
include|#
directive|include
file|"fp_lib.h"
end_include

begin_macro
name|ARM_EABI_FNALIAS
argument_list|(
argument|dadd
argument_list|,
argument|adddf3
argument_list|)
end_macro

begin_function
name|COMPILER_RT_ABI
name|fp_t
name|__adddf3
parameter_list|(
name|fp_t
name|a
parameter_list|,
name|fp_t
name|b
parameter_list|)
block|{
name|rep_t
name|aRep
init|=
name|toRep
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|rep_t
name|bRep
init|=
name|toRep
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|const
name|rep_t
name|aAbs
init|=
name|aRep
operator|&
name|absMask
decl_stmt|;
specifier|const
name|rep_t
name|bAbs
init|=
name|bRep
operator|&
name|absMask
decl_stmt|;
comment|// Detect if a or b is zero, infinity, or NaN.
if|if
condition|(
name|aAbs
operator|-
literal|1U
operator|>=
name|infRep
operator|-
literal|1U
operator|||
name|bAbs
operator|-
literal|1U
operator|>=
name|infRep
operator|-
literal|1U
condition|)
block|{
comment|// NaN + anything = qNaN
if|if
condition|(
name|aAbs
operator|>
name|infRep
condition|)
return|return
name|fromRep
argument_list|(
name|toRep
argument_list|(
name|a
argument_list|)
operator||
name|quietBit
argument_list|)
return|;
comment|// anything + NaN = qNaN
if|if
condition|(
name|bAbs
operator|>
name|infRep
condition|)
return|return
name|fromRep
argument_list|(
name|toRep
argument_list|(
name|b
argument_list|)
operator||
name|quietBit
argument_list|)
return|;
if|if
condition|(
name|aAbs
operator|==
name|infRep
condition|)
block|{
comment|// +/-infinity + -/+infinity = qNaN
if|if
condition|(
operator|(
name|toRep
argument_list|(
name|a
argument_list|)
operator|^
name|toRep
argument_list|(
name|b
argument_list|)
operator|)
operator|==
name|signBit
condition|)
return|return
name|fromRep
argument_list|(
name|qnanRep
argument_list|)
return|;
comment|// +/-infinity + anything remaining = +/- infinity
else|else
return|return
name|a
return|;
block|}
comment|// anything remaining + +/-infinity = +/-infinity
if|if
condition|(
name|bAbs
operator|==
name|infRep
condition|)
return|return
name|b
return|;
comment|// zero + anything = anything
if|if
condition|(
operator|!
name|aAbs
condition|)
block|{
comment|// but we need to get the sign right for zero + zero
if|if
condition|(
operator|!
name|bAbs
condition|)
return|return
name|fromRep
argument_list|(
name|toRep
argument_list|(
name|a
argument_list|)
operator|&
name|toRep
argument_list|(
name|b
argument_list|)
argument_list|)
return|;
else|else
return|return
name|b
return|;
block|}
comment|// anything + zero = anything
if|if
condition|(
operator|!
name|bAbs
condition|)
return|return
name|a
return|;
block|}
comment|// Swap a and b if necessary so that a has the larger absolute value.
if|if
condition|(
name|bAbs
operator|>
name|aAbs
condition|)
block|{
specifier|const
name|rep_t
name|temp
init|=
name|aRep
decl_stmt|;
name|aRep
operator|=
name|bRep
expr_stmt|;
name|bRep
operator|=
name|temp
expr_stmt|;
block|}
comment|// Extract the exponent and significand from the (possibly swapped) a and b.
name|int
name|aExponent
init|=
name|aRep
operator|>>
name|significandBits
operator|&
name|maxExponent
decl_stmt|;
name|int
name|bExponent
init|=
name|bRep
operator|>>
name|significandBits
operator|&
name|maxExponent
decl_stmt|;
name|rep_t
name|aSignificand
init|=
name|aRep
operator|&
name|significandMask
decl_stmt|;
name|rep_t
name|bSignificand
init|=
name|bRep
operator|&
name|significandMask
decl_stmt|;
comment|// Normalize any denormals, and adjust the exponent accordingly.
if|if
condition|(
name|aExponent
operator|==
literal|0
condition|)
name|aExponent
operator|=
name|normalize
argument_list|(
operator|&
name|aSignificand
argument_list|)
expr_stmt|;
if|if
condition|(
name|bExponent
operator|==
literal|0
condition|)
name|bExponent
operator|=
name|normalize
argument_list|(
operator|&
name|bSignificand
argument_list|)
expr_stmt|;
comment|// The sign of the result is the sign of the larger operand, a.  If they
comment|// have opposite signs, we are performing a subtraction; otherwise addition.
specifier|const
name|rep_t
name|resultSign
init|=
name|aRep
operator|&
name|signBit
decl_stmt|;
specifier|const
name|bool
name|subtraction
init|=
operator|(
name|aRep
operator|^
name|bRep
operator|)
operator|&
name|signBit
decl_stmt|;
comment|// Shift the significands to give us round, guard and sticky, and or in the
comment|// implicit significand bit.  (If we fell through from the denormal path it
comment|// was already set by normalize( ), but setting it twice won't hurt
comment|// anything.)
name|aSignificand
operator|=
operator|(
name|aSignificand
operator||
name|implicitBit
operator|)
operator|<<
literal|3
expr_stmt|;
name|bSignificand
operator|=
operator|(
name|bSignificand
operator||
name|implicitBit
operator|)
operator|<<
literal|3
expr_stmt|;
comment|// Shift the significand of b by the difference in exponents, with a sticky
comment|// bottom bit to get rounding correct.
specifier|const
name|unsigned
name|int
name|align
init|=
name|aExponent
operator|-
name|bExponent
decl_stmt|;
if|if
condition|(
name|align
condition|)
block|{
if|if
condition|(
name|align
operator|<
name|typeWidth
condition|)
block|{
specifier|const
name|bool
name|sticky
init|=
name|bSignificand
operator|<<
operator|(
name|typeWidth
operator|-
name|align
operator|)
decl_stmt|;
name|bSignificand
operator|=
name|bSignificand
operator|>>
name|align
operator||
name|sticky
expr_stmt|;
block|}
else|else
block|{
name|bSignificand
operator|=
literal|1
expr_stmt|;
comment|// sticky; b is known to be non-zero.
block|}
block|}
if|if
condition|(
name|subtraction
condition|)
block|{
name|aSignificand
operator|-=
name|bSignificand
expr_stmt|;
comment|// If a == -b, return +zero.
if|if
condition|(
name|aSignificand
operator|==
literal|0
condition|)
return|return
name|fromRep
argument_list|(
literal|0
argument_list|)
return|;
comment|// If partial cancellation occured, we need to left-shift the result
comment|// and adjust the exponent:
if|if
condition|(
name|aSignificand
operator|<
name|implicitBit
operator|<<
literal|3
condition|)
block|{
specifier|const
name|int
name|shift
init|=
name|rep_clz
argument_list|(
name|aSignificand
argument_list|)
operator|-
name|rep_clz
argument_list|(
name|implicitBit
operator|<<
literal|3
argument_list|)
decl_stmt|;
name|aSignificand
operator|<<=
name|shift
expr_stmt|;
name|aExponent
operator|-=
name|shift
expr_stmt|;
block|}
block|}
else|else
comment|/* addition */
block|{
name|aSignificand
operator|+=
name|bSignificand
expr_stmt|;
comment|// If the addition carried up, we need to right-shift the result and
comment|// adjust the exponent:
if|if
condition|(
name|aSignificand
operator|&
name|implicitBit
operator|<<
literal|4
condition|)
block|{
specifier|const
name|bool
name|sticky
init|=
name|aSignificand
operator|&
literal|1
decl_stmt|;
name|aSignificand
operator|=
name|aSignificand
operator|>>
literal|1
operator||
name|sticky
expr_stmt|;
name|aExponent
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|// If we have overflowed the type, return +/- infinity:
if|if
condition|(
name|aExponent
operator|>=
name|maxExponent
condition|)
return|return
name|fromRep
argument_list|(
name|infRep
operator||
name|resultSign
argument_list|)
return|;
if|if
condition|(
name|aExponent
operator|<=
literal|0
condition|)
block|{
comment|// Result is denormal before rounding; the exponent is zero and we
comment|// need to shift the significand.
specifier|const
name|int
name|shift
init|=
literal|1
operator|-
name|aExponent
decl_stmt|;
specifier|const
name|bool
name|sticky
init|=
name|aSignificand
operator|<<
operator|(
name|typeWidth
operator|-
name|shift
operator|)
decl_stmt|;
name|aSignificand
operator|=
name|aSignificand
operator|>>
name|shift
operator||
name|sticky
expr_stmt|;
name|aExponent
operator|=
literal|0
expr_stmt|;
block|}
comment|// Low three bits are round, guard, and sticky.
specifier|const
name|int
name|roundGuardSticky
init|=
name|aSignificand
operator|&
literal|0x7
decl_stmt|;
comment|// Shift the significand into place, and mask off the implicit bit.
name|rep_t
name|result
init|=
name|aSignificand
operator|>>
literal|3
operator|&
name|significandMask
decl_stmt|;
comment|// Insert the exponent and sign.
name|result
operator||=
operator|(
name|rep_t
operator|)
name|aExponent
operator|<<
name|significandBits
expr_stmt|;
name|result
operator||=
name|resultSign
expr_stmt|;
comment|// Final rounding.  The result may overflow to infinity, but that is the
comment|// correct result in that case.
if|if
condition|(
name|roundGuardSticky
operator|>
literal|0x4
condition|)
name|result
operator|++
expr_stmt|;
if|if
condition|(
name|roundGuardSticky
operator|==
literal|0x4
condition|)
name|result
operator|+=
name|result
operator|&
literal|1
expr_stmt|;
return|return
name|fromRep
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

end_unit

