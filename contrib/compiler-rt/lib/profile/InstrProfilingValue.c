begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*===- InstrProfilingValue.c - Support library for PGO instrumentation ----===*\ |* |*                     The LLVM Compiler Infrastructure |* |* This file is distributed under the University of Illinois Open Source |* License. See LICENSE.TXT for details. |* \*===----------------------------------------------------------------------===*/
end_comment

begin_include
include|#
directive|include
file|"InstrProfiling.h"
end_include

begin_include
include|#
directive|include
file|"InstrProfilingInternal.h"
end_include

begin_include
include|#
directive|include
file|"InstrProfilingUtil.h"
end_include

begin_comment
comment|/* For PS4 getenv shim. */
end_comment

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|INSTR_PROF_VALUE_PROF_DATA
end_define

begin_define
define|#
directive|define
name|INSTR_PROF_COMMON_API_IMPL
end_define

begin_include
include|#
directive|include
file|"InstrProfData.inc"
end_include

begin_decl_stmt
specifier|static
name|int
name|hasStaticCounters
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|OutOfNodesWarnings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hasNonDefaultValsPerSite
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSTR_PROF_MAX_VP_WARNS
value|10
end_define

begin_define
define|#
directive|define
name|INSTR_PROF_DEFAULT_NUM_VAL_PER_SITE
value|8
end_define

begin_define
define|#
directive|define
name|INSTR_PROF_VNODE_POOL_SIZE
value|1024
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|_MSC_VER
end_ifndef

begin_comment
comment|/* A shared static pool in addition to the vnodes statically  * allocated by the compiler.  */
end_comment

begin_function_decl
name|COMPILER_RT_VISIBILITY
name|ValueProfNode
name|lprofValueProfNodes
index|[
name|INSTR_PROF_VNODE_POOL_SIZE
index|]
name|COMPILER_RT_SECTION
parameter_list|(
name|COMPILER_RT_SEG
name|INSTR_PROF_VNODES_SECT_NAME_STR
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|COMPILER_RT_VISIBILITY
name|uint32_t
name|VPMaxNumValsPerSite
init|=
name|INSTR_PROF_DEFAULT_NUM_VAL_PER_SITE
decl_stmt|;
end_decl_stmt

begin_function
name|COMPILER_RT_VISIBILITY
name|void
name|lprofSetupValueProfiler
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|Str
init|=
literal|0
decl_stmt|;
name|Str
operator|=
name|getenv
argument_list|(
literal|"LLVM_VP_MAX_NUM_VALS_PER_SITE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Str
operator|&&
name|Str
index|[
literal|0
index|]
condition|)
block|{
name|VPMaxNumValsPerSite
operator|=
name|atoi
argument_list|(
name|Str
argument_list|)
expr_stmt|;
name|hasNonDefaultValsPerSite
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|VPMaxNumValsPerSite
operator|>
name|INSTR_PROF_MAX_NUM_VAL_PER_SITE
condition|)
name|VPMaxNumValsPerSite
operator|=
name|INSTR_PROF_MAX_NUM_VAL_PER_SITE
expr_stmt|;
block|}
end_function

begin_function
name|COMPILER_RT_VISIBILITY
name|void
name|lprofSetMaxValsPerSite
parameter_list|(
name|uint32_t
name|MaxVals
parameter_list|)
block|{
name|VPMaxNumValsPerSite
operator|=
name|MaxVals
expr_stmt|;
name|hasNonDefaultValsPerSite
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This method is only used in value profiler mock testing.  */
end_comment

begin_function
name|COMPILER_RT_VISIBILITY
name|void
name|__llvm_profile_set_num_value_sites
parameter_list|(
name|__llvm_profile_data
modifier|*
name|Data
parameter_list|,
name|uint32_t
name|ValueKind
parameter_list|,
name|uint16_t
name|NumValueSites
parameter_list|)
block|{
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|Data
operator|->
name|NumValueSites
index|[
name|ValueKind
index|]
operator|)
operator|=
name|NumValueSites
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This method is only used in value profiler mock testing.  */
end_comment

begin_function
name|COMPILER_RT_VISIBILITY
specifier|const
name|__llvm_profile_data
modifier|*
name|__llvm_profile_iterate_data
parameter_list|(
specifier|const
name|__llvm_profile_data
modifier|*
name|Data
parameter_list|)
block|{
return|return
name|Data
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This method is only used in value profiler mock testing.  */
end_comment

begin_function
name|COMPILER_RT_VISIBILITY
name|void
modifier|*
name|__llvm_get_function_addr
parameter_list|(
specifier|const
name|__llvm_profile_data
modifier|*
name|Data
parameter_list|)
block|{
return|return
name|Data
operator|->
name|FunctionPointer
return|;
block|}
end_function

begin_comment
comment|/* Allocate an array that holds the pointers to the linked lists of  * value profile counter nodes. The number of element of the array  * is the total number of value profile sites instrumented. Returns  * 0 if allocation fails.  */
end_comment

begin_function
specifier|static
name|int
name|allocateValueProfileCounters
parameter_list|(
name|__llvm_profile_data
modifier|*
name|Data
parameter_list|)
block|{
name|uint64_t
name|NumVSites
init|=
literal|0
decl_stmt|;
name|uint32_t
name|VKI
decl_stmt|;
comment|/* This function will never be called when value site array is allocated      statically at compile time.  */
name|hasStaticCounters
operator|=
literal|0
expr_stmt|;
comment|/* When dynamic allocation is enabled, allow tracking the max number of    * values allowd.  */
if|if
condition|(
operator|!
name|hasNonDefaultValsPerSite
condition|)
name|VPMaxNumValsPerSite
operator|=
name|INSTR_PROF_MAX_NUM_VAL_PER_SITE
expr_stmt|;
for|for
control|(
name|VKI
operator|=
name|IPVK_First
init|;
name|VKI
operator|<=
name|IPVK_Last
condition|;
operator|++
name|VKI
control|)
name|NumVSites
operator|+=
name|Data
operator|->
name|NumValueSites
index|[
name|VKI
index|]
expr_stmt|;
name|ValueProfNode
modifier|*
modifier|*
name|Mem
init|=
operator|(
name|ValueProfNode
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|NumVSites
argument_list|,
sizeof|sizeof
argument_list|(
name|ValueProfNode
operator|*
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Mem
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|COMPILER_RT_BOOL_CMPXCHG
argument_list|(
operator|&
name|Data
operator|->
name|Values
argument_list|,
literal|0
argument_list|,
name|Mem
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|Mem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|ValueProfNode
modifier|*
name|allocateOneNode
parameter_list|(
name|__llvm_profile_data
modifier|*
name|Data
parameter_list|,
name|uint32_t
name|Index
parameter_list|,
name|uint64_t
name|Value
parameter_list|)
block|{
name|ValueProfNode
modifier|*
name|Node
decl_stmt|;
if|if
condition|(
operator|!
name|hasStaticCounters
condition|)
return|return
operator|(
name|ValueProfNode
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|ValueProfNode
argument_list|)
argument_list|)
return|;
comment|/* Early check to avoid value wrapping around.  */
if|if
condition|(
name|CurrentVNode
operator|+
literal|1
operator|>
name|EndVNode
condition|)
block|{
if|if
condition|(
name|OutOfNodesWarnings
operator|++
operator|<
name|INSTR_PROF_MAX_VP_WARNS
condition|)
block|{
name|PROF_WARN
argument_list|(
literal|"Unable to track new values: %s. "
literal|" Consider using option -mllvm -vp-counters-per-site=<n> to "
literal|"allocate more"
literal|" value profile counters at compile time. \n"
argument_list|,
literal|"Running out of static counters"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|Node
operator|=
name|COMPILER_RT_PTR_FETCH_ADD
argument_list|(
name|ValueProfNode
argument_list|,
name|CurrentVNode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Due to section padding, EndVNode point to a byte which is one pass    * an incomplete VNode, so we need to skip the last incomplete node. */
if|if
condition|(
name|Node
operator|+
literal|1
operator|>
name|EndVNode
condition|)
return|return
literal|0
return|;
return|return
name|Node
return|;
block|}
end_function

begin_function
name|COMPILER_RT_VISIBILITY
name|void
name|__llvm_profile_instrument_target
parameter_list|(
name|uint64_t
name|TargetValue
parameter_list|,
name|void
modifier|*
name|Data
parameter_list|,
name|uint32_t
name|CounterIndex
parameter_list|)
block|{
name|__llvm_profile_data
modifier|*
name|PData
init|=
operator|(
name|__llvm_profile_data
operator|*
operator|)
name|Data
decl_stmt|;
if|if
condition|(
operator|!
name|PData
condition|)
return|return;
if|if
condition|(
operator|!
name|PData
operator|->
name|Values
condition|)
block|{
if|if
condition|(
operator|!
name|allocateValueProfileCounters
argument_list|(
name|PData
argument_list|)
condition|)
return|return;
block|}
name|ValueProfNode
modifier|*
modifier|*
name|ValueCounters
init|=
operator|(
name|ValueProfNode
operator|*
operator|*
operator|)
name|PData
operator|->
name|Values
decl_stmt|;
name|ValueProfNode
modifier|*
name|PrevVNode
init|=
name|NULL
decl_stmt|;
name|ValueProfNode
modifier|*
name|MinCountVNode
init|=
name|NULL
decl_stmt|;
name|ValueProfNode
modifier|*
name|CurVNode
init|=
name|ValueCounters
index|[
name|CounterIndex
index|]
decl_stmt|;
name|uint64_t
name|MinCount
init|=
name|UINT64_MAX
decl_stmt|;
name|uint8_t
name|VDataCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|CurVNode
condition|)
block|{
if|if
condition|(
name|TargetValue
operator|==
name|CurVNode
operator|->
name|Value
condition|)
block|{
name|CurVNode
operator|->
name|Count
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|CurVNode
operator|->
name|Count
operator|<
name|MinCount
condition|)
block|{
name|MinCount
operator|=
name|CurVNode
operator|->
name|Count
expr_stmt|;
name|MinCountVNode
operator|=
name|CurVNode
expr_stmt|;
block|}
name|PrevVNode
operator|=
name|CurVNode
expr_stmt|;
name|CurVNode
operator|=
name|CurVNode
operator|->
name|Next
expr_stmt|;
operator|++
name|VDataCount
expr_stmt|;
block|}
if|if
condition|(
name|VDataCount
operator|>=
name|VPMaxNumValsPerSite
condition|)
block|{
comment|/* Bump down the min count node's count. If it reaches 0,      * evict it. This eviction/replacement policy makes hot      * targets more sticky while cold targets less so. In other      * words, it makes it less likely for the hot targets to be      * prematurally evicted during warmup/establishment period,      * when their counts are still low. In a special case when      * the number of values tracked is reduced to only one, this      * policy will guarantee that the dominating target with>50%      * total count will survive in the end. Note that this scheme      * allows the runtime to track the min count node in an adaptive      * manner. It can correct previous mistakes and eventually      * lock on a cold target that is alread in stable state.      *      * In very rare cases,  this replacement scheme may still lead      * to target loss. For instance, out of \c N value slots, \c N-1      * slots are occupied by luke warm targets during the warmup      * period and the remaining one slot is competed by two or more      * very hot targets. If those hot targets occur in an interleaved      * way, none of them will survive (gain enough weight to throw out      * other established entries) due to the ping-pong effect.      * To handle this situation, user can choose to increase the max      * number of tracked values per value site. Alternatively, a more      * expensive eviction mechanism can be implemented. It requires      * the runtime to track the total number of evictions per-site.      * When the total number of evictions reaches certain threshold,      * the runtime can wipe out more than one lowest count entries      * to give space for hot targets.      */
if|if
condition|(
operator|!
operator|(
operator|--
name|MinCountVNode
operator|->
name|Count
operator|)
condition|)
block|{
name|CurVNode
operator|=
name|MinCountVNode
expr_stmt|;
name|CurVNode
operator|->
name|Value
operator|=
name|TargetValue
expr_stmt|;
name|CurVNode
operator|->
name|Count
operator|++
expr_stmt|;
block|}
return|return;
block|}
name|CurVNode
operator|=
name|allocateOneNode
argument_list|(
name|PData
argument_list|,
name|CounterIndex
argument_list|,
name|TargetValue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CurVNode
condition|)
return|return;
name|CurVNode
operator|->
name|Value
operator|=
name|TargetValue
expr_stmt|;
name|CurVNode
operator|->
name|Count
operator|++
expr_stmt|;
name|uint32_t
name|Success
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ValueCounters
index|[
name|CounterIndex
index|]
condition|)
name|Success
operator|=
name|COMPILER_RT_BOOL_CMPXCHG
argument_list|(
operator|&
name|ValueCounters
index|[
name|CounterIndex
index|]
argument_list|,
literal|0
argument_list|,
name|CurVNode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PrevVNode
operator|&&
operator|!
name|PrevVNode
operator|->
name|Next
condition|)
name|Success
operator|=
name|COMPILER_RT_BOOL_CMPXCHG
argument_list|(
operator|&
operator|(
name|PrevVNode
operator|->
name|Next
operator|)
argument_list|,
literal|0
argument_list|,
name|CurVNode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Success
operator|&&
operator|!
name|hasStaticCounters
condition|)
block|{
name|free
argument_list|(
name|CurVNode
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * A wrapper struct that represents value profile runtime data.  * Like InstrProfRecord class which is used by profiling host tools,  * ValueProfRuntimeRecord also implements the abstract intefaces defined in  * ValueProfRecordClosure so that the runtime data can be serialized using  * shared C implementation.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ValueProfRuntimeRecord
block|{
specifier|const
name|__llvm_profile_data
modifier|*
name|Data
decl_stmt|;
name|ValueProfNode
modifier|*
modifier|*
name|NodesKind
index|[
name|IPVK_Last
operator|+
literal|1
index|]
decl_stmt|;
name|uint8_t
modifier|*
modifier|*
name|SiteCountArray
decl_stmt|;
block|}
name|ValueProfRuntimeRecord
typedef|;
end_typedef

begin_comment
comment|/* ValueProfRecordClosure Interface implementation. */
end_comment

begin_function
specifier|static
name|uint32_t
name|getNumValueSitesRT
parameter_list|(
specifier|const
name|void
modifier|*
name|R
parameter_list|,
name|uint32_t
name|VK
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
name|ValueProfRuntimeRecord
operator|*
operator|)
name|R
operator|)
operator|->
name|Data
operator|->
name|NumValueSites
index|[
name|VK
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|getNumValueDataRT
parameter_list|(
specifier|const
name|void
modifier|*
name|R
parameter_list|,
name|uint32_t
name|VK
parameter_list|)
block|{
name|uint32_t
name|S
init|=
literal|0
decl_stmt|,
name|I
decl_stmt|;
specifier|const
name|ValueProfRuntimeRecord
modifier|*
name|Record
init|=
operator|(
specifier|const
name|ValueProfRuntimeRecord
operator|*
operator|)
name|R
decl_stmt|;
if|if
condition|(
name|Record
operator|->
name|SiteCountArray
index|[
name|VK
index|]
operator|==
name|INSTR_PROF_NULLPTR
condition|)
return|return
literal|0
return|;
for|for
control|(
name|I
operator|=
literal|0
init|;
name|I
operator|<
name|Record
operator|->
name|Data
operator|->
name|NumValueSites
index|[
name|VK
index|]
condition|;
name|I
operator|++
control|)
name|S
operator|+=
name|Record
operator|->
name|SiteCountArray
index|[
name|VK
index|]
index|[
name|I
index|]
expr_stmt|;
return|return
name|S
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|getNumValueDataForSiteRT
parameter_list|(
specifier|const
name|void
modifier|*
name|R
parameter_list|,
name|uint32_t
name|VK
parameter_list|,
name|uint32_t
name|S
parameter_list|)
block|{
specifier|const
name|ValueProfRuntimeRecord
modifier|*
name|Record
init|=
operator|(
specifier|const
name|ValueProfRuntimeRecord
operator|*
operator|)
name|R
decl_stmt|;
return|return
name|Record
operator|->
name|SiteCountArray
index|[
name|VK
index|]
index|[
name|S
index|]
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|ValueProfRuntimeRecord
name|RTRecord
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ValueProfRecordClosure
name|RTRecordClosure
init|=
block|{
operator|&
name|RTRecord
block|,
name|INSTR_PROF_NULLPTR
block|,
comment|/* GetNumValueKinds */
name|getNumValueSitesRT
block|,
name|getNumValueDataRT
block|,
name|getNumValueDataForSiteRT
block|,
name|INSTR_PROF_NULLPTR
block|,
comment|/* RemapValueData */
name|INSTR_PROF_NULLPTR
block|,
comment|/* GetValueForSite, */
name|INSTR_PROF_NULLPTR
comment|/* AllocValueProfData */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uint32_t
name|initializeValueProfRuntimeRecord
parameter_list|(
specifier|const
name|__llvm_profile_data
modifier|*
name|Data
parameter_list|,
name|uint8_t
modifier|*
name|SiteCountArray
index|[]
parameter_list|)
block|{
name|unsigned
name|I
decl_stmt|,
name|J
decl_stmt|,
name|S
init|=
literal|0
decl_stmt|,
name|NumValueKinds
init|=
literal|0
decl_stmt|;
name|ValueProfNode
modifier|*
modifier|*
name|Nodes
init|=
operator|(
name|ValueProfNode
operator|*
operator|*
operator|)
name|Data
operator|->
name|Values
decl_stmt|;
name|RTRecord
operator|.
name|Data
operator|=
name|Data
expr_stmt|;
name|RTRecord
operator|.
name|SiteCountArray
operator|=
name|SiteCountArray
expr_stmt|;
for|for
control|(
name|I
operator|=
literal|0
init|;
name|I
operator|<=
name|IPVK_Last
condition|;
name|I
operator|++
control|)
block|{
name|uint16_t
name|N
init|=
name|Data
operator|->
name|NumValueSites
index|[
name|I
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|N
condition|)
continue|continue;
name|NumValueKinds
operator|++
expr_stmt|;
name|RTRecord
operator|.
name|NodesKind
index|[
name|I
index|]
operator|=
name|Nodes
condition|?
operator|&
name|Nodes
index|[
name|S
index|]
else|:
name|INSTR_PROF_NULLPTR
expr_stmt|;
for|for
control|(
name|J
operator|=
literal|0
init|;
name|J
operator|<
name|N
condition|;
name|J
operator|++
control|)
block|{
comment|/* Compute value count for each site. */
name|uint32_t
name|C
init|=
literal|0
decl_stmt|;
name|ValueProfNode
modifier|*
name|Site
init|=
name|Nodes
condition|?
name|RTRecord
operator|.
name|NodesKind
index|[
name|I
index|]
index|[
name|J
index|]
else|:
name|INSTR_PROF_NULLPTR
decl_stmt|;
while|while
condition|(
name|Site
condition|)
block|{
name|C
operator|++
expr_stmt|;
name|Site
operator|=
name|Site
operator|->
name|Next
expr_stmt|;
block|}
if|if
condition|(
name|C
operator|>
name|UCHAR_MAX
condition|)
name|C
operator|=
name|UCHAR_MAX
expr_stmt|;
name|RTRecord
operator|.
name|SiteCountArray
index|[
name|I
index|]
index|[
name|J
index|]
operator|=
name|C
expr_stmt|;
block|}
name|S
operator|+=
name|N
expr_stmt|;
block|}
return|return
name|NumValueKinds
return|;
block|}
end_function

begin_function
specifier|static
name|ValueProfNode
modifier|*
name|getNextNValueData
parameter_list|(
name|uint32_t
name|VK
parameter_list|,
name|uint32_t
name|Site
parameter_list|,
name|InstrProfValueData
modifier|*
name|Dst
parameter_list|,
name|ValueProfNode
modifier|*
name|StartNode
parameter_list|,
name|uint32_t
name|N
parameter_list|)
block|{
name|unsigned
name|I
decl_stmt|;
name|ValueProfNode
modifier|*
name|VNode
init|=
name|StartNode
condition|?
name|StartNode
else|:
name|RTRecord
operator|.
name|NodesKind
index|[
name|VK
index|]
index|[
name|Site
index|]
decl_stmt|;
for|for
control|(
name|I
operator|=
literal|0
init|;
name|I
operator|<
name|N
condition|;
name|I
operator|++
control|)
block|{
name|Dst
index|[
name|I
index|]
operator|.
name|Value
operator|=
name|VNode
operator|->
name|Value
expr_stmt|;
name|Dst
index|[
name|I
index|]
operator|.
name|Count
operator|=
name|VNode
operator|->
name|Count
expr_stmt|;
name|VNode
operator|=
name|VNode
operator|->
name|Next
expr_stmt|;
block|}
return|return
name|VNode
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|getValueProfDataSizeWrapper
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|getValueProfDataSize
argument_list|(
operator|&
name|RTRecordClosure
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|getNumValueDataForSiteWrapper
parameter_list|(
name|uint32_t
name|VK
parameter_list|,
name|uint32_t
name|S
parameter_list|)
block|{
return|return
name|getNumValueDataForSiteRT
argument_list|(
operator|&
name|RTRecord
argument_list|,
name|VK
argument_list|,
name|S
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|VPDataReaderType
name|TheVPDataReader
init|=
block|{
name|initializeValueProfRuntimeRecord
block|,
name|getValueProfRecordHeaderSize
block|,
name|getFirstValueProfRecord
block|,
name|getNumValueDataForSiteWrapper
block|,
name|getValueProfDataSizeWrapper
block|,
name|getNextNValueData
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|COMPILER_RT_VISIBILITY
name|VPDataReaderType
modifier|*
name|lprofGetVPDataReader
parameter_list|()
block|{
return|return
operator|&
name|TheVPDataReader
return|;
block|}
end_function

end_unit

