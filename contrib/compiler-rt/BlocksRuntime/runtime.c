begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * runtime.c  *  * Copyright 2008-2010 Apple, Inc. Permission is hereby granted, free of charge,  * to any person obtaining a copy of this software and associated documentation  * files (the "Software"), to deal in the Software without restriction,  * including without limitation the rights to use, copy, modify, merge, publish,  * distribute, sublicense, and/or sell copies of the Software, and to permit  * persons to whom the Software is furnished to do so, subject to the following  * conditions:  *   * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_include
include|#
directive|include
file|"Block_private.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AVAILABILITY_MACROS_H
end_ifdef

begin_include
include|#
directive|include
file|<AvailabilityMacros.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_AVAILABILITY_MACROS_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TARGET_CONDITIONALS_H
end_ifdef

begin_include
include|#
directive|include
file|<TargetConditionals.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TARGET_CONDITIONALS_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_OSATOMIC_COMPARE_AND_SWAP_INT
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_OSATOMIC_COMPARE_AND_SWAP_LONG
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBKERN_OSATOMIC_H
end_ifdef

begin_include
include|#
directive|include
file|<libkern/OSAtomic.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LIBKERN_OSATOMIC_H */
end_comment

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__WIN32__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_elif

begin_define
define|#
directive|define
name|_CRT_SECURE_NO_WARNINGS
value|1
end_define

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_function
specifier|static
name|__inline
name|bool
name|OSAtomicCompareAndSwapLong
parameter_list|(
name|long
name|oldl
parameter_list|,
name|long
name|newl
parameter_list|,
name|long
specifier|volatile
modifier|*
name|dst
parameter_list|)
block|{
comment|/* fixme barrier is overkill -- see objc-os.h */
name|long
name|original
init|=
name|InterlockedCompareExchange
argument_list|(
name|dst
argument_list|,
name|newl
argument_list|,
name|oldl
argument_list|)
decl_stmt|;
return|return
operator|(
name|original
operator|==
name|oldl
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|bool
name|OSAtomicCompareAndSwapInt
parameter_list|(
name|int
name|oldi
parameter_list|,
name|int
name|newi
parameter_list|,
name|int
specifier|volatile
modifier|*
name|dst
parameter_list|)
block|{
comment|/* fixme barrier is overkill -- see objc-os.h */
name|int
name|original
init|=
name|InterlockedCompareExchange
argument_list|(
name|dst
argument_list|,
name|newi
argument_list|,
name|oldi
argument_list|)
decl_stmt|;
return|return
operator|(
name|original
operator|==
name|oldi
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if the GCC atomic built-ins are available.  If we're on  * a 64-bit system, make sure we have an 8-byte atomic function  * available.  *  */
end_comment

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_SYNC_BOOL_COMPARE_AND_SWAP_INT
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SYNC_BOOL_COMPARE_AND_SWAP_LONG
argument_list|)
end_elif

begin_function
specifier|static
name|__inline
name|bool
name|OSAtomicCompareAndSwapLong
parameter_list|(
name|long
name|oldl
parameter_list|,
name|long
name|newl
parameter_list|,
name|long
specifier|volatile
modifier|*
name|dst
parameter_list|)
block|{
return|return
name|__sync_bool_compare_and_swap
argument_list|(
name|dst
argument_list|,
name|oldl
argument_list|,
name|newl
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|bool
name|OSAtomicCompareAndSwapInt
parameter_list|(
name|int
name|oldi
parameter_list|,
name|int
name|newi
parameter_list|,
name|int
specifier|volatile
modifier|*
name|dst
parameter_list|)
block|{
return|return
name|__sync_bool_compare_and_swap
argument_list|(
name|dst
argument_list|,
name|oldi
argument_list|,
name|newi
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|unknown atomic compare-and-swap primitive
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_OSATOMIC_COMPARE_AND_SWAP_INT&& HAVE_OSATOMIC_COMPARE_AND_SWAP_LONG */
end_comment

begin_comment
comment|/*  * Globals:  */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|_Block_copy_class
init|=
name|_NSConcreteMallocBlock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|_Block_copy_finalizing_class
init|=
name|_NSConcreteMallocBlock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_Block_copy_flag
init|=
name|BLOCK_NEEDS_FREE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_Byref_flag_initial_value
init|=
name|BLOCK_NEEDS_FREE
operator||
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|WANTS_ONE
init|=
operator|(
literal|1
operator|<<
literal|16
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|isGC
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internal Utilities:  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static unsigned long int latching_incr_long(unsigned long int *where) {     while (1) {         unsigned long int old_value = *(volatile unsigned long int *)where;         if ((old_value& BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) {             return BLOCK_REFCOUNT_MASK;         }         if (OSAtomicCompareAndSwapLong(old_value, old_value+1, (volatile long int *)where)) {             return old_value+1;         }     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* if 0 */
end_comment

begin_function
specifier|static
name|int
name|latching_incr_int
parameter_list|(
name|int
modifier|*
name|where
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|old_value
init|=
operator|*
operator|(
specifier|volatile
name|int
operator|*
operator|)
name|where
decl_stmt|;
if|if
condition|(
operator|(
name|old_value
operator|&
name|BLOCK_REFCOUNT_MASK
operator|)
operator|==
name|BLOCK_REFCOUNT_MASK
condition|)
block|{
return|return
name|BLOCK_REFCOUNT_MASK
return|;
block|}
if|if
condition|(
name|OSAtomicCompareAndSwapInt
argument_list|(
name|old_value
argument_list|,
name|old_value
operator|+
literal|1
argument_list|,
operator|(
specifier|volatile
name|int
operator|*
operator|)
name|where
argument_list|)
condition|)
block|{
return|return
name|old_value
operator|+
literal|1
return|;
block|}
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int latching_decr_long(unsigned long int *where) {     while (1) {         unsigned long int old_value = *(volatile int *)where;         if ((old_value& BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) {             return BLOCK_REFCOUNT_MASK;         }         if ((old_value& BLOCK_REFCOUNT_MASK) == 0) {             return 0;         }         if (OSAtomicCompareAndSwapLong(old_value, old_value-1, (volatile long int *)where)) {             return old_value-1;         }     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* if 0 */
end_comment

begin_function
specifier|static
name|int
name|latching_decr_int
parameter_list|(
name|int
modifier|*
name|where
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|old_value
init|=
operator|*
operator|(
specifier|volatile
name|int
operator|*
operator|)
name|where
decl_stmt|;
if|if
condition|(
operator|(
name|old_value
operator|&
name|BLOCK_REFCOUNT_MASK
operator|)
operator|==
name|BLOCK_REFCOUNT_MASK
condition|)
block|{
return|return
name|BLOCK_REFCOUNT_MASK
return|;
block|}
if|if
condition|(
operator|(
name|old_value
operator|&
name|BLOCK_REFCOUNT_MASK
operator|)
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|OSAtomicCompareAndSwapInt
argument_list|(
name|old_value
argument_list|,
name|old_value
operator|-
literal|1
argument_list|,
operator|(
specifier|volatile
name|int
operator|*
operator|)
name|where
argument_list|)
condition|)
block|{
return|return
name|old_value
operator|-
literal|1
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * GC support stub routines:  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_pragma
pragma|#
directive|pragma
name|mark
name|GC
name|Support
name|Routines
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* if 0 */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|_Block_alloc_default
parameter_list|(
specifier|const
name|unsigned
name|long
name|size
parameter_list|,
specifier|const
name|bool
name|initialCountIsOne
parameter_list|,
specifier|const
name|bool
name|isObject
parameter_list|)
block|{
return|return
name|malloc
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_Block_assign_default
parameter_list|(
name|void
modifier|*
name|value
parameter_list|,
name|void
modifier|*
modifier|*
name|destptr
parameter_list|)
block|{
operator|*
name|destptr
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_Block_setHasRefcount_default
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
specifier|const
name|bool
name|hasRefcount
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|_Block_do_nothing
parameter_list|(
specifier|const
name|void
modifier|*
name|aBlock
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|_Block_retain_object_default
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ptr
condition|)
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|_Block_release_object_default
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ptr
condition|)
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|_Block_assign_weak_default
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|void
modifier|*
name|dest
parameter_list|)
block|{
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|dest
operator|=
operator|(
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_Block_memmove_default
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|memmove
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_Block_memmove_gc_broken
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|destp
init|=
operator|(
name|void
operator|*
operator|*
operator|)
name|dest
decl_stmt|;
name|void
modifier|*
modifier|*
name|srcp
init|=
operator|(
name|void
operator|*
operator|*
operator|)
name|src
decl_stmt|;
while|while
condition|(
name|size
condition|)
block|{
name|_Block_assign_default
argument_list|(
operator|*
name|srcp
argument_list|,
name|destp
argument_list|)
expr_stmt|;
name|destp
operator|++
expr_stmt|;
name|srcp
operator|++
expr_stmt|;
name|size
operator|-=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * GC support callout functions - initially set to stub routines:  */
end_comment

begin_function_decl
specifier|static
name|void
modifier|*
function_decl|(
modifier|*
name|_Block_allocator
function_decl|)
parameter_list|(
specifier|const
name|unsigned
name|long
parameter_list|,
specifier|const
name|bool
name|isOne
parameter_list|,
specifier|const
name|bool
name|isObject
parameter_list|)
init|=
name|_Block_alloc_default
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|_Block_deallocator
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
init|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
operator|(
specifier|const
name|void
operator|*
operator|)
operator|)
name|free
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|_Block_assign
function_decl|)
parameter_list|(
name|void
modifier|*
name|value
parameter_list|,
name|void
modifier|*
modifier|*
name|destptr
parameter_list|)
init|=
name|_Block_assign_default
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|_Block_setHasRefcount
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
specifier|const
name|bool
name|hasRefcount
parameter_list|)
init|=
name|_Block_setHasRefcount_default
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|_Block_retain_object
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
init|=
name|_Block_retain_object_default
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|_Block_release_object
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
init|=
name|_Block_release_object_default
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|_Block_assign_weak
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
name|dest
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
init|=
name|_Block_assign_weak_default
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|_Block_memmove
function_decl|)
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
init|=
name|_Block_memmove_default
function_decl|;
end_function_decl

begin_comment
comment|/*  * GC support SPI functions - called from ObjC runtime and CoreFoundation:  */
end_comment

begin_comment
comment|/* Public SPI  * Called from objc-auto to turn on GC.  * version 3, 4 arg, but changed 1st arg  */
end_comment

begin_function
name|void
name|_Block_use_GC
parameter_list|(
name|void
modifier|*
function_decl|(
modifier|*
name|alloc
function_decl|)
parameter_list|(
specifier|const
name|unsigned
name|long
parameter_list|,
specifier|const
name|bool
name|isOne
parameter_list|,
specifier|const
name|bool
name|isObject
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|setHasRefcount
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|bool
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|gc_assign
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|gc_assign_weak
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|gc_memmove
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|)
parameter_list|)
block|{
name|isGC
operator|=
name|true
expr_stmt|;
name|_Block_allocator
operator|=
name|alloc
expr_stmt|;
name|_Block_deallocator
operator|=
name|_Block_do_nothing
expr_stmt|;
name|_Block_assign
operator|=
name|gc_assign
expr_stmt|;
name|_Block_copy_flag
operator|=
name|BLOCK_IS_GC
expr_stmt|;
name|_Block_copy_class
operator|=
name|_NSConcreteAutoBlock
expr_stmt|;
comment|/* blocks with ctors& dtors need to have the dtor run from a class with a finalizer */
name|_Block_copy_finalizing_class
operator|=
name|_NSConcreteFinalizingBlock
expr_stmt|;
name|_Block_setHasRefcount
operator|=
name|setHasRefcount
expr_stmt|;
name|_Byref_flag_initial_value
operator|=
name|BLOCK_IS_GC
expr_stmt|;
comment|// no refcount
name|_Block_retain_object
operator|=
name|_Block_do_nothing
expr_stmt|;
name|_Block_release_object
operator|=
name|_Block_do_nothing
expr_stmt|;
name|_Block_assign_weak
operator|=
name|gc_assign_weak
expr_stmt|;
name|_Block_memmove
operator|=
name|gc_memmove
expr_stmt|;
block|}
end_function

begin_comment
comment|/* transitional */
end_comment

begin_function
name|void
name|_Block_use_GC5
parameter_list|(
name|void
modifier|*
function_decl|(
modifier|*
name|alloc
function_decl|)
parameter_list|(
specifier|const
name|unsigned
name|long
parameter_list|,
specifier|const
name|bool
name|isOne
parameter_list|,
specifier|const
name|bool
name|isObject
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|setHasRefcount
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|bool
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|gc_assign
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|gc_assign_weak
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
comment|/* until objc calls _Block_use_GC it will call us; supply a broken internal memmove implementation until then */
name|_Block_use_GC
argument_list|(
name|alloc
argument_list|,
name|setHasRefcount
argument_list|,
name|gc_assign
argument_list|,
name|gc_assign_weak
argument_list|,
name|_Block_memmove_gc_broken
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called from objc-auto to alternatively turn on retain/release.  * Prior to this the only "object" support we can provide is for those  * super special objects that live in libSystem, namely dispatch queues.  * Blocks and Block_byrefs have their own special entry points.  *  */
end_comment

begin_function
name|void
name|_Block_use_RR
parameter_list|(
name|void
function_decl|(
modifier|*
name|retain
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|release
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|_Block_retain_object
operator|=
name|retain
expr_stmt|;
name|_Block_release_object
operator|=
name|release
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Internal Support routines for copying:  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_pragma
pragma|#
directive|pragma
name|mark
name|Copy
name|/
name|Release
name|support
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* if 0 */
end_comment

begin_comment
comment|/* Copy, or bump refcount, of a block.  If really copying, call the copy helper if present. */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|_Block_copy_internal
parameter_list|(
specifier|const
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|int
name|flags
parameter_list|)
block|{
name|struct
name|Block_layout
modifier|*
name|aBlock
decl_stmt|;
specifier|const
name|bool
name|wantsOne
init|=
operator|(
name|WANTS_ONE
operator|&
name|flags
operator|)
operator|==
name|WANTS_ONE
decl_stmt|;
comment|//printf("_Block_copy_internal(%p, %x)\n", arg, flags);
if|if
condition|(
operator|!
name|arg
condition|)
return|return
name|NULL
return|;
comment|// The following would be better done as a switch statement
name|aBlock
operator|=
operator|(
expr|struct
name|Block_layout
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|aBlock
operator|->
name|flags
operator|&
name|BLOCK_NEEDS_FREE
condition|)
block|{
comment|// latches on high
name|latching_incr_int
argument_list|(
operator|&
name|aBlock
operator|->
name|flags
argument_list|)
expr_stmt|;
return|return
name|aBlock
return|;
block|}
elseif|else
if|if
condition|(
name|aBlock
operator|->
name|flags
operator|&
name|BLOCK_IS_GC
condition|)
block|{
comment|// GC refcounting is expensive so do most refcounting here.
if|if
condition|(
name|wantsOne
operator|&&
operator|(
operator|(
name|latching_incr_int
argument_list|(
operator|&
name|aBlock
operator|->
name|flags
argument_list|)
operator|&
name|BLOCK_REFCOUNT_MASK
operator|)
operator|==
literal|1
operator|)
condition|)
block|{
comment|// Tell collector to hang on this - it will bump the GC refcount version
name|_Block_setHasRefcount
argument_list|(
name|aBlock
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
return|return
name|aBlock
return|;
block|}
elseif|else
if|if
condition|(
name|aBlock
operator|->
name|flags
operator|&
name|BLOCK_IS_GLOBAL
condition|)
block|{
return|return
name|aBlock
return|;
block|}
comment|// Its a stack block.  Make a copy.
if|if
condition|(
operator|!
name|isGC
condition|)
block|{
name|struct
name|Block_layout
modifier|*
name|result
init|=
name|malloc
argument_list|(
name|aBlock
operator|->
name|descriptor
operator|->
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
return|return
operator|(
name|void
operator|*
operator|)
literal|0
return|;
name|memmove
argument_list|(
name|result
argument_list|,
name|aBlock
argument_list|,
name|aBlock
operator|->
name|descriptor
operator|->
name|size
argument_list|)
expr_stmt|;
comment|// bitcopy first
comment|// reset refcount
name|result
operator|->
name|flags
operator|&=
operator|~
operator|(
name|BLOCK_REFCOUNT_MASK
operator|)
expr_stmt|;
comment|// XXX not needed
name|result
operator|->
name|flags
operator||=
name|BLOCK_NEEDS_FREE
operator||
literal|1
expr_stmt|;
name|result
operator|->
name|isa
operator|=
name|_NSConcreteMallocBlock
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|flags
operator|&
name|BLOCK_HAS_COPY_DISPOSE
condition|)
block|{
comment|//printf("calling block copy helper %p(%p, %p)...\n", aBlock->descriptor->copy, result, aBlock);
call|(
modifier|*
name|aBlock
operator|->
name|descriptor
operator|->
name|copy
call|)
argument_list|(
name|result
argument_list|,
name|aBlock
argument_list|)
expr_stmt|;
comment|// do fixup
block|}
return|return
name|result
return|;
block|}
else|else
block|{
comment|// Under GC want allocation with refcount 1 so we ask for "true" if wantsOne
comment|// This allows the copy helper routines to make non-refcounted block copies under GC
name|unsigned
name|long
name|int
name|flags
init|=
name|aBlock
operator|->
name|flags
decl_stmt|;
name|bool
name|hasCTOR
init|=
operator|(
name|flags
operator|&
name|BLOCK_HAS_CTOR
operator|)
operator|!=
literal|0
decl_stmt|;
name|struct
name|Block_layout
modifier|*
name|result
init|=
name|_Block_allocator
argument_list|(
name|aBlock
operator|->
name|descriptor
operator|->
name|size
argument_list|,
name|wantsOne
argument_list|,
name|hasCTOR
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
return|return
operator|(
name|void
operator|*
operator|)
literal|0
return|;
name|memmove
argument_list|(
name|result
argument_list|,
name|aBlock
argument_list|,
name|aBlock
operator|->
name|descriptor
operator|->
name|size
argument_list|)
expr_stmt|;
comment|// bitcopy first
comment|// reset refcount
comment|// if we copy a malloc block to a GC block then we need to clear NEEDS_FREE.
name|flags
operator|&=
operator|~
operator|(
name|BLOCK_NEEDS_FREE
operator||
name|BLOCK_REFCOUNT_MASK
operator|)
expr_stmt|;
comment|// XXX not needed
if|if
condition|(
name|wantsOne
condition|)
name|flags
operator||=
name|BLOCK_IS_GC
operator||
literal|1
expr_stmt|;
else|else
name|flags
operator||=
name|BLOCK_IS_GC
expr_stmt|;
name|result
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BLOCK_HAS_COPY_DISPOSE
condition|)
block|{
comment|//printf("calling block copy helper...\n");
call|(
modifier|*
name|aBlock
operator|->
name|descriptor
operator|->
name|copy
call|)
argument_list|(
name|result
argument_list|,
name|aBlock
argument_list|)
expr_stmt|;
comment|// do fixup
block|}
if|if
condition|(
name|hasCTOR
condition|)
block|{
name|result
operator|->
name|isa
operator|=
name|_NSConcreteFinalizingBlock
expr_stmt|;
block|}
else|else
block|{
name|result
operator|->
name|isa
operator|=
name|_NSConcreteAutoBlock
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Runtime entry points for maintaining the sharing knowledge of byref data blocks.  *  * A closure has been copied and its fixup routine is asking us to fix up the reference to the shared byref data  * Closures that aren't copied must still work, so everyone always accesses variables after dereferencing the forwarding ptr.  * We ask if the byref pointer that we know about has already been copied to the heap, and if so, increment it.  * Otherwise we need to copy it and update the stack forwarding pointer  * XXX We need to account for weak/nonretained read-write barriers.  */
end_comment

begin_function
specifier|static
name|void
name|_Block_byref_assign_copy
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|int
name|flags
parameter_list|)
block|{
name|struct
name|Block_byref
modifier|*
modifier|*
name|destp
init|=
operator|(
expr|struct
name|Block_byref
operator|*
operator|*
operator|)
name|dest
decl_stmt|;
name|struct
name|Block_byref
modifier|*
name|src
init|=
operator|(
expr|struct
name|Block_byref
operator|*
operator|)
name|arg
decl_stmt|;
comment|//printf("_Block_byref_assign_copy called, byref destp %p, src %p, flags %x\n", destp, src, flags);
comment|//printf("src dump: %s\n", _Block_byref_dump(src));
if|if
condition|(
name|src
operator|->
name|forwarding
operator|->
name|flags
operator|&
name|BLOCK_IS_GC
condition|)
block|{
empty_stmt|;
comment|// don't need to do any more work
block|}
elseif|else
if|if
condition|(
operator|(
name|src
operator|->
name|forwarding
operator|->
name|flags
operator|&
name|BLOCK_REFCOUNT_MASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|//printf("making copy\n");
comment|// src points to stack
name|bool
name|isWeak
init|=
operator|(
operator|(
name|flags
operator|&
operator|(
name|BLOCK_FIELD_IS_BYREF
operator||
name|BLOCK_FIELD_IS_WEAK
operator|)
operator|)
operator|==
operator|(
name|BLOCK_FIELD_IS_BYREF
operator||
name|BLOCK_FIELD_IS_WEAK
operator|)
operator|)
decl_stmt|;
comment|// if its weak ask for an object (only matters under GC)
name|struct
name|Block_byref
modifier|*
name|copy
init|=
operator|(
expr|struct
name|Block_byref
operator|*
operator|)
name|_Block_allocator
argument_list|(
name|src
operator|->
name|size
argument_list|,
name|false
argument_list|,
name|isWeak
argument_list|)
decl_stmt|;
name|copy
operator|->
name|flags
operator|=
name|src
operator|->
name|flags
operator||
name|_Byref_flag_initial_value
expr_stmt|;
comment|// non-GC one for caller, one for stack
name|copy
operator|->
name|forwarding
operator|=
name|copy
expr_stmt|;
comment|// patch heap copy to point to itself (skip write-barrier)
name|src
operator|->
name|forwarding
operator|=
name|copy
expr_stmt|;
comment|// patch stack to point to heap copy
name|copy
operator|->
name|size
operator|=
name|src
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|isWeak
condition|)
block|{
name|copy
operator|->
name|isa
operator|=
operator|&
name|_NSConcreteWeakBlockVariable
expr_stmt|;
comment|// mark isa field so it gets weak scanning
block|}
if|if
condition|(
name|src
operator|->
name|flags
operator|&
name|BLOCK_HAS_COPY_DISPOSE
condition|)
block|{
comment|// Trust copy helper to copy everything of interest
comment|// If more than one field shows up in a byref block this is wrong XXX
name|copy
operator|->
name|byref_keep
operator|=
name|src
operator|->
name|byref_keep
expr_stmt|;
name|copy
operator|->
name|byref_destroy
operator|=
name|src
operator|->
name|byref_destroy
expr_stmt|;
call|(
modifier|*
name|src
operator|->
name|byref_keep
call|)
argument_list|(
name|copy
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// just bits.  Blast 'em using _Block_memmove in case they're __strong
name|_Block_memmove
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|copy
operator|->
name|byref_keep
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|src
operator|->
name|byref_keep
argument_list|,
name|src
operator|->
name|size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|Block_byref_header
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// already copied to heap
elseif|else
if|if
condition|(
operator|(
name|src
operator|->
name|forwarding
operator|->
name|flags
operator|&
name|BLOCK_NEEDS_FREE
operator|)
operator|==
name|BLOCK_NEEDS_FREE
condition|)
block|{
name|latching_incr_int
argument_list|(
operator|&
name|src
operator|->
name|forwarding
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
comment|// assign byref data block pointer into new Block
name|_Block_assign
argument_list|(
name|src
operator|->
name|forwarding
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|destp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Old compiler SPI
end_comment

begin_function
specifier|static
name|void
name|_Block_byref_release
parameter_list|(
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|Block_byref
modifier|*
name|shared_struct
init|=
operator|(
expr|struct
name|Block_byref
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|refcount
decl_stmt|;
comment|// dereference the forwarding pointer since the compiler isn't doing this anymore (ever?)
name|shared_struct
operator|=
name|shared_struct
operator|->
name|forwarding
expr_stmt|;
comment|//printf("_Block_byref_release %p called, flags are %x\n", shared_struct, shared_struct->flags);
comment|// To support C++ destructors under GC we arrange for there to be a finalizer for this
comment|// by using an isa that directs the code to a finalizer that calls the byref_destroy method.
if|if
condition|(
operator|(
name|shared_struct
operator|->
name|flags
operator|&
name|BLOCK_NEEDS_FREE
operator|)
operator|==
literal|0
condition|)
block|{
return|return;
comment|// stack or GC or global
block|}
name|refcount
operator|=
name|shared_struct
operator|->
name|flags
operator|&
name|BLOCK_REFCOUNT_MASK
expr_stmt|;
if|if
condition|(
name|refcount
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"_Block_byref_release: Block byref data structure at %p underflowed\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|latching_decr_int
argument_list|(
operator|&
name|shared_struct
operator|->
name|flags
argument_list|)
operator|&
name|BLOCK_REFCOUNT_MASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|//printf("disposing of heap based byref block\n");
if|if
condition|(
name|shared_struct
operator|->
name|flags
operator|&
name|BLOCK_HAS_COPY_DISPOSE
condition|)
block|{
comment|//printf("calling out to helper\n");
call|(
modifier|*
name|shared_struct
operator|->
name|byref_destroy
call|)
argument_list|(
name|shared_struct
argument_list|)
expr_stmt|;
block|}
name|_Block_deallocator
argument_list|(
operator|(
expr|struct
name|Block_layout
operator|*
operator|)
name|shared_struct
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  * API supporting SPI  * _Block_copy, _Block_release, and (old) _Block_destroy  *  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_pragma
pragma|#
directive|pragma
name|mark
name|SPI
name|/
name|API
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* if 0 */
end_comment

begin_function
name|void
modifier|*
name|_Block_copy
parameter_list|(
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|_Block_copy_internal
argument_list|(
name|arg
argument_list|,
name|WANTS_ONE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// API entry point to release a copied Block
end_comment

begin_function
name|void
name|_Block_release
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|Block_layout
modifier|*
name|aBlock
init|=
operator|(
expr|struct
name|Block_layout
operator|*
operator|)
name|arg
decl_stmt|;
name|int32_t
name|newCount
decl_stmt|;
if|if
condition|(
operator|!
name|aBlock
condition|)
return|return;
name|newCount
operator|=
name|latching_decr_int
argument_list|(
operator|&
name|aBlock
operator|->
name|flags
argument_list|)
operator|&
name|BLOCK_REFCOUNT_MASK
expr_stmt|;
if|if
condition|(
name|newCount
operator|>
literal|0
condition|)
return|return;
comment|// Hit zero
if|if
condition|(
name|aBlock
operator|->
name|flags
operator|&
name|BLOCK_IS_GC
condition|)
block|{
comment|// Tell GC we no longer have our own refcounts.  GC will decr its refcount
comment|// and unless someone has done a CFRetain or marked it uncollectable it will
comment|// now be subject to GC reclamation.
name|_Block_setHasRefcount
argument_list|(
name|aBlock
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aBlock
operator|->
name|flags
operator|&
name|BLOCK_NEEDS_FREE
condition|)
block|{
if|if
condition|(
name|aBlock
operator|->
name|flags
operator|&
name|BLOCK_HAS_COPY_DISPOSE
condition|)
call|(
modifier|*
name|aBlock
operator|->
name|descriptor
operator|->
name|dispose
call|)
argument_list|(
name|aBlock
argument_list|)
expr_stmt|;
name|_Block_deallocator
argument_list|(
name|aBlock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aBlock
operator|->
name|flags
operator|&
name|BLOCK_IS_GLOBAL
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Block_release called upon a stack Block: %p, ignored\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|aBlock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// Old Compiler SPI point to release a copied Block used by the compiler in dispose helpers
end_comment

begin_function
specifier|static
name|void
name|_Block_destroy
parameter_list|(
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|Block_layout
modifier|*
name|aBlock
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
return|return;
name|aBlock
operator|=
operator|(
expr|struct
name|Block_layout
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|aBlock
operator|->
name|flags
operator|&
name|BLOCK_IS_GC
condition|)
block|{
comment|// assert(aBlock->Block_flags& BLOCK_HAS_CTOR);
return|return;
comment|// ignore, we are being called because of a DTOR
block|}
name|_Block_release
argument_list|(
name|aBlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  * SPI used by other layers  *  */
end_comment

begin_comment
comment|// SPI, also internal.  Called from NSAutoBlock only under GC
end_comment

begin_function
name|void
modifier|*
name|_Block_copy_collectable
parameter_list|(
specifier|const
name|void
modifier|*
name|aBlock
parameter_list|)
block|{
return|return
name|_Block_copy_internal
argument_list|(
name|aBlock
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// SPI
end_comment

begin_function
name|unsigned
name|long
name|int
name|Block_size
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
operator|(
expr|struct
name|Block_layout
operator|*
operator|)
name|arg
operator|)
operator|->
name|descriptor
operator|->
name|size
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_pragma
pragma|#
directive|pragma
name|mark
name|Compiler
name|SPI
name|entry
name|points
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* if 0 */
end_comment

begin_comment
comment|/*******************************************************  Entry points used by the compiler - the real API!   A Block can reference four different kinds of things that require help when the Block is copied to the heap. 1) C++ stack based objects 2) References to Objective-C objects 3) Other Blocks 4) __block variables  In these cases helper functions are synthesized by the compiler for use in Block_copy and Block_release, called the copy and dispose helpers.  The copy helper emits a call to the C++ const copy constructor for C++ stack based objects and for the rest calls into the runtime support function _Block_object_assign.  The dispose helper has a call to the C++ destructor for case 1 and a call into _Block_object_dispose for the rest.  The flags parameter of _Block_object_assign and _Block_object_dispose is set to 	* BLOCK_FIELD_IS_OBJECT (3), for the case of an Objective-C Object, 	* BLOCK_FIELD_IS_BLOCK (7), for the case of another Block, and 	* BLOCK_FIELD_IS_BYREF (8), for the case of a __block variable. If the __block variable is marked weak the compiler also or's in BLOCK_FIELD_IS_WEAK (16).  So the Block copy/dispose helpers should only ever generate the four flag values of 3, 7, 8, and 24.  When  a __block variable is either a C++ object, an Objective-C object, or another Block then the compiler also generates copy/dispose helper functions.  Similarly to the Block copy helper, the "__block" copy helper (formerly and still a.k.a. "byref" copy helper) will do a C++ copy constructor (not a const one though!) and the dispose helper will do the destructor.  And similarly the helpers will call into the same two support functions with the same values for objects and Blocks with the additional BLOCK_BYREF_CALLER (128) bit of information supplied.  So the __block copy/dispose helpers will generate flag values of 3 or 7 for objects and Blocks respectively, with BLOCK_FIELD_IS_WEAK (16) or'ed as appropriate and always 128 or'd in, for the following set of possibilities: 	__block id                   128+3         __weak block id              128+3+16 	__block (^Block)             128+7 	__weak __block (^Block)      128+7+16          The implementation of the two routines would be improved by switch statements enumerating the eight cases.  ********************************************************/
end_comment

begin_comment
comment|/*  * When Blocks or Block_byrefs hold objects then their copy routine helpers use this entry point  * to do the assignment.  */
end_comment

begin_function
name|void
name|_Block_object_assign
parameter_list|(
name|void
modifier|*
name|destAddr
parameter_list|,
specifier|const
name|void
modifier|*
name|object
parameter_list|,
specifier|const
name|int
name|flags
parameter_list|)
block|{
comment|//printf("_Block_object_assign(*%p, %p, %x)\n", destAddr, object, flags);
if|if
condition|(
operator|(
name|flags
operator|&
name|BLOCK_BYREF_CALLER
operator|)
operator|==
name|BLOCK_BYREF_CALLER
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|BLOCK_FIELD_IS_WEAK
operator|)
operator|==
name|BLOCK_FIELD_IS_WEAK
condition|)
block|{
name|_Block_assign_weak
argument_list|(
name|object
argument_list|,
name|destAddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// do *not* retain or *copy* __block variables whatever they are
name|_Block_assign
argument_list|(
operator|(
name|void
operator|*
operator|)
name|object
argument_list|,
name|destAddr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|BLOCK_FIELD_IS_BYREF
operator|)
operator|==
name|BLOCK_FIELD_IS_BYREF
condition|)
block|{
comment|// copying a __block reference from the stack Block to the heap
comment|// flags will indicate if it holds a __weak reference and needs a special isa
name|_Block_byref_assign_copy
argument_list|(
name|destAddr
argument_list|,
name|object
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
comment|// (this test must be before next one)
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|BLOCK_FIELD_IS_BLOCK
operator|)
operator|==
name|BLOCK_FIELD_IS_BLOCK
condition|)
block|{
comment|// copying a Block declared variable from the stack Block to the heap
name|_Block_assign
argument_list|(
name|_Block_copy_internal
argument_list|(
name|object
argument_list|,
name|flags
argument_list|)
argument_list|,
name|destAddr
argument_list|)
expr_stmt|;
block|}
comment|// (this test must be after previous one)
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|BLOCK_FIELD_IS_OBJECT
operator|)
operator|==
name|BLOCK_FIELD_IS_OBJECT
condition|)
block|{
comment|//printf("retaining object at %p\n", object);
name|_Block_retain_object
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|//printf("done retaining object at %p\n", object);
name|_Block_assign
argument_list|(
operator|(
name|void
operator|*
operator|)
name|object
argument_list|,
name|destAddr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// When Blocks or Block_byrefs hold objects their destroy helper routines call this entry point
end_comment

begin_comment
comment|// to help dispose of the contents
end_comment

begin_comment
comment|// Used initially only for __attribute__((NSObject)) marked pointers.
end_comment

begin_function
name|void
name|_Block_object_dispose
parameter_list|(
specifier|const
name|void
modifier|*
name|object
parameter_list|,
specifier|const
name|int
name|flags
parameter_list|)
block|{
comment|//printf("_Block_object_dispose(%p, %x)\n", object, flags);
if|if
condition|(
name|flags
operator|&
name|BLOCK_FIELD_IS_BYREF
condition|)
block|{
comment|// get rid of the __block data structure held in a Block
name|_Block_byref_release
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|BLOCK_FIELD_IS_BLOCK
operator||
name|BLOCK_BYREF_CALLER
operator|)
operator|)
operator|==
name|BLOCK_FIELD_IS_BLOCK
condition|)
block|{
comment|// get rid of a referenced Block held by this Block
comment|// (ignore __block Block variables, compiler doesn't need to call us)
name|_Block_destroy
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|BLOCK_FIELD_IS_WEAK
operator||
name|BLOCK_FIELD_IS_BLOCK
operator||
name|BLOCK_BYREF_CALLER
operator|)
operator|)
operator|==
name|BLOCK_FIELD_IS_OBJECT
condition|)
block|{
comment|// get rid of a referenced object held by this Block
comment|// (ignore __block object variables, compiler doesn't need to call us)
name|_Block_release_object
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Debugging support:  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_pragma
pragma|#
directive|pragma
name|mark
name|Debugging
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* if 0 */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|_Block_dump
parameter_list|(
specifier|const
name|void
modifier|*
name|block
parameter_list|)
block|{
name|struct
name|Block_layout
modifier|*
name|closure
init|=
operator|(
expr|struct
name|Block_layout
operator|*
operator|)
name|block
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
literal|512
index|]
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|buffer
decl_stmt|;
if|if
condition|(
name|closure
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"NULL passed to _Block_dump\n"
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|closure
operator|->
name|flags
operator|&
name|BLOCK_HAS_DESCRIPTOR
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Block compiled by obsolete compiler, please recompile source for this Block\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"^%p (new layout) =\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|closure
argument_list|)
expr_stmt|;
if|if
condition|(
name|closure
operator|->
name|isa
operator|==
name|NULL
condition|)
block|{
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"isa: NULL\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|closure
operator|->
name|isa
operator|==
name|_NSConcreteStackBlock
condition|)
block|{
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"isa: stack Block\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|closure
operator|->
name|isa
operator|==
name|_NSConcreteMallocBlock
condition|)
block|{
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"isa: malloc heap Block\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|closure
operator|->
name|isa
operator|==
name|_NSConcreteAutoBlock
condition|)
block|{
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"isa: GC heap Block\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|closure
operator|->
name|isa
operator|==
name|_NSConcreteGlobalBlock
condition|)
block|{
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"isa: global Block\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|closure
operator|->
name|isa
operator|==
name|_NSConcreteFinalizingBlock
condition|)
block|{
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"isa: finalizing Block\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"isa?: %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|closure
operator|->
name|isa
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"flags:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|closure
operator|->
name|flags
operator|&
name|BLOCK_HAS_DESCRIPTOR
condition|)
block|{
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|" HASDESCRIPTOR"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|closure
operator|->
name|flags
operator|&
name|BLOCK_NEEDS_FREE
condition|)
block|{
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|" FREEME"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|closure
operator|->
name|flags
operator|&
name|BLOCK_IS_GC
condition|)
block|{
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|" ISGC"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|closure
operator|->
name|flags
operator|&
name|BLOCK_HAS_COPY_DISPOSE
condition|)
block|{
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|" HASHELP"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|closure
operator|->
name|flags
operator|&
name|BLOCK_HAS_CTOR
condition|)
block|{
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|" HASCTOR"
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"\nrefcount: %u\n"
argument_list|,
name|closure
operator|->
name|flags
operator|&
name|BLOCK_REFCOUNT_MASK
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"invoke: %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|closure
operator|->
name|invoke
argument_list|)
expr_stmt|;
block|{
name|struct
name|Block_descriptor
modifier|*
name|dp
init|=
name|closure
operator|->
name|descriptor
decl_stmt|;
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"descriptor: %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"descriptor->reserved: %lu\n"
argument_list|,
name|dp
operator|->
name|reserved
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"descriptor->size: %lu\n"
argument_list|,
name|dp
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|closure
operator|->
name|flags
operator|&
name|BLOCK_HAS_COPY_DISPOSE
condition|)
block|{
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"descriptor->copy helper: %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|dp
operator|->
name|copy
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"descriptor->dispose helper: %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|dp
operator|->
name|dispose
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buffer
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|_Block_byref_dump
parameter_list|(
name|struct
name|Block_byref
modifier|*
name|src
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|buffer
decl_stmt|;
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"byref data block %p contents:\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|src
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"  forwarding: %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|src
operator|->
name|forwarding
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"  flags: 0x%x\n"
argument_list|,
name|src
operator|->
name|flags
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"  size: %d\n"
argument_list|,
name|src
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|flags
operator|&
name|BLOCK_HAS_COPY_DISPOSE
condition|)
block|{
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"  copy helper: %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|src
operator|->
name|byref_keep
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"  dispose helper: %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|src
operator|->
name|byref_destroy
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
return|;
block|}
end_function

end_unit

