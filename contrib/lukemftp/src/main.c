begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: main.c,v 1.94 2005/05/13 05:03:49 lukem Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1996-2004 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Luke Mewburn.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the NetBSD  *	Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1985, 1989, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (C) 1997 and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__COPYRIGHT
argument_list|(
literal|"@(#) Copyright (c) 1985, 1989, 1993, 1994\n\ 	The Regents of the University of California.  All rights reserved.\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|static char sccsid[] = "@(#)main.c	8.6 (Berkeley) 10/9/94";
else|#
directive|else
end_else

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: main.c,v 1.94 2005/05/13 05:03:49 lukem Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * FTP User Program -- Command Interface.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_define
define|#
directive|define
name|GLOBAL
end_define

begin_comment
comment|/* force GLOBAL decls in ftp_var.h to be declared */
end_comment

begin_include
include|#
directive|include
file|"ftp_var.h"
end_include

begin_define
define|#
directive|define
name|FTP_PROXY
value|"ftp_proxy"
end_define

begin_comment
comment|/* env var with FTP proxy location */
end_comment

begin_define
define|#
directive|define
name|HTTP_PROXY
value|"http_proxy"
end_define

begin_comment
comment|/* env var with HTTP proxy location */
end_comment

begin_define
define|#
directive|define
name|NO_PROXY
value|"no_proxy"
end_define

begin_comment
comment|/* env var with list of non-proxied 					 * hosts, comma or space separated */
end_comment

begin_function_decl
specifier|static
name|void
name|setupoption
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|ch
decl_stmt|,
name|rval
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|anonuser
decl_stmt|,
modifier|*
name|anonpass
decl_stmt|,
modifier|*
name|upload_path
decl_stmt|;
name|int
name|dumbterm
decl_stmt|,
name|s
decl_stmt|,
name|len
decl_stmt|,
name|isupload
decl_stmt|;
name|socklen_t
name|slen
decl_stmt|;
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|setprogname
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sigint_raised
operator|=
literal|0
expr_stmt|;
name|ftpport
operator|=
literal|"ftp"
expr_stmt|;
name|httpport
operator|=
literal|"http"
expr_stmt|;
name|gateport
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|getenv
argument_list|(
literal|"FTPSERVERPORT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|gateport
operator|=
name|cp
expr_stmt|;
else|else
name|gateport
operator|=
literal|"ftpgate"
expr_stmt|;
name|doglob
operator|=
literal|1
expr_stmt|;
name|interactive
operator|=
literal|1
expr_stmt|;
name|autologin
operator|=
literal|1
expr_stmt|;
name|passivemode
operator|=
literal|1
expr_stmt|;
name|activefallback
operator|=
literal|1
expr_stmt|;
name|preserve
operator|=
literal|1
expr_stmt|;
name|verbose
operator|=
literal|0
expr_stmt|;
name|progress
operator|=
literal|0
expr_stmt|;
name|gatemode
operator|=
literal|0
expr_stmt|;
name|data
operator|=
operator|-
literal|1
expr_stmt|;
name|outfile
operator|=
name|NULL
expr_stmt|;
name|restartautofetch
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_EDITCOMPLETE
name|editing
operator|=
literal|0
expr_stmt|;
name|el
operator|=
name|NULL
expr_stmt|;
name|hist
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|bytes
operator|=
literal|0
expr_stmt|;
name|mark
operator|=
name|HASHBYTES
expr_stmt|;
name|rate_get
operator|=
literal|0
expr_stmt|;
name|rate_get_incr
operator|=
name|DEFAULTINCR
expr_stmt|;
name|rate_put
operator|=
literal|0
expr_stmt|;
name|rate_put_incr
operator|=
name|DEFAULTINCR
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|epsv4
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|epsv4
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|epsv4bad
operator|=
literal|0
expr_stmt|;
name|upload_path
operator|=
name|NULL
expr_stmt|;
name|isupload
operator|=
literal|0
expr_stmt|;
name|reply_callback
operator|=
name|NULL
expr_stmt|;
name|family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|netrc
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|getenv
argument_list|(
literal|"NETRC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
operator|&&
name|strlcpy
argument_list|(
name|netrc
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|netrc
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|netrc
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"$NETRC `%s': %s"
argument_list|,
name|cp
argument_list|,
name|strerror
argument_list|(
name|ENAMETOOLONG
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Get the default socket buffer sizes if we don't already have them. 	 * It doesn't matter which socket we do this to, because on the first 	 * call no socket buffer sizes will have been modified, so we are 	 * guaranteed to get the system defaults. 	 */
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't create socket"
argument_list|)
expr_stmt|;
name|slen
operator|=
sizeof|sizeof
argument_list|(
name|rcvbuf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|rcvbuf_size
argument_list|,
operator|&
name|slen
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"unable to get default rcvbuf size"
argument_list|)
expr_stmt|;
name|slen
operator|=
sizeof|sizeof
argument_list|(
name|sndbuf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_SNDBUF
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sndbuf_size
argument_list|,
operator|&
name|slen
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"unable to get default sndbuf size"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* sanity check returned buffer sizes */
if|if
condition|(
name|rcvbuf_size
operator|<=
literal|0
condition|)
name|rcvbuf_size
operator|=
literal|8
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
name|sndbuf_size
operator|<=
literal|0
condition|)
name|sndbuf_size
operator|=
literal|8
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
name|sndbuf_size
operator|>
literal|8
operator|*
literal|1024
operator|*
literal|1024
condition|)
name|sndbuf_size
operator|=
literal|8
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
name|rcvbuf_size
operator|>
literal|8
operator|*
literal|1024
operator|*
literal|1024
condition|)
name|rcvbuf_size
operator|=
literal|8
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
name|marg_sl
operator|=
name|xsl_init
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|tmpdir
operator|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|tmpdir
operator|=
name|_PATH_TMP
expr_stmt|;
comment|/* Set default operation mode based on FTPMODE environment variable */
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"FTPMODE"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|cp
argument_list|,
literal|"passive"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|passivemode
operator|=
literal|1
expr_stmt|;
name|activefallback
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|cp
argument_list|,
literal|"active"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|passivemode
operator|=
literal|0
expr_stmt|;
name|activefallback
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|cp
argument_list|,
literal|"gate"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gatemode
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|cp
argument_list|,
literal|"auto"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|passivemode
operator|=
literal|1
expr_stmt|;
name|activefallback
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|warnx
argument_list|(
literal|"unknown $FTPMODE '%s'; using defaults"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|getprogname
argument_list|()
argument_list|,
literal|"pftp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|passivemode
operator|=
literal|1
expr_stmt|;
name|activefallback
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|getprogname
argument_list|()
argument_list|,
literal|"gate-ftp"
argument_list|)
operator|==
literal|0
condition|)
name|gatemode
operator|=
literal|1
expr_stmt|;
name|gateserver
operator|=
name|getenv
argument_list|(
literal|"FTPSERVER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gateserver
operator|==
name|NULL
operator|||
operator|*
name|gateserver
operator|==
literal|'\0'
condition|)
name|gateserver
operator|=
name|GATE_SERVER
expr_stmt|;
if|if
condition|(
name|gatemode
condition|)
block|{
if|if
condition|(
operator|*
name|gateserver
operator|==
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"Neither $FTPSERVER nor GATE_SERVER is defined; disabling gate-ftp"
argument_list|)
expr_stmt|;
name|gatemode
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|cp
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"dumb"
argument_list|)
operator|==
literal|0
condition|)
name|dumbterm
operator|=
literal|1
expr_stmt|;
else|else
name|dumbterm
operator|=
literal|0
expr_stmt|;
name|fromatty
operator|=
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
name|ttyout
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|ttyout
argument_list|)
argument_list|)
condition|)
block|{
name|verbose
operator|=
literal|1
expr_stmt|;
comment|/* verbose if to a tty */
if|if
condition|(
operator|!
name|dumbterm
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_EDITCOMPLETE
if|if
condition|(
name|fromatty
condition|)
comment|/* editing mode on if tty is usable */
name|editing
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_PROGRESS
if|if
condition|(
name|foregroundproc
argument_list|()
condition|)
name|progress
operator|=
literal|1
expr_stmt|;
comment|/* progress bar on if fg */
endif|#
directive|endif
block|}
block|}
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"46AadefginN:o:pP:q:r:RtT:u:vV"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'4'
case|:
name|family
operator|=
name|AF_INET
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
ifdef|#
directive|ifdef
name|INET6
name|family
operator|=
name|AF_INET6
expr_stmt|;
else|#
directive|else
name|warnx
argument_list|(
literal|"INET6 support is not available; ignoring -6"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'A'
case|:
name|activefallback
operator|=
literal|0
expr_stmt|;
name|passivemode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|anonftp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|options
operator||=
name|SO_DEBUG
expr_stmt|;
name|debug
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
ifndef|#
directive|ifndef
name|NO_EDITCOMPLETE
name|editing
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'f'
case|:
name|flushcache
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|doglob
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|interactive
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|autologin
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|strlcpy
argument_list|(
name|netrc
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|netrc
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|netrc
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %s"
argument_list|,
name|optarg
argument_list|,
name|strerror
argument_list|(
name|ENAMETOOLONG
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|outfile
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|outfile
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|ttyout
operator|=
name|stderr
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|passivemode
operator|=
literal|1
expr_stmt|;
name|activefallback
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|ftpport
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quit_time
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|quit_time
operator|<
literal|1
operator|||
operator|*
name|ep
operator|!=
literal|'\0'
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"bad quit value: %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|retry_connect
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry_connect
operator|<
literal|1
operator|||
operator|*
name|ep
operator|!=
literal|'\0'
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"bad retry value: %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|restartautofetch
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|trace
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
block|{
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[
literal|6
index|]
decl_stmt|,
modifier|*
name|oac
decl_stmt|;
comment|/* look for `dir,max[,incr]' */
name|targc
operator|=
literal|0
expr_stmt|;
name|targv
index|[
name|targc
operator|++
index|]
operator|=
literal|"-T"
expr_stmt|;
name|oac
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|strsep
argument_list|(
operator|&
name|oac
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"bad throttle value: %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|targv
index|[
name|targc
operator|++
index|]
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|targc
operator|>=
literal|5
condition|)
break|break;
block|}
if|if
condition|(
name|parserate
argument_list|(
name|targc
argument_list|,
name|targv
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|oac
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'u'
case|:
block|{
name|isupload
operator|=
literal|1
expr_stmt|;
name|interactive
operator|=
literal|0
expr_stmt|;
name|upload_path
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'v'
case|:
name|progress
operator|=
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|progress
operator|=
name|verbose
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* set line buffering on ttyout */
name|setvbuf
argument_list|(
name|ttyout
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|cpend
operator|=
literal|0
expr_stmt|;
comment|/* no pending replies */
name|proxy
operator|=
literal|0
expr_stmt|;
comment|/* proxy not active */
name|crflag
operator|=
literal|1
expr_stmt|;
comment|/* strip c.r. on ascii gets */
name|sendport
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* not using ports */
comment|/* 	 * Cache the user name and home directory. 	 */
name|localhome
operator|=
name|NULL
expr_stmt|;
name|localname
operator|=
name|NULL
expr_stmt|;
name|anonuser
operator|=
literal|"anonymous"
expr_stmt|;
name|cp
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EMPTYSTRING
argument_list|(
name|cp
argument_list|)
condition|)
name|localhome
operator|=
name|xstrdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|pw
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|getlogin
argument_list|()
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|pw
operator|=
name|getpwnam
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
name|pw
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|localhome
operator|==
name|NULL
operator|&&
operator|!
name|EMPTYSTRING
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
condition|)
name|localhome
operator|=
name|xstrdup
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|localname
operator|=
name|xstrdup
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|anonuser
operator|=
name|localname
expr_stmt|;
block|}
if|if
condition|(
name|netrc
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|localhome
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strlcpy
argument_list|(
name|netrc
argument_list|,
name|localhome
argument_list|,
sizeof|sizeof
argument_list|(
name|netrc
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|netrc
argument_list|)
operator|||
name|strlcat
argument_list|(
name|netrc
argument_list|,
literal|"/.netrc"
argument_list|,
sizeof|sizeof
argument_list|(
name|netrc
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|netrc
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s/.netrc: %s"
argument_list|,
name|localhome
argument_list|,
name|strerror
argument_list|(
name|ENAMETOOLONG
argument_list|)
argument_list|)
expr_stmt|;
name|netrc
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|localhome
operator|==
name|NULL
condition|)
name|localhome
operator|=
name|xstrdup
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
comment|/* 	 * Every anonymous FTP server I've encountered will accept the 	 * string "username@", and will append the hostname itself. We 	 * do this by default since many servers are picky about not 	 * having a FQDN in the anonymous password. 	 * - thorpej@NetBSD.org 	 */
name|len
operator|=
name|strlen
argument_list|(
name|anonuser
argument_list|)
operator|+
literal|2
expr_stmt|;
name|anonpass
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|anonpass
argument_list|,
name|anonuser
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|anonpass
argument_list|,
literal|"@"
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 			 * set all the defaults for options defined in 			 * struct option optiontab[]  declared in cmdtab.c 			 */
name|setupoption
argument_list|(
literal|"anonpass"
argument_list|,
name|getenv
argument_list|(
literal|"FTPANONPASS"
argument_list|)
argument_list|,
name|anonpass
argument_list|)
expr_stmt|;
name|setupoption
argument_list|(
literal|"ftp_proxy"
argument_list|,
name|getenv
argument_list|(
name|FTP_PROXY
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|setupoption
argument_list|(
literal|"http_proxy"
argument_list|,
name|getenv
argument_list|(
name|HTTP_PROXY
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|setupoption
argument_list|(
literal|"no_proxy"
argument_list|,
name|getenv
argument_list|(
name|NO_PROXY
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|setupoption
argument_list|(
literal|"pager"
argument_list|,
name|getenv
argument_list|(
literal|"PAGER"
argument_list|)
argument_list|,
name|DEFAULTPAGER
argument_list|)
expr_stmt|;
name|setupoption
argument_list|(
literal|"prompt"
argument_list|,
name|getenv
argument_list|(
literal|"FTPPROMPT"
argument_list|)
argument_list|,
name|DEFAULTPROMPT
argument_list|)
expr_stmt|;
name|setupoption
argument_list|(
literal|"rprompt"
argument_list|,
name|getenv
argument_list|(
literal|"FTPRPROMPT"
argument_list|)
argument_list|,
name|DEFAULTRPROMPT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|anonpass
argument_list|)
expr_stmt|;
name|setttywidth
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGINFO
operator|(
name|void
operator|)
name|xsignal
argument_list|(
name|SIGINFO
argument_list|,
name|psummary
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|xsignal
argument_list|(
name|SIGQUIT
argument_list|,
name|psummary
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xsignal
argument_list|(
name|SIGUSR1
argument_list|,
name|crankrate
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xsignal
argument_list|(
name|SIGUSR2
argument_list|,
name|crankrate
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xsignal
argument_list|(
name|SIGWINCH
argument_list|,
name|setttywidth
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__GNUC__
comment|/* to shut up gcc warnings */
operator|(
name|void
operator|)
operator|&
name|argc
expr_stmt|;
operator|(
name|void
operator|)
operator|&
name|argv
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|isupload
condition|)
block|{
name|rval
operator|=
name|auto_put
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|upload_path
argument_list|)
expr_stmt|;
name|sigint_or_rval_exit
label|:
if|if
condition|(
name|sigint_raised
condition|)
block|{
operator|(
name|void
operator|)
name|xsignal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|raise
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
operator|&&
operator|!
name|isipv6addr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|rval
operator|=
name|auto_fetch
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|>=
literal|0
condition|)
comment|/* -1 == connected and cd-ed */
goto|goto
name|sigint_or_rval_exit
goto|;
block|}
else|else
block|{
name|char
modifier|*
name|xargv
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|user
decl_stmt|,
modifier|*
name|host
decl_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|sigsetjmp
argument_list|(
name|toplevel
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|sigint_or_rval_exit
goto|;
operator|(
name|void
operator|)
name|xsignal
argument_list|(
name|SIGINT
argument_list|,
name|intr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xsignal
argument_list|(
name|SIGPIPE
argument_list|,
name|lostpeer
argument_list|)
expr_stmt|;
name|user
operator|=
name|NULL
expr_stmt|;
name|host
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|host
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|user
operator|=
name|host
expr_stmt|;
name|host
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
comment|/* XXX discards const */
name|xargv
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|getprogname
argument_list|()
expr_stmt|;
name|xargv
index|[
literal|1
index|]
operator|=
name|host
expr_stmt|;
name|xargv
index|[
literal|2
index|]
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|xargv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|int
name|oautologin
decl_stmt|;
name|oautologin
operator|=
name|autologin
expr_stmt|;
if|if
condition|(
name|user
operator|!=
name|NULL
condition|)
block|{
name|anonftp
operator|=
literal|0
expr_stmt|;
name|autologin
operator|=
literal|0
expr_stmt|;
block|}
name|setpeer
argument_list|(
name|argc
operator|+
literal|1
argument_list|,
name|xargv
argument_list|)
expr_stmt|;
name|autologin
operator|=
name|oautologin
expr_stmt|;
if|if
condition|(
name|connected
operator|==
literal|1
operator|&&
name|user
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|ftp_login
argument_list|(
name|host
argument_list|,
name|user
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retry_connect
condition|)
break|break;
if|if
condition|(
operator|!
name|connected
condition|)
block|{
name|macnum
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"Retrying in %d seconds...\n"
argument_list|,
name|retry_connect
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
name|retry_connect
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|connected
condition|)
do|;
name|retry_connect
operator|=
literal|0
expr_stmt|;
comment|/* connected, stop hiding msgs */
block|}
block|}
if|if
condition|(
name|isupload
condition|)
name|usage
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_EDITCOMPLETE
name|controlediting
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* !NO_EDITCOMPLETE */
operator|(
name|void
operator|)
name|sigsetjmp
argument_list|(
name|toplevel
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xsignal
argument_list|(
name|SIGINT
argument_list|,
name|intr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xsignal
argument_list|(
name|SIGPIPE
argument_list|,
name|lostpeer
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
name|cmdscanner
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate a prompt  */
end_comment

begin_function
name|char
modifier|*
name|prompt
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
modifier|*
modifier|*
name|prompt
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|prompt
operator|==
name|NULL
condition|)
block|{
name|struct
name|option
modifier|*
name|o
decl_stmt|;
name|o
operator|=
name|getoption
argument_list|(
literal|"prompt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"no such option `prompt'"
argument_list|)
expr_stmt|;
name|prompt
operator|=
operator|&
operator|(
name|o
operator|->
name|value
operator|)
expr_stmt|;
block|}
name|formatbuf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|*
name|prompt
condition|?
operator|*
name|prompt
else|:
name|DEFAULTPROMPT
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate an rprompt  */
end_comment

begin_function
name|char
modifier|*
name|rprompt
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
modifier|*
modifier|*
name|rprompt
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|rprompt
operator|==
name|NULL
condition|)
block|{
name|struct
name|option
modifier|*
name|o
decl_stmt|;
name|o
operator|=
name|getoption
argument_list|(
literal|"rprompt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"no such option `rprompt'"
argument_list|)
expr_stmt|;
name|rprompt
operator|=
operator|&
operator|(
name|o
operator|->
name|value
operator|)
expr_stmt|;
block|}
name|formatbuf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|*
name|rprompt
condition|?
operator|*
name|rprompt
else|:
name|DEFAULTRPROMPT
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Command parser.  */
end_comment

begin_function
name|void
name|cmdscanner
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|num
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifndef|#
directive|ifndef
name|NO_EDITCOMPLETE
if|if
condition|(
operator|!
name|editing
condition|)
block|{
endif|#
directive|endif
comment|/* !NO_EDITCOMPLETE */
if|if
condition|(
name|fromatty
condition|)
block|{
name|fputs
argument_list|(
name|prompt
argument_list|()
argument_list|,
name|ttyout
argument_list|)
expr_stmt|;
name|p
operator|=
name|rprompt
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"%s "
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|ttyout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|fromatty
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ttyout
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|num
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|line
index|[
operator|--
name|num
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|num
operator|==
literal|0
condition|)
break|break;
name|line
index|[
name|num
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num
operator|==
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|2
condition|)
block|{
name|fputs
argument_list|(
literal|"Sorry, input line is too long.\n"
argument_list|,
name|ttyout
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|num
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|num
operator|!=
name|EOF
condition|)
comment|/* void */
empty_stmt|;
break|break;
block|}
comment|/* else it was a line without a newline */
ifndef|#
directive|ifndef
name|NO_EDITCOMPLETE
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|buf
decl_stmt|;
name|HistEvent
name|ev
decl_stmt|;
name|cursor_pos
operator|=
name|NULL
expr_stmt|;
name|buf
operator|=
name|el_gets
argument_list|(
name|el
argument_list|,
operator|&
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
operator|||
name|num
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fromatty
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ttyout
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|>=
sizeof|sizeof
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
literal|"Sorry, input line is too long.\n"
argument_list|,
name|ttyout
argument_list|)
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
name|line
argument_list|,
name|buf
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
operator|--
name|num
index|]
operator|==
literal|'\n'
condition|)
block|{
name|line
index|[
name|num
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
break|break;
block|}
name|history
argument_list|(
name|hist
argument_list|,
operator|&
name|ev
argument_list|,
name|H_ENTER
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !NO_EDITCOMPLETE */
name|makeargv
argument_list|()
expr_stmt|;
if|if
condition|(
name|margc
operator|==
literal|0
condition|)
continue|continue;
name|c
operator|=
name|getcmd
argument_list|(
name|margv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|(
expr|struct
name|cmd
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|fputs
argument_list|(
literal|"?Ambiguous command.\n"
argument_list|,
name|ttyout
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_EDITCOMPLETE
argument_list|)
comment|/* 			 * attempt to el_parse() unknown commands. 			 * any command containing a ':' would be parsed 			 * as "[prog:]cmd ...", and will result in a 			 * false positive if prog != "ftp", so treat 			 * such commands as invalid. 			 */
if|if
condition|(
name|strchr
argument_list|(
name|margv
index|[
literal|0
index|]
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
operator|||
name|el_parse
argument_list|(
name|el
argument_list|,
name|margc
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|margv
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
comment|/* !NO_EDITCOMPLETE */
name|fputs
argument_list|(
literal|"?Invalid command.\n"
argument_list|,
name|ttyout
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|->
name|c_conn
operator|&&
operator|!
name|connected
condition|)
block|{
name|fputs
argument_list|(
literal|"Not connected.\n"
argument_list|,
name|ttyout
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|confirmrest
operator|=
literal|0
expr_stmt|;
name|margv
index|[
literal|0
index|]
operator|=
name|c
operator|->
name|c_name
expr_stmt|;
call|(
modifier|*
name|c
operator|->
name|c_handler
call|)
argument_list|(
name|margc
argument_list|,
name|margv
argument_list|)
expr_stmt|;
if|if
condition|(
name|bell
operator|&&
name|c
operator|->
name|c_bell
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\007'
argument_list|,
name|ttyout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_handler
operator|!=
name|help
condition|)
break|break;
block|}
operator|(
name|void
operator|)
name|xsignal
argument_list|(
name|SIGINT
argument_list|,
name|intr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xsignal
argument_list|(
name|SIGPIPE
argument_list|,
name|lostpeer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|cmd
modifier|*
name|getcmd
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|struct
name|cmd
modifier|*
name|c
decl_stmt|,
modifier|*
name|found
decl_stmt|;
name|int
name|nmatches
decl_stmt|,
name|longest
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|longest
operator|=
literal|0
expr_stmt|;
name|nmatches
operator|=
literal|0
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|cmdtab
init|;
operator|(
name|p
operator|=
name|c
operator|->
name|c_name
operator|)
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
block|{
for|for
control|(
name|q
operator|=
name|name
init|;
operator|*
name|q
operator|==
operator|*
name|p
operator|++
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
literal|0
condition|)
comment|/* exact match? */
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
operator|!
operator|*
name|q
condition|)
block|{
comment|/* the name was a prefix */
if|if
condition|(
name|q
operator|-
name|name
operator|>
name|longest
condition|)
block|{
name|longest
operator|=
name|q
operator|-
name|name
expr_stmt|;
name|nmatches
operator|=
literal|1
expr_stmt|;
name|found
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|-
name|name
operator|==
name|longest
condition|)
name|nmatches
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nmatches
operator|>
literal|1
condition|)
return|return
operator|(
operator|(
expr|struct
name|cmd
operator|*
operator|)
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Slice a string up into argc/argv.  */
end_comment

begin_decl_stmt
name|int
name|slrflag
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|makeargv
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|argp
decl_stmt|;
name|stringbase
operator|=
name|line
expr_stmt|;
comment|/* scan from first of buffer */
name|argbase
operator|=
name|argbuf
expr_stmt|;
comment|/* store from first of buffer */
name|slrflag
operator|=
literal|0
expr_stmt|;
name|marg_sl
operator|->
name|sl_cur
operator|=
literal|0
expr_stmt|;
comment|/* reset to start of marg_sl */
for|for
control|(
name|margc
operator|=
literal|0
init|;
condition|;
name|margc
operator|++
control|)
block|{
name|argp
operator|=
name|slurpstring
argument_list|()
expr_stmt|;
name|xsl_add
argument_list|(
name|marg_sl
argument_list|,
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|argp
operator|==
name|NULL
condition|)
break|break;
block|}
ifndef|#
directive|ifndef
name|NO_EDITCOMPLETE
if|if
condition|(
name|cursor_pos
operator|==
name|line
condition|)
block|{
name|cursor_argc
operator|=
literal|0
expr_stmt|;
name|cursor_argo
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cursor_pos
operator|!=
name|NULL
condition|)
block|{
name|cursor_argc
operator|=
name|margc
expr_stmt|;
name|cursor_argo
operator|=
name|strlen
argument_list|(
name|margv
index|[
name|margc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !NO_EDITCOMPLETE */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NO_EDITCOMPLETE
end_ifdef

begin_define
define|#
directive|define
name|INC_CHKCURSOR
parameter_list|(
name|x
parameter_list|)
value|(x)++
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !NO_EDITCOMPLETE */
end_comment

begin_define
define|#
directive|define
name|INC_CHKCURSOR
parameter_list|(
name|x
parameter_list|)
value|{ (x)++ ; \ 				if (x == cursor_pos) { \ 					cursor_argc = margc; \ 					cursor_argo = ap-argbase; \ 					cursor_pos = NULL; \ 				} }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !NO_EDITCOMPLETE */
end_comment

begin_comment
comment|/*  * Parse string into argbuf;  * implemented with FSM to  * handle quoting and strings  */
end_comment

begin_function
name|char
modifier|*
name|slurpstring
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|got_one
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|sb
init|=
name|stringbase
decl_stmt|;
name|char
modifier|*
name|ap
init|=
name|argbase
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|argbase
decl_stmt|;
comment|/* will return this if token found */
if|if
condition|(
operator|*
name|sb
operator|==
literal|'!'
operator|||
operator|*
name|sb
operator|==
literal|'$'
condition|)
block|{
comment|/* recognize ! as a token for shell */
switch|switch
condition|(
name|slrflag
condition|)
block|{
comment|/* and $ as token for macro invoke */
case|case
literal|0
case|:
name|slrflag
operator|++
expr_stmt|;
name|INC_CHKCURSOR
argument_list|(
name|stringbase
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|sb
operator|==
literal|'!'
operator|)
condition|?
literal|"!"
else|:
literal|"$"
operator|)
return|;
comment|/* NOTREACHED */
case|case
literal|1
case|:
name|slrflag
operator|++
expr_stmt|;
name|altarg
operator|=
name|stringbase
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|S0
label|:
switch|switch
condition|(
operator|*
name|sb
condition|)
block|{
case|case
literal|'\0'
case|:
goto|goto
name|OUT
goto|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
name|INC_CHKCURSOR
argument_list|(
name|sb
argument_list|)
expr_stmt|;
goto|goto
name|S0
goto|;
default|default:
switch|switch
condition|(
name|slrflag
condition|)
block|{
case|case
literal|0
case|:
name|slrflag
operator|++
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|slrflag
operator|++
expr_stmt|;
name|altarg
operator|=
name|sb
expr_stmt|;
break|break;
default|default:
break|break;
block|}
goto|goto
name|S1
goto|;
block|}
name|S1
label|:
switch|switch
condition|(
operator|*
name|sb
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\0'
case|:
goto|goto
name|OUT
goto|;
comment|/* end of token */
case|case
literal|'\\'
case|:
name|INC_CHKCURSOR
argument_list|(
name|sb
argument_list|)
expr_stmt|;
goto|goto
name|S2
goto|;
comment|/* slurp next character */
case|case
literal|'"'
case|:
name|INC_CHKCURSOR
argument_list|(
name|sb
argument_list|)
expr_stmt|;
goto|goto
name|S3
goto|;
comment|/* slurp quoted string */
default|default:
operator|*
name|ap
operator|=
operator|*
name|sb
expr_stmt|;
comment|/* add character to token */
name|ap
operator|++
expr_stmt|;
name|INC_CHKCURSOR
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|got_one
operator|=
literal|1
expr_stmt|;
goto|goto
name|S1
goto|;
block|}
name|S2
label|:
switch|switch
condition|(
operator|*
name|sb
condition|)
block|{
case|case
literal|'\0'
case|:
goto|goto
name|OUT
goto|;
default|default:
operator|*
name|ap
operator|=
operator|*
name|sb
expr_stmt|;
name|ap
operator|++
expr_stmt|;
name|INC_CHKCURSOR
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|got_one
operator|=
literal|1
expr_stmt|;
goto|goto
name|S1
goto|;
block|}
name|S3
label|:
switch|switch
condition|(
operator|*
name|sb
condition|)
block|{
case|case
literal|'\0'
case|:
goto|goto
name|OUT
goto|;
case|case
literal|'"'
case|:
name|INC_CHKCURSOR
argument_list|(
name|sb
argument_list|)
expr_stmt|;
goto|goto
name|S1
goto|;
default|default:
operator|*
name|ap
operator|=
operator|*
name|sb
expr_stmt|;
name|ap
operator|++
expr_stmt|;
name|INC_CHKCURSOR
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|got_one
operator|=
literal|1
expr_stmt|;
goto|goto
name|S3
goto|;
block|}
name|OUT
label|:
if|if
condition|(
name|got_one
condition|)
operator|*
name|ap
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|argbase
operator|=
name|ap
expr_stmt|;
comment|/* update storage pointer */
name|stringbase
operator|=
name|sb
expr_stmt|;
comment|/* update scan pointer */
if|if
condition|(
name|got_one
condition|)
block|{
return|return
operator|(
name|tmp
operator|)
return|;
block|}
switch|switch
condition|(
name|slrflag
condition|)
block|{
case|case
literal|0
case|:
name|slrflag
operator|++
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|slrflag
operator|++
expr_stmt|;
name|altarg
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Help/usage command.  * Call each command handler with argc == 0 and argv[0] == name.  */
end_comment

begin_function
name|void
name|help
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|cmd
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
name|nargv
index|[
literal|1
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|cmd
decl_stmt|;
name|int
name|isusage
decl_stmt|;
name|cmd
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|isusage
operator|=
operator|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"usage"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
operator|||
operator|(
name|isusage
operator|&&
name|argc
operator|==
literal|1
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"usage: %s [command [...]]\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|StringList
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|xsl_init
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"%sommands may be abbreviated.  Commands are:\n\n"
argument_list|,
name|proxy
condition|?
literal|"Proxy c"
else|:
literal|"C"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|cmdtab
init|;
operator|(
name|p
operator|=
name|c
operator|->
name|c_name
operator|)
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|!
name|proxy
operator|||
name|c
operator|->
name|c_proxy
condition|)
name|xsl_add
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|list_vertical
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sl_free
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
define|#
directive|define
name|HELPINDENT
value|((int) sizeof("disconnect"))
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|arg
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
name|c
operator|=
name|getcmd
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|(
expr|struct
name|cmd
operator|*
operator|)
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"?Ambiguous %s command `%s'\n"
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"?Invalid %s command `%s'\n"
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|isusage
condition|)
block|{
name|nargv
index|[
literal|0
index|]
operator|=
name|c
operator|->
name|c_name
expr_stmt|;
call|(
modifier|*
name|c
operator|->
name|c_handler
call|)
argument_list|(
literal|0
argument_list|,
name|nargv
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"%-*s\t%s\n"
argument_list|,
name|HELPINDENT
argument_list|,
name|c
operator|->
name|c_name
argument_list|,
name|c
operator|->
name|c_help
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|struct
name|option
modifier|*
name|getoption
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|option
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|c
operator|=
name|optiontab
init|;
operator|(
name|p
operator|=
name|c
operator|->
name|name
operator|)
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|c
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|getoptionvalue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|option
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"getoptionvalue() invoked with NULL name"
argument_list|)
expr_stmt|;
name|c
operator|=
name|getoption
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
return|return
operator|(
name|c
operator|->
name|value
operator|)
return|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"getoptionvalue() invoked with unknown option `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
specifier|static
name|void
name|setupoption
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|char
modifier|*
name|defaultvalue
parameter_list|)
block|{
name|char
modifier|*
name|nargv
index|[
literal|3
index|]
decl_stmt|;
name|int
name|overbose
decl_stmt|;
name|nargv
index|[
literal|0
index|]
operator|=
literal|"setupoption()"
expr_stmt|;
name|nargv
index|[
literal|1
index|]
operator|=
name|name
expr_stmt|;
name|nargv
index|[
literal|2
index|]
operator|=
operator|(
name|value
condition|?
name|value
else|:
name|defaultvalue
operator|)
expr_stmt|;
name|overbose
operator|=
name|verbose
expr_stmt|;
name|verbose
operator|=
literal|0
expr_stmt|;
name|setoption
argument_list|(
literal|3
argument_list|,
name|nargv
argument_list|)
expr_stmt|;
name|verbose
operator|=
name|overbose
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|progname
init|=
name|getprogname
argument_list|()
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-46AadefginpRtvV] [-N netrc] [-o outfile] [-P port] [-q quittime]\n"
literal|"           [-r retry] [-T dir,max[,inc][[user@]host [port]]] [host:path[/]]\n"
literal|"           [file:///file] [ftp://[user[:pass]@]host[:port]/path[/]]\n"
literal|"           [http://[user[:pass]@]host[:port]/path] [...]\n"
literal|"       %s -u URL file [...]\n"
argument_list|,
name|progname
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

