begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: progressbar.c,v 1.7 2005/04/11 01:49:31 lukem Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997-2003 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Luke Mewburn.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the NetBSD  *	Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: progressbar.c,v 1.7 2005/04/11 01:49:31 lukem Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * FTP User Program -- Misc support routines  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"progressbar.h"
end_include

begin_define
define|#
directive|define
name|SECSPERHOUR
value|(60 * 60)
end_define

begin_define
define|#
directive|define
name|SECSPERDAY
value|((long)60 * 60 * 24)
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_PROGRESS
argument_list|)
end_if

begin_comment
comment|/*  * return non-zero if we're the current foreground process  */
end_comment

begin_function
name|int
name|foregroundproc
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|pid_t
name|pgrp
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|pgrp
operator|==
operator|-
literal|1
condition|)
name|pgrp
operator|=
name|getpgrp
argument_list|()
expr_stmt|;
return|return
operator|(
name|tcgetpgrp
argument_list|(
name|fileno
argument_list|(
name|ttyout
argument_list|)
argument_list|)
operator|==
name|pgrp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(NO_PROGRESS) */
end_comment

begin_function_decl
specifier|static
name|void
name|updateprogressmeter
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * SIGALRM handler to update the progress meter  */
end_comment

begin_function
specifier|static
name|void
name|updateprogressmeter
parameter_list|(
name|int
name|dummy
parameter_list|)
block|{
name|int
name|oerrno
init|=
name|errno
decl_stmt|;
name|progressmeter
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * List of order of magnitude prefixes.  * The last is `P', as 2^64 = 16384 Petabytes  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|prefixes
index|[]
init|=
literal|" KMGTP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Display a transfer progress bar if progress is non-zero.  * SIGALRM is hijacked for use by this function.  * - Before the transfer, set filesize to size of file (or -1 if unknown),  *   and call with flag = -1. This starts the once per second timer,  *   and a call to updateprogressmeter() upon SIGALRM.  * - During the transfer, updateprogressmeter will call progressmeter  *   with flag = 0  * - After the transfer, call with flag = 1  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|lastupdate
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BUFLEFT
value|(sizeof(buf) - len)
end_define

begin_function
name|void
name|progressmeter
parameter_list|(
name|int
name|flag
parameter_list|)
block|{
specifier|static
name|off_t
name|lastsize
decl_stmt|;
name|off_t
name|cursize
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|,
name|wait
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_PROGRESS
name|struct
name|timeval
name|td
decl_stmt|;
name|off_t
name|abbrevsize
decl_stmt|,
name|bytespersec
decl_stmt|;
name|double
name|elapsed
decl_stmt|;
name|int
name|ratio
decl_stmt|,
name|barlength
decl_stmt|,
name|i
decl_stmt|,
name|remaining
decl_stmt|;
comment|/* 			 * Work variables for progress bar. 			 * 			 * XXX:	if the format of the progress bar changes 			 *	(especially the number of characters in the 			 *	`static' portion of it), be sure to update 			 *	these appropriately. 			 */
endif|#
directive|endif
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
comment|/* workspace for progress bar */
ifndef|#
directive|ifndef
name|NO_PROGRESS
define|#
directive|define
name|BAROVERHEAD
value|43
comment|/* non `*' portion of progress bar */
comment|/* 					 * stars should contain at least 					 * sizeof(buf) - BAROVERHEAD entries 					 */
specifier|static
specifier|const
name|char
name|stars
index|[]
init|=
literal|"*****************************************************************************"
literal|"*****************************************************************************"
literal|"*****************************************************************************"
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lastupdate
operator|=
name|start
expr_stmt|;
name|lastsize
operator|=
name|restart_point
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cursize
operator|=
name|bytes
operator|+
name|restart_point
expr_stmt|;
name|timersub
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|lastupdate
argument_list|,
operator|&
name|wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursize
operator|>
name|lastsize
condition|)
block|{
name|lastupdate
operator|=
name|now
expr_stmt|;
name|lastsize
operator|=
name|cursize
expr_stmt|;
name|wait
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|STANDALONE_PROGRESS
if|if
condition|(
name|quit_time
operator|>
literal|0
operator|&&
name|wait
operator|.
name|tv_sec
operator|>
name|quit_time
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"\r\n%s: "
literal|"transfer aborted because stalled for %lu sec.\r\n"
argument_list|,
name|getprogname
argument_list|()
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|wait
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|fileno
argument_list|(
name|ttyout
argument_list|)
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xsignal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|alarmtimer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|siglongjmp
argument_list|(
name|toplevel
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !STANDALONE_PROGRESS */
block|}
comment|/* 	 * Always set the handler even if we are not the foreground process. 	 */
ifdef|#
directive|ifdef
name|STANDALONE_PROGRESS
if|if
condition|(
name|progress
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|quit_time
operator|>
literal|0
operator|||
name|progress
condition|)
block|{
endif|#
directive|endif
comment|/* !STANDALONE_PROGRESS */
if|if
condition|(
name|flag
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|xsignal_restart
argument_list|(
name|SIGALRM
argument_list|,
name|updateprogressmeter
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|alarmtimer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* set alarm timer for 1 Hz */
block|}
elseif|else
if|if
condition|(
name|flag
operator|==
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|xsignal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|alarmtimer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|NO_PROGRESS
if|if
condition|(
operator|!
name|progress
condition|)
return|return;
name|len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * print progress bar only if we are foreground process. 	 */
if|if
condition|(
operator|!
name|foregroundproc
argument_list|()
condition|)
return|return;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|"\r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|"%s"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|filesize
operator|>
literal|0
condition|)
block|{
name|ratio
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|double
operator|)
name|cursize
operator|*
literal|100.0
operator|/
operator|(
name|double
operator|)
name|filesize
argument_list|)
expr_stmt|;
name|ratio
operator|=
name|MAX
argument_list|(
name|ratio
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ratio
operator|=
name|MIN
argument_list|(
name|ratio
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|"%3d%% "
argument_list|,
name|ratio
argument_list|)
expr_stmt|;
comment|/* 			 * calculate the length of the `*' bar, ensuring that 			 * the number of stars won't exceed the buffer size 			 */
name|barlength
operator|=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|,
name|ttywidth
argument_list|)
operator|-
name|BAROVERHEAD
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
name|barlength
operator|-=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|barlength
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|barlength
operator|*
name|ratio
operator|/
literal|100
expr_stmt|;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|"|%.*s%*s|"
argument_list|,
name|i
argument_list|,
name|stars
argument_list|,
name|barlength
operator|-
name|i
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
name|abbrevsize
operator|=
name|cursize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|abbrevsize
operator|>=
literal|100000
operator|&&
name|i
operator|<
sizeof|sizeof
argument_list|(
name|prefixes
argument_list|)
condition|;
name|i
operator|++
control|)
name|abbrevsize
operator|>>=
literal|10
expr_stmt|;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|" "
name|LLFP
argument_list|(
literal|"5"
argument_list|)
literal|" %c%c "
argument_list|,
operator|(
name|LLT
operator|)
name|abbrevsize
argument_list|,
name|prefixes
index|[
name|i
index|]
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|' '
else|:
literal|'B'
argument_list|)
expr_stmt|;
name|timersub
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|td
argument_list|)
expr_stmt|;
name|elapsed
operator|=
name|td
operator|.
name|tv_sec
operator|+
operator|(
name|td
operator|.
name|tv_usec
operator|/
literal|1000000.0
operator|)
expr_stmt|;
name|bytespersec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|bytespersec
operator|=
name|bytes
expr_stmt|;
if|if
condition|(
name|elapsed
operator|>
literal|0.0
condition|)
name|bytespersec
operator|/=
name|elapsed
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|bytespersec
operator|>=
literal|1024000
operator|&&
name|i
operator|<
sizeof|sizeof
argument_list|(
name|prefixes
argument_list|)
condition|;
name|i
operator|++
control|)
name|bytespersec
operator|>>=
literal|10
expr_stmt|;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|" "
name|LLFP
argument_list|(
literal|"3"
argument_list|)
literal|".%02d %cB/s "
argument_list|,
call|(
name|LLT
call|)
argument_list|(
name|bytespersec
operator|/
literal|1024
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|bytespersec
operator|%
literal|1024
operator|)
operator|*
literal|100
operator|/
literal|1024
argument_list|)
argument_list|,
name|prefixes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|filesize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bytes
operator|<=
literal|0
operator|||
name|elapsed
operator|<=
literal|0.0
operator|||
name|cursize
operator|>
name|filesize
condition|)
block|{
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|"   --:-- ETA"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wait
operator|.
name|tv_sec
operator|>=
name|STALLTIME
condition|)
block|{
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|" - stalled -"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|remaining
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|filesize
operator|-
name|restart_point
operator|)
operator|/
operator|(
name|bytes
operator|/
name|elapsed
operator|)
operator|-
name|elapsed
argument_list|)
expr_stmt|;
if|if
condition|(
name|remaining
operator|>=
literal|100
operator|*
name|SECSPERHOUR
condition|)
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|"   --:-- ETA"
argument_list|)
expr_stmt|;
else|else
block|{
name|i
operator|=
name|remaining
operator|/
name|SECSPERHOUR
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|"%2d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|"   "
argument_list|)
expr_stmt|;
name|i
operator|=
name|remaining
operator|%
name|SECSPERHOUR
expr_stmt|;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|"%02d:%02d ETA"
argument_list|,
name|i
operator|/
literal|60
argument_list|,
name|i
operator|%
literal|60
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|flag
operator|==
literal|1
condition|)
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|fileno
argument_list|(
name|ttyout
argument_list|)
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !NO_PROGRESS */
block|}
ifndef|#
directive|ifndef
name|STANDALONE_PROGRESS
comment|/*  * Display transfer statistics.  * Requires start to be initialised by progressmeter(-1),  * direction to be defined by xfer routines, and filesize and bytes  * to be updated by xfer routines  * If siginfo is nonzero, an ETA is displayed, and the output goes to stderr  * instead of ttyout.  */
name|void
name|ptransfer
parameter_list|(
name|int
name|siginfo
parameter_list|)
block|{
name|struct
name|timeval
name|now
decl_stmt|,
name|td
decl_stmt|,
name|wait
decl_stmt|;
name|double
name|elapsed
decl_stmt|;
name|off_t
name|bytespersec
decl_stmt|;
name|int
name|remaining
decl_stmt|,
name|hh
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
comment|/* Work variable for transfer status. */
if|if
condition|(
operator|!
name|verbose
operator|&&
operator|!
name|progress
operator|&&
operator|!
name|siginfo
condition|)
return|return;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|timersub
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|td
argument_list|)
expr_stmt|;
name|elapsed
operator|=
name|td
operator|.
name|tv_sec
operator|+
operator|(
name|td
operator|.
name|tv_usec
operator|/
literal|1000000.0
operator|)
expr_stmt|;
name|bytespersec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|bytespersec
operator|=
name|bytes
expr_stmt|;
if|if
condition|(
name|elapsed
operator|>
literal|0.0
condition|)
name|bytespersec
operator|/=
name|elapsed
expr_stmt|;
block|}
name|len
operator|=
literal|0
expr_stmt|;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
name|LLF
literal|" byte%s %s in "
argument_list|,
operator|(
name|LLT
operator|)
name|bytes
argument_list|,
name|bytes
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|direction
argument_list|)
expr_stmt|;
name|remaining
operator|=
operator|(
name|int
operator|)
name|elapsed
expr_stmt|;
if|if
condition|(
name|remaining
operator|>
name|SECSPERDAY
condition|)
block|{
name|int
name|days
decl_stmt|;
name|days
operator|=
name|remaining
operator|/
name|SECSPERDAY
expr_stmt|;
name|remaining
operator|%=
name|SECSPERDAY
expr_stmt|;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|"%d day%s "
argument_list|,
name|days
argument_list|,
name|days
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
name|hh
operator|=
name|remaining
operator|/
name|SECSPERHOUR
expr_stmt|;
name|remaining
operator|%=
name|SECSPERHOUR
expr_stmt|;
if|if
condition|(
name|hh
condition|)
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|"%2d:"
argument_list|,
name|hh
argument_list|)
expr_stmt|;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|"%02d:%02d "
argument_list|,
name|remaining
operator|/
literal|60
argument_list|,
name|remaining
operator|%
literal|60
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|bytespersec
operator|>=
literal|1024000
operator|&&
name|i
operator|<
sizeof|sizeof
argument_list|(
name|prefixes
argument_list|)
condition|;
name|i
operator|++
control|)
name|bytespersec
operator|>>=
literal|10
expr_stmt|;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|"("
name|LLF
literal|".%02d %cB/s)"
argument_list|,
call|(
name|LLT
call|)
argument_list|(
name|bytespersec
operator|/
literal|1024
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|bytespersec
operator|%
literal|1024
operator|)
operator|*
literal|100
operator|/
literal|1024
argument_list|)
argument_list|,
name|prefixes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|siginfo
operator|&&
name|bytes
operator|>
literal|0
operator|&&
name|elapsed
operator|>
literal|0.0
operator|&&
name|filesize
operator|>=
literal|0
operator|&&
name|bytes
operator|+
name|restart_point
operator|<=
name|filesize
condition|)
block|{
name|remaining
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|filesize
operator|-
name|restart_point
operator|)
operator|/
operator|(
name|bytes
operator|/
name|elapsed
operator|)
operator|-
name|elapsed
argument_list|)
expr_stmt|;
name|hh
operator|=
name|remaining
operator|/
name|SECSPERHOUR
expr_stmt|;
name|remaining
operator|%=
name|SECSPERHOUR
expr_stmt|;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|"  ETA: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|hh
condition|)
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|"%2d:"
argument_list|,
name|hh
argument_list|)
expr_stmt|;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|"%02d:%02d"
argument_list|,
name|remaining
operator|/
literal|60
argument_list|,
name|remaining
operator|%
literal|60
argument_list|)
expr_stmt|;
name|timersub
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|lastupdate
argument_list|,
operator|&
name|wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait
operator|.
name|tv_sec
operator|>=
name|STALLTIME
condition|)
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|"  (stalled)"
argument_list|)
expr_stmt|;
block|}
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|BUFLEFT
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|siginfo
condition|?
name|STDERR_FILENO
else|:
name|fileno
argument_list|(
name|ttyout
argument_list|)
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/*  * SIG{INFO,QUIT} handler to print transfer stats if a transfer is in progress  */
name|void
name|psummary
parameter_list|(
name|int
name|notused
parameter_list|)
block|{
name|int
name|oerrno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fromatty
condition|)
name|write
argument_list|(
name|fileno
argument_list|(
name|ttyout
argument_list|)
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ptransfer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
name|oerrno
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !STANDALONE_PROGRESS */
comment|/*  * Set the SIGALRM interval timer for wait seconds, 0 to disable.  */
name|void
name|alarmtimer
parameter_list|(
name|int
name|wait
parameter_list|)
block|{
name|struct
name|itimerval
name|itv
decl_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|wait
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|itv
operator|.
name|it_interval
operator|=
name|itv
operator|.
name|it_value
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/*  * Install a POSIX signal handler, allowing the invoker to set whether  * the signal should be restartable or not  */
name|sigfunc
name|xsignal_restart
parameter_list|(
name|int
name|sig
parameter_list|,
name|sigfunc
name|func
parameter_list|,
name|int
name|restartable
parameter_list|)
block|{
name|struct
name|sigaction
name|act
decl_stmt|,
name|oact
decl_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|func
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SA_RESTART
argument_list|)
comment|/* 4.4BSD, Posix(?), SVR4 */
name|act
operator|.
name|sa_flags
operator|=
name|restartable
condition|?
name|SA_RESTART
else|:
literal|0
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|SA_INTERRUPT
argument_list|)
comment|/* SunOS 4.x */
name|act
operator|.
name|sa_flags
operator|=
name|restartable
condition|?
literal|0
else|:
name|SA_INTERRUPT
expr_stmt|;
else|#
directive|else
error|#
directive|error
literal|"system must have SA_RESTART or SA_INTERRUPT"
endif|#
directive|endif
if|if
condition|(
name|sigaction
argument_list|(
name|sig
argument_list|,
operator|&
name|act
argument_list|,
operator|&
name|oact
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|SIG_ERR
operator|)
return|;
return|return
operator|(
name|oact
operator|.
name|sa_handler
operator|)
return|;
block|}
comment|/*  * Install a signal handler with the `restartable' flag set dependent upon  * which signal is being set. (This is a wrapper to xsignal_restart())  */
name|sigfunc
name|xsignal
parameter_list|(
name|int
name|sig
parameter_list|,
name|sigfunc
name|func
parameter_list|)
block|{
name|int
name|restartable
decl_stmt|;
comment|/* 	 * Some signals print output or change the state of the process. 	 * There should be restartable, so that reads and writes are 	 * not affected.  Some signals should cause program flow to change; 	 * these signals should not be restartable, so that the system call 	 * will return with EINTR, and the program will go do something 	 * different.  If the signal handler calls longjmp() or siglongjmp(), 	 * it doesn't matter if it's restartable. 	 */
switch|switch
condition|(
name|sig
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGINFO
case|case
name|SIGINFO
case|:
endif|#
directive|endif
case|case
name|SIGQUIT
case|:
case|case
name|SIGUSR1
case|:
case|case
name|SIGUSR2
case|:
case|case
name|SIGWINCH
case|:
name|restartable
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SIGALRM
case|:
case|case
name|SIGINT
case|:
case|case
name|SIGPIPE
case|:
name|restartable
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* 		 * This is unpleasant, but I don't know what would be better. 		 * Right now, this "can't happen" 		 */
name|errx
argument_list|(
literal|1
argument_list|,
literal|"xsignal_restart called with signal %d"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|xsignal_restart
argument_list|(
name|sig
argument_list|,
name|func
argument_list|,
name|restartable
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

