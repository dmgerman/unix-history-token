begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2002-2004 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_poll.h>
end_include

begin_include
include|#
directive|include
file|<apr_version.h>
end_include

begin_include
include|#
directive|include
file|<apr_portable.h>
end_include

begin_include
include|#
directive|include
file|"serf.h"
end_include

begin_include
include|#
directive|include
file|"serf_bucket_util.h"
end_include

begin_include
include|#
directive|include
file|"serf_private.h"
end_include

begin_comment
comment|/* cleanup for sockets */
end_comment

begin_function
specifier|static
name|apr_status_t
name|clean_skt
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|serf_connection_t
modifier|*
name|conn
init|=
name|data
decl_stmt|;
name|apr_status_t
name|status
init|=
name|APR_SUCCESS
decl_stmt|;
if|if
condition|(
name|conn
operator|->
name|skt
condition|)
block|{
name|serf__log_skt
argument_list|(
name|SOCK_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"cleanup - "
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_socket_close
argument_list|(
name|conn
operator|->
name|skt
argument_list|)
expr_stmt|;
name|conn
operator|->
name|skt
operator|=
name|NULL
expr_stmt|;
name|serf__log_nopref
argument_list|(
name|SOCK_VERBOSE
argument_list|,
literal|"closed socket, status %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|clean_resp
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|serf_request_t
modifier|*
name|request
init|=
name|data
decl_stmt|;
comment|/* The request's RESPOOL is being cleared.  */
comment|/* If the response has allocated some buckets, then destroy them (since        the bucket may hold resources other than memory in RESPOOL). Also        make sure to set their fields to NULL so connection closure does        not attempt to free them again.  */
if|if
condition|(
name|request
operator|->
name|resp_bkt
condition|)
block|{
name|serf_bucket_destroy
argument_list|(
name|request
operator|->
name|resp_bkt
argument_list|)
expr_stmt|;
name|request
operator|->
name|resp_bkt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|request
operator|->
name|req_bkt
condition|)
block|{
name|serf_bucket_destroy
argument_list|(
name|request
operator|->
name|req_bkt
argument_list|)
expr_stmt|;
name|request
operator|->
name|req_bkt
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* ### should we worry about debug stuff, like that performed in        ### destroy_request()? should we worry about calling req->handler        ### to notify this "cancellation" due to pool clearing?  */
comment|/* This pool just got cleared/destroyed. Don't try to destroy the pool        (again) when the request is canceled.  */
name|request
operator|->
name|respool
operator|=
name|NULL
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* cleanup for conns */
end_comment

begin_function
specifier|static
name|apr_status_t
name|clean_conn
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|serf_connection_t
modifier|*
name|conn
init|=
name|data
decl_stmt|;
name|serf__log
argument_list|(
name|CONN_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"cleaning up connection 0x%x\n"
argument_list|,
name|conn
argument_list|)
expr_stmt|;
name|serf_connection_close
argument_list|(
name|conn
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Check if there is data waiting to be sent over the socket. This can happen    in two situations:    - The connection queue has atleast one request with unwritten data.    - All requests are written and the ssl layer wrote some data while reading      the response. This can happen when the server triggers a renegotiation,      e.g. after the first and only request on that connection was received.    Returns 1 if data is pending on CONN, NULL if not.    If NEXT_REQ is not NULL, it will be filled in with the next available request    with unwritten data. */
end_comment

begin_function
specifier|static
name|int
name|request_or_data_pending
parameter_list|(
name|serf_request_t
modifier|*
modifier|*
name|next_req
parameter_list|,
name|serf_connection_t
modifier|*
name|conn
parameter_list|)
block|{
name|serf_request_t
modifier|*
name|request
init|=
name|conn
operator|->
name|requests
decl_stmt|;
while|while
condition|(
name|request
operator|!=
name|NULL
operator|&&
name|request
operator|->
name|req_bkt
operator|==
name|NULL
operator|&&
name|request
operator|->
name|writing_started
condition|)
name|request
operator|=
name|request
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|next_req
condition|)
operator|*
name|next_req
operator|=
name|request
expr_stmt|;
if|if
condition|(
name|request
operator|!=
name|NULL
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|conn
operator|->
name|ostream_head
condition|)
block|{
specifier|const
name|char
modifier|*
name|dummy
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|status
operator|=
name|serf_bucket_peek
argument_list|(
name|conn
operator|->
name|ostream_head
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
operator|&&
name|len
condition|)
block|{
name|serf__log_skt
argument_list|(
name|CONN_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"All requests written but still data pending.\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Update the pollset for this connection. We tweak the pollset based on  * whether we want to read and/or write, given conditions within the  * connection. If the connection is not (yet) in the pollset, then it  * will be added.  */
end_comment

begin_function
name|apr_status_t
name|serf__conn_update_pollset
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|)
block|{
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|apr_pollfd_t
name|desc
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|conn
operator|->
name|skt
condition|)
block|{
return|return
name|APR_SUCCESS
return|;
block|}
comment|/* Remove the socket from the poll set. */
name|desc
operator|.
name|desc_type
operator|=
name|APR_POLL_SOCKET
expr_stmt|;
name|desc
operator|.
name|desc
operator|.
name|s
operator|=
name|conn
operator|->
name|skt
expr_stmt|;
name|desc
operator|.
name|reqevents
operator|=
name|conn
operator|->
name|reqevents
expr_stmt|;
name|status
operator|=
name|ctx
operator|->
name|pollset_rm
argument_list|(
name|ctx
operator|->
name|pollset_baton
argument_list|,
operator|&
name|desc
argument_list|,
name|conn
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&&
operator|!
name|APR_STATUS_IS_NOTFOUND
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|status
return|;
comment|/* Now put it back in with the correct read/write values. */
name|desc
operator|.
name|reqevents
operator|=
name|APR_POLLHUP
operator||
name|APR_POLLERR
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|requests
operator|&&
name|conn
operator|->
name|state
operator|!=
name|SERF_CONN_INIT
condition|)
block|{
comment|/* If there are any outstanding events, then we want to read. */
comment|/* ### not true. we only want to read IF we have sent some data */
name|desc
operator|.
name|reqevents
operator||=
name|APR_POLLIN
expr_stmt|;
comment|/* Don't write if OpenSSL told us that it needs to read data first. */
if|if
condition|(
name|conn
operator|->
name|stop_writing
operator|!=
literal|1
condition|)
block|{
comment|/* If the connection is not closing down and              *   has unwritten data or              *   there are any requests that still have buckets to write out,              *     then we want to write.              */
if|if
condition|(
name|conn
operator|->
name|vec_len
operator|&&
name|conn
operator|->
name|state
operator|!=
name|SERF_CONN_CLOSING
condition|)
name|desc
operator|.
name|reqevents
operator||=
name|APR_POLLOUT
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|conn
operator|->
name|probable_keepalive_limit
operator|&&
name|conn
operator|->
name|completed_requests
operator|>
name|conn
operator|->
name|probable_keepalive_limit
operator|)
operator|||
operator|(
name|conn
operator|->
name|max_outstanding_requests
operator|&&
name|conn
operator|->
name|completed_requests
operator|-
name|conn
operator|->
name|completed_responses
operator|>=
name|conn
operator|->
name|max_outstanding_requests
operator|)
condition|)
block|{
comment|/* we wouldn't try to write any way right now. */
block|}
elseif|else
if|if
condition|(
name|request_or_data_pending
argument_list|(
name|NULL
argument_list|,
name|conn
argument_list|)
condition|)
block|{
name|desc
operator|.
name|reqevents
operator||=
name|APR_POLLOUT
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If we can have async responses, always look for something to read. */
if|if
condition|(
name|conn
operator|->
name|async_responses
condition|)
block|{
name|desc
operator|.
name|reqevents
operator||=
name|APR_POLLIN
expr_stmt|;
block|}
comment|/* save our reqevents, so we can pass it in to remove later. */
name|conn
operator|->
name|reqevents
operator|=
name|desc
operator|.
name|reqevents
expr_stmt|;
comment|/* Note: even if we don't want to read/write this socket, we still      * want to poll it for hangups and errors.      */
return|return
name|ctx
operator|->
name|pollset_add
argument_list|(
name|ctx
operator|->
name|pollset_baton
argument_list|,
operator|&
name|desc
argument_list|,
operator|&
name|conn
operator|->
name|baton
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SERF_DEBUG_BUCKET_USE
end_ifdef

begin_comment
comment|/* Make sure all response buckets were drained. */
end_comment

begin_function
specifier|static
name|void
name|check_buckets_drained
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|)
block|{
name|serf_request_t
modifier|*
name|request
init|=
name|conn
operator|->
name|requests
decl_stmt|;
for|for
control|(
init|;
name|request
condition|;
name|request
operator|=
name|request
operator|->
name|next
control|)
block|{
if|if
condition|(
name|request
operator|->
name|resp_bkt
operator|!=
name|NULL
condition|)
block|{
comment|/* ### crap. can't do this. this allocator may have un-drained              * ### REQUEST buckets.              */
comment|/* serf_debug__entered_loop(request->resp_bkt->allocator); */
comment|/* ### for now, pretend we closed the conn (resets the tracking) */
name|serf_debug__closed_conn
argument_list|(
name|request
operator|->
name|resp_bkt
operator|->
name|allocator
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|destroy_ostream
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|)
block|{
if|if
condition|(
name|conn
operator|->
name|ostream_head
operator|!=
name|NULL
condition|)
block|{
name|serf_bucket_destroy
argument_list|(
name|conn
operator|->
name|ostream_head
argument_list|)
expr_stmt|;
name|conn
operator|->
name|ostream_head
operator|=
name|NULL
expr_stmt|;
name|conn
operator|->
name|ostream_tail
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|detect_eof
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|serf_bucket_t
modifier|*
name|aggregate_bucket
parameter_list|)
block|{
name|serf_connection_t
modifier|*
name|conn
init|=
name|baton
decl_stmt|;
name|conn
operator|->
name|hit_eof
operator|=
literal|1
expr_stmt|;
return|return
name|APR_EAGAIN
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|do_conn_setup
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|serf_bucket_t
modifier|*
name|ostream
decl_stmt|;
if|if
condition|(
name|conn
operator|->
name|ostream_head
operator|==
name|NULL
condition|)
block|{
name|conn
operator|->
name|ostream_head
operator|=
name|serf_bucket_aggregate_create
argument_list|(
name|conn
operator|->
name|allocator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conn
operator|->
name|ostream_tail
operator|==
name|NULL
condition|)
block|{
name|conn
operator|->
name|ostream_tail
operator|=
name|serf__bucket_stream_create
argument_list|(
name|conn
operator|->
name|allocator
argument_list|,
name|detect_eof
argument_list|,
name|conn
argument_list|)
expr_stmt|;
block|}
name|ostream
operator|=
name|conn
operator|->
name|ostream_tail
expr_stmt|;
name|status
operator|=
call|(
modifier|*
name|conn
operator|->
name|setup
call|)
argument_list|(
name|conn
operator|->
name|skt
argument_list|,
operator|&
name|conn
operator|->
name|stream
argument_list|,
operator|&
name|ostream
argument_list|,
name|conn
operator|->
name|setup_baton
argument_list|,
name|conn
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
comment|/* extra destroy here since it wasn't added to the head bucket yet. */
name|serf_bucket_destroy
argument_list|(
name|conn
operator|->
name|ostream_tail
argument_list|)
expr_stmt|;
name|destroy_ostream
argument_list|(
name|conn
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|serf_bucket_aggregate_append
argument_list|(
name|conn
operator|->
name|ostream_head
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Set up the input and output stream buckets.  When a tunnel over an http proxy is needed, create a socket bucket and  empty aggregate bucket for sending and receiving unencrypted requests  over the socket.   After the tunnel is there, or no tunnel was needed, ask the application  to create the input and output buckets, which should take care of the  [en/de]cryption.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|prepare_conn_streams
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|serf_bucket_t
modifier|*
modifier|*
name|istream
parameter_list|,
name|serf_bucket_t
modifier|*
modifier|*
name|ostreamt
parameter_list|,
name|serf_bucket_t
modifier|*
modifier|*
name|ostreamh
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
if|if
condition|(
name|conn
operator|->
name|stream
operator|==
name|NULL
condition|)
block|{
name|conn
operator|->
name|latency
operator|=
name|apr_time_now
argument_list|()
operator|-
name|conn
operator|->
name|connect_time
expr_stmt|;
block|}
comment|/* Do we need a SSL tunnel first? */
if|if
condition|(
name|conn
operator|->
name|state
operator|==
name|SERF_CONN_CONNECTED
condition|)
block|{
comment|/* If the connection does not have an associated bucket, then          * call the setup callback to get one.          */
if|if
condition|(
name|conn
operator|->
name|stream
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|do_conn_setup
argument_list|(
name|conn
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
block|}
operator|*
name|ostreamt
operator|=
name|conn
operator|->
name|ostream_tail
expr_stmt|;
operator|*
name|ostreamh
operator|=
name|conn
operator|->
name|ostream_head
expr_stmt|;
operator|*
name|istream
operator|=
name|conn
operator|->
name|stream
expr_stmt|;
block|}
else|else
block|{
comment|/* SSL tunnel needed and not set up yet, get a direct unencrypted          stream for this socket */
if|if
condition|(
name|conn
operator|->
name|stream
operator|==
name|NULL
condition|)
block|{
operator|*
name|istream
operator|=
name|serf_bucket_socket_create
argument_list|(
name|conn
operator|->
name|skt
argument_list|,
name|conn
operator|->
name|allocator
argument_list|)
expr_stmt|;
block|}
comment|/* Don't create the ostream bucket chain including the ssl_encrypt          bucket yet. This ensure the CONNECT request is sent unencrypted          to the proxy. */
operator|*
name|ostreamt
operator|=
operator|*
name|ostreamh
operator|=
name|conn
operator|->
name|ssltunnel_ostream
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Create and connect sockets for any connections which don't have them  * yet. This is the core of our lazy-connect behavior.  */
end_comment

begin_function
name|apr_status_t
name|serf__open_connections
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ctx
operator|->
name|conns
operator|->
name|nelts
init|;
name|i
operator|--
condition|;
control|)
block|{
name|serf_connection_t
modifier|*
name|conn
init|=
name|GET_CONN
argument_list|(
name|ctx
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|serf__authn_info_t
modifier|*
name|authn_info
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|apr_socket_t
modifier|*
name|skt
decl_stmt|;
name|conn
operator|->
name|seen_in_pollset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|skt
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SERF_DEBUG_BUCKET_USE
name|check_buckets_drained
argument_list|(
name|conn
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
comment|/* Delay opening until we have something to deliver! */
if|if
condition|(
name|conn
operator|->
name|requests
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
name|apr_pool_clear
argument_list|(
name|conn
operator|->
name|skt_pool
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|conn
operator|->
name|skt_pool
argument_list|,
name|conn
argument_list|,
name|clean_skt
argument_list|,
name|clean_skt
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_socket_create
argument_list|(
operator|&
name|skt
argument_list|,
name|conn
operator|->
name|address
operator|->
name|family
argument_list|,
name|SOCK_STREAM
argument_list|,
if|#
directive|if
name|APR_MAJOR_VERSION
operator|>
literal|0
name|APR_PROTO_TCP
argument_list|,
endif|#
directive|endif
name|conn
operator|->
name|skt_pool
argument_list|)
expr_stmt|;
name|serf__log
argument_list|(
name|SOCK_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"created socket for conn 0x%x, status %d\n"
argument_list|,
name|conn
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Set the socket to be non-blocking */
if|if
condition|(
operator|(
name|status
operator|=
name|apr_socket_timeout_set
argument_list|(
name|skt
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Disable Nagle's algorithm */
if|if
condition|(
operator|(
name|status
operator|=
name|apr_socket_opt_set
argument_list|(
name|skt
argument_list|,
name|APR_TCP_NODELAY
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Configured. Store it into the connection now. */
name|conn
operator|->
name|skt
operator|=
name|skt
expr_stmt|;
comment|/* Remember time when we started connecting to server to calculate            network latency. */
name|conn
operator|->
name|connect_time
operator|=
name|apr_time_now
argument_list|()
expr_stmt|;
comment|/* Now that the socket is set up, let's connect it. This should          * return immediately.          */
name|status
operator|=
name|apr_socket_connect
argument_list|(
name|skt
argument_list|,
name|conn
operator|->
name|address
argument_list|)
expr_stmt|;
name|serf__log_skt
argument_list|(
name|SOCK_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|skt
argument_list|,
literal|"connected socket for conn 0x%x, status %d\n"
argument_list|,
name|conn
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|APR_SUCCESS
condition|)
block|{
if|if
condition|(
operator|!
name|APR_STATUS_IS_EINPROGRESS
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|status
return|;
block|}
comment|/* Flag our pollset as dirty now that we have a new socket. */
name|conn
operator|->
name|dirty_conn
operator|=
literal|1
expr_stmt|;
name|ctx
operator|->
name|dirty_pollset
operator|=
literal|1
expr_stmt|;
comment|/* If the authentication was already started on another connection,            prepare this connection (it might be possible to skip some            part of the handshaking). */
if|if
condition|(
name|ctx
operator|->
name|proxy_address
condition|)
block|{
name|authn_info
operator|=
operator|&
name|ctx
operator|->
name|proxy_authn_info
expr_stmt|;
if|if
condition|(
name|authn_info
operator|->
name|scheme
condition|)
block|{
name|authn_info
operator|->
name|scheme
operator|->
name|init_conn_func
argument_list|(
name|authn_info
operator|->
name|scheme
argument_list|,
literal|407
argument_list|,
name|conn
argument_list|,
name|conn
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
name|authn_info
operator|=
name|serf__get_authn_info_for_server
argument_list|(
name|conn
argument_list|)
expr_stmt|;
if|if
condition|(
name|authn_info
operator|->
name|scheme
condition|)
block|{
name|authn_info
operator|->
name|scheme
operator|->
name|init_conn_func
argument_list|(
name|authn_info
operator|->
name|scheme
argument_list|,
literal|401
argument_list|,
name|conn
argument_list|,
name|conn
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Does this connection require a SSL tunnel over the proxy? */
if|if
condition|(
name|ctx
operator|->
name|proxy_address
operator|&&
name|strcmp
argument_list|(
name|conn
operator|->
name|host_info
operator|.
name|scheme
argument_list|,
literal|"https"
argument_list|)
operator|==
literal|0
condition|)
name|serf__ssltunnel_connect
argument_list|(
name|conn
argument_list|)
expr_stmt|;
else|else
block|{
name|serf_bucket_t
modifier|*
name|dummy1
decl_stmt|,
modifier|*
name|dummy2
decl_stmt|;
name|conn
operator|->
name|state
operator|=
name|SERF_CONN_CONNECTED
expr_stmt|;
name|status
operator|=
name|prepare_conn_streams
argument_list|(
name|conn
argument_list|,
operator|&
name|conn
operator|->
name|stream
argument_list|,
operator|&
name|dummy1
argument_list|,
operator|&
name|dummy2
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
block|}
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|no_more_writes
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|)
block|{
comment|/* Note that we should hold new requests until we open our new socket. */
name|conn
operator|->
name|state
operator|=
name|SERF_CONN_CLOSING
expr_stmt|;
name|serf__log_skt
argument_list|(
name|CONN_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"stop writing on conn 0x%x\n"
argument_list|,
name|conn
argument_list|)
expr_stmt|;
comment|/* Clear our iovec. */
name|conn
operator|->
name|vec_len
operator|=
literal|0
expr_stmt|;
comment|/* Update the pollset to know we don't want to write on this socket any      * more.      */
name|conn
operator|->
name|dirty_conn
operator|=
literal|1
expr_stmt|;
name|conn
operator|->
name|ctx
operator|->
name|dirty_pollset
operator|=
literal|1
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Read the 'Connection' header from the response. Return SERF_ERROR_CLOSING if  * the header contains value 'close' indicating the server is closing the  * connection right after this response.  * Otherwise returns APR_SUCCESS.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|is_conn_closing
parameter_list|(
name|serf_bucket_t
modifier|*
name|response
parameter_list|)
block|{
name|serf_bucket_t
modifier|*
name|hdrs
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|hdrs
operator|=
name|serf_bucket_response_get_headers
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|val
operator|=
name|serf_bucket_headers_get
argument_list|(
name|hdrs
argument_list|,
literal|"Connection"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|strcasecmp
argument_list|(
literal|"close"
argument_list|,
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|SERF_ERROR_CLOSING
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|link_requests
parameter_list|(
name|serf_request_t
modifier|*
modifier|*
name|list
parameter_list|,
name|serf_request_t
modifier|*
modifier|*
name|tail
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|)
block|{
if|if
condition|(
operator|*
name|list
operator|==
name|NULL
condition|)
block|{
operator|*
name|list
operator|=
name|request
expr_stmt|;
operator|*
name|tail
operator|=
name|request
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|=
name|request
expr_stmt|;
operator|*
name|tail
operator|=
name|request
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|destroy_request
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|)
block|{
name|serf_connection_t
modifier|*
name|conn
init|=
name|request
operator|->
name|conn
decl_stmt|;
comment|/* The request and response buckets are no longer needed,        nor is the request's pool.  */
if|if
condition|(
name|request
operator|->
name|resp_bkt
condition|)
block|{
name|serf_debug__closed_conn
argument_list|(
name|request
operator|->
name|resp_bkt
operator|->
name|allocator
argument_list|)
expr_stmt|;
name|serf_bucket_destroy
argument_list|(
name|request
operator|->
name|resp_bkt
argument_list|)
expr_stmt|;
name|request
operator|->
name|resp_bkt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|request
operator|->
name|req_bkt
condition|)
block|{
name|serf_debug__closed_conn
argument_list|(
name|request
operator|->
name|req_bkt
operator|->
name|allocator
argument_list|)
expr_stmt|;
name|serf_bucket_destroy
argument_list|(
name|request
operator|->
name|req_bkt
argument_list|)
expr_stmt|;
name|request
operator|->
name|req_bkt
operator|=
name|NULL
expr_stmt|;
block|}
name|serf_debug__bucket_alloc_check
argument_list|(
name|request
operator|->
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|respool
condition|)
block|{
comment|/* ### unregister the pool cleanup for self?  */
name|apr_pool_destroy
argument_list|(
name|request
operator|->
name|respool
argument_list|)
expr_stmt|;
block|}
name|serf_bucket_mem_free
argument_list|(
name|conn
operator|->
name|allocator
argument_list|,
name|request
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|cancel_request
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_request_t
modifier|*
modifier|*
name|list
parameter_list|,
name|int
name|notify_request
parameter_list|)
block|{
comment|/* If we haven't run setup, then we won't have a handler to call. */
if|if
condition|(
name|request
operator|->
name|handler
operator|&&
name|notify_request
condition|)
block|{
comment|/* We actually don't care what the handler returns.          * We have bigger matters at hand.          */
call|(
modifier|*
name|request
operator|->
name|handler
call|)
argument_list|(
name|request
argument_list|,
name|NULL
argument_list|,
name|request
operator|->
name|handler_baton
argument_list|,
name|request
operator|->
name|respool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|list
operator|==
name|request
condition|)
block|{
operator|*
name|list
operator|=
name|request
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|serf_request_t
modifier|*
name|scan
init|=
operator|*
name|list
decl_stmt|;
while|while
condition|(
name|scan
operator|->
name|next
operator|&&
name|scan
operator|->
name|next
operator|!=
name|request
condition|)
name|scan
operator|=
name|scan
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|scan
operator|->
name|next
condition|)
block|{
name|scan
operator|->
name|next
operator|=
name|scan
operator|->
name|next
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
name|destroy_request
argument_list|(
name|request
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|remove_connection
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|serf_connection_t
modifier|*
name|conn
parameter_list|)
block|{
name|apr_pollfd_t
name|desc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|desc
operator|.
name|desc_type
operator|=
name|APR_POLL_SOCKET
expr_stmt|;
name|desc
operator|.
name|desc
operator|.
name|s
operator|=
name|conn
operator|->
name|skt
expr_stmt|;
name|desc
operator|.
name|reqevents
operator|=
name|conn
operator|->
name|reqevents
expr_stmt|;
return|return
name|ctx
operator|->
name|pollset_rm
argument_list|(
name|ctx
operator|->
name|pollset_baton
argument_list|,
operator|&
name|desc
argument_list|,
name|conn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A socket was closed, inform the application. */
end_comment

begin_function
specifier|static
name|void
name|handle_conn_closed
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|apr_status_t
name|status
parameter_list|)
block|{
call|(
modifier|*
name|conn
operator|->
name|closed
call|)
argument_list|(
name|conn
argument_list|,
name|conn
operator|->
name|closed_baton
argument_list|,
name|status
argument_list|,
name|conn
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|reset_connection
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|int
name|requeue_requests
parameter_list|)
block|{
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|serf_request_t
modifier|*
name|old_reqs
decl_stmt|;
name|conn
operator|->
name|probable_keepalive_limit
operator|=
name|conn
operator|->
name|completed_responses
expr_stmt|;
name|conn
operator|->
name|completed_requests
operator|=
literal|0
expr_stmt|;
name|conn
operator|->
name|completed_responses
operator|=
literal|0
expr_stmt|;
name|old_reqs
operator|=
name|conn
operator|->
name|requests
expr_stmt|;
name|conn
operator|->
name|requests
operator|=
name|NULL
expr_stmt|;
name|conn
operator|->
name|requests_tail
operator|=
name|NULL
expr_stmt|;
comment|/* Handle all outstanding requests. These have either not been written yet,        or have been written but the expected reply wasn't received yet. */
while|while
condition|(
name|old_reqs
condition|)
block|{
comment|/* If we haven't started to write the connection, bring it over          * unchanged to our new socket.          * Do not copy a CONNECT request to the new connection, the ssl tunnel          * setup code will create a new CONNECT request already.          */
if|if
condition|(
name|requeue_requests
operator|&&
operator|!
name|old_reqs
operator|->
name|writing_started
operator|&&
operator|!
name|old_reqs
operator|->
name|ssltunnel
condition|)
block|{
name|serf_request_t
modifier|*
name|req
init|=
name|old_reqs
decl_stmt|;
name|old_reqs
operator|=
name|old_reqs
operator|->
name|next
expr_stmt|;
name|req
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|link_requests
argument_list|(
operator|&
name|conn
operator|->
name|requests
argument_list|,
operator|&
name|conn
operator|->
name|requests_tail
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Request has been consumed, or we don't want to requeue the                request. Either way, inform the application that the request                is cancelled. */
name|cancel_request
argument_list|(
name|old_reqs
argument_list|,
operator|&
name|old_reqs
argument_list|,
name|requeue_requests
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Requests queue has been prepared for a new socket, close the old one. */
if|if
condition|(
name|conn
operator|->
name|skt
operator|!=
name|NULL
condition|)
block|{
name|remove_connection
argument_list|(
name|ctx
argument_list|,
name|conn
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_socket_close
argument_list|(
name|conn
operator|->
name|skt
argument_list|)
expr_stmt|;
name|serf__log_skt
argument_list|(
name|SOCK_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"closed socket, status %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|closed
operator|!=
name|NULL
condition|)
block|{
name|handle_conn_closed
argument_list|(
name|conn
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|conn
operator|->
name|skt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|conn
operator|->
name|stream
operator|!=
name|NULL
condition|)
block|{
name|serf_bucket_destroy
argument_list|(
name|conn
operator|->
name|stream
argument_list|)
expr_stmt|;
name|conn
operator|->
name|stream
operator|=
name|NULL
expr_stmt|;
block|}
name|destroy_ostream
argument_list|(
name|conn
argument_list|)
expr_stmt|;
comment|/* Don't try to resume any writes */
name|conn
operator|->
name|vec_len
operator|=
literal|0
expr_stmt|;
name|conn
operator|->
name|dirty_conn
operator|=
literal|1
expr_stmt|;
name|conn
operator|->
name|ctx
operator|->
name|dirty_pollset
operator|=
literal|1
expr_stmt|;
name|conn
operator|->
name|state
operator|=
name|SERF_CONN_INIT
expr_stmt|;
name|serf__log
argument_list|(
name|CONN_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"reset connection 0x%x\n"
argument_list|,
name|conn
argument_list|)
expr_stmt|;
name|conn
operator|->
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
comment|/* Let our context know that we've 'reset' the socket already. */
name|conn
operator|->
name|seen_in_pollset
operator||=
name|APR_POLLHUP
expr_stmt|;
comment|/* Found the connection. Closed it. All done. */
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|socket_writev
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|)
block|{
name|apr_size_t
name|written
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|status
operator|=
name|apr_socket_sendv
argument_list|(
name|conn
operator|->
name|skt
argument_list|,
name|conn
operator|->
name|vec
argument_list|,
name|conn
operator|->
name|vec_len
argument_list|,
operator|&
name|written
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&&
operator|!
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|status
argument_list|)
condition|)
name|serf__log_skt
argument_list|(
name|SOCK_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"socket_sendv error %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* did we write everything? */
if|if
condition|(
name|written
condition|)
block|{
name|apr_size_t
name|len
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|serf__log_skt
argument_list|(
name|SOCK_MSG_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"--- socket_sendv:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|conn
operator|->
name|vec_len
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|+=
name|conn
operator|->
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
if|if
condition|(
name|written
operator|<
name|len
condition|)
block|{
name|serf__log_nopref
argument_list|(
name|SOCK_MSG_VERBOSE
argument_list|,
literal|"%.*s"
argument_list|,
name|conn
operator|->
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
operator|-
operator|(
name|len
operator|-
name|written
operator|)
argument_list|,
name|conn
operator|->
name|vec
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|memmove
argument_list|(
name|conn
operator|->
name|vec
argument_list|,
operator|&
name|conn
operator|->
name|vec
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iovec
argument_list|)
operator|*
operator|(
name|conn
operator|->
name|vec_len
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
name|conn
operator|->
name|vec_len
operator|-=
name|i
expr_stmt|;
block|}
name|conn
operator|->
name|vec
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|(
name|char
operator|*
operator|)
name|conn
operator|->
name|vec
index|[
literal|0
index|]
operator|.
name|iov_base
operator|+
operator|(
name|conn
operator|->
name|vec
index|[
literal|0
index|]
operator|.
name|iov_len
operator|-
operator|(
name|len
operator|-
name|written
operator|)
operator|)
expr_stmt|;
name|conn
operator|->
name|vec
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|len
operator|-
name|written
expr_stmt|;
break|break;
block|}
else|else
block|{
name|serf__log_nopref
argument_list|(
name|SOCK_MSG_VERBOSE
argument_list|,
literal|"%.*s"
argument_list|,
name|conn
operator|->
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|,
name|conn
operator|->
name|vec
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|==
name|written
condition|)
block|{
name|conn
operator|->
name|vec_len
operator|=
literal|0
expr_stmt|;
block|}
name|serf__log_nopref
argument_list|(
name|SOCK_MSG_VERBOSE
argument_list|,
literal|"-(%d)-\n"
argument_list|,
name|written
argument_list|)
expr_stmt|;
comment|/* Log progress information */
name|serf__context_progress_delta
argument_list|(
name|conn
operator|->
name|ctx
argument_list|,
literal|0
argument_list|,
name|written
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|setup_request
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|)
block|{
name|serf_connection_t
modifier|*
name|conn
init|=
name|request
operator|->
name|conn
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
comment|/* Now that we are about to serve the request, allocate a pool. */
name|apr_pool_create
argument_list|(
operator|&
name|request
operator|->
name|respool
argument_list|,
name|conn
operator|->
name|pool
argument_list|)
expr_stmt|;
name|request
operator|->
name|allocator
operator|=
name|serf_bucket_allocator_create
argument_list|(
name|request
operator|->
name|respool
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|request
operator|->
name|respool
argument_list|,
name|request
argument_list|,
name|clean_resp
argument_list|,
name|clean_resp
argument_list|)
expr_stmt|;
comment|/* Fill in the rest of the values for the request. */
name|status
operator|=
name|request
operator|->
name|setup
argument_list|(
name|request
argument_list|,
name|request
operator|->
name|setup_baton
argument_list|,
operator|&
name|request
operator|->
name|req_bkt
argument_list|,
operator|&
name|request
operator|->
name|acceptor
argument_list|,
operator|&
name|request
operator|->
name|acceptor_baton
argument_list|,
operator|&
name|request
operator|->
name|handler
argument_list|,
operator|&
name|request
operator|->
name|handler_baton
argument_list|,
name|request
operator|->
name|respool
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* write data out to the connection */
end_comment

begin_function
specifier|static
name|apr_status_t
name|write_to_connection
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|)
block|{
if|if
condition|(
name|conn
operator|->
name|probable_keepalive_limit
operator|&&
name|conn
operator|->
name|completed_requests
operator|>
name|conn
operator|->
name|probable_keepalive_limit
condition|)
block|{
name|conn
operator|->
name|dirty_conn
operator|=
literal|1
expr_stmt|;
name|conn
operator|->
name|ctx
operator|->
name|dirty_pollset
operator|=
literal|1
expr_stmt|;
comment|/* backoff for now. */
return|return
name|APR_SUCCESS
return|;
block|}
comment|/* Keep reading and sending until we run out of stuff to read, or      * writing would block.      */
while|while
condition|(
literal|1
condition|)
block|{
name|serf_request_t
modifier|*
name|request
decl_stmt|;
name|int
name|stop_reading
init|=
literal|0
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|apr_status_t
name|read_status
decl_stmt|;
name|serf_bucket_t
modifier|*
name|ostreamt
decl_stmt|;
name|serf_bucket_t
modifier|*
name|ostreamh
decl_stmt|;
name|int
name|max_outstanding_requests
init|=
name|conn
operator|->
name|max_outstanding_requests
decl_stmt|;
comment|/* If we're setting up an ssl tunnel, we can't send real requests            at yet, as they need to be encrypted and our encrypt buckets            aren't created yet as we still need to read the unencrypted            response of the CONNECT request. */
if|if
condition|(
name|conn
operator|->
name|state
operator|!=
name|SERF_CONN_CONNECTED
condition|)
name|max_outstanding_requests
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|max_outstanding_requests
operator|&&
name|conn
operator|->
name|completed_requests
operator|-
name|conn
operator|->
name|completed_responses
operator|>=
name|max_outstanding_requests
condition|)
block|{
comment|/* backoff for now. */
return|return
name|APR_SUCCESS
return|;
block|}
comment|/* If we have unwritten data, then write what we can. */
while|while
condition|(
name|conn
operator|->
name|vec_len
condition|)
block|{
name|status
operator|=
name|socket_writev
argument_list|(
name|conn
argument_list|)
expr_stmt|;
comment|/* If the write would have blocked, then we're done. Don't try              * to write anything else to the socket.              */
if|if
condition|(
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|APR_SUCCESS
return|;
if|if
condition|(
name|APR_STATUS_IS_EPIPE
argument_list|(
name|status
argument_list|)
operator|||
name|APR_STATUS_IS_ECONNRESET
argument_list|(
name|status
argument_list|)
operator|||
name|APR_STATUS_IS_ECONNABORTED
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|no_more_writes
argument_list|(
name|conn
argument_list|)
return|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
block|}
comment|/* ### can we have a short write, yet no EAGAIN? a short write            ### would imply unwritten_len> 0 ... */
comment|/* assert: unwritten_len == 0. */
comment|/* We may need to move forward to a request which has something          * to write.          */
if|if
condition|(
operator|!
name|request_or_data_pending
argument_list|(
operator|&
name|request
argument_list|,
name|conn
argument_list|)
condition|)
block|{
comment|/* No more requests (with data) are registered with the              * connection, and no data is pending on the outgoing stream.              * Let's update the pollset so that we don't try to write to this              * socket again.              */
name|conn
operator|->
name|dirty_conn
operator|=
literal|1
expr_stmt|;
name|conn
operator|->
name|ctx
operator|->
name|dirty_pollset
operator|=
literal|1
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
name|status
operator|=
name|prepare_conn_streams
argument_list|(
name|conn
argument_list|,
operator|&
name|conn
operator|->
name|stream
argument_list|,
operator|&
name|ostreamt
argument_list|,
operator|&
name|ostreamh
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
if|if
condition|(
name|request
condition|)
block|{
if|if
condition|(
name|request
operator|->
name|req_bkt
operator|==
name|NULL
condition|)
block|{
name|read_status
operator|=
name|setup_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_status
condition|)
block|{
comment|/* Something bad happened. Propagate any errors. */
return|return
name|read_status
return|;
block|}
block|}
if|if
condition|(
operator|!
name|request
operator|->
name|writing_started
condition|)
block|{
name|request
operator|->
name|writing_started
operator|=
literal|1
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|ostreamt
argument_list|,
name|request
operator|->
name|req_bkt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ### optimize at some point by using read_for_sendfile */
comment|/* TODO: now that read_iovec will effectively try to return as much            data as available, we probably don't want to read ALL_AVAIL, but            a lower number, like the size of one or a few TCP packets, the            available TCP buffer size ... */
name|read_status
operator|=
name|serf_bucket_read_iovec
argument_list|(
name|ostreamh
argument_list|,
name|SERF_READ_ALL_AVAIL
argument_list|,
name|IOV_MAX
argument_list|,
name|conn
operator|->
name|vec
argument_list|,
operator|&
name|conn
operator|->
name|vec_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conn
operator|->
name|hit_eof
condition|)
block|{
if|if
condition|(
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|read_status
argument_list|)
condition|)
block|{
comment|/* We read some stuff, but should not try to read again. */
name|stop_reading
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|read_status
operator|==
name|SERF_ERROR_WAIT_CONN
condition|)
block|{
comment|/* The bucket told us that it can't provide more data until                    more data is read from the socket. This normally happens                    during a SSL handshake.                     We should avoid looking for writability for a while so                    that (hopefully) something will appear in the bucket so                    we can actually write something. otherwise, we could                    end up in a CPU spin: socket wants something, but we                    don't have anything (and keep returning EAGAIN)                  */
name|conn
operator|->
name|stop_writing
operator|=
literal|1
expr_stmt|;
name|conn
operator|->
name|dirty_conn
operator|=
literal|1
expr_stmt|;
name|conn
operator|->
name|ctx
operator|->
name|dirty_pollset
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|read_status
operator|&&
operator|!
name|APR_STATUS_IS_EOF
argument_list|(
name|read_status
argument_list|)
condition|)
block|{
comment|/* Something bad happened. Propagate any errors. */
return|return
name|read_status
return|;
block|}
block|}
comment|/* If we got some data, then deliver it. */
comment|/* ### what to do if we got no data?? is that a problem? */
if|if
condition|(
name|conn
operator|->
name|vec_len
operator|>
literal|0
condition|)
block|{
name|status
operator|=
name|socket_writev
argument_list|(
name|conn
argument_list|)
expr_stmt|;
comment|/* If we can't write any more, or an error occurred, then              * we're done here.              */
if|if
condition|(
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|APR_SUCCESS
return|;
if|if
condition|(
name|APR_STATUS_IS_EPIPE
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|no_more_writes
argument_list|(
name|conn
argument_list|)
return|;
if|if
condition|(
name|APR_STATUS_IS_ECONNRESET
argument_list|(
name|status
argument_list|)
operator|||
name|APR_STATUS_IS_ECONNABORTED
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|no_more_writes
argument_list|(
name|conn
argument_list|)
return|;
block|}
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
block|}
if|if
condition|(
name|read_status
operator|==
name|SERF_ERROR_WAIT_CONN
condition|)
block|{
name|stop_reading
operator|=
literal|1
expr_stmt|;
name|conn
operator|->
name|stop_writing
operator|=
literal|1
expr_stmt|;
name|conn
operator|->
name|dirty_conn
operator|=
literal|1
expr_stmt|;
name|conn
operator|->
name|ctx
operator|->
name|dirty_pollset
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|request
operator|&&
name|read_status
operator|&&
name|conn
operator|->
name|hit_eof
operator|&&
name|conn
operator|->
name|vec_len
operator|==
literal|0
condition|)
block|{
comment|/* If we hit the end of the request bucket and all of its data has              * been written, then clear it out to signify that we're done              * sending the request. On the next iteration through this loop:              * - if there are remaining bytes they will be written, and as the               * request bucket will be completely read it will be destroyed then.              * - we'll see if there are other requests that need to be sent               * ("pipelining").              */
name|conn
operator|->
name|hit_eof
operator|=
literal|0
expr_stmt|;
name|serf_bucket_destroy
argument_list|(
name|request
operator|->
name|req_bkt
argument_list|)
expr_stmt|;
name|request
operator|->
name|req_bkt
operator|=
name|NULL
expr_stmt|;
comment|/* If our connection has async responses enabled, we're not              * going to get a reply back, so kill the request.              */
if|if
condition|(
name|conn
operator|->
name|async_responses
condition|)
block|{
name|conn
operator|->
name|requests
operator|=
name|request
operator|->
name|next
expr_stmt|;
name|destroy_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
name|conn
operator|->
name|completed_requests
operator|++
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|probable_keepalive_limit
operator|&&
name|conn
operator|->
name|completed_requests
operator|>
name|conn
operator|->
name|probable_keepalive_limit
condition|)
block|{
comment|/* backoff for now. */
name|stop_reading
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stop_reading
condition|)
block|{
return|return
name|APR_SUCCESS
return|;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* A response message was received from the server, so call    the handler as specified on the original request. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|handle_response
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
init|=
name|APR_SUCCESS
decl_stmt|;
name|int
name|consumed_response
init|=
literal|0
decl_stmt|;
comment|/* Only enable the new authentication framework if the program has      * registered an authentication credential callback.      *      * This permits older Serf apps to still handle authentication      * themselves by not registering credential callbacks.      */
if|if
condition|(
name|request
operator|->
name|conn
operator|->
name|ctx
operator|->
name|cred_cb
condition|)
block|{
name|status
operator|=
name|serf__handle_auth_response
argument_list|(
operator|&
name|consumed_response
argument_list|,
name|request
argument_list|,
name|request
operator|->
name|resp_bkt
argument_list|,
name|request
operator|->
name|handler_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If there was an error reading the response (maybe there wasn't          enough data available), don't bother passing the response to the          application.           If the authentication was tried, but failed, pass the response          to the application, maybe it can do better. */
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
block|}
if|if
condition|(
operator|!
name|consumed_response
condition|)
block|{
return|return
call|(
modifier|*
name|request
operator|->
name|handler
call|)
argument_list|(
name|request
argument_list|,
name|request
operator|->
name|resp_bkt
argument_list|,
name|request
operator|->
name|handler_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* An async response message was received from the server. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|handle_async_response
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
if|if
condition|(
name|conn
operator|->
name|current_async_response
operator|==
name|NULL
condition|)
block|{
name|conn
operator|->
name|current_async_response
operator|=
call|(
modifier|*
name|conn
operator|->
name|async_acceptor
call|)
argument_list|(
name|NULL
argument_list|,
name|conn
operator|->
name|stream
argument_list|,
name|conn
operator|->
name|async_acceptor_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
call|(
modifier|*
name|conn
operator|->
name|async_handler
call|)
argument_list|(
name|NULL
argument_list|,
name|conn
operator|->
name|current_async_response
argument_list|,
name|conn
operator|->
name|async_handler_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|serf_bucket_destroy
argument_list|(
name|conn
operator|->
name|current_async_response
argument_list|)
expr_stmt|;
name|conn
operator|->
name|current_async_response
operator|=
name|NULL
expr_stmt|;
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf__provide_credentials
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|char
modifier|*
modifier|*
name|username
parameter_list|,
name|char
modifier|*
modifier|*
name|password
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|authn_type
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|serf_connection_t
modifier|*
name|conn
init|=
name|request
operator|->
name|conn
decl_stmt|;
name|serf_request_t
modifier|*
name|authn_req
init|=
name|request
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
if|if
condition|(
name|request
operator|->
name|ssltunnel
operator|==
literal|1
operator|&&
name|conn
operator|->
name|state
operator|==
name|SERF_CONN_SETUP_SSLTUNNEL
condition|)
block|{
comment|/* This is a CONNECT request to set up an SSL tunnel over a proxy.            This request is created by serf, so if the proxy requires            authentication, we can't ask the application for credentials with            this request.             Solution: setup the first request created by the application on            this connection, and use that request and its handler_baton to            call back to the application. */
name|authn_req
operator|=
name|request
operator|->
name|next
expr_stmt|;
comment|/* assert: app_request != NULL */
if|if
condition|(
operator|!
name|authn_req
condition|)
return|return
name|APR_EGENERAL
return|;
if|if
condition|(
operator|!
name|authn_req
operator|->
name|req_bkt
condition|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|status
operator|=
name|setup_request
argument_list|(
name|authn_req
argument_list|)
expr_stmt|;
comment|/* If we can't setup a request, don't bother setting up the                ssl tunnel. */
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
block|}
block|}
comment|/* Ask the application. */
name|status
operator|=
call|(
modifier|*
name|ctx
operator|->
name|cred_cb
call|)
argument_list|(
name|username
argument_list|,
name|password
argument_list|,
name|authn_req
argument_list|,
name|authn_req
operator|->
name|handler_baton
argument_list|,
name|code
argument_list|,
name|authn_type
argument_list|,
name|realm
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* read data from the connection */
end_comment

begin_function
specifier|static
name|apr_status_t
name|read_from_connection
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|apr_pool_t
modifier|*
name|tmppool
decl_stmt|;
name|int
name|close_connection
init|=
name|FALSE
decl_stmt|;
comment|/* Whatever is coming in on the socket corresponds to the first request      * on our chain.      */
name|serf_request_t
modifier|*
name|request
init|=
name|conn
operator|->
name|requests
decl_stmt|;
comment|/* If the stop_writing flag was set on the connection, reset it now because        there is some data to read. */
if|if
condition|(
name|conn
operator|->
name|stop_writing
condition|)
block|{
name|conn
operator|->
name|stop_writing
operator|=
literal|0
expr_stmt|;
name|conn
operator|->
name|dirty_conn
operator|=
literal|1
expr_stmt|;
name|conn
operator|->
name|ctx
operator|->
name|dirty_pollset
operator|=
literal|1
expr_stmt|;
block|}
comment|/* assert: request != NULL */
if|if
condition|(
operator|(
name|status
operator|=
name|apr_pool_create
argument_list|(
operator|&
name|tmppool
argument_list|,
name|conn
operator|->
name|pool
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
goto|goto
name|error
goto|;
comment|/* Invoke response handlers until we have no more work. */
while|while
condition|(
literal|1
condition|)
block|{
name|serf_bucket_t
modifier|*
name|dummy1
decl_stmt|,
modifier|*
name|dummy2
decl_stmt|;
name|apr_pool_clear
argument_list|(
name|tmppool
argument_list|)
expr_stmt|;
comment|/* Only interested in the input stream here. */
name|status
operator|=
name|prepare_conn_streams
argument_list|(
name|conn
argument_list|,
operator|&
name|conn
operator|->
name|stream
argument_list|,
operator|&
name|dummy1
argument_list|,
operator|&
name|dummy2
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* We have a different codepath when we can have async responses. */
if|if
condition|(
name|conn
operator|->
name|async_responses
condition|)
block|{
comment|/* TODO What about socket errors? */
name|status
operator|=
name|handle_async_response
argument_list|(
name|conn
argument_list|,
name|tmppool
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|status
condition|)
block|{
goto|goto
name|error
goto|;
block|}
continue|continue;
block|}
comment|/* We are reading a response for a request we haven't          * written yet!          *          * This shouldn't normally happen EXCEPT:          *          * 1) when the other end has closed the socket and we're          *    pending an EOF return.          * 2) Doing the initial SSL handshake - we'll get EAGAIN          *    as the SSL buckets will hide the handshake from us          *    but not return any data.          * 3) When the server sends us an SSL alert.          *          * In these cases, we should not receive any actual user data.          *          * 4) When the server sends a error response, like 408 Request timeout.          *    This response should be passed to the application.          *          * If we see an EOF (due to either an expired timeout or the server          * sending the SSL 'close notify' shutdown alert), we'll reset the          * connection and open a new one.          */
if|if
condition|(
name|request
operator|->
name|req_bkt
operator|||
operator|!
name|request
operator|->
name|writing_started
condition|)
block|{
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|status
operator|=
name|serf_bucket_peek
argument_list|(
name|conn
operator|->
name|stream
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|reset_connection
argument_list|(
name|conn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|status
argument_list|)
operator|&&
operator|!
name|len
condition|)
block|{
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&&
operator|!
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|status
argument_list|)
condition|)
block|{
comment|/* Read error */
goto|goto
name|error
goto|;
block|}
comment|/* Unexpected response from the server */
block|}
comment|/* If the request doesn't have a response bucket, then call the          * acceptor to get one created.          */
if|if
condition|(
name|request
operator|->
name|resp_bkt
operator|==
name|NULL
condition|)
block|{
name|request
operator|->
name|resp_bkt
operator|=
call|(
modifier|*
name|request
operator|->
name|acceptor
call|)
argument_list|(
name|request
argument_list|,
name|conn
operator|->
name|stream
argument_list|,
name|request
operator|->
name|acceptor_baton
argument_list|,
name|tmppool
argument_list|)
expr_stmt|;
name|apr_pool_clear
argument_list|(
name|tmppool
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|handle_response
argument_list|(
name|request
argument_list|,
name|tmppool
argument_list|)
expr_stmt|;
comment|/* Some systems will not generate a HUP poll event so we have to          * handle the ECONNRESET issue and ECONNABORT here.          */
if|if
condition|(
name|APR_STATUS_IS_ECONNRESET
argument_list|(
name|status
argument_list|)
operator|||
name|APR_STATUS_IS_ECONNABORTED
argument_list|(
name|status
argument_list|)
operator|||
name|status
operator|==
name|SERF_ERROR_REQUEST_LOST
condition|)
block|{
comment|/* If the connection had ever been good, be optimistic& try again.              * If it has never tried again (incl. a retry), fail.              */
if|if
condition|(
name|conn
operator|->
name|completed_responses
condition|)
block|{
name|reset_connection
argument_list|(
name|conn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|SERF_ERROR_REQUEST_LOST
condition|)
block|{
name|status
operator|=
name|SERF_ERROR_ABORTED_CONNECTION
expr_stmt|;
block|}
goto|goto
name|error
goto|;
block|}
comment|/* If our response handler says it can't do anything more, we now          * treat that as a success.          */
if|if
condition|(
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|status
argument_list|)
condition|)
block|{
comment|/* It is possible that while reading the response, the ssl layer                has prepared some data to send. If this was the last request,                serf will not check for socket writability, so force this here.              */
if|if
condition|(
name|request_or_data_pending
argument_list|(
operator|&
name|request
argument_list|,
name|conn
argument_list|)
operator|&&
operator|!
name|request
condition|)
block|{
name|conn
operator|->
name|dirty_conn
operator|=
literal|1
expr_stmt|;
name|conn
operator|->
name|ctx
operator|->
name|dirty_pollset
operator|=
literal|1
expr_stmt|;
block|}
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* If we received APR_SUCCESS, run this loop again. */
if|if
condition|(
operator|!
name|status
condition|)
block|{
continue|continue;
block|}
name|close_connection
operator|=
name|is_conn_closing
argument_list|(
name|request
operator|->
name|resp_bkt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
operator|&&
name|close_connection
operator|!=
name|SERF_ERROR_CLOSING
condition|)
block|{
comment|/* Whether success, or an error, there is no more to do unless              * this request has been completed.              */
goto|goto
name|error
goto|;
block|}
comment|/* The response has been fully-read, so that means the request has          * either been fully-delivered (most likely), or that we don't need to          * write the rest of it anymore, e.g. when a 408 Request timeout was          $ received.          * Remove it from our queue and loop to read another response.          */
name|conn
operator|->
name|requests
operator|=
name|request
operator|->
name|next
expr_stmt|;
name|destroy_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|request
operator|=
name|conn
operator|->
name|requests
expr_stmt|;
comment|/* If we're truly empty, update our tail. */
if|if
condition|(
name|request
operator|==
name|NULL
condition|)
block|{
name|conn
operator|->
name|requests_tail
operator|=
name|NULL
expr_stmt|;
block|}
name|conn
operator|->
name|completed_responses
operator|++
expr_stmt|;
comment|/* We've to rebuild pollset since completed_responses is changed. */
name|conn
operator|->
name|dirty_conn
operator|=
literal|1
expr_stmt|;
name|conn
operator|->
name|ctx
operator|->
name|dirty_pollset
operator|=
literal|1
expr_stmt|;
comment|/* This means that we're being advised that the connection is done. */
if|if
condition|(
name|close_connection
operator|==
name|SERF_ERROR_CLOSING
condition|)
block|{
name|reset_connection
argument_list|(
name|conn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* The server is suddenly deciding to serve more responses than we've          * seen before.          *          * Let our requests go.          */
if|if
condition|(
name|conn
operator|->
name|probable_keepalive_limit
operator|&&
name|conn
operator|->
name|completed_responses
operator|>
name|conn
operator|->
name|probable_keepalive_limit
condition|)
block|{
name|conn
operator|->
name|probable_keepalive_limit
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we just ran out of requests or have unwritten requests, then          * update the pollset. We don't want to read from this socket any          * more. We are definitely done with this loop, too.          */
if|if
condition|(
name|request
operator|==
name|NULL
operator|||
operator|!
name|request
operator|->
name|writing_started
condition|)
block|{
name|conn
operator|->
name|dirty_conn
operator|=
literal|1
expr_stmt|;
name|conn
operator|->
name|ctx
operator|->
name|dirty_pollset
operator|=
literal|1
expr_stmt|;
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|error
label|:
name|apr_pool_destroy
argument_list|(
name|tmppool
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* process all events on the connection */
end_comment

begin_function
name|apr_status_t
name|serf__process_connection
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|apr_int16_t
name|events
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
comment|/* POLLHUP/ERR should come after POLLIN so if there's an error message or      * the like sitting on the connection, we give the app a chance to read      * it before we trigger a reset condition.      */
if|if
condition|(
operator|(
name|events
operator|&
name|APR_POLLIN
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|read_from_connection
argument_list|(
name|conn
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* If we decided to reset our connection, return now as we don't          * want to write.          */
if|if
condition|(
operator|(
name|conn
operator|->
name|seen_in_pollset
operator|&
name|APR_POLLHUP
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|APR_SUCCESS
return|;
block|}
block|}
if|if
condition|(
operator|(
name|events
operator|&
name|APR_POLLHUP
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* The connection got reset by the server. On Windows this can happen            when all data is read, so just cleanup the connection and open            a new one.            If we haven't had any successful responses on this connection,            then error out as it is likely a server issue. */
if|if
condition|(
name|conn
operator|->
name|completed_responses
condition|)
block|{
return|return
name|reset_connection
argument_list|(
name|conn
argument_list|,
literal|1
argument_list|)
return|;
block|}
return|return
name|SERF_ERROR_ABORTED_CONNECTION
return|;
block|}
if|if
condition|(
operator|(
name|events
operator|&
name|APR_POLLERR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We might be talking to a buggy HTTP server that doesn't          * do lingering-close.  (httpd< 2.1.8 does this.)          *          * See:          *          * http://issues.apache.org/bugzilla/show_bug.cgi?id=35292          */
if|if
condition|(
name|conn
operator|->
name|completed_requests
operator|&&
operator|!
name|conn
operator|->
name|probable_keepalive_limit
condition|)
block|{
return|return
name|reset_connection
argument_list|(
name|conn
argument_list|,
literal|1
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|SO_ERROR
comment|/* If possible, get the error from the platform's socket layer and            convert it to an APR status code. */
block|{
name|apr_os_sock_t
name|osskt
decl_stmt|;
if|if
condition|(
operator|!
name|apr_os_sock_get
argument_list|(
operator|&
name|osskt
argument_list|,
name|conn
operator|->
name|skt
argument_list|)
condition|)
block|{
name|int
name|error
decl_stmt|;
name|apr_socklen_t
name|l
init|=
sizeof|sizeof
argument_list|(
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|getsockopt
argument_list|(
name|osskt
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|error
argument_list|,
operator|&
name|l
argument_list|)
condition|)
block|{
name|status
operator|=
name|APR_FROM_OS_ERROR
argument_list|(
name|error
argument_list|)
expr_stmt|;
comment|/* Handle fallback for multi-homed servers.                                              ### Improve algorithm to find better than just 'next'?                         Current Windows versions already handle re-ordering for                        api users by using statistics on the recently failed                        connections to order the list of addresses. */
if|if
condition|(
name|conn
operator|->
name|completed_requests
operator|==
literal|0
operator|&&
name|conn
operator|->
name|address
operator|->
name|next
operator|!=
name|NULL
operator|&&
operator|(
name|APR_STATUS_IS_ECONNREFUSED
argument_list|(
name|status
argument_list|)
operator|||
name|APR_STATUS_IS_TIMEUP
argument_list|(
name|status
argument_list|)
operator|||
name|APR_STATUS_IS_ENETUNREACH
argument_list|(
name|status
argument_list|)
operator|)
condition|)
block|{
name|conn
operator|->
name|address
operator|=
name|conn
operator|->
name|address
operator|->
name|next
expr_stmt|;
return|return
name|reset_connection
argument_list|(
name|conn
argument_list|,
literal|1
argument_list|)
return|;
block|}
return|return
name|status
return|;
block|}
block|}
block|}
endif|#
directive|endif
return|return
name|APR_EGENERAL
return|;
block|}
if|if
condition|(
operator|(
name|events
operator|&
name|APR_POLLOUT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|write_to_connection
argument_list|(
name|conn
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|serf_connection_t
modifier|*
name|serf_connection_create
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|apr_sockaddr_t
modifier|*
name|address
parameter_list|,
name|serf_connection_setup_t
name|setup
parameter_list|,
name|void
modifier|*
name|setup_baton
parameter_list|,
name|serf_connection_closed_t
name|closed
parameter_list|,
name|void
modifier|*
name|closed_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|serf_connection_t
modifier|*
name|conn
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|conn
argument_list|)
argument_list|)
decl_stmt|;
name|conn
operator|->
name|ctx
operator|=
name|ctx
expr_stmt|;
name|conn
operator|->
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
comment|/* Ignore server address if proxy was specified. */
name|conn
operator|->
name|address
operator|=
name|ctx
operator|->
name|proxy_address
condition|?
name|ctx
operator|->
name|proxy_address
else|:
name|address
expr_stmt|;
name|conn
operator|->
name|setup
operator|=
name|setup
expr_stmt|;
name|conn
operator|->
name|setup_baton
operator|=
name|setup_baton
expr_stmt|;
name|conn
operator|->
name|closed
operator|=
name|closed
expr_stmt|;
name|conn
operator|->
name|closed_baton
operator|=
name|closed_baton
expr_stmt|;
name|conn
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|conn
operator|->
name|allocator
operator|=
name|serf_bucket_allocator_create
argument_list|(
name|pool
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|conn
operator|->
name|stream
operator|=
name|NULL
expr_stmt|;
name|conn
operator|->
name|ostream_head
operator|=
name|NULL
expr_stmt|;
name|conn
operator|->
name|ostream_tail
operator|=
name|NULL
expr_stmt|;
name|conn
operator|->
name|baton
operator|.
name|type
operator|=
name|SERF_IO_CONN
expr_stmt|;
name|conn
operator|->
name|baton
operator|.
name|u
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
name|conn
operator|->
name|hit_eof
operator|=
literal|0
expr_stmt|;
name|conn
operator|->
name|state
operator|=
name|SERF_CONN_INIT
expr_stmt|;
name|conn
operator|->
name|latency
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* unknown */
comment|/* Create a subpool for our connection. */
name|apr_pool_create
argument_list|(
operator|&
name|conn
operator|->
name|skt_pool
argument_list|,
name|conn
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* register a cleanup */
name|apr_pool_cleanup_register
argument_list|(
name|conn
operator|->
name|pool
argument_list|,
name|conn
argument_list|,
name|clean_conn
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
comment|/* Add the connection to the context. */
operator|*
operator|(
name|serf_connection_t
operator|*
operator|*
operator|)
name|apr_array_push
argument_list|(
name|ctx
operator|->
name|conns
argument_list|)
operator|=
name|conn
expr_stmt|;
name|serf__log
argument_list|(
name|CONN_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"created connection 0x%x\n"
argument_list|,
name|conn
argument_list|)
expr_stmt|;
return|return
name|conn
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf_connection_create2
parameter_list|(
name|serf_connection_t
modifier|*
modifier|*
name|conn
parameter_list|,
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|apr_uri_t
name|host_info
parameter_list|,
name|serf_connection_setup_t
name|setup
parameter_list|,
name|void
modifier|*
name|setup_baton
parameter_list|,
name|serf_connection_closed_t
name|closed
parameter_list|,
name|void
modifier|*
name|closed_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
init|=
name|APR_SUCCESS
decl_stmt|;
name|serf_connection_t
modifier|*
name|c
decl_stmt|;
name|apr_sockaddr_t
modifier|*
name|host_address
init|=
name|NULL
decl_stmt|;
comment|/* Set the port number explicitly, needed to create the socket later. */
if|if
condition|(
operator|!
name|host_info
operator|.
name|port
condition|)
block|{
name|host_info
operator|.
name|port
operator|=
name|apr_uri_port_of_scheme
argument_list|(
name|host_info
operator|.
name|scheme
argument_list|)
expr_stmt|;
block|}
comment|/* Only lookup the address of the server if no proxy server was        configured. */
if|if
condition|(
operator|!
name|ctx
operator|->
name|proxy_address
condition|)
block|{
name|status
operator|=
name|apr_sockaddr_info_get
argument_list|(
operator|&
name|host_address
argument_list|,
name|host_info
operator|.
name|hostname
argument_list|,
name|APR_UNSPEC
argument_list|,
name|host_info
operator|.
name|port
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
block|}
name|c
operator|=
name|serf_connection_create
argument_list|(
name|ctx
argument_list|,
name|host_address
argument_list|,
name|setup
argument_list|,
name|setup_baton
argument_list|,
name|closed
argument_list|,
name|closed_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* We're not interested in the path following the hostname. */
name|c
operator|->
name|host_url
operator|=
name|apr_uri_unparse
argument_list|(
name|c
operator|->
name|pool
argument_list|,
operator|&
name|host_info
argument_list|,
name|APR_URI_UNP_OMITPATHINFO
operator||
name|APR_URI_UNP_OMITUSERINFO
argument_list|)
expr_stmt|;
comment|/* Store the host info without the path on the connection. */
operator|(
name|void
operator|)
name|apr_uri_parse
argument_list|(
name|c
operator|->
name|pool
argument_list|,
name|c
operator|->
name|host_url
argument_list|,
operator|&
operator|(
name|c
operator|->
name|host_info
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|host_info
operator|.
name|port
condition|)
block|{
name|c
operator|->
name|host_info
operator|.
name|port
operator|=
name|apr_uri_port_of_scheme
argument_list|(
name|c
operator|->
name|host_info
operator|.
name|scheme
argument_list|)
expr_stmt|;
block|}
operator|*
name|conn
operator|=
name|c
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf_connection_reset
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|)
block|{
return|return
name|reset_connection
argument_list|(
name|conn
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf_connection_close
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ctx
operator|->
name|conns
operator|->
name|nelts
init|;
name|i
operator|--
condition|;
control|)
block|{
name|serf_connection_t
modifier|*
name|conn_seq
init|=
name|GET_CONN
argument_list|(
name|ctx
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|conn_seq
operator|==
name|conn
condition|)
block|{
while|while
condition|(
name|conn
operator|->
name|requests
condition|)
block|{
name|serf_request_cancel
argument_list|(
name|conn
operator|->
name|requests
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conn
operator|->
name|skt
operator|!=
name|NULL
condition|)
block|{
name|remove_connection
argument_list|(
name|ctx
argument_list|,
name|conn
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_socket_close
argument_list|(
name|conn
operator|->
name|skt
argument_list|)
expr_stmt|;
name|serf__log_skt
argument_list|(
name|SOCK_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"closed socket, status %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|closed
operator|!=
name|NULL
condition|)
block|{
name|handle_conn_closed
argument_list|(
name|conn
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|conn
operator|->
name|skt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|conn
operator|->
name|stream
operator|!=
name|NULL
condition|)
block|{
name|serf_bucket_destroy
argument_list|(
name|conn
operator|->
name|stream
argument_list|)
expr_stmt|;
name|conn
operator|->
name|stream
operator|=
name|NULL
expr_stmt|;
block|}
name|destroy_ostream
argument_list|(
name|conn
argument_list|)
expr_stmt|;
comment|/* Remove the connection from the context. We don't want to              * deal with it any more.              */
if|if
condition|(
name|i
operator|<
name|ctx
operator|->
name|conns
operator|->
name|nelts
operator|-
literal|1
condition|)
block|{
comment|/* move later connections over this one. */
name|memmove
argument_list|(
operator|&
name|GET_CONN
argument_list|(
name|ctx
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|GET_CONN
argument_list|(
name|ctx
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
operator|(
name|ctx
operator|->
name|conns
operator|->
name|nelts
operator|-
name|i
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|serf_connection_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|--
name|ctx
operator|->
name|conns
operator|->
name|nelts
expr_stmt|;
name|serf__log
argument_list|(
name|CONN_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"closed connection 0x%x\n"
argument_list|,
name|conn
argument_list|)
expr_stmt|;
comment|/* Found the connection. Closed it. All done. */
return|return
name|APR_SUCCESS
return|;
block|}
block|}
comment|/* We didn't find the specified connection. */
comment|/* ### doc talks about this w.r.t poll structures. use something else? */
return|return
name|APR_NOTFOUND
return|;
block|}
end_function

begin_function
name|void
name|serf_connection_set_max_outstanding_requests
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|unsigned
name|int
name|max_requests
parameter_list|)
block|{
if|if
condition|(
name|max_requests
operator|==
literal|0
condition|)
name|serf__log_skt
argument_list|(
name|CONN_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"Set max. nr. of outstanding requests for this "
literal|"connection to unlimited.\n"
argument_list|)
expr_stmt|;
else|else
name|serf__log_skt
argument_list|(
name|CONN_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"Limit max. nr. of outstanding requests for this "
literal|"connection to %u.\n"
argument_list|,
name|max_requests
argument_list|)
expr_stmt|;
name|conn
operator|->
name|max_outstanding_requests
operator|=
name|max_requests
expr_stmt|;
block|}
end_function

begin_function
name|void
name|serf_connection_set_async_responses
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|serf_response_acceptor_t
name|acceptor
parameter_list|,
name|void
modifier|*
name|acceptor_baton
parameter_list|,
name|serf_response_handler_t
name|handler
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|)
block|{
name|conn
operator|->
name|async_responses
operator|=
literal|1
expr_stmt|;
name|conn
operator|->
name|async_acceptor
operator|=
name|acceptor
expr_stmt|;
name|conn
operator|->
name|async_acceptor_baton
operator|=
name|acceptor_baton
expr_stmt|;
name|conn
operator|->
name|async_handler
operator|=
name|handler
expr_stmt|;
name|conn
operator|->
name|async_handler_baton
operator|=
name|handler_baton
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|serf_request_t
modifier|*
name|create_request
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|serf_request_setup_t
name|setup
parameter_list|,
name|void
modifier|*
name|setup_baton
parameter_list|,
name|int
name|priority
parameter_list|,
name|int
name|ssltunnel
parameter_list|)
block|{
name|serf_request_t
modifier|*
name|request
decl_stmt|;
name|request
operator|=
name|serf_bucket_mem_alloc
argument_list|(
name|conn
operator|->
name|allocator
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|conn
operator|=
name|conn
expr_stmt|;
name|request
operator|->
name|setup
operator|=
name|setup
expr_stmt|;
name|request
operator|->
name|setup_baton
operator|=
name|setup_baton
expr_stmt|;
name|request
operator|->
name|handler
operator|=
name|NULL
expr_stmt|;
name|request
operator|->
name|respool
operator|=
name|NULL
expr_stmt|;
name|request
operator|->
name|req_bkt
operator|=
name|NULL
expr_stmt|;
name|request
operator|->
name|resp_bkt
operator|=
name|NULL
expr_stmt|;
name|request
operator|->
name|priority
operator|=
name|priority
expr_stmt|;
name|request
operator|->
name|writing_started
operator|=
literal|0
expr_stmt|;
name|request
operator|->
name|ssltunnel
operator|=
name|ssltunnel
expr_stmt|;
name|request
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|request
operator|->
name|auth_baton
operator|=
name|NULL
expr_stmt|;
return|return
name|request
return|;
block|}
end_function

begin_function
name|serf_request_t
modifier|*
name|serf_connection_request_create
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|serf_request_setup_t
name|setup
parameter_list|,
name|void
modifier|*
name|setup_baton
parameter_list|)
block|{
name|serf_request_t
modifier|*
name|request
decl_stmt|;
name|request
operator|=
name|create_request
argument_list|(
name|conn
argument_list|,
name|setup
argument_list|,
name|setup_baton
argument_list|,
literal|0
argument_list|,
comment|/* priority */
literal|0
comment|/* ssl tunnel */
argument_list|)
expr_stmt|;
comment|/* Link the request to the end of the request chain. */
name|link_requests
argument_list|(
operator|&
name|conn
operator|->
name|requests
argument_list|,
operator|&
name|conn
operator|->
name|requests_tail
argument_list|,
name|request
argument_list|)
expr_stmt|;
comment|/* Ensure our pollset becomes writable in context run */
name|conn
operator|->
name|ctx
operator|->
name|dirty_pollset
operator|=
literal|1
expr_stmt|;
name|conn
operator|->
name|dirty_conn
operator|=
literal|1
expr_stmt|;
return|return
name|request
return|;
block|}
end_function

begin_function
specifier|static
name|serf_request_t
modifier|*
name|priority_request_create
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|int
name|ssltunnelreq
parameter_list|,
name|serf_request_setup_t
name|setup
parameter_list|,
name|void
modifier|*
name|setup_baton
parameter_list|)
block|{
name|serf_request_t
modifier|*
name|request
decl_stmt|;
name|serf_request_t
modifier|*
name|iter
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|request
operator|=
name|create_request
argument_list|(
name|conn
argument_list|,
name|setup
argument_list|,
name|setup_baton
argument_list|,
literal|1
argument_list|,
comment|/* priority */
name|ssltunnelreq
argument_list|)
expr_stmt|;
comment|/* Link the new request after the last written request. */
name|iter
operator|=
name|conn
operator|->
name|requests
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
comment|/* Find a request that has data which needs to be delivered. */
while|while
condition|(
name|iter
operator|!=
name|NULL
operator|&&
name|iter
operator|->
name|req_bkt
operator|==
name|NULL
operator|&&
name|iter
operator|->
name|writing_started
condition|)
block|{
name|prev
operator|=
name|iter
expr_stmt|;
name|iter
operator|=
name|iter
operator|->
name|next
expr_stmt|;
block|}
comment|/* A CONNECT request to setup an ssltunnel has absolute priority over all        other requests on the connection, so:        a. add it first to the queue         b. ensure that other priority requests are added after the CONNECT           request */
if|if
condition|(
operator|!
name|request
operator|->
name|ssltunnel
condition|)
block|{
comment|/* Advance to next non priority request */
while|while
condition|(
name|iter
operator|!=
name|NULL
operator|&&
name|iter
operator|->
name|priority
condition|)
block|{
name|prev
operator|=
name|iter
expr_stmt|;
name|iter
operator|=
name|iter
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prev
condition|)
block|{
name|request
operator|->
name|next
operator|=
name|iter
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|request
expr_stmt|;
block|}
else|else
block|{
name|request
operator|->
name|next
operator|=
name|iter
expr_stmt|;
name|conn
operator|->
name|requests
operator|=
name|request
expr_stmt|;
block|}
comment|/* Ensure our pollset becomes writable in context run */
name|conn
operator|->
name|ctx
operator|->
name|dirty_pollset
operator|=
literal|1
expr_stmt|;
name|conn
operator|->
name|dirty_conn
operator|=
literal|1
expr_stmt|;
return|return
name|request
return|;
block|}
end_function

begin_function
name|serf_request_t
modifier|*
name|serf_connection_priority_request_create
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|serf_request_setup_t
name|setup
parameter_list|,
name|void
modifier|*
name|setup_baton
parameter_list|)
block|{
return|return
name|priority_request_create
argument_list|(
name|conn
argument_list|,
literal|0
argument_list|,
comment|/* not a ssltunnel CONNECT request */
name|setup
argument_list|,
name|setup_baton
argument_list|)
return|;
block|}
end_function

begin_function
name|serf_request_t
modifier|*
name|serf__ssltunnel_request_create
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|serf_request_setup_t
name|setup
parameter_list|,
name|void
modifier|*
name|setup_baton
parameter_list|)
block|{
return|return
name|priority_request_create
argument_list|(
name|conn
argument_list|,
literal|1
argument_list|,
comment|/* This is a ssltunnel CONNECT request */
name|setup
argument_list|,
name|setup_baton
argument_list|)
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf_request_cancel
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|)
block|{
return|return
name|cancel_request
argument_list|(
name|request
argument_list|,
operator|&
name|request
operator|->
name|conn
operator|->
name|requests
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf_request_is_written
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|)
block|{
if|if
condition|(
name|request
operator|->
name|writing_started
operator|&&
operator|!
name|request
operator|->
name|req_bkt
condition|)
return|return
name|APR_SUCCESS
return|;
return|return
name|APR_EBUSY
return|;
block|}
end_function

begin_function
name|apr_pool_t
modifier|*
name|serf_request_get_pool
parameter_list|(
specifier|const
name|serf_request_t
modifier|*
name|request
parameter_list|)
block|{
return|return
name|request
operator|->
name|respool
return|;
block|}
end_function

begin_function
name|serf_bucket_alloc_t
modifier|*
name|serf_request_get_alloc
parameter_list|(
specifier|const
name|serf_request_t
modifier|*
name|request
parameter_list|)
block|{
return|return
name|request
operator|->
name|allocator
return|;
block|}
end_function

begin_function
name|serf_connection_t
modifier|*
name|serf_request_get_conn
parameter_list|(
specifier|const
name|serf_request_t
modifier|*
name|request
parameter_list|)
block|{
return|return
name|request
operator|->
name|conn
return|;
block|}
end_function

begin_function
name|void
name|serf_request_set_handler
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
specifier|const
name|serf_response_handler_t
name|handler
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|)
block|{
name|request
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
name|request
operator|->
name|handler_baton
operator|=
name|handler_baton
expr_stmt|;
block|}
end_function

begin_function
name|serf_bucket_t
modifier|*
name|serf_request_bucket_request_create
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|,
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|serf_bucket_t
modifier|*
name|body
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
block|{
name|serf_bucket_t
modifier|*
name|req_bkt
decl_stmt|,
modifier|*
name|hdrs_bkt
decl_stmt|;
name|serf_connection_t
modifier|*
name|conn
init|=
name|request
operator|->
name|conn
decl_stmt|;
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|int
name|ssltunnel
decl_stmt|;
name|ssltunnel
operator|=
name|ctx
operator|->
name|proxy_address
operator|&&
operator|(
name|strcmp
argument_list|(
name|conn
operator|->
name|host_info
operator|.
name|scheme
argument_list|,
literal|"https"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|req_bkt
operator|=
name|serf_bucket_request_create
argument_list|(
name|method
argument_list|,
name|uri
argument_list|,
name|body
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|hdrs_bkt
operator|=
name|serf_bucket_request_get_headers
argument_list|(
name|req_bkt
argument_list|)
expr_stmt|;
comment|/* Use absolute uri's in requests to a proxy. USe relative uri's in        requests directly to a server or sent through an SSL tunnel. */
if|if
condition|(
name|ctx
operator|->
name|proxy_address
operator|&&
name|conn
operator|->
name|host_url
operator|&&
operator|!
operator|(
name|ssltunnel
operator|&&
operator|!
name|request
operator|->
name|ssltunnel
operator|)
condition|)
block|{
name|serf_bucket_request_set_root
argument_list|(
name|req_bkt
argument_list|,
name|conn
operator|->
name|host_url
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conn
operator|->
name|host_info
operator|.
name|hostinfo
condition|)
name|serf_bucket_headers_setn
argument_list|(
name|hdrs_bkt
argument_list|,
literal|"Host"
argument_list|,
name|conn
operator|->
name|host_info
operator|.
name|hostinfo
argument_list|)
expr_stmt|;
comment|/* Setup server authorization headers, unless this is a CONNECT request. */
if|if
condition|(
operator|!
name|request
operator|->
name|ssltunnel
condition|)
block|{
name|serf__authn_info_t
modifier|*
name|authn_info
decl_stmt|;
name|authn_info
operator|=
name|serf__get_authn_info_for_server
argument_list|(
name|conn
argument_list|)
expr_stmt|;
if|if
condition|(
name|authn_info
operator|->
name|scheme
condition|)
name|authn_info
operator|->
name|scheme
operator|->
name|setup_request_func
argument_list|(
name|HOST
argument_list|,
literal|0
argument_list|,
name|conn
argument_list|,
name|request
argument_list|,
name|method
argument_list|,
name|uri
argument_list|,
name|hdrs_bkt
argument_list|)
expr_stmt|;
block|}
comment|/* Setup proxy authorization headers.        Don't set these headers on the requests to the server if we're using        an SSL tunnel, only on the CONNECT request to setup the tunnel. */
if|if
condition|(
name|ctx
operator|->
name|proxy_authn_info
operator|.
name|scheme
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|conn
operator|->
name|host_info
operator|.
name|scheme
argument_list|,
literal|"https"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|request
operator|->
name|ssltunnel
condition|)
name|ctx
operator|->
name|proxy_authn_info
operator|.
name|scheme
operator|->
name|setup_request_func
argument_list|(
name|PROXY
argument_list|,
literal|0
argument_list|,
name|conn
argument_list|,
name|request
argument_list|,
name|method
argument_list|,
name|uri
argument_list|,
name|hdrs_bkt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|proxy_authn_info
operator|.
name|scheme
operator|->
name|setup_request_func
argument_list|(
name|PROXY
argument_list|,
literal|0
argument_list|,
name|conn
argument_list|,
name|request
argument_list|,
name|method
argument_list|,
name|uri
argument_list|,
name|hdrs_bkt
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|req_bkt
return|;
block|}
end_function

begin_function
name|apr_interval_time_t
name|serf_connection_get_latency
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|)
block|{
if|if
condition|(
name|conn
operator|->
name|ctx
operator|->
name|proxy_address
condition|)
block|{
comment|/* Detecting network latency for proxied connection is not implemented            yet. */
return|return
operator|-
literal|1
return|;
block|}
return|return
name|conn
operator|->
name|latency
return|;
block|}
end_function

end_unit

