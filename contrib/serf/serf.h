begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2002-2004 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SERF_H
end_ifndef

begin_define
define|#
directive|define
name|SERF_H
end_define

begin_comment
comment|/**  * @file serf.h  * @brief Main serf header file  */
end_comment

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<apr_errno.h>
end_include

begin_include
include|#
directive|include
file|<apr_allocator.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_network_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_time.h>
end_include

begin_include
include|#
directive|include
file|<apr_poll.h>
end_include

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* Forward declare some structures */
typedef|typedef
name|struct
name|serf_context_t
name|serf_context_t
typedef|;
typedef|typedef
name|struct
name|serf_bucket_t
name|serf_bucket_t
typedef|;
typedef|typedef
name|struct
name|serf_bucket_type_t
name|serf_bucket_type_t
typedef|;
typedef|typedef
name|struct
name|serf_bucket_alloc_t
name|serf_bucket_alloc_t
typedef|;
typedef|typedef
name|struct
name|serf_connection_t
name|serf_connection_t
typedef|;
typedef|typedef
name|struct
name|serf_listener_t
name|serf_listener_t
typedef|;
typedef|typedef
name|struct
name|serf_incoming_t
name|serf_incoming_t
typedef|;
typedef|typedef
name|struct
name|serf_incoming_request_t
name|serf_incoming_request_t
typedef|;
typedef|typedef
name|struct
name|serf_request_t
name|serf_request_t
typedef|;
comment|/**  * @defgroup serf high-level constructs  * @ingroup serf  * @{  */
comment|/**  * Serf-specific error codes  */
define|#
directive|define
name|SERF_ERROR_RANGE
value|100
define|#
directive|define
name|SERF_ERROR_START
value|(APR_OS_START_USERERR + SERF_ERROR_RANGE)
comment|/* This code is for when this is the last response on this connection:  * i.e. do not send any more requests on this connection or expect  * any more responses.  */
define|#
directive|define
name|SERF_ERROR_CLOSING
value|(SERF_ERROR_START + 1)
comment|/* This code is for when the connection terminated before the request  * could be processed on the other side.  */
define|#
directive|define
name|SERF_ERROR_REQUEST_LOST
value|(SERF_ERROR_START + 2)
comment|/* This code is for when the connection is blocked - we can not proceed  * until something happens - generally due to SSL negotiation-like behavior  * where a write() is blocked until a read() is processed.  */
define|#
directive|define
name|SERF_ERROR_WAIT_CONN
value|(SERF_ERROR_START + 3)
comment|/* This code is for when something went wrong during deflating compressed  * data e.g. a CRC error. */
define|#
directive|define
name|SERF_ERROR_DECOMPRESSION_FAILED
value|(SERF_ERROR_START + 4)
comment|/* This code is for when a response received from a http server is not in  * http-compliant syntax. */
define|#
directive|define
name|SERF_ERROR_BAD_HTTP_RESPONSE
value|(SERF_ERROR_START + 5)
comment|/* The server sent less data than what was announced. */
define|#
directive|define
name|SERF_ERROR_TRUNCATED_HTTP_RESPONSE
value|(SERF_ERROR_START + 6)
comment|/* The proxy server returned an error while setting up the SSL tunnel. */
define|#
directive|define
name|SERF_ERROR_SSLTUNNEL_SETUP_FAILED
value|(SERF_ERROR_START + 7)
comment|/* The server unexpectedly closed the connection prematurely. */
define|#
directive|define
name|SERF_ERROR_ABORTED_CONNECTION
value|(SERF_ERROR_START + 8)
comment|/* SSL certificates related errors */
define|#
directive|define
name|SERF_ERROR_SSL_CERT_FAILED
value|(SERF_ERROR_START + 70)
comment|/* SSL communications related errors */
define|#
directive|define
name|SERF_ERROR_SSL_COMM_FAILED
value|(SERF_ERROR_START + 71)
comment|/* General authentication related errors */
define|#
directive|define
name|SERF_ERROR_AUTHN_FAILED
value|(SERF_ERROR_START + 90)
comment|/* None of the available authn mechanisms for the request are supported */
define|#
directive|define
name|SERF_ERROR_AUTHN_NOT_SUPPORTED
value|(SERF_ERROR_START + 91)
comment|/* Authn was requested by the server but the header lacked some attribute  */
define|#
directive|define
name|SERF_ERROR_AUTHN_MISSING_ATTRIBUTE
value|(SERF_ERROR_START + 92)
comment|/* Authentication handler initialization related errors */
define|#
directive|define
name|SERF_ERROR_AUTHN_INITALIZATION_FAILED
value|(SERF_ERROR_START + 93)
comment|/* Error code reserved for use in the test suite. */
define|#
directive|define
name|SERF_ERROR_ISSUE_IN_TESTSUITE
value|(SERF_ERROR_START + 99)
comment|/* This macro groups errors potentially raised when reading a http response.  */
define|#
directive|define
name|SERF_BAD_RESPONSE_ERROR
parameter_list|(
name|status
parameter_list|)
value|((status) \&& ((SERF_ERROR_DECOMPRESSION_FAILED == (status)) \         ||(SERF_ERROR_BAD_HTTP_RESPONSE == (status)) \         ||(SERF_ERROR_TRUNCATED_HTTP_RESPONSE == (status))))
comment|/**  * Return a string that describes the specified error code.  *  * If the error code is not one of the above Serf error codes, then  * NULL will be returned.  *  * Note regarding lifetime: the string is a statically-allocated constant  */
specifier|const
name|char
modifier|*
name|serf_error_string
parameter_list|(
name|apr_status_t
name|errcode
parameter_list|)
function_decl|;
comment|/**  * Create a new context for serf operations.  *  * A serf context defines a control loop which processes multiple  * connections simultaneously.  *  * The context will be allocated within @a pool.  */
name|serf_context_t
modifier|*
name|serf_context_create
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/**  * Callback function. Add a socket to the externally managed poll set.  *  * Both @a pfd and @a serf_baton should be used when calling serf_event_trigger  * later.  */
typedef|typedef
name|apr_status_t
function_decl|(
modifier|*
name|serf_socket_add_t
function_decl|)
parameter_list|(
name|void
modifier|*
name|user_baton
parameter_list|,
name|apr_pollfd_t
modifier|*
name|pfd
parameter_list|,
name|void
modifier|*
name|serf_baton
parameter_list|)
function_decl|;
comment|/**  * Callback function. Remove the socket, identified by both @a pfd and  * @a serf_baton from the externally managed poll set.  */
typedef|typedef
name|apr_status_t
function_decl|(
modifier|*
name|serf_socket_remove_t
function_decl|)
parameter_list|(
name|void
modifier|*
name|user_baton
parameter_list|,
name|apr_pollfd_t
modifier|*
name|pfd
parameter_list|,
name|void
modifier|*
name|serf_baton
parameter_list|)
function_decl|;
comment|/* Create a new context for serf operations.  *  * Use this function to make serf not use its internal control loop, but  * instead rely on an external event loop. Serf will use the @a addf and @a rmf  * callbacks to notify of any event on a connection. The @a user_baton will be  * passed through the addf and rmf callbacks.  *  * The context will be allocated within @a pool.  */
name|serf_context_t
modifier|*
name|serf_context_create_ex
parameter_list|(
name|void
modifier|*
name|user_baton
parameter_list|,
name|serf_socket_add_t
name|addf
parameter_list|,
name|serf_socket_remove_t
name|rmf
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/**  * Make serf process events on a connection, identified by both @a pfd and  * @a serf_baton.  *  * Any outbound data is delivered, and incoming data is made available to  * the associated response handlers and their buckets.  *  * If any data is processed (incoming or outgoing), then this function will  * return with APR_SUCCESS.  */
name|apr_status_t
name|serf_event_trigger
parameter_list|(
name|serf_context_t
modifier|*
name|s
parameter_list|,
name|void
modifier|*
name|serf_baton
parameter_list|,
specifier|const
name|apr_pollfd_t
modifier|*
name|pfd
parameter_list|)
function_decl|;
comment|/** @see serf_context_run should not block at all. */
define|#
directive|define
name|SERF_DURATION_NOBLOCK
value|0
comment|/** @see serf_context_run should run for (nearly) "forever". */
define|#
directive|define
name|SERF_DURATION_FOREVER
value|2000000000
comment|/* approx 1^31 */
comment|/**  * Run the main networking control loop.  *  * The set of connections defined by the serf context @a ctx are processed.  * Any outbound data is delivered, and incoming data is made available to  * the associated response handlers and their buckets. This function will  * block on the network for no longer than @a duration microseconds.  *  * If any data is processed (incoming or outgoing), then this function will  * return with APR_SUCCESS. Typically, the caller will just want to call it  * again to continue processing data.  *  * If no activity occurs within the specified timeout duration, then  * APR_TIMEUP is returned.  *  * All temporary allocations will be made in @a pool.  */
name|apr_status_t
name|serf_context_run
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|apr_short_interval_time_t
name|duration
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
name|apr_status_t
name|serf_context_prerun
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|)
function_decl|;
comment|/**  * Callback function for progress information. @a progress indicates cumulative  * number of bytes read or written, for the whole context.  */
typedef|typedef
name|void
function_decl|(
modifier|*
name|serf_progress_t
function_decl|)
parameter_list|(
name|void
modifier|*
name|progress_baton
parameter_list|,
name|apr_off_t
name|read
parameter_list|,
name|apr_off_t
name|write
parameter_list|)
function_decl|;
comment|/**  * Sets the progress callback function. @a progress_func will be called every  * time bytes are read of or written on a socket.  */
name|void
name|serf_context_set_progress_cb
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|serf_progress_t
name|progress_func
parameter_list|,
name|void
modifier|*
name|progress_baton
parameter_list|)
function_decl|;
comment|/** @} */
comment|/**  * @defgroup serf connections and requests  * @ingroup serf  * @{  */
comment|/**  * When a connection is established, the application needs to wrap some  * buckets around @a skt to enable serf to process incoming responses. This  * is the control point for assembling connection-level processing logic  * around the given socket.  *  * The @a setup_baton is the baton established at connection creation time.  *  * This callback corresponds to reading from the server. Since this is an  * on-demand activity, we use a callback. The corresponding write operation  * is based on the @see serf_request_deliver function, where the application  * can assemble the appropriate bucket(s) before delivery.  *  * The returned bucket should live at least as long as the connection itself.  * It is assumed that an appropriate allocator is passed in @a setup_baton.  * ### we may want to create a connection-level allocator and pass that  * ### along. however, that allocator would *only* be used for this  * ### callback. it may be wasteful to create a per-conn allocator, so this  * ### baton-based, app-responsible form might be best.  *  * Responsibility for the buckets is passed to the serf library. They will be  * destroyed when the connection is closed.  *  * All temporary allocations should be made in @a pool.  */
typedef|typedef
name|apr_status_t
function_decl|(
modifier|*
name|serf_connection_setup_t
function_decl|)
parameter_list|(
name|apr_socket_t
modifier|*
name|skt
parameter_list|,
name|serf_bucket_t
modifier|*
modifier|*
name|read_bkt
parameter_list|,
name|serf_bucket_t
modifier|*
modifier|*
name|write_bkt
parameter_list|,
name|void
modifier|*
name|setup_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/**  * ### need to update docco w.r.t socket. became "stream" recently.  * ### the stream does not have a barrier, this callback should generally  * ### add a barrier around the stream before incorporating it into a  * ### response bucket stack.  * ### should serf add the barrier automatically to protect its data  * ### structure? i.e. the passed bucket becomes owned rather than  * ### borrowed. that might suit overall semantics better.  * Accept an incoming response for @a request, and its @a socket. A bucket  * for the response should be constructed and returned. This is the control  * point for assembling the appropriate wrapper buckets around the socket to  * enable processing of the incoming response.  *  * The @a acceptor_baton is the baton provided when the specified request  * was created.  *  * The request's pool and bucket allocator should be used for any allocations  * that need to live for the duration of the response. Care should be taken  * to bound the amount of memory stored in this pool -- to ensure that  * allocations are not proportional to the amount of data in the response.  *  * Responsibility for the bucket is passed to the serf library. It will be  * destroyed when the response has been fully read (the bucket returns an  * APR_EOF status from its read functions).  *  * All temporary allocations should be made in @a pool.  */
comment|/* ### do we need to return an error? */
typedef|typedef
name|serf_bucket_t
modifier|*
function_decl|(
modifier|*
name|serf_response_acceptor_t
function_decl|)
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|acceptor_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/**  * Notification callback for when a connection closes.  *  * This callback is used to inform an application that the @a conn  * connection has been (abnormally) closed. The @a closed_baton is the  * baton provided when the connection was first opened. The reason for  * closure is given in @a why, and will be APR_SUCCESS if the application  * requested closure (by clearing the pool used to allocate this  * connection or calling serf_connection_close).  *  * All temporary allocations should be made in @a pool.  */
typedef|typedef
name|void
function_decl|(
modifier|*
name|serf_connection_closed_t
function_decl|)
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|void
modifier|*
name|closed_baton
parameter_list|,
name|apr_status_t
name|why
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/**  * Response data has arrived and should be processed.  *  * Whenever response data for @a request arrives (initially, or continued data  * arrival), this handler is invoked. The response data is available in the  * @a response bucket. The @a handler_baton is passed along from the baton  * provided by the request setup callback (@see serf_request_setup_t).  *  * The handler MUST process data from the @a response bucket until the  * bucket's read function states it would block (see APR_STATUS_IS_EAGAIN).  * The handler is invoked only when new data arrives. If no further data  * arrives, and the handler does not process all available data, then the  * system can result in a deadlock around the unprocessed, but read, data.  *  * The handler should return APR_EOF when the response has been fully read.  * If calling the handler again would block, APR_EAGAIN should be returned.  * If the handler should be invoked again, simply return APR_SUCCESS.  *  * Note: if the connection closed (at the request of the application, or  * because of an (abnormal) termination) while a request is being delivered,  * or before a response arrives, then @a response will be NULL. This is the  * signal that the request was not delivered properly, and no further  * response should be expected (this callback will not be invoked again).  * If a request is injected into the connection (during this callback's  * execution, or otherwise), then the connection will be reopened.  *  * All temporary allocations should be made in @a pool.  */
typedef|typedef
name|apr_status_t
function_decl|(
modifier|*
name|serf_response_handler_t
function_decl|)
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/**  * Callback function to be implemented by the application, so that serf  * can handle server and proxy authentication.  * code = 401 (server) or 407 (proxy).  * baton = the baton passed to serf_context_run.  * authn_type = one of "Basic", "Digest".  */
typedef|typedef
name|apr_status_t
function_decl|(
modifier|*
name|serf_credentials_callback_t
function_decl|)
parameter_list|(
name|char
modifier|*
modifier|*
name|username
parameter_list|,
name|char
modifier|*
modifier|*
name|password
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|authn_type
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/**  * Create a new connection associated with the @a ctx serf context.  *  * If no proxy server is configured, a connection will be created to  * (eventually) connect to the address specified by @a address. The address must  * live at least as long as @a pool (thus, as long as the connection object).  * If a proxy server is configured, @address will be ignored.  *  * The connection object will be allocated within @a pool. Clearing or  * destroying this pool will close the connection, and terminate any  * outstanding requests or responses.  *  * When the connection is closed (upon request or because of an error),  * then the @a closed callback is invoked, and @a closed_baton is passed.  *  * ### doc on setup(_baton). tweak below comment re: acceptor.  * NULL may be passed for @a acceptor and @a closed; default implementations  * will be used.  *  * Note: the connection is not made immediately. It will be opened on  * the next call to @see serf_context_run.  */
name|serf_connection_t
modifier|*
name|serf_connection_create
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|apr_sockaddr_t
modifier|*
name|address
parameter_list|,
name|serf_connection_setup_t
name|setup
parameter_list|,
name|void
modifier|*
name|setup_baton
parameter_list|,
name|serf_connection_closed_t
name|closed
parameter_list|,
name|void
modifier|*
name|closed_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/**  * Create a new connection associated with the @a ctx serf context.  *  * A connection will be created to (eventually) connect to the address  * specified by @a address. The address must live at least as long as  * @a pool (thus, as long as the connection object).  *  * The host address will be looked up based on the hostname in @a host_info.  *  * The connection object will be allocated within @a pool. Clearing or  * destroying this pool will close the connection, and terminate any  * outstanding requests or responses.  *  * When the connection is closed (upon request or because of an error),  * then the @a closed callback is invoked, and @a closed_baton is passed.  *  * ### doc on setup(_baton). tweak below comment re: acceptor.  * NULL may be passed for @a acceptor and @a closed; default implementations  * will be used.  *  * Note: the connection is not made immediately. It will be opened on  * the next call to @see serf_context_run.  */
name|apr_status_t
name|serf_connection_create2
parameter_list|(
name|serf_connection_t
modifier|*
modifier|*
name|conn
parameter_list|,
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|apr_uri_t
name|host_info
parameter_list|,
name|serf_connection_setup_t
name|setup
parameter_list|,
name|void
modifier|*
name|setup_baton
parameter_list|,
name|serf_connection_closed_t
name|closed
parameter_list|,
name|void
modifier|*
name|closed_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
typedef|typedef
name|apr_status_t
function_decl|(
modifier|*
name|serf_accept_client_t
function_decl|)
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|serf_listener_t
modifier|*
name|l
parameter_list|,
name|void
modifier|*
name|accept_baton
parameter_list|,
name|apr_socket_t
modifier|*
name|insock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
name|apr_status_t
name|serf_listener_create
parameter_list|(
name|serf_listener_t
modifier|*
modifier|*
name|listener
parameter_list|,
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|host
parameter_list|,
name|apr_uint16_t
name|port
parameter_list|,
name|void
modifier|*
name|accept_baton
parameter_list|,
name|serf_accept_client_t
name|accept_func
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
typedef|typedef
name|apr_status_t
function_decl|(
modifier|*
name|serf_incoming_request_cb_t
function_decl|)
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|serf_incoming_request_t
modifier|*
name|req
parameter_list|,
name|void
modifier|*
name|request_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
name|apr_status_t
name|serf_incoming_create
parameter_list|(
name|serf_incoming_t
modifier|*
modifier|*
name|client
parameter_list|,
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|apr_socket_t
modifier|*
name|insock
parameter_list|,
name|void
modifier|*
name|request_baton
parameter_list|,
name|serf_incoming_request_cb_t
name|request
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/**  * Reset the connection, but re-open the socket again.  */
name|apr_status_t
name|serf_connection_reset
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|)
function_decl|;
comment|/**  * Close the connection associated with @a conn and cancel all pending requests.  *  * The closed callback passed to serf_connection_create() will be invoked  * with APR_SUCCESS.  */
name|apr_status_t
name|serf_connection_close
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|)
function_decl|;
comment|/**  * Sets the maximum number of outstanding requests @a max_requests on the  * connection @a conn. Setting max_requests to 0 means unlimited (the default).  * Ex.: setting max_requests to 1 means a request is sent when a response on the  * previous request was received and handled.  *  * In general, serf tends to take around 16KB per outstanding request.  */
name|void
name|serf_connection_set_max_outstanding_requests
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|unsigned
name|int
name|max_requests
parameter_list|)
function_decl|;
name|void
name|serf_connection_set_async_responses
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|serf_response_acceptor_t
name|acceptor
parameter_list|,
name|void
modifier|*
name|acceptor_baton
parameter_list|,
name|serf_response_handler_t
name|handler
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|)
function_decl|;
comment|/**  * Setup the @a request for delivery on its connection.  *  * Right before this is invoked, @a pool will be built within the  * connection's pool for the request to use.  The associated response will  * be allocated within that subpool. An associated bucket allocator will  * be built. These items may be fetched from the request object through  * @see serf_request_get_pool or @see serf_request_get_alloc.  *  * The content of the request is specified by the @a req_bkt bucket. When  * a response arrives, the @a acceptor callback will be invoked (along with  * the @a acceptor_baton) to produce a response bucket. That bucket will then  * be passed to @a handler, along with the @a handler_baton.  *  * The responsibility for the request bucket is passed to the request  * object. When the request is done with the bucket, it will be destroyed.  */
typedef|typedef
name|apr_status_t
function_decl|(
modifier|*
name|serf_request_setup_t
function_decl|)
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|void
modifier|*
name|setup_baton
parameter_list|,
name|serf_bucket_t
modifier|*
modifier|*
name|req_bkt
parameter_list|,
name|serf_response_acceptor_t
modifier|*
name|acceptor
parameter_list|,
name|void
modifier|*
modifier|*
name|acceptor_baton
parameter_list|,
name|serf_response_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/**  * Construct a request object for the @a conn connection.  *  * When it is time to deliver the request, the @a setup callback will  * be invoked with the @a setup_baton passed into it to complete the  * construction of the request object.  *  * If the request has not (yet) been delivered, then it may be canceled  * with @see serf_request_cancel.  *  * Invoking any calls other than @see serf_request_cancel before the setup  * callback executes is not supported.  */
name|serf_request_t
modifier|*
name|serf_connection_request_create
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|serf_request_setup_t
name|setup
parameter_list|,
name|void
modifier|*
name|setup_baton
parameter_list|)
function_decl|;
comment|/**  * Construct a request object for the @a conn connection, add it in the  * list as the next to-be-written request before all unwritten requests.  *  * When it is time to deliver the request, the @a setup callback will  * be invoked with the @a setup_baton passed into it to complete the  * construction of the request object.  *  * If the request has not (yet) been delivered, then it may be canceled  * with @see serf_request_cancel.  *  * Invoking any calls other than @see serf_request_cancel before the setup  * callback executes is not supported.  */
name|serf_request_t
modifier|*
name|serf_connection_priority_request_create
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|serf_request_setup_t
name|setup
parameter_list|,
name|void
modifier|*
name|setup_baton
parameter_list|)
function_decl|;
comment|/** Returns detected network latency for the @a conn connection. Negative  *  value means that latency is unknwon.  */
name|apr_interval_time_t
name|serf_connection_get_latency
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|)
function_decl|;
comment|/** Check if a @a request has been completely written.  *  * Returns APR_SUCCESS if the request was written completely on the connection.  * Returns APR_EBUSY if the request is not yet or partially written.  */
name|apr_status_t
name|serf_request_is_written
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|)
function_decl|;
comment|/**  * Cancel the request specified by the @a request object.  *  * If the request has been scheduled for delivery, then its response  * handler will be run, passing NULL for the response bucket.  *  * If the request has already been (partially or fully) delivered, then  * APR_EBUSY is returned and the request is *NOT* canceled. To properly  * cancel the request, the connection must be closed (by clearing or  * destroying its associated pool).  */
name|apr_status_t
name|serf_request_cancel
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|)
function_decl|;
comment|/**  * Return the pool associated with @a request.  *  * WARNING: be very careful about the kinds of things placed into this  * pool. In particular, all allocation should be bounded in size, rather  * than proportional to any data stream.  */
name|apr_pool_t
modifier|*
name|serf_request_get_pool
parameter_list|(
specifier|const
name|serf_request_t
modifier|*
name|request
parameter_list|)
function_decl|;
comment|/**  * Return the bucket allocator associated with @a request.  */
name|serf_bucket_alloc_t
modifier|*
name|serf_request_get_alloc
parameter_list|(
specifier|const
name|serf_request_t
modifier|*
name|request
parameter_list|)
function_decl|;
comment|/**  * Return the connection associated with @a request.  */
name|serf_connection_t
modifier|*
name|serf_request_get_conn
parameter_list|(
specifier|const
name|serf_request_t
modifier|*
name|request
parameter_list|)
function_decl|;
comment|/**  * Update the @a handler and @a handler_baton for this @a request.  *  * This can be called after the request has started processing -  * subsequent data will be delivered to this new handler.  */
name|void
name|serf_request_set_handler
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
specifier|const
name|serf_response_handler_t
name|handler
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|)
function_decl|;
comment|/**  * Configure proxy server settings, to be used by all connections associated  * with the @a ctx serf context.  *  * The next connection will be created to connect to the proxy server  * specified by @a address. The address must live at least as long as the  * serf context.  */
name|void
name|serf_config_proxy
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|apr_sockaddr_t
modifier|*
name|address
parameter_list|)
function_decl|;
comment|/* Supported authentication types. */
define|#
directive|define
name|SERF_AUTHN_NONE
value|0x00
define|#
directive|define
name|SERF_AUTHN_BASIC
value|0x01
define|#
directive|define
name|SERF_AUTHN_DIGEST
value|0x02
define|#
directive|define
name|SERF_AUTHN_NTLM
value|0x04
define|#
directive|define
name|SERF_AUTHN_NEGOTIATE
value|0x08
define|#
directive|define
name|SERF_AUTHN_ALL
value|0xFF
comment|/**  * Define the authentication handlers that serf will try on incoming requests.  */
name|void
name|serf_config_authn_types
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|int
name|authn_types
parameter_list|)
function_decl|;
comment|/**  * Set the credentials callback handler.  */
name|void
name|serf_config_credentials_callback
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|serf_credentials_callback_t
name|cred_cb
parameter_list|)
function_decl|;
comment|/* ### maybe some connection control functions for flood? */
comment|/*** Special bucket creation functions ***/
comment|/**  * Create a bucket of type 'socket bucket'.  * This is basically a wrapper around @a serf_bucket_socket_create, which  * initializes the bucket using connection and/or context specific settings.  */
name|serf_bucket_t
modifier|*
name|serf_context_bucket_socket_create
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|apr_socket_t
modifier|*
name|skt
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
comment|/**  * Create a bucket of type 'request bucket'.  * This is basically a wrapper around @a serf_bucket_request_create, which  * initializes the bucket using request, connection and/or context specific  * settings.  *  * This function will set following header(s):  * - Host: if the connection was created with @a serf_connection_create2.  */
name|serf_bucket_t
modifier|*
name|serf_request_bucket_request_create
parameter_list|(
name|serf_request_t
modifier|*
name|request
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|,
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|serf_bucket_t
modifier|*
name|body
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
comment|/** @} */
comment|/**  * @defgroup serf buckets  * @ingroup serf  * @{  */
comment|/** Pass as REQUESTED to the read function of a bucket to read, consume,  * and return all available data.  */
define|#
directive|define
name|SERF_READ_ALL_AVAIL
value|((apr_size_t)-1)
comment|/** Acceptable newline types for bucket->readline(). */
define|#
directive|define
name|SERF_NEWLINE_CR
value|0x0001
define|#
directive|define
name|SERF_NEWLINE_CRLF
value|0x0002
define|#
directive|define
name|SERF_NEWLINE_LF
value|0x0004
define|#
directive|define
name|SERF_NEWLINE_ANY
value|0x0007
comment|/** Used to indicate that a newline is not present in the data buffer. */
comment|/* ### should we make this zero? */
define|#
directive|define
name|SERF_NEWLINE_NONE
value|0x0008
comment|/** Used to indicate that a CR was found at the end of a buffer, and CRLF  * was acceptable. It may be that the LF is present, but it needs to be  * read first.  *  * Note: an alternative to using this symbol would be for callers to see  * the SERF_NEWLINE_CR return value, and know that some "end of buffer" was  * reached. While this works well for @see serf_util_readline, it does not  * necessary work as well for buckets (there is no obvious "end of buffer",  * although there is an "end of bucket"). The other problem with that  * alternative is that developers might miss the condition. This symbol  * calls out the possibility and ensures that callers will watch for it.  */
define|#
directive|define
name|SERF_NEWLINE_CRLF_SPLIT
value|0x0010
struct|struct
name|serf_bucket_type_t
block|{
comment|/** name of this bucket type */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/**      * Read (and consume) up to @a requested bytes from @a bucket.      *      * A pointer to the data will be returned in @a data, and its length      * is specified by @a len.      *      * The data will exist until one of two conditions occur:      *      * 1) this bucket is destroyed      * 2) another call to any read function or to peek()      *      * If an application needs the data to exist for a longer duration,      * then it must make a copy.      */
name|apr_status_t
function_decl|(
modifier|*
name|read
function_decl|)
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
function_decl|;
comment|/**      * Read (and consume) a line of data from @a bucket.      *      * The acceptable forms of a newline are given by @a acceptable, and      * the type found is returned in @a found. If a newline is not present      * in the returned data, then SERF_NEWLINE_NONE is stored into @a found.      *      * A pointer to the data is returned in @a data, and its length is      * specified by @a len. The data will include the newline, if present.      *      * Note that there is no way to limit the amount of data returned      * by this function.      *      * The lifetime of the data is the same as that of the @see read      * function above.      */
name|apr_status_t
function_decl|(
modifier|*
name|readline
function_decl|)
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|int
name|acceptable
parameter_list|,
name|int
modifier|*
name|found
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
function_decl|;
comment|/**      * Read a set of pointer/length pairs from the bucket.      *      * The size of the @a vecs array is specified by @a vecs_size. The      * bucket should fill in elements of the array, and return the number      * used in @a vecs_used.      *      * Each element of @a vecs should specify a pointer to a block of      * data and a length of that data.      *      * The total length of all data elements should not exceed the      * amount specified in @a requested.      *      * The lifetime of the data is the same as that of the @see read      * function above.      */
name|apr_status_t
function_decl|(
modifier|*
name|read_iovec
function_decl|)
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
name|int
name|vecs_size
parameter_list|,
name|struct
name|iovec
modifier|*
name|vecs
parameter_list|,
name|int
modifier|*
name|vecs_used
parameter_list|)
function_decl|;
comment|/**      * Read data from the bucket in a form suitable for apr_socket_sendfile()      *      * On input, hdtr->numheaders and hdtr->numtrailers specify the size      * of the hdtr->headers and hdtr->trailers arrays, respectively. The      * bucket should fill in the headers and trailers, up to the specified      * limits, and set numheaders and numtrailers to the number of iovecs      * filled in for each item.      *      * @a file should be filled in with a file that can be read. If a file      * is not available or appropriate, then NULL should be stored. The      * file offset for the data should be stored in @a offset, and the      * length of that data should be stored in @a len. If a file is not      * returned, then @a offset and @a len should be ignored.      *      * The file position is not required to correspond to @a offset, and      * the caller may manipulate it at will.      *      * The total length of all data elements, and the portion of the      * file should not exceed the amount specified in @a requested.      *      * The lifetime of the data is the same as that of the @see read      * function above.      */
name|apr_status_t
function_decl|(
modifier|*
name|read_for_sendfile
function_decl|)
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
name|apr_hdtr_t
modifier|*
name|hdtr
parameter_list|,
name|apr_file_t
modifier|*
modifier|*
name|file
parameter_list|,
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
function_decl|;
comment|/**      * Look within @a bucket for a bucket of the given @a type. The bucket      * must be the "initial" data because it will be consumed by this      * function. If the given bucket type is available, then read and consume      * it, and return it to the caller.      *      * This function is usually used by readers that have custom handling      * for specific bucket types (e.g. looking for a file bucket to pass      * to apr_socket_sendfile).      *      * If a bucket of the given type is not found, then NULL is returned.      *      * The returned bucket becomes the responsibility of the caller. When      * the caller is done with the bucket, it should be destroyed.      */
name|serf_bucket_t
modifier|*
function_decl|(
modifier|*
name|read_bucket
function_decl|)
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
specifier|const
name|serf_bucket_type_t
modifier|*
name|type
parameter_list|)
function_decl|;
comment|/**      * Peek, but don't consume, the data in @a bucket.      *      * Since this function is non-destructive, the implicit read size is      * SERF_READ_ALL_AVAIL. The caller can then use whatever amount is      * appropriate.      *      * The @a data parameter will point to the data, and @a len will      * specify how much data is available. The lifetime of the data follows      * the same rules as the @see read function above.      *      * Note: if the peek does not return enough data for your particular      * use, then you must read/consume some first, then peek again.      *      * If the returned data represents all available data, then APR_EOF      * will be returned. Since this function does not consume data, it      * can return the same data repeatedly rather than blocking; thus,      * APR_EAGAIN will never be returned.      */
name|apr_status_t
function_decl|(
modifier|*
name|peek
function_decl|)
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
function_decl|;
comment|/**      * Destroy @a bucket, along with any associated resources.      */
name|void
function_decl|(
modifier|*
name|destroy
function_decl|)
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
function_decl|;
comment|/* ### apr buckets have 'copy', 'split', and 'setaside' functions.        ### not sure whether those will be needed in this bucket model.     */
block|}
struct|;
comment|/**  * Should the use and lifecycle of buckets be tracked?  *  * When tracking, the system will ensure several semantic requirements  * of bucket use:  *  *   - if a bucket returns APR_EAGAIN, one of its read functions should  *     not be called immediately. the context's run loop should be called.  *     ### and for APR_EOF, too?  *   - all buckets must be drained of input before returning to the  *     context's run loop.  *   - buckets should not be destroyed before they return APR_EOF unless  *     the connection is closed for some reason.  *  * Undefine this symbol to avoid the tracking (and a performance gain).  *  * ### we may want to examine when/how we provide this. should it always  * ### be compiled in? and apps select it before including this header?  */
comment|/* #define SERF_DEBUG_BUCKET_USE */
comment|/* Internal macros for tracking bucket use. */
ifdef|#
directive|ifdef
name|SERF_DEBUG_BUCKET_USE
define|#
directive|define
name|SERF__RECREAD
parameter_list|(
name|b
parameter_list|,
name|s
parameter_list|)
value|serf_debug__record_read(b,s)
else|#
directive|else
define|#
directive|define
name|SERF__RECREAD
parameter_list|(
name|b
parameter_list|,
name|s
parameter_list|)
value|(s)
endif|#
directive|endif
define|#
directive|define
name|serf_bucket_read
parameter_list|(
name|b
parameter_list|,
name|r
parameter_list|,
name|d
parameter_list|,
name|l
parameter_list|)
value|SERF__RECREAD(b, (b)->type->read(b,r,d,l))
define|#
directive|define
name|serf_bucket_readline
parameter_list|(
name|b
parameter_list|,
name|a
parameter_list|,
name|f
parameter_list|,
name|d
parameter_list|,
name|l
parameter_list|)
define|\
value|SERF__RECREAD(b, (b)->type->readline(b,a,f,d,l))
define|#
directive|define
name|serf_bucket_read_iovec
parameter_list|(
name|b
parameter_list|,
name|r
parameter_list|,
name|s
parameter_list|,
name|v
parameter_list|,
name|u
parameter_list|)
define|\
value|SERF__RECREAD(b, (b)->type->read_iovec(b,r,s,v,u))
define|#
directive|define
name|serf_bucket_read_for_sendfile
parameter_list|(
name|b
parameter_list|,
name|r
parameter_list|,
name|h
parameter_list|,
name|f
parameter_list|,
name|o
parameter_list|,
name|l
parameter_list|)
define|\
value|SERF__RECREAD(b, (b)->type->read_for_sendfile(b,r,h,f,o,l))
define|#
directive|define
name|serf_bucket_read_bucket
parameter_list|(
name|b
parameter_list|,
name|t
parameter_list|)
value|((b)->type->read_bucket(b,t))
define|#
directive|define
name|serf_bucket_peek
parameter_list|(
name|b
parameter_list|,
name|d
parameter_list|,
name|l
parameter_list|)
value|((b)->type->peek(b,d,l))
define|#
directive|define
name|serf_bucket_destroy
parameter_list|(
name|b
parameter_list|)
value|((b)->type->destroy(b))
comment|/**  * Check whether a real error occurred. Note that bucket read functions  * can return EOF and EAGAIN as part of their "normal" operation, so they  * should not be considered an error.  */
define|#
directive|define
name|SERF_BUCKET_READ_ERROR
parameter_list|(
name|status
parameter_list|)
value|((status) \&& !APR_STATUS_IS_EOF(status) \&& !APR_STATUS_IS_EAGAIN(status) \&& (SERF_ERROR_WAIT_CONN != status))
struct|struct
name|serf_bucket_t
block|{
comment|/** the type of this bucket */
specifier|const
name|serf_bucket_type_t
modifier|*
name|type
decl_stmt|;
comment|/** bucket-private data */
name|void
modifier|*
name|data
decl_stmt|;
comment|/** the allocator used for this bucket (needed at destroy time) */
name|serf_bucket_alloc_t
modifier|*
name|allocator
decl_stmt|;
block|}
struct|;
comment|/**  * Generic macro to construct "is TYPE" macros.  */
define|#
directive|define
name|SERF_BUCKET_CHECK
parameter_list|(
name|b
parameter_list|,
name|btype
parameter_list|)
value|((b)->type ==&serf_bucket_type_ ## btype)
comment|/**  * Notification callback for a block that was not returned to the bucket  * allocator when its pool was destroyed.  *  * The block of memory is given by @a block. The baton provided when the  * allocator was constructed is passed as @a unfreed_baton.  */
typedef|typedef
name|void
function_decl|(
modifier|*
name|serf_unfreed_func_t
function_decl|)
parameter_list|(
name|void
modifier|*
name|unfreed_baton
parameter_list|,
name|void
modifier|*
name|block
parameter_list|)
function_decl|;
comment|/**  * Create a new allocator for buckets.  *  * All buckets are associated with a serf bucket allocator. This allocator  * will be created within @a pool and will be destroyed when that pool is  * cleared or destroyed.  *  * When the allocator is destroyed, if any allocations were not explicitly  * returned (by calling serf_bucket_mem_free), then the @a unfreed callback  * will be invoked for each block. @a unfreed_baton will be passed to the  * callback.  *  * If @a unfreed is NULL, then the library will invoke the abort() stdlib  * call. Any failure to return memory is a bug in the application, and an  * abort can assist with determining what kinds of memory were not freed.  */
name|serf_bucket_alloc_t
modifier|*
name|serf_bucket_allocator_create
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|serf_unfreed_func_t
name|unfreed
parameter_list|,
name|void
modifier|*
name|unfreed_baton
parameter_list|)
function_decl|;
comment|/**  * Return the pool that was used for this @a allocator.  *  * WARNING: the use of this pool for allocations requires a very  *   detailed understanding of pool behaviors, the bucket system,  *   and knowledge of the bucket's use within the overall pattern  *   of request/response behavior.  *  * See design-guide.txt for more information about pool usage.  */
name|apr_pool_t
modifier|*
name|serf_bucket_allocator_get_pool
parameter_list|(
specifier|const
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
comment|/**  * Utility structure for reading a complete line of input from a bucket.  *  * Since it is entirely possible for a line to be broken by APR_EAGAIN,  * this structure can be used to accumulate the data until a complete line  * has been read from a bucket.  */
comment|/* This limit applies to the line buffer functions. If an application needs  * longer lines, then they will need to manually handle line buffering.  */
define|#
directive|define
name|SERF_LINEBUF_LIMIT
value|8000
typedef|typedef
struct|struct
block|{
comment|/* Current state of the buffer. */
enum|enum
block|{
name|SERF_LINEBUF_EMPTY
block|,
name|SERF_LINEBUF_READY
block|,
name|SERF_LINEBUF_PARTIAL
block|,
name|SERF_LINEBUF_CRLF_SPLIT
block|}
name|state
enum|;
comment|/* How much of the buffer have we used? */
name|apr_size_t
name|used
decl_stmt|;
comment|/* The line is read into this buffer, minus CR/LF */
name|char
name|line
index|[
name|SERF_LINEBUF_LIMIT
index|]
decl_stmt|;
block|}
name|serf_linebuf_t
typedef|;
comment|/**  * Initialize the @a linebuf structure.  */
name|void
name|serf_linebuf_init
parameter_list|(
name|serf_linebuf_t
modifier|*
name|linebuf
parameter_list|)
function_decl|;
comment|/**  * Fetch a line of text from @a bucket, accumulating the line into  * @a linebuf. @a acceptable specifies the types of newlines which are  * acceptable for this fetch.  *  * ### we should return a data/len pair so that we can avoid a copy,  * ### rather than having callers look into our state and line buffer.  */
name|apr_status_t
name|serf_linebuf_fetch
parameter_list|(
name|serf_linebuf_t
modifier|*
name|linebuf
parameter_list|,
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|int
name|acceptable
parameter_list|)
function_decl|;
comment|/** @} */
comment|/* Internal functions for bucket use and lifecycle tracking */
name|apr_status_t
name|serf_debug__record_read
parameter_list|(
specifier|const
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_status_t
name|status
parameter_list|)
function_decl|;
name|void
name|serf_debug__entered_loop
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
name|void
name|serf_debug__closed_conn
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
name|void
name|serf_debug__bucket_destroy
parameter_list|(
specifier|const
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
function_decl|;
name|void
name|serf_debug__bucket_alloc_check
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
function_decl|;
comment|/* Version info */
define|#
directive|define
name|SERF_MAJOR_VERSION
value|1
define|#
directive|define
name|SERF_MINOR_VERSION
value|3
define|#
directive|define
name|SERF_PATCH_VERSION
value|0
comment|/* Version number string */
define|#
directive|define
name|SERF_VERSION_STRING
value|APR_STRINGIFY(SERF_MAJOR_VERSION) "." \                             APR_STRINGIFY(SERF_MINOR_VERSION) "." \                             APR_STRINGIFY(SERF_PATCH_VERSION)
comment|/**  * Check at compile time if the Serf version is at least a certain  * level.  * @param major The major version component of the version checked  * for (e.g., the "1" of "1.3.0").  * @param minor The minor version component of the version checked  * for (e.g., the "3" of "1.3.0").  * @param patch The patch level component of the version checked  * for (e.g., the "0" of "1.3.0").  */
define|#
directive|define
name|SERF_VERSION_AT_LEAST
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|,
name|patch
parameter_list|)
define|\
value|(((major)< SERF_MAJOR_VERSION)                                          \   || ((major) == SERF_MAJOR_VERSION&& (minor)< SERF_MINOR_VERSION)     \    || ((major) == SERF_MAJOR_VERSION&& (minor) == SERF_MINOR_VERSION&& \             (patch)<= SERF_PATCH_VERSION))
comment|/**  * Returns the version of the library the application has linked/loaded.  * Values are returned in @a major, @a minor, and @a patch.  *  * Applications will want to use this function to verify compatibility,  * expecially while serf has not reached a 1.0 milestone. APIs and  * semantics may change drastically until the library hits 1.0.  */
name|void
name|serf_lib_version
parameter_list|(
name|int
modifier|*
name|major
parameter_list|,
name|int
modifier|*
name|minor
parameter_list|,
name|int
modifier|*
name|patch
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Every user of serf will want to deal with our various bucket types.  * Go ahead and include that header right now.  *  * Note: make sure this occurs outside of the C++ namespace block  */
end_comment

begin_include
include|#
directive|include
file|"serf_bucket_types.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SERF_H */
end_comment

end_unit

