begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2002-2004 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SERF_BUCKET_UTIL_H
end_ifndef

begin_define
define|#
directive|define
name|SERF_BUCKET_UTIL_H
end_define

begin_comment
comment|/**  * @file serf_bucket_util.h  * @brief This header defines a set of functions and other utilities  * for implementing buckets. It is not needed by users of the bucket  * system.  */
end_comment

begin_include
include|#
directive|include
file|"serf.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/**  * Basic bucket creation function.  *  * This function will create a bucket of @a type, allocating the necessary  * memory from @a allocator. The @a data bucket-private information will  * be stored into the bucket.  */
name|serf_bucket_t
modifier|*
name|serf_bucket_create
parameter_list|(
specifier|const
name|serf_bucket_type_t
modifier|*
name|type
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
comment|/**  * Default implementation of the @see read_iovec functionality.  *  * This function will use the @see read function to get a block of memory,  * then return it in the iovec.  */
name|apr_status_t
name|serf_default_read_iovec
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
name|int
name|vecs_size
parameter_list|,
name|struct
name|iovec
modifier|*
name|vecs
parameter_list|,
name|int
modifier|*
name|vecs_used
parameter_list|)
function_decl|;
comment|/**  * Default implementation of the @see read_for_sendfile functionality.  *  * This function will use the @see read function to get a block of memory,  * then return it as a header. No file will be returned.  */
name|apr_status_t
name|serf_default_read_for_sendfile
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
name|apr_hdtr_t
modifier|*
name|hdtr
parameter_list|,
name|apr_file_t
modifier|*
modifier|*
name|file
parameter_list|,
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
function_decl|;
comment|/**  * Default implementation of the @see read_bucket functionality.  *  * This function will always return NULL, indicating that the @a type  * of bucket cannot be found within @a bucket.  */
name|serf_bucket_t
modifier|*
name|serf_default_read_bucket
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
specifier|const
name|serf_bucket_type_t
modifier|*
name|type
parameter_list|)
function_decl|;
comment|/**  * Default implementation of the @see destroy functionality.  *  * This function will return the @a bucket to its allcoator.  */
name|void
name|serf_default_destroy
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
function_decl|;
comment|/**  * Default implementation of the @see destroy functionality.  *  * This function will return the @a bucket, and the data member to its  * allocator.  */
name|void
name|serf_default_destroy_and_data
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
function_decl|;
comment|/**  * Allocate @a size bytes of memory using @a allocator.  *  * Returns NULL of the requested memory size could not be allocated.  */
name|void
modifier|*
name|serf_bucket_mem_alloc
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
name|apr_size_t
name|size
parameter_list|)
function_decl|;
comment|/**  * Allocate @a size bytes of memory using @a allocator and set all of the  * memory to 0.  *  * Returns NULL of the requested memory size could not be allocated.  */
name|void
modifier|*
name|serf_bucket_mem_calloc
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
name|apr_size_t
name|size
parameter_list|)
function_decl|;
comment|/**  * Free the memory at @a block, returning it to @a allocator.  */
name|void
name|serf_bucket_mem_free
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
name|void
modifier|*
name|block
parameter_list|)
function_decl|;
comment|/**  * Analogous to apr_pstrmemdup, using a bucket allocator instead.  */
name|char
modifier|*
name|serf_bstrmemdup
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|apr_size_t
name|size
parameter_list|)
function_decl|;
comment|/**  * Analogous to apr_pmemdup, using a bucket allocator instead.  */
name|void
modifier|*
name|serf_bmemdup
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
specifier|const
name|void
modifier|*
name|mem
parameter_list|,
name|apr_size_t
name|size
parameter_list|)
function_decl|;
comment|/**  * Analogous to apr_pstrdup, using a bucket allocator instead.  */
name|char
modifier|*
name|serf_bstrdup
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
comment|/**  * Analogous to apr_pstrcatv, using a bucket allocator instead.  */
name|char
modifier|*
name|serf_bstrcatv
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
name|struct
name|iovec
modifier|*
name|vec
parameter_list|,
name|int
name|vecs
parameter_list|,
name|apr_size_t
modifier|*
name|bytes_written
parameter_list|)
function_decl|;
comment|/**  * Read data up to a newline.  *  * @a acceptable contains the allowed forms of a newline, and @a found  * will return the particular newline type that was found. If a newline  * is not found, then SERF_NEWLINE_NONE will be placed in @a found.  *  * @a data should contain a pointer to the data to be scanned. @a len  * should specify the length of that data buffer. On exit, @a data will  * be advanced past the newline, and @a len will specify the remaining  * amount of data in the buffer.  *  * Given this pattern of behavior, the caller should store the initial  * value of @a data as the line start. The difference between the  * returned value of @a data and the saved start is the length of the  * line.  *  * Note that the newline character(s) will remain within the buffer.  * This function scans at a byte level for the newline characters. Thus,  * the data buffer may contain NUL characters. As a corollary, this  * function only works on 8-bit character encodings.  *  * If the data is fully consumed (@a len gets set to zero) and a CR  * character is found at the end and the CRLF sequence is allowed, then  * this function may store SERF_NEWLINE_CRLF_SPLIT into @a found. The  * caller should take particular consideration for the CRLF sequence  * that may be split across data buffer boundaries.  */
name|void
name|serf_util_readline
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
name|int
name|acceptable
parameter_list|,
name|int
modifier|*
name|found
parameter_list|)
function_decl|;
comment|/** The buffer size used within @see serf_databuf_t. */
define|#
directive|define
name|SERF_DATABUF_BUFSIZE
value|8000
comment|/** Callback function which is used to refill the data buffer.  *  * The function takes @a baton, which is the @see read_baton value  * from the serf_databuf_t structure. Data should be placed into  * a buffer specified by @a buf, which is @a bufsize bytes long.  * The amount of data read should be returned in @a len.  *  * APR_EOF should be returned if no more data is available. APR_EAGAIN  * should be returned, rather than blocking. In both cases, @a buf  * should be filled in and @a len set, as appropriate.  */
typedef|typedef
name|apr_status_t
function_decl|(
modifier|*
name|serf_databuf_reader_t
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_size_t
name|bufsize
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
function_decl|;
comment|/**  * This structure is used as an intermediate data buffer for some "external"  * source of data. It works as a scratch pad area for incoming data to be  * stored, and then returned as a ptr/len pair by the bucket read functions.  *  * This structure should be initialized by calling @see serf_databuf_init.  * Users should not bother to zero the structure beforehand.  */
typedef|typedef
struct|struct
block|{
comment|/** The current data position within the buffer. */
specifier|const
name|char
modifier|*
name|current
decl_stmt|;
comment|/** Amount of data remaining in the buffer. */
name|apr_size_t
name|remaining
decl_stmt|;
comment|/** Callback function. */
name|serf_databuf_reader_t
name|read
decl_stmt|;
comment|/** A baton to hold context-specific data. */
name|void
modifier|*
name|read_baton
decl_stmt|;
comment|/** Records the status from the last @see read operation. */
name|apr_status_t
name|status
decl_stmt|;
comment|/** Holds the data until it can be returned. */
name|char
name|buf
index|[
name|SERF_DATABUF_BUFSIZE
index|]
decl_stmt|;
block|}
name|serf_databuf_t
typedef|;
comment|/**  * Initialize the @see serf_databuf_t structure specified by @a databuf.  */
name|void
name|serf_databuf_init
parameter_list|(
name|serf_databuf_t
modifier|*
name|databuf
parameter_list|)
function_decl|;
comment|/**  * Implement a bucket-style read function from the @see serf_databuf_t  * structure given by @a databuf.  *  * The @a requested, @a data, and @a len fields are interpreted and used  * as in the read function of @see serf_bucket_t.  */
name|apr_status_t
name|serf_databuf_read
parameter_list|(
name|serf_databuf_t
modifier|*
name|databuf
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
function_decl|;
comment|/**  * Implement a bucket-style readline function from the @see serf_databuf_t  * structure given by @a databuf.  *  * The @a acceptable, @a found, @a data, and @a len fields are interpreted  * and used as in the read function of @see serf_bucket_t.  */
name|apr_status_t
name|serf_databuf_readline
parameter_list|(
name|serf_databuf_t
modifier|*
name|databuf
parameter_list|,
name|int
name|acceptable
parameter_list|,
name|int
modifier|*
name|found
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
function_decl|;
comment|/**  * Implement a bucket-style peek function from the @see serf_databuf_t  * structure given by @a databuf.  *  * The @a data, and @a len fields are interpreted and used as in the  * peek function of @see serf_bucket_t.  */
name|apr_status_t
name|serf_databuf_peek
parameter_list|(
name|serf_databuf_t
modifier|*
name|databuf
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SERF_BUCKET_UTIL_H */
end_comment

end_unit

