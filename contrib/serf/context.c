begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2002-2004 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_poll.h>
end_include

begin_include
include|#
directive|include
file|<apr_version.h>
end_include

begin_include
include|#
directive|include
file|"serf.h"
end_include

begin_include
include|#
directive|include
file|"serf_bucket_util.h"
end_include

begin_include
include|#
directive|include
file|"serf_private.h"
end_include

begin_comment
comment|/**  * Callback function (implements serf_progress_t). Takes a number of bytes  * read @a read and bytes written @a written, adds those to the total for this  * context and notifies an interested party (if any).  */
end_comment

begin_function
name|void
name|serf__context_progress_delta
parameter_list|(
name|void
modifier|*
name|progress_baton
parameter_list|,
name|apr_off_t
name|read
parameter_list|,
name|apr_off_t
name|written
parameter_list|)
block|{
name|serf_context_t
modifier|*
name|ctx
init|=
name|progress_baton
decl_stmt|;
name|ctx
operator|->
name|progress_read
operator|+=
name|read
expr_stmt|;
name|ctx
operator|->
name|progress_written
operator|+=
name|written
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|progress_func
condition|)
name|ctx
operator|->
name|progress_func
argument_list|(
name|ctx
operator|->
name|progress_baton
argument_list|,
name|ctx
operator|->
name|progress_read
argument_list|,
name|ctx
operator|->
name|progress_written
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check for dirty connections and update their pollsets accordingly. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|check_dirty_pollsets
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* if we're not dirty, return now. */
if|if
condition|(
operator|!
name|ctx
operator|->
name|dirty_pollset
condition|)
block|{
return|return
name|APR_SUCCESS
return|;
block|}
for|for
control|(
name|i
operator|=
name|ctx
operator|->
name|conns
operator|->
name|nelts
init|;
name|i
operator|--
condition|;
control|)
block|{
name|serf_connection_t
modifier|*
name|conn
init|=
name|GET_CONN
argument_list|(
name|ctx
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
comment|/* if this connection isn't dirty, skip it. */
if|if
condition|(
operator|!
name|conn
operator|->
name|dirty_conn
condition|)
block|{
continue|continue;
block|}
comment|/* reset this connection's flag before we update. */
name|conn
operator|->
name|dirty_conn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|serf__conn_update_pollset
argument_list|(
name|conn
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
block|}
comment|/* reset our context flag now */
name|ctx
operator|->
name|dirty_pollset
operator|=
literal|0
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|pollset_add
parameter_list|(
name|void
modifier|*
name|user_baton
parameter_list|,
name|apr_pollfd_t
modifier|*
name|pfd
parameter_list|,
name|void
modifier|*
name|serf_baton
parameter_list|)
block|{
name|serf_pollset_t
modifier|*
name|s
init|=
operator|(
name|serf_pollset_t
operator|*
operator|)
name|user_baton
decl_stmt|;
name|pfd
operator|->
name|client_data
operator|=
name|serf_baton
expr_stmt|;
return|return
name|apr_pollset_add
argument_list|(
name|s
operator|->
name|pollset
argument_list|,
name|pfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|pollset_rm
parameter_list|(
name|void
modifier|*
name|user_baton
parameter_list|,
name|apr_pollfd_t
modifier|*
name|pfd
parameter_list|,
name|void
modifier|*
name|serf_baton
parameter_list|)
block|{
name|serf_pollset_t
modifier|*
name|s
init|=
operator|(
name|serf_pollset_t
operator|*
operator|)
name|user_baton
decl_stmt|;
name|pfd
operator|->
name|client_data
operator|=
name|serf_baton
expr_stmt|;
return|return
name|apr_pollset_remove
argument_list|(
name|s
operator|->
name|pollset
argument_list|,
name|pfd
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|serf_config_proxy
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|apr_sockaddr_t
modifier|*
name|address
parameter_list|)
block|{
name|ctx
operator|->
name|proxy_address
operator|=
name|address
expr_stmt|;
block|}
end_function

begin_function
name|void
name|serf_config_credentials_callback
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|serf_credentials_callback_t
name|cred_cb
parameter_list|)
block|{
name|ctx
operator|->
name|cred_cb
operator|=
name|cred_cb
expr_stmt|;
block|}
end_function

begin_function
name|void
name|serf_config_authn_types
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|int
name|authn_types
parameter_list|)
block|{
name|ctx
operator|->
name|authn_types
operator|=
name|authn_types
expr_stmt|;
block|}
end_function

begin_function
name|serf_context_t
modifier|*
name|serf_context_create_ex
parameter_list|(
name|void
modifier|*
name|user_baton
parameter_list|,
name|serf_socket_add_t
name|addf
parameter_list|,
name|serf_socket_remove_t
name|rmf
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|serf_context_t
modifier|*
name|ctx
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
decl_stmt|;
name|ctx
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
if|if
condition|(
name|user_baton
operator|!=
name|NULL
condition|)
block|{
name|ctx
operator|->
name|pollset_baton
operator|=
name|user_baton
expr_stmt|;
name|ctx
operator|->
name|pollset_add
operator|=
name|addf
expr_stmt|;
name|ctx
operator|->
name|pollset_rm
operator|=
name|rmf
expr_stmt|;
block|}
else|else
block|{
comment|/* build the pollset with a (default) number of connections */
name|serf_pollset_t
modifier|*
name|ps
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ps
argument_list|)
argument_list|)
decl_stmt|;
comment|/* ### TODO: As of APR 1.4.x apr_pollset_create_ex can return a status            ### other than APR_SUCCESS, so we should handle it.            ### Probably move creation of the pollset to later when we have            ### the possibility of returning status to the caller.          */
ifdef|#
directive|ifdef
name|BROKEN_WSAPOLL
comment|/* APR 1.4.x switched to using WSAPoll() on Win32, but it does not          * properly handle errors on a non-blocking sockets (such as          * connecting to a server where no listener is active).          *          * So, sadly, we must force using select() on Win32.          *          * http://mail-archives.apache.org/mod_mbox/apr-dev/201105.mbox/%3CBANLkTin3rBCecCBRvzUA5B-14u-NWxR_Kg@mail.gmail.com%3E          */
operator|(
name|void
operator|)
name|apr_pollset_create_ex
argument_list|(
operator|&
name|ps
operator|->
name|pollset
argument_list|,
name|MAX_CONN
argument_list|,
name|pool
argument_list|,
literal|0
argument_list|,
name|APR_POLLSET_SELECT
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|apr_pollset_create
argument_list|(
operator|&
name|ps
operator|->
name|pollset
argument_list|,
name|MAX_CONN
argument_list|,
name|pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctx
operator|->
name|pollset_baton
operator|=
name|ps
expr_stmt|;
name|ctx
operator|->
name|pollset_add
operator|=
name|pollset_add
expr_stmt|;
name|ctx
operator|->
name|pollset_rm
operator|=
name|pollset_rm
expr_stmt|;
block|}
comment|/* default to a single connection since that is the typical case */
name|ctx
operator|->
name|conns
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|serf_connection_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize progress status */
name|ctx
operator|->
name|progress_read
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|progress_written
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|authn_types
operator|=
name|SERF_AUTHN_ALL
expr_stmt|;
name|ctx
operator|->
name|server_authn_info
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|ctx
return|;
block|}
end_function

begin_function
name|serf_context_t
modifier|*
name|serf_context_create
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|serf_context_create_ex
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf_context_prerun
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|)
block|{
name|apr_status_t
name|status
init|=
name|APR_SUCCESS
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|serf__open_connections
argument_list|(
name|ctx
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|(
name|status
operator|=
name|check_dirty_pollsets
argument_list|(
name|ctx
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf_event_trigger
parameter_list|(
name|serf_context_t
modifier|*
name|s
parameter_list|,
name|void
modifier|*
name|serf_baton
parameter_list|,
specifier|const
name|apr_pollfd_t
modifier|*
name|desc
parameter_list|)
block|{
name|apr_pollfd_t
name|tdesc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|apr_status_t
name|status
init|=
name|APR_SUCCESS
decl_stmt|;
name|serf_io_baton_t
modifier|*
name|io
init|=
name|serf_baton
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|type
operator|==
name|SERF_IO_CONN
condition|)
block|{
name|serf_connection_t
modifier|*
name|conn
init|=
name|io
operator|->
name|u
operator|.
name|conn
decl_stmt|;
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
comment|/* If this connection has already failed, return the error again, and try          * to remove it from the pollset again          */
if|if
condition|(
name|conn
operator|->
name|status
condition|)
block|{
name|tdesc
operator|.
name|desc_type
operator|=
name|APR_POLL_SOCKET
expr_stmt|;
name|tdesc
operator|.
name|desc
operator|.
name|s
operator|=
name|conn
operator|->
name|skt
expr_stmt|;
name|tdesc
operator|.
name|reqevents
operator|=
name|conn
operator|->
name|reqevents
expr_stmt|;
name|ctx
operator|->
name|pollset_rm
argument_list|(
name|ctx
operator|->
name|pollset_baton
argument_list|,
operator|&
name|tdesc
argument_list|,
name|conn
argument_list|)
expr_stmt|;
return|return
name|conn
operator|->
name|status
return|;
block|}
comment|/* apr_pollset_poll() can return a conn multiple times... */
if|if
condition|(
operator|(
name|conn
operator|->
name|seen_in_pollset
operator|&
name|desc
operator|->
name|rtnevents
operator|)
operator|!=
literal|0
operator|||
operator|(
name|conn
operator|->
name|seen_in_pollset
operator|&
name|APR_POLLHUP
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|APR_SUCCESS
return|;
block|}
name|conn
operator|->
name|seen_in_pollset
operator||=
name|desc
operator|->
name|rtnevents
expr_stmt|;
if|if
condition|(
operator|(
name|conn
operator|->
name|status
operator|=
name|serf__process_connection
argument_list|(
name|conn
argument_list|,
name|desc
operator|->
name|rtnevents
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
comment|/* it's possible that the connection was already reset and thus the                socket cleaned up. */
if|if
condition|(
name|conn
operator|->
name|skt
condition|)
block|{
name|tdesc
operator|.
name|desc_type
operator|=
name|APR_POLL_SOCKET
expr_stmt|;
name|tdesc
operator|.
name|desc
operator|.
name|s
operator|=
name|conn
operator|->
name|skt
expr_stmt|;
name|tdesc
operator|.
name|reqevents
operator|=
name|conn
operator|->
name|reqevents
expr_stmt|;
name|ctx
operator|->
name|pollset_rm
argument_list|(
name|ctx
operator|->
name|pollset_baton
argument_list|,
operator|&
name|tdesc
argument_list|,
name|conn
argument_list|)
expr_stmt|;
block|}
return|return
name|conn
operator|->
name|status
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|io
operator|->
name|type
operator|==
name|SERF_IO_LISTENER
condition|)
block|{
name|serf_listener_t
modifier|*
name|l
init|=
name|io
operator|->
name|u
operator|.
name|listener
decl_stmt|;
name|status
operator|=
name|serf__process_listener
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|io
operator|->
name|type
operator|==
name|SERF_IO_CLIENT
condition|)
block|{
name|serf_incoming_t
modifier|*
name|c
init|=
name|io
operator|->
name|u
operator|.
name|client
decl_stmt|;
name|status
operator|=
name|serf__process_client
argument_list|(
name|c
argument_list|,
name|desc
operator|->
name|rtnevents
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf_context_run
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|apr_short_interval_time_t
name|duration
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|apr_int32_t
name|num
decl_stmt|;
specifier|const
name|apr_pollfd_t
modifier|*
name|desc
decl_stmt|;
name|serf_pollset_t
modifier|*
name|ps
init|=
operator|(
name|serf_pollset_t
operator|*
operator|)
name|ctx
operator|->
name|pollset_baton
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|serf_context_prerun
argument_list|(
name|ctx
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|status
return|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|apr_pollset_poll
argument_list|(
name|ps
operator|->
name|pollset
argument_list|,
name|duration
argument_list|,
operator|&
name|num
argument_list|,
operator|&
name|desc
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
comment|/* EINTR indicates a handled signal happened during the poll call,            ignore, the application can safely retry. */
if|if
condition|(
name|APR_STATUS_IS_EINTR
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|APR_SUCCESS
return|;
comment|/* ### do we still need to dispatch stuff here?            ### look at the potential return codes. map to our defined            ### return values? ...         */
comment|/* Use the strict documented error for poll timeouts, to allow proper            handling of the other timeout types when returned from            serf_event_trigger */
if|if
condition|(
name|APR_STATUS_IS_TIMEUP
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|APR_TIMEUP
return|;
comment|/* Return the documented error */
return|return
name|status
return|;
block|}
while|while
condition|(
name|num
operator|--
condition|)
block|{
name|serf_connection_t
modifier|*
name|conn
init|=
name|desc
operator|->
name|client_data
decl_stmt|;
name|status
operator|=
name|serf_event_trigger
argument_list|(
name|ctx
argument_list|,
name|conn
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
name|desc
operator|++
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|void
name|serf_context_set_progress_cb
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|serf_progress_t
name|progress_func
parameter_list|,
name|void
modifier|*
name|progress_baton
parameter_list|)
block|{
name|ctx
operator|->
name|progress_func
operator|=
name|progress_func
expr_stmt|;
name|ctx
operator|->
name|progress_baton
operator|=
name|progress_baton
expr_stmt|;
block|}
end_function

begin_function
name|serf_bucket_t
modifier|*
name|serf_context_bucket_socket_create
parameter_list|(
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|apr_socket_t
modifier|*
name|skt
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
block|{
name|serf_bucket_t
modifier|*
name|bucket
init|=
name|serf_bucket_socket_create
argument_list|(
name|skt
argument_list|,
name|allocator
argument_list|)
decl_stmt|;
comment|/* Use serf's default bytes read/written callback */
name|serf_bucket_socket_set_read_progress_cb
argument_list|(
name|bucket
argument_list|,
name|serf__context_progress_delta
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
return|return
name|bucket
return|;
block|}
end_function

begin_comment
comment|/* ### this really ought to go somewhere else, but... meh.  */
end_comment

begin_function
name|void
name|serf_lib_version
parameter_list|(
name|int
modifier|*
name|major
parameter_list|,
name|int
modifier|*
name|minor
parameter_list|,
name|int
modifier|*
name|patch
parameter_list|)
block|{
operator|*
name|major
operator|=
name|SERF_MAJOR_VERSION
expr_stmt|;
operator|*
name|minor
operator|=
name|SERF_MINOR_VERSION
expr_stmt|;
operator|*
name|patch
operator|=
name|SERF_PATCH_VERSION
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|serf_error_string
parameter_list|(
name|apr_status_t
name|errcode
parameter_list|)
block|{
switch|switch
condition|(
name|errcode
condition|)
block|{
case|case
name|SERF_ERROR_CLOSING
case|:
return|return
literal|"The connection is closing"
return|;
case|case
name|SERF_ERROR_REQUEST_LOST
case|:
return|return
literal|"A request has been lost"
return|;
case|case
name|SERF_ERROR_WAIT_CONN
case|:
return|return
literal|"The connection is blocked, pending further action"
return|;
case|case
name|SERF_ERROR_DECOMPRESSION_FAILED
case|:
return|return
literal|"An error occurred during decompression"
return|;
case|case
name|SERF_ERROR_BAD_HTTP_RESPONSE
case|:
return|return
literal|"The server sent an improper HTTP response"
return|;
case|case
name|SERF_ERROR_TRUNCATED_HTTP_RESPONSE
case|:
return|return
literal|"The server sent a truncated HTTP response body."
return|;
case|case
name|SERF_ERROR_ABORTED_CONNECTION
case|:
return|return
literal|"The server unexpectedly closed the connection."
return|;
case|case
name|SERF_ERROR_SSL_COMM_FAILED
case|:
return|return
literal|"An error occurred during SSL communication"
return|;
case|case
name|SERF_ERROR_SSL_CERT_FAILED
case|:
return|return
literal|"An SSL certificate related error occurred "
return|;
case|case
name|SERF_ERROR_AUTHN_FAILED
case|:
return|return
literal|"An error occurred during authentication"
return|;
case|case
name|SERF_ERROR_AUTHN_NOT_SUPPORTED
case|:
return|return
literal|"The requested authentication type(s) are not supported"
return|;
case|case
name|SERF_ERROR_AUTHN_MISSING_ATTRIBUTE
case|:
return|return
literal|"An authentication attribute is missing"
return|;
case|case
name|SERF_ERROR_AUTHN_INITALIZATION_FAILED
case|:
return|return
literal|"Initialization of an authentication type failed"
return|;
case|case
name|SERF_ERROR_SSLTUNNEL_SETUP_FAILED
case|:
return|return
literal|"The proxy server returned an error while setting up the "
literal|"SSL tunnel."
return|;
default|default:
return|return
name|NULL
return|;
block|}
comment|/* NOTREACHED  */
block|}
end_function

end_unit

