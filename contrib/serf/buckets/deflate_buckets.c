begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2002-2004 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_comment
comment|/* This conditional isn't defined anywhere yet. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZUTIL_H
end_ifdef

begin_include
include|#
directive|include
file|<zutil.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"serf.h"
end_include

begin_include
include|#
directive|include
file|"serf_bucket_util.h"
end_include

begin_comment
comment|/* magic header */
end_comment

begin_decl_stmt
specifier|static
name|char
name|deflate_magic
index|[
literal|2
index|]
init|=
block|{
literal|'\037'
block|,
literal|'\213'
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEFLATE_MAGIC_SIZE
value|10
end_define

begin_define
define|#
directive|define
name|DEFLATE_VERIFY_SIZE
value|8
end_define

begin_define
define|#
directive|define
name|DEFLATE_BUFFER_SIZE
value|8096
end_define

begin_decl_stmt
specifier|static
specifier|const
name|int
name|DEFLATE_WINDOW_SIZE
init|=
operator|-
literal|15
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|DEFLATE_MEMLEVEL
init|=
literal|9
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|serf_bucket_t
modifier|*
name|stream
decl_stmt|;
name|serf_bucket_t
modifier|*
name|inflate_stream
decl_stmt|;
name|int
name|format
decl_stmt|;
comment|/* Are we 'deflate' or 'gzip'? */
enum|enum
block|{
name|STATE_READING_HEADER
block|,
comment|/* reading the gzip header */
name|STATE_HEADER
block|,
comment|/* read the gzip header */
name|STATE_INIT
block|,
comment|/* init'ing zlib functions */
name|STATE_INFLATE
block|,
comment|/* inflating the content now */
name|STATE_READING_VERIFY
block|,
comment|/* reading the final gzip CRC */
name|STATE_VERIFY
block|,
comment|/* verifying the final gzip CRC */
name|STATE_FINISH
block|,
comment|/* clean up after reading body */
name|STATE_DONE
block|,
comment|/* body is done; we'll return EOF here */
block|}
name|state
enum|;
name|z_stream
name|zstream
decl_stmt|;
name|char
name|hdr_buffer
index|[
name|DEFLATE_MAGIC_SIZE
index|]
decl_stmt|;
name|unsigned
name|char
name|buffer
index|[
name|DEFLATE_BUFFER_SIZE
index|]
decl_stmt|;
name|unsigned
name|long
name|crc
decl_stmt|;
name|int
name|windowSize
decl_stmt|;
name|int
name|memLevel
decl_stmt|;
name|int
name|bufferSize
decl_stmt|;
comment|/* How much of the chunk, or the terminator, do we have left to read? */
name|apr_size_t
name|stream_left
decl_stmt|;
comment|/* How much are we supposed to read? */
name|apr_size_t
name|stream_size
decl_stmt|;
name|int
name|stream_status
decl_stmt|;
comment|/* What was the last status we read? */
block|}
name|deflate_context_t
typedef|;
end_typedef

begin_comment
comment|/* Inputs a string and returns a long.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|getLong
parameter_list|(
name|unsigned
name|char
modifier|*
name|string
parameter_list|)
block|{
return|return
operator|(
operator|(
name|unsigned
name|long
operator|)
name|string
index|[
literal|0
index|]
operator|)
operator||
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|string
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|string
index|[
literal|2
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|string
index|[
literal|3
index|]
operator|)
operator|<<
literal|24
operator|)
return|;
block|}
end_function

begin_function
name|serf_bucket_t
modifier|*
name|serf_bucket_deflate_create
parameter_list|(
name|serf_bucket_t
modifier|*
name|stream
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
name|int
name|format
parameter_list|)
block|{
name|deflate_context_t
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|serf_bucket_mem_alloc
argument_list|(
name|allocator
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
name|ctx
operator|->
name|stream_status
operator|=
name|APR_SUCCESS
expr_stmt|;
name|ctx
operator|->
name|inflate_stream
operator|=
name|serf_bucket_aggregate_create
argument_list|(
name|allocator
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|format
operator|=
name|format
expr_stmt|;
name|ctx
operator|->
name|crc
operator|=
literal|0
expr_stmt|;
comment|/* zstream must be NULL'd out. */
name|memset
argument_list|(
operator|&
name|ctx
operator|->
name|zstream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|zstream
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ctx
operator|->
name|format
condition|)
block|{
case|case
name|SERF_DEFLATE_GZIP
case|:
name|ctx
operator|->
name|state
operator|=
name|STATE_READING_HEADER
expr_stmt|;
break|break;
case|case
name|SERF_DEFLATE_DEFLATE
case|:
comment|/* deflate doesn't have a header. */
name|ctx
operator|->
name|state
operator|=
name|STATE_INIT
expr_stmt|;
break|break;
default|default:
comment|/* Not reachable */
return|return
name|NULL
return|;
block|}
comment|/* Initial size of gzip header. */
name|ctx
operator|->
name|stream_left
operator|=
name|ctx
operator|->
name|stream_size
operator|=
name|DEFLATE_MAGIC_SIZE
expr_stmt|;
name|ctx
operator|->
name|windowSize
operator|=
name|DEFLATE_WINDOW_SIZE
expr_stmt|;
name|ctx
operator|->
name|memLevel
operator|=
name|DEFLATE_MEMLEVEL
expr_stmt|;
name|ctx
operator|->
name|bufferSize
operator|=
name|DEFLATE_BUFFER_SIZE
expr_stmt|;
return|return
name|serf_bucket_create
argument_list|(
operator|&
name|serf_bucket_type_deflate
argument_list|,
name|allocator
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|serf_deflate_destroy_and_data
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
block|{
name|deflate_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|state
operator|>
name|STATE_INIT
operator|&&
name|ctx
operator|->
name|state
operator|<=
name|STATE_FINISH
condition|)
name|inflateEnd
argument_list|(
operator|&
name|ctx
operator|->
name|zstream
argument_list|)
expr_stmt|;
comment|/* We may have appended inflate_stream into the stream bucket.      * If so, avoid free'ing it twice.      */
if|if
condition|(
name|ctx
operator|->
name|inflate_stream
condition|)
block|{
name|serf_bucket_destroy
argument_list|(
name|ctx
operator|->
name|inflate_stream
argument_list|)
expr_stmt|;
block|}
name|serf_bucket_destroy
argument_list|(
name|ctx
operator|->
name|stream
argument_list|)
expr_stmt|;
name|serf_default_destroy_and_data
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_deflate_read
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|deflate_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|private_data
decl_stmt|;
name|apr_size_t
name|private_len
decl_stmt|;
name|int
name|zRC
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|ctx
operator|->
name|state
condition|)
block|{
case|case
name|STATE_READING_HEADER
case|:
case|case
name|STATE_READING_VERIFY
case|:
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|ctx
operator|->
name|stream
argument_list|,
name|ctx
operator|->
name|stream_left
argument_list|,
operator|&
name|private_data
argument_list|,
operator|&
name|private_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|status
return|;
block|}
name|memcpy
argument_list|(
name|ctx
operator|->
name|hdr_buffer
operator|+
operator|(
name|ctx
operator|->
name|stream_size
operator|-
name|ctx
operator|->
name|stream_left
operator|)
argument_list|,
name|private_data
argument_list|,
name|private_len
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|stream_left
operator|-=
name|private_len
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|stream_left
operator|==
literal|0
condition|)
block|{
name|ctx
operator|->
name|state
operator|++
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|status
argument_list|)
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|status
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|status
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|status
return|;
block|}
break|break;
case|case
name|STATE_HEADER
case|:
if|if
condition|(
name|ctx
operator|->
name|hdr_buffer
index|[
literal|0
index|]
operator|!=
name|deflate_magic
index|[
literal|0
index|]
operator|||
name|ctx
operator|->
name|hdr_buffer
index|[
literal|1
index|]
operator|!=
name|deflate_magic
index|[
literal|1
index|]
condition|)
block|{
return|return
name|SERF_ERROR_DECOMPRESSION_FAILED
return|;
block|}
if|if
condition|(
name|ctx
operator|->
name|hdr_buffer
index|[
literal|3
index|]
operator|!=
literal|0
condition|)
block|{
return|return
name|SERF_ERROR_DECOMPRESSION_FAILED
return|;
block|}
name|ctx
operator|->
name|state
operator|++
expr_stmt|;
break|break;
case|case
name|STATE_VERIFY
case|:
block|{
name|unsigned
name|long
name|compCRC
decl_stmt|,
name|compLen
decl_stmt|,
name|actualLen
decl_stmt|;
comment|/* Do the checksum computation. */
name|compCRC
operator|=
name|getLong
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ctx
operator|->
name|hdr_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|crc
operator|!=
name|compCRC
condition|)
block|{
return|return
name|SERF_ERROR_DECOMPRESSION_FAILED
return|;
block|}
name|compLen
operator|=
name|getLong
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ctx
operator|->
name|hdr_buffer
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* The length in the trailer is module 2^32, so do the same for                the actual length. */
name|actualLen
operator|=
name|ctx
operator|->
name|zstream
operator|.
name|total_out
expr_stmt|;
name|actualLen
operator|&=
literal|0xFFFFFFFF
expr_stmt|;
if|if
condition|(
name|actualLen
operator|!=
name|compLen
condition|)
block|{
return|return
name|SERF_ERROR_DECOMPRESSION_FAILED
return|;
block|}
name|ctx
operator|->
name|state
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|STATE_INIT
case|:
name|zRC
operator|=
name|inflateInit2
argument_list|(
operator|&
name|ctx
operator|->
name|zstream
argument_list|,
name|ctx
operator|->
name|windowSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|zRC
operator|!=
name|Z_OK
condition|)
block|{
return|return
name|SERF_ERROR_DECOMPRESSION_FAILED
return|;
block|}
name|ctx
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|ctx
operator|->
name|buffer
expr_stmt|;
name|ctx
operator|->
name|zstream
operator|.
name|avail_out
operator|=
name|ctx
operator|->
name|bufferSize
expr_stmt|;
name|ctx
operator|->
name|state
operator|++
expr_stmt|;
break|break;
case|case
name|STATE_FINISH
case|:
name|inflateEnd
argument_list|(
operator|&
name|ctx
operator|->
name|zstream
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_prepend
argument_list|(
name|ctx
operator|->
name|stream
argument_list|,
name|ctx
operator|->
name|inflate_stream
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|inflate_stream
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|state
operator|++
expr_stmt|;
break|break;
case|case
name|STATE_INFLATE
case|:
comment|/* Do we have anything already uncompressed to read? */
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|ctx
operator|->
name|inflate_stream
argument_list|,
name|requested
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|status
return|;
block|}
comment|/* Hide EOF. */
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|status
operator|=
name|ctx
operator|->
name|stream_status
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
comment|/* We've read all of the data from our stream, but we                      * need to continue to iterate until we flush                      * out the zlib buffer.                      */
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|len
operator|!=
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
comment|/* We tried; but we have nothing buffered. Fetch more. */
comment|/* It is possible that we maxed out avail_out before              * exhausting avail_in; therefore, continue using the              * previous buffer.  Otherwise, fetch more data from              * our stream bucket.              */
if|if
condition|(
name|ctx
operator|->
name|zstream
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
comment|/* When we empty our inflated stream, we'll return this                  * status - this allow us to eventually pass up EAGAINs.                  */
name|ctx
operator|->
name|stream_status
operator|=
name|serf_bucket_read
argument_list|(
name|ctx
operator|->
name|stream
argument_list|,
name|ctx
operator|->
name|bufferSize
argument_list|,
operator|&
name|private_data
argument_list|,
operator|&
name|private_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|ctx
operator|->
name|stream_status
argument_list|)
condition|)
block|{
return|return
name|ctx
operator|->
name|stream_status
return|;
block|}
if|if
condition|(
operator|!
name|private_len
operator|&&
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|ctx
operator|->
name|stream_status
argument_list|)
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|ctx
operator|->
name|stream_status
expr_stmt|;
name|ctx
operator|->
name|stream_status
operator|=
name|APR_SUCCESS
expr_stmt|;
return|return
name|status
return|;
block|}
name|ctx
operator|->
name|zstream
operator|.
name|next_in
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|private_data
expr_stmt|;
name|ctx
operator|->
name|zstream
operator|.
name|avail_in
operator|=
name|private_len
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|zRC
operator|=
name|inflate
argument_list|(
operator|&
name|ctx
operator|->
name|zstream
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
comment|/* We're full or zlib requires more space. Either case, clear                    out our buffer, reset, and return. */
if|if
condition|(
name|zRC
operator|==
name|Z_BUF_ERROR
operator|||
name|ctx
operator|->
name|zstream
operator|.
name|avail_out
operator|==
literal|0
condition|)
block|{
name|serf_bucket_t
modifier|*
name|tmp
decl_stmt|;
name|ctx
operator|->
name|zstream
operator|.
name|next_out
operator|=
name|ctx
operator|->
name|buffer
expr_stmt|;
name|private_len
operator|=
name|ctx
operator|->
name|bufferSize
operator|-
name|ctx
operator|->
name|zstream
operator|.
name|avail_out
expr_stmt|;
name|ctx
operator|->
name|crc
operator|=
name|crc32
argument_list|(
name|ctx
operator|->
name|crc
argument_list|,
operator|(
specifier|const
name|Bytef
operator|*
operator|)
name|ctx
operator|->
name|buffer
argument_list|,
name|private_len
argument_list|)
expr_stmt|;
comment|/* FIXME: There probably needs to be a free func. */
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ctx
operator|->
name|buffer
argument_list|,
name|private_len
argument_list|,
name|bucket
operator|->
name|allocator
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|ctx
operator|->
name|inflate_stream
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|zstream
operator|.
name|avail_out
operator|=
name|ctx
operator|->
name|bufferSize
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|zRC
operator|==
name|Z_STREAM_END
condition|)
block|{
name|serf_bucket_t
modifier|*
name|tmp
decl_stmt|;
name|private_len
operator|=
name|ctx
operator|->
name|bufferSize
operator|-
name|ctx
operator|->
name|zstream
operator|.
name|avail_out
expr_stmt|;
name|ctx
operator|->
name|crc
operator|=
name|crc32
argument_list|(
name|ctx
operator|->
name|crc
argument_list|,
operator|(
specifier|const
name|Bytef
operator|*
operator|)
name|ctx
operator|->
name|buffer
argument_list|,
name|private_len
argument_list|)
expr_stmt|;
comment|/* FIXME: There probably needs to be a free func. */
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ctx
operator|->
name|buffer
argument_list|,
name|private_len
argument_list|,
name|bucket
operator|->
name|allocator
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|ctx
operator|->
name|inflate_stream
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|zstream
operator|.
name|avail_out
operator|=
name|ctx
operator|->
name|bufferSize
expr_stmt|;
comment|/* Push back the remaining data to be read. */
name|tmp
operator|=
name|serf_bucket_aggregate_create
argument_list|(
name|bucket
operator|->
name|allocator
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_prepend
argument_list|(
name|tmp
argument_list|,
name|ctx
operator|->
name|stream
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|stream
operator|=
name|tmp
expr_stmt|;
comment|/* We now need to take the remaining avail_in and                      * throw it in ctx->stream so our next read picks it up.                      */
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ctx
operator|->
name|zstream
operator|.
name|next_in
argument_list|,
name|ctx
operator|->
name|zstream
operator|.
name|avail_in
argument_list|,
name|bucket
operator|->
name|allocator
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_prepend
argument_list|(
name|ctx
operator|->
name|stream
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ctx
operator|->
name|format
condition|)
block|{
case|case
name|SERF_DEFLATE_GZIP
case|:
name|ctx
operator|->
name|stream_left
operator|=
name|ctx
operator|->
name|stream_size
operator|=
name|DEFLATE_VERIFY_SIZE
expr_stmt|;
name|ctx
operator|->
name|state
operator|++
expr_stmt|;
break|break;
case|case
name|SERF_DEFLATE_DEFLATE
case|:
comment|/* Deflate does not have a verify footer. */
name|ctx
operator|->
name|state
operator|=
name|STATE_FINISH
expr_stmt|;
break|break;
default|default:
comment|/* Not reachable */
return|return
name|APR_EGENERAL
return|;
block|}
break|break;
block|}
comment|/* Any other error? */
if|if
condition|(
name|zRC
operator|!=
name|Z_OK
condition|)
block|{
return|return
name|SERF_ERROR_DECOMPRESSION_FAILED
return|;
block|}
comment|/* As long as zRC == Z_OK, just keep looping. */
block|}
comment|/* Okay, we've inflated.  Try to read. */
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|ctx
operator|->
name|inflate_stream
argument_list|,
name|requested
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Hide EOF. */
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|status
operator|=
name|ctx
operator|->
name|stream_status
expr_stmt|;
comment|/* If the inflation wasn't finished, return APR_SUCCESS. */
if|if
condition|(
name|zRC
operator|!=
name|Z_STREAM_END
condition|)
return|return
name|APR_SUCCESS
return|;
comment|/* If our stream is finished too and all data was inflated,                  * return SUCCESS so we'll iterate one more time.                  */
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
comment|/* No more data to read from the stream, and everything                        inflated. If all data was received correctly, state                        should have been advanced to STATE_READING_VERIFY or                        STATE_FINISH. If not, then the data was incomplete                        and we have an error. */
if|if
condition|(
name|ctx
operator|->
name|state
operator|!=
name|STATE_INFLATE
condition|)
return|return
name|APR_SUCCESS
return|;
else|else
return|return
name|SERF_ERROR_DECOMPRESSION_FAILED
return|;
block|}
block|}
return|return
name|status
return|;
case|case
name|STATE_DONE
case|:
comment|/* We're done inflating.  Use our finished buffer. */
return|return
name|serf_bucket_read
argument_list|(
name|ctx
operator|->
name|stream
argument_list|,
name|requested
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
return|;
default|default:
comment|/* Not reachable */
return|return
name|APR_EGENERAL
return|;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* ### need to implement */
end_comment

begin_define
define|#
directive|define
name|serf_deflate_readline
value|NULL
end_define

begin_define
define|#
directive|define
name|serf_deflate_peek
value|NULL
end_define

begin_decl_stmt
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_deflate
init|=
block|{
literal|"DEFLATE"
block|,
name|serf_deflate_read
block|,
name|serf_deflate_readline
block|,
name|serf_default_read_iovec
block|,
name|serf_default_read_for_sendfile
block|,
name|serf_default_read_bucket
block|,
name|serf_deflate_peek
block|,
name|serf_deflate_destroy_and_data
block|, }
decl_stmt|;
end_decl_stmt

end_unit

