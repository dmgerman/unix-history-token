begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2002-2004 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  *  * ----  *  * For the OpenSSL thread-safety locking code:  *  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  *  * Originally developed by Aaron Bannert and Justin Erenkrantz, eBuilt.  */
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_network_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_portable.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_base64.h>
end_include

begin_include
include|#
directive|include
file|<apr_version.h>
end_include

begin_include
include|#
directive|include
file|<apr_atomic.h>
end_include

begin_include
include|#
directive|include
file|"serf.h"
end_include

begin_include
include|#
directive|include
file|"serf_private.h"
end_include

begin_include
include|#
directive|include
file|"serf_bucket_util.h"
end_include

begin_include
include|#
directive|include
file|<openssl/bio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/pkcs12.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509v3.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|APR_VERSION_AT_LEAST
end_ifndef

begin_comment
comment|/* Introduced in APR 1.3.0 */
end_comment

begin_define
define|#
directive|define
name|APR_VERSION_AT_LEAST
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|,
name|patch
parameter_list|)
define|\
value|(((major)< APR_MAJOR_VERSION)                                        \       || ((major) == APR_MAJOR_VERSION&& (minor)< APR_MINOR_VERSION)    \       || ((major) == APR_MAJOR_VERSION&& (minor) == APR_MINOR_VERSION&& \                (patch)<= APR_PATCH_VERSION))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APR_VERSION_AT_LEAST */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|APR_ARRAY_PUSH
end_ifndef

begin_define
define|#
directive|define
name|APR_ARRAY_PUSH
parameter_list|(
name|ary
parameter_list|,
name|type
parameter_list|)
value|(*((type *)apr_array_push(ary)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Here's an overview of the SSL bucket's relationship to OpenSSL and serf.  *  * HTTP request:  SSLENCRYPT(REQUEST)  *   [context.c reads from SSLENCRYPT and writes out to the socket]  * HTTP response: RESPONSE(SSLDECRYPT(SOCKET))  *   [handler function reads from RESPONSE which in turn reads from SSLDECRYPT]  *  * HTTP request read call path:  *  * write_to_connection  *  |- serf_bucket_read on SSLENCRYPT  *    |- serf_ssl_read  *      |- serf_databuf_read  *        |- common_databuf_prep  *          |- ssl_encrypt  *            |- 1. Try to read pending encrypted data; If available, return.  *            |- 2. Try to read from ctx->stream [REQUEST bucket]  *            |- 3. Call SSL_write with read data  *              |- ...  *                |- bio_bucket_read can be called  *                |- bio_bucket_write with encrypted data  *                  |- store in sink  *            |- 4. If successful, read pending encrypted data and return.  *            |- 5. If fails, place read data back in ctx->stream  *  * HTTP response read call path:  *  * read_from_connection  *  |- acceptor  *  |- handler  *    |- ...  *      |- serf_bucket_read(SSLDECRYPT)  *        |- serf_ssl_read  *          |- serf_databuf_read  *            |- ssl_decrypt  *              |- 1. SSL_read() for pending decrypted data; if any, return.  *              |- 2. Try to read from ctx->stream [SOCKET bucket]  *              |- 3. Append data to ssl_ctx->source  *              |- 4. Call SSL_read()  *                |- ...  *                  |- bio_bucket_write can be called  *                  |- bio_bucket_read  *                    |- read data from ssl_ctx->source  *              |- If data read, return it.  *              |- If an error, set the STATUS value and return.  *  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|bucket_list
block|{
name|serf_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|struct
name|bucket_list
modifier|*
name|next
decl_stmt|;
block|}
name|bucket_list_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Helper to read data. Wraps stream. */
name|serf_databuf_t
name|databuf
decl_stmt|;
comment|/* Our source for more data. */
name|serf_bucket_t
modifier|*
name|stream
decl_stmt|;
comment|/* The next set of buckets */
name|bucket_list_t
modifier|*
name|stream_next
decl_stmt|;
comment|/* The status of the last thing we read. */
name|apr_status_t
name|status
decl_stmt|;
name|apr_status_t
name|exhausted
decl_stmt|;
name|int
name|exhausted_reset
decl_stmt|;
comment|/* Data we've read but not processed. */
name|serf_bucket_t
modifier|*
name|pending
decl_stmt|;
block|}
name|serf_ssl_stream_t
typedef|;
end_typedef

begin_struct
struct|struct
name|serf_ssl_context_t
block|{
comment|/* How many open buckets refer to this context. */
name|int
name|refcount
decl_stmt|;
comment|/* The pool that this context uses. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* The allocator associated with the above pool. */
name|serf_bucket_alloc_t
modifier|*
name|allocator
decl_stmt|;
comment|/* Internal OpenSSL parameters */
name|SSL_CTX
modifier|*
name|ctx
decl_stmt|;
name|SSL
modifier|*
name|ssl
decl_stmt|;
name|BIO
modifier|*
name|bio
decl_stmt|;
name|serf_ssl_stream_t
name|encrypt
decl_stmt|;
name|serf_ssl_stream_t
name|decrypt
decl_stmt|;
comment|/* Client cert callbacks */
name|serf_ssl_need_client_cert_t
name|cert_callback
decl_stmt|;
name|void
modifier|*
name|cert_userdata
decl_stmt|;
name|apr_pool_t
modifier|*
name|cert_cache_pool
decl_stmt|;
specifier|const
name|char
modifier|*
name|cert_file_success
decl_stmt|;
comment|/* Client cert PW callbacks */
name|serf_ssl_need_cert_password_t
name|cert_pw_callback
decl_stmt|;
name|void
modifier|*
name|cert_pw_userdata
decl_stmt|;
name|apr_pool_t
modifier|*
name|cert_pw_cache_pool
decl_stmt|;
specifier|const
name|char
modifier|*
name|cert_pw_success
decl_stmt|;
comment|/* Server cert callbacks */
name|serf_ssl_need_server_cert_t
name|server_cert_callback
decl_stmt|;
name|serf_ssl_server_cert_chain_cb_t
name|server_cert_chain_callback
decl_stmt|;
name|void
modifier|*
name|server_cert_userdata
decl_stmt|;
specifier|const
name|char
modifier|*
name|cert_path
decl_stmt|;
name|X509
modifier|*
name|cached_cert
decl_stmt|;
name|EVP_PKEY
modifier|*
name|cached_cert_pw
decl_stmt|;
name|apr_status_t
name|pending_err
decl_stmt|;
comment|/* Status of a fatal error, returned on subsequent encrypt or decrypt        requests. */
name|apr_status_t
name|fatal_err
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* The bucket-independent ssl context that this bucket is associated with */
name|serf_ssl_context_t
modifier|*
name|ssl_ctx
decl_stmt|;
comment|/* Pointer to the 'right' databuf. */
name|serf_databuf_t
modifier|*
name|databuf
decl_stmt|;
comment|/* Pointer to our stream, so we can find it later. */
name|serf_bucket_t
modifier|*
modifier|*
name|our_stream
decl_stmt|;
block|}
name|ssl_context_t
typedef|;
end_typedef

begin_struct
struct|struct
name|serf_ssl_certificate_t
block|{
name|X509
modifier|*
name|ssl_cert
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|disable_compression
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|ssl_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|SSL_VERBOSE
end_if

begin_comment
comment|/* Log all ssl alerts that we receive from the server. */
end_comment

begin_function
specifier|static
name|void
name|apps_ssl_info_callback
parameter_list|(
specifier|const
name|SSL
modifier|*
name|s
parameter_list|,
name|int
name|where
parameter_list|,
name|int
name|ret
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|w
decl_stmt|;
name|w
operator|=
name|where
operator|&
operator|~
name|SSL_ST_MASK
expr_stmt|;
if|if
condition|(
name|w
operator|&
name|SSL_ST_CONNECT
condition|)
name|str
operator|=
literal|"SSL_connect"
expr_stmt|;
elseif|else
if|if
condition|(
name|w
operator|&
name|SSL_ST_ACCEPT
condition|)
name|str
operator|=
literal|"SSL_accept"
expr_stmt|;
else|else
name|str
operator|=
literal|"undefined"
expr_stmt|;
if|if
condition|(
name|where
operator|&
name|SSL_CB_LOOP
condition|)
block|{
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"%s:%s\n"
argument_list|,
name|str
argument_list|,
name|SSL_state_string_long
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|where
operator|&
name|SSL_CB_ALERT
condition|)
block|{
name|str
operator|=
operator|(
name|where
operator|&
name|SSL_CB_READ
operator|)
condition|?
literal|"read"
else|:
literal|"write"
expr_stmt|;
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"SSL3 alert %s:%s:%s\n"
argument_list|,
name|str
argument_list|,
name|SSL_alert_type_string_long
argument_list|(
name|ret
argument_list|)
argument_list|,
name|SSL_alert_desc_string_long
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|where
operator|&
name|SSL_CB_EXIT
condition|)
block|{
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"%s:failed in %s\n"
argument_list|,
name|str
argument_list|,
name|SSL_state_string_long
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"%s:error in %s\n"
argument_list|,
name|str
argument_list|,
name|SSL_state_string_long
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Returns the amount read. */
end_comment

begin_function
specifier|static
name|int
name|bio_bucket_read
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
name|char
modifier|*
name|in
parameter_list|,
name|int
name|inlen
parameter_list|)
block|{
name|serf_ssl_context_t
modifier|*
name|ctx
init|=
name|bio
operator|->
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"bio_bucket_read called for %d bytes\n"
argument_list|,
name|inlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|encrypt
operator|.
name|status
operator|==
name|SERF_ERROR_WAIT_CONN
operator|&&
name|BIO_should_read
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
condition|)
block|{
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"bio_bucket_read waiting: (%d %d %d)\n"
argument_list|,
name|BIO_should_retry
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
argument_list|,
name|BIO_should_read
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
argument_list|,
name|BIO_get_retry_flags
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Falling back... */
name|ctx
operator|->
name|encrypt
operator|.
name|exhausted_reset
operator|=
literal|1
expr_stmt|;
name|BIO_clear_retry_flags
argument_list|(
name|bio
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|ctx
operator|->
name|decrypt
operator|.
name|pending
argument_list|,
name|inlen
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|decrypt
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"bio_bucket_read received %d bytes (%d)\n"
argument_list|,
name|len
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
comment|/* Oh suck. */
if|if
condition|(
name|len
condition|)
block|{
name|memcpy
argument_list|(
name|in
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|BIO_set_retry_read
argument_list|(
name|bio
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns the amount written. */
end_comment

begin_function
specifier|static
name|int
name|bio_bucket_write
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|int
name|inl
parameter_list|)
block|{
name|serf_ssl_context_t
modifier|*
name|ctx
init|=
name|bio
operator|->
name|ptr
decl_stmt|;
name|serf_bucket_t
modifier|*
name|tmp
decl_stmt|;
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"bio_bucket_write called for %d bytes\n"
argument_list|,
name|inl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|encrypt
operator|.
name|status
operator|==
name|SERF_ERROR_WAIT_CONN
operator|&&
operator|!
name|BIO_should_read
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
condition|)
block|{
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"bio_bucket_write waiting: (%d %d %d)\n"
argument_list|,
name|BIO_should_retry
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
argument_list|,
name|BIO_should_read
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
argument_list|,
name|BIO_get_retry_flags
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Falling back... */
name|ctx
operator|->
name|encrypt
operator|.
name|exhausted_reset
operator|=
literal|1
expr_stmt|;
name|BIO_clear_retry_flags
argument_list|(
name|bio
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|serf_bucket_simple_copy_create
argument_list|(
name|in
argument_list|,
name|inl
argument_list|,
name|ctx
operator|->
name|encrypt
operator|.
name|pending
operator|->
name|allocator
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|ctx
operator|->
name|encrypt
operator|.
name|pending
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
name|inl
return|;
block|}
end_function

begin_comment
comment|/* Returns the amount read. */
end_comment

begin_function
specifier|static
name|int
name|bio_file_read
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
name|char
modifier|*
name|in
parameter_list|,
name|int
name|inlen
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
init|=
name|bio
operator|->
name|ptr
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|BIO_clear_retry_flags
argument_list|(
name|bio
argument_list|)
expr_stmt|;
name|len
operator|=
name|inlen
expr_stmt|;
name|status
operator|=
name|apr_file_read
argument_list|(
name|file
argument_list|,
name|in
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
comment|/* Oh suck. */
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|BIO_set_retry_read
argument_list|(
name|bio
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|len
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns the amount written. */
end_comment

begin_function
specifier|static
name|int
name|bio_file_write
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|int
name|inl
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
init|=
name|bio
operator|->
name|ptr
decl_stmt|;
name|apr_size_t
name|nbytes
decl_stmt|;
name|BIO_clear_retry_flags
argument_list|(
name|bio
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|inl
expr_stmt|;
name|apr_file_write
argument_list|(
name|file
argument_list|,
name|in
argument_list|,
operator|&
name|nbytes
argument_list|)
expr_stmt|;
return|return
name|nbytes
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bio_file_gets
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
name|char
modifier|*
name|in
parameter_list|,
name|int
name|inlen
parameter_list|)
block|{
return|return
name|bio_file_read
argument_list|(
name|bio
argument_list|,
name|in
argument_list|,
name|inlen
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bio_bucket_create
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|)
block|{
name|bio
operator|->
name|shutdown
operator|=
literal|1
expr_stmt|;
name|bio
operator|->
name|init
operator|=
literal|1
expr_stmt|;
name|bio
operator|->
name|num
operator|=
operator|-
literal|1
expr_stmt|;
name|bio
operator|->
name|ptr
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bio_bucket_destroy
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|)
block|{
comment|/* Did we already free this? */
if|if
condition|(
name|bio
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|bio_bucket_ctrl
parameter_list|(
name|BIO
modifier|*
name|bio
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|num
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|long
name|ret
init|=
literal|1
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
comment|/* abort(); */
break|break;
case|case
name|BIO_CTRL_FLUSH
case|:
comment|/* At this point we can't force a flush. */
break|break;
case|case
name|BIO_CTRL_PUSH
case|:
case|case
name|BIO_CTRL_POP
case|:
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|BIO_METHOD
name|bio_bucket_method
init|=
block|{
name|BIO_TYPE_MEM
block|,
literal|"Serf SSL encryption and decryption buckets"
block|,
name|bio_bucket_write
block|,
name|bio_bucket_read
block|,
name|NULL
block|,
comment|/* Is this called? */
name|NULL
block|,
comment|/* Is this called? */
name|bio_bucket_ctrl
block|,
name|bio_bucket_create
block|,
name|bio_bucket_destroy
block|,
ifdef|#
directive|ifdef
name|OPENSSL_VERSION_NUMBER
name|NULL
comment|/* sslc does not have the callback_ctrl field */
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BIO_METHOD
name|bio_file_method
init|=
block|{
name|BIO_TYPE_FILE
block|,
literal|"Wrapper around APR file structures"
block|,
name|bio_file_write
block|,
name|bio_file_read
block|,
name|NULL
block|,
comment|/* Is this called? */
name|bio_file_gets
block|,
comment|/* Is this called? */
name|bio_bucket_ctrl
block|,
name|bio_bucket_create
block|,
name|bio_bucket_destroy
block|,
ifdef|#
directive|ifdef
name|OPENSSL_VERSION_NUMBER
name|NULL
comment|/* sslc does not have the callback_ctrl field */
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|validate_server_certificate
parameter_list|(
name|int
name|cert_valid
parameter_list|,
name|X509_STORE_CTX
modifier|*
name|store_ctx
parameter_list|)
block|{
name|SSL
modifier|*
name|ssl
decl_stmt|;
name|serf_ssl_context_t
modifier|*
name|ctx
decl_stmt|;
name|X509
modifier|*
name|server_cert
decl_stmt|;
name|int
name|err
decl_stmt|,
name|depth
decl_stmt|;
name|int
name|failures
init|=
literal|0
decl_stmt|;
name|ssl
operator|=
name|X509_STORE_CTX_get_ex_data
argument_list|(
name|store_ctx
argument_list|,
name|SSL_get_ex_data_X509_STORE_CTX_idx
argument_list|()
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|SSL_get_app_data
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|server_cert
operator|=
name|X509_STORE_CTX_get_current_cert
argument_list|(
name|store_ctx
argument_list|)
expr_stmt|;
name|depth
operator|=
name|X509_STORE_CTX_get_error_depth
argument_list|(
name|store_ctx
argument_list|)
expr_stmt|;
comment|/* If the certification was found invalid, get the error and convert it to        something our caller will understand. */
if|if
condition|(
operator|!
name|cert_valid
condition|)
block|{
name|err
operator|=
name|X509_STORE_CTX_get_error
argument_list|(
name|store_ctx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|X509_V_ERR_CERT_NOT_YET_VALID
case|:
name|failures
operator||=
name|SERF_SSL_CERT_NOTYETVALID
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_CERT_HAS_EXPIRED
case|:
name|failures
operator||=
name|SERF_SSL_CERT_EXPIRED
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT
case|:
case|case
name|X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN
case|:
name|failures
operator||=
name|SERF_SSL_CERT_SELF_SIGNED
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY
case|:
case|case
name|X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT
case|:
case|case
name|X509_V_ERR_CERT_UNTRUSTED
case|:
case|case
name|X509_V_ERR_INVALID_CA
case|:
name|failures
operator||=
name|SERF_SSL_CERT_UNKNOWNCA
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_CERT_REVOKED
case|:
name|failures
operator||=
name|SERF_SSL_CERT_REVOKED
expr_stmt|;
break|break;
default|default:
name|failures
operator||=
name|SERF_SSL_CERT_UNKNOWN_FAILURE
expr_stmt|;
break|break;
block|}
block|}
comment|/* Check certificate expiry dates. */
if|if
condition|(
name|X509_cmp_current_time
argument_list|(
name|X509_get_notBefore
argument_list|(
name|server_cert
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|failures
operator||=
name|SERF_SSL_CERT_NOTYETVALID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|X509_cmp_current_time
argument_list|(
name|X509_get_notAfter
argument_list|(
name|server_cert
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|failures
operator||=
name|SERF_SSL_CERT_EXPIRED
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|server_cert_callback
operator|&&
operator|(
name|depth
operator|==
literal|0
operator|||
name|failures
operator|)
condition|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|serf_ssl_certificate_t
modifier|*
name|cert
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|apr_pool_create
argument_list|(
operator|&
name|subpool
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
name|cert
operator|=
name|apr_palloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
name|serf_ssl_certificate_t
argument_list|)
argument_list|)
expr_stmt|;
name|cert
operator|->
name|ssl_cert
operator|=
name|server_cert
expr_stmt|;
name|cert
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
comment|/* Callback for further verification. */
name|status
operator|=
name|ctx
operator|->
name|server_cert_callback
argument_list|(
name|ctx
operator|->
name|server_cert_userdata
argument_list|,
name|failures
argument_list|,
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|APR_SUCCESS
condition|)
name|cert_valid
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* Even if openssl found the certificate valid, the application                told us to reject it. */
name|cert_valid
operator|=
literal|0
expr_stmt|;
comment|/* Pass the error back to the caller through the context-run. */
name|ctx
operator|->
name|pending_err
operator|=
name|status
expr_stmt|;
block|}
name|apr_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|server_cert_chain_callback
operator|&&
operator|(
name|depth
operator|==
literal|0
operator|||
name|failures
operator|)
condition|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|chain
expr_stmt|;
specifier|const
name|serf_ssl_certificate_t
modifier|*
modifier|*
name|certs
decl_stmt|;
name|int
name|certs_len
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|apr_pool_create
argument_list|(
operator|&
name|subpool
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* Borrow the chain to pass to the callback. */
name|chain
operator|=
name|X509_STORE_CTX_get_chain
argument_list|(
name|store_ctx
argument_list|)
expr_stmt|;
comment|/* If the chain can't be retrieved, just pass the current            certificate. */
comment|/* ### can this actually happen with _get_chain() ?  */
if|if
condition|(
operator|!
name|chain
condition|)
block|{
name|serf_ssl_certificate_t
modifier|*
name|cert
init|=
name|apr_palloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cert
argument_list|)
argument_list|)
decl_stmt|;
name|cert
operator|->
name|ssl_cert
operator|=
name|server_cert
expr_stmt|;
name|cert
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
comment|/* Room for the server_cert and a trailing NULL.  */
name|certs
operator|=
name|apr_palloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|certs
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|certs
index|[
literal|0
index|]
operator|=
name|cert
expr_stmt|;
name|certs_len
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|certs_len
operator|=
name|sk_X509_num
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* Room for all the certs and a trailing NULL.  */
name|certs
operator|=
name|apr_palloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|certs
argument_list|)
operator|*
operator|(
name|certs_len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|certs_len
condition|;
operator|++
name|i
control|)
block|{
name|serf_ssl_certificate_t
modifier|*
name|cert
decl_stmt|;
name|cert
operator|=
name|apr_palloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cert
argument_list|)
argument_list|)
expr_stmt|;
name|cert
operator|->
name|ssl_cert
operator|=
name|sk_X509_value
argument_list|(
name|chain
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cert
operator|->
name|depth
operator|=
name|i
expr_stmt|;
name|certs
index|[
name|i
index|]
operator|=
name|cert
expr_stmt|;
block|}
block|}
name|certs
index|[
name|certs_len
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Callback for further verification. */
name|status
operator|=
name|ctx
operator|->
name|server_cert_chain_callback
argument_list|(
name|ctx
operator|->
name|server_cert_userdata
argument_list|,
name|failures
argument_list|,
name|depth
argument_list|,
name|certs
argument_list|,
name|certs_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|APR_SUCCESS
condition|)
block|{
name|cert_valid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Even if openssl found the certificate valid, the application                told us to reject it. */
name|cert_valid
operator|=
literal|0
expr_stmt|;
comment|/* Pass the error back to the caller through the context-run. */
name|ctx
operator|->
name|pending_err
operator|=
name|status
expr_stmt|;
block|}
name|apr_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
return|return
name|cert_valid
return|;
block|}
end_function

begin_comment
comment|/* This function reads an encrypted stream and returns the decrypted stream. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|ssl_decrypt
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_size_t
name|bufsize
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|serf_ssl_context_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
name|apr_size_t
name|priv_len
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|ssl_len
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|fatal_err
condition|)
return|return
name|ctx
operator|->
name|fatal_err
return|;
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"ssl_decrypt: begin %d\n"
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
comment|/* Is there some data waiting to be read? */
name|ssl_len
operator|=
name|SSL_read
argument_list|(
name|ctx
operator|->
name|ssl
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl_len
operator|>
literal|0
condition|)
block|{
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"ssl_decrypt: %d bytes (%d); status: %d; flags: %d\n"
argument_list|,
name|ssl_len
argument_list|,
name|bufsize
argument_list|,
name|ctx
operator|->
name|decrypt
operator|.
name|status
argument_list|,
name|BIO_get_retry_flags
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|ssl_len
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|ctx
operator|->
name|decrypt
operator|.
name|stream
argument_list|,
name|bufsize
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|priv_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
operator|&&
name|priv_len
condition|)
block|{
name|serf_bucket_t
modifier|*
name|tmp
decl_stmt|;
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"ssl_decrypt: read %d bytes (%d); status: %d\n"
argument_list|,
name|priv_len
argument_list|,
name|bufsize
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|serf_bucket_simple_copy_create
argument_list|(
name|data
argument_list|,
name|priv_len
argument_list|,
name|ctx
operator|->
name|decrypt
operator|.
name|pending
operator|->
name|allocator
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|ctx
operator|->
name|decrypt
operator|.
name|pending
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ssl_len
operator|=
name|SSL_read
argument_list|(
name|ctx
operator|->
name|ssl
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl_len
operator|<
literal|0
condition|)
block|{
name|int
name|ssl_err
decl_stmt|;
name|ssl_err
operator|=
name|SSL_get_error
argument_list|(
name|ctx
operator|->
name|ssl
argument_list|,
name|ssl_len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ssl_err
condition|)
block|{
case|case
name|SSL_ERROR_SYSCALL
case|:
operator|*
name|len
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|ctx
operator|->
name|decrypt
operator|.
name|status
expr_stmt|;
break|break;
case|case
name|SSL_ERROR_WANT_READ
case|:
operator|*
name|len
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|APR_EAGAIN
expr_stmt|;
break|break;
case|case
name|SSL_ERROR_SSL
case|:
operator|*
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|pending_err
condition|)
block|{
name|status
operator|=
name|ctx
operator|->
name|pending_err
expr_stmt|;
name|ctx
operator|->
name|pending_err
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|fatal_err
operator|=
name|status
operator|=
name|SERF_ERROR_SSL_COMM_FAILED
expr_stmt|;
block|}
break|break;
default|default:
operator|*
name|len
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|fatal_err
operator|=
name|status
operator|=
name|SERF_ERROR_SSL_COMM_FAILED
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|ssl_len
operator|==
literal|0
condition|)
block|{
comment|/* The server shut down the connection. */
name|int
name|ssl_err
decl_stmt|,
name|shutdown
decl_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
comment|/* Check for SSL_RECEIVED_SHUTDOWN */
name|shutdown
operator|=
name|SSL_get_shutdown
argument_list|(
name|ctx
operator|->
name|ssl
argument_list|)
expr_stmt|;
comment|/* Check for SSL_ERROR_ZERO_RETURN */
name|ssl_err
operator|=
name|SSL_get_error
argument_list|(
name|ctx
operator|->
name|ssl
argument_list|,
name|ssl_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|shutdown
operator|==
name|SSL_RECEIVED_SHUTDOWN
operator|&&
name|ssl_err
operator|==
name|SSL_ERROR_ZERO_RETURN
condition|)
block|{
comment|/* The server closed the SSL session. While this doesn't                 necessary mean the connection is closed, let's close                 it here anyway.                 We can optimize this later. */
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"ssl_decrypt: SSL read error: server"
literal|" shut down connection!\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|APR_EOF
expr_stmt|;
block|}
else|else
block|{
comment|/* A fatal error occurred. */
name|ctx
operator|->
name|fatal_err
operator|=
name|status
operator|=
name|SERF_ERROR_SSL_COMM_FAILED
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|len
operator|=
name|ssl_len
expr_stmt|;
name|serf__log
argument_list|(
name|SSL_MSG_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"---\n%.*s\n-(%d)-\n"
argument_list|,
operator|*
name|len
argument_list|,
name|buf
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
block|}
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"ssl_decrypt: %d %d %d\n"
argument_list|,
name|status
argument_list|,
operator|*
name|len
argument_list|,
name|BIO_get_retry_flags
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* This function reads a decrypted stream and returns an encrypted stream. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|ssl_encrypt
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_size_t
name|bufsize
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|interim_bufsize
decl_stmt|;
name|serf_ssl_context_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|fatal_err
condition|)
return|return
name|ctx
operator|->
name|fatal_err
return|;
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"ssl_encrypt: begin %d\n"
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
comment|/* Try to read already encrypted but unread data first. */
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|ctx
operator|->
name|encrypt
operator|.
name|pending
argument_list|,
name|bufsize
argument_list|,
operator|&
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|status
return|;
block|}
comment|/* Aha, we read something.  Return that now. */
if|if
condition|(
operator|*
name|len
condition|)
block|{
name|memcpy
argument_list|(
name|buf
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
block|}
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"ssl_encrypt: %d %d %d (quick read)\n"
argument_list|,
name|status
argument_list|,
operator|*
name|len
argument_list|,
name|BIO_get_retry_flags
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
if|if
condition|(
name|BIO_should_retry
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
operator|&&
name|BIO_should_write
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
condition|)
block|{
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"ssl_encrypt: %d %d %d (should write exit)\n"
argument_list|,
name|status
argument_list|,
operator|*
name|len
argument_list|,
name|BIO_get_retry_flags
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|APR_EAGAIN
return|;
block|}
comment|/* If we were previously blocked, unblock ourselves now. */
if|if
condition|(
name|BIO_should_read
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
condition|)
block|{
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"ssl_encrypt: reset %d %d (%d %d %d)\n"
argument_list|,
name|status
argument_list|,
name|ctx
operator|->
name|encrypt
operator|.
name|status
argument_list|,
name|BIO_should_retry
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
argument_list|,
name|BIO_should_read
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
argument_list|,
name|BIO_get_retry_flags
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|encrypt
operator|.
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
name|ctx
operator|->
name|encrypt
operator|.
name|exhausted_reset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Oh well, read from our stream now. */
name|interim_bufsize
operator|=
name|bufsize
expr_stmt|;
do|do
block|{
name|apr_size_t
name|interim_len
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|encrypt
operator|.
name|status
condition|)
block|{
name|struct
name|iovec
name|vecs
index|[
literal|64
index|]
decl_stmt|;
name|int
name|vecs_read
decl_stmt|;
name|status
operator|=
name|serf_bucket_read_iovec
argument_list|(
name|ctx
operator|->
name|encrypt
operator|.
name|stream
argument_list|,
name|interim_bufsize
argument_list|,
literal|64
argument_list|,
name|vecs
argument_list|,
operator|&
name|vecs_read
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
operator|&&
name|vecs_read
condition|)
block|{
name|char
modifier|*
name|vecs_data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cur
decl_stmt|,
name|vecs_data_len
decl_stmt|;
name|int
name|ssl_len
decl_stmt|;
comment|/* Combine the buffers of the iovec into one buffer, as                    that is with SSL_write requires. */
name|vecs_data_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vecs_read
condition|;
name|i
operator|++
control|)
block|{
name|vecs_data_len
operator|+=
name|vecs
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
name|vecs_data
operator|=
name|serf_bucket_mem_alloc
argument_list|(
name|ctx
operator|->
name|allocator
argument_list|,
name|vecs_data_len
argument_list|)
expr_stmt|;
name|cur
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vecs_read
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|vecs_data
operator|+
name|cur
argument_list|,
name|vecs
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|vecs
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|cur
operator|+=
name|vecs
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
name|interim_bufsize
operator|-=
name|vecs_data_len
expr_stmt|;
name|interim_len
operator|=
name|vecs_data_len
expr_stmt|;
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"ssl_encrypt: bucket read %d bytes; "
expr|\
literal|"status %d\n"
argument_list|,
name|interim_len
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|serf__log
argument_list|(
name|SSL_MSG_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"---\n%.*s\n-(%d)-\n"
argument_list|,
name|interim_len
argument_list|,
name|vecs_data
argument_list|,
name|interim_len
argument_list|)
expr_stmt|;
comment|/* Stash our status away. */
name|ctx
operator|->
name|encrypt
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|ssl_len
operator|=
name|SSL_write
argument_list|(
name|ctx
operator|->
name|ssl
argument_list|,
name|vecs_data
argument_list|,
name|interim_len
argument_list|)
expr_stmt|;
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"ssl_encrypt: SSL write: %d\n"
argument_list|,
name|ssl_len
argument_list|)
expr_stmt|;
comment|/* We're done. */
name|serf_bucket_mem_free
argument_list|(
name|ctx
operator|->
name|allocator
argument_list|,
name|vecs_data
argument_list|)
expr_stmt|;
comment|/* If we failed to write... */
if|if
condition|(
name|ssl_len
operator|<
literal|0
condition|)
block|{
name|int
name|ssl_err
decl_stmt|;
comment|/* Ah, bugger. We need to put that data back. */
name|serf_bucket_aggregate_prepend_iovec
argument_list|(
name|ctx
operator|->
name|encrypt
operator|.
name|stream
argument_list|,
name|vecs
argument_list|,
name|vecs_read
argument_list|)
expr_stmt|;
name|ssl_err
operator|=
name|SSL_get_error
argument_list|(
name|ctx
operator|->
name|ssl
argument_list|,
name|ssl_len
argument_list|)
expr_stmt|;
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"ssl_encrypt: SSL write error: %d\n"
argument_list|,
name|ssl_err
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl_err
operator|==
name|SSL_ERROR_SYSCALL
condition|)
block|{
name|status
operator|=
name|ctx
operator|->
name|encrypt
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|status
return|;
block|}
block|}
else|else
block|{
comment|/* Oh, no. */
if|if
condition|(
name|ssl_err
operator|==
name|SSL_ERROR_WANT_READ
condition|)
block|{
name|status
operator|=
name|SERF_ERROR_WAIT_CONN
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|fatal_err
operator|=
name|status
operator|=
name|SERF_ERROR_SSL_COMM_FAILED
expr_stmt|;
block|}
block|}
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"ssl_encrypt: SSL write error: %d %d\n"
argument_list|,
name|status
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|interim_len
operator|=
literal|0
expr_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|ctx
operator|->
name|encrypt
operator|.
name|status
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|status
operator|&&
name|interim_bufsize
condition|)
do|;
comment|/* Okay, we exhausted our underlying stream. */
if|if
condition|(
operator|!
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|apr_status_t
name|agg_status
decl_stmt|;
name|struct
name|iovec
name|vecs
index|[
literal|64
index|]
decl_stmt|;
name|int
name|vecs_read
decl_stmt|,
name|i
decl_stmt|;
comment|/* We read something! */
name|agg_status
operator|=
name|serf_bucket_read_iovec
argument_list|(
name|ctx
operator|->
name|encrypt
operator|.
name|pending
argument_list|,
name|bufsize
argument_list|,
literal|64
argument_list|,
name|vecs
argument_list|,
operator|&
name|vecs_read
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vecs_read
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|buf
operator|+
operator|*
name|len
argument_list|,
name|vecs
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|vecs
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
operator|*
name|len
operator|+=
name|vecs
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"ssl_encrypt read agg: %d %d %d %d\n"
argument_list|,
name|status
argument_list|,
name|agg_status
argument_list|,
name|ctx
operator|->
name|encrypt
operator|.
name|status
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|agg_status
condition|)
block|{
name|status
operator|=
name|agg_status
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|SERF_ERROR_WAIT_CONN
operator|&&
name|BIO_should_retry
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
operator|&&
name|BIO_should_read
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
condition|)
block|{
name|ctx
operator|->
name|encrypt
operator|.
name|exhausted
operator|=
name|ctx
operator|->
name|encrypt
operator|.
name|status
expr_stmt|;
name|ctx
operator|->
name|encrypt
operator|.
name|status
operator|=
name|SERF_ERROR_WAIT_CONN
expr_stmt|;
block|}
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"ssl_encrypt finished: %d %d (%d %d %d)\n"
argument_list|,
name|status
argument_list|,
operator|*
name|len
argument_list|,
name|BIO_should_retry
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
argument_list|,
name|BIO_should_read
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
argument_list|,
name|BIO_get_retry_flags
argument_list|(
name|ctx
operator|->
name|bio
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_if
if|#
directive|if
name|APR_HAS_THREADS
end_if

begin_decl_stmt
specifier|static
name|apr_pool_t
modifier|*
name|ssl_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|apr_thread_mutex_t
modifier|*
modifier|*
name|ssl_locks
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|CRYPTO_dynlock_value
block|{
name|apr_thread_mutex_t
modifier|*
name|lock
decl_stmt|;
block|}
name|CRYPTO_dynlock_value
typedef|;
end_typedef

begin_function
specifier|static
name|CRYPTO_dynlock_value
modifier|*
name|ssl_dyn_create
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|CRYPTO_dynlock_value
modifier|*
name|l
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|l
operator|=
name|apr_palloc
argument_list|(
name|ssl_pool
argument_list|,
sizeof|sizeof
argument_list|(
name|CRYPTO_dynlock_value
argument_list|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_thread_mutex_create
argument_list|(
operator|&
name|l
operator|->
name|lock
argument_list|,
name|APR_THREAD_MUTEX_DEFAULT
argument_list|,
name|ssl_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
comment|/* FIXME: return error here */
block|}
return|return
name|l
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ssl_dyn_lock
parameter_list|(
name|int
name|mode
parameter_list|,
name|CRYPTO_dynlock_value
modifier|*
name|l
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|&
name|CRYPTO_LOCK
condition|)
block|{
name|apr_thread_mutex_lock
argument_list|(
name|l
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|&
name|CRYPTO_UNLOCK
condition|)
block|{
name|apr_thread_mutex_unlock
argument_list|(
name|l
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ssl_dyn_destroy
parameter_list|(
name|CRYPTO_dynlock_value
modifier|*
name|l
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|apr_thread_mutex_destroy
argument_list|(
name|l
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ssl_lock
parameter_list|(
name|int
name|mode
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|&
name|CRYPTO_LOCK
condition|)
block|{
name|apr_thread_mutex_lock
argument_list|(
name|ssl_locks
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|&
name|CRYPTO_UNLOCK
condition|)
block|{
name|apr_thread_mutex_unlock
argument_list|(
name|ssl_locks
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|ssl_id
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* FIXME: This is lame and not portable. -aaron */
return|return
operator|(
name|unsigned
name|long
operator|)
name|apr_os_thread_current
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|cleanup_ssl
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|CRYPTO_set_locking_callback
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|CRYPTO_set_id_callback
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|CRYPTO_set_dynlock_create_callback
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|CRYPTO_set_dynlock_lock_callback
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|CRYPTO_set_dynlock_destroy_callback
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|apr_uint32_t
name|have_init_ssl
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_ssl_libraries
parameter_list|(
name|void
parameter_list|)
block|{
name|apr_uint32_t
name|val
decl_stmt|;
if|#
directive|if
name|APR_VERSION_AT_LEAST
argument_list|(
literal|1
operator|,
literal|0
operator|,
literal|0
argument_list|)
name|val
operator|=
name|apr_atomic_xchg32
argument_list|(
operator|&
name|have_init_ssl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|val
operator|=
name|apr_atomic_cas
argument_list|(
operator|&
name|have_init_ssl
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|val
condition|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
name|int
name|i
decl_stmt|,
name|numlocks
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SSL_VERBOSE
comment|/* Warn when compile-time and run-time version of OpenSSL differ in            major/minor version number. */
name|long
name|libver
init|=
name|SSLeay
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|libver
operator|^
name|OPENSSL_VERSION_NUMBER
operator|)
operator|&
literal|0xFFF00000
condition|)
block|{
name|serf__log
argument_list|(
name|SSL_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
literal|"Warning: OpenSSL library version mismatch, compile-time "
literal|"was %lx, runtime is %lx.\n"
argument_list|,
name|OPENSSL_VERSION_NUMBER
argument_list|,
name|libver
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CRYPTO_malloc_init
argument_list|()
expr_stmt|;
name|ERR_load_crypto_strings
argument_list|()
expr_stmt|;
name|SSL_load_error_strings
argument_list|()
expr_stmt|;
name|SSL_library_init
argument_list|()
expr_stmt|;
name|OpenSSL_add_all_algorithms
argument_list|()
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|numlocks
operator|=
name|CRYPTO_num_locks
argument_list|()
expr_stmt|;
name|apr_pool_create
argument_list|(
operator|&
name|ssl_pool
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ssl_locks
operator|=
name|apr_palloc
argument_list|(
name|ssl_pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_thread_mutex_t
operator|*
argument_list|)
operator|*
name|numlocks
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numlocks
condition|;
name|i
operator|++
control|)
block|{
name|apr_status_t
name|rv
decl_stmt|;
comment|/* Intraprocess locks don't /need/ a filename... */
name|rv
operator|=
name|apr_thread_mutex_create
argument_list|(
operator|&
name|ssl_locks
index|[
name|i
index|]
argument_list|,
name|APR_THREAD_MUTEX_DEFAULT
argument_list|,
name|ssl_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
comment|/* FIXME: error out here */
block|}
block|}
name|CRYPTO_set_locking_callback
argument_list|(
name|ssl_lock
argument_list|)
expr_stmt|;
name|CRYPTO_set_id_callback
argument_list|(
name|ssl_id
argument_list|)
expr_stmt|;
name|CRYPTO_set_dynlock_create_callback
argument_list|(
name|ssl_dyn_create
argument_list|)
expr_stmt|;
name|CRYPTO_set_dynlock_lock_callback
argument_list|(
name|ssl_dyn_lock
argument_list|)
expr_stmt|;
name|CRYPTO_set_dynlock_destroy_callback
argument_list|(
name|ssl_dyn_destroy
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|ssl_pool
argument_list|,
name|NULL
argument_list|,
name|cleanup_ssl
argument_list|,
name|cleanup_ssl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ssl_need_client_cert
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|X509
modifier|*
modifier|*
name|cert
parameter_list|,
name|EVP_PKEY
modifier|*
modifier|*
name|pkey
parameter_list|)
block|{
name|serf_ssl_context_t
modifier|*
name|ctx
init|=
name|SSL_get_app_data
argument_list|(
name|ssl
argument_list|)
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|cached_cert
condition|)
block|{
operator|*
name|cert
operator|=
name|ctx
operator|->
name|cached_cert
expr_stmt|;
operator|*
name|pkey
operator|=
name|ctx
operator|->
name|cached_cert_pw
expr_stmt|;
return|return
literal|1
return|;
block|}
while|while
condition|(
name|ctx
operator|->
name|cert_callback
condition|)
block|{
specifier|const
name|char
modifier|*
name|cert_path
decl_stmt|;
name|apr_file_t
modifier|*
name|cert_file
decl_stmt|;
name|BIO
modifier|*
name|bio
decl_stmt|;
name|PKCS12
modifier|*
name|p12
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|retrying_success
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|cert_file_success
condition|)
block|{
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
name|cert_path
operator|=
name|ctx
operator|->
name|cert_file_success
expr_stmt|;
name|ctx
operator|->
name|cert_file_success
operator|=
name|NULL
expr_stmt|;
name|retrying_success
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|ctx
operator|->
name|cert_callback
argument_list|(
name|ctx
operator|->
name|cert_userdata
argument_list|,
operator|&
name|cert_path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|||
operator|!
name|cert_path
condition|)
block|{
break|break;
block|}
comment|/* Load the x.509 cert file stored in PKCS12 */
name|status
operator|=
name|apr_file_open
argument_list|(
operator|&
name|cert_file
argument_list|,
name|cert_path
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
continue|continue;
block|}
name|bio
operator|=
name|BIO_new
argument_list|(
operator|&
name|bio_file_method
argument_list|)
expr_stmt|;
name|bio
operator|->
name|ptr
operator|=
name|cert_file
expr_stmt|;
name|ctx
operator|->
name|cert_path
operator|=
name|cert_path
expr_stmt|;
name|p12
operator|=
name|d2i_PKCS12_bio
argument_list|(
name|bio
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|apr_file_close
argument_list|(
name|cert_file
argument_list|)
expr_stmt|;
name|i
operator|=
name|PKCS12_parse
argument_list|(
name|p12
argument_list|,
name|NULL
argument_list|,
name|pkey
argument_list|,
name|cert
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|PKCS12_free
argument_list|(
name|p12
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|cached_cert
operator|=
operator|*
name|cert
expr_stmt|;
name|ctx
operator|->
name|cached_cert_pw
operator|=
operator|*
name|pkey
expr_stmt|;
if|if
condition|(
operator|!
name|retrying_success
operator|&&
name|ctx
operator|->
name|cert_cache_pool
condition|)
block|{
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|apr_pstrdup
argument_list|(
name|ctx
operator|->
name|cert_cache_pool
argument_list|,
name|ctx
operator|->
name|cert_path
argument_list|)
expr_stmt|;
name|apr_pool_userdata_setn
argument_list|(
name|c
argument_list|,
literal|"serf:ssl:cert"
argument_list|,
name|apr_pool_cleanup_null
argument_list|,
name|ctx
operator|->
name|cert_cache_pool
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
else|else
block|{
name|int
name|err
init|=
name|ERR_get_error
argument_list|()
decl_stmt|;
name|ERR_clear_error
argument_list|()
expr_stmt|;
if|if
condition|(
name|ERR_GET_LIB
argument_list|(
name|err
argument_list|)
operator|==
name|ERR_LIB_PKCS12
operator|&&
name|ERR_GET_REASON
argument_list|(
name|err
argument_list|)
operator|==
name|PKCS12_R_MAC_VERIFY_FAILURE
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|cert_pw_callback
condition|)
block|{
specifier|const
name|char
modifier|*
name|password
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|cert_pw_success
condition|)
block|{
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
name|password
operator|=
name|ctx
operator|->
name|cert_pw_success
expr_stmt|;
name|ctx
operator|->
name|cert_pw_success
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|ctx
operator|->
name|cert_pw_callback
argument_list|(
name|ctx
operator|->
name|cert_pw_userdata
argument_list|,
name|ctx
operator|->
name|cert_path
argument_list|,
operator|&
name|password
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|status
operator|&&
name|password
condition|)
block|{
name|i
operator|=
name|PKCS12_parse
argument_list|(
name|p12
argument_list|,
name|password
argument_list|,
name|pkey
argument_list|,
name|cert
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|PKCS12_free
argument_list|(
name|p12
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|cached_cert
operator|=
operator|*
name|cert
expr_stmt|;
name|ctx
operator|->
name|cached_cert_pw
operator|=
operator|*
name|pkey
expr_stmt|;
if|if
condition|(
operator|!
name|retrying_success
operator|&&
name|ctx
operator|->
name|cert_cache_pool
condition|)
block|{
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|apr_pstrdup
argument_list|(
name|ctx
operator|->
name|cert_cache_pool
argument_list|,
name|ctx
operator|->
name|cert_path
argument_list|)
expr_stmt|;
name|apr_pool_userdata_setn
argument_list|(
name|c
argument_list|,
literal|"serf:ssl:cert"
argument_list|,
name|apr_pool_cleanup_null
argument_list|,
name|ctx
operator|->
name|cert_cache_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|retrying_success
operator|&&
name|ctx
operator|->
name|cert_pw_cache_pool
condition|)
block|{
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|apr_pstrdup
argument_list|(
name|ctx
operator|->
name|cert_pw_cache_pool
argument_list|,
name|password
argument_list|)
expr_stmt|;
name|apr_pool_userdata_setn
argument_list|(
name|c
argument_list|,
literal|"serf:ssl:certpw"
argument_list|,
name|apr_pool_cleanup_null
argument_list|,
name|ctx
operator|->
name|cert_pw_cache_pool
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
block|}
name|PKCS12_free
argument_list|(
name|p12
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"OpenSSL cert error: %d %d %d\n"
argument_list|,
name|ERR_GET_LIB
argument_list|(
name|err
argument_list|)
argument_list|,
name|ERR_GET_FUNC
argument_list|(
name|err
argument_list|)
argument_list|,
name|ERR_GET_REASON
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|PKCS12_free
argument_list|(
name|p12
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|serf_ssl_client_cert_provider_set
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|context
parameter_list|,
name|serf_ssl_need_client_cert_t
name|callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|cache_pool
parameter_list|)
block|{
name|context
operator|->
name|cert_callback
operator|=
name|callback
expr_stmt|;
name|context
operator|->
name|cert_userdata
operator|=
name|data
expr_stmt|;
name|context
operator|->
name|cert_cache_pool
operator|=
name|cache_pool
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|cert_cache_pool
condition|)
block|{
name|apr_pool_userdata_get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|context
operator|->
name|cert_file_success
argument_list|,
literal|"serf:ssl:cert"
argument_list|,
name|cache_pool
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|serf_ssl_client_cert_password_set
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|context
parameter_list|,
name|serf_ssl_need_cert_password_t
name|callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|cache_pool
parameter_list|)
block|{
name|context
operator|->
name|cert_pw_callback
operator|=
name|callback
expr_stmt|;
name|context
operator|->
name|cert_pw_userdata
operator|=
name|data
expr_stmt|;
name|context
operator|->
name|cert_pw_cache_pool
operator|=
name|cache_pool
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|cert_pw_cache_pool
condition|)
block|{
name|apr_pool_userdata_get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|context
operator|->
name|cert_pw_success
argument_list|,
literal|"serf:ssl:certpw"
argument_list|,
name|cache_pool
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|serf_ssl_server_cert_callback_set
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|context
parameter_list|,
name|serf_ssl_need_server_cert_t
name|callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|context
operator|->
name|server_cert_callback
operator|=
name|callback
expr_stmt|;
name|context
operator|->
name|server_cert_userdata
operator|=
name|data
expr_stmt|;
block|}
end_function

begin_function
name|void
name|serf_ssl_server_cert_chain_callback_set
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|context
parameter_list|,
name|serf_ssl_need_server_cert_t
name|cert_callback
parameter_list|,
name|serf_ssl_server_cert_chain_cb_t
name|cert_chain_callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|context
operator|->
name|server_cert_callback
operator|=
name|cert_callback
expr_stmt|;
name|context
operator|->
name|server_cert_chain_callback
operator|=
name|cert_chain_callback
expr_stmt|;
name|context
operator|->
name|server_cert_userdata
operator|=
name|data
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|serf_ssl_context_t
modifier|*
name|ssl_init_context
parameter_list|(
name|void
parameter_list|)
block|{
name|serf_ssl_context_t
modifier|*
name|ssl_ctx
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|serf_bucket_alloc_t
modifier|*
name|allocator
decl_stmt|;
name|init_ssl_libraries
argument_list|()
expr_stmt|;
name|apr_pool_create
argument_list|(
operator|&
name|pool
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|allocator
operator|=
name|serf_bucket_allocator_create
argument_list|(
name|pool
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ssl_ctx
operator|=
name|serf_bucket_mem_alloc
argument_list|(
name|allocator
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ssl_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|ssl_ctx
operator|->
name|refcount
operator|=
literal|0
expr_stmt|;
name|ssl_ctx
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|ssl_ctx
operator|->
name|allocator
operator|=
name|allocator
expr_stmt|;
name|ssl_ctx
operator|->
name|ctx
operator|=
name|SSL_CTX_new
argument_list|(
name|SSLv23_client_method
argument_list|()
argument_list|)
expr_stmt|;
name|SSL_CTX_set_client_cert_cb
argument_list|(
name|ssl_ctx
operator|->
name|ctx
argument_list|,
name|ssl_need_client_cert
argument_list|)
expr_stmt|;
name|ssl_ctx
operator|->
name|cached_cert
operator|=
literal|0
expr_stmt|;
name|ssl_ctx
operator|->
name|cached_cert_pw
operator|=
literal|0
expr_stmt|;
name|ssl_ctx
operator|->
name|pending_err
operator|=
name|APR_SUCCESS
expr_stmt|;
name|ssl_ctx
operator|->
name|fatal_err
operator|=
name|APR_SUCCESS
expr_stmt|;
name|ssl_ctx
operator|->
name|cert_callback
operator|=
name|NULL
expr_stmt|;
name|ssl_ctx
operator|->
name|cert_pw_callback
operator|=
name|NULL
expr_stmt|;
name|ssl_ctx
operator|->
name|server_cert_callback
operator|=
name|NULL
expr_stmt|;
name|ssl_ctx
operator|->
name|server_cert_chain_callback
operator|=
name|NULL
expr_stmt|;
name|SSL_CTX_set_verify
argument_list|(
name|ssl_ctx
operator|->
name|ctx
argument_list|,
name|SSL_VERIFY_PEER
argument_list|,
name|validate_server_certificate
argument_list|)
expr_stmt|;
name|SSL_CTX_set_options
argument_list|(
name|ssl_ctx
operator|->
name|ctx
argument_list|,
name|SSL_OP_ALL
argument_list|)
expr_stmt|;
comment|/* Disable SSL compression by default. */
name|disable_compression
argument_list|(
name|ssl_ctx
argument_list|)
expr_stmt|;
name|ssl_ctx
operator|->
name|ssl
operator|=
name|SSL_new
argument_list|(
name|ssl_ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|ssl_ctx
operator|->
name|bio
operator|=
name|BIO_new
argument_list|(
operator|&
name|bio_bucket_method
argument_list|)
expr_stmt|;
name|ssl_ctx
operator|->
name|bio
operator|->
name|ptr
operator|=
name|ssl_ctx
expr_stmt|;
name|SSL_set_bio
argument_list|(
name|ssl_ctx
operator|->
name|ssl
argument_list|,
name|ssl_ctx
operator|->
name|bio
argument_list|,
name|ssl_ctx
operator|->
name|bio
argument_list|)
expr_stmt|;
name|SSL_set_connect_state
argument_list|(
name|ssl_ctx
operator|->
name|ssl
argument_list|)
expr_stmt|;
name|SSL_set_app_data
argument_list|(
name|ssl_ctx
operator|->
name|ssl
argument_list|,
name|ssl_ctx
argument_list|)
expr_stmt|;
if|#
directive|if
name|SSL_VERBOSE
name|SSL_CTX_set_info_callback
argument_list|(
name|ssl_ctx
operator|->
name|ctx
argument_list|,
name|apps_ssl_info_callback
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|stream
operator|=
name|NULL
expr_stmt|;
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|stream_next
operator|=
name|NULL
expr_stmt|;
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|pending
operator|=
name|serf_bucket_aggregate_create
argument_list|(
name|allocator
argument_list|)
expr_stmt|;
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
name|serf_databuf_init
argument_list|(
operator|&
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|databuf
argument_list|)
expr_stmt|;
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|databuf
operator|.
name|read
operator|=
name|ssl_encrypt
expr_stmt|;
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|databuf
operator|.
name|read_baton
operator|=
name|ssl_ctx
expr_stmt|;
name|ssl_ctx
operator|->
name|decrypt
operator|.
name|stream
operator|=
name|NULL
expr_stmt|;
name|ssl_ctx
operator|->
name|decrypt
operator|.
name|pending
operator|=
name|serf_bucket_aggregate_create
argument_list|(
name|allocator
argument_list|)
expr_stmt|;
name|ssl_ctx
operator|->
name|decrypt
operator|.
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
name|serf_databuf_init
argument_list|(
operator|&
name|ssl_ctx
operator|->
name|decrypt
operator|.
name|databuf
argument_list|)
expr_stmt|;
name|ssl_ctx
operator|->
name|decrypt
operator|.
name|databuf
operator|.
name|read
operator|=
name|ssl_decrypt
expr_stmt|;
name|ssl_ctx
operator|->
name|decrypt
operator|.
name|databuf
operator|.
name|read_baton
operator|=
name|ssl_ctx
expr_stmt|;
return|return
name|ssl_ctx
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|ssl_free_context
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|ssl_ctx
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|p
decl_stmt|;
comment|/* If never had the pending buckets, don't try to free them. */
if|if
condition|(
name|ssl_ctx
operator|->
name|decrypt
operator|.
name|pending
operator|!=
name|NULL
condition|)
block|{
name|serf_bucket_destroy
argument_list|(
name|ssl_ctx
operator|->
name|decrypt
operator|.
name|pending
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|pending
operator|!=
name|NULL
condition|)
block|{
name|serf_bucket_destroy
argument_list|(
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|pending
argument_list|)
expr_stmt|;
block|}
comment|/* SSL_free implicitly frees the underlying BIO. */
name|SSL_free
argument_list|(
name|ssl_ctx
operator|->
name|ssl
argument_list|)
expr_stmt|;
name|SSL_CTX_free
argument_list|(
name|ssl_ctx
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|p
operator|=
name|ssl_ctx
operator|->
name|pool
expr_stmt|;
name|serf_bucket_mem_free
argument_list|(
name|ssl_ctx
operator|->
name|allocator
argument_list|,
name|ssl_ctx
argument_list|)
expr_stmt|;
name|apr_pool_destroy
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|serf_bucket_t
modifier|*
name|serf_bucket_ssl_create
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|ssl_ctx
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
specifier|const
name|serf_bucket_type_t
modifier|*
name|type
parameter_list|)
block|{
name|ssl_context_t
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|serf_bucket_mem_alloc
argument_list|(
name|allocator
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl_ctx
condition|)
block|{
name|ctx
operator|->
name|ssl_ctx
operator|=
name|ssl_init_context
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|ssl_ctx
operator|=
name|ssl_ctx
expr_stmt|;
block|}
name|ctx
operator|->
name|ssl_ctx
operator|->
name|refcount
operator|++
expr_stmt|;
return|return
name|serf_bucket_create
argument_list|(
name|type
argument_list|,
name|allocator
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf_ssl_set_hostname
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SSL_set_tlsext_host_name
if|if
condition|(
name|SSL_set_tlsext_host_name
argument_list|(
name|context
operator|->
name|ssl
argument_list|,
name|hostname
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ERR_clear_error
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf_ssl_use_default_certificates
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|ssl_ctx
parameter_list|)
block|{
name|X509_STORE
modifier|*
name|store
init|=
name|SSL_CTX_get_cert_store
argument_list|(
name|ssl_ctx
operator|->
name|ctx
argument_list|)
decl_stmt|;
name|int
name|result
init|=
name|X509_STORE_set_default_paths
argument_list|(
name|store
argument_list|)
decl_stmt|;
return|return
name|result
condition|?
name|APR_SUCCESS
else|:
name|SERF_ERROR_SSL_CERT_FAILED
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf_ssl_load_cert_file
parameter_list|(
name|serf_ssl_certificate_t
modifier|*
modifier|*
name|cert
parameter_list|,
specifier|const
name|char
modifier|*
name|file_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|file_path
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
name|X509
modifier|*
name|ssl_cert
init|=
name|PEM_read_X509
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl_cert
condition|)
block|{
operator|*
name|cert
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|serf_ssl_certificate_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cert
operator|)
operator|->
name|ssl_cert
operator|=
name|ssl_cert
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
block|}
return|return
name|SERF_ERROR_SSL_CERT_FAILED
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf_ssl_trust_cert
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|ssl_ctx
parameter_list|,
name|serf_ssl_certificate_t
modifier|*
name|cert
parameter_list|)
block|{
name|X509_STORE
modifier|*
name|store
init|=
name|SSL_CTX_get_cert_store
argument_list|(
name|ssl_ctx
operator|->
name|ctx
argument_list|)
decl_stmt|;
name|int
name|result
init|=
name|X509_STORE_add_cert
argument_list|(
name|store
argument_list|,
name|cert
operator|->
name|ssl_cert
argument_list|)
decl_stmt|;
return|return
name|result
condition|?
name|APR_SUCCESS
else|:
name|SERF_ERROR_SSL_CERT_FAILED
return|;
block|}
end_function

begin_function
name|serf_bucket_t
modifier|*
name|serf_bucket_ssl_decrypt_create
parameter_list|(
name|serf_bucket_t
modifier|*
name|stream
parameter_list|,
name|serf_ssl_context_t
modifier|*
name|ssl_ctx
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
block|{
name|serf_bucket_t
modifier|*
name|bkt
decl_stmt|;
name|ssl_context_t
modifier|*
name|ctx
decl_stmt|;
name|bkt
operator|=
name|serf_bucket_ssl_create
argument_list|(
name|ssl_ctx
argument_list|,
name|allocator
argument_list|,
operator|&
name|serf_bucket_type_ssl_decrypt
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|bkt
operator|->
name|data
expr_stmt|;
name|ctx
operator|->
name|databuf
operator|=
operator|&
name|ctx
operator|->
name|ssl_ctx
operator|->
name|decrypt
operator|.
name|databuf
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ssl_ctx
operator|->
name|decrypt
operator|.
name|stream
operator|!=
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|ctx
operator|->
name|ssl_ctx
operator|->
name|decrypt
operator|.
name|stream
operator|=
name|stream
expr_stmt|;
name|ctx
operator|->
name|our_stream
operator|=
operator|&
name|ctx
operator|->
name|ssl_ctx
operator|->
name|decrypt
operator|.
name|stream
expr_stmt|;
return|return
name|bkt
return|;
block|}
end_function

begin_function
name|serf_ssl_context_t
modifier|*
name|serf_bucket_ssl_decrypt_context_get
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
block|{
name|ssl_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
return|return
name|ctx
operator|->
name|ssl_ctx
return|;
block|}
end_function

begin_function
name|serf_bucket_t
modifier|*
name|serf_bucket_ssl_encrypt_create
parameter_list|(
name|serf_bucket_t
modifier|*
name|stream
parameter_list|,
name|serf_ssl_context_t
modifier|*
name|ssl_ctx
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
block|{
name|serf_bucket_t
modifier|*
name|bkt
decl_stmt|;
name|ssl_context_t
modifier|*
name|ctx
decl_stmt|;
name|bkt
operator|=
name|serf_bucket_ssl_create
argument_list|(
name|ssl_ctx
argument_list|,
name|allocator
argument_list|,
operator|&
name|serf_bucket_type_ssl_encrypt
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|bkt
operator|->
name|data
expr_stmt|;
name|ctx
operator|->
name|databuf
operator|=
operator|&
name|ctx
operator|->
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|databuf
expr_stmt|;
name|ctx
operator|->
name|our_stream
operator|=
operator|&
name|ctx
operator|->
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|stream
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|stream
operator|==
name|NULL
condition|)
block|{
name|serf_bucket_t
modifier|*
name|tmp
init|=
name|serf_bucket_aggregate_create
argument_list|(
name|stream
operator|->
name|allocator
argument_list|)
decl_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|tmp
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|stream
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|bucket_list_t
modifier|*
name|new_list
decl_stmt|;
name|new_list
operator|=
name|serf_bucket_mem_alloc
argument_list|(
name|ctx
operator|->
name|ssl_ctx
operator|->
name|allocator
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_list
argument_list|)
argument_list|)
expr_stmt|;
name|new_list
operator|->
name|bucket
operator|=
name|stream
expr_stmt|;
name|new_list
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|stream_next
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|->
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|stream_next
operator|=
name|new_list
expr_stmt|;
block|}
else|else
block|{
name|bucket_list_t
modifier|*
name|scan
init|=
name|ctx
operator|->
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|stream_next
decl_stmt|;
while|while
condition|(
name|scan
operator|->
name|next
operator|!=
name|NULL
condition|)
name|scan
operator|=
name|scan
operator|->
name|next
expr_stmt|;
name|scan
operator|->
name|next
operator|=
name|new_list
expr_stmt|;
block|}
block|}
return|return
name|bkt
return|;
block|}
end_function

begin_function
name|serf_ssl_context_t
modifier|*
name|serf_bucket_ssl_encrypt_context_get
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
block|{
name|ssl_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
return|return
name|ctx
operator|->
name|ssl_ctx
return|;
block|}
end_function

begin_comment
comment|/* Functions to read a serf_ssl_certificate structure. */
end_comment

begin_comment
comment|/* Creates a hash_table with keys (E, CN, OU, O, L, ST and C). */
end_comment

begin_function
specifier|static
name|apr_hash_t
modifier|*
name|convert_X509_NAME_to_table
parameter_list|(
name|X509_NAME
modifier|*
name|org
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|apr_hash_t
modifier|*
name|tgt
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|ret
operator|=
name|X509_NAME_get_text_by_NID
argument_list|(
name|org
argument_list|,
name|NID_commonName
argument_list|,
name|buf
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
name|apr_hash_set
argument_list|(
name|tgt
argument_list|,
literal|"CN"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|X509_NAME_get_text_by_NID
argument_list|(
name|org
argument_list|,
name|NID_pkcs9_emailAddress
argument_list|,
name|buf
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
name|apr_hash_set
argument_list|(
name|tgt
argument_list|,
literal|"E"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|X509_NAME_get_text_by_NID
argument_list|(
name|org
argument_list|,
name|NID_organizationalUnitName
argument_list|,
name|buf
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
name|apr_hash_set
argument_list|(
name|tgt
argument_list|,
literal|"OU"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|X509_NAME_get_text_by_NID
argument_list|(
name|org
argument_list|,
name|NID_organizationName
argument_list|,
name|buf
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
name|apr_hash_set
argument_list|(
name|tgt
argument_list|,
literal|"O"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|X509_NAME_get_text_by_NID
argument_list|(
name|org
argument_list|,
name|NID_localityName
argument_list|,
name|buf
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
name|apr_hash_set
argument_list|(
name|tgt
argument_list|,
literal|"L"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|X509_NAME_get_text_by_NID
argument_list|(
name|org
argument_list|,
name|NID_stateOrProvinceName
argument_list|,
name|buf
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
name|apr_hash_set
argument_list|(
name|tgt
argument_list|,
literal|"ST"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|X509_NAME_get_text_by_NID
argument_list|(
name|org
argument_list|,
name|NID_countryName
argument_list|,
name|buf
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
name|apr_hash_set
argument_list|(
name|tgt
argument_list|,
literal|"C"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tgt
return|;
block|}
end_function

begin_function
name|int
name|serf_ssl_cert_depth
parameter_list|(
specifier|const
name|serf_ssl_certificate_t
modifier|*
name|cert
parameter_list|)
block|{
return|return
name|cert
operator|->
name|depth
return|;
block|}
end_function

begin_function
name|apr_hash_t
modifier|*
name|serf_ssl_cert_issuer
parameter_list|(
specifier|const
name|serf_ssl_certificate_t
modifier|*
name|cert
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|X509_NAME
modifier|*
name|issuer
init|=
name|X509_get_issuer_name
argument_list|(
name|cert
operator|->
name|ssl_cert
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|issuer
condition|)
return|return
name|NULL
return|;
return|return
name|convert_X509_NAME_to_table
argument_list|(
name|issuer
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|apr_hash_t
modifier|*
name|serf_ssl_cert_subject
parameter_list|(
specifier|const
name|serf_ssl_certificate_t
modifier|*
name|cert
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|X509_NAME
modifier|*
name|subject
init|=
name|X509_get_subject_name
argument_list|(
name|cert
operator|->
name|ssl_cert
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|subject
condition|)
return|return
name|NULL
return|;
return|return
name|convert_X509_NAME_to_table
argument_list|(
name|subject
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|apr_hash_t
modifier|*
name|serf_ssl_cert_certificate
parameter_list|(
specifier|const
name|serf_ssl_certificate_t
modifier|*
name|cert
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|tgt
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|md_size
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|char
name|md
index|[
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
name|BIO
modifier|*
name|bio
decl_stmt|;
name|STACK_OF
argument_list|(
name|GENERAL_NAME
argument_list|)
operator|*
name|names
expr_stmt|;
comment|/* sha1 fingerprint */
if|if
condition|(
name|X509_digest
argument_list|(
name|cert
operator|->
name|ssl_cert
argument_list|,
name|EVP_sha1
argument_list|()
argument_list|,
name|md
argument_list|,
operator|&
name|md_size
argument_list|)
condition|)
block|{
specifier|const
name|char
name|hex
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
name|char
name|fingerprint
index|[
name|EVP_MAX_MD_SIZE
operator|*
literal|3
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|md_size
condition|;
name|i
operator|++
control|)
block|{
name|fingerprint
index|[
literal|3
operator|*
name|i
index|]
operator|=
name|hex
index|[
operator|(
name|md
index|[
name|i
index|]
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
index|]
expr_stmt|;
name|fingerprint
index|[
operator|(
literal|3
operator|*
name|i
operator|)
operator|+
literal|1
index|]
operator|=
name|hex
index|[
operator|(
name|md
index|[
name|i
index|]
operator|&
literal|0x0f
operator|)
index|]
expr_stmt|;
name|fingerprint
index|[
operator|(
literal|3
operator|*
name|i
operator|)
operator|+
literal|2
index|]
operator|=
literal|':'
expr_stmt|;
block|}
if|if
condition|(
name|md_size
operator|>
literal|0
condition|)
name|fingerprint
index|[
operator|(
literal|3
operator|*
operator|(
name|md_size
operator|-
literal|1
operator|)
operator|)
operator|+
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|fingerprint
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|apr_hash_set
argument_list|(
name|tgt
argument_list|,
literal|"sha1"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|fingerprint
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* set expiry dates */
name|bio
operator|=
name|BIO_new
argument_list|(
name|BIO_s_mem
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|bio
condition|)
block|{
name|ASN1_TIME
modifier|*
name|notBefore
decl_stmt|,
modifier|*
name|notAfter
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|notBefore
operator|=
name|X509_get_notBefore
argument_list|(
name|cert
operator|->
name|ssl_cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASN1_TIME_print
argument_list|(
name|bio
argument_list|,
name|notBefore
argument_list|)
condition|)
block|{
name|BIO_read
argument_list|(
name|bio
argument_list|,
name|buf
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|tgt
argument_list|,
literal|"notBefore"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|notAfter
operator|=
name|X509_get_notAfter
argument_list|(
name|cert
operator|->
name|ssl_cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASN1_TIME_print
argument_list|(
name|bio
argument_list|,
name|notAfter
argument_list|)
condition|)
block|{
name|BIO_read
argument_list|(
name|bio
argument_list|,
name|buf
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|tgt
argument_list|,
literal|"notAfter"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|BIO_free
argument_list|(
name|bio
argument_list|)
expr_stmt|;
comment|/* Get subjectAltNames */
name|names
operator|=
name|X509_get_ext_d2i
argument_list|(
name|cert
operator|->
name|ssl_cert
argument_list|,
name|NID_subject_alt_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|names
condition|)
block|{
name|int
name|names_count
init|=
name|sk_GENERAL_NAME_num
argument_list|(
name|names
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|san_arr
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|names_count
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|apr_hash_set
argument_list|(
name|tgt
argument_list|,
literal|"subjectAltName"
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|san_arr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|names_count
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|GENERAL_NAME
modifier|*
name|nm
init|=
name|sk_GENERAL_NAME_value
argument_list|(
name|names
argument_list|,
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|nm
operator|->
name|type
condition|)
block|{
case|case
name|GEN_DNS
case|:
name|p
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|nm
operator|->
name|d
operator|.
name|ia5
operator|->
name|data
argument_list|,
name|nm
operator|->
name|d
operator|.
name|ia5
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Don't know what to do - skip. */
break|break;
block|}
if|if
condition|(
name|p
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|san_arr
argument_list|,
name|char
operator|*
argument_list|)
operator|=
name|p
expr_stmt|;
block|}
block|}
name|sk_GENERAL_NAME_pop_free
argument_list|(
name|names
argument_list|,
name|GENERAL_NAME_free
argument_list|)
expr_stmt|;
block|}
return|return
name|tgt
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|serf_ssl_cert_export
parameter_list|(
specifier|const
name|serf_ssl_certificate_t
modifier|*
name|cert
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|binary_cert
decl_stmt|;
name|char
modifier|*
name|encoded_cert
decl_stmt|;
name|int
name|len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|unused
decl_stmt|;
comment|/* find the length of the DER encoding. */
name|len
operator|=
name|i2d_X509
argument_list|(
name|cert
operator|->
name|ssl_cert
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|binary_cert
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|unused
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|binary_cert
expr_stmt|;
name|len
operator|=
name|i2d_X509
argument_list|(
name|cert
operator|->
name|ssl_cert
argument_list|,
operator|&
name|unused
argument_list|)
expr_stmt|;
comment|/* unused is incremented  */
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|encoded_cert
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|apr_base64_encode_len
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|apr_base64_encode
argument_list|(
name|encoded_cert
argument_list|,
name|binary_cert
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|encoded_cert
return|;
block|}
end_function

begin_comment
comment|/* Disables compression for all SSL sessions. */
end_comment

begin_function
specifier|static
name|void
name|disable_compression
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|ssl_ctx
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SSL_OP_NO_COMPRESSION
name|SSL_CTX_set_options
argument_list|(
name|ssl_ctx
operator|->
name|ctx
argument_list|,
name|SSL_OP_NO_COMPRESSION
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|apr_status_t
name|serf_ssl_use_compression
parameter_list|(
name|serf_ssl_context_t
modifier|*
name|ssl_ctx
parameter_list|,
name|int
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|enabled
condition|)
block|{
ifdef|#
directive|ifdef
name|SSL_OP_NO_COMPRESSION
name|SSL_clear_options
argument_list|(
name|ssl_ctx
operator|->
name|ssl
argument_list|,
name|SSL_OP_NO_COMPRESSION
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SSL_OP_NO_COMPRESSION
name|SSL_set_options
argument_list|(
name|ssl_ctx
operator|->
name|ssl
argument_list|,
name|SSL_OP_NO_COMPRESSION
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
endif|#
directive|endif
block|}
return|return
name|APR_EGENERAL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|serf_ssl_destroy_and_data
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
block|{
name|ssl_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
if|if
condition|(
operator|!
operator|--
name|ctx
operator|->
name|ssl_ctx
operator|->
name|refcount
condition|)
block|{
name|ssl_free_context
argument_list|(
name|ctx
operator|->
name|ssl_ctx
argument_list|)
expr_stmt|;
block|}
name|serf_default_destroy_and_data
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serf_ssl_decrypt_destroy_and_data
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
block|{
name|ssl_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|serf_bucket_destroy
argument_list|(
operator|*
name|ctx
operator|->
name|our_stream
argument_list|)
expr_stmt|;
name|serf_ssl_destroy_and_data
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serf_ssl_encrypt_destroy_and_data
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
block|{
name|ssl_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|serf_ssl_context_t
modifier|*
name|ssl_ctx
init|=
name|ctx
operator|->
name|ssl_ctx
decl_stmt|;
if|if
condition|(
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|stream
operator|==
operator|*
name|ctx
operator|->
name|our_stream
condition|)
block|{
name|serf_bucket_destroy
argument_list|(
operator|*
name|ctx
operator|->
name|our_stream
argument_list|)
expr_stmt|;
name|serf_bucket_destroy
argument_list|(
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|pending
argument_list|)
expr_stmt|;
comment|/* Reset our encrypted status and databuf. */
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|databuf
operator|.
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
comment|/* Advance to the next stream - if we have one. */
if|if
condition|(
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|stream_next
operator|==
name|NULL
condition|)
block|{
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|stream
operator|=
name|NULL
expr_stmt|;
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|pending
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|bucket_list_t
modifier|*
name|cur
decl_stmt|;
name|cur
operator|=
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|stream_next
expr_stmt|;
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|stream
operator|=
name|cur
operator|->
name|bucket
expr_stmt|;
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|pending
operator|=
name|serf_bucket_aggregate_create
argument_list|(
name|cur
operator|->
name|bucket
operator|->
name|allocator
argument_list|)
expr_stmt|;
name|ssl_ctx
operator|->
name|encrypt
operator|.
name|stream_next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|serf_bucket_mem_free
argument_list|(
name|ssl_ctx
operator|->
name|allocator
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Ah, darn.  We haven't sent this one along yet. */
return|return;
block|}
name|serf_ssl_destroy_and_data
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_ssl_read
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|ssl_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
return|return
name|serf_databuf_read
argument_list|(
name|ctx
operator|->
name|databuf
argument_list|,
name|requested
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_ssl_readline
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|int
name|acceptable
parameter_list|,
name|int
modifier|*
name|found
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|ssl_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
return|return
name|serf_databuf_readline
argument_list|(
name|ctx
operator|->
name|databuf
argument_list|,
name|acceptable
argument_list|,
name|found
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_ssl_peek
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|ssl_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
return|return
name|serf_databuf_peek
argument_list|(
name|ctx
operator|->
name|databuf
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_ssl_encrypt
init|=
block|{
literal|"SSLENCRYPT"
block|,
name|serf_ssl_read
block|,
name|serf_ssl_readline
block|,
name|serf_default_read_iovec
block|,
name|serf_default_read_for_sendfile
block|,
name|serf_default_read_bucket
block|,
name|serf_ssl_peek
block|,
name|serf_ssl_encrypt_destroy_and_data
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_ssl_decrypt
init|=
block|{
literal|"SSLDECRYPT"
block|,
name|serf_ssl_read
block|,
name|serf_ssl_readline
block|,
name|serf_default_read_iovec
block|,
name|serf_default_read_for_sendfile
block|,
name|serf_default_read_bucket
block|,
name|serf_ssl_peek
block|,
name|serf_ssl_decrypt_destroy_and_data
block|, }
decl_stmt|;
end_decl_stmt

end_unit

