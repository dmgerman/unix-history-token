begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2002-2004 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|"serf.h"
end_include

begin_include
include|#
directive|include
file|"serf_bucket_util.h"
end_include

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|method
decl_stmt|;
specifier|const
name|char
modifier|*
name|uri
decl_stmt|;
name|serf_bucket_t
modifier|*
name|headers
decl_stmt|;
name|serf_bucket_t
modifier|*
name|body
decl_stmt|;
name|apr_int64_t
name|len
decl_stmt|;
block|}
name|request_context_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|LENGTH_UNKNOWN
value|((apr_int64_t)-1)
end_define

begin_function
name|serf_bucket_t
modifier|*
name|serf_bucket_request_create
parameter_list|(
specifier|const
name|char
modifier|*
name|method
parameter_list|,
specifier|const
name|char
modifier|*
name|URI
parameter_list|,
name|serf_bucket_t
modifier|*
name|body
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
block|{
name|request_context_t
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|serf_bucket_mem_alloc
argument_list|(
name|allocator
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|method
operator|=
name|method
expr_stmt|;
name|ctx
operator|->
name|uri
operator|=
name|URI
expr_stmt|;
name|ctx
operator|->
name|headers
operator|=
name|serf_bucket_headers_create
argument_list|(
name|allocator
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|body
operator|=
name|body
expr_stmt|;
name|ctx
operator|->
name|len
operator|=
name|LENGTH_UNKNOWN
expr_stmt|;
return|return
name|serf_bucket_create
argument_list|(
operator|&
name|serf_bucket_type_request
argument_list|,
name|allocator
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|serf_bucket_request_set_CL
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_int64_t
name|len
parameter_list|)
block|{
name|request_context_t
modifier|*
name|ctx
init|=
operator|(
name|request_context_t
operator|*
operator|)
name|bucket
operator|->
name|data
decl_stmt|;
name|ctx
operator|->
name|len
operator|=
name|len
expr_stmt|;
block|}
end_function

begin_function
name|serf_bucket_t
modifier|*
name|serf_bucket_request_get_headers
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
block|{
return|return
operator|(
operator|(
name|request_context_t
operator|*
operator|)
name|bucket
operator|->
name|data
operator|)
operator|->
name|headers
return|;
block|}
end_function

begin_function
name|void
name|serf_bucket_request_set_root
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
specifier|const
name|char
modifier|*
name|root_url
parameter_list|)
block|{
name|request_context_t
modifier|*
name|ctx
init|=
operator|(
name|request_context_t
operator|*
operator|)
name|bucket
operator|->
name|data
decl_stmt|;
comment|/* If uri is already absolute, don't change it. */
if|if
condition|(
name|ctx
operator|->
name|uri
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
return|return;
comment|/* If uri is '/' replace it with root_url. */
if|if
condition|(
name|ctx
operator|->
name|uri
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|ctx
operator|->
name|uri
operator|=
name|root_url
expr_stmt|;
else|else
name|ctx
operator|->
name|uri
operator|=
name|apr_pstrcat
argument_list|(
name|serf_bucket_allocator_get_pool
argument_list|(
name|bucket
operator|->
name|allocator
argument_list|)
argument_list|,
name|root_url
argument_list|,
name|ctx
operator|->
name|uri
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serialize_data
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
block|{
name|request_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|serf_bucket_t
modifier|*
name|new_bucket
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_data
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
literal|4
index|]
decl_stmt|;
name|apr_size_t
name|nbytes
decl_stmt|;
comment|/* Serialize the request-line and headers into one mother string,      * and wrap a bucket around it.      */
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|(
name|char
operator|*
operator|)
name|ctx
operator|->
name|method
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|ctx
operator|->
name|method
argument_list|)
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
literal|" "
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
literal|" "
argument_list|)
operator|-
literal|1
expr_stmt|;
name|iov
index|[
literal|2
index|]
operator|.
name|iov_base
operator|=
operator|(
name|char
operator|*
operator|)
name|ctx
operator|->
name|uri
expr_stmt|;
name|iov
index|[
literal|2
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|ctx
operator|->
name|uri
argument_list|)
expr_stmt|;
name|iov
index|[
literal|3
index|]
operator|.
name|iov_base
operator|=
literal|" HTTP/1.1\r\n"
expr_stmt|;
name|iov
index|[
literal|3
index|]
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
literal|" HTTP/1.1\r\n"
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Create a new bucket for this string with a flat string.  */
name|new_data
operator|=
name|serf_bstrcatv
argument_list|(
name|bucket
operator|->
name|allocator
argument_list|,
name|iov
argument_list|,
literal|4
argument_list|,
operator|&
name|nbytes
argument_list|)
expr_stmt|;
name|new_bucket
operator|=
name|serf_bucket_simple_own_create
argument_list|(
name|new_data
argument_list|,
name|nbytes
argument_list|,
name|bucket
operator|->
name|allocator
argument_list|)
expr_stmt|;
comment|/* Build up the new bucket structure.      *      * Note that self needs to become an aggregate bucket so that a      * pointer to self still represents the "right" data.      */
name|serf_bucket_aggregate_become
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
comment|/* Insert the two buckets. */
name|serf_bucket_aggregate_append
argument_list|(
name|bucket
argument_list|,
name|new_bucket
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|bucket
argument_list|,
name|ctx
operator|->
name|headers
argument_list|)
expr_stmt|;
comment|/* If we know the length, then use C-L and the raw body. Otherwise,        use chunked encoding for the request.  */
if|if
condition|(
name|ctx
operator|->
name|len
operator|!=
name|LENGTH_UNKNOWN
condition|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|ctx
operator|->
name|len
argument_list|)
expr_stmt|;
name|serf_bucket_headers_set
argument_list|(
name|ctx
operator|->
name|headers
argument_list|,
literal|"Content-Length"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|body
operator|!=
name|NULL
condition|)
name|serf_bucket_aggregate_append
argument_list|(
name|bucket
argument_list|,
name|ctx
operator|->
name|body
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|->
name|body
operator|!=
name|NULL
condition|)
block|{
comment|/* Morph the body bucket to a chunked encoding bucket for now. */
name|serf_bucket_headers_setn
argument_list|(
name|ctx
operator|->
name|headers
argument_list|,
literal|"Transfer-Encoding"
argument_list|,
literal|"chunked"
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|body
operator|=
name|serf_bucket_chunk_create
argument_list|(
name|ctx
operator|->
name|body
argument_list|,
name|bucket
operator|->
name|allocator
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|bucket
argument_list|,
name|ctx
operator|->
name|body
argument_list|)
expr_stmt|;
block|}
comment|/* Our private context is no longer needed, and is not referred to by      * any existing bucket. Toss it.      */
name|serf_bucket_mem_free
argument_list|(
name|bucket
operator|->
name|allocator
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_request_read
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
comment|/* Seralize our private data into a new aggregate bucket. */
name|serialize_data
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
comment|/* Delegate to the "new" aggregate bucket to do the read. */
return|return
name|serf_bucket_read
argument_list|(
name|bucket
argument_list|,
name|requested
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_request_readline
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|int
name|acceptable
parameter_list|,
name|int
modifier|*
name|found
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
comment|/* Seralize our private data into a new aggregate bucket. */
name|serialize_data
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
comment|/* Delegate to the "new" aggregate bucket to do the readline. */
return|return
name|serf_bucket_readline
argument_list|(
name|bucket
argument_list|,
name|acceptable
argument_list|,
name|found
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_request_read_iovec
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
name|int
name|vecs_size
parameter_list|,
name|struct
name|iovec
modifier|*
name|vecs
parameter_list|,
name|int
modifier|*
name|vecs_used
parameter_list|)
block|{
comment|/* Seralize our private data into a new aggregate bucket. */
name|serialize_data
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
comment|/* Delegate to the "new" aggregate bucket to do the read. */
return|return
name|serf_bucket_read_iovec
argument_list|(
name|bucket
argument_list|,
name|requested
argument_list|,
name|vecs_size
argument_list|,
name|vecs
argument_list|,
name|vecs_used
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_request_peek
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
comment|/* Seralize our private data into a new aggregate bucket. */
name|serialize_data
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
comment|/* Delegate to the "new" aggregate bucket to do the peek. */
return|return
name|serf_bucket_peek
argument_list|(
name|bucket
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|serf_bucket_request_become
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|,
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|serf_bucket_t
modifier|*
name|body
parameter_list|)
block|{
name|request_context_t
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|serf_bucket_mem_alloc
argument_list|(
name|bucket
operator|->
name|allocator
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|method
operator|=
name|method
expr_stmt|;
name|ctx
operator|->
name|uri
operator|=
name|uri
expr_stmt|;
name|ctx
operator|->
name|headers
operator|=
name|serf_bucket_headers_create
argument_list|(
name|bucket
operator|->
name|allocator
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|body
operator|=
name|body
expr_stmt|;
name|bucket
operator|->
name|type
operator|=
operator|&
name|serf_bucket_type_request
expr_stmt|;
name|bucket
operator|->
name|data
operator|=
name|ctx
expr_stmt|;
comment|/* The allocator remains the same. */
block|}
end_function

begin_decl_stmt
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_request
init|=
block|{
literal|"REQUEST"
block|,
name|serf_request_read
block|,
name|serf_request_readline
block|,
name|serf_request_read_iovec
block|,
name|serf_default_read_for_sendfile
block|,
name|serf_default_read_bucket
block|,
name|serf_request_peek
block|,
name|serf_default_destroy_and_data
block|, }
decl_stmt|;
end_decl_stmt

end_unit

