begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2004 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_comment
comment|/* for strcasecmp() */
end_comment

begin_include
include|#
directive|include
file|"serf.h"
end_include

begin_include
include|#
directive|include
file|"serf_bucket_util.h"
end_include

begin_include
include|#
directive|include
file|"serf_private.h"
end_include

begin_comment
comment|/* for serf__bucket_headers_remove */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|header_list
block|{
specifier|const
name|char
modifier|*
name|header
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|apr_size_t
name|header_size
decl_stmt|;
name|apr_size_t
name|value_size
decl_stmt|;
name|int
name|alloc_flags
decl_stmt|;
define|#
directive|define
name|ALLOC_HEADER
value|0x0001
comment|/* header lives in our allocator */
define|#
directive|define
name|ALLOC_VALUE
value|0x0002
comment|/* value lives in our allocator */
name|struct
name|header_list
modifier|*
name|next
decl_stmt|;
block|}
name|header_list_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|header_list_t
modifier|*
name|list
decl_stmt|;
name|header_list_t
modifier|*
name|last
decl_stmt|;
name|header_list_t
modifier|*
name|cur_read
decl_stmt|;
enum|enum
block|{
name|READ_START
block|,
comment|/* haven't started reading yet */
name|READ_HEADER
block|,
comment|/* reading cur_read->header */
name|READ_SEP
block|,
comment|/* reading ": " */
name|READ_VALUE
block|,
comment|/* reading cur_read->value */
name|READ_CRLF
block|,
comment|/* reading "\r\n" */
name|READ_TERM
block|,
comment|/* reading the final "\r\n" */
name|READ_DONE
comment|/* no more data to read */
block|}
name|state
enum|;
name|apr_size_t
name|amt_read
decl_stmt|;
comment|/* how much of the current state we've read */
block|}
name|headers_context_t
typedef|;
end_typedef

begin_function
name|serf_bucket_t
modifier|*
name|serf_bucket_headers_create
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
block|{
name|headers_context_t
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|serf_bucket_mem_alloc
argument_list|(
name|allocator
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|list
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|state
operator|=
name|READ_START
expr_stmt|;
return|return
name|serf_bucket_create
argument_list|(
operator|&
name|serf_bucket_type_headers
argument_list|,
name|allocator
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|serf_bucket_headers_setx
parameter_list|(
name|serf_bucket_t
modifier|*
name|bkt
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|,
name|apr_size_t
name|header_size
parameter_list|,
name|int
name|header_copy
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|apr_size_t
name|value_size
parameter_list|,
name|int
name|value_copy
parameter_list|)
block|{
name|headers_context_t
modifier|*
name|ctx
init|=
name|bkt
operator|->
name|data
decl_stmt|;
name|header_list_t
modifier|*
name|hdr
decl_stmt|;
if|#
directive|if
literal|0
comment|/* ### include this? */
block|if (ctx->cur_read) {
comment|/* we started reading. can't change now. */
block|abort();     }
endif|#
directive|endif
name|hdr
operator|=
name|serf_bucket_mem_alloc
argument_list|(
name|bkt
operator|->
name|allocator
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|header_size
operator|=
name|header_size
expr_stmt|;
name|hdr
operator|->
name|value_size
operator|=
name|value_size
expr_stmt|;
name|hdr
operator|->
name|alloc_flags
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|header_copy
condition|)
block|{
name|hdr
operator|->
name|header
operator|=
name|serf_bstrmemdup
argument_list|(
name|bkt
operator|->
name|allocator
argument_list|,
name|header
argument_list|,
name|header_size
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|alloc_flags
operator||=
name|ALLOC_HEADER
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|->
name|header
operator|=
name|header
expr_stmt|;
block|}
if|if
condition|(
name|value_copy
condition|)
block|{
name|hdr
operator|->
name|value
operator|=
name|serf_bstrmemdup
argument_list|(
name|bkt
operator|->
name|allocator
argument_list|,
name|value
argument_list|,
name|value_size
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|alloc_flags
operator||=
name|ALLOC_VALUE
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|->
name|value
operator|=
name|value
expr_stmt|;
block|}
comment|/* Add the new header at the end of the list. */
if|if
condition|(
name|ctx
operator|->
name|last
condition|)
name|ctx
operator|->
name|last
operator|->
name|next
operator|=
name|hdr
expr_stmt|;
else|else
name|ctx
operator|->
name|list
operator|=
name|hdr
expr_stmt|;
name|ctx
operator|->
name|last
operator|=
name|hdr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|serf_bucket_headers_set
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers_bucket
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|serf_bucket_headers_setx
argument_list|(
name|headers_bucket
argument_list|,
name|header
argument_list|,
name|strlen
argument_list|(
name|header
argument_list|)
argument_list|,
literal|0
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|serf_bucket_headers_setc
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers_bucket
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|serf_bucket_headers_setx
argument_list|(
name|headers_bucket
argument_list|,
name|header
argument_list|,
name|strlen
argument_list|(
name|header
argument_list|)
argument_list|,
literal|1
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|serf_bucket_headers_setn
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers_bucket
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|serf_bucket_headers_setx
argument_list|(
name|headers_bucket
argument_list|,
name|header
argument_list|,
name|strlen
argument_list|(
name|header
argument_list|)
argument_list|,
literal|0
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|serf_bucket_headers_get
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers_bucket
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|)
block|{
name|headers_context_t
modifier|*
name|ctx
init|=
name|headers_bucket
operator|->
name|data
decl_stmt|;
name|header_list_t
modifier|*
name|found
init|=
name|ctx
operator|->
name|list
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
init|=
name|NULL
decl_stmt|;
name|int
name|value_size
init|=
literal|0
decl_stmt|;
name|int
name|val_alloc
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|found
operator|->
name|header
argument_list|,
name|header
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|val
condition|)
block|{
comment|/* The header is already present.  RFC 2616, section 4.2                    indicates that we should append the new value, separated by                    a comma.  Reasoning: for headers whose values are known to                    be comma-separated, that is clearly the correct behavior;                    for others, the correct behavior is undefined anyway. */
comment|/* The "+1" is for the comma; the +1 in the alloc                    call is for the terminating '\0' */
name|apr_size_t
name|new_size
init|=
name|found
operator|->
name|value_size
operator|+
name|value_size
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|new_val
init|=
name|serf_bucket_mem_alloc
argument_list|(
name|headers_bucket
operator|->
name|allocator
argument_list|,
name|new_size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|new_val
argument_list|,
name|val
argument_list|,
name|value_size
argument_list|)
expr_stmt|;
name|new_val
index|[
name|value_size
index|]
operator|=
literal|','
expr_stmt|;
name|memcpy
argument_list|(
name|new_val
operator|+
name|value_size
operator|+
literal|1
argument_list|,
name|found
operator|->
name|value
argument_list|,
name|found
operator|->
name|value_size
argument_list|)
expr_stmt|;
name|new_val
index|[
name|new_size
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Copy the new value over the already existing value. */
if|if
condition|(
name|val_alloc
condition|)
name|serf_bucket_mem_free
argument_list|(
name|headers_bucket
operator|->
name|allocator
argument_list|,
operator|(
name|void
operator|*
operator|)
name|val
argument_list|)
expr_stmt|;
name|val_alloc
operator||=
name|ALLOC_VALUE
expr_stmt|;
name|val
operator|=
name|new_val
expr_stmt|;
name|value_size
operator|=
name|new_size
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|found
operator|->
name|value
expr_stmt|;
name|value_size
operator|=
name|found
operator|->
name|value_size
expr_stmt|;
block|}
block|}
name|found
operator|=
name|found
operator|->
name|next
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
name|void
name|serf__bucket_headers_remove
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|)
block|{
name|headers_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|header_list_t
modifier|*
name|scan
init|=
name|ctx
operator|->
name|list
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
comment|/* Find and delete all items with the same header (case insensitive) */
while|while
condition|(
name|scan
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|scan
operator|->
name|header
argument_list|,
name|header
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev
condition|)
block|{
name|prev
operator|->
name|next
operator|=
name|scan
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|list
operator|=
name|scan
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|last
operator|==
name|scan
condition|)
block|{
name|ctx
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|prev
operator|=
name|scan
expr_stmt|;
block|}
name|scan
operator|=
name|scan
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|serf_bucket_headers_do
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers_bucket
parameter_list|,
name|serf_bucket_headers_do_callback_fn_t
name|func
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|headers_context_t
modifier|*
name|ctx
init|=
name|headers_bucket
operator|->
name|data
decl_stmt|;
name|header_list_t
modifier|*
name|scan
init|=
name|ctx
operator|->
name|list
decl_stmt|;
while|while
condition|(
name|scan
condition|)
block|{
if|if
condition|(
name|func
argument_list|(
name|baton
argument_list|,
name|scan
operator|->
name|header
argument_list|,
name|scan
operator|->
name|value
argument_list|)
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|scan
operator|=
name|scan
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|serf_headers_destroy_and_data
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
block|{
name|headers_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|header_list_t
modifier|*
name|scan
init|=
name|ctx
operator|->
name|list
decl_stmt|;
while|while
condition|(
name|scan
condition|)
block|{
name|header_list_t
modifier|*
name|next_hdr
init|=
name|scan
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|scan
operator|->
name|alloc_flags
operator|&
name|ALLOC_HEADER
condition|)
name|serf_bucket_mem_free
argument_list|(
name|bucket
operator|->
name|allocator
argument_list|,
operator|(
name|void
operator|*
operator|)
name|scan
operator|->
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan
operator|->
name|alloc_flags
operator|&
name|ALLOC_VALUE
condition|)
name|serf_bucket_mem_free
argument_list|(
name|bucket
operator|->
name|allocator
argument_list|,
operator|(
name|void
operator|*
operator|)
name|scan
operator|->
name|value
argument_list|)
expr_stmt|;
name|serf_bucket_mem_free
argument_list|(
name|bucket
operator|->
name|allocator
argument_list|,
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|next_hdr
expr_stmt|;
block|}
name|serf_default_destroy_and_data
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|select_value
parameter_list|(
name|headers_context_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|value
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|v
decl_stmt|;
name|apr_size_t
name|l
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|state
operator|==
name|READ_START
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|list
operator|==
name|NULL
condition|)
block|{
comment|/* No headers. Move straight to the TERM state. */
name|ctx
operator|->
name|state
operator|=
name|READ_TERM
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|state
operator|=
name|READ_HEADER
expr_stmt|;
name|ctx
operator|->
name|cur_read
operator|=
name|ctx
operator|->
name|list
expr_stmt|;
block|}
name|ctx
operator|->
name|amt_read
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|ctx
operator|->
name|state
condition|)
block|{
case|case
name|READ_HEADER
case|:
name|v
operator|=
name|ctx
operator|->
name|cur_read
operator|->
name|header
expr_stmt|;
name|l
operator|=
name|ctx
operator|->
name|cur_read
operator|->
name|header_size
expr_stmt|;
break|break;
case|case
name|READ_SEP
case|:
name|v
operator|=
literal|": "
expr_stmt|;
name|l
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|READ_VALUE
case|:
name|v
operator|=
name|ctx
operator|->
name|cur_read
operator|->
name|value
expr_stmt|;
name|l
operator|=
name|ctx
operator|->
name|cur_read
operator|->
name|value_size
expr_stmt|;
break|break;
case|case
name|READ_CRLF
case|:
case|case
name|READ_TERM
case|:
name|v
operator|=
literal|"\r\n"
expr_stmt|;
name|l
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|READ_DONE
case|:
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return;
default|default:
comment|/* Not reachable */
return|return;
block|}
operator|*
name|value
operator|=
name|v
operator|+
name|ctx
operator|->
name|amt_read
expr_stmt|;
operator|*
name|len
operator|=
name|l
operator|-
name|ctx
operator|->
name|amt_read
expr_stmt|;
block|}
end_function

begin_comment
comment|/* the current data chunk has been read/consumed. move our internal state. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|consume_chunk
parameter_list|(
name|headers_context_t
modifier|*
name|ctx
parameter_list|)
block|{
comment|/* move to the next state, resetting the amount read. */
operator|++
name|ctx
operator|->
name|state
expr_stmt|;
name|ctx
operator|->
name|amt_read
operator|=
literal|0
expr_stmt|;
comment|/* just sent the terminator and moved to DONE. signal completion. */
if|if
condition|(
name|ctx
operator|->
name|state
operator|==
name|READ_DONE
condition|)
return|return
name|APR_EOF
return|;
comment|/* end of this header. move to the next one. */
if|if
condition|(
name|ctx
operator|->
name|state
operator|==
name|READ_TERM
condition|)
block|{
name|ctx
operator|->
name|cur_read
operator|=
name|ctx
operator|->
name|cur_read
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|cur_read
operator|!=
name|NULL
condition|)
block|{
comment|/* We've got another head to send. Reset the read state. */
name|ctx
operator|->
name|state
operator|=
name|READ_HEADER
expr_stmt|;
block|}
comment|/* else leave in READ_TERM */
block|}
comment|/* there is more data which can be read immediately. */
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_headers_peek
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|headers_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|select_value
argument_list|(
name|ctx
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* already done or returning the CRLF terminator? return EOF */
if|if
condition|(
name|ctx
operator|->
name|state
operator|==
name|READ_DONE
operator|||
name|ctx
operator|->
name|state
operator|==
name|READ_TERM
condition|)
return|return
name|APR_EOF
return|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_headers_read
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|headers_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|apr_size_t
name|avail
decl_stmt|;
name|select_value
argument_list|(
name|ctx
argument_list|,
name|data
argument_list|,
operator|&
name|avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|state
operator|==
name|READ_DONE
condition|)
block|{
operator|*
name|len
operator|=
name|avail
expr_stmt|;
return|return
name|APR_EOF
return|;
block|}
if|if
condition|(
name|requested
operator|>=
name|avail
condition|)
block|{
comment|/* return everything from this chunk */
operator|*
name|len
operator|=
name|avail
expr_stmt|;
comment|/* we consumed this chunk. advance the state. */
return|return
name|consume_chunk
argument_list|(
name|ctx
argument_list|)
return|;
block|}
comment|/* return just the amount requested, and advance our pointer */
operator|*
name|len
operator|=
name|requested
expr_stmt|;
name|ctx
operator|->
name|amt_read
operator|+=
name|requested
expr_stmt|;
comment|/* there is more that can be read immediately */
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_headers_readline
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|int
name|acceptable
parameter_list|,
name|int
modifier|*
name|found
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|headers_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
comment|/* ### what behavior should we use here? APR_EGENERAL for now */
if|if
condition|(
operator|(
name|acceptable
operator|&
name|SERF_NEWLINE_CRLF
operator|)
operator|==
literal|0
condition|)
return|return
name|APR_EGENERAL
return|;
comment|/* get whatever is in this chunk */
name|select_value
argument_list|(
name|ctx
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|state
operator|==
name|READ_DONE
condition|)
return|return
name|APR_EOF
return|;
comment|/* we consumed this chunk. advance the state. */
name|status
operator|=
name|consume_chunk
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* the type of newline found is easy... */
operator|*
name|found
operator|=
operator|(
name|ctx
operator|->
name|state
operator|==
name|READ_CRLF
operator|||
name|ctx
operator|->
name|state
operator|==
name|READ_TERM
operator|)
condition|?
name|SERF_NEWLINE_CRLF
else|:
name|SERF_NEWLINE_NONE
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_headers_read_iovec
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
name|int
name|vecs_size
parameter_list|,
name|struct
name|iovec
modifier|*
name|vecs
parameter_list|,
name|int
modifier|*
name|vecs_used
parameter_list|)
block|{
name|apr_size_t
name|avail
init|=
name|requested
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
name|vecs_used
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vecs_size
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
comment|/* Calling read() would not be a safe opt in the general case, but it          * is here for the header bucket as it only frees all of the header          * keys and values when the entire bucket goes away - not on a          * per-read() basis as is normally the case.          */
name|status
operator|=
name|serf_headers_read
argument_list|(
name|bucket
argument_list|,
name|avail
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|vecs
index|[
operator|*
name|vecs_used
index|]
operator|.
name|iov_base
operator|=
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
name|vecs
index|[
operator|*
name|vecs_used
index|]
operator|.
name|iov_len
operator|=
name|len
expr_stmt|;
operator|(
operator|*
name|vecs_used
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|avail
operator|!=
name|SERF_READ_ALL_AVAIL
condition|)
block|{
name|avail
operator|-=
name|len
expr_stmt|;
comment|/* If we reach 0, then read()'s status will suffice.  */
if|if
condition|(
name|avail
operator|==
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
block|}
block|}
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_headers
init|=
block|{
literal|"HEADERS"
block|,
name|serf_headers_read
block|,
name|serf_headers_readline
block|,
name|serf_headers_read_iovec
block|,
name|serf_default_read_for_sendfile
block|,
name|serf_default_read_bucket
block|,
name|serf_headers_peek
block|,
name|serf_headers_destroy_and_data
block|, }
decl_stmt|;
end_decl_stmt

end_unit

