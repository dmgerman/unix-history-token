begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2002-2004 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"serf.h"
end_include

begin_include
include|#
directive|include
file|"serf_bucket_util.h"
end_include

begin_comment
comment|/* Should be an APR_RING? */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|bucket_list
block|{
name|serf_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|struct
name|bucket_list
modifier|*
name|next
decl_stmt|;
block|}
name|bucket_list_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|bucket_list_t
modifier|*
name|list
decl_stmt|;
comment|/* active buckets */
name|bucket_list_t
modifier|*
name|last
decl_stmt|;
comment|/* last bucket of the list */
name|bucket_list_t
modifier|*
name|done
decl_stmt|;
comment|/* we finished reading this; now pending a destroy */
name|serf_bucket_aggregate_eof_t
name|hold_open
decl_stmt|;
name|void
modifier|*
name|hold_open_baton
decl_stmt|;
comment|/* Does this bucket own its children? !0 if yes, 0 if not. */
name|int
name|bucket_owner
decl_stmt|;
block|}
name|aggregate_context_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|cleanup_aggregate
parameter_list|(
name|aggregate_context_t
modifier|*
name|ctx
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
block|{
name|bucket_list_t
modifier|*
name|next_list
decl_stmt|;
comment|/* If we finished reading a bucket during the previous read, then      * we can now toss that bucket.      */
while|while
condition|(
name|ctx
operator|->
name|done
operator|!=
name|NULL
condition|)
block|{
name|next_list
operator|=
name|ctx
operator|->
name|done
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|bucket_owner
condition|)
block|{
name|serf_bucket_destroy
argument_list|(
name|ctx
operator|->
name|done
operator|->
name|bucket
argument_list|)
expr_stmt|;
block|}
name|serf_bucket_mem_free
argument_list|(
name|allocator
argument_list|,
name|ctx
operator|->
name|done
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|done
operator|=
name|next_list
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|serf_bucket_aggregate_cleanup
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
block|{
name|aggregate_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|cleanup_aggregate
argument_list|(
name|ctx
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|aggregate_context_t
modifier|*
name|create_aggregate
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
block|{
name|aggregate_context_t
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|serf_bucket_mem_alloc
argument_list|(
name|allocator
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|list
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|done
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|hold_open
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|hold_open_baton
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|bucket_owner
operator|=
literal|1
expr_stmt|;
return|return
name|ctx
return|;
block|}
end_function

begin_function
name|serf_bucket_t
modifier|*
name|serf_bucket_aggregate_create
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
block|{
name|aggregate_context_t
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|create_aggregate
argument_list|(
name|allocator
argument_list|)
expr_stmt|;
return|return
name|serf_bucket_create
argument_list|(
operator|&
name|serf_bucket_type_aggregate
argument_list|,
name|allocator
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_function
name|serf_bucket_t
modifier|*
name|serf__bucket_stream_create
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
name|serf_bucket_aggregate_eof_t
name|fn
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|serf_bucket_t
modifier|*
name|bucket
init|=
name|serf_bucket_aggregate_create
argument_list|(
name|allocator
argument_list|)
decl_stmt|;
name|aggregate_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|serf_bucket_aggregate_hold_open
argument_list|(
name|bucket
argument_list|,
name|fn
argument_list|,
name|baton
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|bucket_owner
operator|=
literal|0
expr_stmt|;
return|return
name|bucket
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|serf_aggregate_destroy_and_data
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
block|{
name|aggregate_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|bucket_list_t
modifier|*
name|next_ctx
decl_stmt|;
while|while
condition|(
name|ctx
operator|->
name|list
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|bucket_owner
condition|)
block|{
name|serf_bucket_destroy
argument_list|(
name|ctx
operator|->
name|list
operator|->
name|bucket
argument_list|)
expr_stmt|;
block|}
name|next_ctx
operator|=
name|ctx
operator|->
name|list
operator|->
name|next
expr_stmt|;
name|serf_bucket_mem_free
argument_list|(
name|bucket
operator|->
name|allocator
argument_list|,
name|ctx
operator|->
name|list
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|list
operator|=
name|next_ctx
expr_stmt|;
block|}
name|cleanup_aggregate
argument_list|(
name|ctx
argument_list|,
name|bucket
operator|->
name|allocator
argument_list|)
expr_stmt|;
name|serf_default_destroy_and_data
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|serf_bucket_aggregate_become
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
block|{
name|aggregate_context_t
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|create_aggregate
argument_list|(
name|bucket
operator|->
name|allocator
argument_list|)
expr_stmt|;
name|bucket
operator|->
name|type
operator|=
operator|&
name|serf_bucket_type_aggregate
expr_stmt|;
name|bucket
operator|->
name|data
operator|=
name|ctx
expr_stmt|;
comment|/* The allocator remains the same. */
block|}
end_function

begin_function
name|void
name|serf_bucket_aggregate_prepend
parameter_list|(
name|serf_bucket_t
modifier|*
name|aggregate_bucket
parameter_list|,
name|serf_bucket_t
modifier|*
name|prepend_bucket
parameter_list|)
block|{
name|aggregate_context_t
modifier|*
name|ctx
init|=
name|aggregate_bucket
operator|->
name|data
decl_stmt|;
name|bucket_list_t
modifier|*
name|new_list
decl_stmt|;
name|new_list
operator|=
name|serf_bucket_mem_alloc
argument_list|(
name|aggregate_bucket
operator|->
name|allocator
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_list
argument_list|)
argument_list|)
expr_stmt|;
name|new_list
operator|->
name|bucket
operator|=
name|prepend_bucket
expr_stmt|;
name|new_list
operator|->
name|next
operator|=
name|ctx
operator|->
name|list
expr_stmt|;
name|ctx
operator|->
name|list
operator|=
name|new_list
expr_stmt|;
block|}
end_function

begin_function
name|void
name|serf_bucket_aggregate_append
parameter_list|(
name|serf_bucket_t
modifier|*
name|aggregate_bucket
parameter_list|,
name|serf_bucket_t
modifier|*
name|append_bucket
parameter_list|)
block|{
name|aggregate_context_t
modifier|*
name|ctx
init|=
name|aggregate_bucket
operator|->
name|data
decl_stmt|;
name|bucket_list_t
modifier|*
name|new_list
decl_stmt|;
name|new_list
operator|=
name|serf_bucket_mem_alloc
argument_list|(
name|aggregate_bucket
operator|->
name|allocator
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_list
argument_list|)
argument_list|)
expr_stmt|;
name|new_list
operator|->
name|bucket
operator|=
name|append_bucket
expr_stmt|;
name|new_list
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* If we use APR_RING, this is trivial.  So, wait.     new_list->next = ctx->list;     ctx->list = new_list;     */
if|if
condition|(
name|ctx
operator|->
name|list
operator|==
name|NULL
condition|)
block|{
name|ctx
operator|->
name|list
operator|=
name|new_list
expr_stmt|;
name|ctx
operator|->
name|last
operator|=
name|new_list
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|last
operator|->
name|next
operator|=
name|new_list
expr_stmt|;
name|ctx
operator|->
name|last
operator|=
name|ctx
operator|->
name|last
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|serf_bucket_aggregate_hold_open
parameter_list|(
name|serf_bucket_t
modifier|*
name|aggregate_bucket
parameter_list|,
name|serf_bucket_aggregate_eof_t
name|fn
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|aggregate_context_t
modifier|*
name|ctx
init|=
name|aggregate_bucket
operator|->
name|data
decl_stmt|;
name|ctx
operator|->
name|hold_open
operator|=
name|fn
expr_stmt|;
name|ctx
operator|->
name|hold_open_baton
operator|=
name|baton
expr_stmt|;
block|}
end_function

begin_function
name|void
name|serf_bucket_aggregate_prepend_iovec
parameter_list|(
name|serf_bucket_t
modifier|*
name|aggregate_bucket
parameter_list|,
name|struct
name|iovec
modifier|*
name|vecs
parameter_list|,
name|int
name|vecs_count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Add in reverse order. */
for|for
control|(
name|i
operator|=
name|vecs_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|serf_bucket_t
modifier|*
name|new_bucket
decl_stmt|;
name|new_bucket
operator|=
name|serf_bucket_simple_create
argument_list|(
name|vecs
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|vecs
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|aggregate_bucket
operator|->
name|allocator
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_prepend
argument_list|(
name|aggregate_bucket
argument_list|,
name|new_bucket
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|serf_bucket_aggregate_append_iovec
parameter_list|(
name|serf_bucket_t
modifier|*
name|aggregate_bucket
parameter_list|,
name|struct
name|iovec
modifier|*
name|vecs
parameter_list|,
name|int
name|vecs_count
parameter_list|)
block|{
name|serf_bucket_t
modifier|*
name|new_bucket
decl_stmt|;
name|new_bucket
operator|=
name|serf_bucket_iovec_create
argument_list|(
name|vecs
argument_list|,
name|vecs_count
argument_list|,
name|aggregate_bucket
operator|->
name|allocator
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|aggregate_bucket
argument_list|,
name|new_bucket
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|read_aggregate
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
name|int
name|vecs_size
parameter_list|,
name|struct
name|iovec
modifier|*
name|vecs
parameter_list|,
name|int
modifier|*
name|vecs_used
parameter_list|)
block|{
name|aggregate_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|int
name|cur_vecs_used
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
operator|*
name|vecs_used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|list
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|hold_open
condition|)
block|{
return|return
name|ctx
operator|->
name|hold_open
argument_list|(
name|ctx
operator|->
name|hold_open_baton
argument_list|,
name|bucket
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|APR_EOF
return|;
block|}
block|}
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
while|while
condition|(
name|requested
condition|)
block|{
name|serf_bucket_t
modifier|*
name|head
init|=
name|ctx
operator|->
name|list
operator|->
name|bucket
decl_stmt|;
name|status
operator|=
name|serf_bucket_read_iovec
argument_list|(
name|head
argument_list|,
name|requested
argument_list|,
name|vecs_size
argument_list|,
name|vecs
argument_list|,
operator|&
name|cur_vecs_used
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|status
return|;
comment|/* Add the number of vecs we read to our running total. */
operator|*
name|vecs_used
operator|+=
name|cur_vecs_used
expr_stmt|;
if|if
condition|(
name|cur_vecs_used
operator|>
literal|0
operator|||
name|status
condition|)
block|{
name|bucket_list_t
modifier|*
name|next_list
decl_stmt|;
comment|/* If we got SUCCESS (w/bytes) or EAGAIN, we want to return now              * as it isn't safe to read more without returning to our caller.              */
if|if
condition|(
operator|!
name|status
operator|||
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|status
argument_list|)
operator|||
name|status
operator|==
name|SERF_ERROR_WAIT_CONN
condition|)
block|{
return|return
name|status
return|;
block|}
comment|/* However, if we read EOF, we can stash this bucket in a              * to-be-freed list and move on to the next bucket.  This ensures              * that the bucket stays alive (so as not to violate our read              * semantics).  We'll destroy this list of buckets the next time              * we are asked to perform a read operation - thus ensuring the              * proper read lifetime.              */
name|next_list
operator|=
name|ctx
operator|->
name|list
operator|->
name|next
expr_stmt|;
name|ctx
operator|->
name|list
operator|->
name|next
operator|=
name|ctx
operator|->
name|done
expr_stmt|;
name|ctx
operator|->
name|done
operator|=
name|ctx
operator|->
name|list
expr_stmt|;
name|ctx
operator|->
name|list
operator|=
name|next_list
expr_stmt|;
comment|/* If we have no more in our list, return EOF. */
if|if
condition|(
operator|!
name|ctx
operator|->
name|list
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|hold_open
condition|)
block|{
return|return
name|ctx
operator|->
name|hold_open
argument_list|(
name|ctx
operator|->
name|hold_open_baton
argument_list|,
name|bucket
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|APR_EOF
return|;
block|}
block|}
comment|/* At this point, it safe to read the next bucket - if we can. */
comment|/* If the caller doesn't want ALL_AVAIL, decrement the size              * of the items we just read from the list.              */
if|if
condition|(
name|requested
operator|!=
name|SERF_READ_ALL_AVAIL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_vecs_used
condition|;
name|i
operator|++
control|)
name|requested
operator|-=
name|vecs
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
comment|/* Adjust our vecs to account for what we just read. */
name|vecs_size
operator|-=
name|cur_vecs_used
expr_stmt|;
name|vecs
operator|+=
name|cur_vecs_used
expr_stmt|;
comment|/* We reached our max.  Oh well. */
if|if
condition|(
operator|!
name|requested
operator|||
operator|!
name|vecs_size
condition|)
block|{
return|return
name|APR_SUCCESS
return|;
block|}
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_aggregate_read
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|aggregate_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|struct
name|iovec
name|vec
decl_stmt|;
name|int
name|vecs_used
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|cleanup_aggregate
argument_list|(
name|ctx
argument_list|,
name|bucket
operator|->
name|allocator
argument_list|)
expr_stmt|;
name|status
operator|=
name|read_aggregate
argument_list|(
name|bucket
argument_list|,
name|requested
argument_list|,
literal|1
argument_list|,
operator|&
name|vec
argument_list|,
operator|&
name|vecs_used
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vecs_used
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|data
operator|=
name|vec
operator|.
name|iov_base
expr_stmt|;
operator|*
name|len
operator|=
name|vec
operator|.
name|iov_len
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_aggregate_read_iovec
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
name|int
name|vecs_size
parameter_list|,
name|struct
name|iovec
modifier|*
name|vecs
parameter_list|,
name|int
modifier|*
name|vecs_used
parameter_list|)
block|{
name|aggregate_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|cleanup_aggregate
argument_list|(
name|ctx
argument_list|,
name|bucket
operator|->
name|allocator
argument_list|)
expr_stmt|;
return|return
name|read_aggregate
argument_list|(
name|bucket
argument_list|,
name|requested
argument_list|,
name|vecs_size
argument_list|,
name|vecs
argument_list|,
name|vecs_used
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_aggregate_readline
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|int
name|acceptable
parameter_list|,
name|int
modifier|*
name|found
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
comment|/* Follow pattern from serf_aggregate_read. */
return|return
name|APR_ENOTIMPL
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_aggregate_peek
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
comment|/* Follow pattern from serf_aggregate_read. */
return|return
name|APR_ENOTIMPL
return|;
block|}
end_function

begin_function
specifier|static
name|serf_bucket_t
modifier|*
name|serf_aggregate_read_bucket
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
specifier|const
name|serf_bucket_type_t
modifier|*
name|type
parameter_list|)
block|{
name|aggregate_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|serf_bucket_t
modifier|*
name|found_bucket
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|list
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ctx
operator|->
name|list
operator|->
name|bucket
operator|->
name|type
operator|==
name|type
condition|)
block|{
comment|/* Got the bucket. Consume it from our list. */
name|found_bucket
operator|=
name|ctx
operator|->
name|list
operator|->
name|bucket
expr_stmt|;
name|ctx
operator|->
name|list
operator|=
name|ctx
operator|->
name|list
operator|->
name|next
expr_stmt|;
return|return
name|found_bucket
return|;
block|}
comment|/* Call read_bucket on first one in our list. */
return|return
name|serf_bucket_read_bucket
argument_list|(
name|ctx
operator|->
name|list
operator|->
name|bucket
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_aggregate
init|=
block|{
literal|"AGGREGATE"
block|,
name|serf_aggregate_read
block|,
name|serf_aggregate_readline
block|,
name|serf_aggregate_read_iovec
block|,
name|serf_default_read_for_sendfile
block|,
name|serf_aggregate_read_bucket
block|,
name|serf_aggregate_peek
block|,
name|serf_aggregate_destroy_and_data
block|, }
decl_stmt|;
end_decl_stmt

end_unit

