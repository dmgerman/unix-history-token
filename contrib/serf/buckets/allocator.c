begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2002-2004 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|"serf.h"
end_include

begin_include
include|#
directive|include
file|"serf_bucket_util.h"
end_include

begin_typedef
typedef|typedef
struct|struct
name|node_header_t
block|{
name|apr_size_t
name|size
decl_stmt|;
union|union
block|{
name|struct
name|node_header_t
modifier|*
name|next
decl_stmt|;
comment|/* if size == 0 (freed/inactive) */
comment|/* no data                          if size == STANDARD_NODE_SIZE */
name|apr_memnode_t
modifier|*
name|memnode
decl_stmt|;
comment|/* if size> STANDARD_NODE_SIZE */
block|}
name|u
union|;
block|}
name|node_header_t
typedef|;
end_typedef

begin_comment
comment|/* The size of a node_header_t, properly aligned. Note that (normally)  * this macro will round the size to a multiple of 8 bytes. Keep this in  * mind when altering the node_header_t structure. Also, keep in mind that  * node_header_t is an overhead for every allocation performed through  * the serf_bucket_mem_alloc() function.  */
end_comment

begin_define
define|#
directive|define
name|SIZEOF_NODE_HEADER_T
value|APR_ALIGN_DEFAULT(sizeof(node_header_t))
end_define

begin_comment
comment|/* STANDARD_NODE_SIZE is manually set to an allocation size that will  * capture most allocators performed via this API. It must be "large  * enough" to avoid lots of spillage to allocating directly from the  * apr_allocator associated with the bucket allocator. The apr_allocator  * has a minimum size of 8k, which can be expensive if you missed the  * STANDARD_NODE_SIZE by just a few bytes.  */
end_comment

begin_comment
comment|/* ### we should define some rules or ways to determine how to derive  * ### a "good" value for this. probably log some stats on allocs, then  * ### analyze them for size "misses". then find the balance point between  * ### wasted space due to min-size allocator, and wasted-space due to  * ### size-spill to the 8k minimum.  */
end_comment

begin_define
define|#
directive|define
name|STANDARD_NODE_SIZE
value|128
end_define

begin_comment
comment|/* When allocating a block of memory from the allocator, we should go for  * an 8k block, minus the overhead that the allocator needs.  */
end_comment

begin_define
define|#
directive|define
name|ALLOC_AMT
value|(8192 - APR_MEMNODE_T_SIZE)
end_define

begin_comment
comment|/* Define DEBUG_DOUBLE_FREE if you're interested in debugging double-free  * calls to serf_bucket_mem_free().  */
end_comment

begin_define
define|#
directive|define
name|DEBUG_DOUBLE_FREE
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|serf_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|apr_status_t
name|last
decl_stmt|;
block|}
name|read_status_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|TRACK_BUCKET_COUNT
value|100
end_define

begin_comment
comment|/* track N buckets' status */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|next_index
decl_stmt|;
comment|/* info[] is a ring. next bucket goes at this idx. */
name|int
name|num_used
decl_stmt|;
name|read_status_t
name|info
index|[
name|TRACK_BUCKET_COUNT
index|]
decl_stmt|;
block|}
name|track_state_t
typedef|;
end_typedef

begin_struct
struct|struct
name|serf_bucket_alloc_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|apr_allocator_t
modifier|*
name|allocator
decl_stmt|;
name|int
name|own_allocator
decl_stmt|;
name|serf_unfreed_func_t
name|unfreed
decl_stmt|;
name|void
modifier|*
name|unfreed_baton
decl_stmt|;
name|apr_uint32_t
name|num_alloc
decl_stmt|;
name|node_header_t
modifier|*
name|freelist
decl_stmt|;
comment|/* free STANDARD_NODE_SIZE blocks */
name|apr_memnode_t
modifier|*
name|blocks
decl_stmt|;
comment|/* blocks we allocated for subdividing */
name|track_state_t
modifier|*
name|track
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ==================================================================== */
end_comment

begin_function
specifier|static
name|apr_status_t
name|allocator_cleanup
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|serf_bucket_alloc_t
modifier|*
name|allocator
init|=
name|data
decl_stmt|;
comment|/* If we allocated anything, give it back. */
if|if
condition|(
name|allocator
operator|->
name|blocks
condition|)
block|{
name|apr_allocator_free
argument_list|(
name|allocator
operator|->
name|allocator
argument_list|,
name|allocator
operator|->
name|blocks
argument_list|)
expr_stmt|;
block|}
comment|/* If we allocated our own allocator (?!), destroy it here. */
if|if
condition|(
name|allocator
operator|->
name|own_allocator
condition|)
block|{
name|apr_allocator_destroy
argument_list|(
name|allocator
operator|->
name|allocator
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|serf_bucket_alloc_t
modifier|*
name|serf_bucket_allocator_create
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|serf_unfreed_func_t
name|unfreed
parameter_list|,
name|void
modifier|*
name|unfreed_baton
parameter_list|)
block|{
name|serf_bucket_alloc_t
modifier|*
name|allocator
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|allocator
argument_list|)
argument_list|)
decl_stmt|;
name|allocator
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|allocator
operator|->
name|allocator
operator|=
name|apr_pool_allocator_get
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocator
operator|->
name|allocator
operator|==
name|NULL
condition|)
block|{
comment|/* This most likely means pools are running in debug mode, create our          * own allocator to deal with memory ourselves */
name|apr_allocator_create
argument_list|(
operator|&
name|allocator
operator|->
name|allocator
argument_list|)
expr_stmt|;
name|allocator
operator|->
name|own_allocator
operator|=
literal|1
expr_stmt|;
block|}
name|allocator
operator|->
name|unfreed
operator|=
name|unfreed
expr_stmt|;
name|allocator
operator|->
name|unfreed_baton
operator|=
name|unfreed_baton
expr_stmt|;
ifdef|#
directive|ifdef
name|SERF_DEBUG_BUCKET_USE
block|{
name|track_state_t
modifier|*
name|track
decl_stmt|;
name|track
operator|=
name|allocator
operator|->
name|track
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|allocator
operator|->
name|track
argument_list|)
argument_list|)
expr_stmt|;
name|track
operator|->
name|next_index
operator|=
literal|0
expr_stmt|;
name|track
operator|->
name|num_used
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NOTE: On a fork/exec, the child won't bother cleaning up memory.              This is just fine... the memory will go away at exec.         NOTE: If the child will NOT perform an exec, then the parent or              the child will need to decide who to clean up any              outstanding connection/buckets (as appropriate).  */
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|allocator
argument_list|,
name|allocator_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
return|return
name|allocator
return|;
block|}
end_function

begin_function
name|apr_pool_t
modifier|*
name|serf_bucket_allocator_get_pool
parameter_list|(
specifier|const
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
block|{
return|return
name|allocator
operator|->
name|pool
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|serf_bucket_mem_alloc
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
name|apr_size_t
name|size
parameter_list|)
block|{
name|node_header_t
modifier|*
name|node
decl_stmt|;
operator|++
name|allocator
operator|->
name|num_alloc
expr_stmt|;
name|size
operator|+=
name|SIZEOF_NODE_HEADER_T
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|STANDARD_NODE_SIZE
condition|)
block|{
if|if
condition|(
name|allocator
operator|->
name|freelist
condition|)
block|{
comment|/* just pull a node off our freelist */
name|node
operator|=
name|allocator
operator|->
name|freelist
expr_stmt|;
name|allocator
operator|->
name|freelist
operator|=
name|node
operator|->
name|u
operator|.
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_DOUBLE_FREE
comment|/* When we free an item, we set its size to zero. Thus, when              * we return it to the caller, we must ensure the size is set              * properly.              */
name|node
operator|->
name|size
operator|=
name|STANDARD_NODE_SIZE
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|apr_memnode_t
modifier|*
name|active
init|=
name|allocator
operator|->
name|blocks
decl_stmt|;
if|if
condition|(
name|active
operator|==
name|NULL
operator|||
name|active
operator|->
name|first_avail
operator|+
name|STANDARD_NODE_SIZE
operator|>=
name|active
operator|->
name|endp
condition|)
block|{
name|apr_memnode_t
modifier|*
name|head
init|=
name|allocator
operator|->
name|blocks
decl_stmt|;
comment|/* ran out of room. grab another block. */
name|active
operator|=
name|apr_allocator_alloc
argument_list|(
name|allocator
operator|->
name|allocator
argument_list|,
name|ALLOC_AMT
argument_list|)
expr_stmt|;
comment|/* System couldn't provide us with memory. */
if|if
condition|(
name|active
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* link the block into our tracking list */
name|allocator
operator|->
name|blocks
operator|=
name|active
expr_stmt|;
name|active
operator|->
name|next
operator|=
name|head
expr_stmt|;
block|}
name|node
operator|=
operator|(
name|node_header_t
operator|*
operator|)
name|active
operator|->
name|first_avail
expr_stmt|;
name|node
operator|->
name|size
operator|=
name|STANDARD_NODE_SIZE
expr_stmt|;
name|active
operator|->
name|first_avail
operator|+=
name|STANDARD_NODE_SIZE
expr_stmt|;
block|}
block|}
else|else
block|{
name|apr_memnode_t
modifier|*
name|memnode
init|=
name|apr_allocator_alloc
argument_list|(
name|allocator
operator|->
name|allocator
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|memnode
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|node
operator|=
operator|(
name|node_header_t
operator|*
operator|)
name|memnode
operator|->
name|first_avail
expr_stmt|;
name|node
operator|->
name|u
operator|.
name|memnode
operator|=
name|memnode
expr_stmt|;
name|node
operator|->
name|size
operator|=
name|size
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|node
operator|)
operator|+
name|SIZEOF_NODE_HEADER_T
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|serf_bucket_mem_calloc
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
name|apr_size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|mem
decl_stmt|;
name|mem
operator|=
name|serf_bucket_mem_alloc
argument_list|(
name|allocator
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_function
name|void
name|serf_bucket_mem_free
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|,
name|void
modifier|*
name|block
parameter_list|)
block|{
name|node_header_t
modifier|*
name|node
decl_stmt|;
operator|--
name|allocator
operator|->
name|num_alloc
expr_stmt|;
name|node
operator|=
operator|(
name|node_header_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|block
operator|-
name|SIZEOF_NODE_HEADER_T
operator|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|size
operator|==
name|STANDARD_NODE_SIZE
condition|)
block|{
comment|/* put the node onto our free list */
name|node
operator|->
name|u
operator|.
name|next
operator|=
name|allocator
operator|->
name|freelist
expr_stmt|;
name|allocator
operator|->
name|freelist
operator|=
name|node
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_DOUBLE_FREE
comment|/* note that this thing was freed. */
name|node
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* damn thing was freed already. */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG_DOUBLE_FREE
comment|/* note that this thing was freed. */
name|node
operator|->
name|size
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* now free it */
name|apr_allocator_free
argument_list|(
name|allocator
operator|->
name|allocator
argument_list|,
name|node
operator|->
name|u
operator|.
name|memnode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ==================================================================== */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SERF_DEBUG_BUCKET_USE
end_ifdef

begin_function
specifier|static
name|read_status_t
modifier|*
name|find_read_status
parameter_list|(
name|track_state_t
modifier|*
name|track
parameter_list|,
specifier|const
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|int
name|create_rs
parameter_list|)
block|{
name|read_status_t
modifier|*
name|rs
decl_stmt|;
if|if
condition|(
name|track
operator|->
name|num_used
condition|)
block|{
name|int
name|count
init|=
name|track
operator|->
name|num_used
decl_stmt|;
name|int
name|idx
init|=
name|track
operator|->
name|next_index
decl_stmt|;
comment|/* Search backwards. In all likelihood, the bucket which just got          * read was read very recently.          */
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|idx
operator|--
condition|)
block|{
comment|/* assert: track->num_used == TRACK_BUCKET_COUNT */
name|idx
operator|=
name|track
operator|->
name|num_used
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rs
operator|=
operator|&
name|track
operator|->
name|info
index|[
name|idx
index|]
operator|)
operator|->
name|bucket
operator|==
name|bucket
condition|)
block|{
return|return
name|rs
return|;
block|}
block|}
block|}
comment|/* Only create a new read_status_t when asked. */
if|if
condition|(
operator|!
name|create_rs
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|track
operator|->
name|num_used
operator|<
name|TRACK_BUCKET_COUNT
condition|)
block|{
comment|/* We're still filling up the ring. */
operator|++
name|track
operator|->
name|num_used
expr_stmt|;
block|}
name|rs
operator|=
operator|&
name|track
operator|->
name|info
index|[
name|track
operator|->
name|next_index
index|]
expr_stmt|;
name|rs
operator|->
name|bucket
operator|=
name|bucket
expr_stmt|;
name|rs
operator|->
name|last
operator|=
name|APR_SUCCESS
expr_stmt|;
comment|/* ### the right initial value? */
if|if
condition|(
operator|++
name|track
operator|->
name|next_index
operator|==
name|TRACK_BUCKET_COUNT
condition|)
name|track
operator|->
name|next_index
operator|=
literal|0
expr_stmt|;
return|return
name|rs
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERF_DEBUG_BUCKET_USE */
end_comment

begin_function
name|apr_status_t
name|serf_debug__record_read
parameter_list|(
specifier|const
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_status_t
name|status
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|SERF_DEBUG_BUCKET_USE
return|return
name|status
return|;
else|#
directive|else
name|track_state_t
modifier|*
name|track
init|=
name|bucket
operator|->
name|allocator
operator|->
name|track
decl_stmt|;
name|read_status_t
modifier|*
name|rs
init|=
name|find_read_status
argument_list|(
name|track
argument_list|,
name|bucket
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Validate that the previous status value allowed for another read. */
if|if
condition|(
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|rs
operator|->
name|last
argument_list|)
comment|/* ### or APR_EOF? */
condition|)
block|{
comment|/* Somebody read when they weren't supposed to. Bail. */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Save the current status for later. */
name|rs
operator|->
name|last
operator|=
name|status
expr_stmt|;
return|return
name|status
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|serf_debug__entered_loop
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SERF_DEBUG_BUCKET_USE
name|track_state_t
modifier|*
name|track
init|=
name|allocator
operator|->
name|track
decl_stmt|;
name|read_status_t
modifier|*
name|rs
init|=
operator|&
name|track
operator|->
name|info
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
init|;
name|track
operator|->
name|num_used
condition|;
operator|--
name|track
operator|->
name|num_used
operator|,
operator|++
name|rs
control|)
block|{
if|if
condition|(
name|rs
operator|->
name|last
operator|==
name|APR_SUCCESS
condition|)
block|{
comment|/* Somebody should have read this bucket again. */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* ### other status values? */
block|}
comment|/* num_used was reset. also need to reset the next index. */
name|track
operator|->
name|next_index
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|serf_debug__closed_conn
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SERF_DEBUG_BUCKET_USE
comment|/* Just reset the number used so that we don't examine the info[] */
name|allocator
operator|->
name|track
operator|->
name|num_used
operator|=
literal|0
expr_stmt|;
name|allocator
operator|->
name|track
operator|->
name|next_index
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|serf_debug__bucket_destroy
parameter_list|(
specifier|const
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SERF_DEBUG_BUCKET_USE
name|track_state_t
modifier|*
name|track
init|=
name|bucket
operator|->
name|allocator
operator|->
name|track
decl_stmt|;
name|read_status_t
modifier|*
name|rs
init|=
name|find_read_status
argument_list|(
name|track
argument_list|,
name|bucket
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|!=
name|NULL
operator|&&
name|rs
operator|->
name|last
operator|!=
name|APR_EOF
condition|)
block|{
comment|/* The bucket was destroyed before it was read to completion. */
comment|/* Special exception for socket buckets. If a connection remains          * open, they are not read to completion.          */
if|if
condition|(
name|SERF_BUCKET_IS_SOCKET
argument_list|(
name|bucket
argument_list|)
condition|)
return|return;
comment|/* Ditto for SSL Decrypt buckets. */
if|if
condition|(
name|SERF_BUCKET_IS_SSL_DECRYPT
argument_list|(
name|bucket
argument_list|)
condition|)
return|return;
comment|/* Ditto for SSL Encrypt buckets. */
if|if
condition|(
name|SERF_BUCKET_IS_SSL_ENCRYPT
argument_list|(
name|bucket
argument_list|)
condition|)
return|return;
comment|/* Ditto for barrier buckets. */
if|if
condition|(
name|SERF_BUCKET_IS_BARRIER
argument_list|(
name|bucket
argument_list|)
condition|)
return|return;
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|serf_debug__bucket_alloc_check
parameter_list|(
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SERF_DEBUG_BUCKET_USE
if|if
condition|(
name|allocator
operator|->
name|num_alloc
operator|!=
literal|0
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

end_unit

