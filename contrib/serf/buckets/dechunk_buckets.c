begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2002-2004 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|"serf.h"
end_include

begin_include
include|#
directive|include
file|"serf_bucket_util.h"
end_include

begin_typedef
typedef|typedef
struct|struct
block|{
name|serf_bucket_t
modifier|*
name|stream
decl_stmt|;
enum|enum
block|{
name|STATE_SIZE
block|,
comment|/* reading the chunk size */
name|STATE_CHUNK
block|,
comment|/* reading the chunk */
name|STATE_TERM
block|,
comment|/* reading the chunk terminator */
name|STATE_DONE
comment|/* body is done; we've returned EOF */
block|}
name|state
enum|;
comment|/* Buffer for accumulating a chunk size. */
name|serf_linebuf_t
name|linebuf
decl_stmt|;
comment|/* How much of the chunk, or the terminator, do we have left to read? */
name|apr_int64_t
name|body_left
decl_stmt|;
block|}
name|dechunk_context_t
typedef|;
end_typedef

begin_function
name|serf_bucket_t
modifier|*
name|serf_bucket_dechunk_create
parameter_list|(
name|serf_bucket_t
modifier|*
name|stream
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|allocator
parameter_list|)
block|{
name|dechunk_context_t
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|serf_bucket_mem_alloc
argument_list|(
name|allocator
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
name|ctx
operator|->
name|state
operator|=
name|STATE_SIZE
expr_stmt|;
name|serf_linebuf_init
argument_list|(
operator|&
name|ctx
operator|->
name|linebuf
argument_list|)
expr_stmt|;
return|return
name|serf_bucket_create
argument_list|(
operator|&
name|serf_bucket_type_dechunk
argument_list|,
name|allocator
argument_list|,
name|ctx
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|serf_dechunk_destroy_and_data
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|)
block|{
name|dechunk_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|serf_bucket_destroy
argument_list|(
name|ctx
operator|->
name|stream
argument_list|)
expr_stmt|;
name|serf_default_destroy_and_data
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|serf_dechunk_read
parameter_list|(
name|serf_bucket_t
modifier|*
name|bucket
parameter_list|,
name|apr_size_t
name|requested
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|dechunk_context_t
modifier|*
name|ctx
init|=
name|bucket
operator|->
name|data
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|ctx
operator|->
name|state
condition|)
block|{
case|case
name|STATE_SIZE
case|:
comment|/* fetch a line terminated by CRLF */
name|status
operator|=
name|serf_linebuf_fetch
argument_list|(
operator|&
name|ctx
operator|->
name|linebuf
argument_list|,
name|ctx
operator|->
name|stream
argument_list|,
name|SERF_NEWLINE_CRLF
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|status
return|;
comment|/* if a line was read, then parse it. */
if|if
condition|(
name|ctx
operator|->
name|linebuf
operator|.
name|state
operator|==
name|SERF_LINEBUF_READY
condition|)
block|{
comment|/* NUL-terminate the line. if it filled the entire buffer,                    then just assume the thing is too large. */
if|if
condition|(
name|ctx
operator|->
name|linebuf
operator|.
name|used
operator|==
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|linebuf
operator|.
name|line
argument_list|)
condition|)
return|return
name|APR_FROM_OS_ERROR
argument_list|(
name|ERANGE
argument_list|)
return|;
name|ctx
operator|->
name|linebuf
operator|.
name|line
index|[
name|ctx
operator|->
name|linebuf
operator|.
name|used
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* convert from HEX digits. */
name|ctx
operator|->
name|body_left
operator|=
name|apr_strtoi64
argument_list|(
name|ctx
operator|->
name|linebuf
operator|.
name|line
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
block|{
return|return
name|APR_FROM_OS_ERROR
argument_list|(
name|ERANGE
argument_list|)
return|;
block|}
if|if
condition|(
name|ctx
operator|->
name|body_left
operator|==
literal|0
condition|)
block|{
comment|/* Just read the last-chunk marker. We're DONE. */
name|ctx
operator|->
name|state
operator|=
name|STATE_DONE
expr_stmt|;
name|status
operator|=
name|APR_EOF
expr_stmt|;
block|}
else|else
block|{
comment|/* Got a size, so we'll start reading the chunk now. */
name|ctx
operator|->
name|state
operator|=
name|STATE_CHUNK
expr_stmt|;
block|}
comment|/* If we can read more, then go do so. */
if|if
condition|(
operator|!
name|status
condition|)
continue|continue;
block|}
comment|/* assert: status != 0 */
comment|/* Note that we didn't actually read anything, so our callers              * don't get confused.              */
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|status
return|;
case|case
name|STATE_CHUNK
case|:
if|if
condition|(
name|requested
operator|>
name|ctx
operator|->
name|body_left
condition|)
block|{
name|requested
operator|=
name|ctx
operator|->
name|body_left
expr_stmt|;
block|}
comment|/* Delegate to the stream bucket to do the read. */
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|ctx
operator|->
name|stream
argument_list|,
name|requested
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|status
return|;
comment|/* Some data was read, so decrement the amount left and see              * if we're done reading this chunk.              */
name|ctx
operator|->
name|body_left
operator|-=
operator|*
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|body_left
condition|)
block|{
name|ctx
operator|->
name|state
operator|=
name|STATE_TERM
expr_stmt|;
name|ctx
operator|->
name|body_left
operator|=
literal|2
expr_stmt|;
comment|/* CRLF */
block|}
comment|/* We need more data but there is no more available. */
if|if
condition|(
name|ctx
operator|->
name|body_left
operator|&&
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|SERF_ERROR_TRUNCATED_HTTP_RESPONSE
return|;
block|}
comment|/* Return the data we just read. */
return|return
name|status
return|;
case|case
name|STATE_TERM
case|:
comment|/* Delegate to the stream bucket to do the read. */
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|ctx
operator|->
name|stream
argument_list|,
name|ctx
operator|->
name|body_left
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|status
return|;
comment|/* Some data was read, so decrement the amount left and see              * if we're done reading the chunk terminator.              */
name|ctx
operator|->
name|body_left
operator|-=
operator|*
name|len
expr_stmt|;
comment|/* We need more data but there is no more available. */
if|if
condition|(
name|ctx
operator|->
name|body_left
operator|&&
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|SERF_ERROR_TRUNCATED_HTTP_RESPONSE
return|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|body_left
condition|)
block|{
name|ctx
operator|->
name|state
operator|=
name|STATE_SIZE
expr_stmt|;
block|}
comment|/* Don't return the CR of CRLF to the caller! */
operator|*
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
break|break;
case|case
name|STATE_DONE
case|:
comment|/* Just keep returning EOF */
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|APR_EOF
return|;
default|default:
comment|/* Not reachable */
return|return
name|APR_EGENERAL
return|;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* ### need to implement */
end_comment

begin_define
define|#
directive|define
name|serf_dechunk_readline
value|NULL
end_define

begin_define
define|#
directive|define
name|serf_dechunk_peek
value|NULL
end_define

begin_decl_stmt
specifier|const
name|serf_bucket_type_t
name|serf_bucket_type_dechunk
init|=
block|{
literal|"DECHUNK"
block|,
name|serf_dechunk_read
block|,
name|serf_dechunk_readline
block|,
name|serf_default_read_iovec
block|,
name|serf_default_read_for_sendfile
block|,
name|serf_default_read_bucket
block|,
name|serf_dechunk_peek
block|,
name|serf_dechunk_destroy_and_data
block|, }
decl_stmt|;
end_decl_stmt

end_unit

