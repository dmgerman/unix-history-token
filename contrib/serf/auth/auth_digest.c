begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2009 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_comment
comment|/*** Digest authentication ***/
end_comment

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|<serf_private.h>
end_include

begin_include
include|#
directive|include
file|<auth/auth.h>
end_include

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<apr_base64.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_uuid.h>
end_include

begin_include
include|#
directive|include
file|<apr_md5.h>
end_include

begin_comment
comment|/** Digest authentication, implements RFC 2617. **/
end_comment

begin_comment
comment|/* TODO: add support for the domain attribute. This defines the protection    space, so that serf can decide per URI if it should reuse the cached    credentials for the server, or not. */
end_comment

begin_comment
comment|/* Stores the context information related to Digest authentication.    This information is stored in the per server cache in the serf context. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|digest_authn_info_t
block|{
comment|/* nonce-count for digest authentication */
name|unsigned
name|int
name|digest_nc
decl_stmt|;
specifier|const
name|char
modifier|*
name|header
decl_stmt|;
specifier|const
name|char
modifier|*
name|ha1
decl_stmt|;
specifier|const
name|char
modifier|*
name|realm
decl_stmt|;
specifier|const
name|char
modifier|*
name|cnonce
decl_stmt|;
specifier|const
name|char
modifier|*
name|nonce
decl_stmt|;
specifier|const
name|char
modifier|*
name|opaque
decl_stmt|;
specifier|const
name|char
modifier|*
name|algorithm
decl_stmt|;
specifier|const
name|char
modifier|*
name|qop
decl_stmt|;
specifier|const
name|char
modifier|*
name|username
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|digest_authn_info_t
typedef|;
end_typedef

begin_function
specifier|static
name|char
name|int_to_hex
parameter_list|(
name|int
name|v
parameter_list|)
block|{
return|return
operator|(
name|v
operator|<
literal|10
operator|)
condition|?
literal|'0'
operator|+
name|v
else|:
literal|'a'
operator|+
operator|(
name|v
operator|-
literal|10
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Convert a string if ASCII characters HASHVAL to its hexadecimal  * representation.  *  * The returned string will be allocated in the POOL and be null-terminated.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hex_encode
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|hashval
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|hexval
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
operator|(
name|APR_MD5_DIGESTSIZE
operator|*
literal|2
operator|)
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|APR_MD5_DIGESTSIZE
condition|;
name|i
operator|++
control|)
block|{
name|hexval
index|[
literal|2
operator|*
name|i
index|]
operator|=
name|int_to_hex
argument_list|(
operator|(
name|hashval
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|hexval
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|int_to_hex
argument_list|(
name|hashval
index|[
name|i
index|]
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
name|hexval
index|[
name|APR_MD5_DIGESTSIZE
operator|*
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|hexval
return|;
block|}
end_function

begin_comment
comment|/**  * Returns a 36-byte long string of random characters.  * UUIDs are formatted as: 00112233-4455-6677-8899-AABBCCDDEEFF.  *  * The returned string will be allocated in the POOL and be null-terminated.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|random_cnonce
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_uuid_t
name|uuid
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|APR_UUID_FORMATTED_LENGTH
operator|+
literal|1
argument_list|)
decl_stmt|;
name|apr_uuid_get
argument_list|(
operator|&
name|uuid
argument_list|)
expr_stmt|;
name|apr_uuid_format
argument_list|(
name|buf
argument_list|,
operator|&
name|uuid
argument_list|)
expr_stmt|;
return|return
name|hex_encode
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|build_digest_ha1
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|out_ha1
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|password
parameter_list|,
specifier|const
name|char
modifier|*
name|realm_name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tmp
decl_stmt|;
name|unsigned
name|char
name|ha1
index|[
name|APR_MD5_DIGESTSIZE
index|]
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
comment|/* calculate ha1:        MD5 hash of the combined user name, authentication realm and password */
name|tmp
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s:%s:%s"
argument_list|,
name|username
argument_list|,
name|realm_name
argument_list|,
name|password
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_md5
argument_list|(
name|ha1
argument_list|,
name|tmp
argument_list|,
name|strlen
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
operator|*
name|out_ha1
operator|=
name|hex_encode
argument_list|(
name|ha1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|build_digest_ha2
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|out_ha2
parameter_list|,
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|,
specifier|const
name|char
modifier|*
name|qop
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qop
operator|||
name|strcmp
argument_list|(
name|qop
argument_list|,
literal|"auth"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|tmp
decl_stmt|;
name|unsigned
name|char
name|ha2
index|[
name|APR_MD5_DIGESTSIZE
index|]
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
comment|/* calculate ha2:            MD5 hash of the combined method and URI */
name|tmp
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s:%s"
argument_list|,
name|method
argument_list|,
name|uri
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_md5
argument_list|(
name|ha2
argument_list|,
name|tmp
argument_list|,
name|strlen
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
operator|*
name|out_ha2
operator|=
name|hex_encode
argument_list|(
name|ha2
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
else|else
block|{
comment|/* TODO: auth-int isn't supported! */
return|return
name|APR_ENOTIMPL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|build_auth_header
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|out_header
parameter_list|,
name|digest_authn_info_t
modifier|*
name|digest_info
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|ha2
decl_stmt|;
specifier|const
name|char
modifier|*
name|response
decl_stmt|;
name|unsigned
name|char
name|response_hdr
index|[
name|APR_MD5_DIGESTSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|response_hdr_hex
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|status
operator|=
name|build_digest_ha2
argument_list|(
operator|&
name|ha2
argument_list|,
name|path
argument_list|,
name|method
argument_list|,
name|digest_info
operator|->
name|qop
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
name|hdr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"Digest realm=\"%s\","
literal|" username=\"%s\","
literal|" nonce=\"%s\","
literal|" uri=\"%s\""
argument_list|,
name|digest_info
operator|->
name|realm
argument_list|,
name|digest_info
operator|->
name|username
argument_list|,
name|digest_info
operator|->
name|nonce
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|digest_info
operator|->
name|qop
condition|)
block|{
if|if
condition|(
operator|!
name|digest_info
operator|->
name|cnonce
condition|)
name|digest_info
operator|->
name|cnonce
operator|=
name|random_cnonce
argument_list|(
name|digest_info
operator|->
name|pool
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s, nc=%08x, cnonce=\"%s\", qop=\"%s\""
argument_list|,
name|hdr
argument_list|,
name|digest_info
operator|->
name|digest_nc
argument_list|,
name|digest_info
operator|->
name|cnonce
argument_list|,
name|digest_info
operator|->
name|qop
argument_list|)
expr_stmt|;
comment|/* Build the response header:            MD5 hash of the combined HA1 result, server nonce (nonce),            request counter (nc), client nonce (cnonce),            quality of protection code (qop) and HA2 result. */
name|response
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s:%s:%08x:%s:%s:%s"
argument_list|,
name|digest_info
operator|->
name|ha1
argument_list|,
name|digest_info
operator|->
name|nonce
argument_list|,
name|digest_info
operator|->
name|digest_nc
argument_list|,
name|digest_info
operator|->
name|cnonce
argument_list|,
name|digest_info
operator|->
name|qop
argument_list|,
name|ha2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Build the response header:            MD5 hash of the combined HA1 result, server nonce (nonce)            and HA2 result. */
name|response
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s:%s:%s"
argument_list|,
name|digest_info
operator|->
name|ha1
argument_list|,
name|digest_info
operator|->
name|nonce
argument_list|,
name|ha2
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|apr_md5
argument_list|(
name|response_hdr
argument_list|,
name|response
argument_list|,
name|strlen
argument_list|(
name|response
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
name|response_hdr_hex
operator|=
name|hex_encode
argument_list|(
name|response_hdr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s, response=\"%s\""
argument_list|,
name|hdr
argument_list|,
name|response_hdr_hex
argument_list|)
expr_stmt|;
if|if
condition|(
name|digest_info
operator|->
name|opaque
condition|)
block|{
name|hdr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s, opaque=\"%s\""
argument_list|,
name|hdr
argument_list|,
name|digest_info
operator|->
name|opaque
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|digest_info
operator|->
name|algorithm
condition|)
block|{
name|hdr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s, algorithm=\"%s\""
argument_list|,
name|hdr
argument_list|,
name|digest_info
operator|->
name|algorithm
argument_list|)
expr_stmt|;
block|}
operator|*
name|out_header
operator|=
name|hdr
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf__handle_digest_auth
parameter_list|(
name|int
name|code
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
specifier|const
name|char
modifier|*
name|auth_hdr
parameter_list|,
specifier|const
name|char
modifier|*
name|auth_attr
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|attrs
decl_stmt|;
name|char
modifier|*
name|nextkv
decl_stmt|;
specifier|const
name|char
modifier|*
name|realm
decl_stmt|,
modifier|*
name|realm_name
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|nonce
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|algorithm
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|qop
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|opaque
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|serf_connection_t
modifier|*
name|conn
init|=
name|request
operator|->
name|conn
decl_stmt|;
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|serf__authn_info_t
modifier|*
name|authn_info
decl_stmt|;
name|digest_authn_info_t
modifier|*
name|digest_info
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|apr_pool_t
modifier|*
name|cred_pool
decl_stmt|;
name|char
modifier|*
name|username
decl_stmt|,
modifier|*
name|password
decl_stmt|;
comment|/* Can't do Digest authentication if there's no callback to get        username& password. */
if|if
condition|(
operator|!
name|ctx
operator|->
name|cred_cb
condition|)
block|{
return|return
name|SERF_ERROR_AUTHN_FAILED
return|;
block|}
if|if
condition|(
name|code
operator|==
literal|401
condition|)
block|{
name|authn_info
operator|=
name|serf__get_authn_info_for_server
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|authn_info
operator|=
operator|&
name|ctx
operator|->
name|proxy_authn_info
expr_stmt|;
block|}
name|digest_info
operator|=
name|authn_info
operator|->
name|baton
expr_stmt|;
comment|/* Need a copy cuz we're going to write NUL characters into the string.  */
name|attrs
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|auth_attr
argument_list|)
expr_stmt|;
comment|/* We're expecting a list of key=value pairs, separated by a comma.        Ex. realm="SVN Digest",        nonce="f+zTl/leBAA=e371bd3070adfb47b21f5fc64ad8cc21adc371a5",        algorithm=MD5, qop="auth" */
for|for
control|(
init|;
operator|(
name|key
operator|=
name|apr_strtok
argument_list|(
name|attrs
argument_list|,
literal|","
argument_list|,
operator|&
name|nextkv
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|attrs
operator|=
name|NULL
control|)
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|val
operator|=
name|strchr
argument_list|(
name|key
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|val
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* skip leading spaces */
while|while
condition|(
operator|*
name|key
operator|&&
operator|*
name|key
operator|==
literal|' '
condition|)
name|key
operator|++
expr_stmt|;
comment|/* If the value is quoted, then remove the quotes.  */
if|if
condition|(
operator|*
name|val
operator|==
literal|'"'
condition|)
block|{
name|apr_size_t
name|last
init|=
name|strlen
argument_list|(
name|val
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|val
index|[
name|last
index|]
operator|==
literal|'"'
condition|)
block|{
name|val
index|[
name|last
index|]
operator|=
literal|'\0'
expr_stmt|;
name|val
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"realm"
argument_list|)
operator|==
literal|0
condition|)
name|realm_name
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"nonce"
argument_list|)
operator|==
literal|0
condition|)
name|nonce
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"algorithm"
argument_list|)
operator|==
literal|0
condition|)
name|algorithm
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"qop"
argument_list|)
operator|==
literal|0
condition|)
name|qop
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"opaque"
argument_list|)
operator|==
literal|0
condition|)
name|opaque
operator|=
name|val
expr_stmt|;
comment|/* Ignore all unsupported attributes. */
block|}
if|if
condition|(
operator|!
name|realm_name
condition|)
block|{
return|return
name|SERF_ERROR_AUTHN_MISSING_ATTRIBUTE
return|;
block|}
name|realm
operator|=
name|serf__construct_realm
argument_list|(
name|code
operator|==
literal|401
condition|?
name|HOST
else|:
name|PROXY
argument_list|,
name|conn
argument_list|,
name|realm_name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Ask the application for credentials */
name|apr_pool_create
argument_list|(
operator|&
name|cred_pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|status
operator|=
name|serf__provide_credentials
argument_list|(
name|ctx
argument_list|,
operator|&
name|username
argument_list|,
operator|&
name|password
argument_list|,
name|request
argument_list|,
name|baton
argument_list|,
name|code
argument_list|,
name|authn_info
operator|->
name|scheme
operator|->
name|name
argument_list|,
name|realm
argument_list|,
name|cred_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|apr_pool_destroy
argument_list|(
name|cred_pool
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|digest_info
operator|->
name|header
operator|=
operator|(
name|code
operator|==
literal|401
operator|)
condition|?
literal|"Authorization"
else|:
literal|"Proxy-Authorization"
expr_stmt|;
comment|/* Store the digest authentication parameters in the context cached for        this server in the serf context, so we can use it to create the        Authorization header when setting up requests on the same or different        connections (e.g. in case of KeepAlive off on the server).        TODO: we currently don't cache this info per realm, so each time a request        'switches realms', we have to ask the application for new credentials. */
name|digest_info
operator|->
name|pool
operator|=
name|conn
operator|->
name|pool
expr_stmt|;
name|digest_info
operator|->
name|qop
operator|=
name|apr_pstrdup
argument_list|(
name|digest_info
operator|->
name|pool
argument_list|,
name|qop
argument_list|)
expr_stmt|;
name|digest_info
operator|->
name|nonce
operator|=
name|apr_pstrdup
argument_list|(
name|digest_info
operator|->
name|pool
argument_list|,
name|nonce
argument_list|)
expr_stmt|;
name|digest_info
operator|->
name|cnonce
operator|=
name|NULL
expr_stmt|;
name|digest_info
operator|->
name|opaque
operator|=
name|apr_pstrdup
argument_list|(
name|digest_info
operator|->
name|pool
argument_list|,
name|opaque
argument_list|)
expr_stmt|;
name|digest_info
operator|->
name|algorithm
operator|=
name|apr_pstrdup
argument_list|(
name|digest_info
operator|->
name|pool
argument_list|,
name|algorithm
argument_list|)
expr_stmt|;
name|digest_info
operator|->
name|realm
operator|=
name|apr_pstrdup
argument_list|(
name|digest_info
operator|->
name|pool
argument_list|,
name|realm_name
argument_list|)
expr_stmt|;
name|digest_info
operator|->
name|username
operator|=
name|apr_pstrdup
argument_list|(
name|digest_info
operator|->
name|pool
argument_list|,
name|username
argument_list|)
expr_stmt|;
name|digest_info
operator|->
name|digest_nc
operator|++
expr_stmt|;
name|status
operator|=
name|build_digest_ha1
argument_list|(
operator|&
name|digest_info
operator|->
name|ha1
argument_list|,
name|username
argument_list|,
name|password
argument_list|,
name|digest_info
operator|->
name|realm
argument_list|,
name|digest_info
operator|->
name|pool
argument_list|)
expr_stmt|;
name|apr_pool_destroy
argument_list|(
name|cred_pool
argument_list|)
expr_stmt|;
comment|/* If the handshake is finished tell serf it can send as much requests as it        likes. */
name|serf_connection_set_max_outstanding_requests
argument_list|(
name|conn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf__init_digest
parameter_list|(
name|int
name|code
parameter_list|,
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf__init_digest_connection
parameter_list|(
specifier|const
name|serf__authn_scheme_t
modifier|*
name|scheme
parameter_list|,
name|int
name|code
parameter_list|,
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|serf__authn_info_t
modifier|*
name|authn_info
decl_stmt|;
if|if
condition|(
name|code
operator|==
literal|401
condition|)
block|{
name|authn_info
operator|=
name|serf__get_authn_info_for_server
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|authn_info
operator|=
operator|&
name|ctx
operator|->
name|proxy_authn_info
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|authn_info
operator|->
name|baton
condition|)
block|{
name|authn_info
operator|->
name|baton
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|digest_authn_info_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Make serf send the initial requests one by one */
name|serf_connection_set_max_outstanding_requests
argument_list|(
name|conn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf__setup_request_digest_auth
parameter_list|(
name|peer_t
name|peer
parameter_list|,
name|int
name|code
parameter_list|,
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|,
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|serf_bucket_t
modifier|*
name|hdrs_bkt
parameter_list|)
block|{
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|serf__authn_info_t
modifier|*
name|authn_info
decl_stmt|;
name|digest_authn_info_t
modifier|*
name|digest_info
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
if|if
condition|(
name|peer
operator|==
name|HOST
condition|)
block|{
name|authn_info
operator|=
name|serf__get_authn_info_for_server
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|authn_info
operator|=
operator|&
name|ctx
operator|->
name|proxy_authn_info
expr_stmt|;
block|}
name|digest_info
operator|=
name|authn_info
operator|->
name|baton
expr_stmt|;
if|if
condition|(
name|digest_info
operator|&&
name|digest_info
operator|->
name|realm
condition|)
block|{
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* TODO: per request pool? */
comment|/* for request 'CONNECT serf.googlecode.com:443', the uri also should be            serf.googlecode.com:443. apr_uri_parse can't handle this, so special            case. */
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"CONNECT"
argument_list|)
operator|==
literal|0
condition|)
name|path
operator|=
name|uri
expr_stmt|;
else|else
block|{
name|apr_uri_t
name|parsed_uri
decl_stmt|;
comment|/* Extract path from uri. */
name|status
operator|=
name|apr_uri_parse
argument_list|(
name|conn
operator|->
name|pool
argument_list|,
name|uri
argument_list|,
operator|&
name|parsed_uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
name|path
operator|=
name|parsed_uri
operator|.
name|path
expr_stmt|;
block|}
comment|/* Build a new Authorization header. */
name|digest_info
operator|->
name|header
operator|=
operator|(
name|peer
operator|==
name|HOST
operator|)
condition|?
literal|"Authorization"
else|:
literal|"Proxy-Authorization"
expr_stmt|;
name|status
operator|=
name|build_auth_header
argument_list|(
operator|&
name|value
argument_list|,
name|digest_info
argument_list|,
name|path
argument_list|,
name|method
argument_list|,
name|conn
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
name|serf_bucket_headers_setn
argument_list|(
name|hdrs_bkt
argument_list|,
name|digest_info
operator|->
name|header
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|digest_info
operator|->
name|digest_nc
operator|++
expr_stmt|;
comment|/* Store the uri of this request on the serf_request_t object, to make            it available when validating the Authentication-Info header of the            matching response. */
name|request
operator|->
name|auth_baton
operator|=
operator|(
name|void
operator|*
operator|)
name|path
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf__validate_response_digest_auth
parameter_list|(
specifier|const
name|serf__authn_scheme_t
modifier|*
name|scheme
parameter_list|,
name|peer_t
name|peer
parameter_list|,
name|int
name|code
parameter_list|,
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
name|auth_attr
decl_stmt|;
name|char
modifier|*
name|nextkv
decl_stmt|;
specifier|const
name|char
modifier|*
name|rspauth
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|qop
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|nc_str
init|=
name|NULL
decl_stmt|;
name|serf_bucket_t
modifier|*
name|hdrs
decl_stmt|;
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|hdrs
operator|=
name|serf_bucket_response_get_headers
argument_list|(
name|response
argument_list|)
expr_stmt|;
comment|/* Need a copy cuz we're going to write NUL characters into the string.  */
if|if
condition|(
name|peer
operator|==
name|HOST
condition|)
name|auth_attr
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|serf_bucket_headers_get
argument_list|(
name|hdrs
argument_list|,
literal|"Authentication-Info"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|auth_attr
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|serf_bucket_headers_get
argument_list|(
name|hdrs
argument_list|,
literal|"Proxy-Authentication-Info"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there's no Authentication-Info header there's nothing to validate. */
if|if
condition|(
operator|!
name|auth_attr
condition|)
return|return
name|APR_SUCCESS
return|;
comment|/* We're expecting a list of key=value pairs, separated by a comma.        Ex. rspauth="8a4b8451084b082be6b105e2b7975087",        cnonce="346531653132652d303033392d3435", nc=00000007,        qop=auth */
for|for
control|(
init|;
operator|(
name|key
operator|=
name|apr_strtok
argument_list|(
name|auth_attr
argument_list|,
literal|","
argument_list|,
operator|&
name|nextkv
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|auth_attr
operator|=
name|NULL
control|)
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|val
operator|=
name|strchr
argument_list|(
name|key
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|val
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* skip leading spaces */
while|while
condition|(
operator|*
name|key
operator|&&
operator|*
name|key
operator|==
literal|' '
condition|)
name|key
operator|++
expr_stmt|;
comment|/* If the value is quoted, then remove the quotes.  */
if|if
condition|(
operator|*
name|val
operator|==
literal|'"'
condition|)
block|{
name|apr_size_t
name|last
init|=
name|strlen
argument_list|(
name|val
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|val
index|[
name|last
index|]
operator|==
literal|'"'
condition|)
block|{
name|val
index|[
name|last
index|]
operator|=
literal|'\0'
expr_stmt|;
name|val
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"rspauth"
argument_list|)
operator|==
literal|0
condition|)
name|rspauth
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"qop"
argument_list|)
operator|==
literal|0
condition|)
name|qop
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"nc"
argument_list|)
operator|==
literal|0
condition|)
name|nc_str
operator|=
name|val
expr_stmt|;
block|}
if|if
condition|(
name|rspauth
condition|)
block|{
specifier|const
name|char
modifier|*
name|ha2
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|resp_hdr_hex
decl_stmt|;
name|unsigned
name|char
name|resp_hdr
index|[
name|APR_MD5_DIGESTSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|req_uri
init|=
name|request
operator|->
name|auth_baton
decl_stmt|;
name|serf__authn_info_t
modifier|*
name|authn_info
decl_stmt|;
name|digest_authn_info_t
modifier|*
name|digest_info
decl_stmt|;
if|if
condition|(
name|peer
operator|==
name|HOST
condition|)
block|{
name|authn_info
operator|=
name|serf__get_authn_info_for_server
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|authn_info
operator|=
operator|&
name|ctx
operator|->
name|proxy_authn_info
expr_stmt|;
block|}
name|digest_info
operator|=
name|authn_info
operator|->
name|baton
expr_stmt|;
name|status
operator|=
name|build_digest_ha2
argument_list|(
operator|&
name|ha2
argument_list|,
name|req_uri
argument_list|,
literal|""
argument_list|,
name|qop
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
name|tmp
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s:%s:%s:%s:%s:%s"
argument_list|,
name|digest_info
operator|->
name|ha1
argument_list|,
name|digest_info
operator|->
name|nonce
argument_list|,
name|nc_str
argument_list|,
name|digest_info
operator|->
name|cnonce
argument_list|,
name|digest_info
operator|->
name|qop
argument_list|,
name|ha2
argument_list|)
expr_stmt|;
name|apr_md5
argument_list|(
name|resp_hdr
argument_list|,
name|tmp
argument_list|,
name|strlen
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|resp_hdr_hex
operator|=
name|hex_encode
argument_list|(
name|resp_hdr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Incorrect response-digest in Authentication-Info header. */
if|if
condition|(
name|strcmp
argument_list|(
name|rspauth
argument_list|,
name|resp_hdr_hex
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|SERF_ERROR_AUTHN_FAILED
return|;
block|}
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

end_unit

