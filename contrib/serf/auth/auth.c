begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2009 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"serf.h"
end_include

begin_include
include|#
directive|include
file|"serf_private.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<apr_base64.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_lib.h>
end_include

begin_function
specifier|static
name|apr_status_t
name|default_auth_response_handler
parameter_list|(
specifier|const
name|serf__authn_scheme_t
modifier|*
name|scheme
parameter_list|,
name|peer_t
name|peer
parameter_list|,
name|int
name|code
parameter_list|,
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* These authentication schemes are in order of decreasing security, the topmost    scheme will be used first when the server supports it.      Each set of handlers should support both server (401) and proxy (407)    authentication.      Use lower case for the scheme names to enable case insensitive matching.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|serf__authn_scheme_t
name|serf_authn_schemes
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|SERF_HAVE_SPNEGO
block|{
literal|"Negotiate"
block|,
literal|"negotiate"
block|,
name|SERF_AUTHN_NEGOTIATE
block|,
name|serf__init_spnego
block|,
name|serf__init_spnego_connection
block|,
name|serf__handle_spnego_auth
block|,
name|serf__setup_request_spnego_auth
block|,
name|serf__validate_response_spnego_auth
block|,     }
block|,
ifdef|#
directive|ifdef
name|WIN32
block|{
literal|"NTLM"
block|,
literal|"ntlm"
block|,
name|SERF_AUTHN_NTLM
block|,
name|serf__init_spnego
block|,
name|serf__init_spnego_connection
block|,
name|serf__handle_spnego_auth
block|,
name|serf__setup_request_spnego_auth
block|,
name|serf__validate_response_spnego_auth
block|,     }
block|,
endif|#
directive|endif
comment|/* #ifdef WIN32 */
endif|#
directive|endif
comment|/* SERF_HAVE_SPNEGO */
block|{
literal|"Digest"
block|,
literal|"digest"
block|,
name|SERF_AUTHN_DIGEST
block|,
name|serf__init_digest
block|,
name|serf__init_digest_connection
block|,
name|serf__handle_digest_auth
block|,
name|serf__setup_request_digest_auth
block|,
name|serf__validate_response_digest_auth
block|,     }
block|,
block|{
literal|"Basic"
block|,
literal|"basic"
block|,
name|SERF_AUTHN_BASIC
block|,
name|serf__init_basic
block|,
name|serf__init_basic_connection
block|,
name|serf__handle_basic_auth
block|,
name|serf__setup_request_basic_auth
block|,
name|default_auth_response_handler
block|,     }
block|,
comment|/* ADD NEW AUTHENTICATION IMPLEMENTATIONS HERE (as they're written) */
comment|/* sentinel */
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reads and discards all bytes in the response body. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|discard_body
parameter_list|(
name|serf_bucket_t
modifier|*
name|response
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|response
argument_list|,
name|SERF_READ_ALL_AVAIL
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
comment|/* feed me */
block|}
block|}
end_function

begin_comment
comment|/**  * handle_auth_header is called for each header in the response. It filters  * out the Authenticate headers (WWW or Proxy depending on what's needed) and  * tries to find a matching scheme handler.  *  * Returns a non-0 value of a matching handler was found.  */
end_comment

begin_function
specifier|static
name|int
name|handle_auth_headers
parameter_list|(
name|int
name|code
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_hash_t
modifier|*
name|hdrs
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|serf__authn_scheme_t
modifier|*
name|scheme
decl_stmt|;
name|serf_connection_t
modifier|*
name|conn
init|=
name|request
operator|->
name|conn
decl_stmt|;
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|status
operator|=
name|SERF_ERROR_AUTHN_NOT_SUPPORTED
expr_stmt|;
comment|/* Find the matching authentication handler.        Note that we don't reuse the auth scheme stored in the context,        as that may have changed. (ex. fallback from ntlm to basic.) */
for|for
control|(
name|scheme
operator|=
name|serf_authn_schemes
init|;
name|scheme
operator|->
name|name
operator|!=
literal|0
condition|;
operator|++
name|scheme
control|)
block|{
specifier|const
name|char
modifier|*
name|auth_hdr
decl_stmt|;
name|serf__auth_handler_func_t
name|handler
decl_stmt|;
name|serf__authn_info_t
modifier|*
name|authn_info
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctx
operator|->
name|authn_types
operator|&
name|scheme
operator|->
name|type
operator|)
condition|)
continue|continue;
name|serf__log_skt
argument_list|(
name|AUTH_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"Client supports: %s\n"
argument_list|,
name|scheme
operator|->
name|name
argument_list|)
expr_stmt|;
name|auth_hdr
operator|=
name|apr_hash_get
argument_list|(
name|hdrs
argument_list|,
name|scheme
operator|->
name|key
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|auth_hdr
condition|)
continue|continue;
if|if
condition|(
name|code
operator|==
literal|401
condition|)
block|{
name|authn_info
operator|=
name|serf__get_authn_info_for_server
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|authn_info
operator|=
operator|&
name|ctx
operator|->
name|proxy_authn_info
expr_stmt|;
block|}
if|if
condition|(
name|authn_info
operator|->
name|failed_authn_types
operator|&
name|scheme
operator|->
name|type
condition|)
block|{
comment|/* Skip this authn type since we already tried it before. */
continue|continue;
block|}
comment|/* Found a matching scheme */
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
name|handler
operator|=
name|scheme
operator|->
name|handle_func
expr_stmt|;
name|serf__log_skt
argument_list|(
name|AUTH_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"... matched: %s\n"
argument_list|,
name|scheme
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* If this is the first time we use this scheme on this context and/or            this connection, make sure to initialize the authentication handler             first. */
if|if
condition|(
name|authn_info
operator|->
name|scheme
operator|!=
name|scheme
condition|)
block|{
name|status
operator|=
name|scheme
operator|->
name|init_ctx_func
argument_list|(
name|code
argument_list|,
name|ctx
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
block|{
name|status
operator|=
name|scheme
operator|->
name|init_conn_func
argument_list|(
name|scheme
argument_list|,
name|code
argument_list|,
name|conn
argument_list|,
name|conn
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
name|authn_info
operator|->
name|scheme
operator|=
name|scheme
expr_stmt|;
else|else
name|authn_info
operator|->
name|scheme
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|status
condition|)
block|{
specifier|const
name|char
modifier|*
name|auth_attr
init|=
name|strchr
argument_list|(
name|auth_hdr
argument_list|,
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|auth_attr
condition|)
block|{
name|auth_attr
operator|++
expr_stmt|;
block|}
name|status
operator|=
name|handler
argument_list|(
name|code
argument_list|,
name|request
argument_list|,
name|response
argument_list|,
name|auth_hdr
argument_list|,
name|auth_attr
argument_list|,
name|baton
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|APR_SUCCESS
condition|)
break|break;
comment|/* No success authenticating with this scheme, try the next.            If no more authn schemes are found the status of this scheme will be            returned.         */
name|serf__log_skt
argument_list|(
name|AUTH_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"%s authentication failed.\n"
argument_list|,
name|scheme
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Clear per-request auth_baton when switching to next auth scheme. */
name|request
operator|->
name|auth_baton
operator|=
name|NULL
expr_stmt|;
comment|/* Remember failed auth types to skip in future. */
name|authn_info
operator|->
name|failed_authn_types
operator||=
name|scheme
operator|->
name|type
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * Baton passed to the store_header_in_dict callback function  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|header
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|apr_hash_t
modifier|*
name|hdrs
decl_stmt|;
block|}
name|auth_baton_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|store_header_in_dict
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|)
block|{
name|auth_baton_t
modifier|*
name|ab
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|auth_attr
decl_stmt|;
name|char
modifier|*
name|auth_name
decl_stmt|,
modifier|*
name|c
decl_stmt|;
comment|/* We're only interested in xxxx-Authenticate headers. */
if|if
condition|(
name|strcasecmp
argument_list|(
name|key
argument_list|,
name|ab
operator|->
name|header
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Extract the authentication scheme name.  */
name|auth_attr
operator|=
name|strchr
argument_list|(
name|header
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_attr
condition|)
block|{
name|auth_name
operator|=
name|apr_pstrmemdup
argument_list|(
name|ab
operator|->
name|pool
argument_list|,
name|header
argument_list|,
name|auth_attr
operator|-
name|header
argument_list|)
expr_stmt|;
block|}
else|else
name|auth_name
operator|=
name|apr_pstrmemdup
argument_list|(
name|ab
operator|->
name|pool
argument_list|,
name|header
argument_list|,
name|strlen
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert scheme name to lower case to enable case insensitive matching. */
for|for
control|(
name|c
operator|=
name|auth_name
init|;
operator|*
name|c
operator|!=
literal|'\0'
condition|;
name|c
operator|++
control|)
operator|*
name|c
operator|=
operator|(
name|char
operator|)
name|apr_tolower
argument_list|(
operator|*
name|c
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|ab
operator|->
name|hdrs
argument_list|,
name|auth_name
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|apr_pstrdup
argument_list|(
name|ab
operator|->
name|pool
argument_list|,
name|header
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Dispatch authentication handling. This function matches the possible    authentication mechanisms with those available. Server and proxy    authentication are evaluated separately. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|dispatch_auth
parameter_list|(
name|int
name|code
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|serf_bucket_t
modifier|*
name|hdrs
decl_stmt|;
if|if
condition|(
name|code
operator|==
literal|401
operator|||
name|code
operator|==
literal|407
condition|)
block|{
name|auth_baton_t
name|ab
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|auth_hdr
decl_stmt|;
name|ab
operator|.
name|hdrs
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|ab
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
comment|/* Before iterating over all authn headers, check if there are any. */
if|if
condition|(
name|code
operator|==
literal|401
condition|)
name|ab
operator|.
name|header
operator|=
literal|"WWW-Authenticate"
expr_stmt|;
else|else
name|ab
operator|.
name|header
operator|=
literal|"Proxy-Authenticate"
expr_stmt|;
name|hdrs
operator|=
name|serf_bucket_response_get_headers
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|auth_hdr
operator|=
name|serf_bucket_headers_get
argument_list|(
name|hdrs
argument_list|,
name|ab
operator|.
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|auth_hdr
condition|)
block|{
return|return
name|SERF_ERROR_AUTHN_FAILED
return|;
block|}
name|serf__log_skt
argument_list|(
name|AUTH_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|request
operator|->
name|conn
operator|->
name|skt
argument_list|,
literal|"%s authz required. Response header(s): %s\n"
argument_list|,
name|code
operator|==
literal|401
condition|?
literal|"Server"
else|:
literal|"Proxy"
argument_list|,
name|auth_hdr
argument_list|)
expr_stmt|;
comment|/* Store all WWW- or Proxy-Authenticate headers in a dictionary.             Note: it is possible to have multiple Authentication: headers. We do            not want to combine them (per normal header combination rules) as that            would make it hard to parse. Instead, we want to individually parse            and handle each header in the response, looking for one that we can            work with.         */
name|serf_bucket_headers_do
argument_list|(
name|hdrs
argument_list|,
name|store_header_in_dict
argument_list|,
operator|&
name|ab
argument_list|)
expr_stmt|;
comment|/* Iterate over all authentication schemes, in order of decreasing            security. Try to find a authentication schema the server support. */
return|return
name|handle_auth_headers
argument_list|(
name|code
argument_list|,
name|baton
argument_list|,
name|ab
operator|.
name|hdrs
argument_list|,
name|request
argument_list|,
name|response
argument_list|,
name|pool
argument_list|)
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Read the headers of the response and try the available    handlers if authentication or validation is needed. */
end_comment

begin_function
name|apr_status_t
name|serf__handle_auth_response
parameter_list|(
name|int
modifier|*
name|consumed_response
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|serf_status_line
name|sl
decl_stmt|;
operator|*
name|consumed_response
operator|=
literal|0
expr_stmt|;
comment|/* TODO: the response bucket was created by the application, not at all        guaranteed that this is of type response_bucket!! */
name|status
operator|=
name|serf_bucket_response_status
argument_list|(
name|response
argument_list|,
operator|&
name|sl
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|status
return|;
block|}
if|if
condition|(
operator|!
name|sl
operator|.
name|version
operator|&&
operator|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
operator|||
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|status
argument_list|)
operator|)
condition|)
block|{
return|return
name|status
return|;
block|}
name|status
operator|=
name|serf_bucket_response_wait_for_headers
argument_list|(
name|response
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
operator|!
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|status
return|;
block|}
comment|/* If status is APR_EOF, there were no headers to read.            This can be ok in some situations, and it definitely            means there's no authentication requested now. */
return|return
name|APR_SUCCESS
return|;
block|}
if|if
condition|(
name|sl
operator|.
name|code
operator|==
literal|401
operator|||
name|sl
operator|.
name|code
operator|==
literal|407
condition|)
block|{
comment|/* Authentication requested. */
comment|/* Don't bother handling the authentication request if the response            wasn't received completely yet. Serf will call serf__handle_auth_response            again when more data is received. */
name|status
operator|=
name|discard_body
argument_list|(
name|response
argument_list|)
expr_stmt|;
operator|*
name|consumed_response
operator|=
literal|1
expr_stmt|;
comment|/* Discard all response body before processing authentication. */
if|if
condition|(
operator|!
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|status
return|;
block|}
name|status
operator|=
name|dispatch_auth
argument_list|(
name|sl
operator|.
name|code
argument_list|,
name|request
argument_list|,
name|response
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|status
return|;
block|}
comment|/* Requeue the request with the necessary auth headers. */
comment|/* ### Application doesn't know about this request! */
if|if
condition|(
name|request
operator|->
name|ssltunnel
condition|)
block|{
name|serf__ssltunnel_request_create
argument_list|(
name|request
operator|->
name|conn
argument_list|,
name|request
operator|->
name|setup
argument_list|,
name|request
operator|->
name|setup_baton
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|serf_connection_priority_request_create
argument_list|(
name|request
operator|->
name|conn
argument_list|,
name|request
operator|->
name|setup
argument_list|,
name|request
operator|->
name|setup_baton
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_EOF
return|;
block|}
else|else
block|{
name|serf__validate_response_func_t
name|validate_resp
decl_stmt|;
name|serf_connection_t
modifier|*
name|conn
init|=
name|request
operator|->
name|conn
decl_stmt|;
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|serf__authn_info_t
modifier|*
name|authn_info
decl_stmt|;
name|apr_status_t
name|resp_status
init|=
name|APR_SUCCESS
decl_stmt|;
comment|/* Validate the response server authn headers. */
name|authn_info
operator|=
name|serf__get_authn_info_for_server
argument_list|(
name|conn
argument_list|)
expr_stmt|;
if|if
condition|(
name|authn_info
operator|->
name|scheme
condition|)
block|{
name|validate_resp
operator|=
name|authn_info
operator|->
name|scheme
operator|->
name|validate_response_func
expr_stmt|;
name|resp_status
operator|=
name|validate_resp
argument_list|(
name|authn_info
operator|->
name|scheme
argument_list|,
name|HOST
argument_list|,
name|sl
operator|.
name|code
argument_list|,
name|conn
argument_list|,
name|request
argument_list|,
name|response
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Validate the response proxy authn headers. */
name|authn_info
operator|=
operator|&
name|ctx
operator|->
name|proxy_authn_info
expr_stmt|;
if|if
condition|(
operator|!
name|resp_status
operator|&&
name|authn_info
operator|->
name|scheme
condition|)
block|{
name|validate_resp
operator|=
name|authn_info
operator|->
name|scheme
operator|->
name|validate_response_func
expr_stmt|;
name|resp_status
operator|=
name|validate_resp
argument_list|(
name|authn_info
operator|->
name|scheme
argument_list|,
name|PROXY
argument_list|,
name|sl
operator|.
name|code
argument_list|,
name|conn
argument_list|,
name|request
argument_list|,
name|response
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resp_status
condition|)
block|{
comment|/* If there was an error in the final step of the authentication,                consider the reponse body as invalid and discard it. */
name|status
operator|=
name|discard_body
argument_list|(
name|response
argument_list|)
expr_stmt|;
operator|*
name|consumed_response
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|status
return|;
block|}
comment|/* The whole body was discarded, now return our error. */
return|return
name|resp_status
return|;
block|}
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * base64 encode the authentication data and build an authentication  * header in this format:  * [SCHEME] [BASE64 of auth DATA]  */
end_comment

begin_function
name|void
name|serf__encode_auth_header
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|header
parameter_list|,
specifier|const
name|char
modifier|*
name|scheme
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|encoded_len
decl_stmt|,
name|scheme_len
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|encoded_len
operator|=
name|apr_base64_encode_len
argument_list|(
name|data_len
argument_list|)
expr_stmt|;
name|scheme_len
operator|=
name|strlen
argument_list|(
name|scheme
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|encoded_len
operator|+
name|scheme_len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|header
operator|=
name|ptr
expr_stmt|;
name|apr_cpystrn
argument_list|(
name|ptr
argument_list|,
name|scheme
argument_list|,
name|scheme_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|scheme_len
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|' '
expr_stmt|;
name|apr_base64_encode
argument_list|(
name|ptr
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|serf__construct_realm
parameter_list|(
name|peer_t
name|peer
parameter_list|,
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
specifier|const
name|char
modifier|*
name|realm_name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|peer
operator|==
name|HOST
condition|)
block|{
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"<%s://%s:%d> %s"
argument_list|,
name|conn
operator|->
name|host_info
operator|.
name|scheme
argument_list|,
name|conn
operator|->
name|host_info
operator|.
name|hostname
argument_list|,
name|conn
operator|->
name|host_info
operator|.
name|port
argument_list|,
name|realm_name
argument_list|)
return|;
block|}
else|else
block|{
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"<http://%s:%d> %s"
argument_list|,
name|ctx
operator|->
name|proxy_address
operator|->
name|hostname
argument_list|,
name|ctx
operator|->
name|proxy_address
operator|->
name|port
argument_list|,
name|realm_name
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|serf__authn_info_t
modifier|*
name|serf__get_authn_info_for_server
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|)
block|{
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|serf__authn_info_t
modifier|*
name|authn_info
decl_stmt|;
name|authn_info
operator|=
name|apr_hash_get
argument_list|(
name|ctx
operator|->
name|server_authn_info
argument_list|,
name|conn
operator|->
name|host_url
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|authn_info
condition|)
block|{
name|authn_info
operator|=
name|apr_pcalloc
argument_list|(
name|ctx
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|serf__authn_info_t
argument_list|)
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|ctx
operator|->
name|server_authn_info
argument_list|,
name|apr_pstrdup
argument_list|(
name|ctx
operator|->
name|pool
argument_list|,
name|conn
operator|->
name|host_url
argument_list|)
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|authn_info
argument_list|)
expr_stmt|;
block|}
return|return
name|authn_info
return|;
block|}
end_function

end_unit

