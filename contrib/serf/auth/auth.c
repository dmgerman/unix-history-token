begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2009 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"serf.h"
end_include

begin_include
include|#
directive|include
file|"serf_private.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<apr_base64.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_function
specifier|static
name|apr_status_t
name|default_auth_response_handler
parameter_list|(
name|peer_t
name|peer
parameter_list|,
name|int
name|code
parameter_list|,
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|serf__authn_scheme_t
name|serf_authn_schemes
index|[]
init|=
block|{
block|{
literal|401
block|,
literal|"Basic"
block|,
name|SERF_AUTHN_BASIC
block|,
name|serf__init_basic
block|,
name|serf__init_basic_connection
block|,
name|serf__handle_basic_auth
block|,
name|serf__setup_request_basic_auth
block|,
name|default_auth_response_handler
block|,     }
block|,
block|{
literal|407
block|,
literal|"Basic"
block|,
name|SERF_AUTHN_BASIC
block|,
name|serf__init_basic
block|,
name|serf__init_basic_connection
block|,
name|serf__handle_basic_auth
block|,
name|serf__setup_request_basic_auth
block|,
name|default_auth_response_handler
block|,     }
block|,
block|{
literal|401
block|,
literal|"Digest"
block|,
name|SERF_AUTHN_DIGEST
block|,
name|serf__init_digest
block|,
name|serf__init_digest_connection
block|,
name|serf__handle_digest_auth
block|,
name|serf__setup_request_digest_auth
block|,
name|serf__validate_response_digest_auth
block|,     }
block|,
block|{
literal|407
block|,
literal|"Digest"
block|,
name|SERF_AUTHN_DIGEST
block|,
name|serf__init_digest
block|,
name|serf__init_digest_connection
block|,
name|serf__handle_digest_auth
block|,
name|serf__setup_request_digest_auth
block|,
name|serf__validate_response_digest_auth
block|,     }
block|,
ifdef|#
directive|ifdef
name|SERF_HAVE_KERB
block|{
literal|401
block|,
literal|"Negotiate"
block|,
name|SERF_AUTHN_NEGOTIATE
block|,
name|serf__init_kerb
block|,
name|serf__init_kerb_connection
block|,
name|serf__handle_kerb_auth
block|,
name|serf__setup_request_kerb_auth
block|,
name|serf__validate_response_kerb_auth
block|,     }
block|,
block|{
literal|407
block|,
literal|"Negotiate"
block|,
name|SERF_AUTHN_NEGOTIATE
block|,
name|serf__init_kerb
block|,
name|serf__init_kerb_connection
block|,
name|serf__handle_kerb_auth
block|,
name|serf__setup_request_kerb_auth
block|,
name|serf__validate_response_kerb_auth
block|,     }
block|,
endif|#
directive|endif
comment|/* ADD NEW AUTHENTICATION IMPLEMENTATIONS HERE (as they're written) */
comment|/* sentinel */
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Baton passed to the response header callback function  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|code
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|header
decl_stmt|;
name|serf_request_t
modifier|*
name|request
decl_stmt|;
name|serf_bucket_t
modifier|*
name|response
decl_stmt|;
name|void
modifier|*
name|baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
specifier|const
name|serf__authn_scheme_t
modifier|*
name|scheme
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_scheme_name
decl_stmt|;
block|}
name|auth_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Reads and discards all bytes in the response body. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|discard_body
parameter_list|(
name|serf_bucket_t
modifier|*
name|response
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|status
operator|=
name|serf_bucket_read
argument_list|(
name|response
argument_list|,
name|SERF_READ_ALL_AVAIL
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
comment|/* feed me */
block|}
block|}
end_function

begin_comment
comment|/**  * handle_auth_header is called for each header in the response. It filters  * out the Authenticate headers (WWW or Proxy depending on what's needed) and  * tries to find a matching scheme handler.  *  * Returns a non-0 value of a matching handler was found.  */
end_comment

begin_function
specifier|static
name|int
name|handle_auth_header
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|)
block|{
name|auth_baton_t
modifier|*
name|ab
init|=
name|baton
decl_stmt|;
name|int
name|scheme_found
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|auth_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|auth_attr
decl_stmt|;
specifier|const
name|serf__authn_scheme_t
modifier|*
name|scheme
init|=
name|NULL
decl_stmt|;
name|serf_connection_t
modifier|*
name|conn
init|=
name|ab
operator|->
name|request
operator|->
name|conn
decl_stmt|;
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
comment|/* We're only interested in xxxx-Authenticate headers. */
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|ab
operator|->
name|header
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Extract the authentication scheme name, and prepare for reading        the attributes.  */
name|auth_attr
operator|=
name|strchr
argument_list|(
name|header
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_attr
condition|)
block|{
name|auth_name
operator|=
name|apr_pstrmemdup
argument_list|(
name|ab
operator|->
name|pool
argument_list|,
name|header
argument_list|,
name|auth_attr
operator|-
name|header
argument_list|)
expr_stmt|;
operator|++
name|auth_attr
expr_stmt|;
block|}
else|else
name|auth_name
operator|=
name|header
expr_stmt|;
name|ab
operator|->
name|last_scheme_name
operator|=
name|auth_name
expr_stmt|;
comment|/* Find the matching authentication handler.        Note that we don't reuse the auth scheme stored in the context,        as that may have changed. (ex. fallback from ntlm to basic.) */
for|for
control|(
name|scheme
operator|=
name|serf_authn_schemes
init|;
name|scheme
operator|->
name|code
operator|!=
literal|0
condition|;
operator|++
name|scheme
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|ab
operator|->
name|code
operator|==
name|scheme
operator|->
name|code
operator|&&
name|ctx
operator|->
name|authn_types
operator|&
name|scheme
operator|->
name|type
operator|)
condition|)
continue|continue;
name|serf__log_skt
argument_list|(
name|AUTH_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"Client supports: %s\n"
argument_list|,
name|scheme
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|auth_name
argument_list|,
name|scheme
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|serf__auth_handler_func_t
name|handler
init|=
name|scheme
operator|->
name|handle_func
decl_stmt|;
name|apr_status_t
name|status
init|=
literal|0
decl_stmt|;
name|serf__log_skt
argument_list|(
name|AUTH_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"... matched: %s\n"
argument_list|,
name|scheme
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* If this is the first time we use this scheme on this connection,                make sure to initialize the authentication handler first. */
if|if
condition|(
name|ab
operator|->
name|code
operator|==
literal|401
operator|&&
name|ctx
operator|->
name|authn_info
operator|.
name|scheme
operator|!=
name|scheme
condition|)
block|{
name|status
operator|=
name|scheme
operator|->
name|init_ctx_func
argument_list|(
name|ab
operator|->
name|code
argument_list|,
name|ctx
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
block|{
name|status
operator|=
name|scheme
operator|->
name|init_conn_func
argument_list|(
name|ab
operator|->
name|code
argument_list|,
name|conn
argument_list|,
name|conn
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
name|ctx
operator|->
name|authn_info
operator|.
name|scheme
operator|=
name|scheme
expr_stmt|;
else|else
name|ctx
operator|->
name|authn_info
operator|.
name|scheme
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ab
operator|->
name|code
operator|==
literal|407
operator|&&
name|ctx
operator|->
name|proxy_authn_info
operator|.
name|scheme
operator|!=
name|scheme
condition|)
block|{
name|status
operator|=
name|scheme
operator|->
name|init_ctx_func
argument_list|(
name|ab
operator|->
name|code
argument_list|,
name|ctx
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
block|{
name|status
operator|=
name|scheme
operator|->
name|init_conn_func
argument_list|(
name|ab
operator|->
name|code
argument_list|,
name|conn
argument_list|,
name|conn
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
name|ctx
operator|->
name|proxy_authn_info
operator|.
name|scheme
operator|=
name|scheme
expr_stmt|;
else|else
name|ctx
operator|->
name|proxy_authn_info
operator|.
name|scheme
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|status
condition|)
block|{
name|scheme_found
operator|=
name|TRUE
expr_stmt|;
name|ab
operator|->
name|scheme
operator|=
name|scheme
expr_stmt|;
name|status
operator|=
name|handler
argument_list|(
name|ab
operator|->
name|code
argument_list|,
name|ab
operator|->
name|request
argument_list|,
name|ab
operator|->
name|response
argument_list|,
name|header
argument_list|,
name|auth_attr
argument_list|,
name|ab
operator|->
name|baton
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* If the authentication fails, cache the error for now. Try the                next available scheme. If there's none raise the error. */
if|if
condition|(
name|status
condition|)
block|{
name|scheme_found
operator|=
name|FALSE
expr_stmt|;
name|scheme
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Let the caller now if the authentication setup was succesful                or not. */
name|ab
operator|->
name|status
operator|=
name|status
expr_stmt|;
break|break;
block|}
block|}
comment|/* If a matching scheme handler was found, we can stop iterating        over the response headers - so return a non-0 value. */
return|return
name|scheme_found
return|;
block|}
end_function

begin_comment
comment|/* Dispatch authentication handling. This function matches the possible    authentication mechanisms with those available. Server and proxy    authentication are evaluated separately. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|dispatch_auth
parameter_list|(
name|int
name|code
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|serf_bucket_t
modifier|*
name|hdrs
decl_stmt|;
if|if
condition|(
name|code
operator|==
literal|401
operator|||
name|code
operator|==
literal|407
condition|)
block|{
name|auth_baton_t
name|ab
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|auth_hdr
decl_stmt|;
name|ab
operator|.
name|code
operator|=
name|code
expr_stmt|;
name|ab
operator|.
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
name|ab
operator|.
name|request
operator|=
name|request
expr_stmt|;
name|ab
operator|.
name|response
operator|=
name|response
expr_stmt|;
name|ab
operator|.
name|baton
operator|=
name|baton
expr_stmt|;
name|ab
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
comment|/* Before iterating over all authn headers, check if there are any. */
if|if
condition|(
name|code
operator|==
literal|401
condition|)
name|ab
operator|.
name|header
operator|=
literal|"WWW-Authenticate"
expr_stmt|;
else|else
name|ab
operator|.
name|header
operator|=
literal|"Proxy-Authenticate"
expr_stmt|;
name|hdrs
operator|=
name|serf_bucket_response_get_headers
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|auth_hdr
operator|=
name|serf_bucket_headers_get
argument_list|(
name|hdrs
argument_list|,
name|ab
operator|.
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|auth_hdr
condition|)
block|{
return|return
name|SERF_ERROR_AUTHN_FAILED
return|;
block|}
name|serf__log_skt
argument_list|(
name|AUTH_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|request
operator|->
name|conn
operator|->
name|skt
argument_list|,
literal|"%s authz required. Response header(s): %s\n"
argument_list|,
name|code
operator|==
literal|401
condition|?
literal|"Server"
else|:
literal|"Proxy"
argument_list|,
name|auth_hdr
argument_list|)
expr_stmt|;
comment|/* Iterate over all headers. Try to find a matching authentication scheme            handler.             Note: it is possible to have multiple Authentication: headers. We do            not want to combine them (per normal header combination rules) as that            would make it hard to parse. Instead, we want to individually parse            and handle each header in the response, looking for one that we can            work with.         */
name|serf_bucket_headers_do
argument_list|(
name|hdrs
argument_list|,
name|handle_auth_header
argument_list|,
operator|&
name|ab
argument_list|)
expr_stmt|;
if|if
condition|(
name|ab
operator|.
name|status
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|ab
operator|.
name|status
return|;
if|if
condition|(
operator|!
name|ab
operator|.
name|scheme
operator|||
name|ab
operator|.
name|scheme
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* No matching authentication found. */
return|return
name|SERF_ERROR_AUTHN_NOT_SUPPORTED
return|;
block|}
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Read the headers of the response and try the available    handlers if authentication or validation is needed. */
end_comment

begin_function
name|apr_status_t
name|serf__handle_auth_response
parameter_list|(
name|int
modifier|*
name|consumed_response
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|serf_status_line
name|sl
decl_stmt|;
operator|*
name|consumed_response
operator|=
literal|0
expr_stmt|;
comment|/* TODO: the response bucket was created by the application, not at all        guaranteed that this is of type response_bucket!! */
name|status
operator|=
name|serf_bucket_response_status
argument_list|(
name|response
argument_list|,
operator|&
name|sl
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERF_BUCKET_READ_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|status
return|;
block|}
if|if
condition|(
operator|!
name|sl
operator|.
name|version
operator|&&
operator|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
operator|||
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|status
argument_list|)
operator|)
condition|)
block|{
return|return
name|status
return|;
block|}
name|status
operator|=
name|serf_bucket_response_wait_for_headers
argument_list|(
name|response
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
operator|!
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|status
return|;
block|}
comment|/* If status is APR_EOF, there were no headers to read.            This can be ok in some situations, and it definitely            means there's no authentication requested now. */
return|return
name|APR_SUCCESS
return|;
block|}
if|if
condition|(
name|sl
operator|.
name|code
operator|==
literal|401
operator|||
name|sl
operator|.
name|code
operator|==
literal|407
condition|)
block|{
comment|/* Authentication requested. */
comment|/* Don't bother handling the authentication request if the response            wasn't received completely yet. Serf will call serf__handle_auth_response            again when more data is received. */
name|status
operator|=
name|discard_body
argument_list|(
name|response
argument_list|)
expr_stmt|;
operator|*
name|consumed_response
operator|=
literal|1
expr_stmt|;
comment|/* Discard all response body before processing authentication. */
if|if
condition|(
operator|!
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|status
return|;
block|}
name|status
operator|=
name|dispatch_auth
argument_list|(
name|sl
operator|.
name|code
argument_list|,
name|request
argument_list|,
name|response
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|status
return|;
block|}
comment|/* Requeue the request with the necessary auth headers. */
comment|/* ### Application doesn't know about this request! */
name|serf_connection_priority_request_create
argument_list|(
name|request
operator|->
name|conn
argument_list|,
name|request
operator|->
name|setup
argument_list|,
name|request
operator|->
name|setup_baton
argument_list|)
expr_stmt|;
return|return
name|APR_EOF
return|;
block|}
else|else
block|{
comment|/* Validate the response authn headers if needed. */
name|serf__validate_response_func_t
name|validate_resp
decl_stmt|;
name|serf_connection_t
modifier|*
name|conn
init|=
name|request
operator|->
name|conn
decl_stmt|;
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|apr_status_t
name|resp_status
init|=
name|APR_SUCCESS
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|authn_info
operator|.
name|scheme
condition|)
block|{
name|validate_resp
operator|=
name|ctx
operator|->
name|authn_info
operator|.
name|scheme
operator|->
name|validate_response_func
expr_stmt|;
name|resp_status
operator|=
name|validate_resp
argument_list|(
name|HOST
argument_list|,
name|sl
operator|.
name|code
argument_list|,
name|conn
argument_list|,
name|request
argument_list|,
name|response
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|resp_status
operator|&&
name|ctx
operator|->
name|proxy_authn_info
operator|.
name|scheme
condition|)
block|{
name|validate_resp
operator|=
name|ctx
operator|->
name|proxy_authn_info
operator|.
name|scheme
operator|->
name|validate_response_func
expr_stmt|;
name|resp_status
operator|=
name|validate_resp
argument_list|(
name|PROXY
argument_list|,
name|sl
operator|.
name|code
argument_list|,
name|conn
argument_list|,
name|request
argument_list|,
name|response
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resp_status
condition|)
block|{
comment|/* If there was an error in the final step of the authentication,                consider the reponse body as invalid and discard it. */
name|status
operator|=
name|discard_body
argument_list|(
name|response
argument_list|)
expr_stmt|;
operator|*
name|consumed_response
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
name|status
return|;
block|}
comment|/* The whole body was discarded, now return our error. */
return|return
name|resp_status
return|;
block|}
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * base64 encode the authentication data and build an authentication  * header in this format:  * [SCHEME] [BASE64 of auth DATA]  */
end_comment

begin_function
name|void
name|serf__encode_auth_header
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|header
parameter_list|,
specifier|const
name|char
modifier|*
name|scheme
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|encoded_len
decl_stmt|,
name|scheme_len
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|encoded_len
operator|=
name|apr_base64_encode_len
argument_list|(
name|data_len
argument_list|)
expr_stmt|;
name|scheme_len
operator|=
name|strlen
argument_list|(
name|scheme
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|encoded_len
operator|+
name|scheme_len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|header
operator|=
name|ptr
expr_stmt|;
name|apr_cpystrn
argument_list|(
name|ptr
argument_list|,
name|scheme
argument_list|,
name|scheme_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|scheme_len
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|' '
expr_stmt|;
name|apr_base64_encode
argument_list|(
name|ptr
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

