begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2009 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"auth_spnego.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SERF_HAVE_SPNEGO
end_ifdef

begin_comment
comment|/** These functions implement SPNEGO-based Kerberos and NTLM authentication,  *  using either GSS-API (RFC 2743) or SSPI on Windows.  *  The HTTP message exchange is documented in RFC 4559.  **/
end_comment

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|<serf_private.h>
end_include

begin_include
include|#
directive|include
file|<auth/auth.h>
end_include

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<apr_base64.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_comment
comment|/** TODO:  ** - send session key directly on new connections where we already know  **   the server requires Kerberos authn.  ** - Add a way for serf to give detailed error information back to the  **   application.  **/
end_comment

begin_comment
comment|/* Authentication over HTTP using Kerberos  *  * Kerberos involves three servers:  * - Authentication Server (AS): verifies users during login  * - Ticket-Granting Server (TGS): issues proof of identity tickets  * - HTTP server (S)  *  * Steps:  * 0. User logs in to the AS and receives a TGS ticket. On workstations  * where the login program doesn't support Kerberos, the user can use  * 'kinit'.  *  * 1. C  --> S:    GET  *  *    C<--  S:    401 Authentication Required  *                 WWW-Authenticate: Negotiate  *  * -> app contacts the TGS to request a session key for the HTTP service  *    @ target host. The returned session key is encrypted with the HTTP  *    service's secret key, so we can safely send it to the server.  *  * 2. C  --> S:    GET  *                 Authorization: Negotiate<Base64 encoded session key>  *                 gss_api_ctx->state = gss_api_auth_in_progress;  *  *    C<--  S:    200 OK  *                 WWW-Authenticate: Negotiate<Base64 encoded server  *                                              authentication data>  *  * -> The server returned an (optional) key to proof itself to us. We check this  *    key with the TGS again. If it checks out, we can return the response  *    body to the application.  *  * Note: It's possible that the server returns 401 again in step 2, if the  *       Kerberos context isn't complete yet. This means there is 3rd step  *       where we'll send a request with an Authorization header to the   *       server. Some (simple) tests with mod_auth_kerb and MIT Kerberos 5 show  *       this never happens.  *  * Depending on the type of HTTP server, this handshake is required for either  * every new connection, or for every new request! For more info see the next  * comment on authn_persistence_state_t.  *  * Note: Step 1 of the handshake will only happen on the first connection, once  * we know the server requires Kerberos authentication, the initial requests  * on the other connections will include a session key, so we start at  * step 2 in the handshake.  * ### TODO: Not implemented yet!  */
end_comment

begin_comment
comment|/* Current state of the authentication of the current request. */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|gss_api_auth_not_started
block|,
name|gss_api_auth_in_progress
block|,
name|gss_api_auth_completed
block|, }
name|gss_api_auth_state
typedef|;
end_typedef

begin_comment
comment|/**    authn_persistence_state_t: state that indicates if we are talking with a    server that requires authentication only of the first request (stateful),    or of each request (stateless).      INIT: Begin state. Authenticating the first request on this connection.    UNDECIDED: we haven't identified the server yet, assume STATEFUL for now.      Pipeline mode disabled, requests are sent only after the response off the      previous request arrived.    STATELESS: we know the server requires authentication for each request.      On all new requests add the Authorization header with an initial SPNEGO      token (created per request).      To keep things simple, keep the connection in one by one mode.      (otherwise we'd have to keep a queue of gssapi context objects to match       the Negotiate header of the response with the session initiated by the       mathing request).      This state is an final state.    STATEFUL: alright, we have authenticated the connection and for the server      that is enough. Don't add an Authorization header to new requests.      Serf will switch to pipelined mode.      This state is not a final state, although in practical scenario's it will      be. When we receive a 40x response from the server switch to STATELESS      mode.     We start in state init for the first request until it is authenticated.     The rest of the state machine starts with the arrival of the response to the    second request, and then goes on with each response:        --------       | INIT |     C --> S:    GET request in response to 40x of the server       --------                 add [Proxy]-Authorization header           |           |     ------------     | UNDECIDED|   C --> S:    GET request, assume stateful,     ------------               no [Proxy]-Authorization header           |           |           |------------------------------------------------           |                                               |           | C<-- S: 40x Authentication                   | C<-- S: 200 OK           |          Required                             |           |                                               |           v                                               v       -------------                               ------------     ->| STATELESS |<------------------------------| STATEFUL |<--     | -------------       C<-- S: 40x            ------------  |   * |    |                Authentication                  |     | 200 OK     |    /                Required                        |     |     -----                                                 -----/   **/
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|pstate_init
block|,
name|pstate_undecided
block|,
name|pstate_stateless
block|,
name|pstate_stateful
block|, }
name|authn_persistence_state_t
typedef|;
end_typedef

begin_comment
comment|/* HTTP Service name, used to get the session key.  */
end_comment

begin_define
define|#
directive|define
name|KRB_HTTP_SERVICE
value|"HTTP"
end_define

begin_comment
comment|/* Stores the context information related to Kerberos authentication. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* GSSAPI context */
name|serf__spnego_context_t
modifier|*
name|gss_ctx
decl_stmt|;
comment|/* Current state of the authentication cycle. */
name|gss_api_auth_state
name|state
decl_stmt|;
comment|/* Current persistence state. */
name|authn_persistence_state_t
name|pstate
decl_stmt|;
specifier|const
name|char
modifier|*
name|header
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
block|}
name|gss_authn_info_t
typedef|;
end_typedef

begin_comment
comment|/* On the initial 401 response of the server, request a session key from    the Kerberos KDC to pass to the server, proving that we are who we    claim to be. The session key can only be used with the HTTP service    on the target host. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|gss_api_get_credentials
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|char
modifier|*
name|token
parameter_list|,
name|apr_size_t
name|token_len
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|buf_len
parameter_list|,
name|gss_authn_info_t
modifier|*
name|gss_info
parameter_list|)
block|{
name|serf__spnego_buffer_t
name|input_buf
decl_stmt|;
name|serf__spnego_buffer_t
name|output_buf
decl_stmt|;
name|apr_status_t
name|status
init|=
name|APR_SUCCESS
decl_stmt|;
comment|/* If the server sent us a token, pass it to gss_init_sec_token for        validation. */
if|if
condition|(
name|token
condition|)
block|{
name|input_buf
operator|.
name|value
operator|=
name|token
expr_stmt|;
name|input_buf
operator|.
name|length
operator|=
name|token_len
expr_stmt|;
block|}
else|else
block|{
name|input_buf
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|input_buf
operator|.
name|length
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Establish a security context to the server. */
name|status
operator|=
name|serf__spnego_init_sec_context
argument_list|(
name|conn
argument_list|,
name|gss_info
operator|->
name|gss_ctx
argument_list|,
name|KRB_HTTP_SERVICE
argument_list|,
name|hostname
argument_list|,
operator|&
name|input_buf
argument_list|,
operator|&
name|output_buf
argument_list|,
name|gss_info
operator|->
name|pool
argument_list|,
name|gss_info
operator|->
name|pool
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|APR_SUCCESS
case|:
if|if
condition|(
name|output_buf
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|gss_info
operator|->
name|state
operator|=
name|gss_api_auth_completed
expr_stmt|;
block|}
else|else
block|{
name|gss_info
operator|->
name|state
operator|=
name|gss_api_auth_in_progress
expr_stmt|;
block|}
break|break;
case|case
name|APR_EAGAIN
case|:
name|gss_info
operator|->
name|state
operator|=
name|gss_api_auth_in_progress
expr_stmt|;
name|status
operator|=
name|APR_SUCCESS
expr_stmt|;
break|break;
default|default:
return|return
name|status
return|;
block|}
comment|/* Return the session key to our caller. */
operator|*
name|buf
operator|=
name|output_buf
operator|.
name|value
expr_stmt|;
operator|*
name|buf_len
operator|=
name|output_buf
operator|.
name|length
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* do_auth is invoked in two situations:    - when a response from a server is received that contains an authn header      (either from a 40x or 2xx response)    - when a request is prepared on a connection with stateless authentication.     Read the header sent by the server (if any), invoke the gssapi authn    code and use the resulting Server Ticket on the next request to the    server. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|do_auth
parameter_list|(
name|peer_t
name|peer
parameter_list|,
name|int
name|code
parameter_list|,
name|gss_authn_info_t
modifier|*
name|gss_info
parameter_list|,
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
specifier|const
name|char
modifier|*
name|auth_hdr
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|serf__authn_info_t
modifier|*
name|authn_info
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|token
init|=
name|NULL
decl_stmt|;
name|apr_size_t
name|tmp_len
init|=
literal|0
decl_stmt|,
name|token_len
init|=
literal|0
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
if|if
condition|(
name|peer
operator|==
name|HOST
condition|)
block|{
name|authn_info
operator|=
name|serf__get_authn_info_for_server
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|authn_info
operator|=
operator|&
name|ctx
operator|->
name|proxy_authn_info
expr_stmt|;
block|}
comment|/* Is this a response from a host/proxy? auth_hdr should always be set. */
if|if
condition|(
name|code
operator|&&
name|auth_hdr
condition|)
block|{
specifier|const
name|char
modifier|*
name|space
init|=
name|NULL
decl_stmt|;
comment|/* The server will return a token as attribute to the Negotiate key.            Negotiate YGwGCSqGSIb3EgECAgIAb10wW6ADAgEFoQMCAQ+iTzBNoAMCARCiRgREa6            mouMBAMFqKVdTGtfpZNXKzyw4Yo1paphJdIA3VOgncaoIlXxZLnkHiIHS2v65pVvrp            bRIyjF8xve9HxpnNIucCY9c=             Read this base64 value, decode it and validate it so we're sure the            server is who we expect it to be. */
name|space
operator|=
name|strchr
argument_list|(
name|auth_hdr
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
condition|)
block|{
name|token
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|apr_base64_decode_len
argument_list|(
name|space
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|token_len
operator|=
name|apr_base64_decode
argument_list|(
name|token
argument_list|,
name|space
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is a new request, not a retry in response to a 40x of the            host/proxy.             Only add the Authorization header if we know the server requires            per-request authentication (stateless). */
if|if
condition|(
name|gss_info
operator|->
name|pstate
operator|!=
name|pstate_stateless
condition|)
return|return
name|APR_SUCCESS
return|;
block|}
switch|switch
condition|(
name|gss_info
operator|->
name|pstate
condition|)
block|{
case|case
name|pstate_init
case|:
comment|/* Nothing to do here */
break|break;
case|case
name|pstate_undecided
case|:
comment|/* Fall through */
case|case
name|pstate_stateful
case|:
block|{
comment|/* Switch to stateless mode, from now on handle authentication                    of each request with a new gss context. This is easiest to                    manage when sending requests one by one. */
name|serf__log_skt
argument_list|(
name|AUTH_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"Server requires per-request SPNEGO authn, "
literal|"switching to stateless mode.\n"
argument_list|)
expr_stmt|;
name|gss_info
operator|->
name|pstate
operator|=
name|pstate_stateless
expr_stmt|;
name|serf_connection_set_max_outstanding_requests
argument_list|(
name|conn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|pstate_stateless
case|:
comment|/* Nothing to do here */
break|break;
block|}
if|if
condition|(
name|request
operator|->
name|auth_baton
operator|&&
operator|!
name|token
condition|)
block|{
comment|/* We provided token with this request, but server responded with empty            authentication header. This means server rejected our credentials.            XXX: Probably we need separate error code for this case like            SERF_ERROR_AUTHN_CREDS_REJECTED? */
return|return
name|SERF_ERROR_AUTHN_FAILED
return|;
block|}
comment|/* If the server didn't provide us with a token, start with a new initial        step in the SPNEGO authentication. */
if|if
condition|(
operator|!
name|token
condition|)
block|{
name|serf__spnego_reset_sec_context
argument_list|(
name|gss_info
operator|->
name|gss_ctx
argument_list|)
expr_stmt|;
name|gss_info
operator|->
name|state
operator|=
name|gss_api_auth_not_started
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|==
name|HOST
condition|)
block|{
name|status
operator|=
name|gss_api_get_credentials
argument_list|(
name|conn
argument_list|,
name|token
argument_list|,
name|token_len
argument_list|,
name|conn
operator|->
name|host_info
operator|.
name|hostname
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|tmp_len
argument_list|,
name|gss_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|proxy_host
init|=
name|conn
operator|->
name|ctx
operator|->
name|proxy_address
operator|->
name|hostname
decl_stmt|;
name|status
operator|=
name|gss_api_get_credentials
argument_list|(
name|conn
argument_list|,
name|token
argument_list|,
name|token_len
argument_list|,
name|proxy_host
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|tmp_len
argument_list|,
name|gss_info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
comment|/* On the next request, add an Authorization header. */
if|if
condition|(
name|tmp_len
condition|)
block|{
name|serf__encode_auth_header
argument_list|(
operator|&
name|gss_info
operator|->
name|value
argument_list|,
name|authn_info
operator|->
name|scheme
operator|->
name|name
argument_list|,
name|tmp
argument_list|,
name|tmp_len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|gss_info
operator|->
name|header
operator|=
operator|(
name|peer
operator|==
name|HOST
operator|)
condition|?
literal|"Authorization"
else|:
literal|"Proxy-Authorization"
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf__init_spnego
parameter_list|(
name|int
name|code
parameter_list|,
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* A new connection is created to a server that's known to use    Kerberos. */
end_comment

begin_function
name|apr_status_t
name|serf__init_spnego_connection
parameter_list|(
specifier|const
name|serf__authn_scheme_t
modifier|*
name|scheme
parameter_list|,
name|int
name|code
parameter_list|,
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|serf__authn_info_t
modifier|*
name|authn_info
decl_stmt|;
name|gss_authn_info_t
modifier|*
name|gss_info
init|=
name|NULL
decl_stmt|;
comment|/* For proxy authentication, reuse the gss context for all connections.         For server authentication, create a new gss context per connection. */
if|if
condition|(
name|code
operator|==
literal|401
condition|)
block|{
name|authn_info
operator|=
operator|&
name|conn
operator|->
name|authn_info
expr_stmt|;
block|}
else|else
block|{
name|authn_info
operator|=
operator|&
name|ctx
operator|->
name|proxy_authn_info
expr_stmt|;
block|}
name|gss_info
operator|=
name|authn_info
operator|->
name|baton
expr_stmt|;
if|if
condition|(
operator|!
name|gss_info
condition|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|gss_info
operator|=
name|apr_pcalloc
argument_list|(
name|conn
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gss_info
argument_list|)
argument_list|)
expr_stmt|;
name|gss_info
operator|->
name|pool
operator|=
name|conn
operator|->
name|pool
expr_stmt|;
name|gss_info
operator|->
name|state
operator|=
name|gss_api_auth_not_started
expr_stmt|;
name|gss_info
operator|->
name|pstate
operator|=
name|pstate_init
expr_stmt|;
name|status
operator|=
name|serf__spnego_create_sec_context
argument_list|(
operator|&
name|gss_info
operator|->
name|gss_ctx
argument_list|,
name|scheme
argument_list|,
name|gss_info
operator|->
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
name|authn_info
operator|->
name|baton
operator|=
name|gss_info
expr_stmt|;
block|}
comment|/* Make serf send the initial requests one by one */
name|serf_connection_set_max_outstanding_requests
argument_list|(
name|conn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|serf__log_skt
argument_list|(
name|AUTH_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"Initialized Kerberos context for this connection.\n"
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* A 40x response was received, handle the authentication. */
end_comment

begin_function
name|apr_status_t
name|serf__handle_spnego_auth
parameter_list|(
name|int
name|code
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
specifier|const
name|char
modifier|*
name|auth_hdr
parameter_list|,
specifier|const
name|char
modifier|*
name|auth_attr
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|serf_connection_t
modifier|*
name|conn
init|=
name|request
operator|->
name|conn
decl_stmt|;
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|gss_authn_info_t
modifier|*
name|gss_info
init|=
operator|(
name|code
operator|==
literal|401
operator|)
condition|?
name|conn
operator|->
name|authn_info
operator|.
name|baton
else|:
name|ctx
operator|->
name|proxy_authn_info
operator|.
name|baton
decl_stmt|;
return|return
name|do_auth
argument_list|(
name|code
operator|==
literal|401
condition|?
name|HOST
else|:
name|PROXY
argument_list|,
name|code
argument_list|,
name|gss_info
argument_list|,
name|request
operator|->
name|conn
argument_list|,
name|request
argument_list|,
name|auth_hdr
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Setup the authn headers on this request message. */
end_comment

begin_function
name|apr_status_t
name|serf__setup_request_spnego_auth
parameter_list|(
name|peer_t
name|peer
parameter_list|,
name|int
name|code
parameter_list|,
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|,
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|serf_bucket_t
modifier|*
name|hdrs_bkt
parameter_list|)
block|{
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|gss_authn_info_t
modifier|*
name|gss_info
init|=
operator|(
name|peer
operator|==
name|HOST
operator|)
condition|?
name|conn
operator|->
name|authn_info
operator|.
name|baton
else|:
name|ctx
operator|->
name|proxy_authn_info
operator|.
name|baton
decl_stmt|;
comment|/* If we have an ongoing authentication handshake, the handler of the        previous response will have created the authn headers for this request        already. */
if|if
condition|(
name|gss_info
operator|&&
name|gss_info
operator|->
name|header
operator|&&
name|gss_info
operator|->
name|value
condition|)
block|{
name|serf__log_skt
argument_list|(
name|AUTH_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"Set Negotiate authn header on retried request.\n"
argument_list|)
expr_stmt|;
name|serf_bucket_headers_setn
argument_list|(
name|hdrs_bkt
argument_list|,
name|gss_info
operator|->
name|header
argument_list|,
name|gss_info
operator|->
name|value
argument_list|)
expr_stmt|;
comment|/* Remember that we're using this request for authentication            handshake. */
name|request
operator|->
name|auth_baton
operator|=
operator|(
name|void
operator|*
operator|)
name|TRUE
expr_stmt|;
comment|/* We should send each token only once. */
name|gss_info
operator|->
name|header
operator|=
name|NULL
expr_stmt|;
name|gss_info
operator|->
name|value
operator|=
name|NULL
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
switch|switch
condition|(
name|gss_info
operator|->
name|pstate
condition|)
block|{
case|case
name|pstate_init
case|:
comment|/* We shouldn't normally arrive here, do nothing. */
break|break;
case|case
name|pstate_undecided
case|:
comment|/* fall through */
name|serf__log_skt
argument_list|(
name|AUTH_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"Assume for now that the server supports persistent "
literal|"SPNEGO authentication.\n"
argument_list|)
expr_stmt|;
comment|/* Nothing to do here. */
break|break;
case|case
name|pstate_stateful
case|:
name|serf__log_skt
argument_list|(
name|AUTH_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"SPNEGO on this connection is persistent, "
literal|"don't set authn header on next request.\n"
argument_list|)
expr_stmt|;
comment|/* Nothing to do here. */
break|break;
case|case
name|pstate_stateless
case|:
block|{
name|apr_status_t
name|status
decl_stmt|;
comment|/* Authentication on this connection is known to be stateless.                    Add an initial Negotiate token for the server, to bypass the                    40x response we know we'll otherwise receive.                   (RFC 4559 section 4.2) */
name|serf__log_skt
argument_list|(
name|AUTH_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"Add initial Negotiate header to request.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|do_auth
argument_list|(
name|peer
argument_list|,
name|code
argument_list|,
name|gss_info
argument_list|,
name|conn
argument_list|,
name|request
argument_list|,
literal|0l
argument_list|,
comment|/* no response authn header */
name|conn
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
name|serf_bucket_headers_setn
argument_list|(
name|hdrs_bkt
argument_list|,
name|gss_info
operator|->
name|header
argument_list|,
name|gss_info
operator|->
name|value
argument_list|)
expr_stmt|;
comment|/* Remember that we're using this request for authentication                    handshake. */
name|request
operator|->
name|auth_baton
operator|=
operator|(
name|void
operator|*
operator|)
name|TRUE
expr_stmt|;
comment|/* We should send each token only once. */
name|gss_info
operator|->
name|header
operator|=
name|NULL
expr_stmt|;
name|gss_info
operator|->
name|value
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * Baton passed to the get_auth_header callback function.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|hdr_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|auth_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|hdr_value
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|get_auth_header_baton_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|get_auth_header_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|)
block|{
name|get_auth_header_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
comment|/* We're only interested in xxxx-Authenticate headers. */
if|if
condition|(
name|strcasecmp
argument_list|(
name|key
argument_list|,
name|b
operator|->
name|hdr_name
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Check if header value starts with interesting auth name. */
if|if
condition|(
name|strncmp
argument_list|(
name|header
argument_list|,
name|b
operator|->
name|auth_name
argument_list|,
name|strlen
argument_list|(
name|b
operator|->
name|auth_name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Save interesting header value and stop iteration. */
name|b
operator|->
name|hdr_value
operator|=
name|apr_pstrdup
argument_list|(
name|b
operator|->
name|pool
argument_list|,
name|header
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_auth_header
parameter_list|(
name|serf_bucket_t
modifier|*
name|hdrs
parameter_list|,
specifier|const
name|char
modifier|*
name|hdr_name
parameter_list|,
specifier|const
name|char
modifier|*
name|auth_name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|get_auth_header_baton_t
name|b
decl_stmt|;
name|b
operator|.
name|auth_name
operator|=
name|hdr_name
expr_stmt|;
name|b
operator|.
name|hdr_name
operator|=
name|auth_name
expr_stmt|;
name|b
operator|.
name|hdr_value
operator|=
name|NULL
expr_stmt|;
name|b
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|serf_bucket_headers_do
argument_list|(
name|hdrs
argument_list|,
name|get_auth_header_cb
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
name|b
operator|.
name|hdr_value
return|;
block|}
end_function

begin_comment
comment|/* Function is called when 2xx responses are received. Normally we don't  * have to do anything, except for the first response after the  * authentication handshake. This specific response includes authentication  * data which should be validated by the client (mutual authentication).  */
end_comment

begin_function
name|apr_status_t
name|serf__validate_response_spnego_auth
parameter_list|(
specifier|const
name|serf__authn_scheme_t
modifier|*
name|scheme
parameter_list|,
name|peer_t
name|peer
parameter_list|,
name|int
name|code
parameter_list|,
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|gss_authn_info_t
modifier|*
name|gss_info
decl_stmt|;
specifier|const
name|char
modifier|*
name|auth_hdr_name
decl_stmt|;
comment|/* TODO: currently this function is only called when a response includes        an Authenticate header. This header is optional. If the server does        not provide this header on the first 2xx response, we will not promote        the connection from undecided to stateful. This won't break anything,        but means we stay in non-pipelining mode. */
name|serf__log_skt
argument_list|(
name|AUTH_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"Validate Negotiate response header.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|HOST
condition|)
block|{
name|gss_info
operator|=
name|conn
operator|->
name|authn_info
operator|.
name|baton
expr_stmt|;
name|auth_hdr_name
operator|=
literal|"WWW-Authenticate"
expr_stmt|;
block|}
else|else
block|{
name|gss_info
operator|=
name|ctx
operator|->
name|proxy_authn_info
operator|.
name|baton
expr_stmt|;
name|auth_hdr_name
operator|=
literal|"Proxy-Authenticate"
expr_stmt|;
block|}
if|if
condition|(
name|gss_info
operator|->
name|state
operator|!=
name|gss_api_auth_completed
condition|)
block|{
name|serf_bucket_t
modifier|*
name|hdrs
decl_stmt|;
specifier|const
name|char
modifier|*
name|auth_hdr_val
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|hdrs
operator|=
name|serf_bucket_response_get_headers
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|auth_hdr_val
operator|=
name|get_auth_header
argument_list|(
name|hdrs
argument_list|,
name|auth_hdr_name
argument_list|,
name|scheme
operator|->
name|name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_hdr_val
condition|)
block|{
name|status
operator|=
name|do_auth
argument_list|(
name|peer
argument_list|,
name|code
argument_list|,
name|gss_info
argument_list|,
name|conn
argument_list|,
name|request
argument_list|,
name|auth_hdr_val
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|status
return|;
block|}
block|}
else|else
block|{
comment|/* No Authenticate headers, nothing to validate: authentication                completed.*/
name|gss_info
operator|->
name|state
operator|=
name|gss_api_auth_completed
expr_stmt|;
name|serf__log_skt
argument_list|(
name|AUTH_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"SPNEGO handshake completed.\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gss_info
operator|->
name|state
operator|==
name|gss_api_auth_completed
condition|)
block|{
switch|switch
condition|(
name|gss_info
operator|->
name|pstate
condition|)
block|{
case|case
name|pstate_init
case|:
comment|/* Authentication of the first request is done. */
name|gss_info
operator|->
name|pstate
operator|=
name|pstate_undecided
expr_stmt|;
break|break;
case|case
name|pstate_undecided
case|:
comment|/* The server didn't request for authentication even though                    we didn't add an Authorization header to previous                    request. That means it supports persistent authentication. */
name|gss_info
operator|->
name|pstate
operator|=
name|pstate_stateful
expr_stmt|;
name|serf_connection_set_max_outstanding_requests
argument_list|(
name|conn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Nothing to do here. */
break|break;
block|}
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERF_HAVE_SPNEGO */
end_comment

end_unit

