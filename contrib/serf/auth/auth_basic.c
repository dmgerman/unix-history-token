begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2009 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_comment
comment|/*** Basic authentication ***/
end_comment

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|<serf_private.h>
end_include

begin_include
include|#
directive|include
file|<auth/auth.h>
end_include

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<apr_base64.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_comment
comment|/* Stores the context information related to Basic authentication.    This information is stored in the per server cache in the serf context. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|basic_authn_info_t
block|{
specifier|const
name|char
modifier|*
name|header
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
block|}
name|basic_authn_info_t
typedef|;
end_typedef

begin_function
name|apr_status_t
name|serf__handle_basic_auth
parameter_list|(
name|int
name|code
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
name|serf_bucket_t
modifier|*
name|response
parameter_list|,
specifier|const
name|char
modifier|*
name|auth_hdr
parameter_list|,
specifier|const
name|char
modifier|*
name|auth_attr
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tmp
decl_stmt|;
name|apr_size_t
name|tmp_len
decl_stmt|;
name|serf_connection_t
modifier|*
name|conn
init|=
name|request
operator|->
name|conn
decl_stmt|;
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|serf__authn_info_t
modifier|*
name|authn_info
decl_stmt|;
name|basic_authn_info_t
modifier|*
name|basic_info
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|apr_pool_t
modifier|*
name|cred_pool
decl_stmt|;
name|char
modifier|*
name|username
decl_stmt|,
modifier|*
name|password
decl_stmt|,
modifier|*
name|realm_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|eq
decl_stmt|,
modifier|*
name|realm
init|=
name|NULL
decl_stmt|;
comment|/* Can't do Basic authentication if there's no callback to get        username& password. */
if|if
condition|(
operator|!
name|ctx
operator|->
name|cred_cb
condition|)
block|{
return|return
name|SERF_ERROR_AUTHN_FAILED
return|;
block|}
if|if
condition|(
name|code
operator|==
literal|401
condition|)
block|{
name|authn_info
operator|=
name|serf__get_authn_info_for_server
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|authn_info
operator|=
operator|&
name|ctx
operator|->
name|proxy_authn_info
expr_stmt|;
block|}
name|basic_info
operator|=
name|authn_info
operator|->
name|baton
expr_stmt|;
name|realm_name
operator|=
name|NULL
expr_stmt|;
name|eq
operator|=
name|strchr
argument_list|(
name|auth_attr
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|eq
operator|&&
name|strncasecmp
argument_list|(
name|auth_attr
argument_list|,
literal|"realm"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|realm_name
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|eq
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|realm_name
index|[
literal|0
index|]
operator|==
literal|'\"'
condition|)
block|{
name|apr_size_t
name|realm_len
decl_stmt|;
name|realm_len
operator|=
name|strlen
argument_list|(
name|realm_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|realm_name
index|[
name|realm_len
operator|-
literal|1
index|]
operator|==
literal|'\"'
condition|)
block|{
name|realm_name
index|[
name|realm_len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|realm_name
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|realm_name
condition|)
block|{
return|return
name|SERF_ERROR_AUTHN_MISSING_ATTRIBUTE
return|;
block|}
name|realm
operator|=
name|serf__construct_realm
argument_list|(
name|code
operator|==
literal|401
condition|?
name|HOST
else|:
name|PROXY
argument_list|,
name|conn
argument_list|,
name|realm_name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Ask the application for credentials */
name|apr_pool_create
argument_list|(
operator|&
name|cred_pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|status
operator|=
name|serf__provide_credentials
argument_list|(
name|ctx
argument_list|,
operator|&
name|username
argument_list|,
operator|&
name|password
argument_list|,
name|request
argument_list|,
name|baton
argument_list|,
name|code
argument_list|,
name|authn_info
operator|->
name|scheme
operator|->
name|name
argument_list|,
name|realm
argument_list|,
name|cred_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|apr_pool_destroy
argument_list|(
name|cred_pool
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|tmp
operator|=
name|apr_pstrcat
argument_list|(
name|conn
operator|->
name|pool
argument_list|,
name|username
argument_list|,
literal|":"
argument_list|,
name|password
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tmp_len
operator|=
name|strlen
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|apr_pool_destroy
argument_list|(
name|cred_pool
argument_list|)
expr_stmt|;
name|serf__encode_auth_header
argument_list|(
operator|&
name|basic_info
operator|->
name|value
argument_list|,
name|authn_info
operator|->
name|scheme
operator|->
name|name
argument_list|,
name|tmp
argument_list|,
name|tmp_len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|basic_info
operator|->
name|header
operator|=
operator|(
name|code
operator|==
literal|401
operator|)
condition|?
literal|"Authorization"
else|:
literal|"Proxy-Authorization"
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf__init_basic
parameter_list|(
name|int
name|code
parameter_list|,
name|serf_context_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* For Basic authentication we expect all authn info to be the same for all    connections in the context to the same server (same realm, username,    password). Therefore we can keep the header value in the per-server store    context instead of per connection.    TODO: we currently don't cache this info per realm, so each time a request    'switches realms', we have to ask the application for new credentials. */
end_comment

begin_function
name|apr_status_t
name|serf__init_basic_connection
parameter_list|(
specifier|const
name|serf__authn_scheme_t
modifier|*
name|scheme
parameter_list|,
name|int
name|code
parameter_list|,
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|serf__authn_info_t
modifier|*
name|authn_info
decl_stmt|;
if|if
condition|(
name|code
operator|==
literal|401
condition|)
block|{
name|authn_info
operator|=
name|serf__get_authn_info_for_server
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|authn_info
operator|=
operator|&
name|ctx
operator|->
name|proxy_authn_info
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|authn_info
operator|->
name|baton
condition|)
block|{
name|authn_info
operator|->
name|baton
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_authn_info_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf__setup_request_basic_auth
parameter_list|(
name|peer_t
name|peer
parameter_list|,
name|int
name|code
parameter_list|,
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|serf_request_t
modifier|*
name|request
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|,
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|serf_bucket_t
modifier|*
name|hdrs_bkt
parameter_list|)
block|{
name|serf_context_t
modifier|*
name|ctx
init|=
name|conn
operator|->
name|ctx
decl_stmt|;
name|serf__authn_info_t
modifier|*
name|authn_info
decl_stmt|;
name|basic_authn_info_t
modifier|*
name|basic_info
decl_stmt|;
if|if
condition|(
name|peer
operator|==
name|HOST
condition|)
block|{
name|authn_info
operator|=
name|serf__get_authn_info_for_server
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|authn_info
operator|=
operator|&
name|ctx
operator|->
name|proxy_authn_info
expr_stmt|;
block|}
name|basic_info
operator|=
name|authn_info
operator|->
name|baton
expr_stmt|;
if|if
condition|(
name|basic_info
operator|&&
name|basic_info
operator|->
name|header
operator|&&
name|basic_info
operator|->
name|value
condition|)
block|{
name|serf_bucket_headers_setn
argument_list|(
name|hdrs_bkt
argument_list|,
name|basic_info
operator|->
name|header
argument_list|,
name|basic_info
operator|->
name|value
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
return|return
name|SERF_ERROR_AUTHN_FAILED
return|;
block|}
end_function

end_unit

