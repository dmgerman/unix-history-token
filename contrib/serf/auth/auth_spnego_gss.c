begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2009 Justin Erenkrantz and Greg Stein  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"serf.h"
end_include

begin_include
include|#
directive|include
file|"serf_private.h"
end_include

begin_include
include|#
directive|include
file|"auth_spnego.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SERF_USE_GSSAPI
end_ifdef

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<gssapi/gssapi.h>
end_include

begin_comment
comment|/* This module can support all authentication mechanisms as provided by    the GSS-API implementation, but for now it only supports SPNEGO for    Negotiate.    SPNEGO can delegate authentication to Kerberos if supported by the    host. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GSS_SPNEGO_MECHANISM
end_ifndef

begin_decl_stmt
specifier|static
name|gss_OID_desc
name|spnego_mech_oid
init|=
block|{
literal|6
block|,
literal|"\x2b\x06\x01\x05\x05\x02"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GSS_SPNEGO_MECHANISM
value|&spnego_mech_oid
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|serf__spnego_context_t
block|{
comment|/* GSSAPI context */
name|gss_ctx_id_t
name|gss_ctx
decl_stmt|;
comment|/* Mechanism used to authenticate. */
name|gss_OID
name|gss_mech
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|log_error
parameter_list|(
name|int
name|verbose_flag
parameter_list|,
name|apr_socket_t
modifier|*
name|skt
parameter_list|,
name|serf__spnego_context_t
modifier|*
name|ctx
parameter_list|,
name|OM_uint32
name|err_maj_stat
parameter_list|,
name|OM_uint32
name|err_min_stat
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|OM_uint32
name|maj_stat
decl_stmt|,
name|min_stat
decl_stmt|;
name|gss_buffer_desc
name|stat_buff
decl_stmt|;
name|OM_uint32
name|msg_ctx
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|verbose_flag
condition|)
block|{
name|maj_stat
operator|=
name|gss_display_status
argument_list|(
operator|&
name|min_stat
argument_list|,
name|err_maj_stat
argument_list|,
name|GSS_C_GSS_CODE
argument_list|,
name|ctx
operator|->
name|gss_mech
argument_list|,
operator|&
name|msg_ctx
argument_list|,
operator|&
name|stat_buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|==
name|GSS_S_COMPLETE
operator|||
name|maj_stat
operator|==
name|GSS_S_FAILURE
condition|)
block|{
name|maj_stat
operator|=
name|gss_display_status
argument_list|(
operator|&
name|min_stat
argument_list|,
name|err_min_stat
argument_list|,
name|GSS_C_MECH_CODE
argument_list|,
name|ctx
operator|->
name|gss_mech
argument_list|,
operator|&
name|msg_ctx
argument_list|,
operator|&
name|stat_buff
argument_list|)
expr_stmt|;
block|}
name|serf__log_skt
argument_list|(
name|verbose_flag
argument_list|,
name|__FILE__
argument_list|,
name|skt
argument_list|,
literal|"%s (%x,%d): %s\n"
argument_list|,
name|msg
argument_list|,
name|err_maj_stat
argument_list|,
name|err_min_stat
argument_list|,
name|stat_buff
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Cleans the GSS context object, when the pool used to create it gets    cleared or destroyed. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|cleanup_ctx
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|serf__spnego_context_t
modifier|*
name|ctx
init|=
name|data
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|gss_ctx
operator|!=
name|GSS_C_NO_CONTEXT
condition|)
block|{
name|OM_uint32
name|gss_min_stat
decl_stmt|,
name|gss_maj_stat
decl_stmt|;
name|gss_maj_stat
operator|=
name|gss_delete_sec_context
argument_list|(
operator|&
name|gss_min_stat
argument_list|,
operator|&
name|ctx
operator|->
name|gss_ctx
argument_list|,
name|GSS_C_NO_BUFFER
argument_list|)
expr_stmt|;
if|if
condition|(
name|GSS_ERROR
argument_list|(
name|gss_maj_stat
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
name|AUTH_VERBOSE
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|gss_maj_stat
argument_list|,
name|gss_min_stat
argument_list|,
literal|"Error cleaning up GSS security context"
argument_list|)
expr_stmt|;
return|return
name|SERF_ERROR_AUTHN_FAILED
return|;
block|}
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|cleanup_sec_buffer
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|OM_uint32
name|min_stat
decl_stmt|;
name|gss_buffer_desc
modifier|*
name|gss_buf
init|=
name|data
decl_stmt|;
name|gss_release_buffer
argument_list|(
operator|&
name|min_stat
argument_list|,
name|gss_buf
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf__spnego_create_sec_context
parameter_list|(
name|serf__spnego_context_t
modifier|*
modifier|*
name|ctx_p
parameter_list|,
specifier|const
name|serf__authn_scheme_t
modifier|*
name|scheme
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|serf__spnego_context_t
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|gss_ctx
operator|=
name|GSS_C_NO_CONTEXT
expr_stmt|;
name|ctx
operator|->
name|gss_mech
operator|=
name|GSS_SPNEGO_MECHANISM
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|result_pool
argument_list|,
name|ctx
argument_list|,
name|cleanup_ctx
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
operator|*
name|ctx_p
operator|=
name|ctx
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf__spnego_reset_sec_context
parameter_list|(
name|serf__spnego_context_t
modifier|*
name|ctx
parameter_list|)
block|{
name|OM_uint32
name|dummy_stat
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|gss_ctx
condition|)
operator|(
name|void
operator|)
name|gss_delete_sec_context
argument_list|(
operator|&
name|dummy_stat
argument_list|,
operator|&
name|ctx
operator|->
name|gss_ctx
argument_list|,
name|GSS_C_NO_BUFFER
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|gss_ctx
operator|=
name|GSS_C_NO_CONTEXT
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|apr_status_t
name|serf__spnego_init_sec_context
parameter_list|(
name|serf_connection_t
modifier|*
name|conn
parameter_list|,
name|serf__spnego_context_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|service
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|serf__spnego_buffer_t
modifier|*
name|input_buf
parameter_list|,
name|serf__spnego_buffer_t
modifier|*
name|output_buf
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|gss_buffer_desc
name|gss_input_buf
init|=
name|GSS_C_EMPTY_BUFFER
decl_stmt|;
name|gss_buffer_desc
modifier|*
name|gss_output_buf_p
decl_stmt|;
name|OM_uint32
name|gss_min_stat
decl_stmt|,
name|gss_maj_stat
decl_stmt|;
name|gss_name_t
name|host_gss_name
decl_stmt|;
name|gss_buffer_desc
name|bufdesc
decl_stmt|;
name|gss_OID
name|dummy
decl_stmt|;
comment|/* unused */
comment|/* Get the name for the HTTP service at the target host. */
comment|/* TODO: should be shared between multiple requests. */
name|bufdesc
operator|.
name|value
operator|=
name|apr_pstrcat
argument_list|(
name|scratch_pool
argument_list|,
name|service
argument_list|,
literal|"@"
argument_list|,
name|hostname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bufdesc
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|bufdesc
operator|.
name|value
argument_list|)
expr_stmt|;
name|serf__log_skt
argument_list|(
name|AUTH_VERBOSE
argument_list|,
name|__FILE__
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
literal|"Get principal for %s\n"
argument_list|,
name|bufdesc
operator|.
name|value
argument_list|)
expr_stmt|;
name|gss_maj_stat
operator|=
name|gss_import_name
argument_list|(
operator|&
name|gss_min_stat
argument_list|,
operator|&
name|bufdesc
argument_list|,
name|GSS_C_NT_HOSTBASED_SERVICE
argument_list|,
operator|&
name|host_gss_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|GSS_ERROR
argument_list|(
name|gss_maj_stat
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
name|AUTH_VERBOSE
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
name|ctx
argument_list|,
name|gss_maj_stat
argument_list|,
name|gss_min_stat
argument_list|,
literal|"Error converting principal name to GSS internal format "
argument_list|)
expr_stmt|;
return|return
name|SERF_ERROR_AUTHN_FAILED
return|;
block|}
comment|/* If the server sent us a token, pass it to gss_init_sec_token for        validation. */
name|gss_input_buf
operator|.
name|value
operator|=
name|input_buf
operator|->
name|value
expr_stmt|;
name|gss_input_buf
operator|.
name|length
operator|=
name|input_buf
operator|->
name|length
expr_stmt|;
name|gss_output_buf_p
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gss_output_buf_p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Establish a security context to the server. */
name|gss_maj_stat
operator|=
name|gss_init_sec_context
argument_list|(
operator|&
name|gss_min_stat
argument_list|,
comment|/* minor_status */
name|GSS_C_NO_CREDENTIAL
argument_list|,
comment|/* XXXXX claimant_cred_handle */
operator|&
name|ctx
operator|->
name|gss_ctx
argument_list|,
comment|/* gssapi context handle */
name|host_gss_name
argument_list|,
comment|/* HTTP@server name */
name|ctx
operator|->
name|gss_mech
argument_list|,
comment|/* mech_type (SPNEGO) */
name|GSS_C_MUTUAL_FLAG
argument_list|,
comment|/* ensure the peer authenticates itself */
literal|0
argument_list|,
comment|/* default validity period */
name|GSS_C_NO_CHANNEL_BINDINGS
argument_list|,
comment|/* do not use channel bindings */
operator|&
name|gss_input_buf
argument_list|,
comment|/* server token, initially empty */
operator|&
name|dummy
argument_list|,
comment|/* actual mech type */
name|gss_output_buf_p
argument_list|,
comment|/* output_token */
name|NULL
argument_list|,
comment|/* ret_flags */
name|NULL
comment|/* not interested in remaining validity */
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|result_pool
argument_list|,
name|gss_output_buf_p
argument_list|,
name|cleanup_sec_buffer
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
name|output_buf
operator|->
name|value
operator|=
name|gss_output_buf_p
operator|->
name|value
expr_stmt|;
name|output_buf
operator|->
name|length
operator|=
name|gss_output_buf_p
operator|->
name|length
expr_stmt|;
switch|switch
condition|(
name|gss_maj_stat
condition|)
block|{
case|case
name|GSS_S_COMPLETE
case|:
return|return
name|APR_SUCCESS
return|;
case|case
name|GSS_S_CONTINUE_NEEDED
case|:
return|return
name|APR_EAGAIN
return|;
default|default:
name|log_error
argument_list|(
name|AUTH_VERBOSE
argument_list|,
name|conn
operator|->
name|skt
argument_list|,
name|ctx
argument_list|,
name|gss_maj_stat
argument_list|,
name|gss_min_stat
argument_list|,
literal|"Error during Kerberos handshake"
argument_list|)
expr_stmt|;
return|return
name|SERF_ERROR_AUTHN_FAILED
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERF_USE_GSSAPI */
end_comment

end_unit

