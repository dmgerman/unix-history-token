begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// -*- C++ -*-
end_comment

begin_comment
comment|/* Copyright (C) 1989, 1990, 1991, 1992, 2001, 2002    Free Software Foundation, Inc.      Written by James Clark (jjc@jclark.com)  This file is part of groff.  groff is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  groff is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with groff; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_decl_stmt
name|class
name|macro
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|charinfo
block|{
specifier|static
name|int
name|next_index
decl_stmt|;
name|charinfo
modifier|*
name|translation
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|number
decl_stmt|;
name|macro
modifier|*
name|mac
decl_stmt|;
name|unsigned
name|char
name|special_translation
decl_stmt|;
name|unsigned
name|char
name|hyphenation_code
decl_stmt|;
name|unsigned
name|char
name|flags
decl_stmt|;
name|unsigned
name|char
name|ascii_code
decl_stmt|;
name|unsigned
name|char
name|asciify_code
decl_stmt|;
name|char
name|not_found
decl_stmt|;
name|char
name|transparent_translate
decl_stmt|;
comment|// non-zero means translation applies
comment|// to transparent throughput
name|char
name|translate_input
decl_stmt|;
comment|// non-zero means that asciify_code is
comment|// active for .asciify (set by .trin)
name|char_mode
name|mode
decl_stmt|;
name|public
label|:
enum|enum
block|{
name|ENDS_SENTENCE
init|=
literal|1
block|,
name|BREAK_BEFORE
init|=
literal|2
block|,
name|BREAK_AFTER
init|=
literal|4
block|,
name|OVERLAPS_HORIZONTALLY
init|=
literal|8
block|,
name|OVERLAPS_VERTICALLY
init|=
literal|16
block|,
name|TRANSPARENT
init|=
literal|32
block|,
name|NUMBERED
init|=
literal|64
block|}
enum|;
enum|enum
block|{
name|TRANSLATE_NONE
block|,
name|TRANSLATE_SPACE
block|,
name|TRANSLATE_DUMMY
block|,
name|TRANSLATE_STRETCHABLE_SPACE
block|,
name|TRANSLATE_HYPHEN_INDICATOR
block|}
enum|;
name|symbol
name|nm
decl_stmt|;
name|charinfo
argument_list|(
argument|symbol s
argument_list|)
empty_stmt|;
name|int
name|get_index
parameter_list|()
function_decl|;
name|int
name|ends_sentence
parameter_list|()
function_decl|;
name|int
name|overlaps_vertically
parameter_list|()
function_decl|;
name|int
name|overlaps_horizontally
parameter_list|()
function_decl|;
name|int
name|can_break_before
parameter_list|()
function_decl|;
name|int
name|can_break_after
parameter_list|()
function_decl|;
name|int
name|transparent
parameter_list|()
function_decl|;
name|unsigned
name|char
name|get_hyphenation_code
parameter_list|()
function_decl|;
name|unsigned
name|char
name|get_ascii_code
parameter_list|()
function_decl|;
name|unsigned
name|char
name|get_asciify_code
parameter_list|()
function_decl|;
name|void
name|set_hyphenation_code
parameter_list|(
name|unsigned
name|char
parameter_list|)
function_decl|;
name|void
name|set_ascii_code
parameter_list|(
name|unsigned
name|char
parameter_list|)
function_decl|;
name|void
name|set_asciify_code
parameter_list|(
name|unsigned
name|char
parameter_list|)
function_decl|;
name|void
name|set_translation_input
parameter_list|()
function_decl|;
name|int
name|get_translation_input
parameter_list|()
function_decl|;
name|charinfo
modifier|*
name|get_translation
parameter_list|(
name|int
init|=
literal|0
parameter_list|)
function_decl|;
name|void
name|set_translation
parameter_list|(
name|charinfo
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|void
name|set_flags
parameter_list|(
name|unsigned
name|char
parameter_list|)
function_decl|;
name|void
name|set_special_translation
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|int
name|get_special_translation
parameter_list|(
name|int
init|=
literal|0
parameter_list|)
function_decl|;
name|macro
modifier|*
name|set_macro
parameter_list|(
name|macro
modifier|*
parameter_list|)
function_decl|;
name|macro
modifier|*
name|setx_macro
parameter_list|(
name|macro
modifier|*
parameter_list|,
name|char_mode
parameter_list|)
function_decl|;
name|macro
modifier|*
name|get_macro
parameter_list|()
function_decl|;
name|int
name|first_time_not_found
parameter_list|()
function_decl|;
name|void
name|set_number
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|int
name|get_number
parameter_list|()
function_decl|;
name|int
name|numbered
parameter_list|()
function_decl|;
name|int
name|is_normal
parameter_list|()
function_decl|;
name|int
name|is_fallback
parameter_list|()
function_decl|;
name|int
name|is_special
parameter_list|()
function_decl|;
name|symbol
modifier|*
name|get_symbol
parameter_list|()
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
name|charinfo
modifier|*
name|get_charinfo
parameter_list|(
name|symbol
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|charinfo
modifier|*
name|charset_table
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|charinfo
modifier|*
name|get_charinfo_by_number
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|inline
name|int
name|charinfo
operator|::
name|overlaps_horizontally
argument_list|()
block|{
return|return
name|flags
operator|&
name|OVERLAPS_HORIZONTALLY
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|charinfo
operator|::
name|overlaps_vertically
argument_list|()
block|{
return|return
name|flags
operator|&
name|OVERLAPS_VERTICALLY
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|charinfo
operator|::
name|can_break_before
argument_list|()
block|{
return|return
name|flags
operator|&
name|BREAK_BEFORE
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|charinfo
operator|::
name|can_break_after
argument_list|()
block|{
return|return
name|flags
operator|&
name|BREAK_AFTER
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|charinfo
operator|::
name|ends_sentence
argument_list|()
block|{
return|return
name|flags
operator|&
name|ENDS_SENTENCE
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|charinfo
operator|::
name|transparent
argument_list|()
block|{
return|return
name|flags
operator|&
name|TRANSPARENT
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|charinfo
operator|::
name|numbered
argument_list|()
block|{
return|return
name|flags
operator|&
name|NUMBERED
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|charinfo
operator|::
name|is_normal
argument_list|()
block|{
return|return
name|mode
operator|==
name|CHAR_NORMAL
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|charinfo
operator|::
name|is_fallback
argument_list|()
block|{
return|return
name|mode
operator|==
name|CHAR_FALLBACK
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|charinfo
operator|::
name|is_special
argument_list|()
block|{
return|return
name|mode
operator|==
name|CHAR_SPECIAL
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|charinfo
operator|*
name|charinfo
operator|::
name|get_translation
argument_list|(
argument|int transparent_throughput
argument_list|)
block|{
return|return
operator|(
name|transparent_throughput
operator|&&
operator|!
name|transparent_translate
operator|?
literal|0
operator|:
name|translation
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|unsigned
name|char
name|charinfo
operator|::
name|get_hyphenation_code
argument_list|()
block|{
return|return
name|hyphenation_code
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|unsigned
name|char
name|charinfo
operator|::
name|get_ascii_code
argument_list|()
block|{
return|return
name|ascii_code
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|unsigned
name|char
name|charinfo
operator|::
name|get_asciify_code
argument_list|()
block|{
return|return
operator|(
name|translate_input
operator|?
name|asciify_code
operator|:
literal|0
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|void
name|charinfo
operator|::
name|set_flags
argument_list|(
argument|unsigned char c
argument_list|)
block|{
name|flags
operator|=
name|c
block|; }
specifier|inline
name|int
name|charinfo
operator|::
name|get_index
argument_list|()
block|{
return|return
name|index
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|void
name|charinfo
operator|::
name|set_translation_input
argument_list|()
block|{
name|translate_input
operator|=
literal|1
block|; }
specifier|inline
name|int
name|charinfo
operator|::
name|get_translation_input
argument_list|()
block|{
return|return
name|translate_input
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|charinfo
operator|::
name|get_special_translation
argument_list|(
argument|int transparent_throughput
argument_list|)
block|{
return|return
operator|(
name|transparent_throughput
operator|&&
operator|!
name|transparent_translate
operator|?
name|int
argument_list|(
name|TRANSLATE_NONE
argument_list|)
operator|:
name|special_translation
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|macro
operator|*
name|charinfo
operator|::
name|get_macro
argument_list|()
block|{
return|return
name|mac
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|charinfo
operator|::
name|first_time_not_found
argument_list|()
block|{
if|if
condition|(
name|not_found
condition|)
return|return
literal|0
return|;
else|else
block|{
name|not_found
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  inline
name|symbol
operator|*
name|charinfo
operator|::
name|get_symbol
argument_list|()
block|{
return|return
operator|(
operator|&
name|nm
operator|)
return|;
block|}
end_expr_stmt

end_unit

