begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// -*- C++ -*-
end_comment

begin_comment
comment|/* Copyright (C) 1989, 1990, 1991, 1992, 2000, 2001    Free Software Foundation, Inc.      Written by James Clark (jjc@jclark.com)  This file is part of groff.  groff is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  groff is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with groff; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_struct_decl
struct_decl|struct
name|charinfo
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|node
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|vunits
struct_decl|;
end_struct_decl

begin_decl_stmt
name|class
name|token
block|{
name|symbol
name|nm
decl_stmt|;
name|node
modifier|*
name|nd
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|int
name|val
decl_stmt|;
name|units
name|dim
decl_stmt|;
enum|enum
name|token_type
block|{
name|TOKEN_BACKSPACE
block|,
name|TOKEN_BEGIN_TRAP
block|,
name|TOKEN_CHAR
block|,
comment|// a normal printing character
name|TOKEN_DUMMY
block|,
comment|// \&
name|TOKEN_EMPTY
block|,
comment|// this is the initial value
name|TOKEN_END_TRAP
block|,
name|TOKEN_ESCAPE
block|,
comment|// \e
name|TOKEN_HYPHEN_INDICATOR
block|,
name|TOKEN_INTERRUPT
block|,
comment|// \c
name|TOKEN_ITALIC_CORRECTION
block|,
comment|// \/
name|TOKEN_LEADER
block|,
comment|// ^A
name|TOKEN_LEFT_BRACE
block|,
name|TOKEN_MARK_INPUT
block|,
comment|// \k -- `nm' is the name of the register
name|TOKEN_NEWLINE
block|,
comment|// newline
name|TOKEN_NODE
block|,
name|TOKEN_NUMBERED_CHAR
block|,
name|TOKEN_PAGE_EJECTOR
block|,
name|TOKEN_REQUEST
block|,
name|TOKEN_RIGHT_BRACE
block|,
name|TOKEN_SPACE
block|,
comment|// ` ' -- ordinary space
name|TOKEN_SPECIAL
block|,
comment|// a special character -- \' \` \- \(xx
name|TOKEN_SPREAD
block|,
comment|// \p -- break and spread output line
name|TOKEN_STRETCHABLE_SPACE
block|,
comment|// \~
name|TOKEN_TAB
block|,
comment|// tab
name|TOKEN_TRANSPARENT
block|,
comment|// \!
name|TOKEN_TRANSPARENT_DUMMY
block|,
comment|// \)
name|TOKEN_EOF
comment|// end of file
block|}
name|type
enum|;
name|public
label|:
name|token
argument_list|()
expr_stmt|;
operator|~
name|token
argument_list|()
expr_stmt|;
name|token
argument_list|(
specifier|const
name|token
operator|&
argument_list|)
expr_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|token
operator|&
operator|)
decl_stmt|;
name|void
name|next
parameter_list|()
function_decl|;
name|void
name|process
parameter_list|()
function_decl|;
name|void
name|skip
parameter_list|()
function_decl|;
name|int
name|eof
parameter_list|()
function_decl|;
name|int
name|nspaces
parameter_list|()
function_decl|;
comment|// 1 if space, 2 if double space, 0 otherwise
name|int
name|space
parameter_list|()
function_decl|;
comment|// is the current token a space?
name|int
name|stretchable_space
parameter_list|()
function_decl|;
comment|// is the current token a stretchable space?
name|int
name|white_space
parameter_list|()
function_decl|;
comment|// is the current token space or tab?
name|int
name|special
parameter_list|()
function_decl|;
comment|// is the current token a special character?
name|int
name|newline
parameter_list|()
function_decl|;
comment|// is the current token a newline?
name|int
name|tab
parameter_list|()
function_decl|;
comment|// is the current token a tab?
name|int
name|leader
parameter_list|()
function_decl|;
name|int
name|backspace
parameter_list|()
function_decl|;
name|int
name|delimiter
parameter_list|(
name|int
name|warn
init|=
literal|0
parameter_list|)
function_decl|;
comment|// is it suitable for use as a delimiter?
name|int
name|dummy
parameter_list|()
function_decl|;
name|int
name|transparent_dummy
parameter_list|()
function_decl|;
name|int
name|transparent
parameter_list|()
function_decl|;
name|int
name|left_brace
parameter_list|()
function_decl|;
name|int
name|right_brace
parameter_list|()
function_decl|;
name|int
name|page_ejector
parameter_list|()
function_decl|;
name|int
name|hyphen_indicator
parameter_list|()
function_decl|;
name|int
name|operator
operator|==
operator|(
specifier|const
name|token
operator|&
operator|)
expr_stmt|;
comment|// need this for delimiters, and for conditions
name|int
name|operator
operator|!=
operator|(
specifier|const
name|token
operator|&
operator|)
expr_stmt|;
comment|// ditto
name|unsigned
name|char
name|ch
parameter_list|()
function_decl|;
name|charinfo
modifier|*
name|get_char
parameter_list|(
name|int
name|required
init|=
literal|0
parameter_list|)
function_decl|;
name|int
name|add_to_node_list
parameter_list|(
name|node
modifier|*
modifier|*
parameter_list|)
function_decl|;
name|int
name|title
parameter_list|()
function_decl|;
name|void
name|make_space
parameter_list|()
function_decl|;
name|void
name|make_newline
parameter_list|()
function_decl|;
specifier|const
name|char
modifier|*
name|description
parameter_list|()
function_decl|;
name|friend
name|void
name|process_input_stack
parameter_list|()
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|extern
name|token
name|tok
decl_stmt|;
end_decl_stmt

begin_comment
comment|// the current token
end_comment

begin_function_decl
specifier|extern
name|symbol
name|get_name
parameter_list|(
name|int
name|required
init|=
literal|0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|symbol
name|get_long_name
parameter_list|(
name|int
name|required
init|=
literal|0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|charinfo
modifier|*
name|get_optional_char
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|check_missing_character
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|skip_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|handle_initial_title
parameter_list|()
function_decl|;
end_function_decl

begin_struct_decl
struct_decl|struct
name|hunits
struct_decl|;
end_struct_decl

begin_function_decl
specifier|extern
name|void
name|read_title_parts
parameter_list|(
name|node
modifier|*
modifier|*
name|part
parameter_list|,
name|hunits
modifier|*
name|part_width
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|get_number_rigidly
parameter_list|(
name|units
modifier|*
name|result
parameter_list|,
name|unsigned
name|char
name|si
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|get_number
parameter_list|(
name|units
modifier|*
name|result
parameter_list|,
name|unsigned
name|char
name|si
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|get_integer
parameter_list|(
name|int
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|get_number
parameter_list|(
name|units
modifier|*
name|result
parameter_list|,
name|unsigned
name|char
name|si
parameter_list|,
name|units
name|prev_value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|get_integer
parameter_list|(
name|int
modifier|*
name|result
parameter_list|,
name|int
name|prev_value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|interpolate_number_reg
parameter_list|(
name|symbol
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|char
modifier|*
name|asciify
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|inline
name|int
name|token
operator|::
name|newline
argument_list|()
block|{
return|return
name|type
operator|==
name|TOKEN_NEWLINE
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|token
operator|::
name|space
argument_list|()
block|{
return|return
name|type
operator|==
name|TOKEN_SPACE
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|token
operator|::
name|stretchable_space
argument_list|()
block|{
return|return
name|type
operator|==
name|TOKEN_STRETCHABLE_SPACE
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|token
operator|::
name|special
argument_list|()
block|{
return|return
name|type
operator|==
name|TOKEN_SPECIAL
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|token
operator|::
name|nspaces
argument_list|()
block|{
if|if
condition|(
name|type
operator|==
name|TOKEN_SPACE
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|token
operator|::
name|white_space
argument_list|()
block|{
return|return
name|type
operator|==
name|TOKEN_SPACE
operator|||
name|type
operator|==
name|TOKEN_TAB
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|token
operator|::
name|transparent
argument_list|()
block|{
return|return
name|type
operator|==
name|TOKEN_TRANSPARENT
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|token
operator|::
name|page_ejector
argument_list|()
block|{
return|return
name|type
operator|==
name|TOKEN_PAGE_EJECTOR
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|unsigned
name|char
name|token
operator|::
name|ch
argument_list|()
block|{
return|return
name|type
operator|==
name|TOKEN_CHAR
operator|?
name|c
operator|:
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|token
operator|::
name|eof
argument_list|()
block|{
return|return
name|type
operator|==
name|TOKEN_EOF
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|token
operator|::
name|dummy
argument_list|()
block|{
return|return
name|type
operator|==
name|TOKEN_DUMMY
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|token
operator|::
name|transparent_dummy
argument_list|()
block|{
return|return
name|type
operator|==
name|TOKEN_TRANSPARENT_DUMMY
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|token
operator|::
name|left_brace
argument_list|()
block|{
return|return
name|type
operator|==
name|TOKEN_LEFT_BRACE
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|token
operator|::
name|right_brace
argument_list|()
block|{
return|return
name|type
operator|==
name|TOKEN_RIGHT_BRACE
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|token
operator|::
name|tab
argument_list|()
block|{
return|return
name|type
operator|==
name|TOKEN_TAB
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|token
operator|::
name|leader
argument_list|()
block|{
return|return
name|type
operator|==
name|TOKEN_LEADER
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|token
operator|::
name|backspace
argument_list|()
block|{
return|return
name|type
operator|==
name|TOKEN_BACKSPACE
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|token
operator|::
name|hyphen_indicator
argument_list|()
block|{
return|return
name|type
operator|==
name|TOKEN_HYPHEN_INDICATOR
return|;
block|}
end_expr_stmt

begin_function_decl
name|int
name|has_arg
parameter_list|()
function_decl|;
end_function_decl

end_unit

