begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1990, 1991, 1992, 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.      Written by James Clark (jjc@jclark.com)  This file is part of groff.  groff is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  groff is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with groff; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin St - Fifth Floor, Boston, MA 02110-1301, USA. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRERROR
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|char
modifier|*
name|strerror
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_POSIX_VERSION
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_define
define|#
directive|define
name|PID_T
value|pid_t
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not _POSIX_VERSION */
end_comment

begin_comment
comment|/* traditional Unix */
end_comment

begin_define
define|#
directive|define
name|WIFEXITED
parameter_list|(
name|s
parameter_list|)
value|(((s)& 0377) == 0)
end_define

begin_define
define|#
directive|define
name|WIFSTOPPED
parameter_list|(
name|s
parameter_list|)
value|(((s)& 0377) == 0177)
end_define

begin_define
define|#
directive|define
name|WIFSIGNALED
parameter_list|(
name|s
parameter_list|)
value|(((s)& 0377) != 0&& (((s)& 0377) != 0177))
end_define

begin_define
define|#
directive|define
name|WEXITSTATUS
parameter_list|(
name|s
parameter_list|)
value|(((s)>> 8)& 0377)
end_define

begin_define
define|#
directive|define
name|WTERMSIG
parameter_list|(
name|s
parameter_list|)
value|((s)& 0177)
end_define

begin_define
define|#
directive|define
name|WSTOPSIG
parameter_list|(
name|s
parameter_list|)
value|(((s)>> 8)& 0377)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|WCOREFLAG
end_ifndef

begin_define
define|#
directive|define
name|WCOREFLAG
value|0200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PID_T
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not _POSIX_VERSION */
end_comment

begin_comment
comment|/* SVR4 uses WCOREFLG; Net 2 uses WCOREFLAG. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WCOREFLAG
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|WCOREFLG
end_ifdef

begin_define
define|#
directive|define
name|WCOREFLAG
value|WCOREFLG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCOREFLG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not WCOREFLAG */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WCOREDUMP
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|WCOREFLAG
end_ifdef

begin_define
define|#
directive|define
name|WCOREDUMP
parameter_list|(
name|s
parameter_list|)
value|((s)& WCOREFLAG)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not WCOREFLAG */
end_comment

begin_define
define|#
directive|define
name|WCOREDUMP
parameter_list|(
name|s
parameter_list|)
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCOREFLAG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not WCOREDUMP */
end_comment

begin_include
include|#
directive|include
file|"pipeline.h"
end_include

begin_define
define|#
directive|define
name|error
value|c_error
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
specifier|extern
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|c_fatal
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
specifier|extern
specifier|const
name|char
modifier|*
name|i_to_a
parameter_list|(
name|int
parameter_list|)
function_decl|;
comment|/* from libgroff */
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|sys_fatal
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|xstrsignal
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_UWIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|)
expr|\
operator|||
name|defined
argument_list|(
name|__EMX__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"nonposix.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sh
init|=
literal|"sh"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cmd
init|=
literal|"cmd"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|command
init|=
literal|"command"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|strcasecmp
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|char
modifier|*
name|sbasename
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|base
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|p1
operator|=
name|path
expr_stmt|;
if|if
condition|(
operator|(
name|p2
operator|=
name|strrchr
argument_list|(
name|p1
argument_list|,
literal|'\\'
argument_list|)
operator|)
operator|||
operator|(
name|p2
operator|=
name|strrchr
argument_list|(
name|p1
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|||
operator|(
name|p2
operator|=
name|strrchr
argument_list|(
name|p1
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
name|p1
operator|=
name|p2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|p2
operator|=
name|strrchr
argument_list|(
name|p1
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|strcasecmp
argument_list|(
name|p2
argument_list|,
literal|".exe"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcasecmp
argument_list|(
name|p2
argument_list|,
literal|".com"
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
empty_stmt|;
else|else
name|p2
operator|=
name|p1
operator|+
name|strlen
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|base
operator|=
name|malloc
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|p2
operator|-
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|base
argument_list|,
name|p1
argument_list|,
name|p2
operator|-
name|p1
argument_list|)
expr_stmt|;
operator|*
operator|(
name|base
operator|+
operator|(
name|p2
operator|-
name|p1
operator|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|base
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the name of the system shell */
end_comment

begin_function
name|char
modifier|*
name|system_shell_name
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|shell_name
decl_stmt|;
comment|/*      Use a Unixy shell if it's installed.  Use SHELL if set; otherwise,      let spawnlp try to find sh; if that fails, use COMSPEC if set; if      not, try cmd.exe; if that fails, default to command.com.    */
if|if
condition|(
operator|(
name|shell_name
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|spawnlp
argument_list|(
name|_P_WAIT
argument_list|,
name|sh
argument_list|,
name|sh
argument_list|,
literal|"-c"
argument_list|,
literal|":"
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|shell_name
operator|=
name|sh
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|shell_name
operator|=
name|getenv
argument_list|(
literal|"COMSPEC"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|spawnlp
argument_list|(
name|_P_WAIT
argument_list|,
name|cmd
argument_list|,
name|cmd
argument_list|,
literal|"/c"
argument_list|,
literal|";"
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|shell_name
operator|=
name|cmd
expr_stmt|;
else|else
name|shell_name
operator|=
name|command
expr_stmt|;
return|return
name|sbasename
argument_list|(
name|shell_name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|system_shell_dash_c
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|shell_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|dash_c
decl_stmt|;
name|shell_name
operator|=
name|system_shell_name
argument_list|()
expr_stmt|;
comment|/* Assume that if the shell name ends in "sh", it's Unixy */
if|if
condition|(
name|strcasecmp
argument_list|(
name|shell_name
operator|+
name|strlen
argument_list|(
name|shell_name
argument_list|)
operator|-
name|strlen
argument_list|(
literal|"sh"
argument_list|)
argument_list|,
literal|"sh"
argument_list|)
operator|==
literal|0
condition|)
name|dash_c
operator|=
literal|"-c"
expr_stmt|;
else|else
name|dash_c
operator|=
literal|"/c"
expr_stmt|;
name|free
argument_list|(
name|shell_name
argument_list|)
expr_stmt|;
return|return
name|dash_c
return|;
block|}
end_function

begin_function
name|int
name|is_system_shell
parameter_list|(
specifier|const
name|char
modifier|*
name|prog
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|char
modifier|*
name|this_prog
decl_stmt|,
modifier|*
name|system_shell
decl_stmt|;
if|if
condition|(
operator|!
name|prog
condition|)
comment|/* paranoia */
return|return
literal|0
return|;
name|this_prog
operator|=
name|sbasename
argument_list|(
name|prog
argument_list|)
expr_stmt|;
name|system_shell
operator|=
name|system_shell_name
argument_list|()
expr_stmt|;
name|result
operator|=
name|strcasecmp
argument_list|(
name|this_prog
argument_list|,
name|system_shell
argument_list|)
operator|==
literal|0
expr_stmt|;
name|free
argument_list|(
name|this_prog
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|system_shell
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_comment
comment|/*   Windows 32 doesn't have fork(), so we need to start asynchronous child   processes with spawn() rather than exec().  If there is more than one   command, i.e., a pipeline, the parent must set up each child's I/O   redirection prior to the spawn.  The original stdout must be restored   before spawning the last process in the pipeline, and the original   stdin must be restored in the parent after spawning the last process   and before waiting for any of the children. */
end_comment

begin_function
name|int
name|run_pipeline
parameter_list|(
name|int
name|ncommands
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|commands
parameter_list|,
name|int
name|no_pipe
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|last_input
init|=
literal|0
decl_stmt|;
comment|/* pacify some compilers */
name|int
name|save_stdin
init|=
literal|0
decl_stmt|;
name|int
name|save_stdout
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|char
name|err_str
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|PID_T
name|pids
index|[
name|MAX_COMMANDS
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncommands
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pdes
index|[
literal|2
index|]
decl_stmt|;
name|PID_T
name|pid
decl_stmt|;
comment|/* If no_pipe is set, just run the commands in sequence        to show the version numbers */
if|if
condition|(
name|ncommands
operator|>
literal|1
operator|&&
operator|!
name|no_pipe
condition|)
block|{
comment|/* last command doesn't need a new pipe */
if|if
condition|(
name|i
operator|<
name|ncommands
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|pipe
argument_list|(
name|pdes
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|err_str
argument_list|,
literal|"%s: pipe"
argument_list|,
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sys_fatal
argument_list|(
name|err_str
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 1st command; writer */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* save stdin */
if|if
condition|(
operator|(
name|save_stdin
operator|=
name|dup
argument_list|(
name|STDIN_FILENO
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"dup stdin"
argument_list|)
expr_stmt|;
comment|/* save stdout */
if|if
condition|(
operator|(
name|save_stdout
operator|=
name|dup
argument_list|(
name|STDOUT_FILENO
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"dup stdout"
argument_list|)
expr_stmt|;
comment|/* connect stdout to write end of pipe */
if|if
condition|(
name|dup2
argument_list|(
name|pdes
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|err_str
argument_list|,
literal|"%s: dup2(stdout)"
argument_list|,
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sys_fatal
argument_list|(
name|err_str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|pdes
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|err_str
argument_list|,
literal|"%s: close(pipe[WRITE])"
argument_list|,
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sys_fatal
argument_list|(
name|err_str
argument_list|)
expr_stmt|;
block|}
comment|/* 	   Save the read end of the pipe so that it can be connected to 	   stdin of the next program in the pipeline during the next 	   pass through the loop. 	*/
name|last_input
operator|=
name|pdes
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* reader and writer */
elseif|else
if|if
condition|(
name|i
operator|<
name|ncommands
operator|-
literal|1
condition|)
block|{
comment|/* connect stdin to read end of last pipe */
if|if
condition|(
name|dup2
argument_list|(
name|last_input
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|err_str
argument_list|,
literal|" %s: dup2(stdin)"
argument_list|,
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sys_fatal
argument_list|(
name|err_str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|last_input
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|err_str
argument_list|,
literal|"%s: close(last_input)"
argument_list|,
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sys_fatal
argument_list|(
name|err_str
argument_list|)
expr_stmt|;
block|}
comment|/* connect stdout to write end of new pipe */
if|if
condition|(
name|dup2
argument_list|(
name|pdes
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|err_str
argument_list|,
literal|"%s: dup2(stdout)"
argument_list|,
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sys_fatal
argument_list|(
name|err_str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|pdes
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|err_str
argument_list|,
literal|"%s: close(pipe[WRITE])"
argument_list|,
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sys_fatal
argument_list|(
name|err_str
argument_list|)
expr_stmt|;
block|}
name|last_input
operator|=
name|pdes
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* last command; reader */
else|else
block|{
comment|/* connect stdin to read end of last pipe */
if|if
condition|(
name|dup2
argument_list|(
name|last_input
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|err_str
argument_list|,
literal|"%s: dup2(stdin)"
argument_list|,
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sys_fatal
argument_list|(
name|err_str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|last_input
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|err_str
argument_list|,
literal|"%s: close(last_input)"
argument_list|,
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sys_fatal
argument_list|(
name|err_str
argument_list|)
expr_stmt|;
block|}
comment|/* restore original stdout */
if|if
condition|(
name|dup2
argument_list|(
name|save_stdout
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|err_str
argument_list|,
literal|"%s: dup2(save_stdout))"
argument_list|,
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sys_fatal
argument_list|(
name|err_str
argument_list|)
expr_stmt|;
block|}
comment|/* close stdout copy */
if|if
condition|(
name|close
argument_list|(
name|save_stdout
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|err_str
argument_list|,
literal|"%s: close(save_stdout)"
argument_list|,
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sys_fatal
argument_list|(
name|err_str
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|pid
operator|=
name|spawnvp
argument_list|(
name|_P_NOWAIT
argument_list|,
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|commands
index|[
name|i
index|]
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"couldn't exec %1: %2"
argument_list|,
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* just in case error() doesn't */
name|_exit
argument_list|(
name|EXEC_FAILED_EXIT_STATUS
argument_list|)
expr_stmt|;
block|}
name|pids
index|[
name|i
index|]
operator|=
name|pid
expr_stmt|;
block|}
if|if
condition|(
name|ncommands
operator|>
literal|1
operator|&&
operator|!
name|no_pipe
condition|)
block|{
comment|/* restore original stdin if it was redirected */
if|if
condition|(
name|dup2
argument_list|(
name|save_stdin
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|err_str
argument_list|,
literal|"dup2(save_stdin))"
argument_list|)
expr_stmt|;
name|sys_fatal
argument_list|(
name|err_str
argument_list|)
expr_stmt|;
block|}
comment|/* close stdin copy */
if|if
condition|(
name|close
argument_list|(
name|save_stdin
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|err_str
argument_list|,
literal|"close(save_stdin)"
argument_list|)
expr_stmt|;
name|sys_fatal
argument_list|(
name|err_str
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncommands
condition|;
name|i
operator|++
control|)
block|{
name|int
name|status
decl_stmt|;
name|PID_T
name|pid
decl_stmt|;
name|pid
operator|=
name|pids
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|WAIT
argument_list|(
operator|&
name|status
argument_list|,
name|pid
argument_list|,
name|_WAIT_CHILD
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|err_str
argument_list|,
literal|"%s: wait"
argument_list|,
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sys_fatal
argument_list|(
name|err_str
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|ret
operator||=
literal|1
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not _WIN32 */
end_comment

begin_comment
comment|/* MSDOS doesn't have `fork', so we need to simulate the pipe by running    the programs in sequence with standard streams redirected to and    from temporary files. */
end_comment

begin_comment
comment|/* A signal handler that just records that a signal has happened.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|child_interrupted
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|RETSIGTYPE
name|signal_catcher
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|child_interrupted
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|int
name|run_pipeline
parameter_list|(
name|int
name|ncommands
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|commands
parameter_list|,
name|int
name|no_pipe
parameter_list|)
block|{
name|int
name|save_stdin
init|=
name|dup
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|save_stdout
init|=
name|dup
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tmpfiles
index|[
literal|2
index|]
decl_stmt|;
name|int
name|infile
init|=
literal|0
decl_stmt|;
name|int
name|outfile
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|f
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
comment|/* Choose names for a pair of temporary files to implement the pipeline.      Microsoft's `tempnam' uses the directory specified by `getenv("TMP")'      if it exists; in case it doesn't, try the GROFF alternatives, or      `getenv("TEMP")' as last resort -- at least one of these had better      be set, since Microsoft's default has a high probability of failure. */
name|char
modifier|*
name|tmpdir
decl_stmt|;
if|if
condition|(
operator|(
name|tmpdir
operator|=
name|getenv
argument_list|(
literal|"GROFF_TMPDIR"
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|tmpdir
operator|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|tmpdir
operator|=
name|getenv
argument_list|(
literal|"TEMP"
argument_list|)
expr_stmt|;
comment|/* Don't use `tmpnam' here: Microsoft's implementation yields unusable      file names if current directory is on network share with read-only      root. */
name|tmpfiles
index|[
literal|0
index|]
operator|=
name|tempnam
argument_list|(
name|tmpdir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tmpfiles
index|[
literal|1
index|]
operator|=
name|tempnam
argument_list|(
name|tmpdir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncommands
condition|;
name|i
operator|++
control|)
block|{
name|int
name|exit_status
decl_stmt|;
name|RETSIGTYPE
function_decl|(
modifier|*
name|prev_handler
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
if|if
condition|(
name|i
operator|&&
operator|!
name|no_pipe
condition|)
block|{
comment|/* redirect stdin from temp file */
name|f
operator|=
name|open
argument_list|(
name|tmpfiles
index|[
name|infile
index|]
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"open stdin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"dup2 stdin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|f
argument_list|)
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"close stdin"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|<
name|ncommands
operator|-
literal|1
operator|)
operator|&&
operator|!
name|no_pipe
condition|)
block|{
comment|/* redirect stdout to temp file */
name|f
operator|=
name|open
argument_list|(
name|tmpfiles
index|[
name|outfile
index|]
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_BINARY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"open stdout"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|f
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"dup2 stdout"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|f
argument_list|)
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"close stdout"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dup2
argument_list|(
name|save_stdout
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"restore stdout"
argument_list|)
expr_stmt|;
comment|/* run the program */
name|child_interrupted
operator|=
literal|0
expr_stmt|;
name|prev_handler
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|signal_catcher
argument_list|)
expr_stmt|;
name|exit_status
operator|=
name|spawnvp
argument_list|(
name|P_WAIT
argument_list|,
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|commands
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|prev_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_interrupted
condition|)
block|{
name|error
argument_list|(
literal|"%1: Interrupted"
argument_list|,
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|ret
operator||=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exit_status
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"couldn't exec %1: %2"
argument_list|,
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* just in case error() doesn't */
name|ret
operator||=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|exit_status
operator|!=
literal|0
condition|)
name|ret
operator||=
literal|1
expr_stmt|;
comment|/* There's no sense to continue with the pipe if one of the        programs has ended abnormally, is there? */
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
break|break;
comment|/* swap temp files: make output of this program be input for the next */
name|infile
operator|=
literal|1
operator|-
name|infile
expr_stmt|;
name|outfile
operator|=
literal|1
operator|-
name|outfile
expr_stmt|;
block|}
if|if
condition|(
name|dup2
argument_list|(
name|save_stdin
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"restore stdin"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpfiles
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpfiles
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not _WIN32 */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __MSDOS__, not _WIN32 */
end_comment

begin_function
name|int
name|run_pipeline
parameter_list|(
name|int
name|ncommands
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|commands
parameter_list|,
name|int
name|no_pipe
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|last_input
init|=
literal|0
decl_stmt|;
name|PID_T
name|pids
index|[
name|MAX_COMMANDS
index|]
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|proc_count
init|=
name|ncommands
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncommands
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pdes
index|[
literal|2
index|]
decl_stmt|;
name|PID_T
name|pid
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|!=
name|ncommands
operator|-
literal|1
operator|)
operator|&&
operator|!
name|no_pipe
condition|)
block|{
if|if
condition|(
name|pipe
argument_list|(
name|pdes
argument_list|)
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"pipe"
argument_list|)
expr_stmt|;
block|}
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* child */
if|if
condition|(
name|last_input
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup
argument_list|(
name|last_input
argument_list|)
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"dup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|last_input
argument_list|)
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|!=
name|ncommands
operator|-
literal|1
operator|)
operator|&&
operator|!
name|no_pipe
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup
argument_list|(
name|pdes
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"dup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|pdes
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|pdes
index|[
literal|0
index|]
argument_list|)
condition|)
name|sys_fatal
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
block|}
name|execvp
argument_list|(
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|commands
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"couldn't exec %1: %2"
argument_list|,
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* just in case error() doesn't */
name|_exit
argument_list|(
name|EXEC_FAILED_EXIT_STATUS
argument_list|)
expr_stmt|;
block|}
comment|/* in the parent */
if|if
condition|(
name|last_input
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
name|last_input
argument_list|)
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|!=
name|ncommands
operator|-
literal|1
operator|)
operator|&&
operator|!
name|no_pipe
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
name|pdes
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
name|last_input
operator|=
name|pdes
index|[
literal|0
index|]
expr_stmt|;
block|}
name|pids
index|[
name|i
index|]
operator|=
name|pid
expr_stmt|;
block|}
while|while
condition|(
name|proc_count
operator|>
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|;
name|PID_T
name|pid
init|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
decl_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|sys_fatal
argument_list|(
literal|"wait"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncommands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pids
index|[
name|i
index|]
operator|==
name|pid
condition|)
block|{
name|pids
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
operator|--
name|proc_count
expr_stmt|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|int
name|sig
init|=
name|WTERMSIG
argument_list|(
name|status
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|SIGPIPE
if|if
condition|(
name|sig
operator|==
name|SIGPIPE
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|ncommands
operator|-
literal|1
condition|)
block|{
comment|/* This works around a problem that occurred when using the 		 rerasterize action in gxditview.  What seemed to be 		 happening (on SunOS 4.1.1) was that pclose() closed the 		 pipe and waited for groff, gtroff got a SIGPIPE, but 		 gpic blocked writing to gtroff, and so groff blocked 		 waiting for gpic and gxditview blocked waiting for 		 groff.  I don't understand why gpic wasn't getting a 		 SIGPIPE. */
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ncommands
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|pids
index|[
name|j
index|]
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|kill
argument_list|(
name|pids
index|[
name|j
index|]
argument_list|,
name|SIGPIPE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* SIGPIPE */
block|{
name|error
argument_list|(
literal|"%1: %2%3"
argument_list|,
name|commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|xstrsignal
argument_list|(
name|sig
argument_list|)
argument_list|,
name|WCOREDUMP
argument_list|(
name|status
argument_list|)
condition|?
literal|" (core dumped)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|ret
operator||=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|int
name|exit_status
init|=
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
decl_stmt|;
if|if
condition|(
name|exit_status
operator|==
name|EXEC_FAILED_EXIT_STATUS
condition|)
name|ret
operator||=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|exit_status
operator|!=
literal|0
condition|)
name|ret
operator||=
literal|1
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"unexpected status %1"
argument_list|,
name|i_to_a
argument_list|(
name|status
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __MSDOS__, not _WIN32 */
end_comment

begin_function
specifier|static
name|void
name|sys_fatal
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|c_fatal
argument_list|(
literal|"%1: %2"
argument_list|,
name|s
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|xstrsignal
parameter_list|(
name|int
name|n
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
literal|"Signal "
argument_list|)
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|3
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|NSIG
if|#
directive|if
name|HAVE_DECL_SYS_SIGLIST
if|if
condition|(
name|n
operator|>=
literal|0
operator|&&
name|n
operator|<
name|NSIG
operator|&&
name|sys_siglist
index|[
name|n
index|]
operator|!=
literal|0
condition|)
return|return
name|sys_siglist
index|[
name|n
index|]
return|;
endif|#
directive|endif
comment|/* HAVE_DECL_SYS_SIGLIST */
endif|#
directive|endif
comment|/* NSIG */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Signal %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

end_unit

