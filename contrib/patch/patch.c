begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* patch - a program to apply diffs to original files */
end_comment

begin_comment
comment|/* $Id: patch.c,v 1.22 1997/06/17 22:32:49 eggert Exp $ */
end_comment

begin_comment
comment|/* Copyright 1984, 1985, 1986, 1987, 1988 Larry Wall Copyright 1989, 1990, 1991, 1992, 1993, 1997 Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_define
define|#
directive|define
name|XTERN
end_define

begin_include
include|#
directive|include
file|<common.h>
end_include

begin_undef
undef|#
directive|undef
name|XTERN
end_undef

begin_define
define|#
directive|define
name|XTERN
value|extern
end_define

begin_include
include|#
directive|include
file|<argmatch.h>
end_include

begin_include
include|#
directive|include
file|<backupfile.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<inp.h>
end_include

begin_include
include|#
directive|include
file|<pch.h>
end_include

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_include
include|#
directive|include
file|<version.h>
end_include

begin_if
if|#
directive|if
name|HAVE_UTIME_H
end_if

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some nonstandard hosts don't declare this structure even in<utime.h>.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|HAVE_STRUCT_UTIMBUF
end_if

begin_struct
struct|struct
name|utimbuf
block|{
name|time_t
name|actime
decl_stmt|;
name|time_t
name|modtime
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Output stream state.  */
end_comment

begin_struct
struct|struct
name|outstate
block|{
name|FILE
modifier|*
name|ofp
decl_stmt|;
name|int
name|after_newline
decl_stmt|;
name|int
name|zero_output
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* procedures */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|create_output_file
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|LINENUM
name|locate_hunk
name|PARAMS
argument_list|(
operator|(
name|LINENUM
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|apply_hunk
name|PARAMS
argument_list|(
operator|(
expr|struct
name|outstate
operator|*
operator|,
name|LINENUM
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|copy_till
name|PARAMS
argument_list|(
operator|(
expr|struct
name|outstate
operator|*
operator|,
name|LINENUM
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|patch_match
name|PARAMS
argument_list|(
operator|(
name|LINENUM
operator|,
name|LINENUM
operator|,
name|LINENUM
operator|,
name|LINENUM
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|similar
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|,
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|spew_output
name|PARAMS
argument_list|(
operator|(
expr|struct
name|outstate
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|make_temp
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|numeric_string
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|int
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|abort_hunk
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_some_switches
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_output
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
expr|struct
name|outstate
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_reject
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reinitialize_almost_everything
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|noreturn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|backup_if_mismatch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remove_empty_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if -R was specified on command line.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reverse_flag_specified
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how many input lines have been irretractably output */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|last_frozen_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|do_defines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol to patch using ifdef, ifndef, etc. */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
name|if_defined
index|[]
init|=
literal|"\n#ifdef %s\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|not_defined
index|[]
init|=
literal|"#ifndef %s\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|else_defined
index|[]
init|=
literal|"\n#else\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|end_defined
index|[]
init|=
literal|"\n#endif /* %s */\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
specifier|const
modifier|*
name|Argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|rejfp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reject file pointer */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|patchname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rejname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|volatile
name|TMPREJNAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|LINENUM
name|last_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|LINENUM
name|maxfuzz
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|serrbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
specifier|const
name|program_name
index|[]
init|=
literal|"patch"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Apply a set of diffs as appropriate. */
end_comment

begin_decl_stmt
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
specifier|const
modifier|*
name|val
decl_stmt|;
name|bool
name|somefailed
init|=
name|FALSE
decl_stmt|;
name|struct
name|outstate
name|outstate
decl_stmt|;
name|init_time
argument_list|()
expr_stmt|;
name|setbuf
argument_list|(
name|stderr
argument_list|,
name|serrbuf
argument_list|)
expr_stmt|;
name|bufsize
operator|=
literal|8
operator|*
literal|1024
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
name|strippath
operator|=
name|INT_MAX
expr_stmt|;
name|posixly_correct
operator|=
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|backup_if_mismatch
operator|=
operator|!
name|posixly_correct
expr_stmt|;
name|patch_get
operator|=
operator|(
operator|(
name|val
operator|=
name|getenv
argument_list|(
literal|"PATCH_GET"
argument_list|)
operator|)
condition|?
name|numeric_string
argument_list|(
name|val
argument_list|,
literal|1
argument_list|,
literal|"PATCH_GET value"
argument_list|)
else|:
name|posixly_correct
operator|-
literal|1
operator|)
expr_stmt|;
block|{
name|char
specifier|const
modifier|*
name|v
decl_stmt|;
name|v
operator|=
name|getenv
argument_list|(
literal|"SIMPLE_BACKUP_SUFFIX"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&&
operator|*
name|v
condition|)
name|simple_backup_suffix
operator|=
name|v
expr_stmt|;
name|v
operator|=
name|getenv
argument_list|(
literal|"PATCH_VERSION_CONTROL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
name|v
operator|=
name|getenv
argument_list|(
literal|"VERSION_CONTROL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&&
operator|*
name|v
condition|)
name|backup_type
operator|=
name|get_version
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
comment|/* Cons up the names of the global temporary files.        Do this before `cleanup' can possibly be called (e.g. by `pfatal').  */
name|TMPOUTNAME
operator|=
name|make_temp
argument_list|(
literal|'o'
argument_list|)
expr_stmt|;
name|TMPINNAME
operator|=
name|make_temp
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
name|TMPREJNAME
operator|=
name|make_temp
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
name|TMPPATNAME
operator|=
name|make_temp
argument_list|(
literal|'p'
argument_list|)
expr_stmt|;
comment|/* parse switches */
name|Argc
operator|=
name|argc
expr_stmt|;
name|Argv
operator|=
name|argv
expr_stmt|;
name|get_some_switches
argument_list|()
expr_stmt|;
name|init_output
argument_list|(
name|outfile
argument_list|,
operator|&
name|outstate
argument_list|)
expr_stmt|;
comment|/* Make sure we clean up in case of disaster.  */
name|set_signals
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|open_patch_file
argument_list|(
name|patchname
argument_list|)
init|;
name|there_is_another_patch
argument_list|()
condition|;
name|reinitialize_almost_everything
argument_list|()
control|)
block|{
comment|/* for each patch in patch file */
name|int
name|hunk
init|=
literal|0
decl_stmt|;
name|int
name|failed
init|=
literal|0
decl_stmt|;
name|int
name|mismatch
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|outname
init|=
name|outfile
condition|?
name|outfile
else|:
name|inname
decl_stmt|;
if|if
condition|(
operator|!
name|skip_rest_of_patch
condition|)
name|get_input_file
argument_list|(
name|inname
argument_list|,
name|outname
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff_type
operator|==
name|ED_DIFF
condition|)
block|{
name|outstate
operator|.
name|zero_output
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|dry_run
condition|)
block|{
name|do_ed_script
argument_list|(
name|outstate
operator|.
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outfile
condition|)
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|TMPOUTNAME
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal
argument_list|(
literal|"%s"
argument_list|,
name|TMPOUTNAME
argument_list|)
expr_stmt|;
name|outstate
operator|.
name|zero_output
operator|=
name|statbuf
operator|.
name|st_size
operator|==
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|got_hunk
decl_stmt|;
name|int
name|apply_anyway
init|=
literal|0
decl_stmt|;
comment|/* initialize the patched file */
if|if
condition|(
operator|!
name|skip_rest_of_patch
operator|&&
operator|!
name|outfile
condition|)
name|init_output
argument_list|(
name|TMPOUTNAME
argument_list|,
operator|&
name|outstate
argument_list|)
expr_stmt|;
comment|/* initialize reject file */
name|init_reject
argument_list|(
name|TMPREJNAME
argument_list|)
expr_stmt|;
comment|/* find out where all the lines are */
if|if
condition|(
operator|!
name|skip_rest_of_patch
condition|)
name|scan_input
argument_list|(
name|inname
argument_list|)
expr_stmt|;
comment|/* from here on, open no standard i/o files, because malloc */
comment|/* might misfire and we can't catch it easily */
comment|/* apply each hunk of patch */
while|while
condition|(
literal|0
operator|<
operator|(
name|got_hunk
operator|=
name|another_hunk
argument_list|(
name|diff_type
argument_list|,
name|reverse
argument_list|)
operator|)
condition|)
block|{
name|LINENUM
name|where
init|=
literal|0
decl_stmt|;
comment|/* Pacify `gcc -Wall'.  */
name|LINENUM
name|newwhere
decl_stmt|;
name|LINENUM
name|fuzz
init|=
literal|0
decl_stmt|;
name|LINENUM
name|prefix_context
init|=
name|pch_prefix_context
argument_list|()
decl_stmt|;
name|LINENUM
name|suffix_context
init|=
name|pch_suffix_context
argument_list|()
decl_stmt|;
name|LINENUM
name|context
init|=
operator|(
name|prefix_context
operator|<
name|suffix_context
condition|?
name|suffix_context
else|:
name|prefix_context
operator|)
decl_stmt|;
name|LINENUM
name|mymaxfuzz
init|=
operator|(
name|maxfuzz
operator|<
name|context
condition|?
name|maxfuzz
else|:
name|context
operator|)
decl_stmt|;
name|hunk
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|skip_rest_of_patch
condition|)
block|{
do|do
block|{
name|where
operator|=
name|locate_hunk
argument_list|(
name|fuzz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|where
operator|||
name|fuzz
operator|||
name|last_offset
condition|)
name|mismatch
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hunk
operator|==
literal|1
operator|&&
operator|!
name|where
operator|&&
operator|!
operator|(
name|force
operator||
name|apply_anyway
operator|)
operator|&&
name|reverse
operator|==
name|reverse_flag_specified
condition|)
block|{
comment|/* dwim for reversed patch? */
if|if
condition|(
operator|!
name|pch_swap
argument_list|()
condition|)
block|{
name|say
argument_list|(
literal|"Not enough memory to try swapped hunk!  Assuming unswapped.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Try again.  */
name|where
operator|=
name|locate_hunk
argument_list|(
name|fuzz
argument_list|)
expr_stmt|;
if|if
condition|(
name|where
operator|&&
operator|(
name|ok_to_reverse
argument_list|(
literal|"%s patch detected!"
argument_list|,
operator|(
name|reverse
condition|?
literal|"Unreversed"
else|:
literal|"Reversed (or previously applied)"
operator|)
argument_list|)
operator|)
condition|)
name|reverse
operator|^=
literal|1
expr_stmt|;
else|else
block|{
comment|/* Put it back to normal.  */
if|if
condition|(
operator|!
name|pch_swap
argument_list|()
condition|)
name|fatal
argument_list|(
literal|"lost hunk on alloc error!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|where
condition|)
block|{
name|apply_anyway
operator|=
literal|1
expr_stmt|;
name|fuzz
operator|--
expr_stmt|;
comment|/* Undo `++fuzz' below.  */
name|where
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
do|while
condition|(
operator|!
name|skip_rest_of_patch
operator|&&
operator|!
name|where
operator|&&
operator|++
name|fuzz
operator|<=
name|mymaxfuzz
condition|)
do|;
if|if
condition|(
name|skip_rest_of_patch
condition|)
block|{
comment|/* just got decided */
if|if
condition|(
name|outstate
operator|.
name|ofp
operator|&&
operator|!
name|outfile
condition|)
block|{
name|fclose
argument_list|(
name|outstate
operator|.
name|ofp
argument_list|)
expr_stmt|;
name|outstate
operator|.
name|ofp
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|newwhere
operator|=
name|pch_newfirst
argument_list|()
operator|+
name|last_offset
expr_stmt|;
if|if
condition|(
name|skip_rest_of_patch
condition|)
block|{
name|abort_hunk
argument_list|()
expr_stmt|;
name|failed
operator|++
expr_stmt|;
if|if
condition|(
name|verbosity
operator|==
name|VERBOSE
condition|)
name|say
argument_list|(
literal|"Hunk #%d ignored at %ld.\n"
argument_list|,
name|hunk
argument_list|,
name|newwhere
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|where
operator|||
operator|(
name|where
operator|==
literal|1
operator|&&
name|pch_says_nonexistent
argument_list|(
name|reverse
argument_list|)
operator|&&
name|instat
operator|.
name|st_size
operator|)
condition|)
block|{
if|if
condition|(
name|where
condition|)
name|say
argument_list|(
literal|"Patch attempted to create file `%s', which already exists.\n"
argument_list|,
name|inname
argument_list|)
expr_stmt|;
name|abort_hunk
argument_list|()
expr_stmt|;
name|failed
operator|++
expr_stmt|;
if|if
condition|(
name|verbosity
operator|!=
name|SILENT
condition|)
name|say
argument_list|(
literal|"Hunk #%d FAILED at %ld.\n"
argument_list|,
name|hunk
argument_list|,
name|newwhere
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|apply_hunk
argument_list|(
operator|&
name|outstate
argument_list|,
name|where
argument_list|)
condition|)
block|{
name|abort_hunk
argument_list|()
expr_stmt|;
name|failed
operator|++
expr_stmt|;
if|if
condition|(
name|verbosity
operator|!=
name|SILENT
condition|)
name|say
argument_list|(
literal|"Hunk #%d FAILED at %ld.\n"
argument_list|,
name|hunk
argument_list|,
name|newwhere
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbosity
operator|==
name|VERBOSE
operator|||
operator|(
name|verbosity
operator|!=
name|SILENT
operator|&&
operator|(
name|fuzz
operator|||
name|last_offset
operator|)
operator|)
condition|)
block|{
name|say
argument_list|(
literal|"Hunk #%d succeeded at %ld"
argument_list|,
name|hunk
argument_list|,
name|newwhere
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuzz
condition|)
name|say
argument_list|(
literal|" with fuzz %ld"
argument_list|,
name|fuzz
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_offset
condition|)
name|say
argument_list|(
literal|" (offset %ld line%s)"
argument_list|,
name|last_offset
argument_list|,
name|last_offset
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|say
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|got_hunk
operator|<
literal|0
operator|&&
name|using_plan_a
condition|)
block|{
if|if
condition|(
name|outfile
condition|)
name|fatal
argument_list|(
literal|"out of memory using Plan A"
argument_list|)
expr_stmt|;
name|say
argument_list|(
literal|"\n\nRan out of memory using Plan A -- trying again...\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outstate
operator|.
name|ofp
condition|)
block|{
name|fclose
argument_list|(
name|outstate
operator|.
name|ofp
argument_list|)
expr_stmt|;
name|outstate
operator|.
name|ofp
operator|=
literal|0
expr_stmt|;
block|}
name|fclose
argument_list|(
name|rejfp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* finish spewing out the new file */
if|if
condition|(
operator|!
name|skip_rest_of_patch
condition|)
block|{
name|assert
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spew_output
argument_list|(
operator|&
name|outstate
argument_list|)
condition|)
block|{
name|say
argument_list|(
literal|"Skipping patch.\n"
argument_list|)
expr_stmt|;
name|skip_rest_of_patch
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
comment|/* and put the output where desired */
name|ignore_signals
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|skip_rest_of_patch
operator|&&
operator|!
name|outfile
condition|)
block|{
if|if
condition|(
name|outstate
operator|.
name|zero_output
operator|&&
operator|(
name|remove_empty_files
operator|||
operator|(
name|pch_says_nonexistent
argument_list|(
name|reverse
operator|^
literal|1
argument_list|)
operator|==
literal|2
operator|&&
operator|!
name|posixly_correct
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|verbosity
operator|==
name|VERBOSE
condition|)
name|say
argument_list|(
literal|"Removing file `%s'%s.\n"
argument_list|,
name|outname
argument_list|,
name|dry_run
condition|?
literal|" and any empty ancestor directories"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dry_run
condition|)
block|{
name|move_file
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|outname
argument_list|,
operator|(
name|mode_t
operator|)
literal|0
argument_list|,
operator|(
name|backup_type
operator|!=
name|none
operator|||
operator|(
name|backup_if_mismatch
operator|&&
operator|(
name|mismatch
operator||
name|failed
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|removedirs
argument_list|(
name|outname
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|outstate
operator|.
name|zero_output
operator|&&
name|pch_says_nonexistent
argument_list|(
name|reverse
operator|^
literal|1
argument_list|)
condition|)
block|{
name|mismatch
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|verbosity
operator|!=
name|SILENT
condition|)
name|say
argument_list|(
literal|"File `%s' is not empty after patch, as expected.\n"
argument_list|,
name|outname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dry_run
condition|)
block|{
name|time_t
name|t
decl_stmt|;
name|move_file
argument_list|(
name|TMPOUTNAME
argument_list|,
name|outname
argument_list|,
name|instat
operator|.
name|st_mode
argument_list|,
operator|(
name|backup_type
operator|!=
name|none
operator|||
operator|(
name|backup_if_mismatch
operator|&&
operator|(
name|mismatch
operator||
name|failed
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|set_time
operator||
name|set_utc
operator|)
operator|&&
operator|(
name|t
operator|=
name|pch_timestamp
argument_list|(
name|reverse
operator|^
literal|1
argument_list|)
operator|)
operator|!=
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
block|{
name|struct
name|utimbuf
name|utimbuf
decl_stmt|;
name|utimbuf
operator|.
name|actime
operator|=
name|utimbuf
operator|.
name|modtime
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
operator|!
name|inerrno
operator|&&
operator|!
name|pch_says_nonexistent
argument_list|(
name|reverse
argument_list|)
operator|&&
operator|(
name|t
operator|=
name|pch_timestamp
argument_list|(
name|reverse
argument_list|)
operator|)
operator|!=
operator|(
name|time_t
operator|)
operator|-
literal|1
operator|&&
name|t
operator|!=
name|instat
operator|.
name|st_mtime
condition|)
name|say
argument_list|(
literal|"not setting time of file `%s' (time mismatch)\n"
argument_list|,
name|outname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|force
operator|&&
operator|(
name|mismatch
operator||
name|failed
operator|)
condition|)
name|say
argument_list|(
literal|"not setting time of file `%s' (contents mismatch)\n"
argument_list|,
name|outname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|utime
argument_list|(
name|outname
argument_list|,
operator|&
name|utimbuf
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal
argument_list|(
literal|"can't set timestamp on file `%s'"
argument_list|,
name|outname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inerrno
operator|&&
name|chmod
argument_list|(
name|outname
argument_list|,
name|instat
operator|.
name|st_mode
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal
argument_list|(
literal|"can't set permissions on file `%s'"
argument_list|,
name|outname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|diff_type
operator|!=
name|ED_DIFF
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|rejfp
argument_list|)
operator|!=
literal|0
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
name|failed
condition|)
block|{
name|somefailed
operator|=
name|TRUE
expr_stmt|;
name|say
argument_list|(
literal|"%d out of %d hunk%s %s"
argument_list|,
name|failed
argument_list|,
name|hunk
argument_list|,
literal|"s"
operator|+
operator|(
name|hunk
operator|==
literal|1
operator|)
argument_list|,
name|skip_rest_of_patch
condition|?
literal|"ignored"
else|:
literal|"FAILED"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outname
condition|)
block|{
name|char
modifier|*
name|rej
init|=
name|rejname
decl_stmt|;
if|if
condition|(
operator|!
name|rejname
condition|)
block|{
name|rej
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|outname
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rej
argument_list|,
name|outname
argument_list|)
expr_stmt|;
name|addext
argument_list|(
name|rej
argument_list|,
literal|".rej"
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
block|}
name|say
argument_list|(
literal|" -- saving rejects to %s"
argument_list|,
name|rej
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dry_run
condition|)
block|{
name|move_file
argument_list|(
name|TMPREJNAME
argument_list|,
name|rej
argument_list|,
name|instat
operator|.
name|st_mode
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inerrno
operator|&&
operator|(
name|chmod
argument_list|(
name|rej
argument_list|,
operator|(
name|instat
operator|.
name|st_mode
operator|&
operator|~
operator|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
operator|)
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|pfatal
argument_list|(
literal|"can't set permissions on file `%s'"
argument_list|,
name|rej
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rejname
condition|)
name|free
argument_list|(
name|rej
argument_list|)
expr_stmt|;
block|}
name|say
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|set_signals
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outstate
operator|.
name|ofp
operator|&&
operator|(
name|ferror
argument_list|(
name|outstate
operator|.
name|ofp
argument_list|)
operator|||
name|fclose
argument_list|(
name|outstate
operator|.
name|ofp
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
if|if
condition|(
name|somefailed
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Prepare to find the next patch to do in the patch file. */
end_comment

begin_function
specifier|static
name|void
name|reinitialize_almost_everything
parameter_list|()
block|{
name|re_patch
argument_list|()
expr_stmt|;
name|re_input
argument_list|()
expr_stmt|;
name|input_lines
operator|=
literal|0
expr_stmt|;
name|last_frozen_line
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inname
condition|)
block|{
name|free
argument_list|(
name|inname
argument_list|)
expr_stmt|;
name|inname
operator|=
literal|0
expr_stmt|;
block|}
name|last_offset
operator|=
literal|0
expr_stmt|;
name|diff_type
operator|=
name|NO_DIFF
expr_stmt|;
if|if
condition|(
name|revision
condition|)
block|{
name|free
argument_list|(
name|revision
argument_list|)
expr_stmt|;
name|revision
operator|=
literal|0
expr_stmt|;
block|}
name|reverse
operator|=
name|reverse_flag_specified
expr_stmt|;
name|skip_rest_of_patch
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
specifier|const
name|shortopts
index|[]
init|=
literal|"bB:cd:D:eEfF:g:i:lnNo:p:r:RstTuvV:x:Y:z:Z"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|option
specifier|const
name|longopts
index|[]
init|=
block|{
block|{
literal|"backup"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
block|{
literal|"prefix"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'B'
block|}
block|,
block|{
literal|"context"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"directory"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"ifdef"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'D'
block|}
block|,
block|{
literal|"ed"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
block|{
literal|"remove-empty-files"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'E'
block|}
block|,
block|{
literal|"force"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"fuzz"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'F'
block|}
block|,
block|{
literal|"get"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'g'
block|}
block|,
block|{
literal|"input"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'i'
block|}
block|,
block|{
literal|"ignore-whitespace"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
literal|"normal"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"forward"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'N'
block|}
block|,
block|{
literal|"output"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'o'
block|}
block|,
block|{
literal|"strip"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'p'
block|}
block|,
block|{
literal|"reject-file"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'r'
block|}
block|,
block|{
literal|"reverse"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'R'
block|}
block|,
block|{
literal|"quiet"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"silent"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"batch"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
block|{
literal|"set-time"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'T'
block|}
block|,
block|{
literal|"unified"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'u'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
literal|"version-control"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
literal|"debug"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'x'
block|}
block|,
block|{
literal|"basename-prefix"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'Y'
block|}
block|,
block|{
literal|"suffix"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'z'
block|}
block|,
block|{
literal|"set-utc"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'Z'
block|}
block|,
block|{
literal|"dry-run"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|129
block|}
block|,
block|{
literal|"verbose"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|130
block|}
block|,
block|{
literal|"binary"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|131
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|132
block|}
block|,
block|{
literal|"backup-if-mismatch"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|133
block|}
block|,
block|{
literal|"no-backup-if-mismatch"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|134
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|option_help
index|[]
init|=
block|{
literal|"Input options:"
block|,
literal|""
block|,
literal|"  -p NUM  --strip=NUM  Strip NUM leading components from file names."
block|,
literal|"  -F LINES  --fuzz LINES  Set the fuzz factor to LINES for inexact matching."
block|,
literal|"  -l  --ignore-whitespace  Ignore white space changes between patch and input."
block|,
literal|""
block|,
literal|"  -c  --context  Interpret the patch as a context difference."
block|,
literal|"  -e  --ed  Interpret the patch as an ed script."
block|,
literal|"  -n  --normal  Interpret the patch as a normal difference."
block|,
literal|"  -u  --unified  Interpret the patch as a unified difference."
block|,
literal|""
block|,
literal|"  -N  --forward  Ignore patches that appear to be reversed or already applied."
block|,
literal|"  -R  --reverse  Assume patches were created with old and new files swapped."
block|,
literal|""
block|,
literal|"  -i PATCHFILE  --input=PATCHFILE  Read patch from PATCHFILE instead of stdin."
block|,
literal|""
block|,
literal|"Output options:"
block|,
literal|""
block|,
literal|"  -o FILE  --output=FILE  Output patched files to FILE."
block|,
literal|"  -r FILE  --reject-file=FILE  Output rejects to FILE."
block|,
literal|""
block|,
literal|"  -D NAME  --ifdef=NAME  Make merged if-then-else output using NAME."
block|,
literal|"  -E  --remove-empty-files  Remove output files that are empty after patching."
block|,
literal|""
block|,
literal|"  -Z  --set-utc  Set times of patched files, assuming diff uses UTC (GMT)."
block|,
literal|"  -T  --set-time  Likewise, assuming local time."
block|,
literal|""
block|,
literal|"Backup and version control options:"
block|,
literal|""
block|,
literal|"  -V STYLE  --version-control=STYLE  Use STYLE version control."
block|,
literal|"	STYLE is either 'simple', 'numbered', or 'existing'."
block|,
literal|""
block|,
literal|"  -b  --backup  Back up the original contents of each file."
block|,
literal|"  --backup-if-mismatch  Back up if the patch does not match exactly."
block|,
literal|"  --no-backup-if-mismatch  Back up mismatches only if otherwise requested."
block|,
literal|"  -B PREFIX  --prefix=PREFIX  Prepend PREFIX to backup file names."
block|,
literal|"  -Y PREFIX  --basename-prefix=PREFIX  Prepend PREFIX to backup file basenames."
block|,
literal|"  -z SUFFIX  --suffix=SUFFIX  Append SUFFIX to backup file names."
block|,
literal|""
block|,
literal|"  -g NUM  --get=NUM  Get files from RCS or SCCS if positive; ask if negative."
block|,
literal|""
block|,
literal|"Miscellaneous options:"
block|,
literal|""
block|,
literal|"  -t  --batch  Ask no questions; skip bad-Prereq patches; assume reversed."
block|,
literal|"  -f  --force  Like -t, but ignore bad-Prereq patches, and assume unreversed."
block|,
literal|"  -s  --quiet  --silent  Work silently unless an error occurs."
block|,
literal|"  --verbose  Output extra information about the work being done."
block|,
literal|"  --dry-run  Do not actually change any files; just print what would happen."
block|,
literal|""
block|,
literal|"  -d DIR  --directory=DIR  Change the working directory to DIR first."
block|,
if|#
directive|if
name|HAVE_SETMODE
literal|"  --binary  Read and write data in binary mode."
block|,
else|#
directive|else
literal|"  --binary  Read and write data in binary mode (no effect on this platform)."
block|,
endif|#
directive|endif
literal|""
block|,
literal|"  -v  --version  Output version info."
block|,
literal|"  --help  Output this help."
block|,
literal|""
block|,
literal|"Report bugs to<bug-gnu-utils@prep.ai.mit.edu>."
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|stream
parameter_list|,
name|status
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s: Try `%s --help' for more information.\n"
argument_list|,
name|program_name
argument_list|,
name|Argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"Usage: %s [OPTION]... [ORIGFILE [PATCHFILE]]\n\n"
argument_list|,
name|Argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|option_help
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process switches and filenames.  */
end_comment

begin_function
specifier|static
name|void
name|get_some_switches
parameter_list|()
block|{
specifier|register
name|int
name|optc
decl_stmt|;
if|if
condition|(
name|rejname
condition|)
name|free
argument_list|(
name|rejname
argument_list|)
expr_stmt|;
name|rejname
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|optind
operator|==
name|Argc
condition|)
return|return;
while|while
condition|(
operator|(
name|optc
operator|=
name|getopt_long
argument_list|(
name|Argc
argument_list|,
name|Argv
argument_list|,
name|shortopts
argument_list|,
name|longopts
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|optc
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* Special hack for backward compatibility with CVS 1.9. 		    If the last 4 args are `-b SUFFIX ORIGFILE PATCHFILE', 		    treat `-b' as if it were `-z'.  */
if|if
condition|(
name|Argc
operator|-
name|optind
operator|==
literal|3
operator|&&
name|strcmp
argument_list|(
name|Argv
index|[
name|optind
operator|-
literal|1
index|]
argument_list|,
literal|"-b"
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|Argv
index|[
name|optind
operator|+
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|Argv
index|[
name|optind
operator|+
literal|0
index|]
index|[
literal|1
index|]
operator|)
operator|&&
operator|!
operator|(
name|Argv
index|[
name|optind
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|Argv
index|[
name|optind
operator|+
literal|1
index|]
index|[
literal|1
index|]
operator|)
operator|&&
operator|!
operator|(
name|Argv
index|[
name|optind
operator|+
literal|2
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|Argv
index|[
name|optind
operator|+
literal|2
index|]
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|optarg
operator|=
name|Argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|verbosity
operator|!=
name|SILENT
condition|)
name|say
argument_list|(
literal|"warning: the `-b %s' option is obsolete; use `-z %s' instead\n"
argument_list|,
name|optarg
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
goto|goto
name|case_z
goto|;
block|}
name|backup_type
operator|=
name|simple
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
operator|!
operator|*
name|optarg
condition|)
name|fatal
argument_list|(
literal|"backup prefix is empty"
argument_list|)
expr_stmt|;
name|origprae
operator|=
name|savestr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|diff_type
operator|=
name|CONTEXT_DIFF
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|chdir
argument_list|(
name|optarg
argument_list|)
operator|<
literal|0
condition|)
name|pfatal
argument_list|(
literal|"can't change directory to `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|do_defines
operator|=
name|savestr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|diff_type
operator|=
name|ED_DIFF
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|remove_empty_files
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|maxfuzz
operator|=
name|numeric_string
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|,
literal|"fuzz factor"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|patch_get
operator|=
name|numeric_string
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|,
literal|"get option value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|patchname
operator|=
name|savestr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|canonicalize
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|diff_type
operator|=
name|NORMAL_DIFF
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|noreverse
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"can't output patches to standard output"
argument_list|)
expr_stmt|;
name|outfile
operator|=
name|savestr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|strippath
operator|=
name|numeric_string
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|,
literal|"strip count"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|rejname
operator|=
name|savestr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|reverse
operator|=
literal|1
expr_stmt|;
name|reverse_flag_specified
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|verbosity
operator|=
name|SILENT
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|batch
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|set_time
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|diff_type
operator|=
name|UNI_DIFF
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|version
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|backup_type
operator|=
name|get_version
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|DEBUGGING
case|case
literal|'x'
case|:
name|debug
operator|=
name|numeric_string
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|,
literal|"debugging option"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'Y'
case|:
if|if
condition|(
operator|!
operator|*
name|optarg
condition|)
name|fatal
argument_list|(
literal|"backup basename prefix is empty"
argument_list|)
expr_stmt|;
name|origbase
operator|=
name|savestr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|case_z
label|:
if|if
condition|(
operator|!
operator|*
name|optarg
condition|)
name|fatal
argument_list|(
literal|"backup suffix is empty"
argument_list|)
expr_stmt|;
name|simple_backup_suffix
operator|=
name|savestr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|set_utc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|129
case|:
name|dry_run
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|130
case|:
name|verbosity
operator|=
name|VERBOSE
expr_stmt|;
break|break;
case|case
literal|131
case|:
if|#
directive|if
name|HAVE_SETMODE
name|binary_transput
operator|=
name|O_BINARY
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|132
case|:
name|usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|133
case|:
name|backup_if_mismatch
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|134
case|:
name|backup_if_mismatch
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process any filename args.  */
if|if
condition|(
name|optind
operator|<
name|Argc
condition|)
block|{
name|inname
operator|=
name|savestr
argument_list|(
name|Argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
name|invc
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|Argc
condition|)
block|{
name|patchname
operator|=
name|savestr
argument_list|(
name|Argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|Argc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: extra operand `%s'\n"
argument_list|,
name|program_name
argument_list|,
name|Argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|stderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle STRING (possibly negative if NEGATIVE_ALLOWED is nonzero)    of type ARGTYPE_MSGID by converting it to an integer,    returning the result.  */
end_comment

begin_function
specifier|static
name|int
name|numeric_string
parameter_list|(
name|string
parameter_list|,
name|negative_allowed
parameter_list|,
name|argtype_msgid
parameter_list|)
name|char
specifier|const
modifier|*
name|string
decl_stmt|;
name|int
name|negative_allowed
decl_stmt|;
name|char
specifier|const
modifier|*
name|argtype_msgid
decl_stmt|;
block|{
name|int
name|value
init|=
literal|0
decl_stmt|;
name|char
specifier|const
modifier|*
name|p
init|=
name|string
decl_stmt|;
name|int
name|sign
init|=
operator|*
name|p
operator|==
literal|'-'
condition|?
operator|-
literal|1
else|:
literal|1
decl_stmt|;
name|p
operator|+=
operator|*
name|p
operator|==
literal|'-'
operator|||
operator|*
name|p
operator|==
literal|'+'
expr_stmt|;
do|do
block|{
name|int
name|v10
init|=
name|value
operator|*
literal|10
decl_stmt|;
name|int
name|digit
init|=
operator|*
name|p
operator|-
literal|'0'
decl_stmt|;
name|int
name|signed_digit
init|=
name|sign
operator|*
name|digit
decl_stmt|;
name|int
name|next_value
init|=
name|v10
operator|+
name|signed_digit
decl_stmt|;
if|if
condition|(
literal|9
operator|<
operator|(
name|unsigned
operator|)
name|digit
condition|)
name|fatal
argument_list|(
literal|"%s `%s' is not a number"
argument_list|,
name|argtype_msgid
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|v10
operator|/
literal|10
operator|!=
name|value
operator|||
operator|(
name|next_value
operator|<
name|v10
operator|)
operator|!=
operator|(
name|signed_digit
operator|<
literal|0
operator|)
condition|)
name|fatal
argument_list|(
literal|"%s `%s' is too large"
argument_list|,
name|argtype_msgid
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|value
operator|=
name|next_value
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|++
name|p
condition|)
do|;
if|if
condition|(
name|value
operator|<
literal|0
operator|&&
operator|!
name|negative_allowed
condition|)
name|fatal
argument_list|(
literal|"%s `%s' is negative"
argument_list|,
name|argtype_msgid
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Attempt to find the right place to apply this hunk of patch. */
end_comment

begin_function
specifier|static
name|LINENUM
name|locate_hunk
parameter_list|(
name|fuzz
parameter_list|)
name|LINENUM
name|fuzz
decl_stmt|;
block|{
specifier|register
name|LINENUM
name|first_guess
init|=
name|pch_first
argument_list|()
operator|+
name|last_offset
decl_stmt|;
specifier|register
name|LINENUM
name|offset
decl_stmt|;
name|LINENUM
name|pat_lines
init|=
name|pch_ptrn_lines
argument_list|()
decl_stmt|;
name|LINENUM
name|prefix_context
init|=
name|pch_prefix_context
argument_list|()
decl_stmt|;
name|LINENUM
name|suffix_context
init|=
name|pch_suffix_context
argument_list|()
decl_stmt|;
name|LINENUM
name|context
init|=
operator|(
name|prefix_context
operator|<
name|suffix_context
condition|?
name|suffix_context
else|:
name|prefix_context
operator|)
decl_stmt|;
name|LINENUM
name|prefix_fuzz
init|=
name|fuzz
operator|+
name|prefix_context
operator|-
name|context
decl_stmt|;
name|LINENUM
name|suffix_fuzz
init|=
name|fuzz
operator|+
name|suffix_context
operator|-
name|context
decl_stmt|;
name|LINENUM
name|max_where
init|=
name|input_lines
operator|-
operator|(
name|pat_lines
operator|-
name|suffix_fuzz
operator|)
operator|+
literal|1
decl_stmt|;
name|LINENUM
name|min_where
init|=
name|last_frozen_line
operator|+
literal|1
operator|-
operator|(
name|prefix_context
operator|-
name|prefix_fuzz
operator|)
decl_stmt|;
name|LINENUM
name|max_pos_offset
init|=
name|max_where
operator|-
name|first_guess
decl_stmt|;
name|LINENUM
name|max_neg_offset
init|=
name|first_guess
operator|-
name|min_where
decl_stmt|;
name|LINENUM
name|max_offset
init|=
operator|(
name|max_pos_offset
operator|<
name|max_neg_offset
condition|?
name|max_neg_offset
else|:
name|max_pos_offset
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|pat_lines
condition|)
comment|/* null range matches always */
return|return
name|first_guess
return|;
comment|/* Do not try lines<= 0.  */
if|if
condition|(
name|first_guess
operator|<=
name|max_neg_offset
condition|)
name|max_neg_offset
operator|=
name|first_guess
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|prefix_fuzz
operator|<
literal|0
condition|)
block|{
comment|/* Can only match start of file.  */
if|if
condition|(
name|suffix_fuzz
operator|<
literal|0
condition|)
comment|/* Can only match entire file.  */
if|if
condition|(
name|pat_lines
operator|!=
name|input_lines
operator|||
name|prefix_context
operator|<
name|last_frozen_line
condition|)
return|return
literal|0
return|;
name|offset
operator|=
literal|1
operator|-
name|first_guess
expr_stmt|;
return|return
operator|(
operator|(
name|last_frozen_line
operator|<=
name|prefix_context
operator|&&
name|offset
operator|<=
name|max_pos_offset
operator|&&
name|patch_match
argument_list|(
name|first_guess
argument_list|,
name|offset
argument_list|,
operator|(
name|LINENUM
operator|)
literal|0
argument_list|,
name|suffix_fuzz
argument_list|)
operator|)
condition|?
name|first_guess
else|:
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|suffix_fuzz
operator|<
literal|0
condition|)
block|{
comment|/* Can only match end of file.  */
name|offset
operator|=
name|first_guess
operator|-
operator|(
name|input_lines
operator|-
name|pat_lines
operator|+
literal|1
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|offset
operator|<=
name|max_neg_offset
operator|&&
name|patch_match
argument_list|(
name|first_guess
argument_list|,
operator|-
name|offset
argument_list|,
name|prefix_fuzz
argument_list|,
operator|(
name|LINENUM
operator|)
literal|0
argument_list|)
operator|)
condition|?
name|first_guess
else|:
literal|0
operator|)
return|;
block|}
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<=
name|max_offset
condition|;
name|offset
operator|++
control|)
block|{
if|if
condition|(
name|offset
operator|<=
name|max_pos_offset
operator|&&
name|patch_match
argument_list|(
name|first_guess
argument_list|,
name|offset
argument_list|,
name|prefix_fuzz
argument_list|,
name|suffix_fuzz
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
operator|&
literal|1
condition|)
name|say
argument_list|(
literal|"Offset changing from %ld to %ld\n"
argument_list|,
name|last_offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|last_offset
operator|=
name|offset
expr_stmt|;
return|return
name|first_guess
operator|+
name|offset
return|;
block|}
if|if
condition|(
literal|0
operator|<
name|offset
operator|&&
name|offset
operator|<=
name|max_neg_offset
operator|&&
name|patch_match
argument_list|(
name|first_guess
argument_list|,
operator|-
name|offset
argument_list|,
name|prefix_fuzz
argument_list|,
name|suffix_fuzz
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
operator|&
literal|1
condition|)
name|say
argument_list|(
literal|"Offset changing from %ld to %ld\n"
argument_list|,
name|last_offset
argument_list|,
operator|-
name|offset
argument_list|)
expr_stmt|;
name|last_offset
operator|=
operator|-
name|offset
expr_stmt|;
return|return
name|first_guess
operator|-
name|offset
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* We did not find the pattern, dump out the hunk so they can handle it. */
end_comment

begin_function
specifier|static
name|void
name|abort_hunk
parameter_list|()
block|{
specifier|register
name|LINENUM
name|i
decl_stmt|;
specifier|register
name|LINENUM
name|pat_end
init|=
name|pch_end
argument_list|()
decl_stmt|;
comment|/* add in last_offset to guess the same as the previous successful hunk */
name|LINENUM
name|oldfirst
init|=
name|pch_first
argument_list|()
operator|+
name|last_offset
decl_stmt|;
name|LINENUM
name|newfirst
init|=
name|pch_newfirst
argument_list|()
operator|+
name|last_offset
decl_stmt|;
name|LINENUM
name|oldlast
init|=
name|oldfirst
operator|+
name|pch_ptrn_lines
argument_list|()
operator|-
literal|1
decl_stmt|;
name|LINENUM
name|newlast
init|=
name|newfirst
operator|+
name|pch_repl_lines
argument_list|()
operator|-
literal|1
decl_stmt|;
name|char
specifier|const
modifier|*
name|stars
init|=
operator|(
name|int
operator|)
name|NEW_CONTEXT_DIFF
operator|<=
operator|(
name|int
operator|)
name|diff_type
condition|?
literal|" ****"
else|:
literal|""
decl_stmt|;
name|char
specifier|const
modifier|*
name|minuses
init|=
operator|(
name|int
operator|)
name|NEW_CONTEXT_DIFF
operator|<=
operator|(
name|int
operator|)
name|diff_type
condition|?
literal|" ----"
else|:
literal|" -----"
decl_stmt|;
name|fprintf
argument_list|(
name|rejfp
argument_list|,
literal|"***************\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|pat_end
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|pch_char
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
literal|'*'
case|:
if|if
condition|(
name|oldlast
operator|<
name|oldfirst
condition|)
name|fprintf
argument_list|(
name|rejfp
argument_list|,
literal|"*** 0%s\n"
argument_list|,
name|stars
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|oldlast
operator|==
name|oldfirst
condition|)
name|fprintf
argument_list|(
name|rejfp
argument_list|,
literal|"*** %ld%s\n"
argument_list|,
name|oldfirst
argument_list|,
name|stars
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|rejfp
argument_list|,
literal|"*** %ld,%ld%s\n"
argument_list|,
name|oldfirst
argument_list|,
name|oldlast
argument_list|,
name|stars
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
if|if
condition|(
name|newlast
operator|<
name|newfirst
condition|)
name|fprintf
argument_list|(
name|rejfp
argument_list|,
literal|"--- 0%s\n"
argument_list|,
name|minuses
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|newlast
operator|==
name|newfirst
condition|)
name|fprintf
argument_list|(
name|rejfp
argument_list|,
literal|"--- %ld%s\n"
argument_list|,
name|newfirst
argument_list|,
name|minuses
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|rejfp
argument_list|,
literal|"--- %ld,%ld%s\n"
argument_list|,
name|newfirst
argument_list|,
name|newlast
argument_list|,
name|minuses
argument_list|)
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'-'
case|:
case|case
literal|'+'
case|:
case|case
literal|'!'
case|:
name|fprintf
argument_list|(
name|rejfp
argument_list|,
literal|"%c "
argument_list|,
name|pch_char
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fall into */
case|case
literal|'\n'
case|:
name|pch_write_line
argument_list|(
name|i
argument_list|,
name|rejfp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"fatal internal error in abort_hunk"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|rejfp
argument_list|)
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We found where to apply it (we hope), so do it. */
end_comment

begin_function
specifier|static
name|bool
name|apply_hunk
parameter_list|(
name|outstate
parameter_list|,
name|where
parameter_list|)
name|struct
name|outstate
modifier|*
name|outstate
decl_stmt|;
name|LINENUM
name|where
decl_stmt|;
block|{
specifier|register
name|LINENUM
name|old
init|=
literal|1
decl_stmt|;
specifier|register
name|LINENUM
name|lastline
init|=
name|pch_ptrn_lines
argument_list|()
decl_stmt|;
specifier|register
name|LINENUM
name|new
init|=
name|lastline
operator|+
literal|1
decl_stmt|;
specifier|register
enum|enum
block|{
name|OUTSIDE
block|,
name|IN_IFNDEF
block|,
name|IN_IFDEF
block|,
name|IN_ELSE
block|}
name|def_state
init|=
name|OUTSIDE
enum|;
specifier|register
name|char
specifier|const
modifier|*
name|R_do_defines
init|=
name|do_defines
decl_stmt|;
specifier|register
name|LINENUM
name|pat_end
init|=
name|pch_end
argument_list|()
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
init|=
name|outstate
operator|->
name|ofp
decl_stmt|;
name|where
operator|--
expr_stmt|;
while|while
condition|(
name|pch_char
argument_list|(
name|new
argument_list|)
operator|==
literal|'='
operator|||
name|pch_char
argument_list|(
name|new
argument_list|)
operator|==
literal|'\n'
condition|)
name|new
operator|++
expr_stmt|;
while|while
condition|(
name|old
operator|<=
name|lastline
condition|)
block|{
if|if
condition|(
name|pch_char
argument_list|(
name|old
argument_list|)
operator|==
literal|'-'
condition|)
block|{
name|assert
argument_list|(
name|outstate
operator|->
name|after_newline
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copy_till
argument_list|(
name|outstate
argument_list|,
name|where
operator|+
name|old
operator|-
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|R_do_defines
condition|)
block|{
if|if
condition|(
name|def_state
operator|==
name|OUTSIDE
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
name|outstate
operator|->
name|after_newline
operator|+
name|if_defined
argument_list|,
name|R_do_defines
argument_list|)
expr_stmt|;
name|def_state
operator|=
name|IN_IFNDEF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|def_state
operator|==
name|IN_IFDEF
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
name|outstate
operator|->
name|after_newline
operator|+
name|else_defined
argument_list|)
expr_stmt|;
name|def_state
operator|=
name|IN_ELSE
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
name|outstate
operator|->
name|after_newline
operator|=
name|pch_write_line
argument_list|(
name|old
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|outstate
operator|->
name|zero_output
operator|=
literal|0
expr_stmt|;
block|}
name|last_frozen_line
operator|++
expr_stmt|;
name|old
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new
operator|>
name|pat_end
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|pch_char
argument_list|(
name|new
argument_list|)
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
operator|!
name|copy_till
argument_list|(
name|outstate
argument_list|,
name|where
operator|+
name|old
operator|-
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|R_do_defines
condition|)
block|{
if|if
condition|(
name|def_state
operator|==
name|IN_IFNDEF
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
name|outstate
operator|->
name|after_newline
operator|+
name|else_defined
argument_list|)
expr_stmt|;
name|def_state
operator|=
name|IN_ELSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|def_state
operator|==
name|OUTSIDE
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
name|outstate
operator|->
name|after_newline
operator|+
name|if_defined
argument_list|,
name|R_do_defines
argument_list|)
expr_stmt|;
name|def_state
operator|=
name|IN_IFDEF
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
block|}
name|outstate
operator|->
name|after_newline
operator|=
name|pch_write_line
argument_list|(
name|new
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|outstate
operator|->
name|zero_output
operator|=
literal|0
expr_stmt|;
name|new
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pch_char
argument_list|(
name|new
argument_list|)
operator|!=
name|pch_char
argument_list|(
name|old
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
operator|&
literal|1
condition|)
name|say
argument_list|(
literal|"oldchar = '%c', newchar = '%c'\n"
argument_list|,
name|pch_char
argument_list|(
name|old
argument_list|)
argument_list|,
name|pch_char
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"Out-of-sync patch, lines %ld,%ld -- mangled text or line numbers, maybe?"
argument_list|,
name|pch_hunk_beg
argument_list|()
operator|+
name|old
argument_list|,
name|pch_hunk_beg
argument_list|()
operator|+
name|new
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pch_char
argument_list|(
name|new
argument_list|)
operator|==
literal|'!'
condition|)
block|{
name|assert
argument_list|(
name|outstate
operator|->
name|after_newline
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copy_till
argument_list|(
name|outstate
argument_list|,
name|where
operator|+
name|old
operator|-
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|assert
argument_list|(
name|outstate
operator|->
name|after_newline
argument_list|)
expr_stmt|;
if|if
condition|(
name|R_do_defines
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
name|not_defined
argument_list|,
name|R_do_defines
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
name|def_state
operator|=
name|IN_IFNDEF
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
name|R_do_defines
condition|)
block|{
name|outstate
operator|->
name|after_newline
operator|=
name|pch_write_line
argument_list|(
name|old
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|last_frozen_line
operator|++
expr_stmt|;
name|old
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|pch_char
argument_list|(
name|old
argument_list|)
operator|==
literal|'!'
condition|)
do|;
if|if
condition|(
name|R_do_defines
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
name|outstate
operator|->
name|after_newline
operator|+
name|else_defined
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
name|def_state
operator|=
name|IN_ELSE
expr_stmt|;
block|}
do|do
block|{
name|outstate
operator|->
name|after_newline
operator|=
name|pch_write_line
argument_list|(
name|new
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|new
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|pch_char
argument_list|(
name|new
argument_list|)
operator|==
literal|'!'
condition|)
do|;
name|outstate
operator|->
name|zero_output
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|pch_char
argument_list|(
name|new
argument_list|)
operator|==
literal|' '
argument_list|)
expr_stmt|;
name|old
operator|++
expr_stmt|;
name|new
operator|++
expr_stmt|;
if|if
condition|(
name|R_do_defines
operator|&&
name|def_state
operator|!=
name|OUTSIDE
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
name|outstate
operator|->
name|after_newline
operator|+
name|end_defined
argument_list|,
name|R_do_defines
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
name|outstate
operator|->
name|after_newline
operator|=
literal|1
expr_stmt|;
name|def_state
operator|=
name|OUTSIDE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|new
operator|<=
name|pat_end
operator|&&
name|pch_char
argument_list|(
name|new
argument_list|)
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
operator|!
name|copy_till
argument_list|(
name|outstate
argument_list|,
name|where
operator|+
name|old
operator|-
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|R_do_defines
condition|)
block|{
if|if
condition|(
name|def_state
operator|==
name|OUTSIDE
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
name|outstate
operator|->
name|after_newline
operator|+
name|if_defined
argument_list|,
name|R_do_defines
argument_list|)
expr_stmt|;
name|def_state
operator|=
name|IN_IFDEF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|def_state
operator|==
name|IN_IFNDEF
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
name|outstate
operator|->
name|after_newline
operator|+
name|else_defined
argument_list|)
expr_stmt|;
name|def_state
operator|=
name|IN_ELSE
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
name|outstate
operator|->
name|zero_output
operator|=
literal|0
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
operator|!
name|outstate
operator|->
name|after_newline
operator|&&
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
name|outstate
operator|->
name|after_newline
operator|=
name|pch_write_line
argument_list|(
name|new
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|outstate
operator|->
name|zero_output
operator|=
literal|0
expr_stmt|;
name|new
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|new
operator|<=
name|pat_end
operator|&&
name|pch_char
argument_list|(
name|new
argument_list|)
operator|==
literal|'+'
condition|)
do|;
block|}
if|if
condition|(
name|R_do_defines
operator|&&
name|def_state
operator|!=
name|OUTSIDE
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
name|outstate
operator|->
name|after_newline
operator|+
name|end_defined
argument_list|,
name|R_do_defines
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
name|outstate
operator|->
name|after_newline
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create an output file.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|create_output_file
parameter_list|(
name|name
parameter_list|)
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|fd
init|=
name|create_file
argument_list|(
name|name
argument_list|,
name|O_WRONLY
operator||
name|binary_transput
argument_list|,
name|instat
operator|.
name|st_mode
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|fdopen
argument_list|(
name|fd
argument_list|,
name|binary_transput
condition|?
literal|"wb"
else|:
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|pfatal
argument_list|(
literal|"can't create `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/* Open the new file. */
end_comment

begin_function
specifier|static
name|void
name|init_output
parameter_list|(
name|name
parameter_list|,
name|outstate
parameter_list|)
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
name|struct
name|outstate
modifier|*
name|outstate
decl_stmt|;
block|{
name|outstate
operator|->
name|ofp
operator|=
name|name
condition|?
name|create_output_file
argument_list|(
name|name
argument_list|)
else|:
operator|(
name|FILE
operator|*
operator|)
literal|0
expr_stmt|;
name|outstate
operator|->
name|after_newline
operator|=
literal|1
expr_stmt|;
name|outstate
operator|->
name|zero_output
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open a file to put hunks we can't locate. */
end_comment

begin_function
specifier|static
name|void
name|init_reject
parameter_list|(
name|name
parameter_list|)
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
block|{
name|rejfp
operator|=
name|create_output_file
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy input file to output, up to wherever hunk is to be applied. */
end_comment

begin_function
specifier|static
name|bool
name|copy_till
parameter_list|(
name|outstate
parameter_list|,
name|lastline
parameter_list|)
specifier|register
name|struct
name|outstate
modifier|*
name|outstate
decl_stmt|;
specifier|register
name|LINENUM
name|lastline
decl_stmt|;
block|{
specifier|register
name|LINENUM
name|R_last_frozen_line
init|=
name|last_frozen_line
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
init|=
name|outstate
operator|->
name|ofp
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|R_last_frozen_line
operator|>
name|lastline
condition|)
block|{
name|say
argument_list|(
literal|"misordered hunks! output would be garbled\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
while|while
condition|(
name|R_last_frozen_line
operator|<
name|lastline
condition|)
block|{
name|s
operator|=
name|ifetch
argument_list|(
operator|++
name|R_last_frozen_line
argument_list|,
literal|0
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|outstate
operator|->
name|after_newline
operator|&&
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
operator|)
operator|||
operator|!
name|fwrite
argument_list|(
name|s
argument_list|,
sizeof|sizeof
expr|*
name|s
argument_list|,
name|size
argument_list|,
name|fp
argument_list|)
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
name|outstate
operator|->
name|after_newline
operator|=
name|s
index|[
name|size
operator|-
literal|1
index|]
operator|==
literal|'\n'
expr_stmt|;
name|outstate
operator|->
name|zero_output
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|last_frozen_line
operator|=
name|R_last_frozen_line
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish copying the input file to the output file. */
end_comment

begin_function
specifier|static
name|bool
name|spew_output
parameter_list|(
name|outstate
parameter_list|)
name|struct
name|outstate
modifier|*
name|outstate
decl_stmt|;
block|{
if|if
condition|(
name|debug
operator|&
literal|256
condition|)
name|say
argument_list|(
literal|"il=%ld lfl=%ld\n"
argument_list|,
name|input_lines
argument_list|,
name|last_frozen_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_frozen_line
operator|<
name|input_lines
condition|)
if|if
condition|(
operator|!
name|copy_till
argument_list|(
name|outstate
argument_list|,
name|input_lines
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|outstate
operator|->
name|ofp
operator|&&
operator|!
name|outfile
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|outstate
operator|->
name|ofp
argument_list|)
operator|!=
literal|0
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
name|outstate
operator|->
name|ofp
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Does the patch pattern match at line base+offset? */
end_comment

begin_function
specifier|static
name|bool
name|patch_match
parameter_list|(
name|base
parameter_list|,
name|offset
parameter_list|,
name|prefix_fuzz
parameter_list|,
name|suffix_fuzz
parameter_list|)
name|LINENUM
name|base
decl_stmt|;
name|LINENUM
name|offset
decl_stmt|;
name|LINENUM
name|prefix_fuzz
decl_stmt|;
name|LINENUM
name|suffix_fuzz
decl_stmt|;
block|{
specifier|register
name|LINENUM
name|pline
init|=
literal|1
operator|+
name|prefix_fuzz
decl_stmt|;
specifier|register
name|LINENUM
name|iline
decl_stmt|;
specifier|register
name|LINENUM
name|pat_lines
init|=
name|pch_ptrn_lines
argument_list|()
operator|-
name|suffix_fuzz
decl_stmt|;
name|size_t
name|size
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|iline
operator|=
name|base
operator|+
name|offset
operator|+
name|prefix_fuzz
init|;
name|pline
operator|<=
name|pat_lines
condition|;
name|pline
operator|++
operator|,
name|iline
operator|++
control|)
block|{
name|p
operator|=
name|ifetch
argument_list|(
name|iline
argument_list|,
name|offset
operator|>=
literal|0
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|canonicalize
condition|)
block|{
if|if
condition|(
operator|!
name|similar
argument_list|(
name|p
argument_list|,
name|size
argument_list|,
name|pfetch
argument_list|(
name|pline
argument_list|)
argument_list|,
name|pch_line_len
argument_list|(
name|pline
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|size
operator|!=
name|pch_line_len
argument_list|(
name|pline
argument_list|)
operator|||
name|memcmp
argument_list|(
name|p
argument_list|,
name|pfetch
argument_list|(
name|pline
argument_list|)
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Do two lines match with canonicalized white space? */
end_comment

begin_function
specifier|static
name|bool
name|similar
parameter_list|(
name|a
parameter_list|,
name|alen
parameter_list|,
name|b
parameter_list|,
name|blen
parameter_list|)
specifier|register
name|char
specifier|const
modifier|*
name|a
decl_stmt|;
specifier|register
name|size_t
name|alen
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|b
decl_stmt|;
specifier|register
name|size_t
name|blen
decl_stmt|;
block|{
comment|/* Ignore presence or absence of trailing newlines.  */
name|alen
operator|-=
name|alen
operator|&&
name|a
index|[
name|alen
operator|-
literal|1
index|]
operator|==
literal|'\n'
expr_stmt|;
name|blen
operator|-=
name|blen
operator|&&
name|b
index|[
name|blen
operator|-
literal|1
index|]
operator|==
literal|'\n'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|blen
operator|||
operator|(
operator|*
name|b
operator|==
literal|' '
operator|||
operator|*
name|b
operator|==
literal|'\t'
operator|)
condition|)
block|{
while|while
condition|(
name|blen
operator|&&
operator|(
operator|*
name|b
operator|==
literal|' '
operator|||
operator|*
name|b
operator|==
literal|'\t'
operator|)
condition|)
name|b
operator|++
operator|,
name|blen
operator|--
expr_stmt|;
if|if
condition|(
name|alen
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|a
operator|==
literal|' '
operator|||
operator|*
name|a
operator|==
literal|'\t'
operator|)
condition|)
return|return
name|FALSE
return|;
do|do
name|a
operator|++
operator|,
name|alen
operator|--
expr_stmt|;
do|while
condition|(
name|alen
operator|&&
operator|(
operator|*
name|a
operator|==
literal|' '
operator|||
operator|*
name|a
operator|==
literal|'\t'
operator|)
condition|)
do|;
block|}
if|if
condition|(
operator|!
name|alen
operator|||
operator|!
name|blen
condition|)
return|return
name|alen
operator|==
name|blen
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|alen
operator|||
operator|*
name|a
operator|++
operator|!=
operator|*
name|b
operator|++
condition|)
return|return
name|FALSE
return|;
else|else
name|alen
operator|--
operator|,
name|blen
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make a temporary file.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_MKTEMP
end_if

begin_decl_stmt
name|char
modifier|*
name|mktemp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TMPDIR
end_ifndef

begin_define
define|#
directive|define
name|TMPDIR
value|"/tmp"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|make_temp
parameter_list|(
name|letter
parameter_list|)
name|int
name|letter
decl_stmt|;
block|{
name|char
modifier|*
name|r
decl_stmt|;
if|#
directive|if
name|HAVE_MKTEMP
name|char
specifier|const
modifier|*
name|tmpdir
init|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
decl_stmt|;
comment|/* Unix tradition */
if|if
condition|(
operator|!
name|tmpdir
condition|)
name|tmpdir
operator|=
name|getenv
argument_list|(
literal|"TMP"
argument_list|)
expr_stmt|;
comment|/* DOS tradition */
if|if
condition|(
operator|!
name|tmpdir
condition|)
name|tmpdir
operator|=
name|getenv
argument_list|(
literal|"TEMP"
argument_list|)
expr_stmt|;
comment|/* another DOS tradition */
if|if
condition|(
operator|!
name|tmpdir
condition|)
name|tmpdir
operator|=
name|TMPDIR
expr_stmt|;
name|r
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|tmpdir
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|r
argument_list|,
literal|"%s/p%cXXXXXX"
argument_list|,
name|tmpdir
argument_list|,
name|letter
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|r
condition|)
name|pfatal
argument_list|(
literal|"mktemp"
argument_list|)
expr_stmt|;
else|#
directive|else
name|r
operator|=
name|xmalloc
argument_list|(
name|L_tmpnam
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmpnam
argument_list|(
name|r
argument_list|)
operator|==
name|r
operator|&&
operator|*
name|r
operator|)
condition|)
name|pfatal
argument_list|(
literal|"tmpnam"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Fatal exit with cleanup. */
end_comment

begin_function
name|void
name|fatal_exit
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|cleanup
argument_list|()
expr_stmt|;
if|if
condition|(
name|sig
condition|)
name|exit_with_signal
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
name|unlink
argument_list|(
name|TMPINNAME
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|TMPOUTNAME
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|TMPPATNAME
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|TMPREJNAME
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

