begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* inputting files to be patched */
end_comment

begin_comment
comment|/* $Id: inp.c,v 1.16 1997/06/13 06:28:37 eggert Exp $ */
end_comment

begin_comment
comment|/* Copyright 1986, 1988 Larry Wall Copyright 1991, 1992, 1993, 1997 Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_define
define|#
directive|define
name|XTERN
value|extern
end_define

begin_include
include|#
directive|include
file|<common.h>
end_include

begin_include
include|#
directive|include
file|<backupfile.h>
end_include

begin_include
include|#
directive|include
file|<pch.h>
end_include

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_undef
undef|#
directive|undef
name|XTERN
end_undef

begin_define
define|#
directive|define
name|XTERN
end_define

begin_include
include|#
directive|include
file|<inp.h>
end_include

begin_comment
comment|/* Input-file-with-indexable-lines abstract type */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
modifier|*
name|i_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers to lines in plan A buffer */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|tibufsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of plan b buffers */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TIBUFSIZE_MINIMUM
end_ifndef

begin_define
define|#
directive|define
name|TIBUFSIZE_MINIMUM
value|(8 * 1024)
end_define

begin_comment
comment|/* minimum value for tibufsize */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|tifd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* plan b virtual string array */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tibuf
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* plan b buffers */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|tiline
index|[
literal|2
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1st line in each buffer */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|lines_per_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how many lines per buffer */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|tireclen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of records in tmp file */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|last_line_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of last input line */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|plan_a
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* yield FALSE if memory runs out */
end_comment

begin_decl_stmt
specifier|static
name|void
name|plan_b
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|report_revision
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* New patch--prepare to edit another file. */
end_comment

begin_function
name|void
name|re_input
parameter_list|()
block|{
if|if
condition|(
name|using_plan_a
condition|)
block|{
if|if
condition|(
name|i_ptr
condition|)
block|{
name|free
argument_list|(
name|i_ptr
argument_list|)
expr_stmt|;
name|i_ptr
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|close
argument_list|(
name|tifd
argument_list|)
expr_stmt|;
name|tifd
operator|=
operator|-
literal|1
expr_stmt|;
name|free
argument_list|(
name|tibuf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tibuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tiline
index|[
literal|0
index|]
operator|=
name|tiline
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|tireclen
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Construct the line index, somehow or other. */
end_comment

begin_function
name|void
name|scan_input
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|using_plan_a
operator|=
operator|!
operator|(
name|debug
operator|&
literal|16
operator|)
operator|&&
name|plan_a
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|using_plan_a
condition|)
name|plan_b
argument_list|(
name|filename
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|verbosity
condition|)
block|{
case|case
name|SILENT
case|:
break|break;
case|case
name|VERBOSE
case|:
name|say
argument_list|(
literal|"Patching file `%s' using Plan %s...\n"
argument_list|,
name|filename
argument_list|,
name|using_plan_a
condition|?
literal|"A"
else|:
literal|"B"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFAULT_VERBOSITY
case|:
name|say
argument_list|(
literal|"patching file `%s'\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Report whether a desired revision was found.  */
end_comment

begin_function
specifier|static
name|void
name|report_revision
parameter_list|(
name|found_revision
parameter_list|)
name|int
name|found_revision
decl_stmt|;
block|{
if|if
condition|(
name|found_revision
condition|)
block|{
if|if
condition|(
name|verbosity
operator|==
name|VERBOSE
condition|)
name|say
argument_list|(
literal|"Good.  This file appears to be the %s version.\n"
argument_list|,
name|revision
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|force
condition|)
block|{
if|if
condition|(
name|verbosity
operator|!=
name|SILENT
condition|)
name|say
argument_list|(
literal|"Warning: this file doesn't appear to be the %s version -- patching anyway.\n"
argument_list|,
name|revision
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|batch
condition|)
block|{
name|fatal
argument_list|(
literal|"This file doesn't appear to be the %s version -- aborting."
argument_list|,
name|revision
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ask
argument_list|(
literal|"This file doesn't appear to be the %s version -- patch anyway? [n] "
argument_list|,
name|revision
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'y'
condition|)
name|fatal
argument_list|(
literal|"aborted"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|get_input_file
parameter_list|(
name|filename
parameter_list|,
name|outname
parameter_list|)
name|char
specifier|const
modifier|*
name|filename
decl_stmt|;
name|char
specifier|const
modifier|*
name|outname
decl_stmt|;
block|{
name|int
name|elsewhere
init|=
name|strcmp
argument_list|(
name|filename
argument_list|,
name|outname
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|cs
decl_stmt|;
name|char
modifier|*
name|diffbuf
decl_stmt|;
name|char
modifier|*
name|getbuf
decl_stmt|;
if|if
condition|(
name|inerrno
operator|==
operator|-
literal|1
condition|)
name|inerrno
operator|=
name|stat
argument_list|(
name|inname
argument_list|,
operator|&
name|instat
argument_list|)
operator|==
literal|0
condition|?
literal|0
else|:
name|errno
expr_stmt|;
comment|/* Perhaps look for RCS or SCCS versions.  */
if|if
condition|(
name|patch_get
operator|&&
name|invc
operator|!=
literal|0
operator|&&
operator|(
name|inerrno
operator|||
operator|(
operator|!
name|elsewhere
operator|&&
operator|(
comment|/* No one can write to it.  */
operator|(
name|instat
operator|.
name|st_mode
operator|&
operator|(
name|S_IWUSR
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
operator|)
operator|==
literal|0
comment|/* Only the owner (who's not me) can write to it.  */
operator|||
operator|(
operator|(
name|instat
operator|.
name|st_mode
operator|&
operator|(
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
operator|)
operator|==
literal|0
operator|&&
name|instat
operator|.
name|st_uid
operator|!=
name|geteuid
argument_list|()
operator|)
operator|)
operator|)
operator|)
operator|&&
operator|(
name|invc
operator|=
operator|!
operator|!
operator|(
name|cs
operator|=
operator|(
name|version_controller
argument_list|(
name|filename
argument_list|,
name|elsewhere
argument_list|,
name|inerrno
condition|?
operator|(
expr|struct
name|stat
operator|*
operator|)
literal|0
else|:
operator|&
name|instat
argument_list|,
operator|&
name|getbuf
argument_list|,
operator|&
name|diffbuf
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|inerrno
condition|)
block|{
if|if
condition|(
operator|!
name|elsewhere
operator|&&
operator|(
name|instat
operator|.
name|st_mode
operator|&
operator|(
name|S_IWUSR
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
operator|)
operator|!=
literal|0
condition|)
comment|/* Somebody can write to it.  */
name|fatal
argument_list|(
literal|"file `%s' seems to be locked by somebody else under %s"
argument_list|,
name|filename
argument_list|,
name|cs
argument_list|)
expr_stmt|;
comment|/* It might be checked out unlocked.  See if it's safe to 		   check out the default version locked.  */
if|if
condition|(
name|verbosity
operator|==
name|VERBOSE
condition|)
name|say
argument_list|(
literal|"Comparing file `%s' to default %s version...\n"
argument_list|,
name|filename
argument_list|,
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|systemic
argument_list|(
name|diffbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|say
argument_list|(
literal|"warning: patching file `%s', which does not match default %s version\n"
argument_list|,
name|filename
argument_list|,
name|cs
argument_list|)
expr_stmt|;
name|cs
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cs
operator|&&
name|version_get
argument_list|(
name|filename
argument_list|,
name|cs
argument_list|,
operator|!
name|inerrno
argument_list|,
name|elsewhere
argument_list|,
name|getbuf
argument_list|,
operator|&
name|instat
argument_list|)
condition|)
name|inerrno
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|getbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|diffbuf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inerrno
operator|&&
operator|!
name|pch_says_nonexistent
argument_list|(
name|reverse
argument_list|)
condition|)
block|{
name|errno
operator|=
name|inerrno
expr_stmt|;
name|pfatal
argument_list|(
literal|"can't find file `%s'"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inerrno
condition|)
block|{
name|instat
operator|.
name|st_mode
operator|=
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IRGRP
operator||
name|S_IWGRP
operator||
name|S_IROTH
operator||
name|S_IWOTH
expr_stmt|;
name|instat
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|instat
operator|.
name|st_mode
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"`%s' is not a regular file -- can't patch"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try keeping everything in memory. */
end_comment

begin_function
specifier|static
name|bool
name|plan_a
parameter_list|(
name|filename
parameter_list|)
name|char
specifier|const
modifier|*
name|filename
decl_stmt|;
block|{
specifier|register
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|lim
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|buffer
decl_stmt|;
specifier|register
name|LINENUM
name|iline
decl_stmt|;
name|size_t
name|size
init|=
name|instat
operator|.
name|st_size
decl_stmt|;
name|size_t
name|allocated_bytes_per_input_byte
init|=
sizeof|sizeof
expr|*
name|i_ptr
operator|+
sizeof|sizeof
argument_list|(
name|char
argument_list|)
decl_stmt|;
name|size_t
name|allocated_bytes
init|=
operator|(
name|size
operator|+
literal|2
operator|)
operator|*
name|allocated_bytes_per_input_byte
decl_stmt|;
comment|/* Fail if arithmetic overflow occurs during size calculations,      or if storage isn't available.  */
if|if
condition|(
name|size
operator|!=
name|instat
operator|.
name|st_size
operator|||
name|size
operator|+
literal|2
operator|<
literal|2
operator|||
name|allocated_bytes
operator|/
name|allocated_bytes_per_input_byte
operator|!=
name|size
operator|+
literal|2
operator|||
operator|!
operator|(
name|ptr
operator|=
operator|(
name|char
specifier|const
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|allocated_bytes
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|ptr
operator|+
operator|(
name|size
operator|+
literal|2
operator|)
operator|)
expr_stmt|;
comment|/* Read the input file, but don't bother reading it if it's empty.      When creating files, the files do not actually exist.  */
if|if
condition|(
name|size
condition|)
block|{
name|int
name|ifd
init|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
operator||
name|binary_transput
argument_list|)
decl_stmt|;
name|size_t
name|buffered
init|=
literal|0
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|ifd
operator|<
literal|0
condition|)
name|pfatal
argument_list|(
literal|"can't open file `%s'"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|-
name|buffered
operator|!=
literal|0
operator|&&
operator|(
name|n
operator|=
name|read
argument_list|(
name|ifd
argument_list|,
name|buffer
operator|+
name|buffered
argument_list|,
name|size
operator|-
name|buffered
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Perhaps size is too large for this host.  */
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|buffered
operator|+=
name|n
expr_stmt|;
block|}
comment|/* Some non-POSIX hosts exaggerate st_size in text mode; 	 or the file may have shrunk!  */
name|size
operator|=
name|buffered
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|ifd
argument_list|)
operator|!=
literal|0
condition|)
name|read_fatal
argument_list|()
expr_stmt|;
block|}
comment|/* Scan the buffer and build array of pointers to lines.  */
name|iline
operator|=
literal|0
expr_stmt|;
name|lim
operator|=
name|buffer
operator|+
name|size
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buffer
init|;
condition|;
name|s
operator|++
control|)
block|{
name|ptr
index|[
operator|++
name|iline
index|]
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|memchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|,
name|lim
operator|-
name|s
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|size
operator|&&
name|lim
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|ptr
index|[
operator|++
name|iline
index|]
operator|=
name|lim
expr_stmt|;
name|input_lines
operator|=
name|iline
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|revision
condition|)
block|{
name|char
specifier|const
modifier|*
name|rev
init|=
name|revision
decl_stmt|;
name|int
name|rev0
init|=
name|rev
index|[
literal|0
index|]
decl_stmt|;
name|int
name|found_revision
init|=
literal|0
decl_stmt|;
name|size_t
name|revlen
init|=
name|strlen
argument_list|(
name|rev
argument_list|)
decl_stmt|;
if|if
condition|(
name|revlen
operator|<=
name|size
condition|)
block|{
name|char
specifier|const
modifier|*
name|limrev
init|=
name|lim
operator|-
name|revlen
decl_stmt|;
for|for
control|(
name|s
operator|=
name|buffer
init|;
operator|(
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|memchr
argument_list|(
name|s
argument_list|,
name|rev0
argument_list|,
name|limrev
operator|-
name|s
argument_list|)
operator|)
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|memcmp
argument_list|(
name|s
argument_list|,
name|rev
argument_list|,
name|revlen
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|s
operator|==
name|buffer
operator|||
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|s
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|s
operator|+
literal|1
operator|==
name|limrev
operator|||
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|s
index|[
name|revlen
index|]
argument_list|)
operator|)
condition|)
block|{
name|found_revision
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|report_revision
argument_list|(
name|found_revision
argument_list|)
expr_stmt|;
block|}
comment|/* Plan A will work.  */
name|i_ptr
operator|=
name|ptr
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Keep (virtually) nothing in memory. */
end_comment

begin_function
specifier|static
name|void
name|plan_b
parameter_list|(
name|filename
parameter_list|)
name|char
specifier|const
modifier|*
name|filename
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|size_t
name|len
decl_stmt|;
specifier|register
name|size_t
name|maxlen
decl_stmt|;
specifier|register
name|int
name|found_revision
decl_stmt|;
specifier|register
name|size_t
name|i
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|rev
decl_stmt|;
specifier|register
name|size_t
name|revlen
decl_stmt|;
specifier|register
name|LINENUM
name|line
decl_stmt|;
if|if
condition|(
name|instat
operator|.
name|st_size
operator|==
literal|0
condition|)
name|filename
operator|=
name|NULL_DEVICE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
name|binary_transput
condition|?
literal|"rb"
else|:
literal|"r"
argument_list|)
operator|)
condition|)
name|pfatal
argument_list|(
literal|"can't open file `%s'"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|tifd
operator|=
name|create_file
argument_list|(
name|TMPINNAME
argument_list|,
name|O_RDWR
operator||
name|O_BINARY
argument_list|,
operator|(
name|mode_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|maxlen
operator|=
literal|1
expr_stmt|;
name|rev
operator|=
name|revision
expr_stmt|;
name|found_revision
operator|=
operator|!
name|rev
expr_stmt|;
name|revlen
operator|=
name|rev
condition|?
name|strlen
argument_list|(
name|rev
argument_list|)
else|:
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|ifp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|maxlen
operator|<
name|len
condition|)
name|maxlen
operator|=
name|len
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found_revision
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|revlen
condition|)
block|{
name|found_revision
operator|=
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|size_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|i
operator|=
name|rev
index|[
name|i
index|]
operator|==
name|c
condition|?
name|i
operator|+
literal|1
else|:
operator|(
name|size_t
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|&&
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|revision
condition|)
name|report_revision
argument_list|(
name|found_revision
argument_list|)
expr_stmt|;
name|Fseek
argument_list|(
name|ifp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* rewind file */
for|for
control|(
name|tibufsize
operator|=
name|TIBUFSIZE_MINIMUM
init|;
name|tibufsize
operator|<
name|maxlen
condition|;
name|tibufsize
operator|<<=
literal|1
control|)
continue|continue;
name|lines_per_buf
operator|=
name|tibufsize
operator|/
name|maxlen
expr_stmt|;
name|tireclen
operator|=
name|maxlen
expr_stmt|;
name|tibuf
index|[
literal|0
index|]
operator|=
name|xmalloc
argument_list|(
literal|2
operator|*
name|tibufsize
argument_list|)
expr_stmt|;
name|tibuf
index|[
literal|1
index|]
operator|=
name|tibuf
index|[
literal|0
index|]
operator|+
name|tibufsize
expr_stmt|;
for|for
control|(
name|line
operator|=
literal|1
init|;
condition|;
name|line
operator|++
control|)
block|{
name|char
modifier|*
name|p
init|=
name|tibuf
index|[
literal|0
index|]
operator|+
name|maxlen
operator|*
operator|(
name|line
operator|%
name|lines_per_buf
operator|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|p0
init|=
name|p
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|line
operator|%
name|lines_per_buf
operator|)
condition|)
comment|/* new block */
if|if
condition|(
name|write
argument_list|(
name|tifd
argument_list|,
name|tibuf
index|[
literal|0
index|]
argument_list|,
name|tibufsize
argument_list|)
operator|!=
name|tibufsize
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|ifp
argument_list|)
operator|)
operator|==
name|EOF
condition|)
break|break;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|last_line_size
operator|=
name|p
operator|-
name|p0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|ifp
argument_list|)
operator|)
operator|==
name|EOF
condition|)
block|{
name|last_line_size
operator|=
name|p
operator|-
name|p0
expr_stmt|;
name|line
operator|++
expr_stmt|;
goto|goto
name|EOF_reached
goto|;
block|}
block|}
block|}
name|EOF_reached
label|:
if|if
condition|(
name|ferror
argument_list|(
name|ifp
argument_list|)
operator|||
name|fclose
argument_list|(
name|ifp
argument_list|)
operator|!=
literal|0
condition|)
name|read_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|%
name|lines_per_buf
operator|!=
literal|0
condition|)
if|if
condition|(
name|write
argument_list|(
name|tifd
argument_list|,
name|tibuf
index|[
literal|0
index|]
argument_list|,
name|tibufsize
argument_list|)
operator|!=
name|tibufsize
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
name|input_lines
operator|=
name|line
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch a line from the input file. */
end_comment

begin_function
name|char
specifier|const
modifier|*
name|ifetch
parameter_list|(
name|line
parameter_list|,
name|whichbuf
parameter_list|,
name|psize
parameter_list|)
specifier|register
name|LINENUM
name|line
decl_stmt|;
name|int
name|whichbuf
decl_stmt|;
comment|/* ignored when file in memory */
name|size_t
modifier|*
name|psize
decl_stmt|;
block|{
specifier|register
name|char
specifier|const
modifier|*
name|q
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|line
operator|<
literal|1
operator|||
name|line
operator|>
name|input_lines
condition|)
block|{
operator|*
name|psize
operator|=
literal|0
expr_stmt|;
return|return
literal|""
return|;
block|}
if|if
condition|(
name|using_plan_a
condition|)
block|{
name|p
operator|=
name|i_ptr
index|[
name|line
index|]
expr_stmt|;
operator|*
name|psize
operator|=
name|i_ptr
index|[
name|line
operator|+
literal|1
index|]
operator|-
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
else|else
block|{
name|LINENUM
name|offline
init|=
name|line
operator|%
name|lines_per_buf
decl_stmt|;
name|LINENUM
name|baseline
init|=
name|line
operator|-
name|offline
decl_stmt|;
if|if
condition|(
name|tiline
index|[
literal|0
index|]
operator|==
name|baseline
condition|)
name|whichbuf
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|tiline
index|[
literal|1
index|]
operator|==
name|baseline
condition|)
name|whichbuf
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|tiline
index|[
name|whichbuf
index|]
operator|=
name|baseline
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|tifd
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|baseline
operator|/
name|lines_per_buf
operator|*
name|tibufsize
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|read
argument_list|(
name|tifd
argument_list|,
name|tibuf
index|[
name|whichbuf
index|]
argument_list|,
name|tibufsize
argument_list|)
operator|<
literal|0
condition|)
name|read_fatal
argument_list|()
expr_stmt|;
block|}
name|p
operator|=
name|tibuf
index|[
name|whichbuf
index|]
operator|+
operator|(
name|tireclen
operator|*
name|offline
operator|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|input_lines
condition|)
operator|*
name|psize
operator|=
name|last_line_size
expr_stmt|;
else|else
block|{
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|++
operator|!=
literal|'\n'
condition|;
control|)
continue|continue;
operator|*
name|psize
operator|=
name|q
operator|-
name|p
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
block|}
end_function

end_unit

