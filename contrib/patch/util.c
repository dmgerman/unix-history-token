begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* utility functions for `patch' */
end_comment

begin_comment
comment|/* $Id: util.c,v 1.24 1997/07/10 08:16:12 eggert Exp $ */
end_comment

begin_comment
comment|/* Copyright 1986 Larry Wall Copyright 1992, 1993, 1997 Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_define
define|#
directive|define
name|XTERN
value|extern
end_define

begin_include
include|#
directive|include
file|<common.h>
end_include

begin_include
include|#
directive|include
file|<backupfile.h>
end_include

begin_include
include|#
directive|include
file|<quotearg.h>
end_include

begin_include
include|#
directive|include
file|<version.h>
end_include

begin_undef
undef|#
directive|undef
name|XTERN
end_undef

begin_define
define|#
directive|define
name|XTERN
end_define

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_include
include|#
directive|include
file|<maketime.h>
end_include

begin_include
include|#
directive|include
file|<partime.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
name|SIGCHLD
operator|&&
name|defined
name|SIGCLD
end_if

begin_define
define|#
directive|define
name|SIGCHLD
value|SIGCLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|HAVE_RAISE
end_if

begin_define
define|#
directive|define
name|raise
parameter_list|(
name|sig
parameter_list|)
value|kill (getpid (), sig)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_define
define|#
directive|define
name|vararg_start
value|va_start
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|vararg_start
parameter_list|(
name|ap
parameter_list|,
name|p
parameter_list|)
value|va_start (ap)
end_define

begin_if
if|#
directive|if
name|HAVE_VARARGS_H
end_if

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|char
modifier|*
name|va_list
typedef|;
end_typedef

begin_define
define|#
directive|define
name|va_dcl
value|int va_alist;
end_define

begin_define
define|#
directive|define
name|va_start
parameter_list|(
name|ap
parameter_list|)
value|((ap) = (va_list)&va_alist)
end_define

begin_define
define|#
directive|define
name|va_arg
parameter_list|(
name|ap
parameter_list|,
name|t
parameter_list|)
value|(((t *) ((ap) += sizeof (t)))  [-1])
end_define

begin_define
define|#
directive|define
name|va_end
parameter_list|(
name|ap
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|makedirs
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Move a file FROM to TO, renaming it if possible and copying it if necessary.    If we must create TO, use MODE to create it.    If FROM is null, remove TO (ignoring FROMSTAT).    Back up TO if BACKUP is nonzero.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_comment
comment|/* If mode_t doesn't promote to itself, we can't use old-style definition.  */
end_comment

begin_decl_stmt
name|void
name|move_file
argument_list|(
name|char
specifier|const
operator|*
name|from
argument_list|,
name|char
operator|*
name|to
argument_list|,
name|mode_t
name|mode
argument_list|,
name|int
name|backup
argument_list|)
else|#
directive|else
name|void
name|move_file
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|mode
argument_list|,
name|backup
argument_list|)
name|char
decl|const
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mode_t
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|backup
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|stat
name|to_st
decl_stmt|;
name|int
name|to_errno
init|=
operator|!
name|backup
condition|?
operator|-
literal|1
else|:
name|stat
argument_list|(
name|to
argument_list|,
operator|&
name|to_st
argument_list|)
operator|==
literal|0
condition|?
literal|0
else|:
name|errno
decl_stmt|;
if|if
condition|(
name|backup
condition|)
block|{
name|int
name|try_makedirs_errno
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|bakname
decl_stmt|;
if|if
condition|(
name|origprae
operator|||
name|origbase
condition|)
block|{
name|char
specifier|const
modifier|*
name|p
init|=
name|origprae
condition|?
name|origprae
else|:
literal|""
decl_stmt|;
name|char
specifier|const
modifier|*
name|b
init|=
name|origbase
condition|?
name|origbase
else|:
literal|""
decl_stmt|;
name|char
specifier|const
modifier|*
name|o
init|=
name|base_name
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|size_t
name|plen
init|=
name|strlen
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|size_t
name|tlen
init|=
name|o
operator|-
name|to
decl_stmt|;
name|size_t
name|blen
init|=
name|strlen
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|size_t
name|osize
init|=
name|strlen
argument_list|(
name|o
argument_list|)
operator|+
literal|1
decl_stmt|;
name|bakname
operator|=
name|xmalloc
argument_list|(
name|plen
operator|+
name|tlen
operator|+
name|blen
operator|+
name|osize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bakname
argument_list|,
name|p
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bakname
operator|+
name|plen
argument_list|,
name|to
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bakname
operator|+
name|plen
operator|+
name|tlen
argument_list|,
name|b
argument_list|,
name|blen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bakname
operator|+
name|plen
operator|+
name|tlen
operator|+
name|blen
argument_list|,
name|o
argument_list|,
name|osize
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|+=
name|FILESYSTEM_PREFIX_LEN
argument_list|(
name|p
argument_list|)
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|ISSLASH
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|try_makedirs_errno
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|bakname
operator|=
name|find_backup_file_name
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bakname
condition|)
name|memory_fatal
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|to_errno
condition|)
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
name|say
argument_list|(
literal|"creating empty unreadable file `%s'\n"
argument_list|,
name|bakname
argument_list|)
expr_stmt|;
name|try_makedirs_errno
operator|=
name|ENOENT
expr_stmt|;
name|unlink
argument_list|(
name|bakname
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|bakname
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|try_makedirs_errno
condition|)
name|pfatal
argument_list|(
literal|"can't create file `%s'"
argument_list|,
name|bakname
argument_list|)
expr_stmt|;
name|makedirs
argument_list|(
name|bakname
argument_list|)
expr_stmt|;
name|try_makedirs_errno
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal
argument_list|(
literal|"can't close `%s'"
argument_list|,
name|bakname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
name|say
argument_list|(
literal|"renaming `%s' to `%s'\n"
argument_list|,
name|to
argument_list|,
name|bakname
argument_list|)
expr_stmt|;
while|while
condition|(
name|rename
argument_list|(
name|to
argument_list|,
name|bakname
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|try_makedirs_errno
condition|)
name|pfatal
argument_list|(
literal|"can't rename `%s' to `%s'"
argument_list|,
name|to
argument_list|,
name|bakname
argument_list|)
expr_stmt|;
name|makedirs
argument_list|(
name|bakname
argument_list|)
expr_stmt|;
name|try_makedirs_errno
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|bakname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|from
condition|)
block|{
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
name|say
argument_list|(
literal|"renaming `%s' to `%s'\n"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|to_dir_known_to_exist
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOENT
operator|&&
operator|(
name|to_errno
operator|==
operator|-
literal|1
operator|||
name|to_errno
operator|==
name|ENOENT
operator|)
condition|)
block|{
name|makedirs
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|to_dir_known_to_exist
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|==
literal|0
condition|)
return|return;
block|}
if|if
condition|(
name|errno
operator|==
name|EXDEV
condition|)
block|{
if|if
condition|(
operator|!
name|backup
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|to
argument_list|)
operator|==
literal|0
condition|)
name|to_dir_known_to_exist
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|pfatal
argument_list|(
literal|"can't remove `%s'"
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|to_dir_known_to_exist
condition|)
name|makedirs
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|copy_file
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return;
block|}
name|pfatal
argument_list|(
literal|"can't rename `%s' to `%s'"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|backup
condition|)
block|{
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
name|say
argument_list|(
literal|"removing `%s'\n"
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|to
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal
argument_list|(
literal|"can't remove `%s'"
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Create FILE with OPEN_FLAGS, and with MODE adjusted so that    we can read and write the file and that the file is not executable.    Return the file descriptor.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_comment
comment|/* If mode_t doesn't promote to itself, we can't use old-style definition.  */
end_comment

begin_decl_stmt
name|int
name|create_file
argument_list|(
name|char
specifier|const
operator|*
name|file
argument_list|,
name|int
name|open_flags
argument_list|,
name|mode_t
name|mode
argument_list|)
else|#
directive|else
name|int
name|create_file
argument_list|(
name|file
argument_list|,
name|open_flags
argument_list|,
name|mode
argument_list|)
name|char
decl|const
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|open_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mode_t
name|mode
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|mode
operator||=
name|S_IRUSR
operator||
name|S_IWUSR
expr_stmt|;
name|mode
operator|&=
operator|~
operator|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|O_CREAT
operator|&&
name|O_TRUNC
operator|)
condition|)
name|close
argument_list|(
name|creat
argument_list|(
name|file
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|open_flags
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|pfatal
argument_list|(
literal|"can't create `%s'"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
block|}
end_block

begin_comment
comment|/* Copy a file. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_comment
comment|/* If mode_t doesn't promote to itself, we can't use old-style definition.  */
end_comment

begin_decl_stmt
name|void
name|copy_file
argument_list|(
name|char
specifier|const
operator|*
name|from
argument_list|,
name|char
specifier|const
operator|*
name|to
argument_list|,
name|mode_t
name|mode
argument_list|)
else|#
directive|else
name|void
name|copy_file
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|mode
argument_list|)
name|char
decl|const
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
specifier|const
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mode_t
name|mode
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|tofd
decl_stmt|;
name|int
name|fromfd
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|fromfd
operator|=
name|open
argument_list|(
name|from
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|pfatal
argument_list|(
literal|"can't reopen `%s'"
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|tofd
operator|=
name|create_file
argument_list|(
name|to
argument_list|,
name|O_WRONLY
operator||
name|O_BINARY
argument_list|,
name|mode
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|fromfd
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|read_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|tofd
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|fromfd
argument_list|)
operator|!=
literal|0
condition|)
name|read_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|tofd
argument_list|)
operator|!=
literal|0
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
specifier|const
name|DEV_NULL
index|[]
init|=
name|NULL_DEVICE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|SCCSPREFIX
index|[]
init|=
literal|"s."
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|GET
index|[]
init|=
literal|"get "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|GET_LOCKED
index|[]
init|=
literal|"get -e "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|SCCSDIFF1
index|[]
init|=
literal|"get -p "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|SCCSDIFF2
index|[]
init|=
literal|"|diff - %s"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|RCSSUFFIX
index|[]
init|=
literal|",v"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|CHECKOUT
index|[]
init|=
literal|"co %s"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|CHECKOUT_LOCKED
index|[]
init|=
literal|"co -l %s"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|RCSDIFF1
index|[]
init|=
literal|"rcsdiff %s"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return "RCS" if FILENAME is controlled by RCS,    "SCCS" if it is controlled by SCCS, and 0 otherwise.    READONLY is nonzero if we desire only readonly access to FILENAME.    FILESTAT describes FILENAME's status or is 0 if FILENAME does not exist.    If successful and if GETBUF is nonzero, set *GETBUF to a command    that gets the file; similarly for DIFFBUF and a command to diff the file.    *GETBUF and *DIFFBUF must be freed by the caller.  */
end_comment

begin_function
name|char
specifier|const
modifier|*
name|version_controller
parameter_list|(
name|filename
parameter_list|,
name|readonly
parameter_list|,
name|filestat
parameter_list|,
name|getbuf
parameter_list|,
name|diffbuf
parameter_list|)
name|char
specifier|const
modifier|*
name|filename
decl_stmt|;
name|int
name|readonly
decl_stmt|;
name|struct
name|stat
specifier|const
modifier|*
name|filestat
decl_stmt|;
name|char
modifier|*
modifier|*
name|getbuf
decl_stmt|;
name|char
modifier|*
modifier|*
name|diffbuf
decl_stmt|;
block|{
name|struct
name|stat
name|cstat
decl_stmt|;
name|char
specifier|const
modifier|*
name|filebase
init|=
name|base_name
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|dotslash
init|=
operator|*
name|filename
operator|==
literal|'-'
condition|?
literal|"./"
else|:
literal|""
decl_stmt|;
name|size_t
name|dir_len
init|=
name|filebase
operator|-
name|filename
decl_stmt|;
name|size_t
name|filenamelen
init|=
name|strlen
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|size_t
name|maxfixlen
init|=
sizeof|sizeof
expr|"SCCS/"
operator|-
literal|1
operator|+
sizeof|sizeof
name|SCCSPREFIX
operator|-
literal|1
decl_stmt|;
name|size_t
name|maxtrysize
init|=
name|filenamelen
operator|+
name|maxfixlen
operator|+
literal|1
decl_stmt|;
name|size_t
name|quotelen
init|=
name|quote_system_arg
argument_list|(
literal|0
argument_list|,
name|filename
argument_list|)
decl_stmt|;
name|size_t
name|maxgetsize
init|=
sizeof|sizeof
name|GET_LOCKED
operator|+
name|quotelen
operator|+
name|maxfixlen
decl_stmt|;
name|size_t
name|maxdiffsize
init|=
operator|(
sizeof|sizeof
name|SCCSDIFF1
operator|+
sizeof|sizeof
name|SCCSDIFF2
operator|+
sizeof|sizeof
name|DEV_NULL
operator|-
literal|1
operator|+
literal|2
operator|*
name|quotelen
operator|+
name|maxfixlen
operator|)
decl_stmt|;
name|char
modifier|*
name|trybuf
init|=
name|xmalloc
argument_list|(
name|maxtrysize
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|r
init|=
literal|0
decl_stmt|;
name|strcpy
argument_list|(
name|trybuf
argument_list|,
name|filename
argument_list|)
expr_stmt|;
define|#
directive|define
name|try1
parameter_list|(
name|f
parameter_list|,
name|a1
parameter_list|)
value|(sprintf (trybuf + dir_len, f, a1),    stat (trybuf,&cstat) == 0)
define|#
directive|define
name|try2
parameter_list|(
name|f
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|)
value|(sprintf (trybuf + dir_len, f, a1,a2), stat (trybuf,&cstat) == 0)
comment|/* Check that RCS file is not working file.      Some hosts don't report file name length errors.  */
if|if
condition|(
operator|(
name|try2
argument_list|(
literal|"RCS/%s%s"
argument_list|,
name|filebase
argument_list|,
name|RCSSUFFIX
argument_list|)
operator|||
name|try1
argument_list|(
literal|"RCS/%s"
argument_list|,
name|filebase
argument_list|)
operator|||
name|try2
argument_list|(
literal|"%s%s"
argument_list|,
name|filebase
argument_list|,
name|RCSSUFFIX
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|filestat
operator|&&
name|filestat
operator|->
name|st_dev
operator|==
name|cstat
operator|.
name|st_dev
operator|&&
name|filestat
operator|->
name|st_ino
operator|==
name|cstat
operator|.
name|st_ino
operator|)
condition|)
block|{
if|if
condition|(
name|getbuf
condition|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|getbuf
operator|=
name|xmalloc
argument_list|(
name|maxgetsize
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
name|readonly
condition|?
name|CHECKOUT
else|:
name|CHECKOUT_LOCKED
argument_list|,
name|dotslash
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|quote_system_arg
argument_list|(
name|p
argument_list|,
name|filename
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|diffbuf
condition|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|diffbuf
operator|=
name|xmalloc
argument_list|(
name|maxdiffsize
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
name|RCSDIFF1
argument_list|,
name|dotslash
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|quote_system_arg
argument_list|(
name|p
argument_list|,
name|filename
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'>'
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|DEV_NULL
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
literal|"RCS"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|try2
argument_list|(
literal|"SCCS/%s%s"
argument_list|,
name|SCCSPREFIX
argument_list|,
name|filebase
argument_list|)
operator|||
name|try2
argument_list|(
literal|"%s%s"
argument_list|,
name|SCCSPREFIX
argument_list|,
name|filebase
argument_list|)
condition|)
block|{
if|if
condition|(
name|getbuf
condition|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|getbuf
operator|=
name|xmalloc
argument_list|(
name|maxgetsize
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
name|readonly
condition|?
name|GET
else|:
name|GET_LOCKED
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|quote_system_arg
argument_list|(
name|p
argument_list|,
name|trybuf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|diffbuf
condition|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|diffbuf
operator|=
name|xmalloc
argument_list|(
name|maxdiffsize
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|SCCSDIFF1
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
name|SCCSDIFF1
operator|-
literal|1
expr_stmt|;
name|p
operator|+=
name|quote_system_arg
argument_list|(
name|p
argument_list|,
name|trybuf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
name|SCCSDIFF2
argument_list|,
name|dotslash
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|quote_system_arg
argument_list|(
name|p
argument_list|,
name|filename
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'>'
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|DEV_NULL
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
literal|"SCCS"
expr_stmt|;
block|}
name|free
argument_list|(
name|trybuf
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Get FILENAME from version control system CS.  The file already exists if    EXISTS is nonzero.  Only readonly access is needed if READONLY is nonzero.    Use the command GETBUF to actually get the named file.    Store the resulting file status into *FILESTAT.    Return nonzero if successful.  */
end_comment

begin_function
name|int
name|version_get
parameter_list|(
name|filename
parameter_list|,
name|cs
parameter_list|,
name|exists
parameter_list|,
name|readonly
parameter_list|,
name|getbuf
parameter_list|,
name|filestat
parameter_list|)
name|char
specifier|const
modifier|*
name|filename
decl_stmt|;
name|char
specifier|const
modifier|*
name|cs
decl_stmt|;
name|int
name|exists
decl_stmt|;
name|int
name|readonly
decl_stmt|;
name|char
specifier|const
modifier|*
name|getbuf
decl_stmt|;
name|struct
name|stat
modifier|*
name|filestat
decl_stmt|;
block|{
if|if
condition|(
name|patch_get
operator|<
literal|0
condition|)
block|{
name|ask
argument_list|(
literal|"Get file `%s' from %s%s? [y] "
argument_list|,
name|filename
argument_list|,
name|cs
argument_list|,
name|readonly
condition|?
literal|""
else|:
literal|" with lock"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'n'
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|dry_run
condition|)
block|{
if|if
condition|(
operator|!
name|exists
condition|)
name|fatal
argument_list|(
literal|"can't do dry run on nonexistent version-controlled file `%s'; invoke `%s' and try again"
argument_list|,
name|filename
argument_list|,
name|getbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbosity
operator|==
name|VERBOSE
condition|)
name|say
argument_list|(
literal|"Getting file `%s' from %s%s...\n"
argument_list|,
name|filename
argument_list|,
name|cs
argument_list|,
name|readonly
condition|?
literal|""
else|:
literal|" with lock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|systemic
argument_list|(
name|getbuf
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"can't get file `%s' from %s"
argument_list|,
name|filename
argument_list|,
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
name|filestat
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal
argument_list|(
literal|"%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Allocate a unique area for a string. */
end_comment

begin_function
name|char
modifier|*
name|savebuf
parameter_list|(
name|s
parameter_list|,
name|size
parameter_list|)
specifier|register
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
specifier|register
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|rv
decl_stmt|;
name|assert
argument_list|(
name|s
operator|&&
name|size
argument_list|)
expr_stmt|;
name|rv
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rv
condition|)
block|{
if|if
condition|(
operator|!
name|using_plan_a
condition|)
name|memory_fatal
argument_list|()
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|rv
argument_list|,
name|s
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|savestr
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|savebuf
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|remove_prefix
parameter_list|(
name|p
parameter_list|,
name|prefixlen
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|prefixlen
decl_stmt|;
block|{
name|char
specifier|const
modifier|*
name|s
init|=
name|p
operator|+
name|prefixlen
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
condition|)
continue|continue;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|HAVE_VPRINTF
end_if

begin_define
define|#
directive|define
name|vfprintf
value|my_vfprintf
end_define

begin_decl_stmt
specifier|static
name|int
name|vfprintf
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|vfprintf
parameter_list|(
name|stream
parameter_list|,
name|format
parameter_list|,
name|args
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
specifier|const
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|HAVE_DOPRNT
operator|&&
name|HAVE__DOPRINTF
define|#
directive|define
name|_doprnt
value|_doprintf
endif|#
directive|endif
if|#
directive|if
name|HAVE_DOPRNT
operator|||
name|HAVE__DOPRINTF
name|_doprnt
argument_list|(
name|format
argument_list|,
name|args
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return
name|ferror
argument_list|(
name|stream
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
else|#
directive|else
name|int
modifier|*
name|a
init|=
operator|(
name|int
operator|*
operator|)
name|args
decl_stmt|;
return|return
name|fprintf
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|,
name|a
index|[
literal|7
index|]
argument_list|,
name|a
index|[
literal|8
index|]
argument_list|,
name|a
index|[
literal|9
index|]
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_VPRINTF */
end_comment

begin_comment
comment|/* Terminal output, pun intended. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|void
name|fatal
argument_list|(
name|char
specifier|const
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|fatal
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
decl|const
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|va_list
name|args
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: **** "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|fatal_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|memory_fatal
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|read_fatal
parameter_list|()
block|{
name|pfatal
argument_list|(
literal|"read error"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_fatal
parameter_list|()
block|{
name|pfatal
argument_list|(
literal|"write error"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Say something from patch, something from the system, then silence . . . */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|void
name|pfatal
argument_list|(
name|char
specifier|const
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|pfatal
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
decl|const
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|errnum
init|=
name|errno
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: **** "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* perror bypasses stdio on some hosts.  */
name|errno
operator|=
name|errnum
expr_stmt|;
name|perror
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|fatal_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Tell the user something.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|void
name|say
argument_list|(
name|char
specifier|const
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|say
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
decl|const
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|va_list
name|args
decl_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Get a response from the user, somehow or other. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|void
name|ask
argument_list|(
name|char
specifier|const
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS1*/
name|void
name|ask
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
decl|const
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|static
name|int
name|ttyfd
init|=
operator|-
literal|2
decl_stmt|;
name|int
name|r
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyfd
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* If standard output is not a tty, don't bother opening /dev/tty, 	 since it's unlikely that stdout will be seen by the tty user. 	 The isatty test also works around a bug in GNU Emacs 19.34 under Linux 	 which makes a call-process `patch' hang when it reads from /dev/tty. 	 POSIX.2 requires that we read /dev/tty, though.  */
name|ttyfd
operator|=
operator|(
name|posixly_correct
operator|||
name|isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
condition|?
name|open
argument_list|(
name|TTY_DEVICE
argument_list|,
name|O_RDONLY
argument_list|)
else|:
operator|-
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ttyfd
operator|<
literal|0
condition|)
block|{
comment|/* No terminal at all -- default it.  */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|s
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|read
argument_list|(
name|ttyfd
argument_list|,
name|buf
operator|+
name|s
argument_list|,
name|bufsize
operator|-
literal|1
operator|-
name|s
argument_list|)
operator|)
operator|==
name|bufsize
operator|-
literal|1
operator|-
name|s
operator|&&
name|buf
index|[
name|bufsize
operator|-
literal|2
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|s
operator|=
name|bufsize
operator|-
literal|1
expr_stmt|;
name|bufsize
operator|*=
literal|2
expr_stmt|;
name|buf
operator|=
name|realloc
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|memory_fatal
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"EOF\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"tty read"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ttyfd
argument_list|)
expr_stmt|;
name|ttyfd
operator|=
operator|-
literal|1
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
block|}
name|buf
index|[
name|s
operator|+
name|r
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Return nonzero if it OK to reverse a patch.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
name|int
name|ok_to_reverse
parameter_list|(
name|char
specifier|const
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|ok_to_reverse
parameter_list|(
name|format
parameter_list|,
name|va_alist
parameter_list|)
name|char
specifier|const
modifier|*
name|format
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|noreverse
operator|||
operator|!
operator|(
name|force
operator|&&
name|verbosity
operator|==
name|SILENT
operator|)
condition|)
block|{
name|va_list
name|args
decl_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noreverse
condition|)
block|{
name|printf
argument_list|(
literal|"  Skipping patch.\n"
argument_list|)
expr_stmt|;
name|skip_rest_of_patch
operator|=
name|TRUE
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|force
condition|)
block|{
if|if
condition|(
name|verbosity
operator|!=
name|SILENT
condition|)
name|printf
argument_list|(
literal|"  Applying it anyway.\n"
argument_list|)
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|batch
condition|)
block|{
name|say
argument_list|(
name|reverse
condition|?
literal|"  Ignoring -R.\n"
else|:
literal|"  Assuming -R.\n"
argument_list|)
expr_stmt|;
name|r
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ask
argument_list|(
name|reverse
condition|?
literal|"  Ignore -R? [n] "
else|:
literal|"  Assume -R? [n] "
argument_list|)
expr_stmt|;
name|r
operator|=
operator|*
name|buf
operator|==
literal|'y'
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|ask
argument_list|(
literal|"Apply anyway? [n] "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'y'
condition|)
block|{
if|if
condition|(
name|verbosity
operator|!=
name|SILENT
condition|)
name|say
argument_list|(
literal|"Skipping patch.\n"
argument_list|)
expr_stmt|;
name|skip_rest_of_patch
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* How to handle certain events when not in a critical region. */
end_comment

begin_define
define|#
directive|define
name|NUM_SIGS
value|(sizeof (sigs) / sizeof (*sigs))
end_define

begin_decl_stmt
specifier|static
name|int
specifier|const
name|sigs
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|SIGHUP
name|SIGHUP
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
name|SIGPIPE
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|SIGTERM
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXCPU
name|SIGXCPU
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
name|SIGXFSZ
block|,
endif|#
directive|endif
name|SIGINT
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|HAVE_SIGPROCMASK
end_if

begin_define
define|#
directive|define
name|sigset_t
value|int
end_define

begin_define
define|#
directive|define
name|sigemptyset
parameter_list|(
name|s
parameter_list|)
value|(*(s) = 0)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|sigmask
end_ifndef

begin_define
define|#
directive|define
name|sigmask
parameter_list|(
name|sig
parameter_list|)
value|(1<< ((sig) - 1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|sigaddset
parameter_list|(
name|s
parameter_list|,
name|sig
parameter_list|)
value|(*(s) |= sigmask (sig))
end_define

begin_define
define|#
directive|define
name|sigismember
parameter_list|(
name|s
parameter_list|,
name|sig
parameter_list|)
value|((*(s)& sigmask (sig)) != 0)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|SIG_BLOCK
end_ifndef

begin_define
define|#
directive|define
name|SIG_BLOCK
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SIG_UNBLOCK
end_ifndef

begin_define
define|#
directive|define
name|SIG_UNBLOCK
value|(SIG_BLOCK + 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SIG_SETMASK
end_ifndef

begin_define
define|#
directive|define
name|SIG_SETMASK
value|(SIG_BLOCK + 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|sigprocmask
parameter_list|(
name|how
parameter_list|,
name|n
parameter_list|,
name|o
parameter_list|)
define|\
value|((how) == SIG_BLOCK \    ? ((o) ? *(o) = sigblock (*(n)) : sigblock (*(n))) \    : (how) == SIG_UNBLOCK \    ? sigsetmask (((o) ? *(o) = sigblock (0) : sigblock (0))& ~*(n)) \    : (o ? *(o) = sigsetmask (*(n)) : sigsetmask (*(n))))
end_define

begin_if
if|#
directive|if
operator|!
name|HAVE_SIGSETMASK
end_if

begin_define
define|#
directive|define
name|sigblock
parameter_list|(
name|mask
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|sigsetmask
parameter_list|(
name|mask
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|sigset_t
name|initial_signal_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sigset_t
name|signals_to_block
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|HAVE_SIGACTION
end_if

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|fatal_exit_handler
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|noreturn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|RETSIGTYPE
name|fatal_exit_handler
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|fatal_exit
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|set_signals
parameter_list|(
name|reset
parameter_list|)
name|int
name|reset
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
name|HAVE_SIGACTION
name|struct
name|sigaction
name|initial_act
decl_stmt|,
name|fatal_act
decl_stmt|;
name|fatal_act
operator|.
name|sa_handler
operator|=
name|fatal_exit
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|fatal_act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|fatal_act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|setup_handler
parameter_list|(
name|sig
parameter_list|)
value|sigaction (sig,&fatal_act, (struct sigaction *) 0)
else|#
directive|else
define|#
directive|define
name|setup_handler
parameter_list|(
name|sig
parameter_list|)
value|signal (sig, fatal_exit_handler)
endif|#
directive|endif
if|if
condition|(
operator|!
name|reset
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGCHLD
comment|/* System V fork+wait does not work if SIGCHLD is ignored.  */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sigemptyset
argument_list|(
operator|&
name|signals_to_block
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_SIGS
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ignoring_signal
decl_stmt|;
if|#
directive|if
name|HAVE_SIGACTION
if|if
condition|(
name|sigaction
argument_list|(
name|sigs
index|[
name|i
index|]
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|initial_act
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|ignoring_signal
operator|=
name|initial_act
operator|.
name|sa_handler
operator|==
name|SIG_IGN
expr_stmt|;
else|#
directive|else
name|ignoring_signal
operator|=
name|signal
argument_list|(
name|sigs
index|[
name|i
index|]
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_IGN
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ignoring_signal
condition|)
block|{
name|sigaddset
argument_list|(
operator|&
name|signals_to_block
argument_list|,
name|sigs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|setup_handler
argument_list|(
name|sigs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Undo the effect of ignore_signals.  */
if|#
directive|if
name|HAVE_SIGPROCMASK
operator|||
name|HAVE_SIGSETMASK
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|initial_signal_mask
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_SIGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sigismember
argument_list|(
operator|&
name|signals_to_block
argument_list|,
name|sigs
index|[
name|i
index|]
argument_list|)
condition|)
name|setup_handler
argument_list|(
name|sigs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* How to handle certain events when in a critical region. */
end_comment

begin_function
name|void
name|ignore_signals
parameter_list|()
block|{
if|#
directive|if
name|HAVE_SIGPROCMASK
operator|||
name|HAVE_SIGSETMASK
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|signals_to_block
argument_list|,
operator|&
name|initial_signal_mask
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_SIGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sigismember
argument_list|(
operator|&
name|signals_to_block
argument_list|,
name|sigs
index|[
name|i
index|]
argument_list|)
condition|)
name|signal
argument_list|(
name|sigs
index|[
name|i
index|]
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|exit_with_signal
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|sigset_t
name|s
decl_stmt|;
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|s
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|s
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|raise
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|systemic
parameter_list|(
name|command
parameter_list|)
name|char
specifier|const
modifier|*
name|command
decl_stmt|;
block|{
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
name|say
argument_list|(
literal|"+ %s\n"
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
name|system
argument_list|(
name|command
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|HAVE_MKDIR
end_if

begin_comment
comment|/* These mkdir and rmdir substitutes are good enough for `patch';    they are not general emulators.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|doprogram
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mkdir
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|mode_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rmdir
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|doprogram
parameter_list|(
name|program
parameter_list|,
name|arg
parameter_list|)
name|char
specifier|const
modifier|*
name|program
decl_stmt|;
name|char
specifier|const
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
specifier|static
name|char
specifier|const
name|DISCARD_OUTPUT
index|[]
init|=
literal|" 2>/dev/null"
decl_stmt|;
name|size_t
name|program_len
init|=
name|strlen
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cmd
init|=
name|xmalloc
argument_list|(
name|program_len
operator|+
literal|1
operator|+
name|quote_system_arg
argument_list|(
literal|0
argument_list|,
name|arg
argument_list|)
operator|+
sizeof|sizeof
name|DISCARD_OUTPUT
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|cmd
decl_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|program
argument_list|)
expr_stmt|;
name|p
operator|+=
name|program_len
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|+=
name|quote_system_arg
argument_list|(
name|p
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|DISCARD_OUTPUT
argument_list|)
expr_stmt|;
name|result
operator|=
name|systemic
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_comment
comment|/* If mode_t doesn't promote to itself, we can't use old-style definition.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mkdir
argument_list|(
name|char
specifier|const
operator|*
name|path
argument_list|,
name|mode_t
name|mode
argument_list|)
else|#
directive|else
decl|static
name|int
name|mkdir
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
name|char
decl|const
modifier|*
name|path
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mode_t
name|mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ignored */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
return|return
name|doprogram
argument_list|(
literal|"mkdir"
argument_list|,
name|path
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|rmdir
parameter_list|(
name|path
parameter_list|)
name|char
specifier|const
modifier|*
name|path
decl_stmt|;
block|{
name|int
name|result
init|=
name|doprogram
argument_list|(
literal|"rmdir"
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|errno
operator|=
name|EEXIST
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Replace '/' with '\0' in FILENAME if it marks a place that    needs testing for the existence of directory.  Return the address    of the last location replaced, or 0 if none were replaced.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|replace_slashes
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|replace_slashes
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|last_location_replaced
init|=
literal|0
decl_stmt|;
name|char
specifier|const
modifier|*
name|component_start
decl_stmt|;
for|for
control|(
name|f
operator|=
name|filename
operator|+
name|FILESYSTEM_PREFIX_LEN
argument_list|(
name|filename
argument_list|)
init|;
name|ISSLASH
argument_list|(
operator|*
name|f
argument_list|)
condition|;
name|f
operator|++
control|)
continue|continue;
name|component_start
operator|=
name|f
expr_stmt|;
for|for
control|(
init|;
operator|*
name|f
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|ISSLASH
argument_list|(
operator|*
name|f
argument_list|)
condition|)
block|{
name|char
modifier|*
name|slash
init|=
name|f
decl_stmt|;
comment|/* Treat multiple slashes as if they were one slash.  */
while|while
condition|(
name|ISSLASH
argument_list|(
name|f
index|[
literal|1
index|]
argument_list|)
condition|)
name|f
operator|++
expr_stmt|;
comment|/* Ignore slashes at the end of the path.  */
if|if
condition|(
operator|!
name|f
index|[
literal|1
index|]
condition|)
break|break;
comment|/* "." and ".." need not be tested.  */
if|if
condition|(
operator|!
operator|(
name|slash
operator|-
name|component_start
operator|<=
literal|2
operator|&&
name|component_start
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|slash
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|)
condition|)
block|{
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|last_location_replaced
operator|=
name|slash
expr_stmt|;
block|}
name|component_start
operator|=
name|f
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|last_location_replaced
return|;
block|}
end_function

begin_comment
comment|/* Make sure we'll have the directories to create a file.    Ignore the last element of `filename'.  */
end_comment

begin_function
specifier|static
name|void
name|makedirs
parameter_list|(
name|filename
parameter_list|)
specifier|register
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|f
decl_stmt|;
specifier|register
name|char
modifier|*
name|flim
init|=
name|replace_slashes
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|flim
condition|)
block|{
comment|/* Create any missing directories, replacing NULs by '/'s. 	 Ignore errors.  We may have to keep going even after an EEXIST, 	 since the path may contain ".."s; and when there is an EEXIST 	 failure the system may return some other error number. 	 Any problems will eventually be reported when we create the file.  */
for|for
control|(
name|f
operator|=
name|filename
init|;
name|f
operator|<=
name|flim
condition|;
name|f
operator|++
control|)
if|if
condition|(
operator|!
operator|*
name|f
condition|)
block|{
name|mkdir
argument_list|(
name|filename
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IXUSR
operator||
name|S_IRGRP
operator||
name|S_IWGRP
operator||
name|S_IXGRP
operator||
name|S_IROTH
operator||
name|S_IWOTH
operator||
name|S_IXOTH
argument_list|)
expr_stmt|;
operator|*
name|f
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Remove empty ancestor directories of FILENAME.    Ignore errors, since the path may contain ".."s, and when there    is an EEXIST failure the system may return some other error number.  */
end_comment

begin_function
name|void
name|removedirs
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|ISSLASH
argument_list|(
name|filename
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
operator|(
name|ISSLASH
argument_list|(
name|filename
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|||
operator|(
name|filename
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|i
operator|==
literal|1
operator|||
name|ISSLASH
argument_list|(
name|filename
index|[
name|i
operator|-
literal|2
index|]
argument_list|)
operator|||
operator|(
name|filename
index|[
name|i
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|i
operator|==
literal|2
operator|||
name|ISSLASH
argument_list|(
name|filename
index|[
name|i
operator|-
literal|3
index|]
argument_list|)
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|filename
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rmdir
argument_list|(
name|filename
argument_list|)
operator|==
literal|0
operator|&&
name|verbosity
operator|==
name|VERBOSE
condition|)
name|say
argument_list|(
literal|"Removed empty directory `%s'.\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|filename
index|[
name|i
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|time_t
name|initial_time
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_time
parameter_list|()
block|{
name|time
argument_list|(
operator|&
name|initial_time
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make filenames more reasonable. */
end_comment

begin_function
name|char
modifier|*
name|fetchname
parameter_list|(
name|at
parameter_list|,
name|strip_leading
parameter_list|,
name|pstamp
parameter_list|)
name|char
modifier|*
name|at
decl_stmt|;
name|int
name|strip_leading
decl_stmt|;
name|time_t
modifier|*
name|pstamp
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|sleading
init|=
name|strip_leading
decl_stmt|;
name|time_t
name|stamp
init|=
operator|(
name|time_t
operator|)
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|at
argument_list|)
condition|)
name|at
operator|++
expr_stmt|;
if|if
condition|(
name|debug
operator|&
literal|128
condition|)
name|say
argument_list|(
literal|"fetchname %s %d\n"
argument_list|,
name|at
argument_list|,
name|strip_leading
argument_list|)
expr_stmt|;
name|name
operator|=
name|at
expr_stmt|;
comment|/* Strip off up to `sleading' leading slashes and null terminate.  */
for|for
control|(
name|t
operator|=
name|at
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
name|ISSLASH
argument_list|(
operator|*
name|t
argument_list|)
condition|)
block|{
while|while
condition|(
name|ISSLASH
argument_list|(
name|t
index|[
literal|1
index|]
argument_list|)
condition|)
name|t
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|sleading
operator|>=
literal|0
condition|)
name|name
operator|=
name|t
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|set_time
operator||
name|set_utc
condition|)
name|stamp
operator|=
name|str2time
argument_list|(
name|t
argument_list|,
name|initial_time
argument_list|,
name|set_utc
condition|?
literal|0L
else|:
name|TM_LOCAL_ZONE
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* The head says the file is nonexistent if the timestamp 		   is the epoch; but the listed time is local time, not UTC, 		   and POSIX.1 allows local time to be 24 hours away from UTC. 		   So match any time within 24 hours of the epoch. 		   Use a default time zone 24 hours behind UTC so that any 		   non-zoned time within 24 hours of the epoch is valid.  */
name|stamp
operator|=
name|str2time
argument_list|(
name|t
argument_list|,
name|initial_time
argument_list|,
operator|-
literal|24L
operator|*
literal|60
operator|*
literal|60
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|stamp
operator|&&
name|stamp
operator|<=
literal|2
operator|*
literal|24L
operator|*
literal|60
operator|*
literal|60
condition|)
name|stamp
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|name
condition|)
return|return
literal|0
return|;
comment|/* Allow files to be created by diffing against /dev/null.  */
if|if
condition|(
name|strcmp
argument_list|(
name|at
argument_list|,
literal|"/dev/null"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pstamp
condition|)
operator|*
name|pstamp
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|pstamp
condition|)
operator|*
name|pstamp
operator|=
name|stamp
expr_stmt|;
return|return
name|savestr
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|GENERIC_OBJECT
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|GENERIC_OBJECT
modifier|*
name|p
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|memory_fatal
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|void
name|Fseek
parameter_list|(
name|stream
parameter_list|,
name|offset
parameter_list|,
name|ptrname
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|file_offset
name|offset
decl_stmt|;
name|int
name|ptrname
decl_stmt|;
block|{
if|if
condition|(
name|file_seek
argument_list|(
name|stream
argument_list|,
name|offset
argument_list|,
name|ptrname
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal
argument_list|(
literal|"fseek"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

