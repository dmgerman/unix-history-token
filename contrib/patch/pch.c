begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* reading patches */
end_comment

begin_comment
comment|/* $Id: pch.c,v 1.26 1997/07/21 17:59:46 eggert Exp $ */
end_comment

begin_comment
comment|/* Copyright 1986, 1987, 1988 Larry Wall Copyright 1990, 1991, 1992, 1993, 1997 Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_define
define|#
directive|define
name|XTERN
value|extern
end_define

begin_include
include|#
directive|include
file|<common.h>
end_include

begin_include
include|#
directive|include
file|<backupfile.h>
end_include

begin_include
include|#
directive|include
file|<inp.h>
end_include

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_undef
undef|#
directive|undef
name|XTERN
end_undef

begin_define
define|#
directive|define
name|XTERN
end_define

begin_include
include|#
directive|include
file|<pch.h>
end_include

begin_define
define|#
directive|define
name|INITHUNKMAX
value|125
end_define

begin_comment
comment|/* initial dynamic allocation size */
end_comment

begin_comment
comment|/* Patch (diff listing) abstract type. */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|pfp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* patch file pointer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_says_nonexistent
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* [0] for old file, [1] for new; 		value is 0 for nonempty, 1 for empty, 2 for nonexistent */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_rfc934_nesting
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RFC 934 nesting level */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|p_timestamp
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* timestamps in patch headers */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|p_filesize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of the patch file */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_first
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1st line number */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_newfirst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1st line number of replacement */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_ptrn_lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # lines in pattern */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_repl_lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # lines in replacement text */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_end
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last line in hunk */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max allowed value of p_end */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_prefix_context
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of prefix context lines */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_suffix_context
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of suffix context lines */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_input_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current line # from patch file */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|p_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the text of the hunk */
end_comment

begin_decl_stmt
specifier|static
name|size_t
modifier|*
name|p_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line length including \n if any */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_Char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* +, -, and ! */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|hunkmax
init|=
name|INITHUNKMAX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of above arrays */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_indent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indent to patch */
end_comment

begin_decl_stmt
specifier|static
name|file_offset
name|p_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where to intuit this time */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_bline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line # of p_base */
end_comment

begin_decl_stmt
specifier|static
name|file_offset
name|p_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where intuit found a patch */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_sline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* and the line number for it */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_hunk_beg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line number of current hunk */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_efake
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of faked up lines--don't free */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_bfake
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* beg of faked up lines */
end_comment

begin_enum
enum|enum
name|nametype
block|{
name|OLD
block|,
name|NEW
block|,
name|INDEX
block|,
name|NONE
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|diff
name|intuit_diff_type
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|nametype
name|best_name
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
specifier|const
operator|*
operator|,
name|int
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prefix_components
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|pget_line
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|get_line
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|incomplete_line
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|grow_hunkmax
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|malformed
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|noreturn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|next_intuit_at
name|PARAMS
argument_list|(
operator|(
name|file_offset
operator|,
name|LINENUM
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|skip_to
name|PARAMS
argument_list|(
operator|(
name|file_offset
operator|,
name|LINENUM
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prepare to look for the next patch in the patch file. */
end_comment

begin_function
name|void
name|re_patch
parameter_list|()
block|{
name|p_first
operator|=
literal|0
expr_stmt|;
name|p_newfirst
operator|=
literal|0
expr_stmt|;
name|p_ptrn_lines
operator|=
literal|0
expr_stmt|;
name|p_repl_lines
operator|=
literal|0
expr_stmt|;
name|p_end
operator|=
operator|-
literal|1
expr_stmt|;
name|p_max
operator|=
literal|0
expr_stmt|;
name|p_indent
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open the patch file at the beginning of time. */
end_comment

begin_function
name|void
name|open_patch_file
parameter_list|(
name|filename
parameter_list|)
name|char
specifier|const
modifier|*
name|filename
decl_stmt|;
block|{
name|file_offset
name|file_pos
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
operator|!
name|filename
operator|||
operator|!
operator|*
name|filename
operator|||
name|strEQ
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|file_offset
name|stdin_pos
decl_stmt|;
if|#
directive|if
name|HAVE_SETMODE
if|if
condition|(
name|binary_transput
condition|)
block|{
if|if
condition|(
name|isatty
argument_list|(
name|STDIN_FILENO
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"cannot read binary data from tty on this platform"
argument_list|)
expr_stmt|;
name|setmode
argument_list|(
name|STDIN_FILENO
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fstat
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal
argument_list|(
literal|"fstat"
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|&&
operator|(
name|stdin_pos
operator|=
name|file_tell
argument_list|(
name|stdin
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|pfp
operator|=
name|stdin
expr_stmt|;
name|file_pos
operator|=
name|stdin_pos
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|charsread
decl_stmt|;
name|pfp
operator|=
name|fopen
argument_list|(
name|TMPPATNAME
argument_list|,
literal|"w+b"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pfp
condition|)
name|pfatal
argument_list|(
literal|"can't create `%s'"
argument_list|,
name|TMPPATNAME
argument_list|)
expr_stmt|;
for|for
control|(
name|st
operator|.
name|st_size
operator|=
literal|0
init|;
operator|(
name|charsread
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|bufsize
argument_list|,
name|stdin
argument_list|)
operator|)
operator|!=
literal|0
condition|;
name|st
operator|.
name|st_size
operator|+=
name|charsread
control|)
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|charsread
argument_list|,
name|pfp
argument_list|)
operator|!=
name|charsread
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdin
argument_list|)
operator|!=
literal|0
condition|)
name|read_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|pfp
argument_list|)
operator|!=
literal|0
operator|||
name|file_seek
argument_list|(
name|pfp
argument_list|,
operator|(
name|file_offset
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|pfp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
name|binary_transput
condition|?
literal|"rb"
else|:
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pfp
condition|)
name|pfatal
argument_list|(
literal|"can't open patch file `%s'"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|pfp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal
argument_list|(
literal|"fstat"
argument_list|)
expr_stmt|;
block|}
name|p_filesize
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|p_filesize
operator|!=
operator|(
name|file_offset
operator|)
name|p_filesize
condition|)
name|fatal
argument_list|(
literal|"patch file is too long"
argument_list|)
expr_stmt|;
name|next_intuit_at
argument_list|(
name|file_pos
argument_list|,
operator|(
name|LINENUM
operator|)
literal|1
argument_list|)
expr_stmt|;
name|set_hunkmax
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make sure our dynamically realloced tables are malloced to begin with. */
end_comment

begin_function
name|void
name|set_hunkmax
parameter_list|()
block|{
if|if
condition|(
operator|!
name|p_line
condition|)
name|p_line
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|hunkmax
operator|*
sizeof|sizeof
expr|*
name|p_line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_len
condition|)
name|p_len
operator|=
operator|(
name|size_t
operator|*
operator|)
name|malloc
argument_list|(
name|hunkmax
operator|*
sizeof|sizeof
expr|*
name|p_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Char
condition|)
name|p_Char
operator|=
name|malloc
argument_list|(
name|hunkmax
operator|*
sizeof|sizeof
expr|*
name|p_Char
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enlarge the arrays containing the current hunk of patch. */
end_comment

begin_function
specifier|static
name|bool
name|grow_hunkmax
parameter_list|()
block|{
name|hunkmax
operator|*=
literal|2
expr_stmt|;
name|assert
argument_list|(
name|p_line
operator|&&
name|p_len
operator|&&
name|p_Char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_line
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|p_line
argument_list|,
name|hunkmax
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|p_line
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|p_len
operator|=
operator|(
name|size_t
operator|*
operator|)
name|realloc
argument_list|(
name|p_len
argument_list|,
name|hunkmax
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|p_len
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|p_Char
operator|=
name|realloc
argument_list|(
name|p_Char
argument_list|,
name|hunkmax
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|p_Char
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|using_plan_a
condition|)
name|memory_fatal
argument_list|()
expr_stmt|;
comment|/* Don't free previous values of p_line etc.,        since some broken implementations free them for us.        Whatever is null will be allocated again from within plan_a (),        of all places.  */
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* True if the remainder of the patch file contains a diff of some sort. */
end_comment

begin_function
name|bool
name|there_is_another_patch
parameter_list|()
block|{
if|if
condition|(
name|p_base
operator|!=
literal|0
operator|&&
name|p_base
operator|>=
name|p_filesize
condition|)
block|{
if|if
condition|(
name|verbosity
operator|==
name|VERBOSE
condition|)
name|say
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|verbosity
operator|==
name|VERBOSE
condition|)
name|say
argument_list|(
literal|"Hmm..."
argument_list|)
expr_stmt|;
name|diff_type
operator|=
name|intuit_diff_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|diff_type
operator|==
name|NO_DIFF
condition|)
block|{
if|if
condition|(
name|verbosity
operator|==
name|VERBOSE
condition|)
name|say
argument_list|(
name|p_base
condition|?
literal|"  Ignoring the trailing garbage.\ndone\n"
else|:
literal|"  I can't seem to find a patch in there anywhere.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_base
operator|&&
name|p_filesize
condition|)
name|fatal
argument_list|(
literal|"Only garbage was found in the patch input."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|skip_rest_of_patch
condition|)
block|{
name|Fseek
argument_list|(
name|pfp
argument_list|,
name|p_start
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|p_input_line
operator|=
name|p_sline
operator|-
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|verbosity
operator|==
name|VERBOSE
condition|)
name|say
argument_list|(
literal|"  %sooks like %s to me...\n"
argument_list|,
operator|(
name|p_base
operator|==
literal|0
condition|?
literal|"L"
else|:
literal|"The next patch l"
operator|)
argument_list|,
name|diff_type
operator|==
name|UNI_DIFF
condition|?
literal|"a unified diff"
else|:
name|diff_type
operator|==
name|CONTEXT_DIFF
condition|?
literal|"a context diff"
else|:
name|diff_type
operator|==
name|NEW_CONTEXT_DIFF
condition|?
literal|"a new-style context diff"
else|:
name|diff_type
operator|==
name|NORMAL_DIFF
condition|?
literal|"a normal diff"
else|:
literal|"an ed script"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|!=
name|SILENT
condition|)
block|{
if|if
condition|(
name|p_indent
condition|)
name|say
argument_list|(
literal|"(Patch is indented %d space%s.)\n"
argument_list|,
name|p_indent
argument_list|,
name|p_indent
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inname
condition|)
block|{
name|say
argument_list|(
literal|"can't find file to patch at input line %ld\n"
argument_list|,
name|p_sline
argument_list|)
expr_stmt|;
name|say
argument_list|(
name|strippath
operator|==
name|INT_MAX
condition|?
literal|"Perhaps you should have used the -p or --strip option?\n"
else|:
literal|"Perhaps you used the wrong -p or --strip option?\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|skip_to
argument_list|(
name|p_start
argument_list|,
name|p_sline
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|inname
condition|)
block|{
if|if
condition|(
name|force
operator|||
name|batch
condition|)
block|{
name|say
argument_list|(
literal|"No file to patch.  Skipping patch.\n"
argument_list|)
expr_stmt|;
name|skip_rest_of_patch
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|ask
argument_list|(
literal|"File to patch: "
argument_list|)
expr_stmt|;
name|inname
operator|=
name|fetchname
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|inname
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|inname
argument_list|,
operator|&
name|instat
argument_list|)
operator|==
literal|0
condition|)
block|{
name|inerrno
operator|=
literal|0
expr_stmt|;
name|invc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|perror
argument_list|(
name|inname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inname
argument_list|)
expr_stmt|;
name|inname
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|inname
condition|)
block|{
name|ask
argument_list|(
literal|"Skip this patch? [y] "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'n'
condition|)
block|{
if|if
condition|(
name|verbosity
operator|!=
name|SILENT
condition|)
name|say
argument_list|(
literal|"Skipping patch.\n"
argument_list|)
expr_stmt|;
name|skip_rest_of_patch
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Determine what kind of diff is in the remaining part of the patch file. */
end_comment

begin_function
specifier|static
name|enum
name|diff
name|intuit_diff_type
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|indent
decl_stmt|;
specifier|register
name|file_offset
name|this_line
init|=
literal|0
decl_stmt|;
specifier|register
name|file_offset
name|previous_line
decl_stmt|;
specifier|register
name|file_offset
name|first_command_line
init|=
operator|-
literal|1
decl_stmt|;
name|LINENUM
name|fcl_line
init|=
literal|0
decl_stmt|;
comment|/* Pacify `gcc -W'.  */
specifier|register
name|bool
name|last_line_was_command
init|=
name|FALSE
decl_stmt|;
specifier|register
name|bool
name|this_is_a_command
init|=
name|FALSE
decl_stmt|;
specifier|register
name|bool
name|stars_last_line
init|=
name|FALSE
decl_stmt|;
specifier|register
name|bool
name|stars_this_line
init|=
name|FALSE
decl_stmt|;
name|enum
name|nametype
name|i
decl_stmt|;
name|char
modifier|*
name|name
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|stat
name|st
index|[
literal|3
index|]
decl_stmt|;
name|int
name|stat_errno
index|[
literal|3
index|]
decl_stmt|;
name|int
name|version_controlled
index|[
literal|3
index|]
decl_stmt|;
specifier|register
name|enum
name|diff
name|retval
decl_stmt|;
name|name
index|[
name|OLD
index|]
operator|=
name|name
index|[
name|NEW
index|]
operator|=
name|name
index|[
name|INDEX
index|]
operator|=
literal|0
expr_stmt|;
name|version_controlled
index|[
name|OLD
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|version_controlled
index|[
name|NEW
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|version_controlled
index|[
name|INDEX
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|p_rfc934_nesting
operator|=
literal|0
expr_stmt|;
name|p_timestamp
index|[
name|OLD
index|]
operator|=
name|p_timestamp
index|[
name|NEW
index|]
operator|=
operator|(
name|time_t
operator|)
operator|-
literal|1
expr_stmt|;
name|p_says_nonexistent
index|[
name|OLD
index|]
operator|=
name|p_says_nonexistent
index|[
name|NEW
index|]
operator|=
literal|0
expr_stmt|;
name|Fseek
argument_list|(
name|pfp
argument_list|,
name|p_base
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|p_input_line
operator|=
name|p_bline
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|previous_line
operator|=
name|this_line
expr_stmt|;
name|last_line_was_command
operator|=
name|this_is_a_command
expr_stmt|;
name|stars_last_line
operator|=
name|stars_this_line
expr_stmt|;
name|this_line
operator|=
name|file_tell
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|indent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|pget_line
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|first_command_line
operator|>=
literal|0
condition|)
block|{
comment|/* nothing but deletes!? */
name|p_start
operator|=
name|first_command_line
expr_stmt|;
name|p_sline
operator|=
name|fcl_line
expr_stmt|;
name|retval
operator|=
name|ED_DIFF
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
else|else
block|{
name|p_start
operator|=
name|this_line
expr_stmt|;
name|p_sline
operator|=
name|p_input_line
expr_stmt|;
return|return
name|NO_DIFF
return|;
block|}
block|}
for|for
control|(
name|s
operator|=
name|buf
init|;
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
operator|||
operator|*
name|s
operator|==
literal|'X'
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|indent
operator|=
operator|(
name|indent
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
else|else
name|indent
operator|++
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
name|s
init|;
name|ISDIGIT
argument_list|(
operator|*
name|t
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|','
condition|;
name|t
operator|++
control|)
continue|continue;
name|this_is_a_command
operator|=
operator|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|(
operator|*
name|t
operator|==
literal|'d'
operator|||
operator|*
name|t
operator|==
literal|'c'
operator|||
operator|*
name|t
operator|==
literal|'a'
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|first_command_line
operator|<
literal|0
operator|&&
name|this_is_a_command
condition|)
block|{
name|first_command_line
operator|=
name|this_line
expr_stmt|;
name|fcl_line
operator|=
name|p_input_line
expr_stmt|;
name|p_indent
operator|=
name|indent
expr_stmt|;
comment|/* assume this for now */
block|}
if|if
condition|(
operator|!
name|stars_last_line
operator|&&
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"*** "
argument_list|,
literal|4
argument_list|)
condition|)
name|name
index|[
name|OLD
index|]
operator|=
name|fetchname
argument_list|(
name|s
operator|+
literal|4
argument_list|,
name|strippath
argument_list|,
operator|&
name|p_timestamp
index|[
name|OLD
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"+++ "
argument_list|,
literal|4
argument_list|)
condition|)
comment|/* Swap with NEW below.  */
name|name
index|[
name|OLD
index|]
operator|=
name|fetchname
argument_list|(
name|s
operator|+
literal|4
argument_list|,
name|strippath
argument_list|,
operator|&
name|p_timestamp
index|[
name|OLD
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"Index:"
argument_list|,
literal|6
argument_list|)
condition|)
name|name
index|[
name|INDEX
index|]
operator|=
name|fetchname
argument_list|(
name|s
operator|+
literal|6
argument_list|,
name|strippath
argument_list|,
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"Prereq:"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
for|for
control|(
name|t
operator|=
name|s
operator|+
literal|7
init|;
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
continue|continue;
name|revision
operator|=
name|t
expr_stmt|;
for|for
control|(
name|t
operator|=
name|revision
init|;
operator|*
name|t
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
continue|continue;
if|if
condition|(
name|t
operator|==
name|revision
condition|)
name|revision
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|char
name|oldc
init|=
operator|*
name|t
decl_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|revision
operator|=
name|savestr
argument_list|(
name|revision
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
name|oldc
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|t
operator|=
name|s
init|;
name|t
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|t
index|[
literal|1
index|]
operator|==
literal|' '
condition|;
name|t
operator|+=
literal|2
control|)
continue|continue;
if|if
condition|(
name|strnEQ
argument_list|(
name|t
argument_list|,
literal|"--- "
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|time_t
name|timestamp
init|=
operator|(
name|time_t
operator|)
operator|-
literal|1
decl_stmt|;
name|name
index|[
name|NEW
index|]
operator|=
name|fetchname
argument_list|(
name|t
operator|+
literal|4
argument_list|,
name|strippath
argument_list|,
operator|&
name|timestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|timestamp
operator|!=
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
block|{
name|p_timestamp
index|[
name|NEW
index|]
operator|=
name|timestamp
expr_stmt|;
name|p_rfc934_nesting
operator|=
operator|(
name|t
operator|-
name|s
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|diff_type
operator|==
name|NO_DIFF
operator|||
name|diff_type
operator|==
name|ED_DIFF
operator|)
operator|&&
name|first_command_line
operator|>=
literal|0
operator|&&
name|strEQ
argument_list|(
name|s
argument_list|,
literal|".\n"
argument_list|)
condition|)
block|{
name|p_indent
operator|=
name|indent
expr_stmt|;
name|p_start
operator|=
name|first_command_line
expr_stmt|;
name|p_sline
operator|=
name|fcl_line
expr_stmt|;
name|retval
operator|=
name|ED_DIFF
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
if|if
condition|(
operator|(
name|diff_type
operator|==
name|NO_DIFF
operator|||
name|diff_type
operator|==
name|UNI_DIFF
operator|)
operator|&&
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"@@ -"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
comment|/* `name' and `p_timestamp' are backwards; swap them.  */
name|time_t
name|ti
init|=
name|p_timestamp
index|[
name|OLD
index|]
decl_stmt|;
name|p_timestamp
index|[
name|OLD
index|]
operator|=
name|p_timestamp
index|[
name|NEW
index|]
expr_stmt|;
name|p_timestamp
index|[
name|NEW
index|]
operator|=
name|ti
expr_stmt|;
name|t
operator|=
name|name
index|[
name|OLD
index|]
expr_stmt|;
name|name
index|[
name|OLD
index|]
operator|=
name|name
index|[
name|NEW
index|]
expr_stmt|;
name|name
index|[
name|NEW
index|]
operator|=
name|t
expr_stmt|;
name|s
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|atol
argument_list|(
name|s
argument_list|)
condition|)
name|p_says_nonexistent
index|[
name|OLD
index|]
operator|=
literal|1
operator|+
operator|!
name|p_timestamp
index|[
name|OLD
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|atol
argument_list|(
name|s
argument_list|)
condition|)
name|p_says_nonexistent
index|[
name|NEW
index|]
operator|=
literal|1
operator|+
operator|!
name|p_timestamp
index|[
name|NEW
index|]
expr_stmt|;
name|p_indent
operator|=
name|indent
expr_stmt|;
name|p_start
operator|=
name|this_line
expr_stmt|;
name|p_sline
operator|=
name|p_input_line
expr_stmt|;
name|retval
operator|=
name|UNI_DIFF
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|name
index|[
name|OLD
index|]
operator|||
operator|!
name|p_timestamp
index|[
name|OLD
index|]
operator|)
operator|&&
operator|(
name|name
index|[
name|NEW
index|]
operator|||
operator|!
name|p_timestamp
index|[
name|NEW
index|]
operator|)
operator|)
condition|)
name|say
argument_list|(
literal|"missing header for unified diff at line %ld of patch\n"
argument_list|,
name|p_sline
argument_list|)
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
name|stars_this_line
operator|=
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"********"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|diff_type
operator|==
name|NO_DIFF
operator|||
name|diff_type
operator|==
name|CONTEXT_DIFF
operator|||
name|diff_type
operator|==
name|NEW_CONTEXT_DIFF
operator|)
operator|&&
name|stars_last_line
operator|&&
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"*** "
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|s
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|atol
argument_list|(
name|s
argument_list|)
condition|)
name|p_says_nonexistent
index|[
name|OLD
index|]
operator|=
literal|1
operator|+
operator|!
name|p_timestamp
index|[
name|OLD
index|]
expr_stmt|;
comment|/* if this is a new context diff the character just before */
comment|/* the newline is a '*'. */
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
name|p_indent
operator|=
name|indent
expr_stmt|;
name|p_start
operator|=
name|previous_line
expr_stmt|;
name|p_sline
operator|=
name|p_input_line
operator|-
literal|1
expr_stmt|;
name|retval
operator|=
operator|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|'*'
condition|?
name|NEW_CONTEXT_DIFF
else|:
name|CONTEXT_DIFF
operator|)
expr_stmt|;
block|{
comment|/* Scan the first hunk to see whether the file contents 		 appear to have been deleted.  */
name|file_offset
name|saved_p_base
init|=
name|p_base
decl_stmt|;
name|LINENUM
name|saved_p_bline
init|=
name|p_bline
decl_stmt|;
name|Fseek
argument_list|(
name|pfp
argument_list|,
name|previous_line
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|p_input_line
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|another_hunk
argument_list|(
name|retval
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|p_repl_lines
operator|&&
name|p_newfirst
operator|==
literal|1
condition|)
name|p_says_nonexistent
index|[
name|NEW
index|]
operator|=
literal|1
operator|+
operator|!
name|p_timestamp
index|[
name|NEW
index|]
expr_stmt|;
name|next_intuit_at
argument_list|(
name|saved_p_base
argument_list|,
name|saved_p_bline
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
name|name
index|[
name|OLD
index|]
operator|||
operator|!
name|p_timestamp
index|[
name|OLD
index|]
operator|)
operator|&&
operator|(
name|name
index|[
name|NEW
index|]
operator|||
operator|!
name|p_timestamp
index|[
name|NEW
index|]
operator|)
operator|)
condition|)
name|say
argument_list|(
literal|"missing header for context diff at line %ld of patch\n"
argument_list|,
name|p_sline
argument_list|)
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
if|if
condition|(
operator|(
name|diff_type
operator|==
name|NO_DIFF
operator|||
name|diff_type
operator|==
name|NORMAL_DIFF
operator|)
operator|&&
name|last_line_was_command
operator|&&
operator|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"< "
argument_list|,
literal|2
argument_list|)
operator|||
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"> "
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
block|{
name|p_start
operator|=
name|previous_line
expr_stmt|;
name|p_sline
operator|=
name|p_input_line
operator|-
literal|1
expr_stmt|;
name|p_indent
operator|=
name|indent
expr_stmt|;
name|retval
operator|=
name|NORMAL_DIFF
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
block|}
name|scan_exit
label|:
comment|/* To intuit `inname', the name of the file to patch,        use the algorithm specified by POSIX 1003.2b/D11 section 5.22.7.2        (with some modifications if posixly_correct is zero):         - Take the old and new names from the context header if present, 	 and take the index name from the `Index:' line if present and 	 if either the old and new names are both absent 	 or posixly_correct is nonzero. 	 Consider the file names to be in the order (old, new, index).        - If some named files exist, use the first one if posixly_correct 	 is nonzero, the best one otherwise.        - If patch_get is nonzero, and no named files exist, 	 but an RCS or SCCS master file exists, 	 use the first named file with an RCS or SCCS master.        - If no named files exist, no RCS or SCCS master was found, 	 some names are given, posixly_correct is zero, 	 and the patch appears to create a file, then use the best name 	 requiring the creation of the fewest directories.        - Otherwise, report failure by setting `inname' to 0; 	 this causes our invoker to ask the user for a file name.  */
name|i
operator|=
name|NONE
expr_stmt|;
if|if
condition|(
operator|!
name|inname
condition|)
block|{
name|enum
name|nametype
name|i0
init|=
name|NONE
decl_stmt|;
if|if
condition|(
operator|!
name|posixly_correct
operator|&&
operator|(
name|name
index|[
name|OLD
index|]
operator|||
name|name
index|[
name|NEW
index|]
operator|)
operator|&&
name|name
index|[
name|INDEX
index|]
condition|)
block|{
name|free
argument_list|(
name|name
index|[
name|INDEX
index|]
argument_list|)
expr_stmt|;
name|name
index|[
name|INDEX
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|OLD
init|;
name|i
operator|<=
name|INDEX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|i0
operator|!=
name|NONE
operator|&&
name|strcmp
argument_list|(
name|name
index|[
name|i0
index|]
argument_list|,
name|name
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* It's the same name as before; reuse stat results.  */
name|stat_errno
index|[
name|i
index|]
operator|=
name|stat_errno
index|[
name|i0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|stat_errno
index|[
name|i
index|]
condition|)
name|st
index|[
name|i
index|]
operator|=
name|st
index|[
name|i0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
operator|&
name|st
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
name|stat_errno
index|[
name|i
index|]
operator|=
name|errno
expr_stmt|;
else|else
block|{
name|stat_errno
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|posixly_correct
condition|)
break|break;
block|}
name|i0
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|posixly_correct
condition|)
block|{
name|i
operator|=
name|best_name
argument_list|(
name|name
argument_list|,
name|stat_errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NONE
operator|&&
name|patch_get
condition|)
block|{
name|enum
name|nametype
name|nope
init|=
name|NONE
decl_stmt|;
for|for
control|(
name|i
operator|=
name|OLD
init|;
name|i
operator|<=
name|INDEX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
index|[
name|i
index|]
condition|)
block|{
name|char
specifier|const
modifier|*
name|cs
decl_stmt|;
name|char
modifier|*
name|getbuf
decl_stmt|;
name|char
modifier|*
name|diffbuf
decl_stmt|;
name|int
name|readonly
init|=
name|outfile
operator|&&
name|strcmp
argument_list|(
name|outfile
argument_list|,
name|name
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|nope
operator|==
name|NONE
operator|||
name|strcmp
argument_list|(
name|name
index|[
name|nope
index|]
argument_list|,
name|name
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cs
operator|=
operator|(
name|version_controller
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
name|readonly
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|getbuf
argument_list|,
operator|&
name|diffbuf
argument_list|)
operator|)
expr_stmt|;
name|version_controlled
index|[
name|i
index|]
operator|=
operator|!
operator|!
name|cs
expr_stmt|;
if|if
condition|(
name|cs
condition|)
block|{
if|if
condition|(
name|version_get
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
name|cs
argument_list|,
literal|0
argument_list|,
name|readonly
argument_list|,
name|getbuf
argument_list|,
operator|&
name|st
index|[
name|i
index|]
argument_list|)
condition|)
name|stat_errno
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|version_controlled
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|getbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|diffbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stat_errno
index|[
name|i
index|]
condition|)
break|break;
block|}
block|}
name|nope
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_says_nonexistent
index|[
name|reverse
operator|^
operator|(
name|i
operator|==
name|NONE
operator|||
name|st
index|[
name|i
index|]
operator|.
name|st_size
operator|==
literal|0
operator|)
index|]
condition|)
block|{
name|assert
argument_list|(
name|i0
operator|!=
name|NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok_to_reverse
argument_list|(
literal|"The next patch%s would %s the file `%s',\nwhich %s!"
argument_list|,
name|reverse
condition|?
literal|", when reversed,"
else|:
literal|""
argument_list|,
operator|(
name|i
operator|==
name|NONE
condition|?
literal|"delete"
else|:
name|st
index|[
name|i
index|]
operator|.
name|st_size
operator|==
literal|0
condition|?
literal|"empty out"
else|:
literal|"create"
operator|)
argument_list|,
name|name
index|[
name|i
operator|==
name|NONE
operator|||
name|st
index|[
name|i
index|]
operator|.
name|st_size
operator|==
literal|0
condition|?
name|i0
else|:
name|i
index|]
argument_list|,
operator|(
name|i
operator|==
name|NONE
condition|?
literal|"does not exist"
else|:
name|st
index|[
name|i
index|]
operator|.
name|st_size
operator|==
literal|0
condition|?
literal|"is already empty"
else|:
literal|"already exists"
operator|)
argument_list|)
condition|)
name|reverse
operator|^=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|NONE
operator|&&
name|p_says_nonexistent
index|[
name|reverse
index|]
condition|)
block|{
name|int
name|newdirs
index|[
literal|3
index|]
decl_stmt|;
name|int
name|newdirs_min
init|=
name|INT_MAX
decl_stmt|;
name|int
name|distance_from_minimum
index|[
literal|3
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
name|OLD
init|;
name|i
operator|<=
name|INDEX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
index|[
name|i
index|]
condition|)
block|{
name|newdirs
index|[
name|i
index|]
operator|=
operator|(
name|prefix_components
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
operator|-
name|prefix_components
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|newdirs
index|[
name|i
index|]
operator|<
name|newdirs_min
condition|)
name|newdirs_min
operator|=
name|newdirs
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|OLD
init|;
name|i
operator|<=
name|INDEX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
index|[
name|i
index|]
condition|)
name|distance_from_minimum
index|[
name|i
index|]
operator|=
name|newdirs
index|[
name|i
index|]
operator|-
name|newdirs_min
expr_stmt|;
name|i
operator|=
name|best_name
argument_list|(
name|name
argument_list|,
name|distance_from_minimum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|==
name|NONE
condition|)
name|inerrno
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|inname
operator|=
name|name
index|[
name|i
index|]
expr_stmt|;
name|name
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|inerrno
operator|=
name|stat_errno
index|[
name|i
index|]
expr_stmt|;
name|invc
operator|=
name|version_controlled
index|[
name|i
index|]
expr_stmt|;
name|instat
operator|=
name|st
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|OLD
init|;
name|i
operator|<=
name|INDEX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Count the path name components in FILENAME's prefix.    If CHECKDIRS is nonzero, count only existing directories.  */
end_comment

begin_function
specifier|static
name|int
name|prefix_components
parameter_list|(
name|filename
parameter_list|,
name|checkdirs
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|checkdirs
decl_stmt|;
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|stat_buf
decl_stmt|;
name|int
name|stat_result
decl_stmt|;
name|char
modifier|*
name|f
init|=
name|filename
operator|+
name|FILESYSTEM_PREFIX_LEN
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|f
condition|)
while|while
condition|(
operator|*
operator|++
name|f
condition|)
if|if
condition|(
name|ISSLASH
argument_list|(
name|f
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|!
name|ISSLASH
argument_list|(
name|f
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|checkdirs
condition|)
block|{
operator|*
name|f
operator|=
literal|'\0'
expr_stmt|;
name|stat_result
operator|=
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|stat_buf
argument_list|)
expr_stmt|;
operator|*
name|f
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|stat_result
operator|==
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|stat_buf
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
break|break;
block|}
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Return the index of the best of NAME[OLD], NAME[NEW], and NAME[INDEX].    Ignore null names, and ignore NAME[i] if IGNORE[i] is nonzero.    Return NONE if all names are ignored.  */
end_comment

begin_function
specifier|static
name|enum
name|nametype
name|best_name
parameter_list|(
name|name
parameter_list|,
name|ignore
parameter_list|)
name|char
modifier|*
specifier|const
modifier|*
name|name
decl_stmt|;
name|int
specifier|const
modifier|*
name|ignore
decl_stmt|;
block|{
name|enum
name|nametype
name|i
decl_stmt|;
name|int
name|components
index|[
literal|3
index|]
decl_stmt|;
name|int
name|components_min
init|=
name|INT_MAX
decl_stmt|;
name|size_t
name|basename_len
index|[
literal|3
index|]
decl_stmt|;
name|size_t
name|basename_len_min
init|=
operator|(
name|size_t
operator|)
operator|-
literal|1
decl_stmt|;
name|size_t
name|len
index|[
literal|3
index|]
decl_stmt|;
name|size_t
name|len_min
init|=
operator|(
name|size_t
operator|)
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
name|OLD
init|;
name|i
operator|<=
name|INDEX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
index|[
name|i
index|]
operator|&&
operator|!
name|ignore
index|[
name|i
index|]
condition|)
block|{
comment|/* Take the names with the fewest prefix components.  */
name|components
index|[
name|i
index|]
operator|=
name|prefix_components
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|components_min
operator|<
name|components
index|[
name|i
index|]
condition|)
continue|continue;
name|components_min
operator|=
name|components
index|[
name|i
index|]
expr_stmt|;
comment|/* Of those, take the names with the shortest basename.  */
name|basename_len
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|base_name
argument_list|(
name|name
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|basename_len_min
operator|<
name|basename_len
index|[
name|i
index|]
condition|)
continue|continue;
name|basename_len_min
operator|=
name|basename_len
index|[
name|i
index|]
expr_stmt|;
comment|/* Of those, take the shortest names.  */
name|len
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len_min
operator|<
name|len
index|[
name|i
index|]
condition|)
continue|continue;
name|len_min
operator|=
name|len
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Of those, take the first name.  */
for|for
control|(
name|i
operator|=
name|OLD
init|;
name|i
operator|<=
name|INDEX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
index|[
name|i
index|]
operator|&&
operator|!
name|ignore
index|[
name|i
index|]
operator|&&
name|components
index|[
name|i
index|]
operator|==
name|components_min
operator|&&
name|basename_len
index|[
name|i
index|]
operator|==
name|basename_len_min
operator|&&
name|len
index|[
name|i
index|]
operator|==
name|len_min
condition|)
break|break;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Remember where this patch ends so we know where to start up again. */
end_comment

begin_function
specifier|static
name|void
name|next_intuit_at
parameter_list|(
name|file_pos
parameter_list|,
name|file_line
parameter_list|)
name|file_offset
name|file_pos
decl_stmt|;
name|LINENUM
name|file_line
decl_stmt|;
block|{
name|p_base
operator|=
name|file_pos
expr_stmt|;
name|p_bline
operator|=
name|file_line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Basically a verbose fseek() to the actual diff listing. */
end_comment

begin_function
specifier|static
name|void
name|skip_to
parameter_list|(
name|file_pos
parameter_list|,
name|file_line
parameter_list|)
name|file_offset
name|file_pos
decl_stmt|;
name|LINENUM
name|file_line
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|i
init|=
name|pfp
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|o
init|=
name|stdout
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|assert
argument_list|(
name|p_base
operator|<=
name|file_pos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|verbosity
operator|==
name|VERBOSE
operator|||
operator|!
name|inname
operator|)
operator|&&
name|p_base
operator|<
name|file_pos
condition|)
block|{
name|Fseek
argument_list|(
name|i
argument_list|,
name|p_base
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|say
argument_list|(
literal|"The text leading up to this was:\n--------------------------\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|file_tell
argument_list|(
name|i
argument_list|)
operator|<
name|file_pos
condition|)
block|{
name|putc
argument_list|(
literal|'|'
argument_list|,
name|o
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|i
argument_list|)
operator|)
operator|==
name|EOF
condition|)
name|read_fatal
argument_list|()
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
block|}
name|say
argument_list|(
literal|"--------------------------\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|Fseek
argument_list|(
name|i
argument_list|,
name|file_pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|p_input_line
operator|=
name|file_line
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make this a function for better debugging.  */
end_comment

begin_function
specifier|static
name|void
name|malformed
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"malformed patch at line %ld: %s"
argument_list|,
name|p_input_line
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* about as informative as "Syntax error" in C */
block|}
end_function

begin_comment
comment|/* 1 if there is more of the current diff listing to process;    0 if not; -1 if ran out of memory. */
end_comment

begin_function
name|int
name|another_hunk
parameter_list|(
name|difftype
parameter_list|,
name|rev
parameter_list|)
name|enum
name|diff
name|difftype
decl_stmt|;
name|int
name|rev
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|LINENUM
name|context
init|=
literal|0
decl_stmt|;
specifier|register
name|size_t
name|chars_read
decl_stmt|;
while|while
condition|(
name|p_end
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|p_end
operator|==
name|p_efake
condition|)
name|p_end
operator|=
name|p_bfake
expr_stmt|;
comment|/* don't free twice */
else|else
name|free
argument_list|(
name|p_line
index|[
name|p_end
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|--
expr_stmt|;
block|}
name|assert
argument_list|(
name|p_end
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_efake
operator|=
operator|-
literal|1
expr_stmt|;
name|p_max
operator|=
name|hunkmax
expr_stmt|;
comment|/* gets reduced when --- found */
if|if
condition|(
name|difftype
operator|==
name|CONTEXT_DIFF
operator|||
name|difftype
operator|==
name|NEW_CONTEXT_DIFF
condition|)
block|{
name|file_offset
name|line_beginning
init|=
name|file_tell
argument_list|(
name|pfp
argument_list|)
decl_stmt|;
comment|/* file pos of the current line */
name|LINENUM
name|repl_beginning
init|=
literal|0
decl_stmt|;
comment|/* index of --- line */
specifier|register
name|LINENUM
name|fillcnt
init|=
literal|0
decl_stmt|;
comment|/* #lines of missing ptrn or repl */
specifier|register
name|LINENUM
name|fillsrc
decl_stmt|;
comment|/* index of first line to copy */
specifier|register
name|LINENUM
name|filldst
decl_stmt|;
comment|/* index of first missing line */
name|bool
name|ptrn_spaces_eaten
init|=
name|FALSE
decl_stmt|;
comment|/* ptrn was slightly misformed */
name|bool
name|some_context
init|=
name|FALSE
decl_stmt|;
comment|/* (perhaps internal) context seen */
specifier|register
name|bool
name|repl_could_be_missing
init|=
name|TRUE
decl_stmt|;
name|bool
name|repl_missing
init|=
name|FALSE
decl_stmt|;
comment|/* we are now backtracking */
name|file_offset
name|repl_backtrack_position
init|=
literal|0
decl_stmt|;
comment|/* file pos of first repl line */
name|LINENUM
name|repl_patch_line
decl_stmt|;
comment|/* input line number for same */
name|LINENUM
name|repl_context
decl_stmt|;
comment|/* context for same */
name|LINENUM
name|ptrn_prefix_context
init|=
operator|-
literal|1
decl_stmt|;
comment|/* lines in pattern prefix context */
name|LINENUM
name|ptrn_suffix_context
init|=
operator|-
literal|1
decl_stmt|;
comment|/* lines in pattern suffix context */
name|LINENUM
name|repl_prefix_context
init|=
operator|-
literal|1
decl_stmt|;
comment|/* lines in replac. prefix context */
specifier|register
name|LINENUM
name|ptrn_copiable
init|=
literal|0
decl_stmt|;
comment|/* # of copiable lines in ptrn */
comment|/* Pacify `gcc -Wall'.  */
name|fillsrc
operator|=
name|filldst
operator|=
name|repl_patch_line
operator|=
name|repl_context
operator|=
literal|0
expr_stmt|;
name|chars_read
operator|=
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|chars_read
operator|<=
literal|8
operator|||
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"********"
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|next_intuit_at
argument_list|(
name|line_beginning
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
return|return
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
name|p_hunk_beg
operator|=
name|p_input_line
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|p_end
operator|<
name|p_max
condition|)
block|{
name|chars_read
operator|=
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|chars_read
condition|)
block|{
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
if|if
condition|(
name|p_max
operator|-
name|p_end
operator|<
literal|4
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"  \n"
argument_list|)
expr_stmt|;
comment|/* assume blank lines got chopped */
name|chars_read
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|fatal
argument_list|(
literal|"unexpected end of file in patch"
argument_list|)
expr_stmt|;
block|}
block|}
name|p_end
operator|++
expr_stmt|;
if|if
condition|(
name|p_end
operator|==
name|hunkmax
condition|)
name|fatal
argument_list|(
literal|"unterminated hunk starting at line %ld; giving up at line %ld: %s"
argument_list|,
name|pch_hunk_beg
argument_list|()
argument_list|,
name|p_input_line
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p_end
operator|<
name|hunkmax
argument_list|)
expr_stmt|;
name|p_Char
index|[
name|p_end
index|]
operator|=
operator|*
name|buf
expr_stmt|;
name|p_len
index|[
name|p_end
index|]
operator|=
literal|0
expr_stmt|;
name|p_line
index|[
name|p_end
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
literal|'*'
case|:
if|if
condition|(
name|strnEQ
argument_list|(
name|buf
argument_list|,
literal|"********"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
else|else
name|fatal
argument_list|(
literal|"unexpected end of hunk at line %ld"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_end
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|fatal
argument_list|(
literal|"unexpected `***' at line %ld: %s"
argument_list|,
name|p_input_line
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|context
operator|=
literal|0
expr_stmt|;
name|p_len
index|[
name|p_end
index|]
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
name|p_end
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|s
operator|=
name|buf
init|;
operator|*
name|s
operator|&&
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
continue|continue;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"0,0"
argument_list|,
literal|3
argument_list|)
condition|)
name|remove_prefix
argument_list|(
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|p_first
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|&&
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_ptrn_lines
operator|=
operator|(
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|s
argument_list|)
operator|)
operator|-
name|p_first
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_first
condition|)
name|p_ptrn_lines
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|p_ptrn_lines
operator|=
literal|0
expr_stmt|;
name|p_first
operator|=
literal|1
expr_stmt|;
block|}
name|p_max
operator|=
name|p_ptrn_lines
operator|+
literal|6
expr_stmt|;
comment|/* we need this much at least */
while|while
condition|(
name|p_max
operator|>=
name|hunkmax
condition|)
if|if
condition|(
operator|!
name|grow_hunkmax
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
name|p_max
operator|=
name|hunkmax
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|!=
literal|'-'
condition|)
goto|goto
name|change_line
goto|;
if|if
condition|(
name|ptrn_prefix_context
operator|==
operator|-
literal|1
condition|)
name|ptrn_prefix_context
operator|=
name|context
expr_stmt|;
name|ptrn_suffix_context
operator|=
name|context
expr_stmt|;
if|if
condition|(
name|repl_beginning
operator|||
operator|(
name|p_end
operator|!=
name|p_ptrn_lines
operator|+
literal|1
operator|+
operator|(
name|p_Char
index|[
name|p_end
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|p_end
operator|==
literal|1
condition|)
block|{
comment|/* `Old' lines were omitted.  Set up to fill 			   them in from `new' context lines.  */
name|p_end
operator|=
name|p_ptrn_lines
operator|+
literal|1
expr_stmt|;
name|ptrn_prefix_context
operator|=
name|ptrn_suffix_context
operator|=
operator|-
literal|1
expr_stmt|;
name|fillsrc
operator|=
name|p_end
operator|+
literal|1
expr_stmt|;
name|filldst
operator|=
literal|1
expr_stmt|;
name|fillcnt
operator|=
name|p_ptrn_lines
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|repl_beginning
condition|)
name|fatal
argument_list|(
literal|"%s `---' at line %ld; check line numbers at line %ld"
argument_list|,
operator|(
name|p_end
operator|<=
name|p_ptrn_lines
condition|?
literal|"Premature"
else|:
literal|"Overdue"
operator|)
argument_list|,
name|p_input_line
argument_list|,
name|p_hunk_beg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|repl_could_be_missing
condition|)
name|fatal
argument_list|(
literal|"duplicate `---' at line %ld; check line numbers at line %ld"
argument_list|,
name|p_input_line
argument_list|,
name|p_hunk_beg
operator|+
name|repl_beginning
argument_list|)
expr_stmt|;
else|else
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
block|}
name|repl_beginning
operator|=
name|p_end
expr_stmt|;
name|repl_backtrack_position
operator|=
name|file_tell
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|repl_patch_line
operator|=
name|p_input_line
expr_stmt|;
name|repl_context
operator|=
name|context
expr_stmt|;
name|p_len
index|[
name|p_end
index|]
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
name|p_end
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_Char
index|[
name|p_end
index|]
operator|=
literal|'='
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
init|;
operator|*
name|s
operator|&&
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
continue|continue;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_newfirst
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
do|do
block|{
if|if
condition|(
operator|!
operator|*
operator|++
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
name|p_repl_lines
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|s
argument_list|)
operator|-
name|p_newfirst
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_newfirst
condition|)
name|p_repl_lines
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|p_repl_lines
operator|=
literal|0
expr_stmt|;
name|p_newfirst
operator|=
literal|1
expr_stmt|;
block|}
name|p_max
operator|=
name|p_repl_lines
operator|+
name|p_end
expr_stmt|;
while|while
condition|(
name|p_max
operator|>=
name|hunkmax
condition|)
if|if
condition|(
operator|!
name|grow_hunkmax
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|p_repl_lines
operator|!=
name|ptrn_copiable
operator|&&
operator|(
name|p_prefix_context
operator|!=
literal|0
operator|||
name|context
operator|!=
literal|0
operator|||
name|p_repl_lines
operator|!=
literal|1
operator|)
condition|)
name|repl_could_be_missing
operator|=
name|FALSE
expr_stmt|;
name|context
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
case|case
literal|'!'
case|:
name|repl_could_be_missing
operator|=
name|FALSE
expr_stmt|;
name|change_line
label|:
name|s
operator|=
name|buf
operator|+
literal|1
expr_stmt|;
name|chars_read
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|&&
name|canonicalize
condition|)
block|{
name|strcpy
argument_list|(
name|s
argument_list|,
literal|" \n"
argument_list|)
expr_stmt|;
name|chars_read
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|chars_read
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
if|if
condition|(
operator|!
name|repl_beginning
condition|)
block|{
if|if
condition|(
name|ptrn_prefix_context
operator|==
operator|-
literal|1
condition|)
name|ptrn_prefix_context
operator|=
name|context
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|repl_prefix_context
operator|==
operator|-
literal|1
condition|)
name|repl_prefix_context
operator|=
name|context
expr_stmt|;
block|}
name|chars_read
operator|-=
operator|(
literal|1
operator|<
name|chars_read
operator|&&
name|p_end
operator|==
operator|(
name|repl_beginning
condition|?
name|p_max
else|:
name|p_ptrn_lines
operator|)
operator|&&
name|incomplete_line
argument_list|()
operator|)
expr_stmt|;
name|p_len
index|[
name|p_end
index|]
operator|=
name|chars_read
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
name|p_end
index|]
operator|=
name|savebuf
argument_list|(
name|s
argument_list|,
name|chars_read
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|context
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
comment|/* assume spaces got eaten */
name|s
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\t'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|chars_read
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
operator|&&
operator|(
operator|!
name|ptrn_spaces_eaten
operator|||
name|difftype
operator|==
name|NEW_CONTEXT_DIFF
operator|)
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|chars_read
operator|-=
operator|(
literal|1
operator|<
name|chars_read
operator|&&
name|p_end
operator|==
operator|(
name|repl_beginning
condition|?
name|p_max
else|:
name|p_ptrn_lines
operator|)
operator|&&
name|incomplete_line
argument_list|()
operator|)
expr_stmt|;
name|p_len
index|[
name|p_end
index|]
operator|=
name|chars_read
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
name|p_end
index|]
operator|=
name|savebuf
argument_list|(
name|buf
argument_list|,
name|chars_read
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|p_end
operator|!=
name|p_ptrn_lines
operator|+
literal|1
condition|)
block|{
name|ptrn_spaces_eaten
operator||=
operator|(
name|repl_beginning
operator|!=
literal|0
operator|)
expr_stmt|;
name|some_context
operator|=
name|TRUE
expr_stmt|;
name|context
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|repl_beginning
condition|)
name|ptrn_copiable
operator|++
expr_stmt|;
name|p_Char
index|[
name|p_end
index|]
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
case|case
literal|' '
case|:
name|s
operator|=
name|buf
operator|+
literal|1
expr_stmt|;
name|chars_read
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|&&
name|canonicalize
condition|)
block|{
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|chars_read
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|chars_read
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|some_context
operator|=
name|TRUE
expr_stmt|;
name|context
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|repl_beginning
condition|)
name|ptrn_copiable
operator|++
expr_stmt|;
name|chars_read
operator|-=
operator|(
literal|1
operator|<
name|chars_read
operator|&&
name|p_end
operator|==
operator|(
name|repl_beginning
condition|?
name|p_max
else|:
name|p_ptrn_lines
operator|)
operator|&&
name|incomplete_line
argument_list|()
operator|)
expr_stmt|;
name|p_len
index|[
name|p_end
index|]
operator|=
name|chars_read
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
name|p_end
index|]
operator|=
name|savebuf
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|chars_read
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
default|default:
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|malformed
argument_list|()
expr_stmt|;
block|}
block|}
name|hunk_done
label|:
if|if
condition|(
name|p_end
operator|>=
literal|0
operator|&&
operator|!
name|repl_beginning
condition|)
name|fatal
argument_list|(
literal|"no `---' found in patch at line %ld"
argument_list|,
name|pch_hunk_beg
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|repl_missing
condition|)
block|{
comment|/* reset state back to just after --- */
name|p_input_line
operator|=
name|repl_patch_line
expr_stmt|;
name|context
operator|=
name|repl_context
expr_stmt|;
for|for
control|(
name|p_end
operator|--
init|;
name|p_end
operator|>
name|repl_beginning
condition|;
name|p_end
operator|--
control|)
name|free
argument_list|(
name|p_line
index|[
name|p_end
index|]
argument_list|)
expr_stmt|;
name|Fseek
argument_list|(
name|pfp
argument_list|,
name|repl_backtrack_position
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* redundant 'new' context lines were omitted - set */
comment|/* up to fill them in from the old file context */
name|fillsrc
operator|=
literal|1
expr_stmt|;
name|filldst
operator|=
name|repl_beginning
operator|+
literal|1
expr_stmt|;
name|fillcnt
operator|=
name|p_repl_lines
expr_stmt|;
name|p_end
operator|=
name|p_max
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|some_context
operator|&&
name|fillcnt
operator|==
literal|1
condition|)
block|{
comment|/* the first hunk was a null hunk with no context */
comment|/* and we were expecting one line -- fix it up. */
while|while
condition|(
name|filldst
operator|<
name|p_end
condition|)
block|{
name|p_line
index|[
name|filldst
index|]
operator|=
name|p_line
index|[
name|filldst
operator|+
literal|1
index|]
expr_stmt|;
name|p_Char
index|[
name|filldst
index|]
operator|=
name|p_Char
index|[
name|filldst
operator|+
literal|1
index|]
expr_stmt|;
name|p_len
index|[
name|filldst
index|]
operator|=
name|p_len
index|[
name|filldst
operator|+
literal|1
index|]
expr_stmt|;
name|filldst
operator|++
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|repl_beginning--;
comment|/* this doesn't need to be fixed */
endif|#
directive|endif
name|p_end
operator|--
expr_stmt|;
name|p_first
operator|++
expr_stmt|;
comment|/* do append rather than insert */
name|fillcnt
operator|=
literal|0
expr_stmt|;
name|p_ptrn_lines
operator|=
literal|0
expr_stmt|;
block|}
name|p_prefix_context
operator|=
operator|(
operator|(
name|repl_prefix_context
operator|==
operator|-
literal|1
operator|||
operator|(
name|ptrn_prefix_context
operator|!=
operator|-
literal|1
operator|&&
name|ptrn_prefix_context
operator|<
name|repl_prefix_context
operator|)
operator|)
condition|?
name|ptrn_prefix_context
else|:
name|repl_prefix_context
operator|)
expr_stmt|;
name|p_suffix_context
operator|=
operator|(
operator|(
name|ptrn_suffix_context
operator|!=
operator|-
literal|1
operator|&&
name|ptrn_suffix_context
operator|<
name|context
operator|)
condition|?
name|ptrn_suffix_context
else|:
name|context
operator|)
expr_stmt|;
name|assert
argument_list|(
name|p_prefix_context
operator|!=
operator|-
literal|1
operator|&&
name|p_suffix_context
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|difftype
operator|==
name|CONTEXT_DIFF
operator|&&
operator|(
name|fillcnt
operator|||
operator|(
name|p_first
operator|>
literal|1
operator|&&
name|p_prefix_context
operator|+
name|p_suffix_context
operator|<
name|ptrn_copiable
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|verbosity
operator|==
name|VERBOSE
condition|)
name|say
argument_list|(
literal|"%s\n%s\n%s\n"
argument_list|,
literal|"(Fascinating -- this is really a new-style context diff but without"
argument_list|,
literal|"the telltale extra asterisks on the *** line that usually indicate"
argument_list|,
literal|"the new style...)"
argument_list|)
expr_stmt|;
name|diff_type
operator|=
name|difftype
operator|=
name|NEW_CONTEXT_DIFF
expr_stmt|;
block|}
comment|/* if there were omitted context lines, fill them in now */
if|if
condition|(
name|fillcnt
condition|)
block|{
name|p_bfake
operator|=
name|filldst
expr_stmt|;
comment|/* remember where not to free() */
name|p_efake
operator|=
name|filldst
operator|+
name|fillcnt
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|fillcnt
operator|--
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|fillsrc
operator|<=
name|p_end
operator|&&
name|fillsrc
operator|!=
name|repl_beginning
operator|&&
name|p_Char
index|[
name|fillsrc
index|]
operator|!=
literal|' '
condition|)
name|fillsrc
operator|++
expr_stmt|;
if|if
condition|(
name|p_end
operator|<
name|fillsrc
operator|||
name|fillsrc
operator|==
name|repl_beginning
condition|)
name|fatal
argument_list|(
literal|"replacement text or line numbers mangled in hunk at line %ld"
argument_list|,
name|p_hunk_beg
argument_list|)
expr_stmt|;
name|p_line
index|[
name|filldst
index|]
operator|=
name|p_line
index|[
name|fillsrc
index|]
expr_stmt|;
name|p_Char
index|[
name|filldst
index|]
operator|=
name|p_Char
index|[
name|fillsrc
index|]
expr_stmt|;
name|p_len
index|[
name|filldst
index|]
operator|=
name|p_len
index|[
name|fillsrc
index|]
expr_stmt|;
name|fillsrc
operator|++
expr_stmt|;
name|filldst
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|fillsrc
operator|<=
name|p_end
operator|&&
name|fillsrc
operator|!=
name|repl_beginning
condition|)
block|{
if|if
condition|(
name|p_Char
index|[
name|fillsrc
index|]
operator|==
literal|' '
condition|)
name|fatal
argument_list|(
literal|"replacement text or line numbers mangled in hunk at line %ld"
argument_list|,
name|p_hunk_beg
argument_list|)
expr_stmt|;
name|fillsrc
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|&
literal|64
condition|)
name|printf
argument_list|(
literal|"fillsrc %ld, filldst %ld, rb %ld, e+1 %ld\n"
argument_list|,
name|fillsrc
argument_list|,
name|filldst
argument_list|,
name|repl_beginning
argument_list|,
name|p_end
operator|+
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fillsrc
operator|==
name|p_end
operator|+
literal|1
operator|||
name|fillsrc
operator|==
name|repl_beginning
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|filldst
operator|==
name|p_end
operator|+
literal|1
operator|||
name|filldst
operator|==
name|repl_beginning
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|difftype
operator|==
name|UNI_DIFF
condition|)
block|{
name|file_offset
name|line_beginning
init|=
name|file_tell
argument_list|(
name|pfp
argument_list|)
decl_stmt|;
comment|/* file pos of the current line */
specifier|register
name|LINENUM
name|fillsrc
decl_stmt|;
comment|/* index of old lines */
specifier|register
name|LINENUM
name|filldst
decl_stmt|;
comment|/* index of new lines */
name|char
name|ch
init|=
literal|'\0'
decl_stmt|;
name|chars_read
operator|=
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|chars_read
operator|<=
literal|4
operator|||
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"@@ -"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|next_intuit_at
argument_list|(
name|line_beginning
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
return|return
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
name|s
operator|=
name|buf
operator|+
literal|4
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_first
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|p_ptrn_lines
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
operator|++
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
name|p_ptrn_lines
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'+'
operator|||
operator|!
operator|*
operator|++
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_newfirst
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|p_repl_lines
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
operator|++
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
name|p_repl_lines
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'@'
condition|)
name|malformed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptrn_lines
condition|)
name|p_first
operator|++
expr_stmt|;
comment|/* do append rather than insert */
if|if
condition|(
operator|!
name|p_repl_lines
condition|)
name|p_newfirst
operator|++
expr_stmt|;
name|p_max
operator|=
name|p_ptrn_lines
operator|+
name|p_repl_lines
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|p_max
operator|>=
name|hunkmax
condition|)
if|if
condition|(
operator|!
name|grow_hunkmax
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
name|fillsrc
operator|=
literal|1
expr_stmt|;
name|filldst
operator|=
name|fillsrc
operator|+
name|p_ptrn_lines
expr_stmt|;
name|p_end
operator|=
name|filldst
operator|+
name|p_repl_lines
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"*** %ld,%ld ****\n"
argument_list|,
name|p_first
argument_list|,
name|p_first
operator|+
name|p_ptrn_lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_len
index|[
literal|0
index|]
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
literal|0
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_Char
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"--- %ld,%ld ----\n"
argument_list|,
name|p_newfirst
argument_list|,
name|p_newfirst
operator|+
name|p_repl_lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_len
index|[
name|filldst
index|]
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
name|filldst
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_Char
index|[
name|filldst
operator|++
index|]
operator|=
literal|'='
expr_stmt|;
name|p_prefix_context
operator|=
operator|-
literal|1
expr_stmt|;
name|p_hunk_beg
operator|=
name|p_input_line
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|fillsrc
operator|<=
name|p_ptrn_lines
operator|||
name|filldst
operator|<=
name|p_end
condition|)
block|{
name|chars_read
operator|=
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|chars_read
condition|)
block|{
if|if
condition|(
name|p_max
operator|-
name|filldst
operator|<
literal|3
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|" \n"
argument_list|)
expr_stmt|;
comment|/* assume blank lines got chopped */
name|chars_read
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fatal
argument_list|(
literal|"unexpected end of file in patch"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|s
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\t'
operator|||
operator|*
name|buf
operator|==
literal|'\n'
condition|)
block|{
name|ch
operator|=
literal|' '
expr_stmt|;
comment|/* assume the space got eaten */
name|s
operator|=
name|savebuf
argument_list|(
name|buf
argument_list|,
name|chars_read
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
operator|*
name|buf
expr_stmt|;
name|s
operator|=
name|savebuf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
operator|--
name|chars_read
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
condition|)
block|{
while|while
condition|(
operator|--
name|filldst
operator|>
name|p_ptrn_lines
condition|)
name|free
argument_list|(
name|p_line
index|[
name|filldst
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|fillsrc
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'-'
case|:
if|if
condition|(
name|fillsrc
operator|>
name|p_ptrn_lines
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|filldst
operator|-
literal|1
expr_stmt|;
name|malformed
argument_list|()
expr_stmt|;
block|}
name|chars_read
operator|-=
name|fillsrc
operator|==
name|p_ptrn_lines
operator|&&
name|incomplete_line
argument_list|()
expr_stmt|;
name|p_Char
index|[
name|fillsrc
index|]
operator|=
name|ch
expr_stmt|;
name|p_line
index|[
name|fillsrc
index|]
operator|=
name|s
expr_stmt|;
name|p_len
index|[
name|fillsrc
operator|++
index|]
operator|=
name|chars_read
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|ch
operator|=
literal|' '
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|' '
case|:
if|if
condition|(
name|fillsrc
operator|>
name|p_ptrn_lines
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|filldst
operator|>
name|p_ptrn_lines
condition|)
name|free
argument_list|(
name|p_line
index|[
name|filldst
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|fillsrc
operator|-
literal|1
expr_stmt|;
name|malformed
argument_list|()
expr_stmt|;
block|}
name|context
operator|++
expr_stmt|;
name|chars_read
operator|-=
name|fillsrc
operator|==
name|p_ptrn_lines
operator|&&
name|incomplete_line
argument_list|()
expr_stmt|;
name|p_Char
index|[
name|fillsrc
index|]
operator|=
name|ch
expr_stmt|;
name|p_line
index|[
name|fillsrc
index|]
operator|=
name|s
expr_stmt|;
name|p_len
index|[
name|fillsrc
operator|++
index|]
operator|=
name|chars_read
expr_stmt|;
name|s
operator|=
name|savebuf
argument_list|(
name|s
argument_list|,
name|chars_read
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
while|while
condition|(
operator|--
name|filldst
operator|>
name|p_ptrn_lines
condition|)
name|free
argument_list|(
name|p_line
index|[
name|filldst
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|fillsrc
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* FALL THROUGH */
case|case
literal|'+'
case|:
if|if
condition|(
name|filldst
operator|>
name|p_end
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|filldst
operator|>
name|p_ptrn_lines
condition|)
name|free
argument_list|(
name|p_line
index|[
name|filldst
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|fillsrc
operator|-
literal|1
expr_stmt|;
name|malformed
argument_list|()
expr_stmt|;
block|}
name|chars_read
operator|-=
name|filldst
operator|==
name|p_end
operator|&&
name|incomplete_line
argument_list|()
expr_stmt|;
name|p_Char
index|[
name|filldst
index|]
operator|=
name|ch
expr_stmt|;
name|p_line
index|[
name|filldst
index|]
operator|=
name|s
expr_stmt|;
name|p_len
index|[
name|filldst
operator|++
index|]
operator|=
name|chars_read
expr_stmt|;
break|break;
default|default:
name|p_end
operator|=
name|filldst
expr_stmt|;
name|malformed
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|!=
literal|' '
condition|)
block|{
if|if
condition|(
name|p_prefix_context
operator|==
operator|-
literal|1
condition|)
name|p_prefix_context
operator|=
name|context
expr_stmt|;
name|context
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* while */
if|if
condition|(
name|p_prefix_context
operator|==
operator|-
literal|1
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_suffix_context
operator|=
name|context
expr_stmt|;
block|}
else|else
block|{
comment|/* normal diff--fake it up */
name|char
name|hunk_type
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|LINENUM
name|min
decl_stmt|,
name|max
decl_stmt|;
name|file_offset
name|line_beginning
init|=
name|file_tell
argument_list|(
name|pfp
argument_list|)
decl_stmt|;
name|p_prefix_context
operator|=
name|p_suffix_context
operator|=
literal|0
expr_stmt|;
name|chars_read
operator|=
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
operator|!
name|chars_read
operator|||
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|buf
argument_list|)
condition|)
block|{
name|next_intuit_at
argument_list|(
name|line_beginning
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
return|return
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
name|p_first
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
init|;
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|p_ptrn_lines
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
operator|++
name|s
argument_list|)
operator|-
name|p_first
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
name|p_ptrn_lines
operator|=
operator|(
operator|*
name|s
operator|!=
literal|'a'
operator|)
expr_stmt|;
name|hunk_type
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|hunk_type
operator|==
literal|'a'
condition|)
name|p_first
operator|++
expr_stmt|;
comment|/* do append rather than insert */
name|min
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
operator|++
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|max
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
operator|++
name|s
argument_list|)
expr_stmt|;
else|else
name|max
operator|=
name|min
expr_stmt|;
if|if
condition|(
name|hunk_type
operator|==
literal|'d'
condition|)
name|min
operator|++
expr_stmt|;
name|p_end
operator|=
name|p_ptrn_lines
operator|+
literal|1
operator|+
name|max
operator|-
name|min
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|p_end
operator|>=
name|hunkmax
condition|)
if|if
condition|(
operator|!
name|grow_hunkmax
argument_list|()
condition|)
block|{
name|p_end
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_newfirst
operator|=
name|min
expr_stmt|;
name|p_repl_lines
operator|=
name|max
operator|-
name|min
operator|+
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"*** %ld,%ld\n"
argument_list|,
name|p_first
argument_list|,
name|p_first
operator|+
name|p_ptrn_lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_len
index|[
literal|0
index|]
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
literal|0
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_Char
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|p_ptrn_lines
condition|;
name|i
operator|++
control|)
block|{
name|chars_read
operator|=
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
name|p_end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|chars_read
condition|)
name|fatal
argument_list|(
literal|"unexpected end of file in patch at line %ld"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'<'
operator|||
operator|(
name|buf
index|[
literal|1
index|]
operator|!=
literal|' '
operator|&&
name|buf
index|[
literal|1
index|]
operator|!=
literal|'\t'
operator|)
condition|)
name|fatal
argument_list|(
literal|"`<' expected at line %ld of patch"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
name|chars_read
operator|-=
literal|2
operator|+
operator|(
name|i
operator|==
name|p_ptrn_lines
operator|&&
name|incomplete_line
argument_list|()
operator|)
expr_stmt|;
name|p_len
index|[
name|i
index|]
operator|=
name|chars_read
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
name|i
index|]
operator|=
name|savebuf
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|chars_read
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_Char
index|[
name|i
index|]
operator|=
literal|'-'
expr_stmt|;
block|}
if|if
condition|(
name|hunk_type
operator|==
literal|'c'
condition|)
block|{
name|chars_read
operator|=
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
name|p_end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|chars_read
condition|)
name|fatal
argument_list|(
literal|"unexpected end of file in patch at line %ld"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'-'
condition|)
name|fatal
argument_list|(
literal|"`---' expected at line %ld of patch"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"--- %ld,%ld\n"
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|p_len
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
name|i
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_Char
index|[
name|i
index|]
operator|=
literal|'='
expr_stmt|;
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<=
name|p_end
condition|;
name|i
operator|++
control|)
block|{
name|chars_read
operator|=
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
name|p_end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|chars_read
condition|)
name|fatal
argument_list|(
literal|"unexpected end of file in patch at line %ld"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'>'
operator|||
operator|(
name|buf
index|[
literal|1
index|]
operator|!=
literal|' '
operator|&&
name|buf
index|[
literal|1
index|]
operator|!=
literal|'\t'
operator|)
condition|)
name|fatal
argument_list|(
literal|"`>' expected at line %ld of patch"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
name|chars_read
operator|-=
literal|2
operator|+
operator|(
name|i
operator|==
name|p_end
operator|&&
name|incomplete_line
argument_list|()
operator|)
expr_stmt|;
name|p_len
index|[
name|i
index|]
operator|=
name|chars_read
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
name|i
index|]
operator|=
name|savebuf
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|chars_read
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_Char
index|[
name|i
index|]
operator|=
literal|'+'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rev
condition|)
comment|/* backwards patch? */
if|if
condition|(
operator|!
name|pch_swap
argument_list|()
condition|)
name|say
argument_list|(
literal|"Not enough memory to swap next hunk!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
literal|2
condition|)
block|{
name|LINENUM
name|i
decl_stmt|;
name|char
name|special
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|p_end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|p_ptrn_lines
condition|)
name|special
operator|=
literal|'^'
expr_stmt|;
else|else
name|special
operator|=
literal|' '
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%3ld %c %c "
argument_list|,
name|i
argument_list|,
name|p_Char
index|[
name|i
index|]
argument_list|,
name|special
argument_list|)
expr_stmt|;
name|pch_write_line
argument_list|(
name|i
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_end
operator|+
literal|1
operator|<
name|hunkmax
condition|)
comment|/* paranoia reigns supreme... */
name|p_Char
index|[
name|p_end
operator|+
literal|1
index|]
operator|=
literal|'^'
expr_stmt|;
comment|/* add a stopper for apply_hunk */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|get_line
parameter_list|()
block|{
return|return
name|pget_line
argument_list|(
name|p_indent
argument_list|,
name|p_rfc934_nesting
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Input a line from the patch file, worrying about indentation.    Strip up to INDENT characters' worth of leading indentation.    Then remove up to RFC934_NESTING instances of leading "- ".    Ignore any partial lines at end of input, but warn about them.    Succeed if a line was read; it is terminated by "\n\0" for convenience.    Return the number of characters read, including '\n' but not '\0'.    Return -1 if we ran out of memory.  */
end_comment

begin_function
specifier|static
name|size_t
name|pget_line
parameter_list|(
name|indent
parameter_list|,
name|rfc934_nesting
parameter_list|)
name|int
name|indent
decl_stmt|;
name|int
name|rfc934_nesting
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fp
init|=
name|pfp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|b
decl_stmt|;
specifier|register
name|size_t
name|s
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|read_fatal
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|indent
operator|<=
name|i
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'X'
condition|)
name|i
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
name|i
operator|=
operator|(
name|i
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
else|else
break|break;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|b
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|'-'
operator|&&
literal|0
operator|<=
operator|--
name|rfc934_nesting
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|patch_ends_in_middle_of_line
goto|;
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|patch_ends_in_middle_of_line
goto|;
block|}
name|s
operator|=
name|bufsize
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|==
name|s
operator|-
literal|1
condition|)
block|{
name|s
operator|*=
literal|2
expr_stmt|;
name|b
operator|=
name|realloc
argument_list|(
name|b
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
if|if
condition|(
operator|!
name|using_plan_a
condition|)
name|memory_fatal
argument_list|()
expr_stmt|;
return|return
operator|(
name|size_t
operator|)
operator|-
literal|1
return|;
block|}
name|buf
operator|=
name|b
expr_stmt|;
name|bufsize
operator|=
name|s
expr_stmt|;
block|}
name|b
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|patch_ends_in_middle_of_line
goto|;
block|}
name|b
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
return|return
name|i
return|;
name|patch_ends_in_middle_of_line
label|:
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|read_fatal
argument_list|()
expr_stmt|;
name|say
argument_list|(
literal|"patch unexpectedly ends in middle of line\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|incomplete_line
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|fp
init|=
name|pfp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|file_offset
name|line_beginning
init|=
name|file_tell
argument_list|(
name|fp
argument_list|)
decl_stmt|;
if|if
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|==
literal|'\\'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
continue|continue;
return|return
name|TRUE
return|;
block|}
else|else
block|{
comment|/* We don't trust ungetc.  */
name|Fseek
argument_list|(
name|pfp
argument_list|,
name|line_beginning
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Reverse the old and new portions of the current hunk. */
end_comment

begin_function
name|bool
name|pch_swap
parameter_list|()
block|{
name|char
modifier|*
modifier|*
name|tp_line
decl_stmt|;
comment|/* the text of the hunk */
name|size_t
modifier|*
name|tp_len
decl_stmt|;
comment|/* length of each line */
name|char
modifier|*
name|tp_char
decl_stmt|;
comment|/* +, -, and ! */
specifier|register
name|LINENUM
name|i
decl_stmt|;
specifier|register
name|LINENUM
name|n
decl_stmt|;
name|bool
name|blankline
init|=
name|FALSE
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|i
operator|=
name|p_first
expr_stmt|;
name|p_first
operator|=
name|p_newfirst
expr_stmt|;
name|p_newfirst
operator|=
name|i
expr_stmt|;
comment|/* make a scratch copy */
name|tp_line
operator|=
name|p_line
expr_stmt|;
name|tp_len
operator|=
name|p_len
expr_stmt|;
name|tp_char
operator|=
name|p_Char
expr_stmt|;
name|p_line
operator|=
literal|0
expr_stmt|;
comment|/* force set_hunkmax to allocate again */
name|p_len
operator|=
literal|0
expr_stmt|;
name|p_Char
operator|=
literal|0
expr_stmt|;
name|set_hunkmax
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_line
operator|||
operator|!
name|p_len
operator|||
operator|!
name|p_Char
condition|)
block|{
if|if
condition|(
name|p_line
condition|)
name|free
argument_list|(
name|p_line
argument_list|)
expr_stmt|;
name|p_line
operator|=
name|tp_line
expr_stmt|;
if|if
condition|(
name|p_len
condition|)
name|free
argument_list|(
name|p_len
argument_list|)
expr_stmt|;
name|p_len
operator|=
name|tp_len
expr_stmt|;
if|if
condition|(
name|p_Char
condition|)
name|free
argument_list|(
name|p_Char
argument_list|)
expr_stmt|;
name|p_Char
operator|=
name|tp_char
expr_stmt|;
return|return
name|FALSE
return|;
comment|/* not enough memory to swap hunk! */
block|}
comment|/* now turn the new into the old */
name|i
operator|=
name|p_ptrn_lines
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tp_char
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* account for possible blank line */
name|blankline
operator|=
name|TRUE
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p_efake
operator|>=
literal|0
condition|)
block|{
comment|/* fix non-freeable ptr range */
if|if
condition|(
name|p_efake
operator|<=
name|i
condition|)
name|n
operator|=
name|p_end
operator|-
name|i
operator|+
literal|1
expr_stmt|;
else|else
name|n
operator|=
operator|-
name|i
expr_stmt|;
name|p_efake
operator|+=
name|n
expr_stmt|;
name|p_bfake
operator|+=
name|n
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|i
operator|<=
name|p_end
condition|;
name|i
operator|++
operator|,
name|n
operator|++
control|)
block|{
name|p_line
index|[
name|n
index|]
operator|=
name|tp_line
index|[
name|i
index|]
expr_stmt|;
name|p_Char
index|[
name|n
index|]
operator|=
name|tp_char
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p_Char
index|[
name|n
index|]
operator|==
literal|'+'
condition|)
name|p_Char
index|[
name|n
index|]
operator|=
literal|'-'
expr_stmt|;
name|p_len
index|[
name|n
index|]
operator|=
name|tp_len
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|blankline
condition|)
block|{
name|i
operator|=
name|p_ptrn_lines
operator|+
literal|1
expr_stmt|;
name|p_line
index|[
name|n
index|]
operator|=
name|tp_line
index|[
name|i
index|]
expr_stmt|;
name|p_Char
index|[
name|n
index|]
operator|=
name|tp_char
index|[
name|i
index|]
expr_stmt|;
name|p_len
index|[
name|n
index|]
operator|=
name|tp_len
index|[
name|i
index|]
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|assert
argument_list|(
name|p_Char
index|[
literal|0
index|]
operator|==
literal|'='
argument_list|)
expr_stmt|;
name|p_Char
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
for|for
control|(
name|s
operator|=
name|p_line
index|[
literal|0
index|]
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
operator|*
name|s
operator|=
literal|'*'
expr_stmt|;
comment|/* now turn the old into the new */
name|assert
argument_list|(
name|tp_char
index|[
literal|0
index|]
operator|==
literal|'*'
argument_list|)
expr_stmt|;
name|tp_char
index|[
literal|0
index|]
operator|=
literal|'='
expr_stmt|;
for|for
control|(
name|s
operator|=
name|tp_line
index|[
literal|0
index|]
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
operator|*
name|s
operator|=
literal|'-'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|n
operator|<=
name|p_end
condition|;
name|i
operator|++
operator|,
name|n
operator|++
control|)
block|{
name|p_line
index|[
name|n
index|]
operator|=
name|tp_line
index|[
name|i
index|]
expr_stmt|;
name|p_Char
index|[
name|n
index|]
operator|=
name|tp_char
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p_Char
index|[
name|n
index|]
operator|==
literal|'-'
condition|)
name|p_Char
index|[
name|n
index|]
operator|=
literal|'+'
expr_stmt|;
name|p_len
index|[
name|n
index|]
operator|=
name|tp_len
index|[
name|i
index|]
expr_stmt|;
block|}
name|assert
argument_list|(
name|i
operator|==
name|p_ptrn_lines
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|p_ptrn_lines
expr_stmt|;
name|p_ptrn_lines
operator|=
name|p_repl_lines
expr_stmt|;
name|p_repl_lines
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|tp_line
condition|)
name|free
argument_list|(
name|tp_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp_len
condition|)
name|free
argument_list|(
name|tp_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp_char
condition|)
name|free
argument_list|(
name|tp_char
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return whether file WHICH (0 = old, 1 = new) appears to nonexistent.    Return 1 for empty, 2 for nonexistent.  */
end_comment

begin_function
name|bool
name|pch_says_nonexistent
parameter_list|(
name|which
parameter_list|)
name|int
name|which
decl_stmt|;
block|{
return|return
name|p_says_nonexistent
index|[
name|which
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return timestamp of patch header for file WHICH (0 = old, 1 = new),    or -1 if there was no timestamp or an error in the timestamp.  */
end_comment

begin_function
name|time_t
name|pch_timestamp
parameter_list|(
name|which
parameter_list|)
name|int
name|which
decl_stmt|;
block|{
return|return
name|p_timestamp
index|[
name|which
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the specified line position in the old file of the old context. */
end_comment

begin_function
name|LINENUM
name|pch_first
parameter_list|()
block|{
return|return
name|p_first
return|;
block|}
end_function

begin_comment
comment|/* Return the number of lines of old context. */
end_comment

begin_function
name|LINENUM
name|pch_ptrn_lines
parameter_list|()
block|{
return|return
name|p_ptrn_lines
return|;
block|}
end_function

begin_comment
comment|/* Return the probable line position in the new file of the first line. */
end_comment

begin_function
name|LINENUM
name|pch_newfirst
parameter_list|()
block|{
return|return
name|p_newfirst
return|;
block|}
end_function

begin_comment
comment|/* Return the number of lines in the replacement text including context. */
end_comment

begin_function
name|LINENUM
name|pch_repl_lines
parameter_list|()
block|{
return|return
name|p_repl_lines
return|;
block|}
end_function

begin_comment
comment|/* Return the number of lines in the whole hunk. */
end_comment

begin_function
name|LINENUM
name|pch_end
parameter_list|()
block|{
return|return
name|p_end
return|;
block|}
end_function

begin_comment
comment|/* Return the number of context lines before the first changed line. */
end_comment

begin_function
name|LINENUM
name|pch_prefix_context
parameter_list|()
block|{
return|return
name|p_prefix_context
return|;
block|}
end_function

begin_comment
comment|/* Return the number of context lines after the last changed line. */
end_comment

begin_function
name|LINENUM
name|pch_suffix_context
parameter_list|()
block|{
return|return
name|p_suffix_context
return|;
block|}
end_function

begin_comment
comment|/* Return the length of a particular patch line. */
end_comment

begin_function
name|size_t
name|pch_line_len
parameter_list|(
name|line
parameter_list|)
name|LINENUM
name|line
decl_stmt|;
block|{
return|return
name|p_len
index|[
name|line
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the control character (+, -, *, !, etc) for a patch line. */
end_comment

begin_function
name|char
name|pch_char
parameter_list|(
name|line
parameter_list|)
name|LINENUM
name|line
decl_stmt|;
block|{
return|return
name|p_Char
index|[
name|line
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to a particular patch line. */
end_comment

begin_function
name|char
modifier|*
name|pfetch
parameter_list|(
name|line
parameter_list|)
name|LINENUM
name|line
decl_stmt|;
block|{
return|return
name|p_line
index|[
name|line
index|]
return|;
block|}
end_function

begin_comment
comment|/* Output a patch line.  */
end_comment

begin_function
name|bool
name|pch_write_line
parameter_list|(
name|line
parameter_list|,
name|file
parameter_list|)
name|LINENUM
name|line
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|bool
name|after_newline
init|=
name|p_line
index|[
name|line
index|]
index|[
name|p_len
index|[
name|line
index|]
operator|-
literal|1
index|]
operator|==
literal|'\n'
decl_stmt|;
if|if
condition|(
operator|!
name|fwrite
argument_list|(
name|p_line
index|[
name|line
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_line
index|[
name|line
index|]
argument_list|)
argument_list|,
name|p_len
index|[
name|line
index|]
argument_list|,
name|file
argument_list|)
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
return|return
name|after_newline
return|;
block|}
end_function

begin_comment
comment|/* Return where in the patch file this hunk began, for error messages. */
end_comment

begin_function
name|LINENUM
name|pch_hunk_beg
parameter_list|()
block|{
return|return
name|p_hunk_beg
return|;
block|}
end_function

begin_comment
comment|/* Apply an ed script by feeding ed itself. */
end_comment

begin_function
name|void
name|do_ed_script
parameter_list|(
name|ofp
parameter_list|)
name|FILE
modifier|*
name|ofp
decl_stmt|;
block|{
specifier|static
name|char
specifier|const
name|ed_program
index|[]
init|=
name|ed_PROGRAM
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|file_offset
name|beginning_of_this_line
decl_stmt|;
specifier|register
name|bool
name|this_line_is_command
init|=
name|FALSE
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|pipefp
init|=
literal|0
decl_stmt|;
specifier|register
name|size_t
name|chars_read
decl_stmt|;
if|if
condition|(
operator|!
name|skip_rest_of_patch
condition|)
block|{
name|assert
argument_list|(
operator|!
name|inerrno
argument_list|)
expr_stmt|;
name|copy_file
argument_list|(
name|inname
argument_list|,
name|TMPOUTNAME
argument_list|,
name|instat
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s%s"
argument_list|,
name|ed_program
argument_list|,
name|verbosity
operator|==
name|VERBOSE
condition|?
literal|""
else|:
literal|"- "
argument_list|,
name|TMPOUTNAME
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|pipefp
operator|=
name|popen
argument_list|(
name|buf
argument_list|,
name|binary_transput
condition|?
literal|"wb"
else|:
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pipefp
condition|)
name|pfatal
argument_list|(
literal|"can't open pipe to `%s'"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|beginning_of_this_line
operator|=
name|file_tell
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|chars_read
operator|=
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|chars_read
condition|)
block|{
name|next_intuit_at
argument_list|(
name|beginning_of_this_line
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|t
operator|=
name|buf
init|;
name|ISDIGIT
argument_list|(
operator|*
name|t
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|','
condition|;
name|t
operator|++
control|)
continue|continue;
name|this_line_is_command
operator|=
operator|(
name|ISDIGIT
argument_list|(
operator|*
name|buf
argument_list|)
operator|&&
operator|(
operator|*
name|t
operator|==
literal|'d'
operator|||
operator|*
name|t
operator|==
literal|'c'
operator|||
operator|*
name|t
operator|==
literal|'a'
operator|||
operator|*
name|t
operator|==
literal|'i'
operator|||
operator|*
name|t
operator|==
literal|'s'
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|this_line_is_command
condition|)
block|{
if|if
condition|(
name|pipefp
condition|)
if|if
condition|(
operator|!
name|fwrite
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
expr|*
name|buf
argument_list|,
name|chars_read
argument_list|,
name|pipefp
argument_list|)
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|!=
literal|'d'
operator|&&
operator|*
name|t
operator|!=
literal|'s'
condition|)
block|{
while|while
condition|(
operator|(
name|chars_read
operator|=
name|get_line
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pipefp
condition|)
if|if
condition|(
operator|!
name|fwrite
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
expr|*
name|buf
argument_list|,
name|chars_read
argument_list|,
name|pipefp
argument_list|)
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
name|chars_read
operator|==
literal|2
operator|&&
name|strEQ
argument_list|(
name|buf
argument_list|,
literal|".\n"
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
else|else
block|{
name|next_intuit_at
argument_list|(
name|beginning_of_this_line
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|pipefp
condition|)
return|return;
if|if
condition|(
name|fwrite
argument_list|(
literal|"w\nq\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|,
name|pipefp
argument_list|)
operator|==
literal|0
operator|||
name|fflush
argument_list|(
name|pipefp
argument_list|)
operator|!=
literal|0
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
name|pclose
argument_list|(
name|pipefp
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s FAILED"
argument_list|,
name|ed_program
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofp
condition|)
block|{
name|FILE
modifier|*
name|ifp
init|=
name|fopen
argument_list|(
name|TMPOUTNAME
argument_list|,
name|binary_transput
condition|?
literal|"rb"
else|:
literal|"r"
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|ifp
condition|)
name|pfatal
argument_list|(
literal|"can't open `%s'"
argument_list|,
name|TMPOUTNAME
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|ifp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
name|putc
argument_list|(
name|c
argument_list|,
name|ofp
argument_list|)
operator|==
name|EOF
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|ifp
argument_list|)
operator|||
name|fclose
argument_list|(
name|ifp
argument_list|)
operator|!=
literal|0
condition|)
name|read_fatal
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

