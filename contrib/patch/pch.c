begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* reading patches */
end_comment

begin_comment
comment|/* $Id: pch.c,v 1.23 1997/06/17 06:52:12 eggert Exp $ */
end_comment

begin_comment
comment|/* Copyright 1986, 1987, 1988 Larry Wall Copyright 1990, 1991, 1992, 1993, 1997 Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_define
define|#
directive|define
name|XTERN
value|extern
end_define

begin_include
include|#
directive|include
file|<common.h>
end_include

begin_include
include|#
directive|include
file|<backupfile.h>
end_include

begin_include
include|#
directive|include
file|<inp.h>
end_include

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_undef
undef|#
directive|undef
name|XTERN
end_undef

begin_define
define|#
directive|define
name|XTERN
end_define

begin_include
include|#
directive|include
file|<pch.h>
end_include

begin_define
define|#
directive|define
name|INITHUNKMAX
value|125
end_define

begin_comment
comment|/* initial dynamic allocation size */
end_comment

begin_comment
comment|/* Patch (diff listing) abstract type. */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|pfp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* patch file pointer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_says_nonexistent
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* [0] for old file, [1] for new; 		value is 0 for nonempty, 1 for empty, 2 for nonexistent */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|p_timestamp
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* timestamps in patch headers */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|p_filesize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of the patch file */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_first
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1st line number */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_newfirst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1st line number of replacement */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_ptrn_lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # lines in pattern */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_repl_lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # lines in replacement text */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_end
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last line in hunk */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max allowed value of p_end */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_prefix_context
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of prefix context lines */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_suffix_context
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of suffix context lines */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_input_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current line # from patch file */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|p_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the text of the hunk */
end_comment

begin_decl_stmt
specifier|static
name|size_t
modifier|*
name|p_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line length including \n if any */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_Char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* +, -, and ! */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|hunkmax
init|=
name|INITHUNKMAX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of above arrays */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_indent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indent to patch */
end_comment

begin_decl_stmt
specifier|static
name|file_offset
name|p_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where to intuit this time */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_bline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line # of p_base */
end_comment

begin_decl_stmt
specifier|static
name|file_offset
name|p_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where intuit found a patch */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_sline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* and the line number for it */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_hunk_beg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line number of current hunk */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_efake
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of faked up lines--don't free */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_bfake
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* beg of faked up lines */
end_comment

begin_enum
enum|enum
name|nametype
block|{
name|OLD
block|,
name|NEW
block|,
name|INDEX
block|,
name|NONE
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|diff
name|intuit_diff_type
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|nametype
name|best_name
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
specifier|const
operator|*
operator|,
name|int
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prefix_components
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|pget_line
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|get_line
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|incomplete_line
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|grow_hunkmax
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|malformed
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|next_intuit_at
name|PARAMS
argument_list|(
operator|(
name|file_offset
operator|,
name|LINENUM
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|skip_to
name|PARAMS
argument_list|(
operator|(
name|file_offset
operator|,
name|LINENUM
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prepare to look for the next patch in the patch file. */
end_comment

begin_function
name|void
name|re_patch
parameter_list|()
block|{
name|p_first
operator|=
literal|0
expr_stmt|;
name|p_newfirst
operator|=
literal|0
expr_stmt|;
name|p_ptrn_lines
operator|=
literal|0
expr_stmt|;
name|p_repl_lines
operator|=
literal|0
expr_stmt|;
name|p_end
operator|=
operator|-
literal|1
expr_stmt|;
name|p_max
operator|=
literal|0
expr_stmt|;
name|p_indent
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open the patch file at the beginning of time. */
end_comment

begin_function
name|void
name|open_patch_file
parameter_list|(
name|filename
parameter_list|)
name|char
specifier|const
modifier|*
name|filename
decl_stmt|;
block|{
name|file_offset
name|file_pos
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
operator|!
name|filename
operator|||
operator|!
operator|*
name|filename
operator|||
name|strEQ
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|file_offset
name|stdin_pos
decl_stmt|;
if|#
directive|if
name|HAVE_SETMODE
if|if
condition|(
name|binary_transput
condition|)
block|{
if|if
condition|(
name|isatty
argument_list|(
name|STDIN_FILENO
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"cannot read binary data from tty on this platform"
argument_list|)
expr_stmt|;
name|setmode
argument_list|(
name|STDIN_FILENO
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fstat
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal
argument_list|(
literal|"fstat"
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|&&
operator|(
name|stdin_pos
operator|=
name|file_tell
argument_list|(
name|stdin
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|pfp
operator|=
name|stdin
expr_stmt|;
name|file_pos
operator|=
name|stdin_pos
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|charsread
decl_stmt|;
name|pfp
operator|=
name|fopen
argument_list|(
name|TMPPATNAME
argument_list|,
literal|"w+b"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pfp
condition|)
name|pfatal
argument_list|(
literal|"can't create `%s'"
argument_list|,
name|TMPPATNAME
argument_list|)
expr_stmt|;
for|for
control|(
name|st
operator|.
name|st_size
operator|=
literal|0
init|;
operator|(
name|charsread
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|bufsize
argument_list|,
name|stdin
argument_list|)
operator|)
operator|!=
literal|0
condition|;
name|st
operator|.
name|st_size
operator|+=
name|charsread
control|)
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|charsread
argument_list|,
name|pfp
argument_list|)
operator|!=
name|charsread
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdin
argument_list|)
operator|!=
literal|0
condition|)
name|read_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|pfp
argument_list|)
operator|!=
literal|0
operator|||
name|file_seek
argument_list|(
name|pfp
argument_list|,
operator|(
name|file_offset
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|pfp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
name|binary_transput
condition|?
literal|"rb"
else|:
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pfp
condition|)
name|pfatal
argument_list|(
literal|"can't open patch file `%s'"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|pfp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal
argument_list|(
literal|"fstat"
argument_list|)
expr_stmt|;
block|}
name|p_filesize
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
name|next_intuit_at
argument_list|(
name|file_pos
argument_list|,
operator|(
name|LINENUM
operator|)
literal|1
argument_list|)
expr_stmt|;
name|set_hunkmax
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make sure our dynamically realloced tables are malloced to begin with. */
end_comment

begin_function
name|void
name|set_hunkmax
parameter_list|()
block|{
if|if
condition|(
operator|!
name|p_line
condition|)
name|p_line
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|hunkmax
operator|*
sizeof|sizeof
expr|*
name|p_line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_len
condition|)
name|p_len
operator|=
operator|(
name|size_t
operator|*
operator|)
name|malloc
argument_list|(
name|hunkmax
operator|*
sizeof|sizeof
expr|*
name|p_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Char
condition|)
name|p_Char
operator|=
name|malloc
argument_list|(
name|hunkmax
operator|*
sizeof|sizeof
expr|*
name|p_Char
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enlarge the arrays containing the current hunk of patch. */
end_comment

begin_function
specifier|static
name|bool
name|grow_hunkmax
parameter_list|()
block|{
name|hunkmax
operator|*=
literal|2
expr_stmt|;
name|assert
argument_list|(
name|p_line
operator|&&
name|p_len
operator|&&
name|p_Char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_line
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|p_line
argument_list|,
name|hunkmax
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|p_line
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|p_len
operator|=
operator|(
name|size_t
operator|*
operator|)
name|realloc
argument_list|(
name|p_len
argument_list|,
name|hunkmax
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|p_len
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|p_Char
operator|=
name|realloc
argument_list|(
name|p_Char
argument_list|,
name|hunkmax
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|p_Char
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|using_plan_a
condition|)
name|memory_fatal
argument_list|()
expr_stmt|;
comment|/* Don't free previous values of p_line etc.,        since some broken implementations free them for us.        Whatever is null will be allocated again from within plan_a (),        of all places.  */
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* True if the remainder of the patch file contains a diff of some sort. */
end_comment

begin_function
name|bool
name|there_is_another_patch
parameter_list|()
block|{
if|if
condition|(
name|p_base
operator|!=
literal|0
operator|&&
name|p_base
operator|>=
name|p_filesize
condition|)
block|{
if|if
condition|(
name|verbosity
operator|==
name|VERBOSE
condition|)
name|say
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|verbosity
operator|==
name|VERBOSE
condition|)
name|say
argument_list|(
literal|"Hmm..."
argument_list|)
expr_stmt|;
name|diff_type
operator|=
name|intuit_diff_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|diff_type
operator|==
name|NO_DIFF
condition|)
block|{
if|if
condition|(
name|verbosity
operator|==
name|VERBOSE
condition|)
name|say
argument_list|(
name|p_base
condition|?
literal|"  Ignoring the trailing garbage.\ndone\n"
else|:
literal|"  I can't seem to find a patch in there anywhere.\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|skip_rest_of_patch
condition|)
block|{
name|Fseek
argument_list|(
name|pfp
argument_list|,
name|p_start
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|p_input_line
operator|=
name|p_sline
operator|-
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|verbosity
operator|==
name|VERBOSE
condition|)
name|say
argument_list|(
literal|"  %sooks like %s to me...\n"
argument_list|,
operator|(
name|p_base
operator|==
literal|0
condition|?
literal|"L"
else|:
literal|"The next patch l"
operator|)
argument_list|,
name|diff_type
operator|==
name|UNI_DIFF
condition|?
literal|"a unified diff"
else|:
name|diff_type
operator|==
name|CONTEXT_DIFF
condition|?
literal|"a context diff"
else|:
name|diff_type
operator|==
name|NEW_CONTEXT_DIFF
condition|?
literal|"a new-style context diff"
else|:
name|diff_type
operator|==
name|NORMAL_DIFF
condition|?
literal|"a normal diff"
else|:
literal|"an ed script"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|!=
name|SILENT
condition|)
block|{
if|if
condition|(
name|p_indent
condition|)
name|say
argument_list|(
literal|"(Patch is indented %d space%s.)\n"
argument_list|,
name|p_indent
argument_list|,
name|p_indent
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inname
condition|)
name|say
argument_list|(
literal|"can't find file to patch at input line %ld\n"
argument_list|,
name|p_sline
argument_list|)
expr_stmt|;
block|}
name|skip_to
argument_list|(
name|p_start
argument_list|,
name|p_sline
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|inname
condition|)
block|{
if|if
condition|(
name|force
operator|||
name|batch
condition|)
block|{
name|say
argument_list|(
literal|"No file to patch.  Skipping patch.\n"
argument_list|)
expr_stmt|;
name|skip_rest_of_patch
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|ask
argument_list|(
literal|"File to patch: "
argument_list|)
expr_stmt|;
name|inname
operator|=
name|fetchname
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|inname
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|inname
argument_list|,
operator|&
name|instat
argument_list|)
operator|==
literal|0
condition|)
block|{
name|inerrno
operator|=
literal|0
expr_stmt|;
name|invc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|perror
argument_list|(
name|inname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inname
argument_list|)
expr_stmt|;
name|inname
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|inname
condition|)
block|{
name|ask
argument_list|(
literal|"Skip this patch? [y] "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'n'
condition|)
block|{
if|if
condition|(
name|verbosity
operator|!=
name|SILENT
condition|)
name|say
argument_list|(
literal|"Skipping patch.\n"
argument_list|)
expr_stmt|;
name|skip_rest_of_patch
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Determine what kind of diff is in the remaining part of the patch file. */
end_comment

begin_function
specifier|static
name|enum
name|diff
name|intuit_diff_type
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|indent
decl_stmt|;
specifier|register
name|file_offset
name|this_line
init|=
literal|0
decl_stmt|;
specifier|register
name|file_offset
name|previous_line
decl_stmt|;
specifier|register
name|file_offset
name|first_command_line
init|=
operator|-
literal|1
decl_stmt|;
name|LINENUM
name|fcl_line
init|=
literal|0
decl_stmt|;
comment|/* Pacify `gcc -W'.  */
specifier|register
name|bool
name|last_line_was_command
init|=
name|FALSE
decl_stmt|;
specifier|register
name|bool
name|this_is_a_command
init|=
name|FALSE
decl_stmt|;
specifier|register
name|bool
name|stars_last_line
init|=
name|FALSE
decl_stmt|;
specifier|register
name|bool
name|stars_this_line
init|=
name|FALSE
decl_stmt|;
name|enum
name|nametype
name|i
decl_stmt|;
name|char
modifier|*
name|name
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|stat
name|st
index|[
literal|3
index|]
decl_stmt|;
name|int
name|stat_errno
index|[
literal|3
index|]
decl_stmt|;
name|int
name|version_controlled
index|[
literal|3
index|]
decl_stmt|;
specifier|register
name|enum
name|diff
name|retval
decl_stmt|;
name|name
index|[
name|OLD
index|]
operator|=
name|name
index|[
name|NEW
index|]
operator|=
name|name
index|[
name|INDEX
index|]
operator|=
literal|0
expr_stmt|;
name|version_controlled
index|[
name|OLD
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|version_controlled
index|[
name|NEW
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|version_controlled
index|[
name|INDEX
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|p_timestamp
index|[
name|OLD
index|]
operator|=
name|p_timestamp
index|[
name|NEW
index|]
operator|=
operator|(
name|time_t
operator|)
operator|-
literal|1
expr_stmt|;
name|p_says_nonexistent
index|[
name|OLD
index|]
operator|=
name|p_says_nonexistent
index|[
name|NEW
index|]
operator|=
literal|0
expr_stmt|;
name|Fseek
argument_list|(
name|pfp
argument_list|,
name|p_base
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|p_input_line
operator|=
name|p_bline
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|previous_line
operator|=
name|this_line
expr_stmt|;
name|last_line_was_command
operator|=
name|this_is_a_command
expr_stmt|;
name|stars_last_line
operator|=
name|stars_this_line
expr_stmt|;
name|this_line
operator|=
name|file_tell
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|indent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|pget_line
argument_list|(
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|first_command_line
operator|>=
literal|0
condition|)
block|{
comment|/* nothing but deletes!? */
name|p_start
operator|=
name|first_command_line
expr_stmt|;
name|p_sline
operator|=
name|fcl_line
expr_stmt|;
name|retval
operator|=
name|ED_DIFF
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
else|else
block|{
name|p_start
operator|=
name|this_line
expr_stmt|;
name|p_sline
operator|=
name|p_input_line
expr_stmt|;
name|retval
operator|=
name|NO_DIFF
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
block|}
for|for
control|(
name|s
operator|=
name|buf
init|;
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
operator|||
operator|*
name|s
operator|==
literal|'X'
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|indent
operator|=
operator|(
name|indent
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
else|else
name|indent
operator|++
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
name|s
init|;
name|ISDIGIT
argument_list|(
operator|*
name|t
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|','
condition|;
name|t
operator|++
control|)
continue|continue;
name|this_is_a_command
operator|=
operator|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|(
operator|*
name|t
operator|==
literal|'d'
operator|||
operator|*
name|t
operator|==
literal|'c'
operator|||
operator|*
name|t
operator|==
literal|'a'
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|first_command_line
operator|<
literal|0
operator|&&
name|this_is_a_command
condition|)
block|{
name|first_command_line
operator|=
name|this_line
expr_stmt|;
name|fcl_line
operator|=
name|p_input_line
expr_stmt|;
name|p_indent
operator|=
name|indent
expr_stmt|;
comment|/* assume this for now */
block|}
if|if
condition|(
operator|!
name|stars_last_line
operator|&&
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"*** "
argument_list|,
literal|4
argument_list|)
condition|)
name|name
index|[
name|OLD
index|]
operator|=
name|fetchname
argument_list|(
name|s
operator|+
literal|4
argument_list|,
name|strippath
argument_list|,
operator|&
name|p_timestamp
index|[
name|OLD
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"--- "
argument_list|,
literal|4
argument_list|)
condition|)
name|name
index|[
name|NEW
index|]
operator|=
name|fetchname
argument_list|(
name|s
operator|+
literal|4
argument_list|,
name|strippath
argument_list|,
operator|&
name|p_timestamp
index|[
name|NEW
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"+++ "
argument_list|,
literal|4
argument_list|)
condition|)
comment|/* Swap with NEW below.  */
name|name
index|[
name|OLD
index|]
operator|=
name|fetchname
argument_list|(
name|s
operator|+
literal|4
argument_list|,
name|strippath
argument_list|,
operator|&
name|p_timestamp
index|[
name|OLD
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"Index:"
argument_list|,
literal|6
argument_list|)
condition|)
name|name
index|[
name|INDEX
index|]
operator|=
name|fetchname
argument_list|(
name|s
operator|+
literal|6
argument_list|,
name|strippath
argument_list|,
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"Prereq:"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
for|for
control|(
name|t
operator|=
name|s
operator|+
literal|7
init|;
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
continue|continue;
name|revision
operator|=
name|t
expr_stmt|;
for|for
control|(
name|t
operator|=
name|revision
init|;
operator|*
name|t
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
continue|continue;
if|if
condition|(
name|t
operator|==
name|revision
condition|)
name|revision
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|char
name|oldc
init|=
operator|*
name|t
decl_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|revision
operator|=
name|savestr
argument_list|(
name|revision
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
name|oldc
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|diff_type
operator|==
name|NO_DIFF
operator|||
name|diff_type
operator|==
name|ED_DIFF
operator|)
operator|&&
name|first_command_line
operator|>=
literal|0
operator|&&
name|strEQ
argument_list|(
name|s
argument_list|,
literal|".\n"
argument_list|)
condition|)
block|{
name|p_indent
operator|=
name|indent
expr_stmt|;
name|p_start
operator|=
name|first_command_line
expr_stmt|;
name|p_sline
operator|=
name|fcl_line
expr_stmt|;
name|retval
operator|=
name|ED_DIFF
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
if|if
condition|(
operator|(
name|diff_type
operator|==
name|NO_DIFF
operator|||
name|diff_type
operator|==
name|UNI_DIFF
operator|)
operator|&&
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"@@ -"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
comment|/* `name' and `p_timestamp' are backwards; swap them.  */
name|time_t
name|ti
init|=
name|p_timestamp
index|[
name|OLD
index|]
decl_stmt|;
name|p_timestamp
index|[
name|OLD
index|]
operator|=
name|p_timestamp
index|[
name|NEW
index|]
expr_stmt|;
name|p_timestamp
index|[
name|NEW
index|]
operator|=
name|ti
expr_stmt|;
name|t
operator|=
name|name
index|[
name|OLD
index|]
expr_stmt|;
name|name
index|[
name|OLD
index|]
operator|=
name|name
index|[
name|NEW
index|]
expr_stmt|;
name|name
index|[
name|NEW
index|]
operator|=
name|t
expr_stmt|;
name|s
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|atol
argument_list|(
name|s
argument_list|)
condition|)
name|p_says_nonexistent
index|[
name|OLD
index|]
operator|=
literal|1
operator|+
operator|!
name|p_timestamp
index|[
name|OLD
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|atol
argument_list|(
name|s
argument_list|)
condition|)
name|p_says_nonexistent
index|[
name|NEW
index|]
operator|=
literal|1
operator|+
operator|!
name|p_timestamp
index|[
name|NEW
index|]
expr_stmt|;
name|p_indent
operator|=
name|indent
expr_stmt|;
name|p_start
operator|=
name|this_line
expr_stmt|;
name|p_sline
operator|=
name|p_input_line
expr_stmt|;
name|retval
operator|=
name|UNI_DIFF
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|name
index|[
name|OLD
index|]
operator|||
operator|!
name|p_timestamp
index|[
name|OLD
index|]
operator|)
operator|&&
operator|(
name|name
index|[
name|NEW
index|]
operator|||
operator|!
name|p_timestamp
index|[
name|NEW
index|]
operator|)
operator|)
condition|)
name|say
argument_list|(
literal|"missing header for unified diff at line %ld of patch\n"
argument_list|,
name|p_sline
argument_list|)
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
name|stars_this_line
operator|=
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"********"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|diff_type
operator|==
name|NO_DIFF
operator|||
name|diff_type
operator|==
name|CONTEXT_DIFF
operator|||
name|diff_type
operator|==
name|NEW_CONTEXT_DIFF
operator|)
operator|&&
name|stars_last_line
operator|&&
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"*** "
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|s
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|atol
argument_list|(
name|s
argument_list|)
condition|)
name|p_says_nonexistent
index|[
name|OLD
index|]
operator|=
literal|1
operator|+
operator|!
name|p_timestamp
index|[
name|OLD
index|]
expr_stmt|;
comment|/* if this is a new context diff the character just before */
comment|/* the newline is a '*'. */
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
name|p_indent
operator|=
name|indent
expr_stmt|;
name|p_start
operator|=
name|previous_line
expr_stmt|;
name|p_sline
operator|=
name|p_input_line
operator|-
literal|1
expr_stmt|;
name|retval
operator|=
operator|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|'*'
condition|?
name|NEW_CONTEXT_DIFF
else|:
name|CONTEXT_DIFF
operator|)
expr_stmt|;
block|{
comment|/* Scan the first hunk to see whether the file contents 		 appear to have been deleted.  */
name|file_offset
name|saved_p_base
init|=
name|p_base
decl_stmt|;
name|LINENUM
name|saved_p_bline
init|=
name|p_bline
decl_stmt|;
name|Fseek
argument_list|(
name|pfp
argument_list|,
name|previous_line
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|p_input_line
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|another_hunk
argument_list|(
name|retval
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|p_repl_lines
operator|&&
name|p_newfirst
operator|==
literal|1
condition|)
name|p_says_nonexistent
index|[
name|NEW
index|]
operator|=
literal|1
operator|+
operator|!
name|p_timestamp
index|[
name|NEW
index|]
expr_stmt|;
name|next_intuit_at
argument_list|(
name|saved_p_base
argument_list|,
name|saved_p_bline
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
name|name
index|[
name|OLD
index|]
operator|||
operator|!
name|p_timestamp
index|[
name|OLD
index|]
operator|)
operator|&&
operator|(
name|name
index|[
name|NEW
index|]
operator|||
operator|!
name|p_timestamp
index|[
name|NEW
index|]
operator|)
operator|)
condition|)
name|say
argument_list|(
literal|"missing header for context diff at line %ld of patch\n"
argument_list|,
name|p_sline
argument_list|)
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
if|if
condition|(
operator|(
name|diff_type
operator|==
name|NO_DIFF
operator|||
name|diff_type
operator|==
name|NORMAL_DIFF
operator|)
operator|&&
name|last_line_was_command
operator|&&
operator|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"< "
argument_list|,
literal|2
argument_list|)
operator|||
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"> "
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
block|{
name|p_start
operator|=
name|previous_line
expr_stmt|;
name|p_sline
operator|=
name|p_input_line
operator|-
literal|1
expr_stmt|;
name|p_indent
operator|=
name|indent
expr_stmt|;
name|retval
operator|=
name|NORMAL_DIFF
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
block|}
name|scan_exit
label|:
comment|/* To intuit `inname', the name of the file to patch,        use the algorithm specified by POSIX 1003.2b/D11 section 5.22.7.2        (with some modifications if posixly_correct is zero):         - Take the old and new names from the context header if present, 	 and take the index name from the `Index:' line if present and 	 if either the old and new names are both absent 	 or posixly_correct is nonzero. 	 Consider the file names to be in the order (old, new, index).        - If some named files exist, use the first one if posixly_correct 	 is nonzero, the best one otherwise.        - If patch_get is nonzero, and no named files exist, 	 but an RCS or SCCS master file exists, 	 use the first named file with an RCS or SCCS master.        - If no named files exist, no RCS or SCCS master was found, 	 some names are given, posixly_correct is zero, 	 and the patch appears to create a file, then use the best name 	 requiring the creation of the fewest directories.        - Otherwise, report failure by setting `inname' to 0; 	 this causes our invoker to ask the user for a file name.  */
name|i
operator|=
name|NONE
expr_stmt|;
if|if
condition|(
operator|!
name|inname
condition|)
block|{
name|enum
name|nametype
name|i0
init|=
name|NONE
decl_stmt|;
if|if
condition|(
operator|!
name|posixly_correct
operator|&&
operator|(
name|name
index|[
name|OLD
index|]
operator|||
name|name
index|[
name|NEW
index|]
operator|)
operator|&&
name|name
index|[
name|INDEX
index|]
condition|)
block|{
name|free
argument_list|(
name|name
index|[
name|INDEX
index|]
argument_list|)
expr_stmt|;
name|name
index|[
name|INDEX
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|OLD
init|;
name|i
operator|<=
name|INDEX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|i0
operator|!=
name|NONE
operator|&&
name|strcmp
argument_list|(
name|name
index|[
name|i0
index|]
argument_list|,
name|name
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* It's the same name as before; reuse stat results.  */
name|stat_errno
index|[
name|i
index|]
operator|=
name|stat_errno
index|[
name|i0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|stat_errno
index|[
name|i
index|]
condition|)
name|st
index|[
name|i
index|]
operator|=
name|st
index|[
name|i0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
operator|&
name|st
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
name|stat_errno
index|[
name|i
index|]
operator|=
name|errno
expr_stmt|;
else|else
block|{
name|stat_errno
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|posixly_correct
condition|)
break|break;
block|}
name|i0
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|posixly_correct
condition|)
block|{
name|i
operator|=
name|best_name
argument_list|(
name|name
argument_list|,
name|stat_errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NONE
operator|&&
name|patch_get
condition|)
block|{
name|enum
name|nametype
name|nope
init|=
name|NONE
decl_stmt|;
for|for
control|(
name|i
operator|=
name|OLD
init|;
name|i
operator|<=
name|INDEX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
index|[
name|i
index|]
condition|)
block|{
name|char
specifier|const
modifier|*
name|cs
decl_stmt|;
name|char
modifier|*
name|getbuf
decl_stmt|;
name|char
modifier|*
name|diffbuf
decl_stmt|;
name|int
name|readonly
init|=
name|outfile
operator|&&
name|strcmp
argument_list|(
name|outfile
argument_list|,
name|name
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|nope
operator|==
name|NONE
operator|||
name|strcmp
argument_list|(
name|name
index|[
name|nope
index|]
argument_list|,
name|name
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cs
operator|=
operator|(
name|version_controller
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
name|readonly
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|getbuf
argument_list|,
operator|&
name|diffbuf
argument_list|)
operator|)
expr_stmt|;
name|version_controlled
index|[
name|i
index|]
operator|=
operator|!
operator|!
name|cs
expr_stmt|;
if|if
condition|(
name|cs
condition|)
block|{
if|if
condition|(
name|version_get
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
name|cs
argument_list|,
literal|0
argument_list|,
name|readonly
argument_list|,
name|getbuf
argument_list|,
operator|&
name|st
index|[
name|i
index|]
argument_list|)
condition|)
name|stat_errno
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|version_controlled
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|getbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|diffbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stat_errno
index|[
name|i
index|]
condition|)
break|break;
block|}
block|}
name|nope
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_says_nonexistent
index|[
name|reverse
operator|^
operator|(
name|i
operator|==
name|NONE
operator|||
name|st
index|[
name|i
index|]
operator|.
name|st_size
operator|==
literal|0
operator|)
index|]
condition|)
block|{
name|assert
argument_list|(
name|i0
operator|!=
name|NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok_to_reverse
argument_list|(
literal|"The next patch%s would %s the file `%s',\nwhich %s!"
argument_list|,
name|reverse
condition|?
literal|", when reversed,"
else|:
literal|""
argument_list|,
operator|(
name|i
operator|==
name|NONE
condition|?
literal|"delete"
else|:
name|st
index|[
name|i
index|]
operator|.
name|st_size
operator|==
literal|0
condition|?
literal|"empty out"
else|:
literal|"create"
operator|)
argument_list|,
name|name
index|[
name|i
operator|==
name|NONE
operator|||
name|st
index|[
name|i
index|]
operator|.
name|st_size
operator|==
literal|0
condition|?
name|i0
else|:
name|i
index|]
argument_list|,
operator|(
name|i
operator|==
name|NONE
condition|?
literal|"does not exist"
else|:
name|st
index|[
name|i
index|]
operator|.
name|st_size
operator|==
literal|0
condition|?
literal|"is already empty"
else|:
literal|"already exists"
operator|)
argument_list|)
condition|)
name|reverse
operator|^=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|NONE
operator|&&
name|p_says_nonexistent
index|[
name|reverse
index|]
condition|)
block|{
name|int
name|newdirs
index|[
literal|3
index|]
decl_stmt|;
name|int
name|newdirs_min
init|=
name|INT_MAX
decl_stmt|;
name|int
name|distance_from_minimum
index|[
literal|3
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
name|OLD
init|;
name|i
operator|<=
name|INDEX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
index|[
name|i
index|]
condition|)
block|{
name|newdirs
index|[
name|i
index|]
operator|=
operator|(
name|prefix_components
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
operator|-
name|prefix_components
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|newdirs
index|[
name|i
index|]
operator|<
name|newdirs_min
condition|)
name|newdirs_min
operator|=
name|newdirs
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|OLD
init|;
name|i
operator|<=
name|INDEX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
index|[
name|i
index|]
condition|)
name|distance_from_minimum
index|[
name|i
index|]
operator|=
name|newdirs
index|[
name|i
index|]
operator|-
name|newdirs_min
expr_stmt|;
name|i
operator|=
name|best_name
argument_list|(
name|name
argument_list|,
name|distance_from_minimum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|==
name|NONE
condition|)
name|inerrno
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|inname
operator|=
name|name
index|[
name|i
index|]
expr_stmt|;
name|name
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|inerrno
operator|=
name|stat_errno
index|[
name|i
index|]
expr_stmt|;
name|invc
operator|=
name|version_controlled
index|[
name|i
index|]
expr_stmt|;
name|instat
operator|=
name|st
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|OLD
init|;
name|i
operator|<=
name|INDEX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Count the path name components in FILENAME's prefix.    If CHECKDIRS is nonzero, count only existing directories.  */
end_comment

begin_function
specifier|static
name|int
name|prefix_components
parameter_list|(
name|filename
parameter_list|,
name|checkdirs
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|checkdirs
decl_stmt|;
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|stat_buf
decl_stmt|;
name|int
name|stat_result
decl_stmt|;
name|char
modifier|*
name|f
init|=
name|filename
operator|+
name|FILESYSTEM_PREFIX_LEN
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|f
condition|)
while|while
condition|(
operator|*
operator|++
name|f
condition|)
if|if
condition|(
name|ISSLASH
argument_list|(
name|f
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|!
name|ISSLASH
argument_list|(
name|f
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|checkdirs
condition|)
block|{
operator|*
name|f
operator|=
literal|'\0'
expr_stmt|;
name|stat_result
operator|=
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|stat_buf
argument_list|)
expr_stmt|;
operator|*
name|f
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|stat_result
operator|==
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|stat_buf
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
break|break;
block|}
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Return the index of the best of NAME[OLD], NAME[NEW], and NAME[INDEX].    Ignore null names, and ignore NAME[i] if IGNORE[i] is nonzero.    Return NONE if all names are ignored.  */
end_comment

begin_function
specifier|static
name|enum
name|nametype
name|best_name
parameter_list|(
name|name
parameter_list|,
name|ignore
parameter_list|)
name|char
modifier|*
specifier|const
modifier|*
name|name
decl_stmt|;
name|int
specifier|const
modifier|*
name|ignore
decl_stmt|;
block|{
name|enum
name|nametype
name|i
decl_stmt|;
name|int
name|components
index|[
literal|3
index|]
decl_stmt|;
name|int
name|components_min
init|=
name|INT_MAX
decl_stmt|;
name|size_t
name|basename_len
index|[
literal|3
index|]
decl_stmt|;
name|size_t
name|basename_len_min
init|=
operator|(
name|size_t
operator|)
operator|-
literal|1
decl_stmt|;
name|size_t
name|len
index|[
literal|3
index|]
decl_stmt|;
name|size_t
name|len_min
init|=
operator|(
name|size_t
operator|)
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
name|OLD
init|;
name|i
operator|<=
name|INDEX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
index|[
name|i
index|]
operator|&&
operator|!
name|ignore
index|[
name|i
index|]
condition|)
block|{
comment|/* Take the names with the fewest prefix components.  */
name|components
index|[
name|i
index|]
operator|=
name|prefix_components
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|components_min
operator|<
name|components
index|[
name|i
index|]
condition|)
continue|continue;
name|components_min
operator|=
name|components
index|[
name|i
index|]
expr_stmt|;
comment|/* Of those, take the names with the shortest basename.  */
name|basename_len
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|base_name
argument_list|(
name|name
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|basename_len_min
operator|<
name|basename_len
index|[
name|i
index|]
condition|)
continue|continue;
name|basename_len_min
operator|=
name|basename_len
index|[
name|i
index|]
expr_stmt|;
comment|/* Of those, take the shortest names.  */
name|len
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len_min
operator|<
name|len
index|[
name|i
index|]
condition|)
continue|continue;
name|len_min
operator|=
name|len
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Of those, take the first name.  */
for|for
control|(
name|i
operator|=
name|OLD
init|;
name|i
operator|<=
name|INDEX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
index|[
name|i
index|]
operator|&&
operator|!
name|ignore
index|[
name|i
index|]
operator|&&
name|components
index|[
name|i
index|]
operator|==
name|components_min
operator|&&
name|basename_len
index|[
name|i
index|]
operator|==
name|basename_len_min
operator|&&
name|len
index|[
name|i
index|]
operator|==
name|len_min
condition|)
break|break;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Remember where this patch ends so we know where to start up again. */
end_comment

begin_function
specifier|static
name|void
name|next_intuit_at
parameter_list|(
name|file_pos
parameter_list|,
name|file_line
parameter_list|)
name|file_offset
name|file_pos
decl_stmt|;
name|LINENUM
name|file_line
decl_stmt|;
block|{
name|p_base
operator|=
name|file_pos
expr_stmt|;
name|p_bline
operator|=
name|file_line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Basically a verbose fseek() to the actual diff listing. */
end_comment

begin_function
specifier|static
name|void
name|skip_to
parameter_list|(
name|file_pos
parameter_list|,
name|file_line
parameter_list|)
name|file_offset
name|file_pos
decl_stmt|;
name|LINENUM
name|file_line
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|i
init|=
name|pfp
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|o
init|=
name|stdout
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|assert
argument_list|(
name|p_base
operator|<=
name|file_pos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|verbosity
operator|==
name|VERBOSE
operator|||
operator|!
name|inname
operator|)
operator|&&
name|p_base
operator|<
name|file_pos
condition|)
block|{
name|Fseek
argument_list|(
name|i
argument_list|,
name|p_base
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|say
argument_list|(
literal|"The text leading up to this was:\n--------------------------\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|file_tell
argument_list|(
name|i
argument_list|)
operator|<
name|file_pos
condition|)
block|{
name|putc
argument_list|(
literal|'|'
argument_list|,
name|o
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|i
argument_list|)
operator|)
operator|==
name|EOF
condition|)
name|read_fatal
argument_list|()
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
block|}
name|say
argument_list|(
literal|"--------------------------\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|Fseek
argument_list|(
name|i
argument_list|,
name|file_pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|p_input_line
operator|=
name|file_line
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make this a function for better debugging.  */
end_comment

begin_function
specifier|static
name|void
name|malformed
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"malformed patch at line %ld: %s"
argument_list|,
name|p_input_line
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* about as informative as "Syntax error" in C */
block|}
end_function

begin_comment
comment|/* 1 if there is more of the current diff listing to process;    0 if not; -1 if ran out of memory. */
end_comment

begin_function
name|int
name|another_hunk
parameter_list|(
name|difftype
parameter_list|,
name|rev
parameter_list|)
name|enum
name|diff
name|difftype
decl_stmt|;
name|int
name|rev
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|LINENUM
name|context
init|=
literal|0
decl_stmt|;
specifier|register
name|size_t
name|chars_read
decl_stmt|;
while|while
condition|(
name|p_end
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|p_end
operator|==
name|p_efake
condition|)
name|p_end
operator|=
name|p_bfake
expr_stmt|;
comment|/* don't free twice */
else|else
name|free
argument_list|(
name|p_line
index|[
name|p_end
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|--
expr_stmt|;
block|}
name|assert
argument_list|(
name|p_end
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_efake
operator|=
operator|-
literal|1
expr_stmt|;
name|p_max
operator|=
name|hunkmax
expr_stmt|;
comment|/* gets reduced when --- found */
if|if
condition|(
name|difftype
operator|==
name|CONTEXT_DIFF
operator|||
name|difftype
operator|==
name|NEW_CONTEXT_DIFF
condition|)
block|{
name|file_offset
name|line_beginning
init|=
name|file_tell
argument_list|(
name|pfp
argument_list|)
decl_stmt|;
comment|/* file pos of the current line */
name|LINENUM
name|repl_beginning
init|=
literal|0
decl_stmt|;
comment|/* index of --- line */
specifier|register
name|LINENUM
name|fillcnt
init|=
literal|0
decl_stmt|;
comment|/* #lines of missing ptrn or repl */
specifier|register
name|LINENUM
name|fillsrc
decl_stmt|;
comment|/* index of first line to copy */
specifier|register
name|LINENUM
name|filldst
decl_stmt|;
comment|/* index of first missing line */
name|bool
name|ptrn_spaces_eaten
init|=
name|FALSE
decl_stmt|;
comment|/* ptrn was slightly misformed */
name|bool
name|some_context
init|=
name|FALSE
decl_stmt|;
comment|/* (perhaps internal) context seen */
specifier|register
name|bool
name|repl_could_be_missing
init|=
name|TRUE
decl_stmt|;
name|bool
name|repl_missing
init|=
name|FALSE
decl_stmt|;
comment|/* we are now backtracking */
name|file_offset
name|repl_backtrack_position
init|=
literal|0
decl_stmt|;
comment|/* file pos of first repl line */
name|LINENUM
name|repl_patch_line
decl_stmt|;
comment|/* input line number for same */
name|LINENUM
name|repl_context
decl_stmt|;
comment|/* context for same */
name|LINENUM
name|ptrn_prefix_context
init|=
operator|-
literal|1
decl_stmt|;
comment|/* lines in pattern prefix context */
name|LINENUM
name|ptrn_suffix_context
init|=
operator|-
literal|1
decl_stmt|;
comment|/* lines in pattern suffix context */
name|LINENUM
name|repl_prefix_context
init|=
operator|-
literal|1
decl_stmt|;
comment|/* lines in replac. prefix context */
specifier|register
name|LINENUM
name|ptrn_copiable
init|=
literal|0
decl_stmt|;
comment|/* # of copiable lines in ptrn */
comment|/* Pacify `gcc -Wall'.  */
name|fillsrc
operator|=
name|filldst
operator|=
name|repl_patch_line
operator|=
name|repl_context
operator|=
literal|0
expr_stmt|;
name|chars_read
operator|=
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|chars_read
operator|<=
literal|8
operator|||
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"********"
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|next_intuit_at
argument_list|(
name|line_beginning
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
return|return
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
name|p_hunk_beg
operator|=
name|p_input_line
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|p_end
operator|<
name|p_max
condition|)
block|{
name|chars_read
operator|=
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|chars_read
condition|)
block|{
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
if|if
condition|(
name|p_max
operator|-
name|p_end
operator|<
literal|4
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"  \n"
argument_list|)
expr_stmt|;
comment|/* assume blank lines got chopped */
name|chars_read
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|fatal
argument_list|(
literal|"unexpected end of file in patch"
argument_list|)
expr_stmt|;
block|}
block|}
name|p_end
operator|++
expr_stmt|;
if|if
condition|(
name|p_end
operator|==
name|hunkmax
condition|)
name|fatal
argument_list|(
literal|"unterminated hunk starting at line %ld; giving up at line %ld: %s"
argument_list|,
name|pch_hunk_beg
argument_list|()
argument_list|,
name|p_input_line
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p_end
operator|<
name|hunkmax
argument_list|)
expr_stmt|;
name|p_Char
index|[
name|p_end
index|]
operator|=
operator|*
name|buf
expr_stmt|;
name|p_len
index|[
name|p_end
index|]
operator|=
literal|0
expr_stmt|;
name|p_line
index|[
name|p_end
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
literal|'*'
case|:
if|if
condition|(
name|strnEQ
argument_list|(
name|buf
argument_list|,
literal|"********"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
else|else
name|fatal
argument_list|(
literal|"unexpected end of hunk at line %ld"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_end
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|fatal
argument_list|(
literal|"unexpected `***' at line %ld: %s"
argument_list|,
name|p_input_line
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|context
operator|=
literal|0
expr_stmt|;
name|p_len
index|[
name|p_end
index|]
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
name|p_end
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|s
operator|=
name|buf
init|;
operator|*
name|s
operator|&&
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
continue|continue;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"0,0"
argument_list|,
literal|3
argument_list|)
condition|)
name|remove_prefix
argument_list|(
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|p_first
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|&&
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_ptrn_lines
operator|=
operator|(
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|s
argument_list|)
operator|)
operator|-
name|p_first
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_first
condition|)
name|p_ptrn_lines
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|p_ptrn_lines
operator|=
literal|0
expr_stmt|;
name|p_first
operator|=
literal|1
expr_stmt|;
block|}
name|p_max
operator|=
name|p_ptrn_lines
operator|+
literal|6
expr_stmt|;
comment|/* we need this much at least */
while|while
condition|(
name|p_max
operator|>=
name|hunkmax
condition|)
if|if
condition|(
operator|!
name|grow_hunkmax
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
name|p_max
operator|=
name|hunkmax
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|!=
literal|'-'
condition|)
goto|goto
name|change_line
goto|;
if|if
condition|(
name|ptrn_prefix_context
operator|==
operator|-
literal|1
condition|)
name|ptrn_prefix_context
operator|=
name|context
expr_stmt|;
name|ptrn_suffix_context
operator|=
name|context
expr_stmt|;
if|if
condition|(
name|repl_beginning
operator|||
operator|(
name|p_end
operator|!=
name|p_ptrn_lines
operator|+
literal|1
operator|+
operator|(
name|p_Char
index|[
name|p_end
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|p_end
operator|==
literal|1
condition|)
block|{
comment|/* `Old' lines were omitted.  Set up to fill 			   them in from `new' context lines.  */
name|p_end
operator|=
name|p_ptrn_lines
operator|+
literal|1
expr_stmt|;
name|ptrn_prefix_context
operator|=
name|ptrn_suffix_context
operator|=
operator|-
literal|1
expr_stmt|;
name|fillsrc
operator|=
name|p_end
operator|+
literal|1
expr_stmt|;
name|filldst
operator|=
literal|1
expr_stmt|;
name|fillcnt
operator|=
name|p_ptrn_lines
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|repl_beginning
condition|)
name|fatal
argument_list|(
literal|"%s `---' at line %ld; check line numbers at line %ld"
argument_list|,
operator|(
name|p_end
operator|<=
name|p_ptrn_lines
condition|?
literal|"Premature"
else|:
literal|"Overdue"
operator|)
argument_list|,
name|p_input_line
argument_list|,
name|p_hunk_beg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|repl_could_be_missing
condition|)
name|fatal
argument_list|(
literal|"duplicate `---' at line %ld; check line numbers at line %ld"
argument_list|,
name|p_input_line
argument_list|,
name|p_hunk_beg
operator|+
name|repl_beginning
argument_list|)
expr_stmt|;
else|else
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
block|}
name|repl_beginning
operator|=
name|p_end
expr_stmt|;
name|repl_backtrack_position
operator|=
name|file_tell
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|repl_patch_line
operator|=
name|p_input_line
expr_stmt|;
name|repl_context
operator|=
name|context
expr_stmt|;
name|p_len
index|[
name|p_end
index|]
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
name|p_end
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_Char
index|[
name|p_end
index|]
operator|=
literal|'='
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
init|;
operator|*
name|s
operator|&&
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
continue|continue;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_newfirst
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
do|do
block|{
if|if
condition|(
operator|!
operator|*
operator|++
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
name|p_repl_lines
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|s
argument_list|)
operator|-
name|p_newfirst
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_newfirst
condition|)
name|p_repl_lines
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|p_repl_lines
operator|=
literal|0
expr_stmt|;
name|p_newfirst
operator|=
literal|1
expr_stmt|;
block|}
name|p_max
operator|=
name|p_repl_lines
operator|+
name|p_end
expr_stmt|;
while|while
condition|(
name|p_max
operator|>=
name|hunkmax
condition|)
if|if
condition|(
operator|!
name|grow_hunkmax
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|p_repl_lines
operator|!=
name|ptrn_copiable
operator|&&
operator|(
name|p_prefix_context
operator|!=
literal|0
operator|||
name|context
operator|!=
literal|0
operator|||
name|p_repl_lines
operator|!=
literal|1
operator|)
condition|)
name|repl_could_be_missing
operator|=
name|FALSE
expr_stmt|;
name|context
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
case|case
literal|'!'
case|:
name|repl_could_be_missing
operator|=
name|FALSE
expr_stmt|;
name|change_line
label|:
name|s
operator|=
name|buf
operator|+
literal|1
expr_stmt|;
name|chars_read
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|&&
name|canonicalize
condition|)
block|{
name|strcpy
argument_list|(
name|s
argument_list|,
literal|" \n"
argument_list|)
expr_stmt|;
name|chars_read
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|chars_read
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
if|if
condition|(
operator|!
name|repl_beginning
condition|)
block|{
if|if
condition|(
name|ptrn_prefix_context
operator|==
operator|-
literal|1
condition|)
name|ptrn_prefix_context
operator|=
name|context
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|repl_prefix_context
operator|==
operator|-
literal|1
condition|)
name|repl_prefix_context
operator|=
name|context
expr_stmt|;
block|}
name|chars_read
operator|-=
operator|(
literal|1
operator|<
name|chars_read
operator|&&
name|p_end
operator|==
operator|(
name|repl_beginning
condition|?
name|p_max
else|:
name|p_ptrn_lines
operator|)
operator|&&
name|incomplete_line
argument_list|()
operator|)
expr_stmt|;
name|p_len
index|[
name|p_end
index|]
operator|=
name|chars_read
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
name|p_end
index|]
operator|=
name|savebuf
argument_list|(
name|s
argument_list|,
name|chars_read
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|context
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
comment|/* assume spaces got eaten */
name|s
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\t'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|chars_read
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
operator|&&
operator|(
operator|!
name|ptrn_spaces_eaten
operator|||
name|difftype
operator|==
name|NEW_CONTEXT_DIFF
operator|)
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|chars_read
operator|-=
operator|(
literal|1
operator|<
name|chars_read
operator|&&
name|p_end
operator|==
operator|(
name|repl_beginning
condition|?
name|p_max
else|:
name|p_ptrn_lines
operator|)
operator|&&
name|incomplete_line
argument_list|()
operator|)
expr_stmt|;
name|p_len
index|[
name|p_end
index|]
operator|=
name|chars_read
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
name|p_end
index|]
operator|=
name|savebuf
argument_list|(
name|buf
argument_list|,
name|chars_read
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|p_end
operator|!=
name|p_ptrn_lines
operator|+
literal|1
condition|)
block|{
name|ptrn_spaces_eaten
operator||=
operator|(
name|repl_beginning
operator|!=
literal|0
operator|)
expr_stmt|;
name|some_context
operator|=
name|TRUE
expr_stmt|;
name|context
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|repl_beginning
condition|)
name|ptrn_copiable
operator|++
expr_stmt|;
name|p_Char
index|[
name|p_end
index|]
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
case|case
literal|' '
case|:
name|s
operator|=
name|buf
operator|+
literal|1
expr_stmt|;
name|chars_read
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|&&
name|canonicalize
condition|)
block|{
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|chars_read
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|chars_read
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|some_context
operator|=
name|TRUE
expr_stmt|;
name|context
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|repl_beginning
condition|)
name|ptrn_copiable
operator|++
expr_stmt|;
name|chars_read
operator|-=
operator|(
literal|1
operator|<
name|chars_read
operator|&&
name|p_end
operator|==
operator|(
name|repl_beginning
condition|?
name|p_max
else|:
name|p_ptrn_lines
operator|)
operator|&&
name|incomplete_line
argument_list|()
operator|)
expr_stmt|;
name|p_len
index|[
name|p_end
index|]
operator|=
name|chars_read
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
name|p_end
index|]
operator|=
name|savebuf
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|chars_read
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
default|default:
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|malformed
argument_list|()
expr_stmt|;
block|}
block|}
name|hunk_done
label|:
if|if
condition|(
name|p_end
operator|>=
literal|0
operator|&&
operator|!
name|repl_beginning
condition|)
name|fatal
argument_list|(
literal|"no `---' found in patch at line %ld"
argument_list|,
name|pch_hunk_beg
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|repl_missing
condition|)
block|{
comment|/* reset state back to just after --- */
name|p_input_line
operator|=
name|repl_patch_line
expr_stmt|;
name|context
operator|=
name|repl_context
expr_stmt|;
for|for
control|(
name|p_end
operator|--
init|;
name|p_end
operator|>
name|repl_beginning
condition|;
name|p_end
operator|--
control|)
name|free
argument_list|(
name|p_line
index|[
name|p_end
index|]
argument_list|)
expr_stmt|;
name|Fseek
argument_list|(
name|pfp
argument_list|,
name|repl_backtrack_position
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* redundant 'new' context lines were omitted - set */
comment|/* up to fill them in from the old file context */
name|fillsrc
operator|=
literal|1
expr_stmt|;
name|filldst
operator|=
name|repl_beginning
operator|+
literal|1
expr_stmt|;
name|fillcnt
operator|=
name|p_repl_lines
expr_stmt|;
name|p_end
operator|=
name|p_max
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|some_context
operator|&&
name|fillcnt
operator|==
literal|1
condition|)
block|{
comment|/* the first hunk was a null hunk with no context */
comment|/* and we were expecting one line -- fix it up. */
while|while
condition|(
name|filldst
operator|<
name|p_end
condition|)
block|{
name|p_line
index|[
name|filldst
index|]
operator|=
name|p_line
index|[
name|filldst
operator|+
literal|1
index|]
expr_stmt|;
name|p_Char
index|[
name|filldst
index|]
operator|=
name|p_Char
index|[
name|filldst
operator|+
literal|1
index|]
expr_stmt|;
name|p_len
index|[
name|filldst
index|]
operator|=
name|p_len
index|[
name|filldst
operator|+
literal|1
index|]
expr_stmt|;
name|filldst
operator|++
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|repl_beginning--;
comment|/* this doesn't need to be fixed */
endif|#
directive|endif
name|p_end
operator|--
expr_stmt|;
name|p_first
operator|++
expr_stmt|;
comment|/* do append rather than insert */
name|fillcnt
operator|=
literal|0
expr_stmt|;
name|p_ptrn_lines
operator|=
literal|0
expr_stmt|;
block|}
name|p_prefix_context
operator|=
operator|(
operator|(
name|repl_prefix_context
operator|==
operator|-
literal|1
operator|||
operator|(
name|ptrn_prefix_context
operator|!=
operator|-
literal|1
operator|&&
name|ptrn_prefix_context
operator|<
name|repl_prefix_context
operator|)
operator|)
condition|?
name|ptrn_prefix_context
else|:
name|repl_prefix_context
operator|)
expr_stmt|;
name|p_suffix_context
operator|=
operator|(
operator|(
name|ptrn_suffix_context
operator|!=
operator|-
literal|1
operator|&&
name|ptrn_suffix_context
operator|<
name|context
operator|)
condition|?
name|ptrn_suffix_context
else|:
name|context
operator|)
expr_stmt|;
name|assert
argument_list|(
name|p_prefix_context
operator|!=
operator|-
literal|1
operator|&&
name|p_suffix_context
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|difftype
operator|==
name|CONTEXT_DIFF
operator|&&
operator|(
name|fillcnt
operator|||
operator|(
name|p_first
operator|>
literal|1
operator|&&
name|p_prefix_context
operator|+
name|p_suffix_context
operator|<
name|ptrn_copiable
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|verbosity
operator|==
name|VERBOSE
condition|)
name|say
argument_list|(
literal|"%s\n%s\n%s\n"
argument_list|,
literal|"(Fascinating -- this is really a new-style context diff but without"
argument_list|,
literal|"the telltale extra asterisks on the *** line that usually indicate"
argument_list|,
literal|"the new style...)"
argument_list|)
expr_stmt|;
name|diff_type
operator|=
name|difftype
operator|=
name|NEW_CONTEXT_DIFF
expr_stmt|;
block|}
comment|/* if there were omitted context lines, fill them in now */
if|if
condition|(
name|fillcnt
condition|)
block|{
name|p_bfake
operator|=
name|filldst
expr_stmt|;
comment|/* remember where not to free() */
name|p_efake
operator|=
name|filldst
operator|+
name|fillcnt
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|fillcnt
operator|--
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|fillsrc
operator|<=
name|p_end
operator|&&
name|fillsrc
operator|!=
name|repl_beginning
operator|&&
name|p_Char
index|[
name|fillsrc
index|]
operator|!=
literal|' '
condition|)
name|fillsrc
operator|++
expr_stmt|;
if|if
condition|(
name|p_end
operator|<
name|fillsrc
operator|||
name|fillsrc
operator|==
name|repl_beginning
condition|)
name|fatal
argument_list|(
literal|"replacement text or line numbers mangled in hunk at line %ld"
argument_list|,
name|p_hunk_beg
argument_list|)
expr_stmt|;
name|p_line
index|[
name|filldst
index|]
operator|=
name|p_line
index|[
name|fillsrc
index|]
expr_stmt|;
name|p_Char
index|[
name|filldst
index|]
operator|=
name|p_Char
index|[
name|fillsrc
index|]
expr_stmt|;
name|p_len
index|[
name|filldst
index|]
operator|=
name|p_len
index|[
name|fillsrc
index|]
expr_stmt|;
name|fillsrc
operator|++
expr_stmt|;
name|filldst
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|fillsrc
operator|<=
name|p_end
operator|&&
name|fillsrc
operator|!=
name|repl_beginning
condition|)
block|{
if|if
condition|(
name|p_Char
index|[
name|fillsrc
index|]
operator|==
literal|' '
condition|)
name|fatal
argument_list|(
literal|"replacement text or line numbers mangled in hunk at line %ld"
argument_list|,
name|p_hunk_beg
argument_list|)
expr_stmt|;
name|fillsrc
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|&
literal|64
condition|)
name|printf
argument_list|(
literal|"fillsrc %ld, filldst %ld, rb %ld, e+1 %ld\n"
argument_list|,
name|fillsrc
argument_list|,
name|filldst
argument_list|,
name|repl_beginning
argument_list|,
name|p_end
operator|+
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fillsrc
operator|==
name|p_end
operator|+
literal|1
operator|||
name|fillsrc
operator|==
name|repl_beginning
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|filldst
operator|==
name|p_end
operator|+
literal|1
operator|||
name|filldst
operator|==
name|repl_beginning
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|difftype
operator|==
name|UNI_DIFF
condition|)
block|{
name|file_offset
name|line_beginning
init|=
name|file_tell
argument_list|(
name|pfp
argument_list|)
decl_stmt|;
comment|/* file pos of the current line */
specifier|register
name|LINENUM
name|fillsrc
decl_stmt|;
comment|/* index of old lines */
specifier|register
name|LINENUM
name|filldst
decl_stmt|;
comment|/* index of new lines */
name|char
name|ch
init|=
literal|'\0'
decl_stmt|;
name|chars_read
operator|=
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|chars_read
operator|<=
literal|4
operator|||
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"@@ -"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|next_intuit_at
argument_list|(
name|line_beginning
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
return|return
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
name|s
operator|=
name|buf
operator|+
literal|4
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_first
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|p_ptrn_lines
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
operator|++
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
name|p_ptrn_lines
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'+'
operator|||
operator|!
operator|*
operator|++
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_newfirst
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|p_repl_lines
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
operator|++
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
name|p_repl_lines
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'@'
condition|)
name|malformed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptrn_lines
condition|)
name|p_first
operator|++
expr_stmt|;
comment|/* do append rather than insert */
if|if
condition|(
operator|!
name|p_repl_lines
condition|)
name|p_newfirst
operator|++
expr_stmt|;
name|p_max
operator|=
name|p_ptrn_lines
operator|+
name|p_repl_lines
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|p_max
operator|>=
name|hunkmax
condition|)
if|if
condition|(
operator|!
name|grow_hunkmax
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
name|fillsrc
operator|=
literal|1
expr_stmt|;
name|filldst
operator|=
name|fillsrc
operator|+
name|p_ptrn_lines
expr_stmt|;
name|p_end
operator|=
name|filldst
operator|+
name|p_repl_lines
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"*** %ld,%ld ****\n"
argument_list|,
name|p_first
argument_list|,
name|p_first
operator|+
name|p_ptrn_lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_len
index|[
literal|0
index|]
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
literal|0
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_Char
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"--- %ld,%ld ----\n"
argument_list|,
name|p_newfirst
argument_list|,
name|p_newfirst
operator|+
name|p_repl_lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_len
index|[
name|filldst
index|]
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
name|filldst
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_Char
index|[
name|filldst
operator|++
index|]
operator|=
literal|'='
expr_stmt|;
name|p_prefix_context
operator|=
operator|-
literal|1
expr_stmt|;
name|p_hunk_beg
operator|=
name|p_input_line
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|fillsrc
operator|<=
name|p_ptrn_lines
operator|||
name|filldst
operator|<=
name|p_end
condition|)
block|{
name|chars_read
operator|=
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|chars_read
condition|)
block|{
if|if
condition|(
name|p_max
operator|-
name|filldst
operator|<
literal|3
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|" \n"
argument_list|)
expr_stmt|;
comment|/* assume blank lines got chopped */
name|chars_read
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fatal
argument_list|(
literal|"unexpected end of file in patch"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|s
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\t'
operator|||
operator|*
name|buf
operator|==
literal|'\n'
condition|)
block|{
name|ch
operator|=
literal|' '
expr_stmt|;
comment|/* assume the space got eaten */
name|s
operator|=
name|savebuf
argument_list|(
name|buf
argument_list|,
name|chars_read
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
operator|*
name|buf
expr_stmt|;
name|s
operator|=
name|savebuf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
operator|--
name|chars_read
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
condition|)
block|{
while|while
condition|(
operator|--
name|filldst
operator|>
name|p_ptrn_lines
condition|)
name|free
argument_list|(
name|p_line
index|[
name|filldst
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|fillsrc
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'-'
case|:
if|if
condition|(
name|fillsrc
operator|>
name|p_ptrn_lines
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|filldst
operator|-
literal|1
expr_stmt|;
name|malformed
argument_list|()
expr_stmt|;
block|}
name|chars_read
operator|-=
name|fillsrc
operator|==
name|p_ptrn_lines
operator|&&
name|incomplete_line
argument_list|()
expr_stmt|;
name|p_Char
index|[
name|fillsrc
index|]
operator|=
name|ch
expr_stmt|;
name|p_line
index|[
name|fillsrc
index|]
operator|=
name|s
expr_stmt|;
name|p_len
index|[
name|fillsrc
operator|++
index|]
operator|=
name|chars_read
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|ch
operator|=
literal|' '
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|' '
case|:
if|if
condition|(
name|fillsrc
operator|>
name|p_ptrn_lines
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|filldst
operator|>
name|p_ptrn_lines
condition|)
name|free
argument_list|(
name|p_line
index|[
name|filldst
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|fillsrc
operator|-
literal|1
expr_stmt|;
name|malformed
argument_list|()
expr_stmt|;
block|}
name|context
operator|++
expr_stmt|;
name|chars_read
operator|-=
name|fillsrc
operator|==
name|p_ptrn_lines
operator|&&
name|incomplete_line
argument_list|()
expr_stmt|;
name|p_Char
index|[
name|fillsrc
index|]
operator|=
name|ch
expr_stmt|;
name|p_line
index|[
name|fillsrc
index|]
operator|=
name|s
expr_stmt|;
name|p_len
index|[
name|fillsrc
operator|++
index|]
operator|=
name|chars_read
expr_stmt|;
name|s
operator|=
name|savebuf
argument_list|(
name|s
argument_list|,
name|chars_read
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
while|while
condition|(
operator|--
name|filldst
operator|>
name|p_ptrn_lines
condition|)
name|free
argument_list|(
name|p_line
index|[
name|filldst
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|fillsrc
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* FALL THROUGH */
case|case
literal|'+'
case|:
if|if
condition|(
name|filldst
operator|>
name|p_end
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|filldst
operator|>
name|p_ptrn_lines
condition|)
name|free
argument_list|(
name|p_line
index|[
name|filldst
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|fillsrc
operator|-
literal|1
expr_stmt|;
name|malformed
argument_list|()
expr_stmt|;
block|}
name|chars_read
operator|-=
name|filldst
operator|==
name|p_end
operator|&&
name|incomplete_line
argument_list|()
expr_stmt|;
name|p_Char
index|[
name|filldst
index|]
operator|=
name|ch
expr_stmt|;
name|p_line
index|[
name|filldst
index|]
operator|=
name|s
expr_stmt|;
name|p_len
index|[
name|filldst
operator|++
index|]
operator|=
name|chars_read
expr_stmt|;
break|break;
default|default:
name|p_end
operator|=
name|filldst
expr_stmt|;
name|malformed
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|!=
literal|' '
condition|)
block|{
if|if
condition|(
name|p_prefix_context
operator|==
operator|-
literal|1
condition|)
name|p_prefix_context
operator|=
name|context
expr_stmt|;
name|context
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* while */
if|if
condition|(
name|p_prefix_context
operator|==
operator|-
literal|1
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_suffix_context
operator|=
name|context
expr_stmt|;
block|}
else|else
block|{
comment|/* normal diff--fake it up */
name|char
name|hunk_type
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|LINENUM
name|min
decl_stmt|,
name|max
decl_stmt|;
name|file_offset
name|line_beginning
init|=
name|file_tell
argument_list|(
name|pfp
argument_list|)
decl_stmt|;
name|p_prefix_context
operator|=
name|p_suffix_context
operator|=
literal|0
expr_stmt|;
name|chars_read
operator|=
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
operator|!
name|chars_read
operator|||
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|buf
argument_list|)
condition|)
block|{
name|next_intuit_at
argument_list|(
name|line_beginning
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
return|return
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
name|p_first
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
init|;
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|p_ptrn_lines
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
operator|++
name|s
argument_list|)
operator|-
name|p_first
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
name|p_ptrn_lines
operator|=
operator|(
operator|*
name|s
operator|!=
literal|'a'
operator|)
expr_stmt|;
name|hunk_type
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|hunk_type
operator|==
literal|'a'
condition|)
name|p_first
operator|++
expr_stmt|;
comment|/* do append rather than insert */
name|min
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
operator|++
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|max
operator|=
operator|(
name|LINENUM
operator|)
name|atol
argument_list|(
operator|++
name|s
argument_list|)
expr_stmt|;
else|else
name|max
operator|=
name|min
expr_stmt|;
if|if
condition|(
name|hunk_type
operator|==
literal|'d'
condition|)
name|min
operator|++
expr_stmt|;
name|p_end
operator|=
name|p_ptrn_lines
operator|+
literal|1
operator|+
name|max
operator|-
name|min
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|p_end
operator|>=
name|hunkmax
condition|)
if|if
condition|(
operator|!
name|grow_hunkmax
argument_list|()
condition|)
block|{
name|p_end
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_newfirst
operator|=
name|min
expr_stmt|;
name|p_repl_lines
operator|=
name|max
operator|-
name|min
operator|+
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"*** %ld,%ld\n"
argument_list|,
name|p_first
argument_list|,
name|p_first
operator|+
name|p_ptrn_lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_len
index|[
literal|0
index|]
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
literal|0
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_Char
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|p_ptrn_lines
condition|;
name|i
operator|++
control|)
block|{
name|chars_read
operator|=
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
name|p_end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|chars_read
condition|)
name|fatal
argument_list|(
literal|"unexpected end of file in patch at line %ld"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'<'
operator|||
operator|(
name|buf
index|[
literal|1
index|]
operator|!=
literal|' '
operator|&&
name|buf
index|[
literal|1
index|]
operator|!=
literal|'\t'
operator|)
condition|)
name|fatal
argument_list|(
literal|"`<' expected at line %ld of patch"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
name|chars_read
operator|-=
literal|2
operator|+
operator|(
name|i
operator|==
name|p_ptrn_lines
operator|&&
name|incomplete_line
argument_list|()
operator|)
expr_stmt|;
name|p_len
index|[
name|i
index|]
operator|=
name|chars_read
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
name|i
index|]
operator|=
name|savebuf
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|chars_read
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_Char
index|[
name|i
index|]
operator|=
literal|'-'
expr_stmt|;
block|}
if|if
condition|(
name|hunk_type
operator|==
literal|'c'
condition|)
block|{
name|chars_read
operator|=
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
name|p_end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|chars_read
condition|)
name|fatal
argument_list|(
literal|"unexpected end of file in patch at line %ld"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'-'
condition|)
name|fatal
argument_list|(
literal|"`---' expected at line %ld of patch"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"--- %ld,%ld\n"
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|p_len
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
name|i
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_Char
index|[
name|i
index|]
operator|=
literal|'='
expr_stmt|;
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<=
name|p_end
condition|;
name|i
operator|++
control|)
block|{
name|chars_read
operator|=
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|chars_read
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
name|p_end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|chars_read
condition|)
name|fatal
argument_list|(
literal|"unexpected end of file in patch at line %ld"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'>'
operator|||
operator|(
name|buf
index|[
literal|1
index|]
operator|!=
literal|' '
operator|&&
name|buf
index|[
literal|1
index|]
operator|!=
literal|'\t'
operator|)
condition|)
name|fatal
argument_list|(
literal|"`>' expected at line %ld of patch"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
name|chars_read
operator|-=
literal|2
operator|+
operator|(
name|i
operator|==
name|p_end
operator|&&
name|incomplete_line
argument_list|()
operator|)
expr_stmt|;
name|p_len
index|[
name|i
index|]
operator|=
name|chars_read
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_line
index|[
name|i
index|]
operator|=
name|savebuf
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|chars_read
argument_list|)
operator|)
condition|)
block|{
name|p_end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_Char
index|[
name|i
index|]
operator|=
literal|'+'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rev
condition|)
comment|/* backwards patch? */
if|if
condition|(
operator|!
name|pch_swap
argument_list|()
condition|)
name|say
argument_list|(
literal|"Not enough memory to swap next hunk!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
literal|2
condition|)
block|{
name|LINENUM
name|i
decl_stmt|;
name|char
name|special
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|p_end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|p_ptrn_lines
condition|)
name|special
operator|=
literal|'^'
expr_stmt|;
else|else
name|special
operator|=
literal|' '
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%3ld %c %c "
argument_list|,
name|i
argument_list|,
name|p_Char
index|[
name|i
index|]
argument_list|,
name|special
argument_list|)
expr_stmt|;
name|pch_write_line
argument_list|(
name|i
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_end
operator|+
literal|1
operator|<
name|hunkmax
condition|)
comment|/* paranoia reigns supreme... */
name|p_Char
index|[
name|p_end
operator|+
literal|1
index|]
operator|=
literal|'^'
expr_stmt|;
comment|/* add a stopper for apply_hunk */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|get_line
parameter_list|()
block|{
return|return
name|pget_line
argument_list|(
name|p_indent
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Input a line from the patch file, worrying about indentation.    Strip up to INDENT characters' worth of leading indentation.    Ignore any partial lines at end of input, but warn about them.    Succeed if a line was read; it is terminated by "\n\0" for convenience.    Return the number of characters read, including '\n' but not '\0'.    Return -1 if we ran out of memory.  */
end_comment

begin_function
specifier|static
name|size_t
name|pget_line
parameter_list|(
name|indent
parameter_list|)
name|int
name|indent
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fp
init|=
name|pfp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|b
decl_stmt|;
specifier|register
name|size_t
name|s
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|read_fatal
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|indent
operator|<=
name|i
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'X'
condition|)
name|i
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
name|i
operator|=
operator|(
name|i
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
else|else
break|break;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|b
operator|=
name|buf
expr_stmt|;
name|s
operator|=
name|bufsize
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|==
name|s
operator|-
literal|1
condition|)
block|{
name|s
operator|*=
literal|2
expr_stmt|;
name|b
operator|=
name|realloc
argument_list|(
name|b
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
if|if
condition|(
operator|!
name|using_plan_a
condition|)
name|memory_fatal
argument_list|()
expr_stmt|;
return|return
operator|(
name|size_t
operator|)
operator|-
literal|1
return|;
block|}
name|buf
operator|=
name|b
expr_stmt|;
name|bufsize
operator|=
name|s
expr_stmt|;
block|}
name|b
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|read_fatal
argument_list|()
expr_stmt|;
name|say
argument_list|(
literal|"patch unexpectedly ends in middle of line\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|b
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|incomplete_line
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|fp
init|=
name|pfp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|file_offset
name|line_beginning
init|=
name|file_tell
argument_list|(
name|fp
argument_list|)
decl_stmt|;
if|if
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|==
literal|'\\'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
continue|continue;
return|return
name|TRUE
return|;
block|}
else|else
block|{
comment|/* We don't trust ungetc.  */
name|Fseek
argument_list|(
name|pfp
argument_list|,
name|line_beginning
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Reverse the old and new portions of the current hunk. */
end_comment

begin_function
name|bool
name|pch_swap
parameter_list|()
block|{
name|char
modifier|*
modifier|*
name|tp_line
decl_stmt|;
comment|/* the text of the hunk */
name|size_t
modifier|*
name|tp_len
decl_stmt|;
comment|/* length of each line */
name|char
modifier|*
name|tp_char
decl_stmt|;
comment|/* +, -, and ! */
specifier|register
name|LINENUM
name|i
decl_stmt|;
specifier|register
name|LINENUM
name|n
decl_stmt|;
name|bool
name|blankline
init|=
name|FALSE
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|i
operator|=
name|p_first
expr_stmt|;
name|p_first
operator|=
name|p_newfirst
expr_stmt|;
name|p_newfirst
operator|=
name|i
expr_stmt|;
comment|/* make a scratch copy */
name|tp_line
operator|=
name|p_line
expr_stmt|;
name|tp_len
operator|=
name|p_len
expr_stmt|;
name|tp_char
operator|=
name|p_Char
expr_stmt|;
name|p_line
operator|=
literal|0
expr_stmt|;
comment|/* force set_hunkmax to allocate again */
name|p_len
operator|=
literal|0
expr_stmt|;
name|p_Char
operator|=
literal|0
expr_stmt|;
name|set_hunkmax
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_line
operator|||
operator|!
name|p_len
operator|||
operator|!
name|p_Char
condition|)
block|{
if|if
condition|(
name|p_line
condition|)
name|free
argument_list|(
name|p_line
argument_list|)
expr_stmt|;
name|p_line
operator|=
name|tp_line
expr_stmt|;
if|if
condition|(
name|p_len
condition|)
name|free
argument_list|(
name|p_len
argument_list|)
expr_stmt|;
name|p_len
operator|=
name|tp_len
expr_stmt|;
if|if
condition|(
name|p_Char
condition|)
name|free
argument_list|(
name|p_Char
argument_list|)
expr_stmt|;
name|p_Char
operator|=
name|tp_char
expr_stmt|;
return|return
name|FALSE
return|;
comment|/* not enough memory to swap hunk! */
block|}
comment|/* now turn the new into the old */
name|i
operator|=
name|p_ptrn_lines
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tp_char
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* account for possible blank line */
name|blankline
operator|=
name|TRUE
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p_efake
operator|>=
literal|0
condition|)
block|{
comment|/* fix non-freeable ptr range */
if|if
condition|(
name|p_efake
operator|<=
name|i
condition|)
name|n
operator|=
name|p_end
operator|-
name|i
operator|+
literal|1
expr_stmt|;
else|else
name|n
operator|=
operator|-
name|i
expr_stmt|;
name|p_efake
operator|+=
name|n
expr_stmt|;
name|p_bfake
operator|+=
name|n
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|i
operator|<=
name|p_end
condition|;
name|i
operator|++
operator|,
name|n
operator|++
control|)
block|{
name|p_line
index|[
name|n
index|]
operator|=
name|tp_line
index|[
name|i
index|]
expr_stmt|;
name|p_Char
index|[
name|n
index|]
operator|=
name|tp_char
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p_Char
index|[
name|n
index|]
operator|==
literal|'+'
condition|)
name|p_Char
index|[
name|n
index|]
operator|=
literal|'-'
expr_stmt|;
name|p_len
index|[
name|n
index|]
operator|=
name|tp_len
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|blankline
condition|)
block|{
name|i
operator|=
name|p_ptrn_lines
operator|+
literal|1
expr_stmt|;
name|p_line
index|[
name|n
index|]
operator|=
name|tp_line
index|[
name|i
index|]
expr_stmt|;
name|p_Char
index|[
name|n
index|]
operator|=
name|tp_char
index|[
name|i
index|]
expr_stmt|;
name|p_len
index|[
name|n
index|]
operator|=
name|tp_len
index|[
name|i
index|]
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|assert
argument_list|(
name|p_Char
index|[
literal|0
index|]
operator|==
literal|'='
argument_list|)
expr_stmt|;
name|p_Char
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
for|for
control|(
name|s
operator|=
name|p_line
index|[
literal|0
index|]
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
operator|*
name|s
operator|=
literal|'*'
expr_stmt|;
comment|/* now turn the old into the new */
name|assert
argument_list|(
name|tp_char
index|[
literal|0
index|]
operator|==
literal|'*'
argument_list|)
expr_stmt|;
name|tp_char
index|[
literal|0
index|]
operator|=
literal|'='
expr_stmt|;
for|for
control|(
name|s
operator|=
name|tp_line
index|[
literal|0
index|]
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
operator|*
name|s
operator|=
literal|'-'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|n
operator|<=
name|p_end
condition|;
name|i
operator|++
operator|,
name|n
operator|++
control|)
block|{
name|p_line
index|[
name|n
index|]
operator|=
name|tp_line
index|[
name|i
index|]
expr_stmt|;
name|p_Char
index|[
name|n
index|]
operator|=
name|tp_char
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p_Char
index|[
name|n
index|]
operator|==
literal|'-'
condition|)
name|p_Char
index|[
name|n
index|]
operator|=
literal|'+'
expr_stmt|;
name|p_len
index|[
name|n
index|]
operator|=
name|tp_len
index|[
name|i
index|]
expr_stmt|;
block|}
name|assert
argument_list|(
name|i
operator|==
name|p_ptrn_lines
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|p_ptrn_lines
expr_stmt|;
name|p_ptrn_lines
operator|=
name|p_repl_lines
expr_stmt|;
name|p_repl_lines
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|tp_line
condition|)
name|free
argument_list|(
name|tp_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp_len
condition|)
name|free
argument_list|(
name|tp_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp_char
condition|)
name|free
argument_list|(
name|tp_char
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return whether file WHICH (0 = old, 1 = new) appears to nonexistent.    Return 1 for empty, 2 for nonexistent.  */
end_comment

begin_function
name|bool
name|pch_says_nonexistent
parameter_list|(
name|which
parameter_list|)
name|int
name|which
decl_stmt|;
block|{
return|return
name|p_says_nonexistent
index|[
name|which
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return timestamp of patch header for file WHICH (0 = old, 1 = new),    or -1 if there was no timestamp or an error in the timestamp.  */
end_comment

begin_function
name|time_t
name|pch_timestamp
parameter_list|(
name|which
parameter_list|)
name|int
name|which
decl_stmt|;
block|{
return|return
name|p_timestamp
index|[
name|which
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the specified line position in the old file of the old context. */
end_comment

begin_function
name|LINENUM
name|pch_first
parameter_list|()
block|{
return|return
name|p_first
return|;
block|}
end_function

begin_comment
comment|/* Return the number of lines of old context. */
end_comment

begin_function
name|LINENUM
name|pch_ptrn_lines
parameter_list|()
block|{
return|return
name|p_ptrn_lines
return|;
block|}
end_function

begin_comment
comment|/* Return the probable line position in the new file of the first line. */
end_comment

begin_function
name|LINENUM
name|pch_newfirst
parameter_list|()
block|{
return|return
name|p_newfirst
return|;
block|}
end_function

begin_comment
comment|/* Return the number of lines in the replacement text including context. */
end_comment

begin_function
name|LINENUM
name|pch_repl_lines
parameter_list|()
block|{
return|return
name|p_repl_lines
return|;
block|}
end_function

begin_comment
comment|/* Return the number of lines in the whole hunk. */
end_comment

begin_function
name|LINENUM
name|pch_end
parameter_list|()
block|{
return|return
name|p_end
return|;
block|}
end_function

begin_comment
comment|/* Return the number of context lines before the first changed line. */
end_comment

begin_function
name|LINENUM
name|pch_prefix_context
parameter_list|()
block|{
return|return
name|p_prefix_context
return|;
block|}
end_function

begin_comment
comment|/* Return the number of context lines after the last changed line. */
end_comment

begin_function
name|LINENUM
name|pch_suffix_context
parameter_list|()
block|{
return|return
name|p_suffix_context
return|;
block|}
end_function

begin_comment
comment|/* Return the length of a particular patch line. */
end_comment

begin_function
name|size_t
name|pch_line_len
parameter_list|(
name|line
parameter_list|)
name|LINENUM
name|line
decl_stmt|;
block|{
return|return
name|p_len
index|[
name|line
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the control character (+, -, *, !, etc) for a patch line. */
end_comment

begin_function
name|char
name|pch_char
parameter_list|(
name|line
parameter_list|)
name|LINENUM
name|line
decl_stmt|;
block|{
return|return
name|p_Char
index|[
name|line
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to a particular patch line. */
end_comment

begin_function
name|char
modifier|*
name|pfetch
parameter_list|(
name|line
parameter_list|)
name|LINENUM
name|line
decl_stmt|;
block|{
return|return
name|p_line
index|[
name|line
index|]
return|;
block|}
end_function

begin_comment
comment|/* Output a patch line.  */
end_comment

begin_function
name|bool
name|pch_write_line
parameter_list|(
name|line
parameter_list|,
name|file
parameter_list|)
name|LINENUM
name|line
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|bool
name|after_newline
init|=
name|p_line
index|[
name|line
index|]
index|[
name|p_len
index|[
name|line
index|]
operator|-
literal|1
index|]
operator|==
literal|'\n'
decl_stmt|;
if|if
condition|(
operator|!
name|fwrite
argument_list|(
name|p_line
index|[
name|line
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_line
index|[
name|line
index|]
argument_list|)
argument_list|,
name|p_len
index|[
name|line
index|]
argument_list|,
name|file
argument_list|)
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
return|return
name|after_newline
return|;
block|}
end_function

begin_comment
comment|/* Return where in the patch file this hunk began, for error messages. */
end_comment

begin_function
name|LINENUM
name|pch_hunk_beg
parameter_list|()
block|{
return|return
name|p_hunk_beg
return|;
block|}
end_function

begin_comment
comment|/* Apply an ed script by feeding ed itself. */
end_comment

begin_function
name|void
name|do_ed_script
parameter_list|(
name|ofp
parameter_list|)
name|FILE
modifier|*
name|ofp
decl_stmt|;
block|{
specifier|static
name|char
specifier|const
name|ed_program
index|[]
init|=
name|ed_PROGRAM
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|file_offset
name|beginning_of_this_line
decl_stmt|;
specifier|register
name|bool
name|this_line_is_command
init|=
name|FALSE
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|pipefp
init|=
literal|0
decl_stmt|;
specifier|register
name|size_t
name|chars_read
decl_stmt|;
if|if
condition|(
operator|!
name|skip_rest_of_patch
condition|)
block|{
name|assert
argument_list|(
operator|!
name|inerrno
argument_list|)
expr_stmt|;
name|copy_file
argument_list|(
name|inname
argument_list|,
name|TMPOUTNAME
argument_list|,
name|instat
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s%s"
argument_list|,
name|ed_program
argument_list|,
name|verbosity
operator|==
name|VERBOSE
condition|?
literal|""
else|:
literal|"- "
argument_list|,
name|TMPOUTNAME
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|pipefp
operator|=
name|popen
argument_list|(
name|buf
argument_list|,
name|binary_transput
condition|?
literal|"wb"
else|:
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pipefp
condition|)
name|pfatal
argument_list|(
literal|"can't open pipe to `%s'"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|beginning_of_this_line
operator|=
name|file_tell
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|chars_read
operator|=
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|chars_read
condition|)
block|{
name|next_intuit_at
argument_list|(
name|beginning_of_this_line
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|t
operator|=
name|buf
init|;
name|ISDIGIT
argument_list|(
operator|*
name|t
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|','
condition|;
name|t
operator|++
control|)
continue|continue;
name|this_line_is_command
operator|=
operator|(
name|ISDIGIT
argument_list|(
operator|*
name|buf
argument_list|)
operator|&&
operator|(
operator|*
name|t
operator|==
literal|'d'
operator|||
operator|*
name|t
operator|==
literal|'c'
operator|||
operator|*
name|t
operator|==
literal|'a'
operator|||
operator|*
name|t
operator|==
literal|'i'
operator|||
operator|*
name|t
operator|==
literal|'s'
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|this_line_is_command
condition|)
block|{
if|if
condition|(
name|pipefp
condition|)
if|if
condition|(
operator|!
name|fwrite
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
expr|*
name|buf
argument_list|,
name|chars_read
argument_list|,
name|pipefp
argument_list|)
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|!=
literal|'d'
operator|&&
operator|*
name|t
operator|!=
literal|'s'
condition|)
block|{
while|while
condition|(
operator|(
name|chars_read
operator|=
name|get_line
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pipefp
condition|)
if|if
condition|(
operator|!
name|fwrite
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
expr|*
name|buf
argument_list|,
name|chars_read
argument_list|,
name|pipefp
argument_list|)
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
name|chars_read
operator|==
literal|2
operator|&&
name|strEQ
argument_list|(
name|buf
argument_list|,
literal|".\n"
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
else|else
block|{
name|next_intuit_at
argument_list|(
name|beginning_of_this_line
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|pipefp
condition|)
return|return;
if|if
condition|(
name|fwrite
argument_list|(
literal|"w\nq\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|,
name|pipefp
argument_list|)
operator|==
literal|0
operator|||
name|fflush
argument_list|(
name|pipefp
argument_list|)
operator|!=
literal|0
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
name|pclose
argument_list|(
name|pipefp
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s FAILED"
argument_list|,
name|ed_program
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofp
condition|)
block|{
name|FILE
modifier|*
name|ifp
init|=
name|fopen
argument_list|(
name|TMPOUTNAME
argument_list|,
name|binary_transput
condition|?
literal|"rb"
else|:
literal|"r"
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|ifp
condition|)
name|pfatal
argument_list|(
literal|"can't open `%s'"
argument_list|,
name|TMPOUTNAME
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|ifp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
name|putc
argument_list|(
name|c
argument_list|,
name|ofp
argument_list|)
operator|==
name|EOF
condition|)
name|write_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|ifp
argument_list|)
operator|||
name|fclose
argument_list|(
name|ifp
argument_list|)
operator|!=
literal|0
condition|)
name|read_fatal
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

