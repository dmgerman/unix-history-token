begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Parse a string, yielding a struct partime that describes it.  */
end_comment

begin_comment
comment|/* Copyright 1993, 1994, 1995, 1997 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.     This file is part of RCS.     RCS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     RCS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with RCS; see the file COPYING.    If not, write to the Free Software Foundation,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Report problems and direct all questions to:  	rcs-bugs@cs.purdue.edu   */
end_comment

begin_if
if|#
directive|if
name|has_conf_h
end_if

begin_include
include|#
directive|include
file|<conf.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|__STDC__
end_ifndef

begin_define
define|#
directive|define
name|const
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_LIMITS_H
end_if

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_MIN
end_ifndef

begin_define
define|#
directive|define
name|LONG_MIN
value|(-1-2147483647L)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|STDC_HEADERS
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|P
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|P
parameter_list|(
name|x
parameter_list|)
value|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_if
if|#
directive|if
name|STDC_HEADERS
end_if

begin_define
define|#
directive|define
name|CTYPE_DOMAIN
parameter_list|(
name|c
parameter_list|)
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CTYPE_DOMAIN
parameter_list|(
name|c
parameter_list|)
value|((unsigned) (c)<= 0177)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ISALNUM
parameter_list|(
name|c
parameter_list|)
value|(CTYPE_DOMAIN (c)&& isalnum (c))
end_define

begin_define
define|#
directive|define
name|ISALPHA
parameter_list|(
name|c
parameter_list|)
value|(CTYPE_DOMAIN (c)&& isalpha (c))
end_define

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|c
parameter_list|)
value|(CTYPE_DOMAIN (c)&& isspace (c))
end_define

begin_define
define|#
directive|define
name|ISUPPER
parameter_list|(
name|c
parameter_list|)
value|(CTYPE_DOMAIN (c)&& isupper (c))
end_define

begin_define
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|c
parameter_list|)
value|((unsigned) (c) - '0'<= 9)
end_define

begin_include
include|#
directive|include
file|<partime.h>
end_include

begin_decl_stmt
name|char
specifier|const
name|partimeId
index|[]
init|=
literal|"$Id: partime.c,v 5.16 1997/05/19 06:33:53 eggert Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lookup tables for names of months, weekdays, time zones.  */
end_comment

begin_define
define|#
directive|define
name|NAME_LENGTH_MAXIMUM
value|4
end_define

begin_struct
struct|struct
name|name_val
block|{
name|char
name|name
index|[
name|NAME_LENGTH_MAXIMUM
index|]
decl_stmt|;
name|int
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|parse_decimal
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|parse_fixed
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|parse_pattern_letter
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|int
operator|,
expr|struct
name|partime
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|parse_prefix
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
expr|struct
name|partime
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|parse_ranged
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lookup
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
expr|struct
name|name_val
specifier|const
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|merge_partime
name|P
argument_list|(
operator|(
expr|struct
name|partime
operator|*
operator|,
expr|struct
name|partime
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|undefine
name|P
argument_list|(
operator|(
expr|struct
name|partime
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|name_val
specifier|const
name|month_names
index|[]
init|=
block|{
block|{
literal|"jan"
block|,
literal|0
block|}
block|,
block|{
literal|"feb"
block|,
literal|1
block|}
block|,
block|{
literal|"mar"
block|,
literal|2
block|}
block|,
block|{
literal|"apr"
block|,
literal|3
block|}
block|,
block|{
literal|"may"
block|,
literal|4
block|}
block|,
block|{
literal|"jun"
block|,
literal|5
block|}
block|,
block|{
literal|"jul"
block|,
literal|6
block|}
block|,
block|{
literal|"aug"
block|,
literal|7
block|}
block|,
block|{
literal|"sep"
block|,
literal|8
block|}
block|,
block|{
literal|"oct"
block|,
literal|9
block|}
block|,
block|{
literal|"nov"
block|,
literal|10
block|}
block|,
block|{
literal|"dec"
block|,
literal|11
block|}
block|,
block|{
literal|""
block|,
name|TM_UNDEFINED
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|name_val
specifier|const
name|weekday_names
index|[]
init|=
block|{
block|{
literal|"sun"
block|,
literal|0
block|}
block|,
block|{
literal|"mon"
block|,
literal|1
block|}
block|,
block|{
literal|"tue"
block|,
literal|2
block|}
block|,
block|{
literal|"wed"
block|,
literal|3
block|}
block|,
block|{
literal|"thu"
block|,
literal|4
block|}
block|,
block|{
literal|"fri"
block|,
literal|5
block|}
block|,
block|{
literal|"sat"
block|,
literal|6
block|}
block|,
block|{
literal|""
block|,
name|TM_UNDEFINED
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|hr60nonnegative
parameter_list|(
name|t
parameter_list|)
value|((t)/100 * 60  +  (t)%100)
end_define

begin_define
define|#
directive|define
name|hr60
parameter_list|(
name|t
parameter_list|)
value|((t)<0 ? -hr60nonnegative(-(t)) : hr60nonnegative(t))
end_define

begin_define
define|#
directive|define
name|zs
parameter_list|(
name|t
parameter_list|,
name|s
parameter_list|)
value|{s, hr60(t)}
end_define

begin_define
define|#
directive|define
name|zd
parameter_list|(
name|t
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|)
value|zs(t, s),  zs((t)+100, d)
end_define

begin_decl_stmt
specifier|static
name|struct
name|name_val
specifier|const
name|zone_names
index|[]
init|=
block|{
name|zs
argument_list|(
operator|-
literal|1000
argument_list|,
literal|"hst"
argument_list|)
block|,
comment|/* Hawaii */
name|zd
argument_list|(
operator|-
literal|1000
argument_list|,
literal|"hast"
argument_list|,
literal|"hadt"
argument_list|)
block|,
comment|/* Hawaii-Aleutian */
name|zd
argument_list|(
operator|-
literal|900
argument_list|,
literal|"akst"
argument_list|,
literal|"akdt"
argument_list|)
block|,
comment|/* Alaska */
name|zd
argument_list|(
operator|-
literal|800
argument_list|,
literal|"pst"
argument_list|,
literal|"pdt"
argument_list|)
block|,
comment|/* Pacific */
name|zd
argument_list|(
operator|-
literal|700
argument_list|,
literal|"mst"
argument_list|,
literal|"mdt"
argument_list|)
block|,
comment|/* Mountain */
name|zd
argument_list|(
operator|-
literal|600
argument_list|,
literal|"cst"
argument_list|,
literal|"cdt"
argument_list|)
block|,
comment|/* Central */
name|zd
argument_list|(
operator|-
literal|500
argument_list|,
literal|"est"
argument_list|,
literal|"edt"
argument_list|)
block|,
comment|/* Eastern */
name|zd
argument_list|(
operator|-
literal|400
argument_list|,
literal|"ast"
argument_list|,
literal|"adt"
argument_list|)
block|,
comment|/* Atlantic */
name|zd
argument_list|(
operator|-
literal|330
argument_list|,
literal|"nst"
argument_list|,
literal|"ndt"
argument_list|)
block|,
comment|/* Newfoundland */
name|zs
argument_list|(
literal|000
argument_list|,
literal|"utc"
argument_list|)
block|,
comment|/* Coordinated Universal */
name|zs
argument_list|(
literal|000
argument_list|,
literal|"uct"
argument_list|)
block|,
comment|/* " */
name|zs
argument_list|(
literal|000
argument_list|,
literal|"cut"
argument_list|)
block|,
comment|/* " */
name|zs
argument_list|(
literal|000
argument_list|,
literal|"ut"
argument_list|)
block|,
comment|/* Universal */
name|zs
argument_list|(
literal|000
argument_list|,
literal|"z"
argument_list|)
block|,
comment|/* Zulu (required by ISO 8601) */
name|zd
argument_list|(
literal|000
argument_list|,
literal|"gmt"
argument_list|,
literal|"bst"
argument_list|)
block|,
comment|/* Greenwich Mean, British Summer */
name|zd
argument_list|(
literal|000
argument_list|,
literal|"wet"
argument_list|,
literal|"west"
argument_list|)
block|,
comment|/* Western European */
name|zd
argument_list|(
literal|100
argument_list|,
literal|"cet"
argument_list|,
literal|"cest"
argument_list|)
block|,
comment|/* Central European */
name|zd
argument_list|(
literal|100
argument_list|,
literal|"met"
argument_list|,
literal|"mest"
argument_list|)
block|,
comment|/* Middle European (bug in old tz versions) */
name|zd
argument_list|(
literal|100
argument_list|,
literal|"mez"
argument_list|,
literal|"mesz"
argument_list|)
block|,
comment|/* Mittel-Europaeische Zeit */
name|zd
argument_list|(
literal|200
argument_list|,
literal|"eet"
argument_list|,
literal|"eest"
argument_list|)
block|,
comment|/* Eastern European */
name|zs
argument_list|(
literal|530
argument_list|,
literal|"ist"
argument_list|)
block|,
comment|/* India */
name|zd
argument_list|(
literal|900
argument_list|,
literal|"jst"
argument_list|,
literal|"jdt"
argument_list|)
block|,
comment|/* Japan */
name|zd
argument_list|(
literal|900
argument_list|,
literal|"kst"
argument_list|,
literal|"kdt"
argument_list|)
block|,
comment|/* Korea */
name|zd
argument_list|(
literal|1200
argument_list|,
literal|"nzst"
argument_list|,
literal|"nzdt"
argument_list|)
block|,
comment|/* New Zealand */
block|{
literal|"lt"
block|,
literal|1
block|}
block|,
if|#
directive|if
literal|0
comment|/* The following names are duplicates or are not well attested.      There are lots more where these came from.  */
block|zs (-1100, "sst" ),
comment|/* Samoan */
block|zd (- 900, "yst" , "ydt" ),
comment|/* Yukon - name is no longer used */
block|zd (- 500, "ast" , "adt" ),
comment|/* Acre */
block|zd (- 400, "wst" , "wdt" ),
comment|/* Western Brazil */
block|zd (- 400, "cst" , "cdt" ),
comment|/* Chile */
block|zd (- 200, "fst" , "fdt" ),
comment|/* Fernando de Noronha */
block|zs (  000, "wat" ),
comment|/* West African */
block|zs (  100, "cat" ),
comment|/* Central African */
block|zs (  200, "sat" ),
comment|/* South African */
block|zd (  200, "ist" , "idt" ),
comment|/* Israel */
block|zs (  300, "eat" ),
comment|/* East African */
block|zd (  300, "msk" , "msd" ),
comment|/* Moscow */
block|zd (  330, "ist" , "idt" ),
comment|/* Iran */
block|zs (  800, "hkt" ),
comment|/* Hong Kong */
block|zs (  800, "sgt" ),
comment|/* Singapore */
block|zd (  800, "cst" , "cdt" ),
comment|/* China */
block|zd (  800, "wst" , "wst" ),
comment|/* Western Australia */
block|zd (  930, "cst" , "cst" ),
comment|/* Central Australia */
block|zs ( 1000, "gst" ),
comment|/* Guam */
block|zd ( 1000, "est" , "est" ),
comment|/* Eastern Australia */
endif|#
directive|endif
block|{
literal|""
block|,
operator|-
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Look for a prefix of S in TABLE, returning val for first matching entry.  */
end_comment

begin_function
specifier|static
name|int
name|lookup
parameter_list|(
name|s
parameter_list|,
name|table
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|struct
name|name_val
specifier|const
name|table
index|[]
decl_stmt|;
block|{
name|int
name|j
decl_stmt|;
name|char
name|buf
index|[
name|NAME_LENGTH_MAXIMUM
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NAME_LENGTH_MAXIMUM
condition|;
name|j
operator|++
control|)
block|{
name|unsigned
name|char
name|c
init|=
operator|*
name|s
operator|++
decl_stmt|;
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|buf
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|buf
index|[
name|j
index|]
operator|=
name|ISUPPER
argument_list|(
name|c
argument_list|)
condition|?
name|tolower
argument_list|(
name|c
argument_list|)
else|:
name|c
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
name|table
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|j
operator|==
name|NAME_LENGTH_MAXIMUM
operator|||
operator|!
name|table
index|[
literal|0
index|]
operator|.
name|name
index|[
name|j
index|]
condition|)
return|return
name|table
index|[
literal|0
index|]
operator|.
name|val
return|;
elseif|else
if|if
condition|(
name|buf
index|[
name|j
index|]
operator|!=
name|table
index|[
literal|0
index|]
operator|.
name|name
index|[
name|j
index|]
condition|)
break|break;
block|}
end_function

begin_comment
comment|/* Set *T to ``undefined'' values.  */
end_comment

begin_function
specifier|static
name|void
name|undefine
parameter_list|(
name|t
parameter_list|)
name|struct
name|partime
modifier|*
name|t
decl_stmt|;
block|{
name|t
operator|->
name|tm
operator|.
name|tm_sec
operator|=
name|t
operator|->
name|tm
operator|.
name|tm_min
operator|=
name|t
operator|->
name|tm
operator|.
name|tm_hour
operator|=
name|t
operator|->
name|tm
operator|.
name|tm_mday
operator|=
name|t
operator|->
name|tm
operator|.
name|tm_mon
operator|=
name|t
operator|->
name|tm
operator|.
name|tm_year
operator|=
name|t
operator|->
name|tm
operator|.
name|tm_wday
operator|=
name|t
operator|->
name|tm
operator|.
name|tm_yday
operator|=
name|t
operator|->
name|ymodulus
operator|=
name|t
operator|->
name|yweek
operator|=
name|TM_UNDEFINED
expr_stmt|;
name|t
operator|->
name|zone
operator|=
name|TM_UNDEFINED_ZONE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Array of patterns to look for in a date string.    Order is important: we look for the first matching pattern    whose values do not contradict values that we already know about.    See `parse_pattern_letter' below for the meaning of the pattern codes.  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|patterns
index|[]
init|=
block|{
comment|/* These traditional patterns must come first,      to prevent an ISO 8601 format from misinterpreting their prefixes.  */
literal|"E_n_y"
block|,
literal|"x"
block|,
comment|/* RFC 822 */
literal|"E_n"
block|,
literal|"n_E"
block|,
literal|"n"
block|,
literal|"t:m:s_A"
block|,
literal|"t:m_A"
block|,
literal|"t_A"
block|,
comment|/* traditional */
literal|"y/N/D$"
block|,
comment|/* traditional RCS */
comment|/* ISO 8601:1988 formats, generalized a bit.  */
literal|"y-N-D$"
block|,
literal|"4ND$"
block|,
literal|"Y-N$"
block|,
literal|"RND$"
block|,
literal|"-R=N$"
block|,
literal|"-R$"
block|,
literal|"--N=D$"
block|,
literal|"N=DT"
block|,
literal|"--N$"
block|,
literal|"---D$"
block|,
literal|"DT"
block|,
literal|"Y-d$"
block|,
literal|"4d$"
block|,
literal|"R=d$"
block|,
literal|"-d$"
block|,
literal|"dT"
block|,
literal|"y-W-X"
block|,
literal|"yWX"
block|,
literal|"y=W"
block|,
literal|"-r-W-X"
block|,
literal|"r-W-XT"
block|,
literal|"-rWX"
block|,
literal|"rWXT"
block|,
literal|"-W=X"
block|,
literal|"W=XT"
block|,
literal|"-W"
block|,
literal|"-w-X"
block|,
literal|"w-XT"
block|,
literal|"---X$"
block|,
literal|"XT"
block|,
literal|"4$"
block|,
literal|"T"
block|,
literal|"h:m:s$"
block|,
literal|"hms$"
block|,
literal|"h:m$"
block|,
literal|"hm$"
block|,
literal|"h$"
block|,
literal|"-m:s$"
block|,
literal|"-ms$"
block|,
literal|"-m$"
block|,
literal|"--s$"
block|,
literal|"Y"
block|,
literal|"Z"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse an initial prefix of STR, setting *T accordingly.    Return the first character after the prefix, or 0 if it couldn't be parsed.    Start with pattern *PI; if success, set *PI to the next pattern to try.    Set *PI to -1 if we know there are no more patterns to try;    if *PI is initially negative, give up immediately.  */
end_comment

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|parse_prefix
parameter_list|(
name|str
parameter_list|,
name|t
parameter_list|,
name|pi
parameter_list|)
name|char
specifier|const
modifier|*
name|str
decl_stmt|;
name|struct
name|partime
modifier|*
name|t
decl_stmt|;
name|int
modifier|*
name|pi
decl_stmt|;
block|{
name|int
name|i
init|=
operator|*
name|pi
decl_stmt|;
name|char
specifier|const
modifier|*
name|pat
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Remove initial noise.  */
while|while
condition|(
operator|!
name|ISALNUM
argument_list|(
name|c
operator|=
operator|*
name|str
argument_list|)
operator|&&
name|c
operator|!=
literal|'-'
operator|&&
name|c
operator|!=
literal|'+'
condition|)
block|{
if|if
condition|(
operator|!
name|c
condition|)
block|{
name|undefine
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|*
name|pi
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|str
return|;
block|}
name|str
operator|++
expr_stmt|;
block|}
comment|/* Try a pattern until one succeeds.  */
while|while
condition|(
operator|(
name|pat
operator|=
name|patterns
index|[
name|i
operator|++
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
specifier|const
modifier|*
name|s
init|=
name|str
decl_stmt|;
name|undefine
argument_list|(
name|t
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|c
operator|=
operator|*
name|pat
operator|++
operator|)
condition|)
block|{
operator|*
name|pi
operator|=
name|i
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
do|while
condition|(
operator|(
name|s
operator|=
name|parse_pattern_letter
argument_list|(
name|s
argument_list|,
name|c
argument_list|,
name|t
argument_list|)
operator|)
operator|!=
literal|0
condition|)
do|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parse an initial prefix of S of length DIGITS; it must be a number.    Store the parsed number into *RES.    Return the first character after the prefix, or 0 if it wasn't parsed.  */
end_comment

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|parse_fixed
parameter_list|(
name|s
parameter_list|,
name|digits
parameter_list|,
name|res
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|int
name|digits
decl_stmt|,
decl|*
name|res
decl_stmt|;
end_function

begin_block
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|char
specifier|const
modifier|*
name|lim
init|=
name|s
operator|+
name|digits
decl_stmt|;
while|while
condition|(
name|s
operator|<
name|lim
condition|)
block|{
name|unsigned
name|d
init|=
operator|*
name|s
operator|++
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
literal|9
operator|<
name|d
condition|)
return|return
literal|0
return|;
name|n
operator|=
literal|10
operator|*
name|n
operator|+
name|d
expr_stmt|;
block|}
operator|*
name|res
operator|=
name|n
expr_stmt|;
return|return
name|s
return|;
block|}
end_block

begin_comment
comment|/* Parse an initial prefix of S of length DIGITS;    it must be a number in the range LO through HI.    Store the parsed number into *RES.    Return the first character after the prefix, or 0 if it wasn't parsed.  */
end_comment

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|parse_ranged
parameter_list|(
name|s
parameter_list|,
name|digits
parameter_list|,
name|lo
parameter_list|,
name|hi
parameter_list|,
name|res
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|int
name|digits
decl_stmt|,
name|lo
decl_stmt|,
name|hi
decl_stmt|,
decl|*
name|res
decl_stmt|;
end_function

begin_block
block|{
name|s
operator|=
name|parse_fixed
argument_list|(
name|s
argument_list|,
name|digits
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
name|s
operator|&&
name|lo
operator|<=
operator|*
name|res
operator|&&
operator|*
name|res
operator|<=
name|hi
condition|?
name|s
else|:
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Parse an initial prefix of S of length DIGITS;    it must be a number in the range LO through HI    and it may be followed by a fraction to be computed using RESOLUTION.    Store the parsed number into *RES; store the fraction times RESOLUTION,    rounded to the nearest integer, into *FRES.    Return the first character after the prefix, or 0 if it wasn't parsed.  */
end_comment

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|parse_decimal
parameter_list|(
name|s
parameter_list|,
name|digits
parameter_list|,
name|lo
parameter_list|,
name|hi
parameter_list|,
name|resolution
parameter_list|,
name|res
parameter_list|,
name|fres
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|int
name|digits
decl_stmt|,
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|resolution
decl_stmt|,
decl|*
name|res
decl_stmt|,
modifier|*
name|fres
decl_stmt|;
end_function

begin_block
block|{
name|s
operator|=
name|parse_fixed
argument_list|(
name|s
argument_list|,
name|digits
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
name|lo
operator|<=
operator|*
name|res
operator|&&
operator|*
name|res
operator|<=
name|hi
condition|)
block|{
name|int
name|f
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|','
operator|||
name|s
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
name|ISDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|char
specifier|const
modifier|*
name|s1
init|=
operator|++
name|s
decl_stmt|;
name|int
name|num10
init|=
literal|0
decl_stmt|,
name|denom10
init|=
literal|10
decl_stmt|,
name|product
decl_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
operator|++
name|s
argument_list|)
condition|)
block|{
name|int
name|d
init|=
name|denom10
operator|*
literal|10
decl_stmt|;
if|if
condition|(
name|d
operator|/
literal|10
operator|!=
name|denom10
condition|)
return|return
literal|0
return|;
comment|/* overflow */
name|denom10
operator|=
name|d
expr_stmt|;
block|}
name|s
operator|=
name|parse_fixed
argument_list|(
name|s1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|s
operator|-
name|s1
argument_list|)
argument_list|,
operator|&
name|num10
argument_list|)
expr_stmt|;
name|product
operator|=
name|num10
operator|*
name|resolution
expr_stmt|;
name|f
operator|=
operator|(
name|product
operator|+
operator|(
name|denom10
operator|>>
literal|1
operator|)
operator|)
operator|/
name|denom10
expr_stmt|;
name|f
operator|-=
name|f
operator|&
operator|(
name|product
operator|%
name|denom10
operator|==
name|denom10
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* round to even */
if|if
condition|(
name|f
operator|<
literal|0
operator|||
name|product
operator|/
name|resolution
operator|!=
name|num10
condition|)
return|return
literal|0
return|;
comment|/* overflow */
block|}
operator|*
name|fres
operator|=
name|f
expr_stmt|;
return|return
name|s
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Parse an initial prefix of S; it must denote a time zone.    Set *ZONE to the number of seconds east of GMT,    or to TM_LOCAL_ZONE if it is the local time zone.    Return the first character after the prefix, or 0 if it wasn't parsed.  */
end_comment

begin_function
name|char
modifier|*
name|parzone
parameter_list|(
name|s
parameter_list|,
name|zone
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|long
modifier|*
name|zone
decl_stmt|;
block|{
name|char
name|sign
decl_stmt|;
name|int
name|hh
decl_stmt|,
name|mm
decl_stmt|,
name|ss
decl_stmt|;
name|int
name|minutesEastOfUTC
decl_stmt|;
name|long
name|offset
decl_stmt|,
name|z
decl_stmt|;
comment|/* The formats are LT, n, n DST, nDST, no, o      where n is a time zone name      and o is a time zone offset of the form [-+]hh[:mm[:ss]].  */
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'-'
case|:
case|case
literal|'+'
case|:
name|z
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|minutesEastOfUTC
operator|=
name|lookup
argument_list|(
name|s
argument_list|,
name|zone_names
argument_list|)
expr_stmt|;
if|if
condition|(
name|minutesEastOfUTC
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Don't bother to check rest of spelling.  */
while|while
condition|(
name|ISALPHA
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
comment|/* Don't modify LT.  */
if|if
condition|(
name|minutesEastOfUTC
operator|==
literal|1
condition|)
block|{
operator|*
name|zone
operator|=
name|TM_LOCAL_ZONE
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
name|z
operator|=
name|minutesEastOfUTC
operator|*
literal|60L
expr_stmt|;
comment|/* Look for trailing " DST".  */
if|if
condition|(
operator|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'T'
operator|||
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|s
index|[
operator|-
literal|2
index|]
operator|==
literal|'S'
operator|||
name|s
index|[
operator|-
literal|2
index|]
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|s
index|[
operator|-
literal|3
index|]
operator|==
literal|'D'
operator|||
name|s
index|[
operator|-
literal|3
index|]
operator|==
literal|'d'
operator|)
condition|)
goto|goto
name|trailing_dst
goto|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'D'
operator|||
name|s
index|[
literal|0
index|]
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'S'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|s
index|[
literal|2
index|]
operator|==
literal|'T'
operator|||
name|s
index|[
literal|2
index|]
operator|==
literal|'t'
operator|)
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
name|trailing_dst
label|:
operator|*
name|zone
operator|=
name|z
operator|+
literal|60
operator|*
literal|60
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'-'
case|:
case|case
literal|'+'
case|:
break|break;
default|default:
operator|*
name|zone
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
break|break;
block|}
name|sign
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|23
argument_list|,
operator|&
name|hh
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|mm
operator|=
name|ss
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|59
argument_list|,
operator|&
name|mm
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
operator|&&
name|s
index|[
operator|-
literal|3
index|]
operator|==
literal|':'
operator|&&
name|ISDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
operator|(
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|59
argument_list|,
operator|&
name|ss
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
name|offset
operator|=
operator|(
name|hh
operator|*
literal|60
operator|+
name|mm
operator|)
operator|*
literal|60L
operator|+
name|ss
expr_stmt|;
operator|*
name|zone
operator|=
name|z
operator|+
operator|(
name|sign
operator|==
literal|'-'
condition|?
operator|-
name|offset
else|:
name|offset
operator|)
expr_stmt|;
comment|/* ?? Are fractions allowed here?  If so, they're not implemented.  */
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
end_function

begin_comment
comment|/* Parse an initial prefix of S, matching the pattern whose code is C.    Set *T accordingly.    Return the first character after the prefix, or 0 if it wasn't parsed.  */
end_comment

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|parse_pattern_letter
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|,
name|t
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|partime
modifier|*
name|t
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'$'
case|:
comment|/* The next character must be a non-digit.  */
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'-'
case|:
case|case
literal|'/'
case|:
case|case
literal|':'
case|:
comment|/* These characters stand for themselves.  */
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
name|c
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'4'
case|:
comment|/* 4-digit year */
name|s
operator|=
name|parse_fixed
argument_list|(
name|s
argument_list|,
literal|4
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_year
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
comment|/* optional '-' */
name|s
operator|+=
operator|*
name|s
operator|==
literal|'-'
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/* AM or PM */
comment|/* This matches the regular expression [AaPp][Mm]?.          It must not be followed by a letter or digit;          otherwise it would match prefixes of strings like "PST".  */
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
if|if
condition|(
name|t
operator|->
name|tm
operator|.
name|tm_hour
operator|==
literal|12
condition|)
name|t
operator|->
name|tm
operator|.
name|tm_hour
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
if|if
condition|(
name|t
operator|->
name|tm
operator|.
name|tm_hour
operator|!=
literal|12
condition|)
name|t
operator|->
name|tm
operator|.
name|tm_hour
operator|+=
literal|12
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
name|s
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ISALNUM
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'D'
case|:
comment|/* day of month [01-31] */
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|31
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_mday
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* day of year [001-366] */
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|366
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_yday
argument_list|)
expr_stmt|;
name|t
operator|->
name|tm
operator|.
name|tm_yday
operator|--
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* extended day of month [1-9, 01-31] */
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
argument_list|,
operator|(
name|ISDIGIT
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|)
operator|&&
name|ISDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|)
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|31
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_mday
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* hour [00-23 followed by optional fraction] */
block|{
name|int
name|frac
decl_stmt|;
name|s
operator|=
name|parse_decimal
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|23
argument_list|,
literal|60
operator|*
literal|60
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_hour
argument_list|,
operator|&
name|frac
argument_list|)
expr_stmt|;
name|t
operator|->
name|tm
operator|.
name|tm_min
operator|=
name|frac
operator|/
literal|60
expr_stmt|;
name|t
operator|->
name|tm
operator|.
name|tm_sec
operator|=
name|frac
operator|%
literal|60
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
comment|/* minute [00-59 followed by optional fraction] */
name|s
operator|=
name|parse_decimal
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|59
argument_list|,
literal|60
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_min
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_sec
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* month name [e.g. "Jan"] */
if|if
condition|(
operator|!
name|TM_DEFINED
argument_list|(
name|t
operator|->
name|tm
operator|.
name|tm_mon
operator|=
name|lookup
argument_list|(
name|s
argument_list|,
name|month_names
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Don't bother to check rest of spelling.  */
while|while
condition|(
name|ISALPHA
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* month [01-12] */
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_mon
argument_list|)
expr_stmt|;
name|t
operator|->
name|tm
operator|.
name|tm_mon
operator|--
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* year % 10 (remainder in origin-0 decade) [0-9] */
name|s
operator|=
name|parse_fixed
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_year
argument_list|)
expr_stmt|;
name|t
operator|->
name|ymodulus
operator|=
literal|10
expr_stmt|;
break|break;
name|case_R
label|:
case|case
literal|'R'
case|:
comment|/* year % 100 (remainder in origin-0 century) [00-99] */
name|s
operator|=
name|parse_fixed
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_year
argument_list|)
expr_stmt|;
name|t
operator|->
name|ymodulus
operator|=
literal|100
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* second [00-60 followed by optional fraction] */
block|{
name|int
name|frac
decl_stmt|;
name|s
operator|=
name|parse_decimal
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|60
argument_list|,
literal|1
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_sec
argument_list|,
operator|&
name|frac
argument_list|)
expr_stmt|;
name|t
operator|->
name|tm
operator|.
name|tm_sec
operator|+=
name|frac
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
comment|/* 'T' or 't' */
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'T'
case|:
case|case
literal|'t'
case|:
break|break;
default|default:
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'t'
case|:
comment|/* traditional hour [1-9 or 01-12] */
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
argument_list|,
operator|(
name|ISDIGIT
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|)
operator|&&
name|ISDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|)
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_hour
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* 'W' or 'w' only (stands for current week) */
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'W'
case|:
case|case
literal|'w'
case|:
break|break;
default|default:
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'W'
case|:
comment|/* 'W' or 'w', followed by a week of year [00-53] */
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'W'
case|:
case|case
literal|'w'
case|:
break|break;
default|default:
return|return
literal|0
return|;
block|}
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|53
argument_list|,
operator|&
name|t
operator|->
name|yweek
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* weekday (1=Mon ... 7=Sun) [1-7] */
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|7
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_wday
argument_list|)
expr_stmt|;
name|t
operator|->
name|tm
operator|.
name|tm_wday
operator|--
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* weekday name [e.g. "Sun"] */
if|if
condition|(
operator|!
name|TM_DEFINED
argument_list|(
name|t
operator|->
name|tm
operator|.
name|tm_wday
operator|=
name|lookup
argument_list|(
name|s
argument_list|,
name|weekday_names
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Don't bother to check rest of spelling.  */
while|while
condition|(
name|ISALPHA
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
comment|/* either R or Y */
if|if
condition|(
name|ISDIGIT
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|)
operator|&&
name|ISDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|ISDIGIT
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
condition|)
goto|goto
name|case_R
goto|;
comment|/* fall into */
case|case
literal|'Y'
case|:
comment|/* year in full [4 or more digits] */
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
name|s
index|[
name|len
index|]
argument_list|)
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|4
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|parse_fixed
argument_list|(
name|s
argument_list|,
name|len
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_year
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'Z'
case|:
comment|/* time zone */
name|s
operator|=
name|parzone
argument_list|(
name|s
argument_list|,
operator|&
name|t
operator|->
name|zone
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
comment|/* possibly empty sequence of non-alphanumerics */
while|while
condition|(
operator|!
name|ISALNUM
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* bad pattern */
return|return
literal|0
return|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* If there is no conflict, merge into *T the additional information in *U    and return 0.  Otherwise do nothing and return -1.  */
end_comment

begin_function
specifier|static
name|int
name|merge_partime
parameter_list|(
name|t
parameter_list|,
name|u
parameter_list|)
name|struct
name|partime
modifier|*
name|t
decl_stmt|;
name|struct
name|partime
specifier|const
modifier|*
name|u
decl_stmt|;
block|{
define|#
directive|define
name|conflict
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a) != (b)&&  TM_DEFINED (a)&&  TM_DEFINED (b))
if|if
condition|(
name|conflict
argument_list|(
name|t
operator|->
name|tm
operator|.
name|tm_sec
argument_list|,
name|u
operator|->
name|tm
operator|.
name|tm_sec
argument_list|)
operator|||
name|conflict
argument_list|(
name|t
operator|->
name|tm
operator|.
name|tm_min
argument_list|,
name|u
operator|->
name|tm
operator|.
name|tm_min
argument_list|)
operator|||
name|conflict
argument_list|(
name|t
operator|->
name|tm
operator|.
name|tm_hour
argument_list|,
name|u
operator|->
name|tm
operator|.
name|tm_hour
argument_list|)
operator|||
name|conflict
argument_list|(
name|t
operator|->
name|tm
operator|.
name|tm_mday
argument_list|,
name|u
operator|->
name|tm
operator|.
name|tm_mday
argument_list|)
operator|||
name|conflict
argument_list|(
name|t
operator|->
name|tm
operator|.
name|tm_mon
argument_list|,
name|u
operator|->
name|tm
operator|.
name|tm_mon
argument_list|)
operator|||
name|conflict
argument_list|(
name|t
operator|->
name|tm
operator|.
name|tm_year
argument_list|,
name|u
operator|->
name|tm
operator|.
name|tm_year
argument_list|)
operator|||
name|conflict
argument_list|(
name|t
operator|->
name|tm
operator|.
name|tm_wday
argument_list|,
name|u
operator|->
name|tm
operator|.
name|tm_yday
argument_list|)
operator|||
name|conflict
argument_list|(
name|t
operator|->
name|ymodulus
argument_list|,
name|u
operator|->
name|ymodulus
argument_list|)
operator|||
name|conflict
argument_list|(
name|t
operator|->
name|yweek
argument_list|,
name|u
operator|->
name|yweek
argument_list|)
operator|||
operator|(
name|t
operator|->
name|zone
operator|!=
name|u
operator|->
name|zone
operator|&&
name|t
operator|->
name|zone
operator|!=
name|TM_UNDEFINED_ZONE
operator|&&
name|u
operator|->
name|zone
operator|!=
name|TM_UNDEFINED_ZONE
operator|)
condition|)
return|return
operator|-
literal|1
return|;
undef|#
directive|undef
name|conflict
define|#
directive|define
name|merge_
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|if (TM_DEFINED (b)) (a) = (b);
name|merge_
argument_list|(
argument|t->tm.tm_sec
argument_list|,
argument|u->tm.tm_sec
argument_list|)
name|merge_
argument_list|(
argument|t->tm.tm_min
argument_list|,
argument|u->tm.tm_min
argument_list|)
name|merge_
argument_list|(
argument|t->tm.tm_hour
argument_list|,
argument|u->tm.tm_hour
argument_list|)
name|merge_
argument_list|(
argument|t->tm.tm_mday
argument_list|,
argument|u->tm.tm_mday
argument_list|)
name|merge_
argument_list|(
argument|t->tm.tm_mon
argument_list|,
argument|u->tm.tm_mon
argument_list|)
name|merge_
argument_list|(
argument|t->tm.tm_year
argument_list|,
argument|u->tm.tm_year
argument_list|)
name|merge_
argument_list|(
argument|t->tm.tm_wday
argument_list|,
argument|u->tm.tm_yday
argument_list|)
name|merge_
argument_list|(
argument|t->ymodulus
argument_list|,
argument|u->ymodulus
argument_list|)
name|merge_
argument_list|(
argument|t->yweek
argument_list|,
argument|u->yweek
argument_list|)
undef|#
directive|undef
name|merge_
if|if
condition|(
name|u
operator|->
name|zone
operator|!=
name|TM_UNDEFINED_ZONE
condition|)
name|t
operator|->
name|zone
operator|=
name|u
operator|->
name|zone
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parse a date/time prefix of S, putting the parsed result into *T.    Return the first character after the prefix.    The prefix may contain no useful information;    in that case, *T will contain only undefined values.  */
end_comment

begin_function
name|char
modifier|*
name|partime
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|struct
name|partime
modifier|*
name|t
decl_stmt|;
block|{
name|struct
name|partime
name|p
decl_stmt|;
name|undefine
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
specifier|const
modifier|*
name|s1
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|s1
operator|=
name|parse_prefix
argument_list|(
name|s
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
do|while
condition|(
name|merge_partime
argument_list|(
name|t
argument_list|,
operator|&
name|p
argument_list|)
operator|!=
literal|0
condition|)
do|;
name|s
operator|=
name|s1
expr_stmt|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
end_function

end_unit

