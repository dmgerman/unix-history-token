begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000, Boris Popov  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    This product includes software developed by Boris Popov.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: rap.c,v 1.8 2001/02/24 15:56:05 bp Exp $  * $FreeBSD$  *  * This is very simple implementation of RAP protocol.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb_lib.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb_conn.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb_rap.h>
end_include

begin_comment
comment|/*#include<sys/ioctl.h>*/
end_comment

begin_function
specifier|static
name|int
name|smb_rap_parserqparam
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
modifier|*
name|next
parameter_list|,
name|int
modifier|*
name|rlen
parameter_list|)
block|{
name|char
modifier|*
name|np
decl_stmt|;
name|int
name|len
decl_stmt|,
name|m
decl_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'L'
case|:
case|case
literal|'T'
case|:
case|case
literal|'W'
case|:
name|len
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
case|case
literal|'O'
case|:
name|len
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'F'
case|:
name|len
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
name|len
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|len
operator|*=
name|strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|np
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|s
operator|=
name|np
expr_stmt|;
block|}
operator|*
name|rlen
operator|=
name|len
expr_stmt|;
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|next
operator|=
name|s
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_rap_parserpparam
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
modifier|*
name|next
parameter_list|,
name|int
modifier|*
name|rlen
parameter_list|)
block|{
name|char
modifier|*
name|np
decl_stmt|;
name|int
name|len
decl_stmt|,
name|m
decl_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'h'
case|:
name|len
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|len
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|len
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|len
operator|*=
name|strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|np
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|s
operator|=
name|np
expr_stmt|;
block|}
operator|*
name|rlen
operator|=
name|len
expr_stmt|;
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|next
operator|=
name|s
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_rap_parserpdata
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
modifier|*
name|next
parameter_list|,
name|int
modifier|*
name|rlen
parameter_list|)
block|{
name|char
modifier|*
name|np
decl_stmt|;
name|int
name|len
decl_stmt|,
name|m
decl_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'B'
case|:
name|len
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|len
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
case|case
literal|'O'
case|:
case|case
literal|'z'
case|:
name|len
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|len
operator|*=
name|strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|np
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|s
operator|=
name|np
expr_stmt|;
block|}
operator|*
name|rlen
operator|=
name|len
expr_stmt|;
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|next
operator|=
name|s
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_rap_rqparam_z
parameter_list|(
name|struct
name|smb_rap
modifier|*
name|rap
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|1
decl_stmt|;
name|bcopy
argument_list|(
name|value
argument_list|,
name|rap
operator|->
name|r_npbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|rap
operator|->
name|r_npbuf
operator|+=
name|len
expr_stmt|;
name|rap
operator|->
name|r_plen
operator|+=
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_rap_rqparam
parameter_list|(
name|struct
name|smb_rap
modifier|*
name|rap
parameter_list|,
name|char
name|ptype
parameter_list|,
name|char
name|plen
parameter_list|,
name|long
name|value
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|rap
operator|->
name|r_npbuf
decl_stmt|;
name|int
name|len
decl_stmt|;
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
literal|'L'
case|:
case|case
literal|'W'
case|:
name|setwle
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|setdle
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|len
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|memset
argument_list|(
name|p
argument_list|,
name|value
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|len
operator|=
name|plen
expr_stmt|;
default|default:
return|return
name|EINVAL
return|;
block|}
name|rap
operator|->
name|r_npbuf
operator|+=
name|len
expr_stmt|;
name|rap
operator|->
name|r_plen
operator|+=
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|smb_rap_create
parameter_list|(
name|int
name|fn
parameter_list|,
specifier|const
name|char
modifier|*
name|param
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|smb_rap
modifier|*
modifier|*
name|rapp
parameter_list|)
block|{
name|struct
name|smb_rap
modifier|*
name|rap
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|plen
decl_stmt|,
name|len
decl_stmt|;
name|rap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rap
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|bzero
argument_list|(
name|rap
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rap
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|rap
operator|->
name|r_sparam
operator|=
name|rap
operator|->
name|r_nparam
operator|=
name|strdup
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|rap
operator|->
name|r_sdata
operator|=
name|rap
operator|->
name|r_ndata
operator|=
name|strdup
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate length of request parameter block 	 */
name|len
operator|=
literal|2
operator|+
name|strlen
argument_list|(
name|param
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|smb_rap_parserqparam
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|plen
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|len
operator|+=
name|plen
expr_stmt|;
block|}
name|rap
operator|->
name|r_pbuf
operator|=
name|rap
operator|->
name|r_npbuf
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|smb_rap_rqparam
argument_list|(
name|rap
argument_list|,
literal|'W'
argument_list|,
literal|1
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|smb_rap_rqparam_z
argument_list|(
name|rap
argument_list|,
name|rap
operator|->
name|r_sparam
argument_list|)
expr_stmt|;
name|smb_rap_rqparam_z
argument_list|(
name|rap
argument_list|,
name|rap
operator|->
name|r_sdata
argument_list|)
expr_stmt|;
operator|*
name|rapp
operator|=
name|rap
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|smb_rap_done
parameter_list|(
name|struct
name|smb_rap
modifier|*
name|rap
parameter_list|)
block|{
if|if
condition|(
name|rap
operator|->
name|r_sparam
condition|)
name|free
argument_list|(
name|rap
operator|->
name|r_sparam
argument_list|)
expr_stmt|;
if|if
condition|(
name|rap
operator|->
name|r_sdata
condition|)
name|free
argument_list|(
name|rap
operator|->
name|r_sdata
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|smb_rap_setNparam
parameter_list|(
name|struct
name|smb_rap
modifier|*
name|rap
parameter_list|,
name|long
name|value
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|rap
operator|->
name|r_nparam
decl_stmt|;
name|char
name|ptype
init|=
operator|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|,
name|plen
decl_stmt|;
name|error
operator|=
name|smb_rap_parserqparam
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
literal|'L'
case|:
name|rap
operator|->
name|r_rcvbuflen
operator|=
name|value
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'W'
case|:
case|case
literal|'D'
case|:
case|case
literal|'b'
case|:
name|error
operator|=
name|smb_rap_rqparam
argument_list|(
name|rap
argument_list|,
name|ptype
argument_list|,
name|plen
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
name|rap
operator|->
name|r_nparam
operator|=
name|p
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|smb_rap_setPparam
parameter_list|(
name|struct
name|smb_rap
modifier|*
name|rap
parameter_list|,
name|void
modifier|*
name|value
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|rap
operator|->
name|r_nparam
decl_stmt|;
name|char
name|ptype
init|=
operator|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|,
name|plen
decl_stmt|;
name|error
operator|=
name|smb_rap_parserqparam
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
literal|'r'
case|:
name|rap
operator|->
name|r_rcvbuf
operator|=
name|value
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
name|rap
operator|->
name|r_nparam
operator|=
name|p
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_rap_getNparam
parameter_list|(
name|struct
name|smb_rap
modifier|*
name|rap
parameter_list|,
name|long
modifier|*
name|value
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|rap
operator|->
name|r_nparam
decl_stmt|;
name|char
name|ptype
init|=
operator|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|,
name|plen
decl_stmt|;
name|error
operator|=
name|smb_rap_parserpparam
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
literal|'h'
case|:
operator|*
name|value
operator|=
name|le16toh
argument_list|(
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|rap
operator|->
name|r_npbuf
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
name|rap
operator|->
name|r_npbuf
operator|+=
name|plen
expr_stmt|;
name|rap
operator|->
name|r_nparam
operator|=
name|p
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|smb_rap_request
parameter_list|(
name|struct
name|smb_rap
modifier|*
name|rap
parameter_list|,
name|struct
name|smb_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|u_int16_t
modifier|*
name|rp
decl_stmt|,
name|conv
decl_stmt|;
name|u_int32_t
modifier|*
name|p32
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|,
modifier|*
name|p
init|=
name|rap
operator|->
name|r_nparam
decl_stmt|;
name|char
name|ptype
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rdatacnt
decl_stmt|,
name|rparamcnt
decl_stmt|,
name|entries
decl_stmt|,
name|done
decl_stmt|,
name|dlen
decl_stmt|;
name|rdatacnt
operator|=
name|rap
operator|->
name|r_rcvbuflen
expr_stmt|;
name|rparamcnt
operator|=
name|rap
operator|->
name|r_plen
expr_stmt|;
name|error
operator|=
name|smb_t2_request
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\\PIPE\\LANMAN"
argument_list|,
name|rap
operator|->
name|r_plen
argument_list|,
name|rap
operator|->
name|r_pbuf
argument_list|,
comment|/* int tparamcnt, void *tparam */
literal|0
argument_list|,
name|NULL
argument_list|,
comment|/* int tdatacnt, void *tdata */
operator|&
name|rparamcnt
argument_list|,
name|rap
operator|->
name|r_pbuf
argument_list|,
comment|/* rparamcnt, void *rparam */
operator|&
name|rdatacnt
argument_list|,
name|rap
operator|->
name|r_rcvbuf
comment|/* int *rdatacnt, void *rdata */
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|rp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|rap
operator|->
name|r_pbuf
expr_stmt|;
name|rap
operator|->
name|r_result
operator|=
name|le16toh
argument_list|(
operator|*
name|rp
operator|++
argument_list|)
expr_stmt|;
name|conv
operator|=
name|le16toh
argument_list|(
operator|*
name|rp
operator|++
argument_list|)
expr_stmt|;
name|rap
operator|->
name|r_npbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|rp
expr_stmt|;
name|rap
operator|->
name|r_entries
operator|=
name|entries
operator|=
literal|0
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
operator|*
name|p
condition|)
block|{
name|ptype
operator|=
operator|*
name|p
expr_stmt|;
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
literal|'e'
case|:
name|rap
operator|->
name|r_entries
operator|=
name|entries
operator|=
name|le16toh
argument_list|(
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|rap
operator|->
name|r_npbuf
argument_list|)
expr_stmt|;
name|rap
operator|->
name|r_npbuf
operator|+=
literal|2
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
default|default:
name|done
operator|=
literal|1
expr_stmt|;
block|}
comment|/*		error = smb_rap_parserpparam(p,&p,&plen); 		if (error) { 			smb_error("reply parameter mismath %s", 0, p); 			return EBADRPC; 		}*/
block|}
name|rap
operator|->
name|r_nparam
operator|=
name|p
expr_stmt|;
comment|/* 	 * In general, unpacking entries we may need to relocate 	 * entries for proper alingning. For now use them as is. 	 */
name|dp
operator|=
name|rap
operator|->
name|r_rcvbuf
expr_stmt|;
while|while
condition|(
name|entries
operator|--
condition|)
block|{
name|p
operator|=
name|rap
operator|->
name|r_sdata
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|ptype
operator|=
operator|*
name|p
expr_stmt|;
name|error
operator|=
name|smb_rap_parserpdata
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|dlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|smb_error
argument_list|(
literal|"reply data mismath %s"
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|EBADRPC
return|;
block|}
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
literal|'z'
case|:
name|p32
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|dp
expr_stmt|;
operator|*
name|p32
operator|=
operator|(
operator|*
name|p32
operator|&
literal|0xffff
operator|)
operator|-
name|conv
expr_stmt|;
break|break;
block|}
name|dp
operator|+=
name|dlen
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|smb_rap_error
parameter_list|(
name|struct
name|smb_rap
modifier|*
name|rap
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|rap
operator|->
name|r_result
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|rap
operator|->
name|r_result
operator||
name|SMB_RAP_ERROR
return|;
block|}
end_function

begin_function
name|int
name|smb_rap_NetShareEnum
parameter_list|(
name|struct
name|smb_ctx
modifier|*
name|ctx
parameter_list|,
name|int
name|sLevel
parameter_list|,
name|void
modifier|*
name|pbBuffer
parameter_list|,
name|int
name|cbBuffer
parameter_list|,
name|int
modifier|*
name|pcEntriesRead
parameter_list|,
name|int
modifier|*
name|pcTotalAvail
parameter_list|)
block|{
name|struct
name|smb_rap
modifier|*
name|rap
decl_stmt|;
name|long
name|lval
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|smb_rap_create
argument_list|(
literal|0
argument_list|,
literal|"WrLeh"
argument_list|,
literal|"B13BWz"
argument_list|,
operator|&
name|rap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|smb_rap_setNparam
argument_list|(
name|rap
argument_list|,
name|sLevel
argument_list|)
expr_stmt|;
comment|/* W - sLevel */
name|smb_rap_setPparam
argument_list|(
name|rap
argument_list|,
name|pbBuffer
argument_list|)
expr_stmt|;
comment|/* r - pbBuffer */
name|smb_rap_setNparam
argument_list|(
name|rap
argument_list|,
name|cbBuffer
argument_list|)
expr_stmt|;
comment|/* L - cbBuffer */
name|error
operator|=
name|smb_rap_request
argument_list|(
name|rap
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|pcEntriesRead
operator|=
name|rap
operator|->
name|r_entries
expr_stmt|;
name|error
operator|=
name|smb_rap_getNparam
argument_list|(
name|rap
argument_list|,
operator|&
name|lval
argument_list|)
expr_stmt|;
operator|*
name|pcTotalAvail
operator|=
name|lval
expr_stmt|;
block|}
name|error
operator|=
name|smb_rap_error
argument_list|(
name|rap
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|smb_rap_done
argument_list|(
name|rap
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

end_unit

