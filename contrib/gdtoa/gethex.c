begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************  The author of this software is David M. Gay.  Copyright (C) 1998 by Lucent Technologies All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name of Lucent or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ****************************************************************/
end_comment

begin_comment
comment|/* Please send bug reports to David M. Gay (dmg at acm dot org,  * with " at " changed at "@" and " dot " changed to ".").	*/
end_comment

begin_include
include|#
directive|include
file|"gdtoaimp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LOCALE
end_ifdef

begin_include
include|#
directive|include
file|"locale.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|gethex
parameter_list|(
name|sp
parameter_list|,
name|fpi
parameter_list|,
name|exp
parameter_list|,
name|bp
parameter_list|,
name|sign
parameter_list|)
name|CONST
name|char
modifier|*
modifier|*
name|sp
decl_stmt|;
name|FPI
modifier|*
name|fpi
decl_stmt|;
name|Long
modifier|*
name|exp
decl_stmt|;
name|Bigint
modifier|*
modifier|*
name|bp
decl_stmt|;
name|int
name|sign
decl_stmt|;
else|#
directive|else
function|gethex
parameter_list|(
name|CONST
name|char
modifier|*
modifier|*
name|sp
parameter_list|,
name|FPI
modifier|*
name|fpi
parameter_list|,
name|Long
modifier|*
name|exp
parameter_list|,
name|Bigint
modifier|*
modifier|*
name|bp
parameter_list|,
name|int
name|sign
parameter_list|)
endif|#
directive|endif
block|{
name|Bigint
modifier|*
name|b
decl_stmt|;
name|CONST
name|unsigned
name|char
modifier|*
name|decpt
decl_stmt|,
modifier|*
name|s0
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
name|int
name|esign
decl_stmt|,
name|havedig
decl_stmt|,
name|irv
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|,
name|nbits
decl_stmt|,
name|up
decl_stmt|,
name|zret
decl_stmt|;
name|ULong
name|L
decl_stmt|,
name|lostbits
decl_stmt|,
modifier|*
name|x
decl_stmt|;
name|Long
name|e
decl_stmt|,
name|e1
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_LOCALE
name|unsigned
name|char
name|decimalpoint
init|=
operator|*
name|localeconv
argument_list|()
operator|->
name|decimal_point
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|decimalpoint
value|'.'
endif|#
directive|endif
if|if
condition|(
operator|!
name|hexdig
index|[
literal|'0'
index|]
condition|)
name|hexdig_init_D2A
argument_list|()
expr_stmt|;
name|havedig
operator|=
literal|0
expr_stmt|;
name|s0
operator|=
operator|*
operator|(
name|CONST
name|unsigned
name|char
operator|*
operator|*
operator|)
name|sp
operator|+
literal|2
expr_stmt|;
while|while
condition|(
name|s0
index|[
name|havedig
index|]
operator|==
literal|'0'
condition|)
name|havedig
operator|++
expr_stmt|;
name|s0
operator|+=
name|havedig
expr_stmt|;
name|s
operator|=
name|s0
expr_stmt|;
name|decpt
operator|=
literal|0
expr_stmt|;
name|zret
operator|=
literal|0
expr_stmt|;
name|e
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|hexdig
index|[
operator|*
name|s
index|]
condition|)
block|{
name|zret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
name|decimalpoint
condition|)
goto|goto
name|pcheck
goto|;
name|decpt
operator|=
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|hexdig
index|[
operator|*
name|s
index|]
condition|)
goto|goto
name|pcheck
goto|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'0'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|hexdig
index|[
operator|*
name|s
index|]
condition|)
name|zret
operator|=
literal|0
expr_stmt|;
name|havedig
operator|=
literal|1
expr_stmt|;
name|s0
operator|=
name|s
expr_stmt|;
block|}
while|while
condition|(
name|hexdig
index|[
operator|*
name|s
index|]
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|decimalpoint
operator|&&
operator|!
name|decpt
condition|)
block|{
name|decpt
operator|=
operator|++
name|s
expr_stmt|;
while|while
condition|(
name|hexdig
index|[
operator|*
name|s
index|]
condition|)
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|decpt
condition|)
name|e
operator|=
operator|-
operator|(
operator|(
call|(
name|Long
call|)
argument_list|(
name|s
operator|-
name|decpt
argument_list|)
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|pcheck
label|:
name|s1
operator|=
name|s
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|esign
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
operator|++
name|s
condition|)
block|{
case|case
literal|'-'
case|:
name|esign
operator|=
literal|1
expr_stmt|;
comment|/* no break */
case|case
literal|'+'
case|:
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|hexdig
index|[
operator|*
name|s
index|]
operator|)
operator|==
literal|0
operator|||
name|n
operator|>
literal|0x19
condition|)
block|{
name|s
operator|=
name|s1
expr_stmt|;
break|break;
block|}
name|e1
operator|=
name|n
operator|-
literal|0x10
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|hexdig
index|[
operator|*
operator|++
name|s
index|]
operator|)
operator|!=
literal|0
operator|&&
name|n
operator|<=
literal|0x19
condition|)
name|e1
operator|=
literal|10
operator|*
name|e1
operator|+
name|n
operator|-
literal|0x10
expr_stmt|;
if|if
condition|(
name|esign
condition|)
name|e1
operator|=
operator|-
name|e1
expr_stmt|;
name|e
operator|+=
name|e1
expr_stmt|;
block|}
operator|*
name|sp
operator|=
operator|(
name|char
operator|*
operator|)
name|s
expr_stmt|;
if|if
condition|(
name|zret
condition|)
return|return
name|havedig
condition|?
name|STRTOG_Zero
else|:
name|STRTOG_NoNumber
return|;
name|n
operator|=
name|s1
operator|-
name|s0
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|n
operator|>
literal|7
condition|;
name|n
operator|>>=
literal|1
control|)
name|k
operator|++
expr_stmt|;
name|b
operator|=
name|Balloc
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|x
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|L
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|s1
operator|>
name|s0
condition|)
block|{
if|if
condition|(
operator|*
operator|--
name|s1
operator|==
name|decimalpoint
condition|)
continue|continue;
if|if
condition|(
name|n
operator|==
literal|32
condition|)
block|{
operator|*
name|x
operator|++
operator|=
name|L
expr_stmt|;
name|L
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
name|L
operator||=
operator|(
name|hexdig
index|[
operator|*
name|s1
index|]
operator|&
literal|0x0f
operator|)
operator|<<
name|n
expr_stmt|;
name|n
operator|+=
literal|4
expr_stmt|;
block|}
operator|*
name|x
operator|++
operator|=
name|L
expr_stmt|;
name|b
operator|->
name|wds
operator|=
name|n
operator|=
name|x
operator|-
name|b
operator|->
name|x
expr_stmt|;
name|n
operator|=
literal|32
operator|*
name|n
operator|-
name|hi0bits
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|nbits
operator|=
name|fpi
operator|->
name|nbits
expr_stmt|;
name|lostbits
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|b
operator|->
name|x
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|nbits
condition|)
block|{
name|n
operator|-=
name|nbits
expr_stmt|;
if|if
condition|(
name|any_on
argument_list|(
name|b
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|lostbits
operator|=
literal|1
expr_stmt|;
name|k
operator|=
name|n
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|x
index|[
name|k
operator|>>
name|kshift
index|]
operator|&
literal|1
operator|<<
operator|(
name|k
operator|&
name|kmask
operator|)
condition|)
block|{
name|lostbits
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|1
operator|&&
name|any_on
argument_list|(
name|b
argument_list|,
name|k
operator|-
literal|1
argument_list|)
condition|)
name|lostbits
operator|=
literal|3
expr_stmt|;
block|}
block|}
name|rshift
argument_list|(
name|b
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|e
operator|+=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|<
name|nbits
condition|)
block|{
name|n
operator|=
name|nbits
operator|-
name|n
expr_stmt|;
name|b
operator|=
name|lshift
argument_list|(
name|b
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|e
operator|-=
name|n
expr_stmt|;
name|x
operator|=
name|b
operator|->
name|x
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|>
name|fpi
operator|->
name|emax
condition|)
block|{
name|ovfl
label|:
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
return|return
name|STRTOG_Infinite
operator||
name|STRTOG_Overflow
operator||
name|STRTOG_Inexhi
return|;
block|}
name|irv
operator|=
name|STRTOG_Normal
expr_stmt|;
if|if
condition|(
name|e
operator|<
name|fpi
operator|->
name|emin
condition|)
block|{
name|irv
operator|=
name|STRTOG_Denormal
expr_stmt|;
name|n
operator|=
name|fpi
operator|->
name|emin
operator|-
name|e
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|nbits
condition|)
block|{
switch|switch
condition|(
name|fpi
operator|->
name|rounding
condition|)
block|{
case|case
name|FPI_Round_near
case|:
if|if
condition|(
name|n
operator|==
name|nbits
operator|&&
operator|(
name|n
operator|<
literal|2
operator|||
name|any_on
argument_list|(
name|b
argument_list|,
name|n
operator|-
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|one_bit
goto|;
break|break;
case|case
name|FPI_Round_up
case|:
if|if
condition|(
operator|!
name|sign
condition|)
goto|goto
name|one_bit
goto|;
break|break;
case|case
name|FPI_Round_down
case|:
if|if
condition|(
name|sign
condition|)
block|{
name|one_bit
label|:
operator|*
name|exp
operator|=
name|fpi
operator|->
name|emin
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|=
name|b
operator|->
name|wds
operator|=
literal|1
expr_stmt|;
operator|*
name|bp
operator|=
name|b
expr_stmt|;
return|return
name|STRTOG_Denormal
operator||
name|STRTOG_Inexhi
operator||
name|STRTOG_Underflow
return|;
block|}
block|}
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
return|return
name|STRTOG_Zero
operator||
name|STRTOG_Inexlo
operator||
name|STRTOG_Underflow
return|;
block|}
name|k
operator|=
name|n
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lostbits
condition|)
name|lostbits
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|>
literal|0
condition|)
name|lostbits
operator|=
name|any_on
argument_list|(
name|b
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
index|[
name|k
operator|>>
name|kshift
index|]
operator|&
literal|1
operator|<<
operator|(
name|k
operator|&
name|kmask
operator|)
condition|)
name|lostbits
operator||=
literal|2
expr_stmt|;
name|nbits
operator|-=
name|n
expr_stmt|;
name|rshift
argument_list|(
name|b
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|e
operator|=
name|fpi
operator|->
name|emin
expr_stmt|;
block|}
if|if
condition|(
name|lostbits
condition|)
block|{
name|up
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|fpi
operator|->
name|rounding
condition|)
block|{
case|case
name|FPI_Round_zero
case|:
break|break;
case|case
name|FPI_Round_near
case|:
if|if
condition|(
name|lostbits
operator|&
literal|2
operator|&&
operator|(
name|lostbits
operator|&
literal|1
operator|)
operator||
name|x
index|[
literal|0
index|]
operator|&
literal|1
condition|)
name|up
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|FPI_Round_up
case|:
name|up
operator|=
literal|1
operator|-
name|sign
expr_stmt|;
break|break;
case|case
name|FPI_Round_down
case|:
name|up
operator|=
name|sign
expr_stmt|;
block|}
if|if
condition|(
name|up
condition|)
block|{
name|k
operator|=
name|b
operator|->
name|wds
expr_stmt|;
name|b
operator|=
name|increment
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|x
operator|=
name|b
operator|->
name|x
expr_stmt|;
if|if
condition|(
name|irv
operator|==
name|STRTOG_Denormal
condition|)
block|{
if|if
condition|(
name|nbits
operator|==
name|fpi
operator|->
name|nbits
operator|-
literal|1
operator|&&
name|x
index|[
name|nbits
operator|>>
name|kshift
index|]
operator|&
literal|1
operator|<<
operator|(
name|nbits
operator|&
name|kmask
operator|)
condition|)
name|irv
operator|=
name|STRTOG_Normal
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|wds
operator|>
name|k
operator|||
operator|(
name|n
operator|=
name|nbits
operator|&
name|kmask
operator|)
operator|!=
literal|0
operator|&&
name|hi0bits
argument_list|(
name|x
index|[
name|k
operator|-
literal|1
index|]
argument_list|)
operator|<
literal|32
operator|-
name|n
condition|)
block|{
name|rshift
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|e
operator|>
name|fpi
operator|->
name|emax
condition|)
goto|goto
name|ovfl
goto|;
block|}
name|irv
operator||=
name|STRTOG_Inexhi
expr_stmt|;
block|}
else|else
name|irv
operator||=
name|STRTOG_Inexlo
expr_stmt|;
block|}
operator|*
name|bp
operator|=
name|b
expr_stmt|;
operator|*
name|exp
operator|=
name|e
expr_stmt|;
return|return
name|irv
return|;
block|}
end_function

end_unit

