begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************  The author of this software is David M. Gay.  Copyright (C) 1998-2001 by Lucent Technologies All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name of Lucent or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ****************************************************************/
end_comment

begin_comment
comment|/* Please send bug reports to David M. Gay (dmg at acm dot org,  * with " at " changed at "@" and " dot " changed to ".").	*/
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"gdtoaimp.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_FENV_H
end_ifndef

begin_include
include|#
directive|include
file|<fenv.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LOCALE
end_ifdef

begin_include
include|#
directive|include
file|"locale.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_Arith
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|NO_IEEE_Scale
end_ifndef

begin_define
define|#
directive|define
name|Avoid_Underflow
end_define

begin_undef
undef|#
directive|undef
name|tinytens
end_undef

begin_comment
comment|/* The factor of 2^106 in tinytens[4] helps us avoid setting the underflow */
end_comment

begin_comment
comment|/* flag unnecessarily.  It leads to a song and dance at the end of strtod. */
end_comment

begin_decl_stmt
specifier|static
name|CONST
name|double
name|tinytens
index|[]
init|=
block|{
literal|1e-16
block|,
literal|1e-32
block|,
literal|1e-64
block|,
literal|1e-128
block|,
literal|9007199254740992.
operator|*
literal|9007199254740992.e-256
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
end_ifdef

begin_undef
undef|#
directive|undef
name|Check_FLT_ROUNDS
end_undef

begin_define
define|#
directive|define
name|Check_FLT_ROUNDS
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Rounding
value|Flt_Rounds
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|Avoid_Underflow
end_ifdef

begin_comment
comment|/*{*/
end_comment

begin_decl_stmt
specifier|static
name|double
name|sulp
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|x
argument_list|,
name|scale
argument_list|)
name|U
modifier|*
name|x
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scale
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|U
operator|*
name|x
operator|,
name|int
name|scale
operator|)
endif|#
directive|endif
block|{
name|U
name|u
block|;
name|double
name|rv
block|;
name|int
name|i
block|;
name|rv
operator|=
name|ulp
argument_list|(
name|x
argument_list|)
block|;
if|if
condition|(
operator|!
name|scale
operator|||
operator|(
name|i
operator|=
literal|2
operator|*
name|P
operator|+
literal|1
operator|-
operator|(
operator|(
name|word0
argument_list|(
name|x
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>>
name|Exp_shift
operator|)
operator|)
operator|<=
literal|0
condition|)
return|return
name|rv
return|;
comment|/* Is there an example where i<= 0 ? */
name|word0
argument_list|(
operator|&
name|u
argument_list|)
operator|=
name|Exp_1
operator|+
operator|(
name|i
operator|<<
name|Exp_shift
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|word1
argument_list|(
operator|&
name|u
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|rv
operator|*
name|u
operator|.
name|d
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/*}*/
end_comment

begin_macro
unit|double
name|strtod
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
argument|s00
argument_list|,
argument|se
argument_list|)
end_macro

begin_decl_stmt
name|CONST
name|char
modifier|*
name|s00
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|se
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|CONST
name|char
operator|*
name|s00
operator|,
name|char
operator|*
operator|*
name|se
operator|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|Avoid_Underflow
name|int
name|scale
block|;
endif|#
directive|endif
name|int
name|bb2
block|,
name|bb5
block|,
name|bbe
block|,
name|bd2
block|,
name|bd5
block|,
name|bbbits
block|,
name|bs2
block|,
name|c
block|,
name|decpt
block|,
name|dsign
block|,
name|e
block|,
name|e1
block|,
name|esign
block|,
name|i
block|,
name|j
block|,
name|k
block|,
name|nd
block|,
name|nd0
block|,
name|nf
block|,
name|nz
block|,
name|nz0
block|,
name|sign
block|;
name|CONST
name|char
operator|*
name|s
block|,
operator|*
name|s0
block|,
operator|*
name|s1
block|;
name|double
name|aadj
block|;
name|Long
name|L
block|;
name|U
name|adj
block|,
name|aadj1
block|,
name|rv
block|,
name|rv0
block|;
name|ULong
name|y
block|,
name|z
block|;
name|Bigint
operator|*
name|bb
block|,
operator|*
name|bb1
block|,
operator|*
name|bd
block|,
operator|*
name|bd0
block|,
operator|*
name|bs
block|,
operator|*
name|delta
block|;
ifdef|#
directive|ifdef
name|Avoid_Underflow
name|ULong
name|Lsb
block|,
name|Lsb1
block|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SET_INEXACT
name|int
name|inexact
block|,
name|oldinexact
block|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_LOCALE
comment|/*{{*/
ifdef|#
directive|ifdef
name|NO_LOCALE_CACHE
name|char
operator|*
name|decimalpoint
operator|=
name|localeconv
argument_list|()
operator|->
name|decimal_point
block|;
name|int
name|dplen
operator|=
name|strlen
argument_list|(
name|decimalpoint
argument_list|)
block|;
else|#
directive|else
name|char
operator|*
name|decimalpoint
block|;
specifier|static
name|char
operator|*
name|decimalpoint_cache
block|;
specifier|static
name|int
name|dplen
block|;
if|if
condition|(
operator|!
operator|(
name|s0
operator|=
name|decimalpoint_cache
operator|)
condition|)
block|{
name|s0
operator|=
name|localeconv
argument_list|()
operator|->
name|decimal_point
expr_stmt|;
if|if
condition|(
operator|(
name|decimalpoint_cache
operator|=
operator|(
name|char
operator|*
operator|)
name|MALLOC
argument_list|(
name|strlen
argument_list|(
name|s0
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|decimalpoint_cache
argument_list|,
name|s0
argument_list|)
expr_stmt|;
name|s0
operator|=
name|decimalpoint_cache
expr_stmt|;
block|}
name|dplen
operator|=
name|strlen
argument_list|(
name|s0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} 	decimalpoint
operator|=
operator|(
name|char
operator|*
operator|)
name|s0
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*NO_LOCALE_CACHE*/
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*USE_LOCALE}{*/
end_comment

begin_define
define|#
directive|define
name|dplen
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*USE_LOCALE}}*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
end_ifdef

begin_comment
comment|/*{*/
end_comment

begin_decl_stmt
name|int
name|Rounding
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|Trust_FLT_ROUNDS
end_ifdef

begin_comment
comment|/*{{ only define this if FLT_ROUNDS really works! */
end_comment

begin_expr_stmt
name|Rounding
operator|=
name|Flt_Rounds
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*}{*/
end_comment

begin_expr_stmt
name|Rounding
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|fegetround
argument_list|()
condition|)
block|{
case|case
name|FE_TOWARDZERO
case|:
name|Rounding
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FE_UPWARD
case|:
name|Rounding
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|FE_DOWNWARD
case|:
name|Rounding
operator|=
literal|3
expr_stmt|;
block|}
end_switch

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*}}*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*}*/
end_comment

begin_expr_stmt
name|sign
operator|=
name|nz0
operator|=
name|nz
operator|=
name|decpt
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
literal|0.
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|s
operator|=
name|s00
init|;
condition|;
name|s
operator|++
control|)
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'-'
case|:
name|sign
operator|=
literal|1
expr_stmt|;
comment|/* no break */
case|case
literal|'+'
case|:
if|if
condition|(
operator|*
operator|++
name|s
condition|)
goto|goto
name|break2
goto|;
comment|/* no break */
case|case
literal|0
case|:
goto|goto
name|ret0
goto|;
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\r'
case|:
case|case
literal|' '
case|:
continue|continue;
default|default:
goto|goto
name|break2
goto|;
block|}
end_for

begin_label
name|break2
label|:
end_label

begin_if
if|if
condition|(
operator|*
name|s
operator|==
literal|'0'
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_HEX_FP
comment|/*{*/
block|{
specifier|static
name|FPI
name|fpi
init|=
block|{
literal|53
block|,
literal|1
operator|-
literal|1023
operator|-
literal|53
operator|+
literal|1
block|,
literal|2046
operator|-
literal|1023
operator|-
literal|53
operator|+
literal|1
block|,
literal|1
block|,
name|SI
block|}
decl_stmt|;
name|Long
name|exp
decl_stmt|;
name|ULong
name|bits
index|[
literal|2
index|]
decl_stmt|;
switch|switch
condition|(
name|s
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
block|{
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
name|FPI
name|fpi1
init|=
name|fpi
decl_stmt|;
name|fpi1
operator|.
name|rounding
operator|=
name|Rounding
expr_stmt|;
else|#
directive|else
define|#
directive|define
name|fpi1
value|fpi
endif|#
directive|endif
switch|switch
condition|(
operator|(
name|i
operator|=
name|gethex
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|fpi1
argument_list|,
operator|&
name|exp
argument_list|,
operator|&
name|bb
argument_list|,
name|sign
argument_list|)
operator|)
operator|&
name|STRTOG_Retmask
condition|)
block|{
case|case
name|STRTOG_NoNumber
case|:
name|s
operator|=
name|s00
expr_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
case|case
name|STRTOG_Zero
case|:
break|break;
default|default:
if|if
condition|(
name|bb
condition|)
block|{
name|copybits
argument_list|(
name|bits
argument_list|,
name|fpi
operator|.
name|nbits
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
name|ULtod
argument_list|(
operator|(
operator|(
name|U
operator|*
operator|)
operator|&
name|rv
operator|)
operator|->
name|L
argument_list|,
name|bits
argument_list|,
name|exp
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|ret
goto|;
block|}
block|}
endif|#
directive|endif
comment|/*}*/
name|nz0
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s
operator|==
literal|'0'
condition|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
goto|goto
name|ret
goto|;
block|}
end_if

begin_expr_stmt
name|s0
operator|=
name|s
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|y
operator|=
name|z
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|nd
operator|=
name|nf
operator|=
literal|0
init|;
operator|(
name|c
operator|=
operator|*
name|s
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|;
name|nd
operator|++
operator|,
name|s
operator|++
control|)
if|if
condition|(
name|nd
operator|<
literal|9
condition|)
name|y
operator|=
literal|10
operator|*
name|y
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|<
literal|16
condition|)
name|z
operator|=
literal|10
operator|*
name|z
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
end_for

begin_expr_stmt
name|nd0
operator|=
name|nd
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LOCALE
end_ifdef

begin_if
if|if
condition|(
name|c
operator|==
operator|*
name|decimalpoint
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|decimalpoint
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|s
index|[
name|i
index|]
operator|!=
name|decimalpoint
index|[
name|i
index|]
condition|)
goto|goto
name|dig_done
goto|;
name|s
operator|+=
name|i
expr_stmt|;
name|c
operator|=
operator|*
name|s
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
endif|#
directive|endif
name|decpt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|nd
condition|)
block|{
for|for
control|(
init|;
name|c
operator|==
literal|'0'
condition|;
name|c
operator|=
operator|*
operator|++
name|s
control|)
name|nz
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|s0
operator|=
name|s
expr_stmt|;
name|nf
operator|+=
name|nz
expr_stmt|;
name|nz
operator|=
literal|0
expr_stmt|;
goto|goto
name|have_dig
goto|;
block|}
goto|goto
name|dig_done
goto|;
block|}
for|for
control|(
init|;
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|;
name|c
operator|=
operator|*
operator|++
name|s
control|)
block|{
name|have_dig
label|:
name|nz
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|-=
literal|'0'
condition|)
block|{
name|nf
operator|+=
name|nz
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nz
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|nd
operator|++
operator|<
literal|9
condition|)
name|y
operator|*=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|<=
name|DBL_DIG
operator|+
literal|1
condition|)
name|z
operator|*=
literal|10
expr_stmt|;
if|if
condition|(
name|nd
operator|++
operator|<
literal|9
condition|)
name|y
operator|=
literal|10
operator|*
name|y
operator|+
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|<=
name|DBL_DIG
operator|+
literal|1
condition|)
name|z
operator|=
literal|10
operator|*
name|z
operator|+
name|c
expr_stmt|;
name|nz
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/*}*/
name|dig_done
label|:
name|e
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
condition|)
block|{
if|if
condition|(
operator|!
name|nd
operator|&&
operator|!
name|nz
operator|&&
operator|!
name|nz0
condition|)
block|{
goto|goto
name|ret0
goto|;
block|}
name|s00
operator|=
name|s
expr_stmt|;
name|esign
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
operator|++
name|s
condition|)
block|{
case|case
literal|'-'
case|:
name|esign
operator|=
literal|1
expr_stmt|;
case|case
literal|'+'
case|:
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|'0'
condition|)
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|L
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|s1
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|s
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|L
operator|=
literal|10
operator|*
name|L
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|s
operator|-
name|s1
operator|>
literal|8
operator|||
name|L
operator|>
literal|19999
condition|)
comment|/* Avoid confusion from exponents 					 * so large that e might overflow. 					 */
name|e
operator|=
literal|19999
expr_stmt|;
comment|/* safe for 16 bit ints */
else|else
name|e
operator|=
operator|(
name|int
operator|)
name|L
expr_stmt|;
if|if
condition|(
name|esign
condition|)
name|e
operator|=
operator|-
name|e
expr_stmt|;
block|}
else|else
name|e
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|s
operator|=
name|s00
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nd
condition|)
block|{
if|if
condition|(
operator|!
name|nz
operator|&&
operator|!
name|nz0
condition|)
block|{
ifdef|#
directive|ifdef
name|INFNAN_CHECK
comment|/* Check for Nan and Infinity */
name|ULong
name|bits
index|[
literal|2
index|]
decl_stmt|;
specifier|static
name|FPI
name|fpinan
init|=
comment|/* only 52 explicit bits */
block|{
literal|52
block|,
literal|1
operator|-
literal|1023
operator|-
literal|53
operator|+
literal|1
block|,
literal|2046
operator|-
literal|1023
operator|-
literal|53
operator|+
literal|1
block|,
literal|1
block|,
name|SI
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|decpt
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
if|if
condition|(
name|match
argument_list|(
operator|&
name|s
argument_list|,
literal|"nf"
argument_list|)
condition|)
block|{
operator|--
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|match
argument_list|(
operator|&
name|s
argument_list|,
literal|"inity"
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
literal|0x7ff00000
expr_stmt|;
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
literal|0
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
break|break;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
if|if
condition|(
name|match
argument_list|(
operator|&
name|s
argument_list|,
literal|"an"
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|No_Hex_NaN
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
comment|/*)*/
operator|&&
name|hexnan
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|fpinan
argument_list|,
name|bits
argument_list|)
operator|==
name|STRTOG_NaNbits
condition|)
block|{
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
literal|0x7ff80000
operator||
name|bits
index|[
literal|1
index|]
expr_stmt|;
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|bits
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|NAN_WORD0
expr_stmt|;
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|NAN_WORD1
expr_stmt|;
ifndef|#
directive|ifndef
name|No_Hex_NaN
block|}
endif|#
directive|endif
goto|goto
name|ret
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* INFNAN_CHECK */
name|ret0
label|:
name|s
operator|=
name|s00
expr_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|ret
goto|;
block|}
name|e1
operator|=
name|e
operator|-=
name|nf
expr_stmt|;
comment|/* Now we have nd0 digits, starting at s0, followed by a 	 * decimal point, followed by nd-nd0 digits.  The number we're 	 * after is the integer represented by those digits times 	 * 10**e */
if|if
condition|(
operator|!
name|nd0
condition|)
name|nd0
operator|=
name|nd
expr_stmt|;
name|k
operator|=
name|nd
operator|<
name|DBL_DIG
operator|+
literal|1
condition|?
name|nd
else|:
name|DBL_DIG
operator|+
literal|1
expr_stmt|;
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|9
condition|)
block|{
ifdef|#
directive|ifdef
name|SET_INEXACT
if|if
condition|(
name|k
operator|>
name|DBL_DIG
condition|)
name|oldinexact
operator|=
name|get_inexact
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|tens
index|[
name|k
operator|-
literal|9
index|]
operator|*
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|+
name|z
expr_stmt|;
block|}
name|bd0
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nd
operator|<=
name|DBL_DIG
ifndef|#
directive|ifndef
name|RND_PRODQUOT
ifndef|#
directive|ifndef
name|Honor_FLT_ROUNDS
operator|&&
name|Flt_Rounds
operator|==
literal|1
endif|#
directive|endif
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
operator|!
name|e
condition|)
goto|goto
name|ret
goto|;
ifndef|#
directive|ifndef
name|ROUND_BIASED_without_Round_Up
if|if
condition|(
name|e
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|<=
name|Ten_pmax
condition|)
block|{
ifdef|#
directive|ifdef
name|VAX
goto|goto
name|vax_ovfl_check
goto|;
else|#
directive|else
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
comment|/* round correctly FLT_ROUNDS = 2 or 3 */
if|if
condition|(
name|sign
condition|)
block|{
name|rv
operator|.
name|d
operator|=
operator|-
name|rv
operator|.
name|d
expr_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* rv = */
name|rounded_product
argument_list|(
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
argument_list|,
name|tens
index|[
name|e
index|]
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
endif|#
directive|endif
block|}
name|i
operator|=
name|DBL_DIG
operator|-
name|nd
expr_stmt|;
if|if
condition|(
name|e
operator|<=
name|Ten_pmax
operator|+
name|i
condition|)
block|{
comment|/* A fancier test would sometimes let us do 				 * this for larger i values. 				 */
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
comment|/* round correctly FLT_ROUNDS = 2 or 3 */
if|if
condition|(
name|sign
condition|)
block|{
name|rv
operator|.
name|d
operator|=
operator|-
name|rv
operator|.
name|d
expr_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|e
operator|-=
name|i
expr_stmt|;
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|*=
name|tens
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|VAX
comment|/* VAX exponent range is so narrow we must 				 * worry about overflow here... 				 */
name|vax_ovfl_check
label|:
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
comment|/* rv = */
name|rounded_product
argument_list|(
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
argument_list|,
name|tens
index|[
name|e
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
literal|1
operator|-
name|P
operator|)
condition|)
goto|goto
name|ovfl
goto|;
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
else|#
directive|else
comment|/* rv = */
name|rounded_product
argument_list|(
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
argument_list|,
name|tens
index|[
name|e
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|ret
goto|;
block|}
block|}
ifndef|#
directive|ifndef
name|Inaccurate_Divide
elseif|else
if|if
condition|(
name|e
operator|>=
operator|-
name|Ten_pmax
condition|)
block|{
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
comment|/* round correctly FLT_ROUNDS = 2 or 3 */
if|if
condition|(
name|sign
condition|)
block|{
name|rv
operator|.
name|d
operator|=
operator|-
name|rv
operator|.
name|d
expr_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* rv = */
name|rounded_quotient
argument_list|(
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
argument_list|,
name|tens
index|[
operator|-
name|e
index|]
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* ROUND_BIASED_without_Round_Up */
block|}
name|e1
operator|+=
name|nd
operator|-
name|k
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE_Arith
ifdef|#
directive|ifdef
name|SET_INEXACT
name|inexact
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|k
operator|<=
name|DBL_DIG
condition|)
name|oldinexact
operator|=
name|get_inexact
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Avoid_Underflow
name|scale
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
if|if
condition|(
name|Rounding
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|sign
condition|)
name|Rounding
operator|=
name|Rounding
operator|==
literal|2
condition|?
literal|0
else|:
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|Rounding
operator|!=
literal|2
condition|)
name|Rounding
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/*IEEE_Arith*/
comment|/* Get starting approximation = rv * 10**e1 */
if|if
condition|(
name|e1
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|e1
operator|&
literal|15
operator|)
operator|!=
literal|0
condition|)
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|*=
name|tens
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e1
operator|&=
operator|~
literal|15
condition|)
block|{
if|if
condition|(
name|e1
operator|>
name|DBL_MAX_10_EXP
condition|)
block|{
name|ovfl
label|:
comment|/* Can't trust HUGE_VAL */
ifdef|#
directive|ifdef
name|IEEE_Arith
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
switch|switch
condition|(
name|Rounding
condition|)
block|{
case|case
literal|0
case|:
comment|/* toward 0 */
case|case
literal|3
case|:
comment|/* toward -infinity */
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|Big0
expr_stmt|;
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|Big1
expr_stmt|;
break|break;
default|default:
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|Exp_mask
expr_stmt|;
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
comment|/*Honor_FLT_ROUNDS*/
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|Exp_mask
expr_stmt|;
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/*Honor_FLT_ROUNDS*/
ifdef|#
directive|ifdef
name|SET_INEXACT
comment|/* set overflow bit */
name|dval
argument_list|(
operator|&
name|rv0
argument_list|)
operator|=
literal|1e300
expr_stmt|;
name|dval
argument_list|(
operator|&
name|rv0
argument_list|)
operator|*=
name|dval
argument_list|(
operator|&
name|rv0
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/*IEEE_Arith*/
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|Big0
expr_stmt|;
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|Big1
expr_stmt|;
endif|#
directive|endif
comment|/*IEEE_Arith*/
name|range_err
label|:
if|if
condition|(
name|bd0
condition|)
block|{
name|Bfree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bd0
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_ERRNO
name|errno
operator|=
name|ERANGE
expr_stmt|;
endif|#
directive|endif
goto|goto
name|ret
goto|;
block|}
name|e1
operator|>>=
literal|4
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|e1
operator|>
literal|1
condition|;
name|j
operator|++
operator|,
name|e1
operator|>>=
literal|1
control|)
if|if
condition|(
name|e1
operator|&
literal|1
condition|)
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|*=
name|bigtens
index|[
name|j
index|]
expr_stmt|;
comment|/* The last multiplication could overflow. */
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|*=
name|bigtens
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|=
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
name|P
operator|)
condition|)
goto|goto
name|ovfl
goto|;
if|if
condition|(
name|z
operator|>
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
literal|1
operator|-
name|P
operator|)
condition|)
block|{
comment|/* set to largest number */
comment|/* (Can't trust DBL_MAX) */
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|Big0
expr_stmt|;
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|Big1
expr_stmt|;
block|}
else|else
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|e1
operator|<
literal|0
condition|)
block|{
name|e1
operator|=
operator|-
name|e1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|e1
operator|&
literal|15
operator|)
operator|!=
literal|0
condition|)
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|/=
name|tens
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e1
operator|>>=
literal|4
condition|)
block|{
if|if
condition|(
name|e1
operator|>=
literal|1
operator|<<
name|n_bigtens
condition|)
goto|goto
name|undfl
goto|;
ifdef|#
directive|ifdef
name|Avoid_Underflow
if|if
condition|(
name|e1
operator|&
name|Scale_Bit
condition|)
name|scale
operator|=
literal|2
operator|*
name|P
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|e1
operator|>
literal|0
condition|;
name|j
operator|++
operator|,
name|e1
operator|>>=
literal|1
control|)
if|if
condition|(
name|e1
operator|&
literal|1
condition|)
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|*=
name|tinytens
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|scale
operator|&&
operator|(
name|j
operator|=
literal|2
operator|*
name|P
operator|+
literal|1
operator|-
operator|(
operator|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>>
name|Exp_shift
operator|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* scaled rv is denormal; zap j low bits */
if|if
condition|(
name|j
operator|>=
literal|32
condition|)
block|{
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|53
condition|)
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
operator|(
name|P
operator|+
literal|2
operator|)
operator|*
name|Exp_msk1
expr_stmt|;
else|else
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&=
literal|0xffffffff
operator|<<
operator|(
name|j
operator|-
literal|32
operator|)
expr_stmt|;
block|}
else|else
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|&=
literal|0xffffffff
operator|<<
name|j
expr_stmt|;
block|}
else|#
directive|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|e1
operator|>
literal|1
condition|;
name|j
operator|++
operator|,
name|e1
operator|>>=
literal|1
control|)
if|if
condition|(
name|e1
operator|&
literal|1
condition|)
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|*=
name|tinytens
index|[
name|j
index|]
expr_stmt|;
comment|/* The last multiplication could underflow. */
name|dval
argument_list|(
operator|&
name|rv0
argument_list|)
operator|=
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
expr_stmt|;
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|*=
name|tinytens
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
condition|)
block|{
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
literal|2.
operator|*
name|dval
argument_list|(
operator|&
name|rv0
argument_list|)
expr_stmt|;
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|*=
name|tinytens
index|[
name|j
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
condition|)
block|{
name|undfl
label|:
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
literal|0.
expr_stmt|;
goto|goto
name|range_err
goto|;
block|}
ifndef|#
directive|ifndef
name|Avoid_Underflow
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|Tiny0
expr_stmt|;
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|Tiny1
expr_stmt|;
comment|/* The refinement below will clean 				 * this approximation up. 				 */
block|}
endif|#
directive|endif
block|}
block|}
comment|/* Now the hard part -- adjusting rv to the correct value.*/
comment|/* Put digits into bd: true value = bd * 10^e */
name|bd0
operator|=
name|s2b
argument_list|(
name|s0
argument_list|,
name|nd0
argument_list|,
name|nd
argument_list|,
name|y
argument_list|,
name|dplen
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bd
operator|=
name|Balloc
argument_list|(
name|bd0
operator|->
name|k
argument_list|)
expr_stmt|;
name|Bcopy
argument_list|(
name|bd
argument_list|,
name|bd0
argument_list|)
expr_stmt|;
name|bb
operator|=
name|d2b
argument_list|(
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
argument_list|,
operator|&
name|bbe
argument_list|,
operator|&
name|bbbits
argument_list|)
expr_stmt|;
comment|/* rv = bb * 2^bbe */
name|bs
operator|=
name|i2b
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|>=
literal|0
condition|)
block|{
name|bb2
operator|=
name|bb5
operator|=
literal|0
expr_stmt|;
name|bd2
operator|=
name|bd5
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
name|bb2
operator|=
name|bb5
operator|=
operator|-
name|e
expr_stmt|;
name|bd2
operator|=
name|bd5
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bbe
operator|>=
literal|0
condition|)
name|bb2
operator|+=
name|bbe
expr_stmt|;
else|else
name|bd2
operator|-=
name|bbe
expr_stmt|;
name|bs2
operator|=
name|bb2
expr_stmt|;
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
if|if
condition|(
name|Rounding
operator|!=
literal|1
condition|)
name|bs2
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Avoid_Underflow
name|Lsb
operator|=
name|LSB
expr_stmt|;
name|Lsb1
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|bbe
operator|-
name|scale
expr_stmt|;
name|i
operator|=
name|j
operator|+
name|bbbits
operator|-
literal|1
expr_stmt|;
comment|/* logb(rv) */
name|j
operator|=
name|P
operator|+
literal|1
operator|-
name|bbbits
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|Emin
condition|)
block|{
comment|/* denormal */
name|i
operator|=
name|Emin
operator|-
name|i
expr_stmt|;
name|j
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|32
condition|)
name|Lsb
operator|<<=
name|i
expr_stmt|;
else|else
name|Lsb1
operator|=
name|Lsb
operator|<<
operator|(
name|i
operator|-
literal|32
operator|)
expr_stmt|;
block|}
else|#
directive|else
comment|/*Avoid_Underflow*/
ifdef|#
directive|ifdef
name|Sudden_Underflow
ifdef|#
directive|ifdef
name|IBM
name|j
operator|=
literal|1
operator|+
literal|4
operator|*
name|P
operator|-
literal|3
operator|-
name|bbbits
operator|+
operator|(
operator|(
name|bbe
operator|+
name|bbbits
operator|-
literal|1
operator|)
operator|&
literal|3
operator|)
expr_stmt|;
else|#
directive|else
name|j
operator|=
name|P
operator|+
literal|1
operator|-
name|bbbits
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/*Sudden_Underflow*/
name|j
operator|=
name|bbe
expr_stmt|;
name|i
operator|=
name|j
operator|+
name|bbbits
operator|-
literal|1
expr_stmt|;
comment|/* logb(&rv) */
if|if
condition|(
name|i
operator|<
name|Emin
condition|)
comment|/* denormal */
name|j
operator|+=
name|P
operator|-
name|Emin
expr_stmt|;
else|else
name|j
operator|=
name|P
operator|+
literal|1
operator|-
name|bbbits
expr_stmt|;
endif|#
directive|endif
comment|/*Sudden_Underflow*/
endif|#
directive|endif
comment|/*Avoid_Underflow*/
name|bb2
operator|+=
name|j
expr_stmt|;
name|bd2
operator|+=
name|j
expr_stmt|;
ifdef|#
directive|ifdef
name|Avoid_Underflow
name|bd2
operator|+=
name|scale
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|bb2
operator|<
name|bd2
condition|?
name|bb2
else|:
name|bd2
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|bs2
condition|)
name|i
operator|=
name|bs2
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|bb2
operator|-=
name|i
expr_stmt|;
name|bd2
operator|-=
name|i
expr_stmt|;
name|bs2
operator|-=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|bb5
operator|>
literal|0
condition|)
block|{
name|bs
operator|=
name|pow5mult
argument_list|(
name|bs
argument_list|,
name|bb5
argument_list|)
expr_stmt|;
name|bb1
operator|=
name|mult
argument_list|(
name|bs
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bb
operator|=
name|bb1
expr_stmt|;
block|}
if|if
condition|(
name|bb2
operator|>
literal|0
condition|)
name|bb
operator|=
name|lshift
argument_list|(
name|bb
argument_list|,
name|bb2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bd5
operator|>
literal|0
condition|)
name|bd
operator|=
name|pow5mult
argument_list|(
name|bd
argument_list|,
name|bd5
argument_list|)
expr_stmt|;
if|if
condition|(
name|bd2
operator|>
literal|0
condition|)
name|bd
operator|=
name|lshift
argument_list|(
name|bd
argument_list|,
name|bd2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs2
operator|>
literal|0
condition|)
name|bs
operator|=
name|lshift
argument_list|(
name|bs
argument_list|,
name|bs2
argument_list|)
expr_stmt|;
name|delta
operator|=
name|diff
argument_list|(
name|bb
argument_list|,
name|bd
argument_list|)
expr_stmt|;
name|dsign
operator|=
name|delta
operator|->
name|sign
expr_stmt|;
name|delta
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|cmp
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
if|if
condition|(
name|Rounding
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* Error is less than an ulp */
if|if
condition|(
operator|!
name|delta
operator|->
name|x
index|[
literal|0
index|]
operator|&&
name|delta
operator|->
name|wds
operator|<=
literal|1
condition|)
block|{
comment|/* exact */
ifdef|#
directive|ifdef
name|SET_INEXACT
name|inexact
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|Rounding
condition|)
block|{
if|if
condition|(
name|dsign
condition|)
block|{
name|dval
argument_list|(
operator|&
name|adj
argument_list|)
operator|=
literal|1.
expr_stmt|;
goto|goto
name|apply_adj
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|dsign
condition|)
block|{
name|dval
argument_list|(
operator|&
name|adj
argument_list|)
operator|=
operator|-
literal|1.
expr_stmt|;
if|if
condition|(
operator|!
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|&&
operator|!
operator|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Frac_mask
operator|)
condition|)
block|{
name|y
operator|=
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
expr_stmt|;
ifdef|#
directive|ifdef
name|Avoid_Underflow
if|if
condition|(
operator|!
name|scale
operator|||
name|y
operator|>
literal|2
operator|*
name|P
operator|*
name|Exp_msk1
condition|)
else|#
directive|else
if|if
condition|(
name|y
condition|)
endif|#
directive|endif
block|{
name|delta
operator|=
name|lshift
argument_list|(
name|delta
argument_list|,
name|Log2P
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
operator|<=
literal|0
condition|)
name|dval
argument_list|(
operator|&
name|adj
argument_list|)
operator|=
operator|-
literal|0.5
expr_stmt|;
block|}
block|}
name|apply_adj
label|:
ifdef|#
directive|ifdef
name|Avoid_Underflow
if|if
condition|(
name|scale
operator|&&
operator|(
name|y
operator|=
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
literal|2
operator|*
name|P
operator|*
name|Exp_msk1
condition|)
name|word0
argument_list|(
operator|&
name|adj
argument_list|)
operator|+=
operator|(
literal|2
operator|*
name|P
operator|+
literal|1
operator|)
operator|*
name|Exp_msk1
operator|-
name|y
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|Sudden_Underflow
if|if
condition|(
operator|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
name|P
operator|*
name|Exp_msk1
condition|)
block|{
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|+=
name|adj
operator|*
name|ulp
argument_list|(
operator|&
name|rv
argument_list|)
expr_stmt|;
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/*Sudden_Underflow*/
endif|#
directive|endif
comment|/*Avoid_Underflow*/
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|+=
name|adj
operator|.
name|d
operator|*
name|ulp
argument_list|(
operator|&
name|rv
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|dval
argument_list|(
operator|&
name|adj
argument_list|)
operator|=
name|ratio
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|adj
operator|.
name|d
operator|<
literal|1.
condition|)
name|dval
argument_list|(
operator|&
name|adj
argument_list|)
operator|=
literal|1.
expr_stmt|;
if|if
condition|(
name|adj
operator|.
name|d
operator|<=
literal|0x7ffffffe
condition|)
block|{
comment|/* dval(&adj) = Rounding ? ceil(&adj) : floor(&adj); */
name|y
operator|=
name|adj
operator|.
name|d
expr_stmt|;
if|if
condition|(
name|y
operator|!=
name|adj
operator|.
name|d
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|Rounding
operator|>>
literal|1
operator|)
operator|^
name|dsign
operator|)
condition|)
name|y
operator|++
expr_stmt|;
name|dval
argument_list|(
operator|&
name|adj
argument_list|)
operator|=
name|y
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|Avoid_Underflow
if|if
condition|(
name|scale
operator|&&
operator|(
name|y
operator|=
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
literal|2
operator|*
name|P
operator|*
name|Exp_msk1
condition|)
name|word0
argument_list|(
operator|&
name|adj
argument_list|)
operator|+=
operator|(
literal|2
operator|*
name|P
operator|+
literal|1
operator|)
operator|*
name|Exp_msk1
operator|-
name|y
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|Sudden_Underflow
if|if
condition|(
operator|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
name|P
operator|*
name|Exp_msk1
condition|)
block|{
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
name|dval
argument_list|(
operator|&
name|adj
argument_list|)
operator|*=
name|ulp
argument_list|(
operator|&
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsign
condition|)
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|+=
name|adj
expr_stmt|;
else|else
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|-=
name|adj
expr_stmt|;
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
endif|#
directive|endif
comment|/*Sudden_Underflow*/
endif|#
directive|endif
comment|/*Avoid_Underflow*/
name|dval
argument_list|(
operator|&
name|adj
argument_list|)
operator|*=
name|ulp
argument_list|(
operator|&
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsign
condition|)
block|{
if|if
condition|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|==
name|Big0
operator|&&
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|==
name|Big1
condition|)
goto|goto
name|ovfl
goto|;
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|+=
name|adj
operator|.
name|d
expr_stmt|;
block|}
else|else
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|-=
name|adj
operator|.
name|d
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
endif|#
directive|endif
comment|/*Honor_FLT_ROUNDS*/
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* Error is less than half an ulp -- check for 			 * special case of mantissa a power of two. 			 */
if|if
condition|(
name|dsign
operator|||
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|||
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Bndry_mask
ifdef|#
directive|ifdef
name|IEEE_Arith
ifdef|#
directive|ifdef
name|Avoid_Underflow
operator|||
operator|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
operator|(
literal|2
operator|*
name|P
operator|+
literal|1
operator|)
operator|*
name|Exp_msk1
else|#
directive|else
operator|||
operator|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
name|Exp_msk1
endif|#
directive|endif
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|SET_INEXACT
if|if
condition|(
operator|!
name|delta
operator|->
name|x
index|[
literal|0
index|]
operator|&&
name|delta
operator|->
name|wds
operator|<=
literal|1
condition|)
name|inexact
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
operator|!
name|delta
operator|->
name|x
index|[
literal|0
index|]
operator|&&
name|delta
operator|->
name|wds
operator|<=
literal|1
condition|)
block|{
comment|/* exact result */
ifdef|#
directive|ifdef
name|SET_INEXACT
name|inexact
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|delta
operator|=
name|lshift
argument_list|(
name|delta
argument_list|,
name|Log2P
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|drop_down
goto|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* exactly half-way between */
if|if
condition|(
name|dsign
condition|)
block|{
if|if
condition|(
operator|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Bndry_mask1
operator|)
operator|==
name|Bndry_mask1
operator|&&
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|==
operator|(
ifdef|#
directive|ifdef
name|Avoid_Underflow
operator|(
name|scale
operator|&&
operator|(
name|y
operator|=
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
literal|2
operator|*
name|P
operator|*
name|Exp_msk1
operator|)
condition|?
operator|(
literal|0xffffffff
operator|&
operator|(
literal|0xffffffff
operator|<<
operator|(
literal|2
operator|*
name|P
operator|+
literal|1
operator|-
operator|(
name|y
operator|>>
name|Exp_shift
operator|)
operator|)
operator|)
operator|)
else|:
endif|#
directive|endif
literal|0xffffffff
operator|)
condition|)
block|{
comment|/*boundary case -- increment exponent*/
if|if
condition|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|==
name|Big0
operator|&&
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|==
name|Big1
condition|)
goto|goto
name|ovfl
goto|;
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
operator|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|+
name|Exp_msk1
ifdef|#
directive|ifdef
name|IBM
operator||
name|Exp_msk1
operator|>>
literal|4
endif|#
directive|endif
expr_stmt|;
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|Avoid_Underflow
name|dsign
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Bndry_mask
operator|)
operator|&&
operator|!
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
condition|)
block|{
name|drop_down
label|:
comment|/* boundary case -- decrement exponent */
ifdef|#
directive|ifdef
name|Sudden_Underflow
comment|/*{{*/
name|L
operator|=
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
if|if
condition|(
name|L
operator|<
name|Exp_msk1
condition|)
else|#
directive|else
ifdef|#
directive|ifdef
name|Avoid_Underflow
if|if
condition|(
name|L
operator|<=
operator|(
name|scale
condition|?
operator|(
literal|2
operator|*
name|P
operator|+
literal|1
operator|)
operator|*
name|Exp_msk1
else|:
name|Exp_msk1
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|L
operator|<=
name|Exp_msk1
condition|)
endif|#
directive|endif
comment|/*Avoid_Underflow*/
endif|#
directive|endif
comment|/*IBM*/
goto|goto
name|undfl
goto|;
name|L
operator|-=
name|Exp_msk1
expr_stmt|;
else|#
directive|else
comment|/*Sudden_Underflow}{*/
ifdef|#
directive|ifdef
name|Avoid_Underflow
if|if
condition|(
name|scale
condition|)
block|{
name|L
operator|=
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
expr_stmt|;
if|if
condition|(
name|L
operator|<=
operator|(
literal|2
operator|*
name|P
operator|+
literal|1
operator|)
operator|*
name|Exp_msk1
condition|)
block|{
if|if
condition|(
name|L
operator|>
operator|(
name|P
operator|+
literal|2
operator|)
operator|*
name|Exp_msk1
condition|)
comment|/* round even ==> */
comment|/* accept rv */
break|break;
comment|/* rv = smallest denormal */
goto|goto
name|undfl
goto|;
block|}
block|}
endif|#
directive|endif
comment|/*Avoid_Underflow*/
name|L
operator|=
operator|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|-
name|Exp_msk1
expr_stmt|;
endif|#
directive|endif
comment|/*Sudden_Underflow}}*/
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|L
operator||
name|Bndry_mask1
expr_stmt|;
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
literal|0xffffffff
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
goto|goto
name|cont
goto|;
else|#
directive|else
break|break;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|ROUND_BIASED
ifdef|#
directive|ifdef
name|Avoid_Underflow
if|if
condition|(
name|Lsb1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Lsb1
operator|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Lsb
operator|)
condition|)
break|break;
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|LSB
operator|)
condition|)
break|break;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|dsign
condition|)
ifdef|#
directive|ifdef
name|Avoid_Underflow
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|+=
name|sulp
argument_list|(
operator|&
name|rv
argument_list|,
name|scale
argument_list|)
expr_stmt|;
else|#
directive|else
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|+=
name|ulp
argument_list|(
operator|&
name|rv
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ROUND_BIASED
else|else
block|{
ifdef|#
directive|ifdef
name|Avoid_Underflow
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|-=
name|sulp
argument_list|(
operator|&
name|rv
argument_list|,
name|scale
argument_list|)
expr_stmt|;
else|#
directive|else
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|-=
name|ulp
argument_list|(
operator|&
name|rv
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Sudden_Underflow
if|if
condition|(
operator|!
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
condition|)
goto|goto
name|undfl
goto|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|Avoid_Underflow
name|dsign
operator|=
literal|1
operator|-
name|dsign
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
operator|(
name|aadj
operator|=
name|ratio
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
operator|)
operator|<=
literal|2.
condition|)
block|{
if|if
condition|(
name|dsign
condition|)
name|aadj
operator|=
name|dval
argument_list|(
operator|&
name|aadj1
argument_list|)
operator|=
literal|1.
expr_stmt|;
elseif|else
if|if
condition|(
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|||
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Bndry_mask
condition|)
block|{
ifndef|#
directive|ifndef
name|Sudden_Underflow
if|if
condition|(
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|==
name|Tiny1
operator|&&
operator|!
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
condition|)
goto|goto
name|undfl
goto|;
endif|#
directive|endif
name|aadj
operator|=
literal|1.
expr_stmt|;
name|dval
argument_list|(
operator|&
name|aadj1
argument_list|)
operator|=
operator|-
literal|1.
expr_stmt|;
block|}
else|else
block|{
comment|/* special case -- power of FLT_RADIX to be */
comment|/* rounded down... */
if|if
condition|(
name|aadj
operator|<
literal|2.
operator|/
name|FLT_RADIX
condition|)
name|aadj
operator|=
literal|1.
operator|/
name|FLT_RADIX
expr_stmt|;
else|else
name|aadj
operator|*=
literal|0.5
expr_stmt|;
name|dval
argument_list|(
operator|&
name|aadj1
argument_list|)
operator|=
operator|-
name|aadj
expr_stmt|;
block|}
block|}
else|else
block|{
name|aadj
operator|*=
literal|0.5
expr_stmt|;
name|dval
argument_list|(
operator|&
name|aadj1
argument_list|)
operator|=
name|dsign
condition|?
name|aadj
else|:
operator|-
name|aadj
expr_stmt|;
ifdef|#
directive|ifdef
name|Check_FLT_ROUNDS
switch|switch
condition|(
name|Rounding
condition|)
block|{
case|case
literal|2
case|:
comment|/* towards +infinity */
name|dval
argument_list|(
operator|&
name|aadj1
argument_list|)
operator|-=
literal|0.5
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* towards 0 */
case|case
literal|3
case|:
comment|/* towards -infinity */
name|dval
argument_list|(
operator|&
name|aadj1
argument_list|)
operator|+=
literal|0.5
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|Flt_Rounds
operator|==
literal|0
condition|)
name|dval
argument_list|(
operator|&
name|aadj1
argument_list|)
operator|+=
literal|0.5
expr_stmt|;
endif|#
directive|endif
comment|/*Check_FLT_ROUNDS*/
block|}
name|y
operator|=
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
expr_stmt|;
comment|/* Check for overflow */
if|if
condition|(
name|y
operator|==
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
literal|1
operator|)
condition|)
block|{
name|dval
argument_list|(
operator|&
name|rv0
argument_list|)
operator|=
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
expr_stmt|;
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
name|dval
argument_list|(
operator|&
name|adj
argument_list|)
operator|=
name|dval
argument_list|(
operator|&
name|aadj1
argument_list|)
operator|*
name|ulp
argument_list|(
operator|&
name|rv
argument_list|)
expr_stmt|;
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|+=
name|dval
argument_list|(
operator|&
name|adj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>=
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
name|P
operator|)
condition|)
block|{
if|if
condition|(
name|word0
argument_list|(
operator|&
name|rv0
argument_list|)
operator|==
name|Big0
operator|&&
name|word1
argument_list|(
operator|&
name|rv0
argument_list|)
operator|==
name|Big1
condition|)
goto|goto
name|ovfl
goto|;
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|Big0
expr_stmt|;
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|Big1
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
else|else
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|Avoid_Underflow
if|if
condition|(
name|scale
operator|&&
name|y
operator|<=
literal|2
operator|*
name|P
operator|*
name|Exp_msk1
condition|)
block|{
if|if
condition|(
name|aadj
operator|<=
literal|0x7fffffff
condition|)
block|{
if|if
condition|(
operator|(
name|z
operator|=
name|aadj
operator|)
operator|<=
literal|0
condition|)
name|z
operator|=
literal|1
expr_stmt|;
name|aadj
operator|=
name|z
expr_stmt|;
name|dval
argument_list|(
operator|&
name|aadj1
argument_list|)
operator|=
name|dsign
condition|?
name|aadj
else|:
operator|-
name|aadj
expr_stmt|;
block|}
name|word0
argument_list|(
operator|&
name|aadj1
argument_list|)
operator|+=
operator|(
literal|2
operator|*
name|P
operator|+
literal|1
operator|)
operator|*
name|Exp_msk1
operator|-
name|y
expr_stmt|;
block|}
name|dval
argument_list|(
operator|&
name|adj
argument_list|)
operator|=
name|dval
argument_list|(
operator|&
name|aadj1
argument_list|)
operator|*
name|ulp
argument_list|(
operator|&
name|rv
argument_list|)
expr_stmt|;
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|+=
name|dval
argument_list|(
operator|&
name|adj
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|Sudden_Underflow
if|if
condition|(
operator|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
name|P
operator|*
name|Exp_msk1
condition|)
block|{
name|dval
argument_list|(
operator|&
name|rv0
argument_list|)
operator|=
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
expr_stmt|;
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
name|dval
argument_list|(
operator|&
name|adj
argument_list|)
operator|=
name|dval
argument_list|(
operator|&
name|aadj1
argument_list|)
operator|*
name|ulp
argument_list|(
operator|&
name|rv
argument_list|)
expr_stmt|;
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|+=
name|adj
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
if|if
condition|(
operator|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<
name|P
operator|*
name|Exp_msk1
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
name|P
operator|*
name|Exp_msk1
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|word0
argument_list|(
operator|&
name|rv0
argument_list|)
operator|==
name|Tiny0
operator|&&
name|word1
argument_list|(
operator|&
name|rv0
argument_list|)
operator|==
name|Tiny1
condition|)
goto|goto
name|undfl
goto|;
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|Tiny0
expr_stmt|;
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|=
name|Tiny1
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
else|else
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
block|}
else|else
block|{
name|dval
argument_list|(
operator|&
name|adj
argument_list|)
operator|=
name|dval
argument_list|(
operator|&
name|aadj1
argument_list|)
operator|*
name|ulp
argument_list|(
operator|&
name|rv
argument_list|)
expr_stmt|;
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|+=
name|adj
expr_stmt|;
block|}
else|#
directive|else
comment|/*Sudden_Underflow*/
comment|/* Compute dval(&adj) so that the IEEE rounding rules will 			 * correctly round rv + dval(&adj) in some half-way cases. 			 * If rv * ulp(&rv) is denormalized (i.e., 			 * y<= (P-1)*Exp_msk1), we must adjust aadj to avoid 			 * trouble from bits lost to denormalization; 			 * example: 1.2e-307 . 			 */
if|if
condition|(
name|y
operator|<=
operator|(
name|P
operator|-
literal|1
operator|)
operator|*
name|Exp_msk1
operator|&&
name|aadj
operator|>
literal|1.
condition|)
block|{
name|dval
argument_list|(
operator|&
name|aadj1
argument_list|)
operator|=
call|(
name|double
call|)
argument_list|(
name|int
argument_list|)
argument_list|(
name|aadj
operator|+
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsign
condition|)
name|dval
argument_list|(
operator|&
name|aadj1
argument_list|)
operator|=
operator|-
name|dval
argument_list|(
operator|&
name|aadj1
argument_list|)
expr_stmt|;
block|}
name|dval
argument_list|(
operator|&
name|adj
argument_list|)
operator|=
name|dval
argument_list|(
operator|&
name|aadj1
argument_list|)
operator|*
name|ulp
argument_list|(
operator|&
name|rv
argument_list|)
expr_stmt|;
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|+=
name|adj
expr_stmt|;
endif|#
directive|endif
comment|/*Sudden_Underflow*/
endif|#
directive|endif
comment|/*Avoid_Underflow*/
block|}
name|z
operator|=
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
expr_stmt|;
ifndef|#
directive|ifndef
name|SET_INEXACT
ifdef|#
directive|ifdef
name|Avoid_Underflow
if|if
condition|(
operator|!
name|scale
condition|)
endif|#
directive|endif
if|if
condition|(
name|y
operator|==
name|z
condition|)
block|{
comment|/* Can we stop now? */
name|L
operator|=
operator|(
name|Long
operator|)
name|aadj
expr_stmt|;
name|aadj
operator|-=
name|L
expr_stmt|;
comment|/* The tolerances below are conservative. */
if|if
condition|(
name|dsign
operator|||
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|||
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Bndry_mask
condition|)
block|{
if|if
condition|(
name|aadj
operator|<
literal|.4999999
operator|||
name|aadj
operator|>
literal|.5000001
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|aadj
operator|<
literal|.4999999
operator|/
name|FLT_RADIX
condition|)
break|break;
block|}
endif|#
directive|endif
name|cont
label|:
name|Bfree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
name|Bfree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bd0
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|delta
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SET_INEXACT
if|if
condition|(
name|inexact
condition|)
block|{
if|if
condition|(
operator|!
name|oldinexact
condition|)
block|{
name|word0
argument_list|(
operator|&
name|rv0
argument_list|)
operator|=
name|Exp_1
operator|+
operator|(
literal|70
operator|<<
name|Exp_shift
operator|)
expr_stmt|;
name|word1
argument_list|(
operator|&
name|rv0
argument_list|)
operator|=
literal|0
expr_stmt|;
name|dval
argument_list|(
operator|&
name|rv0
argument_list|)
operator|+=
literal|1.
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|oldinexact
condition|)
name|clear_inexact
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Avoid_Underflow
if|if
condition|(
name|scale
condition|)
block|{
name|word0
argument_list|(
operator|&
name|rv0
argument_list|)
operator|=
name|Exp_1
operator|-
literal|2
operator|*
name|P
operator|*
name|Exp_msk1
expr_stmt|;
name|word1
argument_list|(
operator|&
name|rv0
argument_list|)
operator|=
literal|0
expr_stmt|;
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
operator|*=
name|dval
argument_list|(
operator|&
name|rv0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_ERRNO
comment|/* try to avoid the bug of testing an 8087 register value */
ifdef|#
directive|ifdef
name|IEEE_Arith
if|if
condition|(
operator|!
operator|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|==
literal|0
operator|&&
name|word1
argument_list|(
operator|&
name|rv
argument_list|)
operator|==
literal|0
condition|)
endif|#
directive|endif
name|errno
operator|=
name|ERANGE
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* Avoid_Underflow */
ifdef|#
directive|ifdef
name|SET_INEXACT
if|if
condition|(
name|inexact
operator|&&
operator|!
operator|(
name|word0
argument_list|(
operator|&
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
condition|)
block|{
comment|/* set underflow bit */
name|dval
argument_list|(
operator|&
name|rv0
argument_list|)
operator|=
literal|1e-300
expr_stmt|;
name|dval
argument_list|(
operator|&
name|rv0
argument_list|)
operator|*=
name|dval
argument_list|(
operator|&
name|rv0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ret
label|:
if|if
condition|(
name|se
condition|)
operator|*
name|se
operator|=
operator|(
name|char
operator|*
operator|)
name|s
expr_stmt|;
return|return
name|sign
condition|?
operator|-
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
else|:
name|dval
argument_list|(
operator|&
name|rv
argument_list|)
return|;
block|}
end_if

end_unit

