begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************  The author of this software is David M. Gay.  Copyright (C) 1998-2001 by Lucent Technologies All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name of Lucent or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ****************************************************************/
end_comment

begin_comment
comment|/* Please send bug reports to David M. Gay (dmg at acm dot org,  * with " at " changed at "@" and " dot " changed to ".").	*/
end_comment

begin_include
include|#
directive|include
file|"gdtoaimp.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_FENV_H
end_ifndef

begin_include
include|#
directive|include
file|<fenv.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LOCALE
end_ifdef

begin_include
include|#
directive|include
file|"locale.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_Arith
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|NO_IEEE_Scale
end_ifndef

begin_define
define|#
directive|define
name|Avoid_Underflow
end_define

begin_undef
undef|#
directive|undef
name|tinytens
end_undef

begin_comment
comment|/* The factor of 2^53 in tinytens[4] helps us avoid setting the underflow */
end_comment

begin_comment
comment|/* flag unnecessarily.  It leads to a song and dance at the end of strtod. */
end_comment

begin_decl_stmt
specifier|static
name|CONST
name|double
name|tinytens
index|[]
init|=
block|{
literal|1e-16
block|,
literal|1e-32
block|,
literal|1e-64
block|,
literal|1e-128
block|,
literal|9007199254740992.e-256
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
end_ifdef

begin_define
define|#
directive|define
name|Rounding
value|rounding
end_define

begin_undef
undef|#
directive|undef
name|Check_FLT_ROUNDS
end_undef

begin_define
define|#
directive|define
name|Check_FLT_ROUNDS
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Rounding
value|Flt_Rounds
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|double
name|strtod
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|s00
argument_list|,
name|se
argument_list|)
name|CONST
name|char
modifier|*
name|s00
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|se
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|CONST
name|char
operator|*
name|s00
operator|,
name|char
operator|*
operator|*
name|se
operator|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|Avoid_Underflow
name|int
name|scale
block|;
endif|#
directive|endif
name|int
name|bb2
block|,
name|bb5
block|,
name|bbe
block|,
name|bd2
block|,
name|bd5
block|,
name|bbbits
block|,
name|bs2
block|,
name|c
block|,
name|decpt
block|,
name|dsign
block|,
name|e
block|,
name|e1
block|,
name|esign
block|,
name|i
block|,
name|j
block|,
name|k
block|,
name|nd
block|,
name|nd0
block|,
name|nf
block|,
name|nz
block|,
name|nz0
block|,
name|sign
block|;
name|CONST
name|char
operator|*
name|s
block|,
operator|*
name|s0
block|,
operator|*
name|s1
block|;
name|double
name|aadj
block|,
name|aadj1
block|,
name|adj
block|,
name|rv
block|,
name|rv0
block|;
name|Long
name|L
block|;
name|ULong
name|y
block|,
name|z
block|;
name|Bigint
operator|*
name|bb
block|,
operator|*
name|bb1
block|,
operator|*
name|bd
block|,
operator|*
name|bd0
block|,
operator|*
name|bs
block|,
operator|*
name|delta
block|;
ifdef|#
directive|ifdef
name|SET_INEXACT
name|int
name|inexact
block|,
name|oldinexact
block|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
name|int
name|rounding
block|;
endif|#
directive|endif
name|sign
operator|=
name|nz0
operator|=
name|nz
operator|=
name|decpt
operator|=
literal|0
block|;
name|dval
argument_list|(
name|rv
argument_list|)
operator|=
literal|0.
block|;
for|for
control|(
name|s
operator|=
name|s00
init|;
condition|;
name|s
operator|++
control|)
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'-'
case|:
name|sign
operator|=
literal|1
expr_stmt|;
comment|/* no break */
case|case
literal|'+'
case|:
if|if
condition|(
operator|*
operator|++
name|s
condition|)
goto|goto
name|break2
goto|;
comment|/* no break */
case|case
literal|0
case|:
goto|goto
name|ret0
goto|;
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\r'
case|:
case|case
literal|' '
case|:
continue|continue;
default|default:
goto|goto
name|break2
goto|;
block|}
name|break2
operator|:
end_expr_stmt

begin_if
if|if
condition|(
operator|*
name|s
operator|==
literal|'0'
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_HEX_FP
block|{
specifier|static
name|FPI
name|fpi
init|=
block|{
literal|53
block|,
literal|1
operator|-
literal|1023
operator|-
literal|53
operator|+
literal|1
block|,
literal|2046
operator|-
literal|1023
operator|-
literal|53
operator|+
literal|1
block|,
literal|1
block|,
name|SI
block|}
decl_stmt|;
name|Long
name|exp
decl_stmt|;
name|ULong
name|bits
index|[
literal|2
index|]
decl_stmt|;
switch|switch
condition|(
name|s
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
block|{
if|#
directive|if
name|defined
argument_list|(
name|FE_DOWNWARD
argument_list|)
operator|&&
name|defined
argument_list|(
name|FE_TONEAREST
argument_list|)
operator|&&
name|defined
argument_list|(
name|FE_TOWARDZERO
argument_list|)
operator|&&
name|defined
argument_list|(
name|FE_UPWARD
argument_list|)
name|FPI
name|fpi1
init|=
name|fpi
decl_stmt|;
switch|switch
condition|(
name|fegetround
argument_list|()
condition|)
block|{
case|case
name|FE_TOWARDZERO
case|:
name|fpi1
operator|.
name|rounding
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FE_UPWARD
case|:
name|fpi1
operator|.
name|rounding
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|FE_DOWNWARD
case|:
name|fpi1
operator|.
name|rounding
operator|=
literal|3
expr_stmt|;
block|}
else|#
directive|else
define|#
directive|define
name|fpi1
value|fpi
endif|#
directive|endif
switch|switch
condition|(
operator|(
name|i
operator|=
name|gethex
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|fpi1
argument_list|,
operator|&
name|exp
argument_list|,
operator|&
name|bb
argument_list|,
name|sign
argument_list|)
operator|)
operator|&
name|STRTOG_Retmask
condition|)
block|{
case|case
name|STRTOG_NoNumber
case|:
name|s
operator|=
name|s00
expr_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
case|case
name|STRTOG_Zero
case|:
break|break;
default|default:
if|if
condition|(
name|bb
condition|)
block|{
name|copybits
argument_list|(
name|bits
argument_list|,
name|fpi
operator|.
name|nbits
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
name|ULtod
argument_list|(
operator|(
operator|(
name|U
operator|*
operator|)
operator|&
name|rv
operator|)
operator|->
name|L
argument_list|,
name|bits
argument_list|,
name|exp
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|ret
goto|;
block|}
block|}
endif|#
directive|endif
name|nz0
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s
operator|==
literal|'0'
condition|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
goto|goto
name|ret
goto|;
block|}
end_if

begin_expr_stmt
name|s0
operator|=
name|s
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|y
operator|=
name|z
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|nd
operator|=
name|nf
operator|=
literal|0
init|;
operator|(
name|c
operator|=
operator|*
name|s
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|;
name|nd
operator|++
operator|,
name|s
operator|++
control|)
if|if
condition|(
name|nd
operator|<
literal|9
condition|)
name|y
operator|=
literal|10
operator|*
name|y
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|<
literal|16
condition|)
name|z
operator|=
literal|10
operator|*
name|z
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
end_for

begin_expr_stmt
name|nd0
operator|=
name|nd
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LOCALE
end_ifdef

begin_if
if|if
condition|(
name|c
operator|==
operator|*
name|localeconv
argument_list|()
operator|->
name|decimal_point
condition|)
else|#
directive|else
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
endif|#
directive|endif
block|{
name|decpt
operator|=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|nd
condition|)
block|{
for|for
control|(
init|;
name|c
operator|==
literal|'0'
condition|;
name|c
operator|=
operator|*
operator|++
name|s
control|)
name|nz
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|s0
operator|=
name|s
expr_stmt|;
name|nf
operator|+=
name|nz
expr_stmt|;
name|nz
operator|=
literal|0
expr_stmt|;
goto|goto
name|have_dig
goto|;
block|}
goto|goto
name|dig_done
goto|;
block|}
for|for
control|(
init|;
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|;
name|c
operator|=
operator|*
operator|++
name|s
control|)
block|{
name|have_dig
label|:
name|nz
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|-=
literal|'0'
condition|)
block|{
name|nf
operator|+=
name|nz
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nz
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|nd
operator|++
operator|<
literal|9
condition|)
name|y
operator|*=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|<=
name|DBL_DIG
operator|+
literal|1
condition|)
name|z
operator|*=
literal|10
expr_stmt|;
if|if
condition|(
name|nd
operator|++
operator|<
literal|9
condition|)
name|y
operator|=
literal|10
operator|*
name|y
operator|+
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|<=
name|DBL_DIG
operator|+
literal|1
condition|)
name|z
operator|=
literal|10
operator|*
name|z
operator|+
name|c
expr_stmt|;
name|nz
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_if

begin_label
name|dig_done
label|:
end_label

begin_expr_stmt
name|e
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
condition|)
block|{
if|if
condition|(
operator|!
name|nd
operator|&&
operator|!
name|nz
operator|&&
operator|!
name|nz0
condition|)
block|{
goto|goto
name|ret0
goto|;
block|}
name|s00
operator|=
name|s
expr_stmt|;
name|esign
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
operator|++
name|s
condition|)
block|{
case|case
literal|'-'
case|:
name|esign
operator|=
literal|1
expr_stmt|;
case|case
literal|'+'
case|:
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|'0'
condition|)
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|L
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|s1
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|s
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|L
operator|=
literal|10
operator|*
name|L
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|s
operator|-
name|s1
operator|>
literal|8
operator|||
name|L
operator|>
literal|19999
condition|)
comment|/* Avoid confusion from exponents 					 * so large that e might overflow. 					 */
name|e
operator|=
literal|19999
expr_stmt|;
comment|/* safe for 16 bit ints */
else|else
name|e
operator|=
operator|(
name|int
operator|)
name|L
expr_stmt|;
if|if
condition|(
name|esign
condition|)
name|e
operator|=
operator|-
name|e
expr_stmt|;
block|}
else|else
name|e
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|s
operator|=
name|s00
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|nd
condition|)
block|{
if|if
condition|(
operator|!
name|nz
operator|&&
operator|!
name|nz0
condition|)
block|{
ifdef|#
directive|ifdef
name|INFNAN_CHECK
comment|/* Check for Nan and Infinity */
name|ULong
name|bits
index|[
literal|2
index|]
decl_stmt|;
specifier|static
name|FPI
name|fpinan
init|=
comment|/* only 52 explicit bits */
block|{
literal|52
block|,
literal|1
operator|-
literal|1023
operator|-
literal|53
operator|+
literal|1
block|,
literal|2046
operator|-
literal|1023
operator|-
literal|53
operator|+
literal|1
block|,
literal|1
block|,
name|SI
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|decpt
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
if|if
condition|(
name|match
argument_list|(
operator|&
name|s
argument_list|,
literal|"nf"
argument_list|)
condition|)
block|{
operator|--
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|match
argument_list|(
operator|&
name|s
argument_list|,
literal|"inity"
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
literal|0x7ff00000
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
literal|0
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
break|break;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
if|if
condition|(
name|match
argument_list|(
operator|&
name|s
argument_list|,
literal|"an"
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|No_Hex_NaN
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
comment|/*)*/
operator|&&
name|hexnan
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|fpinan
argument_list|,
name|bits
argument_list|)
operator|==
name|STRTOG_NaNbits
condition|)
block|{
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
literal|0x7ff00000
operator||
name|bits
index|[
literal|1
index|]
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
name|bits
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|NAN_WORD0
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
name|NAN_WORD1
expr_stmt|;
ifndef|#
directive|ifndef
name|No_Hex_NaN
block|}
endif|#
directive|endif
goto|goto
name|ret
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* INFNAN_CHECK */
name|ret0
label|:
name|s
operator|=
name|s00
expr_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|ret
goto|;
block|}
end_if

begin_expr_stmt
name|e1
operator|=
name|e
operator|-=
name|nf
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Now we have nd0 digits, starting at s0, followed by a 	 * decimal point, followed by nd-nd0 digits.  The number we're 	 * after is the integer represented by those digits times 	 * 10**e */
end_comment

begin_if
if|if
condition|(
operator|!
name|nd0
condition|)
name|nd0
operator|=
name|nd
expr_stmt|;
end_if

begin_expr_stmt
name|k
operator|=
name|nd
operator|<
name|DBL_DIG
operator|+
literal|1
condition|?
name|nd
else|:
name|DBL_DIG
operator|+
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dval
argument_list|(
name|rv
argument_list|)
operator|=
name|y
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|k
operator|>
literal|9
condition|)
block|{
ifdef|#
directive|ifdef
name|SET_INEXACT
if|if
condition|(
name|k
operator|>
name|DBL_DIG
condition|)
name|oldinexact
operator|=
name|get_inexact
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|dval
argument_list|(
name|rv
argument_list|)
operator|=
name|tens
index|[
name|k
operator|-
literal|9
index|]
operator|*
name|dval
argument_list|(
name|rv
argument_list|)
operator|+
name|z
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|bd0
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|nd
operator|<=
name|DBL_DIG
ifndef|#
directive|ifndef
name|RND_PRODQUOT
ifndef|#
directive|ifndef
name|Honor_FLT_ROUNDS
operator|&&
name|Flt_Rounds
operator|==
literal|1
endif|#
directive|endif
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
operator|!
name|e
condition|)
goto|goto
name|ret
goto|;
if|if
condition|(
name|e
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|<=
name|Ten_pmax
condition|)
block|{
ifdef|#
directive|ifdef
name|VAX
goto|goto
name|vax_ovfl_check
goto|;
else|#
directive|else
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
comment|/* round correctly FLT_ROUNDS = 2 or 3 */
if|if
condition|(
name|sign
condition|)
block|{
name|rv
operator|=
operator|-
name|rv
expr_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* rv = */
name|rounded_product
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|,
name|tens
index|[
name|e
index|]
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
endif|#
directive|endif
block|}
name|i
operator|=
name|DBL_DIG
operator|-
name|nd
expr_stmt|;
if|if
condition|(
name|e
operator|<=
name|Ten_pmax
operator|+
name|i
condition|)
block|{
comment|/* A fancier test would sometimes let us do 				 * this for larger i values. 				 */
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
comment|/* round correctly FLT_ROUNDS = 2 or 3 */
if|if
condition|(
name|sign
condition|)
block|{
name|rv
operator|=
operator|-
name|rv
expr_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|e
operator|-=
name|i
expr_stmt|;
name|dval
argument_list|(
name|rv
argument_list|)
operator|*=
name|tens
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|VAX
comment|/* VAX exponent range is so narrow we must 				 * worry about overflow here... 				 */
name|vax_ovfl_check
label|:
name|word0
argument_list|(
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
comment|/* rv = */
name|rounded_product
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|,
name|tens
index|[
name|e
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
literal|1
operator|-
name|P
operator|)
condition|)
goto|goto
name|ovfl
goto|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
else|#
directive|else
comment|/* rv = */
name|rounded_product
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|,
name|tens
index|[
name|e
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|ret
goto|;
block|}
block|}
ifndef|#
directive|ifndef
name|Inaccurate_Divide
elseif|else
if|if
condition|(
name|e
operator|>=
operator|-
name|Ten_pmax
condition|)
block|{
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
comment|/* round correctly FLT_ROUNDS = 2 or 3 */
if|if
condition|(
name|sign
condition|)
block|{
name|rv
operator|=
operator|-
name|rv
expr_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* rv = */
name|rounded_quotient
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|,
name|tens
index|[
operator|-
name|e
index|]
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
endif|#
directive|endif
block|}
end_if

begin_expr_stmt
name|e1
operator|+=
name|nd
operator|-
name|k
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_Arith
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|SET_INEXACT
end_ifdef

begin_expr_stmt
name|inexact
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|k
operator|<=
name|DBL_DIG
condition|)
name|oldinexact
operator|=
name|get_inexact
argument_list|()
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|Avoid_Underflow
end_ifdef

begin_expr_stmt
name|scale
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
end_ifdef

begin_if
if|if
condition|(
operator|(
name|rounding
operator|=
name|Flt_Rounds
operator|)
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|sign
condition|)
name|rounding
operator|=
name|rounding
operator|==
literal|2
condition|?
literal|0
else|:
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|rounding
operator|!=
literal|2
condition|)
name|rounding
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*IEEE_Arith*/
end_comment

begin_comment
comment|/* Get starting approximation = rv * 10**e1 */
end_comment

begin_if
if|if
condition|(
name|e1
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|e1
operator|&
literal|15
operator|)
operator|!=
literal|0
condition|)
name|dval
argument_list|(
name|rv
argument_list|)
operator|*=
name|tens
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e1
operator|&=
operator|~
literal|15
condition|)
block|{
if|if
condition|(
name|e1
operator|>
name|DBL_MAX_10_EXP
condition|)
block|{
name|ovfl
label|:
ifndef|#
directive|ifndef
name|NO_ERRNO
name|errno
operator|=
name|ERANGE
expr_stmt|;
endif|#
directive|endif
comment|/* Can't trust HUGE_VAL */
ifdef|#
directive|ifdef
name|IEEE_Arith
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
switch|switch
condition|(
name|rounding
condition|)
block|{
case|case
literal|0
case|:
comment|/* toward 0 */
case|case
literal|3
case|:
comment|/* toward -infinity */
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|Big0
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
name|Big1
expr_stmt|;
break|break;
default|default:
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|Exp_mask
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
comment|/*Honor_FLT_ROUNDS*/
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|Exp_mask
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/*Honor_FLT_ROUNDS*/
ifdef|#
directive|ifdef
name|SET_INEXACT
comment|/* set overflow bit */
name|dval
argument_list|(
name|rv0
argument_list|)
operator|=
literal|1e300
expr_stmt|;
name|dval
argument_list|(
name|rv0
argument_list|)
operator|*=
name|dval
argument_list|(
name|rv0
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/*IEEE_Arith*/
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|Big0
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
name|Big1
expr_stmt|;
endif|#
directive|endif
comment|/*IEEE_Arith*/
if|if
condition|(
name|bd0
condition|)
goto|goto
name|retfree
goto|;
goto|goto
name|ret
goto|;
block|}
name|e1
operator|>>=
literal|4
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|e1
operator|>
literal|1
condition|;
name|j
operator|++
operator|,
name|e1
operator|>>=
literal|1
control|)
if|if
condition|(
name|e1
operator|&
literal|1
condition|)
name|dval
argument_list|(
name|rv
argument_list|)
operator|*=
name|bigtens
index|[
name|j
index|]
expr_stmt|;
comment|/* The last multiplication could overflow. */
name|word0
argument_list|(
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
name|dval
argument_list|(
name|rv
argument_list|)
operator|*=
name|bigtens
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|=
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
name|P
operator|)
condition|)
goto|goto
name|ovfl
goto|;
if|if
condition|(
name|z
operator|>
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
literal|1
operator|-
name|P
operator|)
condition|)
block|{
comment|/* set to largest number */
comment|/* (Can't trust DBL_MAX) */
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|Big0
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
name|Big1
expr_stmt|;
block|}
else|else
name|word0
argument_list|(
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|e1
operator|<
literal|0
condition|)
block|{
name|e1
operator|=
operator|-
name|e1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|e1
operator|&
literal|15
operator|)
operator|!=
literal|0
condition|)
name|dval
argument_list|(
name|rv
argument_list|)
operator|/=
name|tens
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e1
operator|>>=
literal|4
condition|)
block|{
if|if
condition|(
name|e1
operator|>=
literal|1
operator|<<
name|n_bigtens
condition|)
goto|goto
name|undfl
goto|;
ifdef|#
directive|ifdef
name|Avoid_Underflow
if|if
condition|(
name|e1
operator|&
name|Scale_Bit
condition|)
name|scale
operator|=
literal|2
operator|*
name|P
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|e1
operator|>
literal|0
condition|;
name|j
operator|++
operator|,
name|e1
operator|>>=
literal|1
control|)
if|if
condition|(
name|e1
operator|&
literal|1
condition|)
name|dval
argument_list|(
name|rv
argument_list|)
operator|*=
name|tinytens
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|scale
operator|&&
operator|(
name|j
operator|=
literal|2
operator|*
name|P
operator|+
literal|1
operator|-
operator|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>>
name|Exp_shift
operator|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* scaled rv is denormal; zap j low bits */
if|if
condition|(
name|j
operator|>=
literal|32
condition|)
block|{
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|53
condition|)
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
operator|(
name|P
operator|+
literal|2
operator|)
operator|*
name|Exp_msk1
expr_stmt|;
else|else
name|word0
argument_list|(
name|rv
argument_list|)
operator|&=
literal|0xffffffff
operator|<<
name|j
operator|-
literal|32
expr_stmt|;
block|}
else|else
name|word1
argument_list|(
name|rv
argument_list|)
operator|&=
literal|0xffffffff
operator|<<
name|j
expr_stmt|;
block|}
else|#
directive|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|e1
operator|>
literal|1
condition|;
name|j
operator|++
operator|,
name|e1
operator|>>=
literal|1
control|)
if|if
condition|(
name|e1
operator|&
literal|1
condition|)
name|dval
argument_list|(
name|rv
argument_list|)
operator|*=
name|tinytens
index|[
name|j
index|]
expr_stmt|;
comment|/* The last multiplication could underflow. */
name|dval
argument_list|(
name|rv0
argument_list|)
operator|=
name|dval
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|dval
argument_list|(
name|rv
argument_list|)
operator|*=
name|tinytens
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|dval
argument_list|(
name|rv
argument_list|)
condition|)
block|{
name|dval
argument_list|(
name|rv
argument_list|)
operator|=
literal|2.
operator|*
name|dval
argument_list|(
name|rv0
argument_list|)
expr_stmt|;
name|dval
argument_list|(
name|rv
argument_list|)
operator|*=
name|tinytens
index|[
name|j
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|dval
argument_list|(
name|rv
argument_list|)
condition|)
block|{
name|undfl
label|:
name|dval
argument_list|(
name|rv
argument_list|)
operator|=
literal|0.
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_ERRNO
name|errno
operator|=
name|ERANGE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bd0
condition|)
goto|goto
name|retfree
goto|;
goto|goto
name|ret
goto|;
block|}
ifndef|#
directive|ifndef
name|Avoid_Underflow
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|Tiny0
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
name|Tiny1
expr_stmt|;
comment|/* The refinement below will clean 				 * this approximation up. 				 */
block|}
endif|#
directive|endif
block|}
block|}
end_if

begin_comment
comment|/* Now the hard part -- adjusting rv to the correct value.*/
end_comment

begin_comment
comment|/* Put digits into bd: true value = bd * 10^e */
end_comment

begin_expr_stmt
name|bd0
operator|=
name|s2b
argument_list|(
name|s0
argument_list|,
name|nd0
argument_list|,
name|nd
argument_list|,
name|y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
name|bd
operator|=
name|Balloc
argument_list|(
name|bd0
operator|->
name|k
argument_list|)
expr_stmt|;
name|Bcopy
argument_list|(
name|bd
argument_list|,
name|bd0
argument_list|)
expr_stmt|;
name|bb
operator|=
name|d2b
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|,
operator|&
name|bbe
argument_list|,
operator|&
name|bbbits
argument_list|)
expr_stmt|;
comment|/* rv = bb * 2^bbe */
name|bs
operator|=
name|i2b
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|>=
literal|0
condition|)
block|{
name|bb2
operator|=
name|bb5
operator|=
literal|0
expr_stmt|;
name|bd2
operator|=
name|bd5
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
name|bb2
operator|=
name|bb5
operator|=
operator|-
name|e
expr_stmt|;
name|bd2
operator|=
name|bd5
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bbe
operator|>=
literal|0
condition|)
name|bb2
operator|+=
name|bbe
expr_stmt|;
else|else
name|bd2
operator|-=
name|bbe
expr_stmt|;
name|bs2
operator|=
name|bb2
expr_stmt|;
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
if|if
condition|(
name|rounding
operator|!=
literal|1
condition|)
name|bs2
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Avoid_Underflow
name|j
operator|=
name|bbe
operator|-
name|scale
expr_stmt|;
name|i
operator|=
name|j
operator|+
name|bbbits
operator|-
literal|1
expr_stmt|;
comment|/* logb(rv) */
if|if
condition|(
name|i
operator|<
name|Emin
condition|)
comment|/* denormal */
name|j
operator|+=
name|P
operator|-
name|Emin
expr_stmt|;
else|else
name|j
operator|=
name|P
operator|+
literal|1
operator|-
name|bbbits
expr_stmt|;
else|#
directive|else
comment|/*Avoid_Underflow*/
ifdef|#
directive|ifdef
name|Sudden_Underflow
ifdef|#
directive|ifdef
name|IBM
name|j
operator|=
literal|1
operator|+
literal|4
operator|*
name|P
operator|-
literal|3
operator|-
name|bbbits
operator|+
operator|(
operator|(
name|bbe
operator|+
name|bbbits
operator|-
literal|1
operator|)
operator|&
literal|3
operator|)
expr_stmt|;
else|#
directive|else
name|j
operator|=
name|P
operator|+
literal|1
operator|-
name|bbbits
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/*Sudden_Underflow*/
name|j
operator|=
name|bbe
expr_stmt|;
name|i
operator|=
name|j
operator|+
name|bbbits
operator|-
literal|1
expr_stmt|;
comment|/* logb(rv) */
if|if
condition|(
name|i
operator|<
name|Emin
condition|)
comment|/* denormal */
name|j
operator|+=
name|P
operator|-
name|Emin
expr_stmt|;
else|else
name|j
operator|=
name|P
operator|+
literal|1
operator|-
name|bbbits
expr_stmt|;
endif|#
directive|endif
comment|/*Sudden_Underflow*/
endif|#
directive|endif
comment|/*Avoid_Underflow*/
name|bb2
operator|+=
name|j
expr_stmt|;
name|bd2
operator|+=
name|j
expr_stmt|;
ifdef|#
directive|ifdef
name|Avoid_Underflow
name|bd2
operator|+=
name|scale
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|bb2
operator|<
name|bd2
condition|?
name|bb2
else|:
name|bd2
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|bs2
condition|)
name|i
operator|=
name|bs2
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|bb2
operator|-=
name|i
expr_stmt|;
name|bd2
operator|-=
name|i
expr_stmt|;
name|bs2
operator|-=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|bb5
operator|>
literal|0
condition|)
block|{
name|bs
operator|=
name|pow5mult
argument_list|(
name|bs
argument_list|,
name|bb5
argument_list|)
expr_stmt|;
name|bb1
operator|=
name|mult
argument_list|(
name|bs
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bb
operator|=
name|bb1
expr_stmt|;
block|}
if|if
condition|(
name|bb2
operator|>
literal|0
condition|)
name|bb
operator|=
name|lshift
argument_list|(
name|bb
argument_list|,
name|bb2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bd5
operator|>
literal|0
condition|)
name|bd
operator|=
name|pow5mult
argument_list|(
name|bd
argument_list|,
name|bd5
argument_list|)
expr_stmt|;
if|if
condition|(
name|bd2
operator|>
literal|0
condition|)
name|bd
operator|=
name|lshift
argument_list|(
name|bd
argument_list|,
name|bd2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs2
operator|>
literal|0
condition|)
name|bs
operator|=
name|lshift
argument_list|(
name|bs
argument_list|,
name|bs2
argument_list|)
expr_stmt|;
name|delta
operator|=
name|diff
argument_list|(
name|bb
argument_list|,
name|bd
argument_list|)
expr_stmt|;
name|dsign
operator|=
name|delta
operator|->
name|sign
expr_stmt|;
name|delta
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|cmp
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
if|if
condition|(
name|rounding
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* Error is less than an ulp */
if|if
condition|(
operator|!
name|delta
operator|->
name|x
index|[
literal|0
index|]
operator|&&
name|delta
operator|->
name|wds
operator|<=
literal|1
condition|)
block|{
comment|/* exact */
ifdef|#
directive|ifdef
name|SET_INEXACT
name|inexact
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|rounding
condition|)
block|{
if|if
condition|(
name|dsign
condition|)
block|{
name|adj
operator|=
literal|1.
expr_stmt|;
goto|goto
name|apply_adj
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|dsign
condition|)
block|{
name|adj
operator|=
operator|-
literal|1.
expr_stmt|;
if|if
condition|(
operator|!
name|word1
argument_list|(
name|rv
argument_list|)
operator|&&
operator|!
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Frac_mask
operator|)
condition|)
block|{
name|y
operator|=
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
expr_stmt|;
ifdef|#
directive|ifdef
name|Avoid_Underflow
if|if
condition|(
operator|!
name|scale
operator|||
name|y
operator|>
literal|2
operator|*
name|P
operator|*
name|Exp_msk1
condition|)
else|#
directive|else
if|if
condition|(
name|y
condition|)
endif|#
directive|endif
block|{
name|delta
operator|=
name|lshift
argument_list|(
name|delta
argument_list|,
name|Log2P
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
operator|<=
literal|0
condition|)
name|adj
operator|=
operator|-
literal|0.5
expr_stmt|;
block|}
block|}
name|apply_adj
label|:
ifdef|#
directive|ifdef
name|Avoid_Underflow
if|if
condition|(
name|scale
operator|&&
operator|(
name|y
operator|=
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
literal|2
operator|*
name|P
operator|*
name|Exp_msk1
condition|)
name|word0
argument_list|(
name|adj
argument_list|)
operator|+=
operator|(
literal|2
operator|*
name|P
operator|+
literal|1
operator|)
operator|*
name|Exp_msk1
operator|-
name|y
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|Sudden_Underflow
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
name|P
operator|*
name|Exp_msk1
condition|)
block|{
name|word0
argument_list|(
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
name|dval
argument_list|(
name|rv
argument_list|)
operator|+=
name|adj
operator|*
name|ulp
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|)
expr_stmt|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/*Sudden_Underflow*/
endif|#
directive|endif
comment|/*Avoid_Underflow*/
name|dval
argument_list|(
name|rv
argument_list|)
operator|+=
name|adj
operator|*
name|ulp
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|adj
operator|=
name|ratio
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|adj
operator|<
literal|1.
condition|)
name|adj
operator|=
literal|1.
expr_stmt|;
if|if
condition|(
name|adj
operator|<=
literal|0x7ffffffe
condition|)
block|{
comment|/* adj = rounding ? ceil(adj) : floor(adj); */
name|y
operator|=
name|adj
expr_stmt|;
if|if
condition|(
name|y
operator|!=
name|adj
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|rounding
operator|>>
literal|1
operator|)
operator|^
name|dsign
operator|)
condition|)
name|y
operator|++
expr_stmt|;
name|adj
operator|=
name|y
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|Avoid_Underflow
if|if
condition|(
name|scale
operator|&&
operator|(
name|y
operator|=
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
literal|2
operator|*
name|P
operator|*
name|Exp_msk1
condition|)
name|word0
argument_list|(
name|adj
argument_list|)
operator|+=
operator|(
literal|2
operator|*
name|P
operator|+
literal|1
operator|)
operator|*
name|Exp_msk1
operator|-
name|y
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|Sudden_Underflow
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
name|P
operator|*
name|Exp_msk1
condition|)
block|{
name|word0
argument_list|(
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
name|adj
operator|*=
name|ulp
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsign
condition|)
name|dval
argument_list|(
name|rv
argument_list|)
operator|+=
name|adj
expr_stmt|;
else|else
name|dval
argument_list|(
name|rv
argument_list|)
operator|-=
name|adj
expr_stmt|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
endif|#
directive|endif
comment|/*Sudden_Underflow*/
endif|#
directive|endif
comment|/*Avoid_Underflow*/
name|adj
operator|*=
name|ulp
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsign
condition|)
name|dval
argument_list|(
name|rv
argument_list|)
operator|+=
name|adj
expr_stmt|;
else|else
name|dval
argument_list|(
name|rv
argument_list|)
operator|-=
name|adj
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
endif|#
directive|endif
comment|/*Honor_FLT_ROUNDS*/
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* Error is less than half an ulp -- check for 			 * special case of mantissa a power of two. 			 */
if|if
condition|(
name|dsign
operator|||
name|word1
argument_list|(
name|rv
argument_list|)
operator|||
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask
ifdef|#
directive|ifdef
name|IEEE_Arith
ifdef|#
directive|ifdef
name|Avoid_Underflow
operator|||
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
operator|(
literal|2
operator|*
name|P
operator|+
literal|1
operator|)
operator|*
name|Exp_msk1
else|#
directive|else
operator|||
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
name|Exp_msk1
endif|#
directive|endif
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|SET_INEXACT
if|if
condition|(
operator|!
name|delta
operator|->
name|x
index|[
literal|0
index|]
operator|&&
name|delta
operator|->
name|wds
operator|<=
literal|1
condition|)
name|inexact
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
operator|!
name|delta
operator|->
name|x
index|[
literal|0
index|]
operator|&&
name|delta
operator|->
name|wds
operator|<=
literal|1
condition|)
block|{
comment|/* exact result */
ifdef|#
directive|ifdef
name|SET_INEXACT
name|inexact
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|delta
operator|=
name|lshift
argument_list|(
name|delta
argument_list|,
name|Log2P
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|drop_down
goto|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* exactly half-way between */
if|if
condition|(
name|dsign
condition|)
block|{
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask1
operator|)
operator|==
name|Bndry_mask1
operator|&&
name|word1
argument_list|(
name|rv
argument_list|)
operator|==
operator|(
ifdef|#
directive|ifdef
name|Avoid_Underflow
operator|(
name|scale
operator|&&
operator|(
name|y
operator|=
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
literal|2
operator|*
name|P
operator|*
name|Exp_msk1
operator|)
condition|?
operator|(
literal|0xffffffff
operator|&
operator|(
literal|0xffffffff
operator|<<
operator|(
literal|2
operator|*
name|P
operator|+
literal|1
operator|-
operator|(
name|y
operator|>>
name|Exp_shift
operator|)
operator|)
operator|)
operator|)
else|:
endif|#
directive|endif
literal|0xffffffff
operator|)
condition|)
block|{
comment|/*boundary case -- increment exponent*/
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|+
name|Exp_msk1
ifdef|#
directive|ifdef
name|IBM
operator||
name|Exp_msk1
operator|>>
literal|4
endif|#
directive|endif
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|Avoid_Underflow
name|dsign
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask
operator|)
operator|&&
operator|!
name|word1
argument_list|(
name|rv
argument_list|)
condition|)
block|{
name|drop_down
label|:
comment|/* boundary case -- decrement exponent */
ifdef|#
directive|ifdef
name|Sudden_Underflow
comment|/*{{*/
name|L
operator|=
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
if|if
condition|(
name|L
operator|<
name|Exp_msk1
condition|)
else|#
directive|else
ifdef|#
directive|ifdef
name|Avoid_Underflow
if|if
condition|(
name|L
operator|<=
operator|(
name|scale
condition|?
operator|(
literal|2
operator|*
name|P
operator|+
literal|1
operator|)
operator|*
name|Exp_msk1
else|:
name|Exp_msk1
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|L
operator|<=
name|Exp_msk1
condition|)
endif|#
directive|endif
comment|/*Avoid_Underflow*/
endif|#
directive|endif
comment|/*IBM*/
goto|goto
name|undfl
goto|;
name|L
operator|-=
name|Exp_msk1
expr_stmt|;
else|#
directive|else
comment|/*Sudden_Underflow}{*/
ifdef|#
directive|ifdef
name|Avoid_Underflow
if|if
condition|(
name|scale
condition|)
block|{
name|L
operator|=
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
expr_stmt|;
if|if
condition|(
name|L
operator|<=
operator|(
literal|2
operator|*
name|P
operator|+
literal|1
operator|)
operator|*
name|Exp_msk1
condition|)
block|{
if|if
condition|(
name|L
operator|>
operator|(
name|P
operator|+
literal|2
operator|)
operator|*
name|Exp_msk1
condition|)
comment|/* round even ==> */
comment|/* accept rv */
break|break;
comment|/* rv = smallest denormal */
goto|goto
name|undfl
goto|;
block|}
block|}
endif|#
directive|endif
comment|/*Avoid_Underflow*/
name|L
operator|=
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|-
name|Exp_msk1
expr_stmt|;
endif|#
directive|endif
comment|/*Sudden_Underflow}*/
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|L
operator||
name|Bndry_mask1
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
literal|0xffffffff
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
goto|goto
name|cont
goto|;
else|#
directive|else
break|break;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|ROUND_BIASED
if|if
condition|(
operator|!
operator|(
name|word1
argument_list|(
name|rv
argument_list|)
operator|&
name|LSB
operator|)
condition|)
break|break;
endif|#
directive|endif
if|if
condition|(
name|dsign
condition|)
name|dval
argument_list|(
name|rv
argument_list|)
operator|+=
name|ulp
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ROUND_BIASED
else|else
block|{
name|dval
argument_list|(
name|rv
argument_list|)
operator|-=
name|ulp
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|Sudden_Underflow
if|if
condition|(
operator|!
name|dval
argument_list|(
name|rv
argument_list|)
condition|)
goto|goto
name|undfl
goto|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|Avoid_Underflow
name|dsign
operator|=
literal|1
operator|-
name|dsign
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
operator|(
name|aadj
operator|=
name|ratio
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
operator|)
operator|<=
literal|2.
condition|)
block|{
if|if
condition|(
name|dsign
condition|)
name|aadj
operator|=
name|aadj1
operator|=
literal|1.
expr_stmt|;
elseif|else
if|if
condition|(
name|word1
argument_list|(
name|rv
argument_list|)
operator|||
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask
condition|)
block|{
ifndef|#
directive|ifndef
name|Sudden_Underflow
if|if
condition|(
name|word1
argument_list|(
name|rv
argument_list|)
operator|==
name|Tiny1
operator|&&
operator|!
name|word0
argument_list|(
name|rv
argument_list|)
condition|)
goto|goto
name|undfl
goto|;
endif|#
directive|endif
name|aadj
operator|=
literal|1.
expr_stmt|;
name|aadj1
operator|=
operator|-
literal|1.
expr_stmt|;
block|}
else|else
block|{
comment|/* special case -- power of FLT_RADIX to be */
comment|/* rounded down... */
if|if
condition|(
name|aadj
operator|<
literal|2.
operator|/
name|FLT_RADIX
condition|)
name|aadj
operator|=
literal|1.
operator|/
name|FLT_RADIX
expr_stmt|;
else|else
name|aadj
operator|*=
literal|0.5
expr_stmt|;
name|aadj1
operator|=
operator|-
name|aadj
expr_stmt|;
block|}
block|}
else|else
block|{
name|aadj
operator|*=
literal|0.5
expr_stmt|;
name|aadj1
operator|=
name|dsign
condition|?
name|aadj
else|:
operator|-
name|aadj
expr_stmt|;
ifdef|#
directive|ifdef
name|Check_FLT_ROUNDS
switch|switch
condition|(
name|Rounding
condition|)
block|{
case|case
literal|2
case|:
comment|/* towards +infinity */
name|aadj1
operator|-=
literal|0.5
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* towards 0 */
case|case
literal|3
case|:
comment|/* towards -infinity */
name|aadj1
operator|+=
literal|0.5
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|Flt_Rounds
operator|==
literal|0
condition|)
name|aadj1
operator|+=
literal|0.5
expr_stmt|;
endif|#
directive|endif
comment|/*Check_FLT_ROUNDS*/
block|}
name|y
operator|=
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
expr_stmt|;
comment|/* Check for overflow */
if|if
condition|(
name|y
operator|==
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
literal|1
operator|)
condition|)
block|{
name|dval
argument_list|(
name|rv0
argument_list|)
operator|=
name|dval
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
name|adj
operator|=
name|aadj1
operator|*
name|ulp
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|)
expr_stmt|;
name|dval
argument_list|(
name|rv
argument_list|)
operator|+=
name|adj
expr_stmt|;
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>=
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
name|P
operator|)
condition|)
block|{
if|if
condition|(
name|word0
argument_list|(
name|rv0
argument_list|)
operator|==
name|Big0
operator|&&
name|word1
argument_list|(
name|rv0
argument_list|)
operator|==
name|Big1
condition|)
goto|goto
name|ovfl
goto|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|Big0
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
name|Big1
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
else|else
name|word0
argument_list|(
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|Avoid_Underflow
if|if
condition|(
name|scale
operator|&&
name|y
operator|<=
literal|2
operator|*
name|P
operator|*
name|Exp_msk1
condition|)
block|{
if|if
condition|(
name|aadj
operator|<=
literal|0x7fffffff
condition|)
block|{
if|if
condition|(
operator|(
name|z
operator|=
name|aadj
operator|)
operator|<=
literal|0
condition|)
name|z
operator|=
literal|1
expr_stmt|;
name|aadj
operator|=
name|z
expr_stmt|;
name|aadj1
operator|=
name|dsign
condition|?
name|aadj
else|:
operator|-
name|aadj
expr_stmt|;
block|}
name|word0
argument_list|(
name|aadj1
argument_list|)
operator|+=
operator|(
literal|2
operator|*
name|P
operator|+
literal|1
operator|)
operator|*
name|Exp_msk1
operator|-
name|y
expr_stmt|;
block|}
name|adj
operator|=
name|aadj1
operator|*
name|ulp
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|)
expr_stmt|;
name|dval
argument_list|(
name|rv
argument_list|)
operator|+=
name|adj
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|Sudden_Underflow
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
name|P
operator|*
name|Exp_msk1
condition|)
block|{
name|dval
argument_list|(
name|rv0
argument_list|)
operator|=
name|dval
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
name|adj
operator|=
name|aadj1
operator|*
name|ulp
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|)
expr_stmt|;
name|dval
argument_list|(
name|rv
argument_list|)
operator|+=
name|adj
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<
name|P
operator|*
name|Exp_msk1
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
name|P
operator|*
name|Exp_msk1
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|word0
argument_list|(
name|rv0
argument_list|)
operator|==
name|Tiny0
operator|&&
name|word1
argument_list|(
name|rv0
argument_list|)
operator|==
name|Tiny1
condition|)
goto|goto
name|undfl
goto|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|Tiny0
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
name|Tiny1
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
else|else
name|word0
argument_list|(
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
block|}
else|else
block|{
name|adj
operator|=
name|aadj1
operator|*
name|ulp
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|)
expr_stmt|;
name|dval
argument_list|(
name|rv
argument_list|)
operator|+=
name|adj
expr_stmt|;
block|}
else|#
directive|else
comment|/*Sudden_Underflow*/
comment|/* Compute adj so that the IEEE rounding rules will 			 * correctly round rv + adj in some half-way cases. 			 * If rv * ulp(rv) is denormalized (i.e., 			 * y<= (P-1)*Exp_msk1), we must adjust aadj to avoid 			 * trouble from bits lost to denormalization; 			 * example: 1.2e-307 . 			 */
if|if
condition|(
name|y
operator|<=
operator|(
name|P
operator|-
literal|1
operator|)
operator|*
name|Exp_msk1
operator|&&
name|aadj
operator|>
literal|1.
condition|)
block|{
name|aadj1
operator|=
call|(
name|double
call|)
argument_list|(
name|int
argument_list|)
argument_list|(
name|aadj
operator|+
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsign
condition|)
name|aadj1
operator|=
operator|-
name|aadj1
expr_stmt|;
block|}
name|adj
operator|=
name|aadj1
operator|*
name|ulp
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|)
expr_stmt|;
name|dval
argument_list|(
name|rv
argument_list|)
operator|+=
name|adj
expr_stmt|;
endif|#
directive|endif
comment|/*Sudden_Underflow*/
endif|#
directive|endif
comment|/*Avoid_Underflow*/
block|}
name|z
operator|=
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
expr_stmt|;
ifndef|#
directive|ifndef
name|SET_INEXACT
ifdef|#
directive|ifdef
name|Avoid_Underflow
if|if
condition|(
operator|!
name|scale
condition|)
endif|#
directive|endif
if|if
condition|(
name|y
operator|==
name|z
condition|)
block|{
comment|/* Can we stop now? */
name|L
operator|=
operator|(
name|Long
operator|)
name|aadj
expr_stmt|;
name|aadj
operator|-=
name|L
expr_stmt|;
comment|/* The tolerances below are conservative. */
if|if
condition|(
name|dsign
operator|||
name|word1
argument_list|(
name|rv
argument_list|)
operator|||
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask
condition|)
block|{
if|if
condition|(
name|aadj
operator|<
literal|.4999999
operator|||
name|aadj
operator|>
literal|.5000001
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|aadj
operator|<
literal|.4999999
operator|/
name|FLT_RADIX
condition|)
break|break;
block|}
endif|#
directive|endif
name|cont
label|:
name|Bfree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
end_for

begin_ifdef
ifdef|#
directive|ifdef
name|SET_INEXACT
end_ifdef

begin_if
if|if
condition|(
name|inexact
condition|)
block|{
if|if
condition|(
operator|!
name|oldinexact
condition|)
block|{
name|word0
argument_list|(
name|rv0
argument_list|)
operator|=
name|Exp_1
operator|+
operator|(
literal|70
operator|<<
name|Exp_shift
operator|)
expr_stmt|;
name|word1
argument_list|(
name|rv0
argument_list|)
operator|=
literal|0
expr_stmt|;
name|dval
argument_list|(
name|rv0
argument_list|)
operator|+=
literal|1.
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|oldinexact
condition|)
name|clear_inexact
argument_list|()
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|Avoid_Underflow
end_ifdef

begin_if
if|if
condition|(
name|scale
condition|)
block|{
name|word0
argument_list|(
name|rv0
argument_list|)
operator|=
name|Exp_1
operator|-
literal|2
operator|*
name|P
operator|*
name|Exp_msk1
expr_stmt|;
name|word1
argument_list|(
name|rv0
argument_list|)
operator|=
literal|0
expr_stmt|;
name|dval
argument_list|(
name|rv
argument_list|)
operator|*=
name|dval
argument_list|(
name|rv0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_ERRNO
comment|/* try to avoid the bug of testing an 8087 register value */
if|if
condition|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|==
literal|0
operator|&&
name|word1
argument_list|(
name|rv
argument_list|)
operator|==
literal|0
condition|)
name|errno
operator|=
name|ERANGE
expr_stmt|;
endif|#
directive|endif
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Avoid_Underflow */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SET_INEXACT
end_ifdef

begin_if
if|if
condition|(
name|inexact
operator|&&
operator|!
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
condition|)
block|{
comment|/* set underflow bit */
name|dval
argument_list|(
name|rv0
argument_list|)
operator|=
literal|1e-300
expr_stmt|;
name|dval
argument_list|(
name|rv0
argument_list|)
operator|*=
name|dval
argument_list|(
name|rv0
argument_list|)
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_label
name|retfree
label|:
end_label

begin_expr_stmt
name|Bfree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|bd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|bs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|bd0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|delta
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|ret
label|:
end_label

begin_if
if|if
condition|(
name|se
condition|)
operator|*
name|se
operator|=
operator|(
name|char
operator|*
operator|)
name|s
expr_stmt|;
end_if

begin_return
return|return
name|sign
condition|?
operator|-
name|dval
argument_list|(
name|rv
argument_list|)
else|:
name|dval
argument_list|(
name|rv
argument_list|)
return|;
end_return

unit|}
end_unit

