begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************  The author of this software is David M. Gay.  Copyright (C) 1998 by Lucent Technologies All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name of Lucent or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ****************************************************************/
end_comment

begin_comment
comment|/* Please send bug reports to David M. Gay (dmg at acm dot org,  * with " at " changed at "@" and " dot " changed to ".").	*/
end_comment

begin_include
include|#
directive|include
file|"gdtoaimp.h"
end_include

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|strtoIg
parameter_list|(
name|s00
parameter_list|,
name|se
parameter_list|,
name|fpi
parameter_list|,
name|exp
parameter_list|,
name|B
parameter_list|,
name|rvp
parameter_list|)
name|CONST
name|char
modifier|*
name|s00
decl_stmt|;
name|char
modifier|*
modifier|*
name|se
decl_stmt|;
name|FPI
modifier|*
name|fpi
decl_stmt|;
name|Long
modifier|*
name|exp
decl_stmt|;
name|Bigint
modifier|*
modifier|*
name|B
decl_stmt|;
name|int
modifier|*
name|rvp
decl_stmt|;
else|#
directive|else
function|strtoIg
parameter_list|(
name|CONST
name|char
modifier|*
name|s00
parameter_list|,
name|char
modifier|*
modifier|*
name|se
parameter_list|,
name|FPI
modifier|*
name|fpi
parameter_list|,
name|Long
modifier|*
name|exp
parameter_list|,
name|Bigint
modifier|*
modifier|*
name|B
parameter_list|,
name|int
modifier|*
name|rvp
parameter_list|)
endif|#
directive|endif
block|{
name|Bigint
modifier|*
name|b
decl_stmt|,
modifier|*
name|b1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nb
decl_stmt|,
name|nw
decl_stmt|,
name|nw1
decl_stmt|,
name|rv
decl_stmt|,
name|rv1
decl_stmt|,
name|swap
decl_stmt|;
name|unsigned
name|int
name|nb1
decl_stmt|,
name|nb11
decl_stmt|;
name|Long
name|e1
decl_stmt|;
name|b
operator|=
operator|*
name|B
expr_stmt|;
name|rv
operator|=
name|strtodg
argument_list|(
name|s00
argument_list|,
name|se
argument_list|,
name|fpi
argument_list|,
name|exp
argument_list|,
name|b
operator|->
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rv
operator|&
name|STRTOG_Inexact
operator|)
condition|)
block|{
name|B
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|*
name|rvp
operator|=
name|rv
return|;
block|}
name|e1
operator|=
name|exp
index|[
literal|0
index|]
expr_stmt|;
name|rv1
operator|=
name|rv
operator|^
name|STRTOG_Inexact
expr_stmt|;
name|b1
operator|=
name|Balloc
argument_list|(
name|b
operator|->
name|k
argument_list|)
expr_stmt|;
name|Bcopy
argument_list|(
name|b1
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|nb
operator|=
name|fpi
operator|->
name|nbits
expr_stmt|;
name|nb1
operator|=
name|nb
operator|&
literal|31
expr_stmt|;
name|nb11
operator|=
operator|(
name|nb1
operator|-
literal|1
operator|)
operator|&
literal|31
expr_stmt|;
name|nw
operator|=
name|b
operator|->
name|wds
expr_stmt|;
name|nw1
operator|=
name|nw
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|rv
operator|&
name|STRTOG_Inexlo
condition|)
block|{
name|swap
operator|=
literal|0
expr_stmt|;
name|b1
operator|=
name|increment
argument_list|(
name|b1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpi
operator|->
name|sudden_underflow
operator|&&
operator|(
name|rv
operator|&
name|STRTOG_Retmask
operator|)
operator|==
name|STRTOG_Zero
condition|)
block|{
name|b1
operator|->
name|x
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|b1
operator|->
name|x
index|[
name|nw1
index|]
operator|=
literal|1L
operator|<<
name|nb11
expr_stmt|;
name|rv1
operator|+=
name|STRTOG_Normal
operator|-
name|STRTOG_Zero
expr_stmt|;
name|rv1
operator|&=
operator|~
name|STRTOG_Underflow
expr_stmt|;
goto|goto
name|swapcheck
goto|;
block|}
if|if
condition|(
name|b1
operator|->
name|wds
operator|>
name|nw
operator|||
name|nb1
operator|&&
name|b1
operator|->
name|x
index|[
name|nw1
index|]
operator|&
literal|1L
operator|<<
name|nb1
condition|)
block|{
if|if
condition|(
operator|++
name|e1
operator|>
name|fpi
operator|->
name|emax
condition|)
name|rv1
operator|=
name|STRTOG_Infinite
operator||
name|STRTOG_Inexhi
expr_stmt|;
name|rshift
argument_list|(
name|b1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rv
operator|&
name|STRTOG_Retmask
operator|)
operator|==
name|STRTOG_Denormal
condition|)
block|{
if|if
condition|(
name|b1
operator|->
name|x
index|[
name|nw1
index|]
operator|&
literal|1L
operator|<<
name|nb11
condition|)
block|{
name|rv1
operator|+=
name|STRTOG_Normal
operator|-
name|STRTOG_Denormal
expr_stmt|;
name|rv1
operator|&=
operator|~
name|STRTOG_Underflow
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|swap
operator|=
name|STRTOG_Neg
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|&
name|STRTOG_Retmask
operator|)
operator|==
name|STRTOG_Infinite
condition|)
block|{
name|b1
operator|=
name|set_ones
argument_list|(
name|b1
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|e1
operator|=
name|fpi
operator|->
name|emax
expr_stmt|;
name|rv1
operator|=
name|STRTOG_Normal
operator||
name|STRTOG_Inexlo
expr_stmt|;
goto|goto
name|swapcheck
goto|;
block|}
name|decrement
argument_list|(
name|b1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|&
name|STRTOG_Retmask
operator|)
operator|==
name|STRTOG_Denormal
condition|)
block|{
for|for
control|(
name|i
operator|=
name|nw1
init|;
operator|!
name|b1
operator|->
name|x
index|[
name|i
index|]
condition|;
operator|--
name|i
control|)
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|rv1
operator|=
name|STRTOG_Zero
operator||
name|STRTOG_Inexlo
expr_stmt|;
break|break;
block|}
goto|goto
name|swapcheck
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|b1
operator|->
name|x
index|[
name|nw1
index|]
operator|&
literal|1L
operator|<<
name|nb11
operator|)
condition|)
block|{
if|if
condition|(
name|e1
operator|==
name|fpi
operator|->
name|emin
condition|)
block|{
if|if
condition|(
name|fpi
operator|->
name|sudden_underflow
condition|)
name|rv1
operator|+=
name|STRTOG_Zero
operator|-
name|STRTOG_Normal
expr_stmt|;
else|else
name|rv1
operator|+=
name|STRTOG_Denormal
operator|-
name|STRTOG_Normal
expr_stmt|;
name|rv1
operator||=
name|STRTOG_Underflow
expr_stmt|;
block|}
else|else
block|{
name|b1
operator|=
name|lshift
argument_list|(
name|b1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|b1
operator|->
name|x
index|[
literal|0
index|]
operator||=
literal|1
expr_stmt|;
operator|--
name|e1
expr_stmt|;
block|}
block|}
block|}
name|swapcheck
label|:
if|if
condition|(
name|swap
operator|^
operator|(
name|rv
operator|&
name|STRTOG_Neg
operator|)
condition|)
block|{
name|rvp
index|[
literal|0
index|]
operator|=
name|rv1
expr_stmt|;
name|rvp
index|[
literal|1
index|]
operator|=
name|rv
expr_stmt|;
name|B
index|[
literal|0
index|]
operator|=
name|b1
expr_stmt|;
name|B
index|[
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|exp
index|[
literal|1
index|]
operator|=
name|exp
index|[
literal|0
index|]
expr_stmt|;
name|exp
index|[
literal|0
index|]
operator|=
name|e1
expr_stmt|;
block|}
else|else
block|{
name|rvp
index|[
literal|0
index|]
operator|=
name|rv
expr_stmt|;
name|rvp
index|[
literal|1
index|]
operator|=
name|rv1
expr_stmt|;
name|B
index|[
literal|1
index|]
operator|=
name|b1
expr_stmt|;
name|exp
index|[
literal|1
index|]
operator|=
name|e1
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

end_unit

