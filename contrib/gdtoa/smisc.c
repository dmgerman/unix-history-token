begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************  The author of this software is David M. Gay.  Copyright (C) 1998, 1999 by Lucent Technologies All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name of Lucent or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ****************************************************************/
end_comment

begin_comment
comment|/* Please send bug reports to David M. Gay (dmg at acm dot org,  * with " at " changed at "@" and " dot " changed to ".").	*/
end_comment

begin_include
include|#
directive|include
file|"gdtoaimp.h"
end_include

begin_decl_stmt
name|Bigint
modifier|*
name|s2b
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|s
argument_list|,
name|nd0
argument_list|,
name|nd
argument_list|,
name|y9
argument_list|,
name|dplen
argument_list|)
name|CONST
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dplen
decl_stmt|,
name|nd0
decl_stmt|,
name|nd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ULong
name|y9
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|CONST
name|char
operator|*
name|s
operator|,
name|int
name|nd0
operator|,
name|int
name|nd
operator|,
name|ULong
name|y9
operator|,
name|int
name|dplen
operator|)
endif|#
directive|endif
block|{
name|Bigint
operator|*
name|b
block|;
name|int
name|i
block|,
name|k
block|;
name|Long
name|x
block|,
name|y
block|;
name|x
operator|=
operator|(
name|nd
operator|+
literal|8
operator|)
operator|/
literal|9
block|;
for|for
control|(
name|k
operator|=
literal|0
operator|,
name|y
operator|=
literal|1
init|;
name|x
operator|>
name|y
condition|;
name|y
operator|<<=
literal|1
operator|,
name|k
operator|++
control|)
empty_stmt|;
ifdef|#
directive|ifdef
name|Pack_32
name|b
operator|=
name|Balloc
argument_list|(
name|k
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|b
operator|->
name|x
index|[
literal|0
index|]
operator|=
name|y9
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|b
operator|->
name|wds
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|b
operator|=
name|Balloc
argument_list|(
name|k
operator|+
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|b
operator|->
name|x
index|[
literal|0
index|]
operator|=
name|y9
operator|&
literal|0xffff
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|b
operator|->
name|wds
operator|=
operator|(
name|b
operator|->
name|x
index|[
literal|1
index|]
operator|=
name|y9
operator|>>
literal|16
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|i
operator|=
literal|9
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
literal|9
operator|<
name|nd0
condition|)
block|{
name|s
operator|+=
literal|9
expr_stmt|;
do|do
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
literal|10
argument_list|,
operator|*
name|s
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
do|while
condition|(
operator|++
name|i
operator|<
name|nd0
condition|)
do|;
name|s
operator|+=
name|dplen
expr_stmt|;
block|}
else|else
name|s
operator|+=
name|dplen
operator|+
literal|9
expr_stmt|;
end_if

begin_for
for|for
control|(
init|;
name|i
operator|<
name|nd
condition|;
name|i
operator|++
control|)
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
literal|10
argument_list|,
operator|*
name|s
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
end_for

begin_return
return|return
name|b
return|;
end_return

begin_macro
unit|}   double
name|ratio
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|Bigint
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|a
operator|,
name|Bigint
operator|*
name|b
operator|)
endif|#
directive|endif
block|{
name|double
name|da
block|,
name|db
block|;
name|int
name|k
block|,
name|ka
block|,
name|kb
block|;
name|dval
argument_list|(
name|da
argument_list|)
operator|=
name|b2d
argument_list|(
name|a
argument_list|,
operator|&
name|ka
argument_list|)
block|;
name|dval
argument_list|(
name|db
argument_list|)
operator|=
name|b2d
argument_list|(
name|b
argument_list|,
operator|&
name|kb
argument_list|)
block|;
name|k
operator|=
name|ka
operator|-
name|kb
operator|+
name|ULbits
operator|*
operator|(
name|a
operator|->
name|wds
operator|-
name|b
operator|->
name|wds
operator|)
block|;
ifdef|#
directive|ifdef
name|IBM
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
name|word0
argument_list|(
name|da
argument_list|)
operator|+=
operator|(
name|k
operator|>>
literal|2
operator|)
operator|*
name|Exp_msk1
expr_stmt|;
if|if
condition|(
name|k
operator|&=
literal|3
condition|)
name|dval
argument_list|(
name|da
argument_list|)
operator|*=
literal|1
operator|<<
name|k
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|k
operator|=
operator|-
name|k
expr_stmt|;
name|word0
argument_list|(
name|db
argument_list|)
operator|+=
operator|(
name|k
operator|>>
literal|2
operator|)
operator|*
name|Exp_msk1
expr_stmt|;
if|if
condition|(
name|k
operator|&=
literal|3
condition|)
name|dval
argument_list|(
name|db
argument_list|)
operator|*=
literal|1
operator|<<
name|k
expr_stmt|;
block|}
end_else

begin_else
else|#
directive|else
end_else

begin_if
if|if
condition|(
name|k
operator|>
literal|0
condition|)
name|word0
argument_list|(
name|da
argument_list|)
operator|+=
name|k
operator|*
name|Exp_msk1
expr_stmt|;
else|else
block|{
name|k
operator|=
operator|-
name|k
expr_stmt|;
name|word0
argument_list|(
name|db
argument_list|)
operator|+=
name|k
operator|*
name|Exp_msk1
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
name|dval
argument_list|(
name|da
argument_list|)
operator|/
name|dval
argument_list|(
name|db
argument_list|)
return|;
end_return

begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|INFNAN_CHECK
end_ifdef

begin_macro
unit|int
name|match
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
argument|sp
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|sp
decl_stmt|,
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|CONST
name|char
operator|*
operator|*
name|sp
operator|,
name|char
operator|*
name|t
operator|)
endif|#
directive|endif
block|{
name|int
name|c
block|,
name|d
block|;
name|CONST
name|char
operator|*
name|s
operator|=
operator|*
name|sp
block|;
while|while
condition|(
operator|(
name|d
operator|=
operator|*
name|t
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|s
operator|)
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
name|c
operator|+=
literal|'a'
operator|-
literal|'A'
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|d
condition|)
return|return
literal|0
return|;
block|}
operator|*
name|sp
operator|=
name|s
operator|+
literal|1
expr_stmt|;
end_expr_stmt

begin_return
return|return
literal|1
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* INFNAN_CHECK */
end_comment

begin_ifdef
unit|void
ifdef|#
directive|ifdef
name|KR_headers
end_ifdef

begin_macro
name|copybits
argument_list|(
argument|c
argument_list|,
argument|n
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|ULong
modifier|*
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Bigint
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_macro
name|copybits
argument_list|(
argument|ULong *c
argument_list|,
argument|int n
argument_list|,
argument|Bigint *b
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|ULong
modifier|*
name|ce
decl_stmt|,
modifier|*
name|x
decl_stmt|,
modifier|*
name|xe
decl_stmt|;
ifdef|#
directive|ifdef
name|Pack_16
name|int
name|nw
decl_stmt|,
name|nw1
decl_stmt|;
endif|#
directive|endif
name|ce
operator|=
name|c
operator|+
operator|(
operator|(
name|n
operator|-
literal|1
operator|)
operator|>>
name|kshift
operator|)
operator|+
literal|1
expr_stmt|;
name|x
operator|=
name|b
operator|->
name|x
expr_stmt|;
ifdef|#
directive|ifdef
name|Pack_32
name|xe
operator|=
name|x
operator|+
name|b
operator|->
name|wds
expr_stmt|;
while|while
condition|(
name|x
operator|<
name|xe
condition|)
operator|*
name|c
operator|++
operator|=
operator|*
name|x
operator|++
expr_stmt|;
else|#
directive|else
name|nw
operator|=
name|b
operator|->
name|wds
expr_stmt|;
name|nw1
operator|=
name|nw
operator|&
literal|1
expr_stmt|;
for|for
control|(
name|xe
operator|=
name|x
operator|+
operator|(
name|nw
operator|-
name|nw1
operator|)
init|;
name|x
operator|<
name|xe
condition|;
name|x
operator|+=
literal|2
control|)
name|Storeinc
argument_list|(
name|c
argument_list|,
name|x
index|[
literal|1
index|]
argument_list|,
name|x
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nw1
condition|)
operator|*
name|c
operator|++
operator|=
operator|*
name|x
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|c
operator|<
name|ce
condition|)
operator|*
name|c
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|ULong
ifdef|#
directive|ifdef
name|KR_headers
name|any_on
parameter_list|(
name|b
parameter_list|,
name|k
parameter_list|)
name|Bigint
modifier|*
name|b
decl_stmt|;
name|int
name|k
decl_stmt|;
else|#
directive|else
function|any_on
parameter_list|(
name|Bigint
modifier|*
name|b
parameter_list|,
name|int
name|k
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|n
decl_stmt|,
name|nwds
decl_stmt|;
name|ULong
modifier|*
name|x
decl_stmt|,
modifier|*
name|x0
decl_stmt|,
name|x1
decl_stmt|,
name|x2
decl_stmt|;
name|x
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|nwds
operator|=
name|b
operator|->
name|wds
expr_stmt|;
name|n
operator|=
name|k
operator|>>
name|kshift
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|nwds
condition|)
name|n
operator|=
name|nwds
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|<
name|nwds
operator|&&
operator|(
name|k
operator|&=
name|kmask
operator|)
condition|)
block|{
name|x1
operator|=
name|x2
operator|=
name|x
index|[
name|n
index|]
expr_stmt|;
name|x1
operator|>>=
name|k
expr_stmt|;
name|x1
operator|<<=
name|k
expr_stmt|;
if|if
condition|(
name|x1
operator|!=
name|x2
condition|)
return|return
literal|1
return|;
block|}
name|x0
operator|=
name|x
expr_stmt|;
name|x
operator|+=
name|n
expr_stmt|;
while|while
condition|(
name|x
operator|>
name|x0
condition|)
if|if
condition|(
operator|*
operator|--
name|x
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

