begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************  The author of this software is David M. Gay.  Copyright (C) 1998-2001 by Lucent Technologies All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name of Lucent or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ****************************************************************/
end_comment

begin_comment
comment|/* Please send bug reports to David M. Gay (dmg at acm dot org,  * with " at " changed at "@" and " dot " changed to ".").	*/
end_comment

begin_include
include|#
directive|include
file|"gdtoaimp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LOCALE
end_ifdef

begin_include
include|#
directive|include
file|"locale.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|CONST
name|int
name|fivesbits
index|[]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|,
literal|10
block|,
literal|12
block|,
literal|14
block|,
literal|17
block|,
literal|19
block|,
literal|21
block|,
literal|24
block|,
literal|26
block|,
literal|28
block|,
literal|31
block|,
literal|33
block|,
literal|35
block|,
literal|38
block|,
literal|40
block|,
literal|42
block|,
literal|45
block|,
literal|47
block|,
literal|49
block|,
literal|52
ifdef|#
directive|ifdef
name|VAX
block|,
literal|54
block|,
literal|56
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|Bigint
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|increment
parameter_list|(
name|b
parameter_list|)
name|Bigint
modifier|*
name|b
decl_stmt|;
else|#
directive|else
function|increment
parameter_list|(
name|Bigint
modifier|*
name|b
parameter_list|)
endif|#
directive|endif
block|{
name|ULong
modifier|*
name|x
decl_stmt|,
modifier|*
name|xe
decl_stmt|;
name|Bigint
modifier|*
name|b1
decl_stmt|;
ifdef|#
directive|ifdef
name|Pack_16
name|ULong
name|carry
init|=
literal|1
decl_stmt|,
name|y
decl_stmt|;
endif|#
directive|endif
name|x
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|xe
operator|=
name|x
operator|+
name|b
operator|->
name|wds
expr_stmt|;
ifdef|#
directive|ifdef
name|Pack_32
do|do
block|{
if|if
condition|(
operator|*
name|x
operator|<
operator|(
name|ULong
operator|)
literal|0xffffffffL
condition|)
block|{
operator|++
operator|*
name|x
expr_stmt|;
return|return
name|b
return|;
block|}
operator|*
name|x
operator|++
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|<
name|xe
condition|)
do|;
else|#
directive|else
do|do
block|{
name|y
operator|=
operator|*
name|x
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
operator|*
name|x
operator|++
operator|=
name|y
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
operator|!
name|carry
condition|)
return|return
name|b
return|;
block|}
do|while
condition|(
name|x
operator|<
name|xe
condition|)
do|;
if|if
condition|(
name|carry
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|b
operator|->
name|wds
operator|>=
name|b
operator|->
name|maxwds
condition|)
block|{
name|b1
operator|=
name|Balloc
argument_list|(
name|b
operator|->
name|k
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Bcopy
argument_list|(
name|b1
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|=
name|b1
expr_stmt|;
block|}
name|b
operator|->
name|x
index|[
name|b
operator|->
name|wds
operator|++
index|]
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|decrement
parameter_list|(
name|b
parameter_list|)
name|Bigint
modifier|*
name|b
decl_stmt|;
else|#
directive|else
function|decrement
parameter_list|(
name|Bigint
modifier|*
name|b
parameter_list|)
endif|#
directive|endif
block|{
name|ULong
modifier|*
name|x
decl_stmt|,
modifier|*
name|xe
decl_stmt|;
ifdef|#
directive|ifdef
name|Pack_16
name|ULong
name|borrow
init|=
literal|1
decl_stmt|,
name|y
decl_stmt|;
endif|#
directive|endif
name|x
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|xe
operator|=
name|x
operator|+
name|b
operator|->
name|wds
expr_stmt|;
ifdef|#
directive|ifdef
name|Pack_32
do|do
block|{
if|if
condition|(
operator|*
name|x
condition|)
block|{
operator|--
operator|*
name|x
expr_stmt|;
break|break;
block|}
operator|*
name|x
operator|++
operator|=
literal|0xffffffffL
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|<
name|xe
condition|)
do|;
else|#
directive|else
do|do
block|{
name|y
operator|=
operator|*
name|x
operator|-
name|borrow
expr_stmt|;
name|borrow
operator|=
operator|(
name|y
operator|&
literal|0x10000
operator|)
operator|>>
literal|16
expr_stmt|;
operator|*
name|x
operator|++
operator|=
name|y
operator|&
literal|0xffff
expr_stmt|;
block|}
do|while
condition|(
name|borrow
operator|&&
name|x
operator|<
name|xe
condition|)
do|;
endif|#
directive|endif
return|return
name|STRTOG_Inexlo
return|;
block|}
end_function

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|all_on
parameter_list|(
name|b
parameter_list|,
name|n
parameter_list|)
name|Bigint
modifier|*
name|b
decl_stmt|;
name|int
name|n
decl_stmt|;
else|#
directive|else
function|all_on
parameter_list|(
name|Bigint
modifier|*
name|b
parameter_list|,
name|int
name|n
parameter_list|)
endif|#
directive|endif
block|{
name|ULong
modifier|*
name|x
decl_stmt|,
modifier|*
name|xe
decl_stmt|;
name|x
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|xe
operator|=
name|x
operator|+
operator|(
name|n
operator|>>
name|kshift
operator|)
expr_stmt|;
while|while
condition|(
name|x
operator|<
name|xe
condition|)
if|if
condition|(
operator|(
operator|*
name|x
operator|++
operator|&
name|ALL_ON
operator|)
operator|!=
name|ALL_ON
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|n
operator|&=
name|kmask
condition|)
return|return
operator|(
operator|(
operator|*
name|x
operator||
operator|(
name|ALL_ON
operator|<<
name|n
operator|)
operator|)
operator|&
name|ALL_ON
operator|)
operator|==
name|ALL_ON
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|Bigint
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|set_ones
parameter_list|(
name|b
parameter_list|,
name|n
parameter_list|)
name|Bigint
modifier|*
name|b
decl_stmt|;
name|int
name|n
decl_stmt|;
else|#
directive|else
function|set_ones
parameter_list|(
name|Bigint
modifier|*
name|b
parameter_list|,
name|int
name|n
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|k
decl_stmt|;
name|ULong
modifier|*
name|x
decl_stmt|,
modifier|*
name|xe
decl_stmt|;
name|k
operator|=
operator|(
name|n
operator|+
operator|(
operator|(
literal|1
operator|<<
name|kshift
operator|)
operator|-
literal|1
operator|)
operator|)
operator|>>
name|kshift
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|k
operator|<
name|k
condition|)
block|{
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|=
name|Balloc
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
name|k
operator|=
name|n
operator|>>
name|kshift
expr_stmt|;
if|if
condition|(
name|n
operator|&=
name|kmask
condition|)
name|k
operator|++
expr_stmt|;
name|b
operator|->
name|wds
operator|=
name|k
expr_stmt|;
name|x
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|xe
operator|=
name|x
operator|+
name|k
expr_stmt|;
while|while
condition|(
name|x
operator|<
name|xe
condition|)
operator|*
name|x
operator|++
operator|=
name|ALL_ON
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|x
index|[
operator|-
literal|1
index|]
operator|>>=
name|ULbits
operator|-
name|n
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|rvOK
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|d
argument_list|,
name|fpi
argument_list|,
name|exp
argument_list|,
name|bits
argument_list|,
name|exact
argument_list|,
name|rd
argument_list|,
name|irv
argument_list|)
name|double
name|d
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FPI
modifier|*
name|fpi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Long
modifier|*
name|exp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ULong
modifier|*
name|bits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|exact
decl_stmt|,
name|rd
decl_stmt|,
modifier|*
name|irv
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|double
name|d
operator|,
name|FPI
operator|*
name|fpi
operator|,
name|Long
operator|*
name|exp
operator|,
name|ULong
operator|*
name|bits
operator|,
name|int
name|exact
operator|,
name|int
name|rd
operator|,
name|int
operator|*
name|irv
operator|)
endif|#
directive|endif
block|{
name|Bigint
operator|*
name|b
block|;
name|ULong
name|carry
block|,
name|inex
block|,
name|lostbits
block|;
name|int
name|bdif
block|,
name|e
block|,
name|j
block|,
name|k
block|,
name|k1
block|,
name|nb
block|,
name|rv
block|;
name|carry
operator|=
name|rv
operator|=
literal|0
block|;
name|b
operator|=
name|d2b
argument_list|(
name|d
argument_list|,
operator|&
name|e
argument_list|,
operator|&
name|bdif
argument_list|)
block|;
name|bdif
operator|-=
name|nb
operator|=
name|fpi
operator|->
name|nbits
block|;
name|e
operator|+=
name|bdif
block|;
if|if
condition|(
name|bdif
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|exact
condition|)
goto|goto
name|trunc
goto|;
goto|goto
name|ret
goto|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|P
operator|==
name|nb
condition|)
block|{
if|if
condition|(
ifndef|#
directive|ifndef
name|IMPRECISE_INEXACT
name|exact
operator|&&
endif|#
directive|endif
name|fpi
operator|->
name|rounding
operator|==
ifdef|#
directive|ifdef
name|RND_PRODQUOT
name|FPI_Round_near
else|#
directive|else
name|Flt_Rounds
endif|#
directive|endif
condition|)
goto|goto
name|trunc
goto|;
goto|goto
name|ret
goto|;
block|}
end_if

begin_switch
switch|switch
condition|(
name|rd
condition|)
block|{
case|case
literal|1
case|:
goto|goto
name|trunc
goto|;
case|case
literal|2
case|:
break|break;
default|default:
comment|/* round near */
name|k
operator|=
name|bdif
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
goto|goto
name|trunc
goto|;
if|if
condition|(
operator|!
name|k
condition|)
block|{
if|if
condition|(
operator|!
name|exact
condition|)
goto|goto
name|ret
goto|;
if|if
condition|(
name|b
operator|->
name|x
index|[
literal|0
index|]
operator|&
literal|2
condition|)
break|break;
goto|goto
name|trunc
goto|;
block|}
if|if
condition|(
name|b
operator|->
name|x
index|[
name|k
operator|>>
name|kshift
index|]
operator|&
operator|(
operator|(
name|ULong
operator|)
literal|1
operator|<<
operator|(
name|k
operator|&
name|kmask
operator|)
operator|)
condition|)
break|break;
goto|goto
name|trunc
goto|;
block|}
end_switch

begin_comment
comment|/* "break" cases: round up 1 bit, then truncate; bdif> 0 */
end_comment

begin_expr_stmt
name|carry
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_label
name|trunc
label|:
end_label

begin_expr_stmt
name|inex
operator|=
name|lostbits
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|bdif
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|lostbits
operator|=
name|any_on
argument_list|(
name|b
argument_list|,
name|bdif
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|inex
operator|=
name|STRTOG_Inexlo
expr_stmt|;
name|rshift
argument_list|(
name|b
argument_list|,
name|bdif
argument_list|)
expr_stmt|;
if|if
condition|(
name|carry
condition|)
block|{
name|inex
operator|=
name|STRTOG_Inexhi
expr_stmt|;
name|b
operator|=
name|increment
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|nb
operator|&
name|kmask
operator|)
operator|!=
literal|0
condition|)
name|j
operator|=
name|ULbits
operator|-
name|j
expr_stmt|;
if|if
condition|(
name|hi0bits
argument_list|(
name|b
operator|->
name|x
index|[
name|b
operator|->
name|wds
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|j
condition|)
block|{
if|if
condition|(
operator|!
name|lostbits
condition|)
name|lostbits
operator|=
name|b
operator|->
name|x
index|[
literal|0
index|]
operator|&
literal|1
expr_stmt|;
name|rshift
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|e
operator|++
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|bdif
operator|<
literal|0
condition|)
name|b
operator|=
name|lshift
argument_list|(
name|b
argument_list|,
operator|-
name|bdif
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|e
operator|<
name|fpi
operator|->
name|emin
condition|)
block|{
name|k
operator|=
name|fpi
operator|->
name|emin
operator|-
name|e
expr_stmt|;
name|e
operator|=
name|fpi
operator|->
name|emin
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|nb
operator|||
name|fpi
operator|->
name|sudden_underflow
condition|)
block|{
name|b
operator|->
name|wds
operator|=
name|inex
operator|=
literal|0
expr_stmt|;
operator|*
name|irv
operator|=
name|STRTOG_Underflow
operator||
name|STRTOG_Inexlo
expr_stmt|;
block|}
else|else
block|{
name|k1
operator|=
name|k
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|k1
operator|>
literal|0
operator|&&
operator|!
name|lostbits
condition|)
name|lostbits
operator|=
name|any_on
argument_list|(
name|b
argument_list|,
name|k1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lostbits
operator|&&
operator|!
name|exact
condition|)
goto|goto
name|ret
goto|;
name|lostbits
operator||=
name|carry
operator|=
name|b
operator|->
name|x
index|[
name|k1
operator|>>
name|kshift
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|k1
operator|&
name|kmask
operator|)
operator|)
expr_stmt|;
name|rshift
argument_list|(
name|b
argument_list|,
name|k
argument_list|)
expr_stmt|;
operator|*
name|irv
operator|=
name|STRTOG_Denormal
expr_stmt|;
if|if
condition|(
name|carry
condition|)
block|{
name|b
operator|=
name|increment
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|inex
operator|=
name|STRTOG_Inexhi
operator||
name|STRTOG_Underflow
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lostbits
condition|)
name|inex
operator|=
name|STRTOG_Inexlo
operator||
name|STRTOG_Underflow
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|e
operator|>
name|fpi
operator|->
name|emax
condition|)
block|{
name|e
operator|=
name|fpi
operator|->
name|emax
operator|+
literal|1
expr_stmt|;
operator|*
name|irv
operator|=
name|STRTOG_Infinite
operator||
name|STRTOG_Overflow
operator||
name|STRTOG_Inexhi
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_ERRNO
name|errno
operator|=
name|ERANGE
expr_stmt|;
endif|#
directive|endif
name|b
operator|->
name|wds
operator|=
name|inex
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_expr_stmt
operator|*
name|exp
operator|=
name|e
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|copybits
argument_list|(
name|bits
argument_list|,
name|nb
argument_list|,
name|b
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|irv
operator||=
name|inex
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rv
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_label
name|ret
label|:
end_label

begin_expr_stmt
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|rv
return|;
end_return

begin_function
unit|}   static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|mantbits
parameter_list|(
name|d
parameter_list|)
name|double
name|d
decl_stmt|;
else|#
directive|else
function|mantbits
parameter_list|(
name|double
name|d
parameter_list|)
endif|#
directive|endif
block|{
name|ULong
name|L
decl_stmt|;
ifdef|#
directive|ifdef
name|VAX
name|L
operator|=
name|word1
argument_list|(
name|d
argument_list|)
operator|<<
literal|16
operator||
name|word1
argument_list|(
name|d
argument_list|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|L
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|L
operator|=
name|word1
argument_list|(
name|d
argument_list|)
operator|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
return|return
name|P
operator|-
name|lo0bits
argument_list|(
operator|&
name|L
argument_list|)
return|;
ifdef|#
directive|ifdef
name|VAX
name|L
operator|=
name|word0
argument_list|(
name|d
argument_list|)
operator|<<
literal|16
operator||
name|word0
argument_list|(
name|d
argument_list|)
operator|>>
literal|16
operator||
name|Exp_msk11
expr_stmt|;
else|#
directive|else
name|L
operator|=
name|word0
argument_list|(
name|d
argument_list|)
operator||
name|Exp_msk1
expr_stmt|;
endif|#
directive|endif
return|return
name|P
operator|-
literal|32
operator|-
name|lo0bits
argument_list|(
operator|&
name|L
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|strtodg
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|s00
argument_list|,
name|se
argument_list|,
name|fpi
argument_list|,
name|exp
argument_list|,
name|bits
argument_list|)
name|CONST
name|char
modifier|*
name|s00
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|se
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FPI
modifier|*
name|fpi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Long
modifier|*
name|exp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ULong
modifier|*
name|bits
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|CONST
name|char
operator|*
name|s00
operator|,
name|char
operator|*
operator|*
name|se
operator|,
name|FPI
operator|*
name|fpi
operator|,
name|Long
operator|*
name|exp
operator|,
name|ULong
operator|*
name|bits
operator|)
endif|#
directive|endif
block|{
name|int
name|abe
block|,
name|abits
block|,
name|asub
block|;
name|int
name|bb0
block|,
name|bb2
block|,
name|bb5
block|,
name|bbe
block|,
name|bd2
block|,
name|bd5
block|,
name|bbbits
block|,
name|bs2
block|,
name|c
block|,
name|decpt
block|,
name|denorm
block|;
name|int
name|dsign
block|,
name|e
block|,
name|e1
block|,
name|e2
block|,
name|emin
block|,
name|esign
block|,
name|finished
block|,
name|i
block|,
name|inex
block|,
name|irv
block|;
name|int
name|j
block|,
name|k
block|,
name|nbits
block|,
name|nd
block|,
name|nd0
block|,
name|nf
block|,
name|nz
block|,
name|nz0
block|,
name|rd
block|,
name|rvbits
block|,
name|rve
block|,
name|rve1
block|,
name|sign
block|;
name|int
name|sudden_underflow
block|;
name|CONST
name|char
operator|*
name|s
block|,
operator|*
name|s0
block|,
operator|*
name|s1
block|;
name|double
name|adj
block|,
name|adj0
block|,
name|rv
block|,
name|tol
block|;
name|Long
name|L
block|;
name|ULong
name|y
block|,
name|z
block|;
name|Bigint
operator|*
name|ab
block|,
operator|*
name|bb
block|,
operator|*
name|bb1
block|,
operator|*
name|bd
block|,
operator|*
name|bd0
block|,
operator|*
name|bs
block|,
operator|*
name|delta
block|,
operator|*
name|rvb
block|,
operator|*
name|rvb0
block|;
name|irv
operator|=
name|STRTOG_Zero
block|;
name|denorm
operator|=
name|sign
operator|=
name|nz0
operator|=
name|nz
operator|=
literal|0
block|;
name|dval
argument_list|(
name|rv
argument_list|)
operator|=
literal|0.
block|;
name|rvb
operator|=
literal|0
block|;
name|nbits
operator|=
name|fpi
operator|->
name|nbits
block|;
for|for
control|(
name|s
operator|=
name|s00
init|;
condition|;
name|s
operator|++
control|)
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'-'
case|:
name|sign
operator|=
literal|1
expr_stmt|;
comment|/* no break */
case|case
literal|'+'
case|:
if|if
condition|(
operator|*
operator|++
name|s
condition|)
goto|goto
name|break2
goto|;
comment|/* no break */
case|case
literal|0
case|:
name|sign
operator|=
literal|0
expr_stmt|;
name|irv
operator|=
name|STRTOG_NoNumber
expr_stmt|;
name|s
operator|=
name|s00
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\r'
case|:
case|case
literal|' '
case|:
continue|continue;
default|default:
goto|goto
name|break2
goto|;
block|}
name|break2
operator|:
end_expr_stmt

begin_if
if|if
condition|(
operator|*
name|s
operator|==
literal|'0'
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_HEX_FP
switch|switch
condition|(
name|s
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|irv
operator|=
name|gethex
argument_list|(
operator|&
name|s
argument_list|,
name|fpi
argument_list|,
name|exp
argument_list|,
operator|&
name|rvb
argument_list|,
name|sign
argument_list|)
expr_stmt|;
if|if
condition|(
name|irv
operator|==
name|STRTOG_NoNumber
condition|)
block|{
name|s
operator|=
name|s00
expr_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|ret
goto|;
block|}
endif|#
directive|endif
name|nz0
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s
operator|==
literal|'0'
condition|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
goto|goto
name|ret
goto|;
block|}
end_if

begin_expr_stmt
name|sudden_underflow
operator|=
name|fpi
operator|->
name|sudden_underflow
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|s0
operator|=
name|s
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|y
operator|=
name|z
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|decpt
operator|=
name|nd
operator|=
name|nf
operator|=
literal|0
init|;
operator|(
name|c
operator|=
operator|*
name|s
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|;
name|nd
operator|++
operator|,
name|s
operator|++
control|)
if|if
condition|(
name|nd
operator|<
literal|9
condition|)
name|y
operator|=
literal|10
operator|*
name|y
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|<
literal|16
condition|)
name|z
operator|=
literal|10
operator|*
name|z
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
end_for

begin_expr_stmt
name|nd0
operator|=
name|nd
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LOCALE
end_ifdef

begin_if
if|if
condition|(
name|c
operator|==
operator|*
name|localeconv
argument_list|()
operator|->
name|decimal_point
condition|)
else|#
directive|else
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
endif|#
directive|endif
block|{
name|decpt
operator|=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|nd
condition|)
block|{
for|for
control|(
init|;
name|c
operator|==
literal|'0'
condition|;
name|c
operator|=
operator|*
operator|++
name|s
control|)
name|nz
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|s0
operator|=
name|s
expr_stmt|;
name|nf
operator|+=
name|nz
expr_stmt|;
name|nz
operator|=
literal|0
expr_stmt|;
goto|goto
name|have_dig
goto|;
block|}
goto|goto
name|dig_done
goto|;
block|}
for|for
control|(
init|;
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|;
name|c
operator|=
operator|*
operator|++
name|s
control|)
block|{
name|have_dig
label|:
name|nz
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|-=
literal|'0'
condition|)
block|{
name|nf
operator|+=
name|nz
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nz
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|nd
operator|++
operator|<
literal|9
condition|)
name|y
operator|*=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|<=
name|DBL_DIG
operator|+
literal|1
condition|)
name|z
operator|*=
literal|10
expr_stmt|;
if|if
condition|(
name|nd
operator|++
operator|<
literal|9
condition|)
name|y
operator|=
literal|10
operator|*
name|y
operator|+
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|<=
name|DBL_DIG
operator|+
literal|1
condition|)
name|z
operator|=
literal|10
operator|*
name|z
operator|+
name|c
expr_stmt|;
name|nz
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_if

begin_label
name|dig_done
label|:
end_label

begin_expr_stmt
name|e
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
condition|)
block|{
if|if
condition|(
operator|!
name|nd
operator|&&
operator|!
name|nz
operator|&&
operator|!
name|nz0
condition|)
block|{
name|irv
operator|=
name|STRTOG_NoNumber
expr_stmt|;
name|s
operator|=
name|s00
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|s00
operator|=
name|s
expr_stmt|;
name|esign
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
operator|++
name|s
condition|)
block|{
case|case
literal|'-'
case|:
name|esign
operator|=
literal|1
expr_stmt|;
case|case
literal|'+'
case|:
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|'0'
condition|)
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|L
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|s1
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|s
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|L
operator|=
literal|10
operator|*
name|L
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|s
operator|-
name|s1
operator|>
literal|8
operator|||
name|L
operator|>
literal|19999
condition|)
comment|/* Avoid confusion from exponents 					 * so large that e might overflow. 					 */
name|e
operator|=
literal|19999
expr_stmt|;
comment|/* safe for 16 bit ints */
else|else
name|e
operator|=
operator|(
name|int
operator|)
name|L
expr_stmt|;
if|if
condition|(
name|esign
condition|)
name|e
operator|=
operator|-
name|e
expr_stmt|;
block|}
else|else
name|e
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|s
operator|=
name|s00
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|nd
condition|)
block|{
if|if
condition|(
operator|!
name|nz
operator|&&
operator|!
name|nz0
condition|)
block|{
ifdef|#
directive|ifdef
name|INFNAN_CHECK
comment|/* Check for Nan and Infinity */
if|if
condition|(
operator|!
name|decpt
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
if|if
condition|(
name|match
argument_list|(
operator|&
name|s
argument_list|,
literal|"nf"
argument_list|)
condition|)
block|{
operator|--
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|match
argument_list|(
operator|&
name|s
argument_list|,
literal|"inity"
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
name|irv
operator|=
name|STRTOG_Infinite
expr_stmt|;
goto|goto
name|infnanexp
goto|;
block|}
break|break;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
if|if
condition|(
name|match
argument_list|(
operator|&
name|s
argument_list|,
literal|"an"
argument_list|)
condition|)
block|{
name|irv
operator|=
name|STRTOG_NaN
expr_stmt|;
operator|*
name|exp
operator|=
name|fpi
operator|->
name|emax
operator|+
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|No_Hex_NaN
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
comment|/*)*/
name|irv
operator|=
name|hexnan
argument_list|(
operator|&
name|s
argument_list|,
name|fpi
argument_list|,
name|bits
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|infnanexp
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* INFNAN_CHECK */
name|irv
operator|=
name|STRTOG_NoNumber
expr_stmt|;
name|s
operator|=
name|s00
expr_stmt|;
block|}
goto|goto
name|ret
goto|;
block|}
end_if

begin_expr_stmt
name|irv
operator|=
name|STRTOG_Normal
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|e1
operator|=
name|e
operator|-=
name|nf
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rd
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|fpi
operator|->
name|rounding
operator|&
literal|3
condition|)
block|{
case|case
name|FPI_Round_up
case|:
name|rd
operator|=
literal|2
operator|-
name|sign
expr_stmt|;
break|break;
case|case
name|FPI_Round_zero
case|:
name|rd
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|FPI_Round_down
case|:
name|rd
operator|=
literal|1
operator|+
name|sign
expr_stmt|;
block|}
end_switch

begin_comment
comment|/* Now we have nd0 digits, starting at s0, followed by a 	 * decimal point, followed by nd-nd0 digits.  The number we're 	 * after is the integer represented by those digits times 	 * 10**e */
end_comment

begin_if
if|if
condition|(
operator|!
name|nd0
condition|)
name|nd0
operator|=
name|nd
expr_stmt|;
end_if

begin_expr_stmt
name|k
operator|=
name|nd
operator|<
name|DBL_DIG
operator|+
literal|1
condition|?
name|nd
else|:
name|DBL_DIG
operator|+
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dval
argument_list|(
name|rv
argument_list|)
operator|=
name|y
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|k
operator|>
literal|9
condition|)
name|dval
argument_list|(
name|rv
argument_list|)
operator|=
name|tens
index|[
name|k
operator|-
literal|9
index|]
operator|*
name|dval
argument_list|(
name|rv
argument_list|)
operator|+
name|z
expr_stmt|;
end_if

begin_expr_stmt
name|bd0
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|nbits
operator|<=
name|P
operator|&&
name|nd
operator|<=
name|DBL_DIG
condition|)
block|{
if|if
condition|(
operator|!
name|e
condition|)
block|{
if|if
condition|(
name|rvOK
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|,
name|fpi
argument_list|,
name|exp
argument_list|,
name|bits
argument_list|,
literal|1
argument_list|,
name|rd
argument_list|,
operator|&
name|irv
argument_list|)
condition|)
goto|goto
name|ret
goto|;
block|}
elseif|else
if|if
condition|(
name|e
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|<=
name|Ten_pmax
condition|)
block|{
ifdef|#
directive|ifdef
name|VAX
goto|goto
name|vax_ovfl_check
goto|;
else|#
directive|else
name|i
operator|=
name|fivesbits
index|[
name|e
index|]
operator|+
name|mantbits
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|)
operator|<=
name|P
expr_stmt|;
comment|/* rv = */
name|rounded_product
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|,
name|tens
index|[
name|e
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rvOK
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|,
name|fpi
argument_list|,
name|exp
argument_list|,
name|bits
argument_list|,
name|i
argument_list|,
name|rd
argument_list|,
operator|&
name|irv
argument_list|)
condition|)
goto|goto
name|ret
goto|;
name|e1
operator|-=
name|e
expr_stmt|;
goto|goto
name|rv_notOK
goto|;
endif|#
directive|endif
block|}
name|i
operator|=
name|DBL_DIG
operator|-
name|nd
expr_stmt|;
if|if
condition|(
name|e
operator|<=
name|Ten_pmax
operator|+
name|i
condition|)
block|{
comment|/* A fancier test would sometimes let us do 				 * this for larger i values. 				 */
name|e2
operator|=
name|e
operator|-
name|i
expr_stmt|;
name|e1
operator|-=
name|i
expr_stmt|;
name|dval
argument_list|(
name|rv
argument_list|)
operator|*=
name|tens
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|VAX
comment|/* VAX exponent range is so narrow we must 				 * worry about overflow here... 				 */
name|vax_ovfl_check
label|:
name|dval
argument_list|(
name|adj
argument_list|)
operator|=
name|dval
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|word0
argument_list|(
name|adj
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
comment|/* adj = */
name|rounded_product
argument_list|(
name|dval
argument_list|(
name|adj
argument_list|)
argument_list|,
name|tens
index|[
name|e2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|word0
argument_list|(
name|adj
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
literal|1
operator|-
name|P
operator|)
condition|)
goto|goto
name|rv_notOK
goto|;
name|word0
argument_list|(
name|adj
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
name|dval
argument_list|(
name|rv
argument_list|)
operator|=
name|dval
argument_list|(
name|adj
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* rv = */
name|rounded_product
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|,
name|tens
index|[
name|e2
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rvOK
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|,
name|fpi
argument_list|,
name|exp
argument_list|,
name|bits
argument_list|,
literal|0
argument_list|,
name|rd
argument_list|,
operator|&
name|irv
argument_list|)
condition|)
goto|goto
name|ret
goto|;
name|e1
operator|-=
name|e2
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|Inaccurate_Divide
elseif|else
if|if
condition|(
name|e
operator|>=
operator|-
name|Ten_pmax
condition|)
block|{
comment|/* rv = */
name|rounded_quotient
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|,
name|tens
index|[
operator|-
name|e
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rvOK
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|,
name|fpi
argument_list|,
name|exp
argument_list|,
name|bits
argument_list|,
literal|0
argument_list|,
name|rd
argument_list|,
operator|&
name|irv
argument_list|)
condition|)
goto|goto
name|ret
goto|;
name|e1
operator|-=
name|e
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_if

begin_label
name|rv_notOK
label|:
end_label

begin_expr_stmt
name|e1
operator|+=
name|nd
operator|-
name|k
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Get starting approximation = rv * 10**e1 */
end_comment

begin_expr_stmt
name|e2
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|e1
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|e1
operator|&
literal|15
operator|)
operator|!=
literal|0
condition|)
name|dval
argument_list|(
name|rv
argument_list|)
operator|*=
name|tens
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e1
operator|&=
operator|~
literal|15
condition|)
block|{
name|e1
operator|>>=
literal|4
expr_stmt|;
while|while
condition|(
name|e1
operator|>=
operator|(
literal|1
operator|<<
name|n_bigtens
operator|-
literal|1
operator|)
condition|)
block|{
name|e2
operator|+=
operator|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>>
name|Exp_shift1
operator|)
operator|-
name|Bias
expr_stmt|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|&=
operator|~
name|Exp_mask
expr_stmt|;
name|word0
argument_list|(
name|rv
argument_list|)
operator||=
name|Bias
operator|<<
name|Exp_shift1
expr_stmt|;
name|dval
argument_list|(
name|rv
argument_list|)
operator|*=
name|bigtens
index|[
name|n_bigtens
operator|-
literal|1
index|]
expr_stmt|;
name|e1
operator|-=
literal|1
operator|<<
name|n_bigtens
operator|-
literal|1
expr_stmt|;
block|}
name|e2
operator|+=
operator|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>>
name|Exp_shift1
operator|)
operator|-
name|Bias
expr_stmt|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|&=
operator|~
name|Exp_mask
expr_stmt|;
name|word0
argument_list|(
name|rv
argument_list|)
operator||=
name|Bias
operator|<<
name|Exp_shift1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|e1
operator|>
literal|0
condition|;
name|j
operator|++
operator|,
name|e1
operator|>>=
literal|1
control|)
if|if
condition|(
name|e1
operator|&
literal|1
condition|)
name|dval
argument_list|(
name|rv
argument_list|)
operator|*=
name|bigtens
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|e1
operator|<
literal|0
condition|)
block|{
name|e1
operator|=
operator|-
name|e1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|e1
operator|&
literal|15
operator|)
operator|!=
literal|0
condition|)
name|dval
argument_list|(
name|rv
argument_list|)
operator|/=
name|tens
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e1
operator|&=
operator|~
literal|15
condition|)
block|{
name|e1
operator|>>=
literal|4
expr_stmt|;
while|while
condition|(
name|e1
operator|>=
operator|(
literal|1
operator|<<
name|n_bigtens
operator|-
literal|1
operator|)
condition|)
block|{
name|e2
operator|+=
operator|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>>
name|Exp_shift1
operator|)
operator|-
name|Bias
expr_stmt|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|&=
operator|~
name|Exp_mask
expr_stmt|;
name|word0
argument_list|(
name|rv
argument_list|)
operator||=
name|Bias
operator|<<
name|Exp_shift1
expr_stmt|;
name|dval
argument_list|(
name|rv
argument_list|)
operator|*=
name|tinytens
index|[
name|n_bigtens
operator|-
literal|1
index|]
expr_stmt|;
name|e1
operator|-=
literal|1
operator|<<
name|n_bigtens
operator|-
literal|1
expr_stmt|;
block|}
name|e2
operator|+=
operator|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>>
name|Exp_shift1
operator|)
operator|-
name|Bias
expr_stmt|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|&=
operator|~
name|Exp_mask
expr_stmt|;
name|word0
argument_list|(
name|rv
argument_list|)
operator||=
name|Bias
operator|<<
name|Exp_shift1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|e1
operator|>
literal|0
condition|;
name|j
operator|++
operator|,
name|e1
operator|>>=
literal|1
control|)
if|if
condition|(
name|e1
operator|&
literal|1
condition|)
name|dval
argument_list|(
name|rv
argument_list|)
operator|*=
name|tinytens
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|IBM
end_ifdef

begin_comment
comment|/* e2 is a correction to the (base 2) exponent of the return 	 * value, reflecting adjustments above to avoid overflow in the 	 * native arithmetic.  For native IBM (base 16) arithmetic, we 	 * must multiply e2 by 4 to change from base 16 to 2. 	 */
end_comment

begin_expr_stmt
name|e2
operator|<<=
literal|2
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|rvb
operator|=
name|d2b
argument_list|(
name|dval
argument_list|(
name|rv
argument_list|)
argument_list|,
operator|&
name|rve
argument_list|,
operator|&
name|rvbits
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* rv = rvb * 2^rve */
end_comment

begin_expr_stmt
name|rve
operator|+=
name|e2
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|j
operator|=
name|rvbits
operator|-
name|nbits
operator|)
operator|>
literal|0
condition|)
block|{
name|rshift
argument_list|(
name|rvb
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|rvbits
operator|=
name|nbits
expr_stmt|;
name|rve
operator|+=
name|j
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|bb0
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* trailing zero bits in rvb */
end_comment

begin_expr_stmt
name|e2
operator|=
name|rve
operator|+
name|rvbits
operator|-
name|nbits
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|e2
operator|>
name|fpi
operator|->
name|emax
operator|+
literal|1
condition|)
goto|goto
name|huge
goto|;
end_if

begin_expr_stmt
name|rve1
operator|=
name|rve
operator|+
name|rvbits
operator|-
name|nbits
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|e2
operator|<
operator|(
name|emin
operator|=
name|fpi
operator|->
name|emin
operator|)
condition|)
block|{
name|denorm
operator|=
literal|1
expr_stmt|;
name|j
operator|=
name|rve
operator|-
name|emin
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|rvb
operator|=
name|lshift
argument_list|(
name|rvb
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|rvbits
operator|+=
name|j
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
name|rvbits
operator|+=
name|j
expr_stmt|;
if|if
condition|(
name|rvbits
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|rvbits
operator|<
operator|-
literal|1
condition|)
block|{
name|ufl
label|:
name|rvb
operator|->
name|wds
operator|=
literal|0
expr_stmt|;
name|rvb
operator|->
name|x
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|exp
operator|=
name|emin
expr_stmt|;
name|irv
operator|=
name|STRTOG_Underflow
operator||
name|STRTOG_Inexlo
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|rvb
operator|->
name|x
index|[
literal|0
index|]
operator|=
name|rvb
operator|->
name|wds
operator|=
name|rvbits
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|rshift
argument_list|(
name|rvb
argument_list|,
operator|-
name|j
argument_list|)
expr_stmt|;
block|}
name|rve
operator|=
name|rve1
operator|=
name|emin
expr_stmt|;
if|if
condition|(
name|sudden_underflow
operator|&&
name|e2
operator|+
literal|1
operator|<
name|emin
condition|)
goto|goto
name|ufl
goto|;
block|}
end_if

begin_comment
comment|/* Now the hard part -- adjusting rv to the correct value.*/
end_comment

begin_comment
comment|/* Put digits into bd: true value = bd * 10^e */
end_comment

begin_expr_stmt
name|bd0
operator|=
name|s2b
argument_list|(
name|s0
argument_list|,
name|nd0
argument_list|,
name|nd
argument_list|,
name|y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
name|bd
operator|=
name|Balloc
argument_list|(
name|bd0
operator|->
name|k
argument_list|)
expr_stmt|;
name|Bcopy
argument_list|(
name|bd
argument_list|,
name|bd0
argument_list|)
expr_stmt|;
name|bb
operator|=
name|Balloc
argument_list|(
name|rvb
operator|->
name|k
argument_list|)
expr_stmt|;
name|Bcopy
argument_list|(
name|bb
argument_list|,
name|rvb
argument_list|)
expr_stmt|;
name|bbbits
operator|=
name|rvbits
operator|-
name|bb0
expr_stmt|;
name|bbe
operator|=
name|rve
operator|+
name|bb0
expr_stmt|;
name|bs
operator|=
name|i2b
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|>=
literal|0
condition|)
block|{
name|bb2
operator|=
name|bb5
operator|=
literal|0
expr_stmt|;
name|bd2
operator|=
name|bd5
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
name|bb2
operator|=
name|bb5
operator|=
operator|-
name|e
expr_stmt|;
name|bd2
operator|=
name|bd5
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bbe
operator|>=
literal|0
condition|)
name|bb2
operator|+=
name|bbe
expr_stmt|;
else|else
name|bd2
operator|-=
name|bbe
expr_stmt|;
name|bs2
operator|=
name|bb2
expr_stmt|;
name|j
operator|=
name|nbits
operator|+
literal|1
operator|-
name|bbbits
expr_stmt|;
name|i
operator|=
name|bbe
operator|+
name|bbbits
operator|-
name|nbits
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|emin
condition|)
comment|/* denormal */
name|j
operator|+=
name|i
operator|-
name|emin
expr_stmt|;
name|bb2
operator|+=
name|j
expr_stmt|;
name|bd2
operator|+=
name|j
expr_stmt|;
name|i
operator|=
name|bb2
operator|<
name|bd2
condition|?
name|bb2
else|:
name|bd2
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|bs2
condition|)
name|i
operator|=
name|bs2
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|bb2
operator|-=
name|i
expr_stmt|;
name|bd2
operator|-=
name|i
expr_stmt|;
name|bs2
operator|-=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|bb5
operator|>
literal|0
condition|)
block|{
name|bs
operator|=
name|pow5mult
argument_list|(
name|bs
argument_list|,
name|bb5
argument_list|)
expr_stmt|;
name|bb1
operator|=
name|mult
argument_list|(
name|bs
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bb
operator|=
name|bb1
expr_stmt|;
block|}
name|bb2
operator|-=
name|bb0
expr_stmt|;
if|if
condition|(
name|bb2
operator|>
literal|0
condition|)
name|bb
operator|=
name|lshift
argument_list|(
name|bb
argument_list|,
name|bb2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bb2
operator|<
literal|0
condition|)
name|rshift
argument_list|(
name|bb
argument_list|,
operator|-
name|bb2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bd5
operator|>
literal|0
condition|)
name|bd
operator|=
name|pow5mult
argument_list|(
name|bd
argument_list|,
name|bd5
argument_list|)
expr_stmt|;
if|if
condition|(
name|bd2
operator|>
literal|0
condition|)
name|bd
operator|=
name|lshift
argument_list|(
name|bd
argument_list|,
name|bd2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs2
operator|>
literal|0
condition|)
name|bs
operator|=
name|lshift
argument_list|(
name|bs
argument_list|,
name|bs2
argument_list|)
expr_stmt|;
name|asub
operator|=
literal|1
expr_stmt|;
name|inex
operator|=
name|STRTOG_Inexhi
expr_stmt|;
name|delta
operator|=
name|diff
argument_list|(
name|bb
argument_list|,
name|bd
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|->
name|wds
operator|<=
literal|1
operator|&&
operator|!
name|delta
operator|->
name|x
index|[
literal|0
index|]
condition|)
break|break;
name|dsign
operator|=
name|delta
operator|->
name|sign
expr_stmt|;
name|delta
operator|->
name|sign
operator|=
name|finished
operator|=
literal|0
expr_stmt|;
name|L
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|cmp
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|&&
name|i
operator|<=
literal|0
condition|)
block|{
name|irv
operator|=
name|STRTOG_Normal
expr_stmt|;
if|if
condition|(
operator|(
name|finished
operator|=
name|dsign
operator|^
operator|(
name|rd
operator|&
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dsign
operator|!=
literal|0
condition|)
block|{
name|irv
operator||=
name|STRTOG_Inexhi
expr_stmt|;
goto|goto
name|adj1
goto|;
block|}
name|irv
operator||=
name|STRTOG_Inexlo
expr_stmt|;
if|if
condition|(
name|rve1
operator|==
name|emin
condition|)
goto|goto
name|adj1
goto|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|nbits
init|;
name|j
operator|>=
name|ULbits
condition|;
name|i
operator|++
operator|,
name|j
operator|-=
name|ULbits
control|)
block|{
if|if
condition|(
name|rvb
operator|->
name|x
index|[
name|i
index|]
operator|&
name|ALL_ON
condition|)
goto|goto
name|adj1
goto|;
block|}
if|if
condition|(
name|j
operator|>
literal|1
operator|&&
name|lo0bits
argument_list|(
name|rvb
operator|->
name|x
operator|+
name|i
argument_list|)
operator|<
name|j
operator|-
literal|1
condition|)
goto|goto
name|adj1
goto|;
name|rve
operator|=
name|rve1
operator|-
literal|1
expr_stmt|;
name|rvb
operator|=
name|set_ones
argument_list|(
name|rvb
argument_list|,
name|rvbits
operator|=
name|nbits
argument_list|)
expr_stmt|;
break|break;
block|}
name|irv
operator||=
name|dsign
condition|?
name|STRTOG_Inexlo
else|:
name|STRTOG_Inexhi
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* Error is less than half an ulp -- check for 			 * special case of mantissa a power of two. 			 */
name|irv
operator|=
name|dsign
condition|?
name|STRTOG_Normal
operator||
name|STRTOG_Inexlo
else|:
name|STRTOG_Normal
operator||
name|STRTOG_Inexhi
expr_stmt|;
if|if
condition|(
name|dsign
operator|||
name|bbbits
operator|>
literal|1
operator|||
name|denorm
operator|||
name|rve1
operator|==
name|emin
condition|)
break|break;
name|delta
operator|=
name|lshift
argument_list|(
name|delta
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
operator|>
literal|0
condition|)
block|{
name|irv
operator|=
name|STRTOG_Normal
operator||
name|STRTOG_Inexlo
expr_stmt|;
goto|goto
name|drop_down
goto|;
block|}
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* exactly half-way between */
if|if
condition|(
name|dsign
condition|)
block|{
if|if
condition|(
name|denorm
operator|&&
name|all_on
argument_list|(
name|rvb
argument_list|,
name|rvbits
argument_list|)
condition|)
block|{
comment|/*boundary case -- increment exponent*/
name|rvb
operator|->
name|wds
operator|=
literal|1
expr_stmt|;
name|rvb
operator|->
name|x
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|rve
operator|=
name|emin
operator|+
name|nbits
operator|-
operator|(
name|rvbits
operator|=
literal|1
operator|)
expr_stmt|;
name|irv
operator|=
name|STRTOG_Normal
operator||
name|STRTOG_Inexhi
expr_stmt|;
name|denorm
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|irv
operator|=
name|STRTOG_Normal
operator||
name|STRTOG_Inexlo
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bbbits
operator|==
literal|1
condition|)
block|{
name|irv
operator|=
name|STRTOG_Normal
expr_stmt|;
name|drop_down
label|:
comment|/* boundary case -- decrement exponent */
if|if
condition|(
name|rve1
operator|==
name|emin
condition|)
block|{
name|irv
operator|=
name|STRTOG_Normal
operator||
name|STRTOG_Inexhi
expr_stmt|;
if|if
condition|(
name|rvb
operator|->
name|wds
operator|==
literal|1
operator|&&
name|rvb
operator|->
name|x
index|[
literal|0
index|]
operator|==
literal|1
condition|)
name|sudden_underflow
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|rve
operator|-=
name|nbits
expr_stmt|;
name|rvb
operator|=
name|set_ones
argument_list|(
name|rvb
argument_list|,
name|rvbits
operator|=
name|nbits
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|irv
operator|=
name|STRTOG_Normal
operator||
name|STRTOG_Inexhi
expr_stmt|;
if|if
condition|(
name|bbbits
operator|<
name|nbits
operator|&&
operator|!
name|denorm
operator|||
operator|!
operator|(
name|rvb
operator|->
name|x
index|[
literal|0
index|]
operator|&
literal|1
operator|)
condition|)
break|break;
if|if
condition|(
name|dsign
condition|)
block|{
name|rvb
operator|=
name|increment
argument_list|(
name|rvb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|rvbits
operator|&
name|kmask
operator|)
operator|!=
literal|0
condition|)
name|j
operator|=
name|ULbits
operator|-
name|j
expr_stmt|;
if|if
condition|(
name|hi0bits
argument_list|(
name|rvb
operator|->
name|x
index|[
operator|(
name|rvb
operator|->
name|wds
operator|-
literal|1
operator|)
operator|>>
name|kshift
index|]
argument_list|)
operator|!=
name|j
condition|)
name|rvbits
operator|++
expr_stmt|;
name|irv
operator|=
name|STRTOG_Normal
operator||
name|STRTOG_Inexhi
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bbbits
operator|==
literal|1
condition|)
goto|goto
name|undfl
goto|;
name|decrement
argument_list|(
name|rvb
argument_list|)
expr_stmt|;
name|irv
operator|=
name|STRTOG_Normal
operator||
name|STRTOG_Inexlo
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|dval
argument_list|(
name|adj
argument_list|)
operator|=
name|ratio
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
operator|)
operator|<=
literal|2.
condition|)
block|{
name|adj1
label|:
name|inex
operator|=
name|STRTOG_Inexlo
expr_stmt|;
if|if
condition|(
name|dsign
condition|)
block|{
name|asub
operator|=
literal|0
expr_stmt|;
name|inex
operator|=
name|STRTOG_Inexhi
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|denorm
operator|&&
name|bbbits
operator|<=
literal|1
condition|)
block|{
name|undfl
label|:
name|rvb
operator|->
name|wds
operator|=
literal|0
expr_stmt|;
name|rve
operator|=
name|emin
expr_stmt|;
name|irv
operator|=
name|STRTOG_Underflow
operator||
name|STRTOG_Inexlo
expr_stmt|;
break|break;
block|}
name|adj0
operator|=
name|dval
argument_list|(
name|adj
argument_list|)
operator|=
literal|1.
expr_stmt|;
block|}
else|else
block|{
name|adj0
operator|=
name|dval
argument_list|(
name|adj
argument_list|)
operator|*=
literal|0.5
expr_stmt|;
if|if
condition|(
name|dsign
condition|)
block|{
name|asub
operator|=
literal|0
expr_stmt|;
name|inex
operator|=
name|STRTOG_Inexlo
expr_stmt|;
block|}
if|if
condition|(
name|dval
argument_list|(
name|adj
argument_list|)
operator|<
literal|2147483647.
condition|)
block|{
name|L
operator|=
name|adj0
expr_stmt|;
name|adj0
operator|-=
name|L
expr_stmt|;
switch|switch
condition|(
name|rd
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|adj0
operator|>=
literal|.5
condition|)
goto|goto
name|inc_L
goto|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|asub
operator|&&
name|adj0
operator|>
literal|0.
condition|)
goto|goto
name|inc_L
goto|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
operator|!
name|asub
operator|&&
name|adj0
operator|>
literal|0.
condition|)
block|{
name|inc_L
label|:
name|L
operator|++
expr_stmt|;
name|inex
operator|=
name|STRTOG_Inexact
operator|-
name|inex
expr_stmt|;
block|}
block|}
name|dval
argument_list|(
name|adj
argument_list|)
operator|=
name|L
expr_stmt|;
block|}
block|}
name|y
operator|=
name|rve
operator|+
name|rvbits
expr_stmt|;
comment|/* adj *= ulp(dval(rv)); */
comment|/* if (asub) rv -= adj; else rv += adj; */
if|if
condition|(
operator|!
name|denorm
operator|&&
name|rvbits
operator|<
name|nbits
condition|)
block|{
name|rvb
operator|=
name|lshift
argument_list|(
name|rvb
argument_list|,
name|j
operator|=
name|nbits
operator|-
name|rvbits
argument_list|)
expr_stmt|;
name|rve
operator|-=
name|j
expr_stmt|;
name|rvbits
operator|=
name|nbits
expr_stmt|;
block|}
name|ab
operator|=
name|d2b
argument_list|(
name|dval
argument_list|(
name|adj
argument_list|)
argument_list|,
operator|&
name|abe
argument_list|,
operator|&
name|abits
argument_list|)
expr_stmt|;
if|if
condition|(
name|abe
operator|<
literal|0
condition|)
name|rshift
argument_list|(
name|ab
argument_list|,
operator|-
name|abe
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|abe
operator|>
literal|0
condition|)
name|ab
operator|=
name|lshift
argument_list|(
name|ab
argument_list|,
name|abe
argument_list|)
expr_stmt|;
name|rvb0
operator|=
name|rvb
expr_stmt|;
if|if
condition|(
name|asub
condition|)
block|{
comment|/* rv -= adj; */
name|j
operator|=
name|hi0bits
argument_list|(
name|rvb
operator|->
name|x
index|[
name|rvb
operator|->
name|wds
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|rvb
operator|=
name|diff
argument_list|(
name|rvb
argument_list|,
name|ab
argument_list|)
expr_stmt|;
name|k
operator|=
name|rvb0
operator|->
name|wds
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|denorm
condition|)
comment|/* do nothing */
empty_stmt|;
elseif|else
if|if
condition|(
name|rvb
operator|->
name|wds
operator|<=
name|k
operator|||
name|hi0bits
argument_list|(
name|rvb
operator|->
name|x
index|[
name|k
index|]
argument_list|)
operator|>
name|hi0bits
argument_list|(
name|rvb0
operator|->
name|x
index|[
name|k
index|]
argument_list|)
condition|)
block|{
comment|/* unlikely; can only have lost 1 high bit */
if|if
condition|(
name|rve1
operator|==
name|emin
condition|)
block|{
operator|--
name|rvbits
expr_stmt|;
name|denorm
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rvb
operator|=
name|lshift
argument_list|(
name|rvb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|--
name|rve
expr_stmt|;
operator|--
name|rve1
expr_stmt|;
name|L
operator|=
name|finished
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|rvb
operator|=
name|sum
argument_list|(
name|rvb
argument_list|,
name|ab
argument_list|)
expr_stmt|;
name|k
operator|=
name|rvb
operator|->
name|wds
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|k
operator|>=
name|rvb0
operator|->
name|wds
operator|||
name|hi0bits
argument_list|(
name|rvb
operator|->
name|x
index|[
name|k
index|]
argument_list|)
operator|<
name|hi0bits
argument_list|(
name|rvb0
operator|->
name|x
index|[
name|k
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|denorm
condition|)
block|{
if|if
condition|(
operator|++
name|rvbits
operator|==
name|nbits
condition|)
name|denorm
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rshift
argument_list|(
name|rvb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rve
operator|++
expr_stmt|;
name|rve1
operator|++
expr_stmt|;
name|L
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|Bfree
argument_list|(
name|ab
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|rvb0
argument_list|)
expr_stmt|;
if|if
condition|(
name|finished
condition|)
break|break;
name|z
operator|=
name|rve
operator|+
name|rvbits
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|z
operator|&&
name|L
condition|)
block|{
comment|/* Can we stop now? */
name|tol
operator|=
name|dval
argument_list|(
name|adj
argument_list|)
operator|*
literal|5e-16
expr_stmt|;
comment|/*> max rel error */
name|dval
argument_list|(
name|adj
argument_list|)
operator|=
name|adj0
operator|-
literal|.5
expr_stmt|;
if|if
condition|(
name|dval
argument_list|(
name|adj
argument_list|)
operator|<
operator|-
name|tol
condition|)
block|{
if|if
condition|(
name|adj0
operator|>
name|tol
condition|)
block|{
name|irv
operator||=
name|inex
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|dval
argument_list|(
name|adj
argument_list|)
operator|>
name|tol
operator|&&
name|adj0
operator|<
literal|1.
operator|-
name|tol
condition|)
block|{
name|irv
operator||=
name|inex
expr_stmt|;
break|break;
block|}
block|}
name|bb0
operator|=
name|denorm
condition|?
literal|0
else|:
name|trailz
argument_list|(
name|rvb
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
operator|!
name|denorm
operator|&&
operator|(
name|j
operator|=
name|nbits
operator|-
name|rvbits
operator|)
condition|)
block|{
if|if
condition|(
name|j
operator|>
literal|0
condition|)
name|rvb
operator|=
name|lshift
argument_list|(
name|rvb
argument_list|,
name|j
argument_list|)
expr_stmt|;
else|else
name|rshift
argument_list|(
name|rvb
argument_list|,
operator|-
name|j
argument_list|)
expr_stmt|;
name|rve
operator|-=
name|j
expr_stmt|;
block|}
end_if

begin_expr_stmt
operator|*
name|exp
operator|=
name|rve
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|bd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|bs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|bd0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|delta
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|rve
operator|>
name|fpi
operator|->
name|emax
condition|)
block|{
name|huge
label|:
name|rvb
operator|->
name|wds
operator|=
literal|0
expr_stmt|;
name|irv
operator|=
name|STRTOG_Infinite
operator||
name|STRTOG_Overflow
operator||
name|STRTOG_Inexhi
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_ERRNO
name|errno
operator|=
name|ERANGE
expr_stmt|;
endif|#
directive|endif
name|infnanexp
label|:
operator|*
name|exp
operator|=
name|fpi
operator|->
name|emax
operator|+
literal|1
expr_stmt|;
block|}
end_if

begin_label
name|ret
label|:
end_label

begin_if
if|if
condition|(
name|denorm
condition|)
block|{
if|if
condition|(
name|sudden_underflow
condition|)
block|{
name|rvb
operator|->
name|wds
operator|=
literal|0
expr_stmt|;
name|irv
operator|=
name|STRTOG_Underflow
operator||
name|STRTOG_Inexlo
expr_stmt|;
block|}
else|else
block|{
name|irv
operator|=
operator|(
name|irv
operator|&
operator|~
name|STRTOG_Retmask
operator|)
operator||
operator|(
name|rvb
operator|->
name|wds
operator|>
literal|0
condition|?
name|STRTOG_Denormal
else|:
name|STRTOG_Zero
operator|)
expr_stmt|;
if|if
condition|(
name|irv
operator|&
name|STRTOG_Inexact
condition|)
name|irv
operator||=
name|STRTOG_Underflow
expr_stmt|;
block|}
block|}
end_if

begin_if
if|if
condition|(
name|se
condition|)
operator|*
name|se
operator|=
operator|(
name|char
operator|*
operator|)
name|s
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|sign
condition|)
name|irv
operator||=
name|STRTOG_Neg
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|rvb
condition|)
block|{
name|copybits
argument_list|(
name|bits
argument_list|,
name|nbits
argument_list|,
name|rvb
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|rvb
argument_list|)
expr_stmt|;
block|}
end_if

begin_return
return|return
name|irv
return|;
end_return

unit|}
end_unit

