begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************  The author of this software is David M. Gay.  Copyright (C) 1998, 1999 by Lucent Technologies All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name of Lucent or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ****************************************************************/
end_comment

begin_comment
comment|/* Please send bug reports to David M. Gay (dmg at acm dot org,  * with " at " changed at "@" and " dot " changed to ".").	*/
end_comment

begin_include
include|#
directive|include
file|"gdtoaimp.h"
end_include

begin_comment
comment|/* dtoa for IEEE arithmetic (dmg): convert double to ASCII string.  *  * Inspired by "How to Print Floating-Point Numbers Accurately" by  * Guy L. Steele, Jr. and Jon L. White [Proc. ACM SIGPLAN '90, pp. 112-126].  *  * Modifications:  *	1. Rather than iterating, we use a simple numeric overestimate  *	   to determine k = floor(log10(d)).  We scale relevant  *	   quantities using O(log2(k)) rather than O(k) multiplications.  *	2. For some modes> 2 (corresponding to ecvt and fcvt), we don't  *	   try to generate digits strictly left to right.  Instead, we  *	   compute with fewer bits and propagate the carry if necessary  *	   when rounding the final digit up.  This is often faster.  *	3. Under the assumption that input will be rounded nearest,  *	   mode 0 renders 1e23 as 1e23 rather than 9.999999999999999e22.  *	   That is, we allow equality in stopping tests when the  *	   round-nearest rule will give the same floating-point value  *	   as would satisfaction of the stopping test with strict  *	   inequality.  *	4. We remove common factors of powers of 2 from relevant  *	   quantities.  *	5. When converting floating-point integers less than 1e16,  *	   we use floating-point arithmetic rather than resorting  *	   to multiple-precision integers.  *	6. When asked to produce fewer than 15 digits, we first try  *	   to get by with floating-point arithmetic; we resort to  *	   multiple-precision integer arithmetic only if we cannot  *	   guarantee that the floating-point calculation has given  *	   the correctly rounded result.  For k requested digits and  *	   "uniformly" distributed input, the probability is  *	   something like 10^(k-15) that we must resort to the Long  *	   calculation.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
end_ifdef

begin_undef
undef|#
directive|undef
name|Check_FLT_ROUNDS
end_undef

begin_define
define|#
directive|define
name|Check_FLT_ROUNDS
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Rounding
value|Flt_Rounds
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|dtoa
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|d0
argument_list|,
name|mode
argument_list|,
name|ndigits
argument_list|,
name|decpt
argument_list|,
name|sign
argument_list|,
name|rve
argument_list|)
name|double
name|d0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mode
decl_stmt|,
name|ndigits
decl_stmt|,
modifier|*
name|decpt
decl_stmt|,
modifier|*
name|sign
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|rve
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|double
name|d0
operator|,
name|int
name|mode
operator|,
name|int
name|ndigits
operator|,
name|int
operator|*
name|decpt
operator|,
name|int
operator|*
name|sign
operator|,
name|char
operator|*
operator|*
name|rve
operator|)
endif|#
directive|endif
block|{
comment|/*	Arguments ndigits, decpt, sign are similar to those 	of ecvt and fcvt; trailing zeros are suppressed from 	the returned string.  If not null, *rve is set to point 	to the end of the return value.  If d is +-Infinity or NaN, 	then *decpt is set to 9999.  	mode: 		0 ==> shortest string that yields d when read in 			and rounded to nearest. 		1 ==> like 0, but with Steele& White stopping rule; 			e.g. with IEEE P754 arithmetic , mode 0 gives 			1e23 whereas mode 1 gives 9.999999999999999e22. 		2 ==> max(1,ndigits) significant digits.  This gives a 			return value similar to that of ecvt, except 			that trailing zeros are suppressed. 		3 ==> through ndigits past the decimal point.  This 			gives a return value similar to that from fcvt, 			except that trailing zeros are suppressed, and 			ndigits can be negative. 		4,5 ==> similar to 2 and 3, respectively, but (in 			round-nearest mode) with the tests of mode 0 to 			possibly return a shorter string that rounds to d. 			With IEEE arithmetic and compilation with 			-DHonor_FLT_ROUNDS, modes 4 and 5 behave the same 			as modes 2 and 3 when FLT_ROUNDS != 1. 		6-9 ==> Debugging modes similar to mode - 4:  don't try 			fast floating-point estimate (if applicable).  		Values of mode other than 0-9 are treated as mode 0.  		Sufficient space is allocated to the return value 		to hold the suppressed trailing zeros. 	*/
name|int
name|bbits
block|,
name|b2
block|,
name|b5
block|,
name|be
block|,
name|dig
block|,
name|i
block|,
name|ieps
block|,
name|ilim
block|,
name|ilim0
block|,
name|ilim1
block|,
name|j
block|,
name|j1
block|,
name|k
block|,
name|k0
block|,
name|k_check
block|,
name|leftright
block|,
name|m2
block|,
name|m5
block|,
name|s2
block|,
name|s5
block|,
name|spec_case
block|,
name|try_quick
block|;
name|Long
name|L
block|;
ifndef|#
directive|ifndef
name|Sudden_Underflow
name|int
name|denorm
block|;
name|ULong
name|x
block|;
endif|#
directive|endif
name|Bigint
operator|*
name|b
block|,
operator|*
name|b1
block|,
operator|*
name|delta
block|,
operator|*
name|mlo
block|,
operator|*
name|mhi
block|,
operator|*
name|S
block|;
name|U
name|d
block|,
name|d2
block|,
name|eps
block|;
name|double
name|ds
block|;
name|char
operator|*
name|s
block|,
operator|*
name|s0
block|;
ifdef|#
directive|ifdef
name|SET_INEXACT
name|int
name|inexact
block|,
name|oldinexact
block|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
comment|/*{*/
name|int
name|Rounding
block|;
ifdef|#
directive|ifdef
name|Trust_FLT_ROUNDS
comment|/*{{ only define this if FLT_ROUNDS really works! */
name|Rounding
operator|=
name|Flt_Rounds
block|;
else|#
directive|else
comment|/*}{*/
name|Rounding
operator|=
literal|1
block|;
switch|switch
condition|(
name|fegetround
argument_list|()
condition|)
block|{
case|case
name|FE_TOWARDZERO
case|:
name|Rounding
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FE_UPWARD
case|:
name|Rounding
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|FE_DOWNWARD
case|:
name|Rounding
operator|=
literal|3
expr_stmt|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*}}*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*}*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MULTIPLE_THREADS
end_ifndef

begin_if
if|if
condition|(
name|dtoa_result
condition|)
block|{
name|freedtoa
argument_list|(
name|dtoa_result
argument_list|)
expr_stmt|;
name|dtoa_result
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|d
operator|.
name|d
operator|=
name|d0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|word0
argument_list|(
operator|&
name|d
argument_list|)
operator|&
name|Sign_bit
condition|)
block|{
comment|/* set sign for everything, including 0's and NaNs */
operator|*
name|sign
operator|=
literal|1
expr_stmt|;
name|word0
argument_list|(
operator|&
name|d
argument_list|)
operator|&=
operator|~
name|Sign_bit
expr_stmt|;
comment|/* clear sign bit */
block|}
else|else
operator|*
name|sign
operator|=
literal|0
expr_stmt|;
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IEEE_Arith
argument_list|)
operator|+
name|defined
argument_list|(
name|VAX
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_Arith
end_ifdef

begin_if
if|if
condition|(
operator|(
name|word0
argument_list|(
operator|&
name|d
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|==
name|Exp_mask
condition|)
else|#
directive|else
if|if
condition|(
name|word0
argument_list|(
operator|&
name|d
argument_list|)
operator|==
literal|0x8000
condition|)
endif|#
directive|endif
block|{
comment|/* Infinity or NaN */
operator|*
name|decpt
operator|=
literal|9999
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE_Arith
if|if
condition|(
operator|!
name|word1
argument_list|(
operator|&
name|d
argument_list|)
operator|&&
operator|!
operator|(
name|word0
argument_list|(
operator|&
name|d
argument_list|)
operator|&
literal|0xfffff
operator|)
condition|)
return|return
name|nrv_alloc
argument_list|(
literal|"Infinity"
argument_list|,
name|rve
argument_list|,
literal|8
argument_list|)
return|;
endif|#
directive|endif
return|return
name|nrv_alloc
argument_list|(
literal|"NaN"
argument_list|,
name|rve
argument_list|,
literal|3
argument_list|)
return|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IBM
end_ifdef

begin_expr_stmt
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|+=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* normalize */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
operator|!
name|dval
argument_list|(
operator|&
name|d
argument_list|)
condition|)
block|{
operator|*
name|decpt
operator|=
literal|1
expr_stmt|;
return|return
name|nrv_alloc
argument_list|(
literal|"0"
argument_list|,
name|rve
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|SET_INEXACT
end_ifdef

begin_expr_stmt
name|try_quick
operator|=
name|oldinexact
operator|=
name|get_inexact
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|inexact
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
end_ifdef

begin_if
if|if
condition|(
name|Rounding
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
operator|*
name|sign
condition|)
name|Rounding
operator|=
name|Rounding
operator|==
literal|2
condition|?
literal|0
else|:
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|Rounding
operator|!=
literal|2
condition|)
name|Rounding
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|b
operator|=
name|d2b
argument_list|(
name|dval
argument_list|(
operator|&
name|d
argument_list|)
argument_list|,
operator|&
name|be
argument_list|,
operator|&
name|bbits
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|Sudden_Underflow
end_ifdef

begin_expr_stmt
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|word0
argument_list|(
operator|&
name|d
argument_list|)
operator|>>
name|Exp_shift1
operator|&
operator|(
name|Exp_mask
operator|>>
name|Exp_shift1
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_if
if|if
condition|(
operator|(
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|word0
argument_list|(
operator|&
name|d
argument_list|)
operator|>>
name|Exp_shift1
operator|&
operator|(
name|Exp_mask
operator|>>
name|Exp_shift1
operator|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
endif|#
directive|endif
name|dval
argument_list|(
operator|&
name|d2
argument_list|)
operator|=
name|dval
argument_list|(
operator|&
name|d
argument_list|)
expr_stmt|;
name|word0
argument_list|(
operator|&
name|d2
argument_list|)
operator|&=
name|Frac_mask1
expr_stmt|;
name|word0
argument_list|(
operator|&
name|d2
argument_list|)
operator||=
name|Exp_11
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
if|if
condition|(
operator|(
name|j
operator|=
literal|11
operator|-
name|hi0bits
argument_list|(
name|word0
argument_list|(
operator|&
name|d2
argument_list|)
operator|&
name|Frac_mask
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|dval
argument_list|(
operator|&
name|d2
argument_list|)
operator|/=
literal|1
operator|<<
name|j
expr_stmt|;
endif|#
directive|endif
comment|/* log(x)	~=~ log(1.5) + (x-1.5)/1.5 		 * log10(x)	 =  log(x) / log(10) 		 *		~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10)) 		 * log10(&d) = (i-Bias)*log(2)/log(10) + log10(&d2) 		 * 		 * This suggests computing an approximation k to log10(&d) by 		 * 		 * k = (i - Bias)*0.301029995663981 		 *	+ ( (d2-1.5)*0.289529654602168 + 0.176091259055681 ); 		 * 		 * We want k to be too large rather than too small. 		 * The error in the first-order Taylor series approximation 		 * is in our favor, so we just round up the constant enough 		 * to compensate for any error in the multiplication of 		 * (i - Bias) by 0.301029995663981; since |i - Bias|<= 1077, 		 * and 1077 * 0.30103 * 2^-52 ~=~ 7.2e-14, 		 * adding 1e-13 to the constant term more than suffices. 		 * Hence we adjust the constant term to 0.1760912590558. 		 * (We could get a more accurate k by invoking log10, 		 *  but this is probably not worthwhile.) 		 */
name|i
operator|-=
name|Bias
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
name|i
operator|<<=
literal|2
expr_stmt|;
name|i
operator|+=
name|j
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Sudden_Underflow
name|denorm
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* d is denormalized */
name|i
operator|=
name|bbits
operator|+
name|be
operator|+
operator|(
name|Bias
operator|+
operator|(
name|P
operator|-
literal|1
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|x
operator|=
name|i
operator|>
literal|32
condition|?
name|word0
argument_list|(
operator|&
name|d
argument_list|)
operator|<<
operator|(
literal|64
operator|-
name|i
operator|)
operator||
name|word1
argument_list|(
operator|&
name|d
argument_list|)
operator|>>
operator|(
name|i
operator|-
literal|32
operator|)
else|:
name|word1
argument_list|(
operator|&
name|d
argument_list|)
operator|<<
operator|(
literal|32
operator|-
name|i
operator|)
expr_stmt|;
name|dval
argument_list|(
operator|&
name|d2
argument_list|)
operator|=
name|x
expr_stmt|;
name|word0
argument_list|(
operator|&
name|d2
argument_list|)
operator|-=
literal|31
operator|*
name|Exp_msk1
expr_stmt|;
comment|/* adjust exponent */
name|i
operator|-=
operator|(
name|Bias
operator|+
operator|(
name|P
operator|-
literal|1
operator|)
operator|-
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|denorm
operator|=
literal|1
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|ds
operator|=
operator|(
name|dval
argument_list|(
operator|&
name|d2
argument_list|)
operator|-
literal|1.5
operator|)
operator|*
literal|0.289529654602168
operator|+
literal|0.1760912590558
operator|+
name|i
operator|*
literal|0.301029995663981
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|k
operator|=
operator|(
name|int
operator|)
name|ds
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ds
operator|<
literal|0.
operator|&&
name|ds
operator|!=
name|k
condition|)
name|k
operator|--
expr_stmt|;
end_if

begin_comment
comment|/* want k = floor(ds) */
end_comment

begin_expr_stmt
name|k_check
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|k
operator|>=
literal|0
operator|&&
name|k
operator|<=
name|Ten_pmax
condition|)
block|{
if|if
condition|(
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|<
name|tens
index|[
name|k
index|]
condition|)
name|k
operator|--
expr_stmt|;
name|k_check
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|j
operator|=
name|bbits
operator|-
name|i
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
block|{
name|b2
operator|=
literal|0
expr_stmt|;
name|s2
operator|=
name|j
expr_stmt|;
block|}
else|else
block|{
name|b2
operator|=
operator|-
name|j
expr_stmt|;
name|s2
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|k
operator|>=
literal|0
condition|)
block|{
name|b5
operator|=
literal|0
expr_stmt|;
name|s5
operator|=
name|k
expr_stmt|;
name|s2
operator|+=
name|k
expr_stmt|;
block|}
else|else
block|{
name|b2
operator|-=
name|k
expr_stmt|;
name|b5
operator|=
operator|-
name|k
expr_stmt|;
name|s5
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|mode
operator|<
literal|0
operator|||
name|mode
operator|>
literal|9
condition|)
name|mode
operator|=
literal|0
expr_stmt|;
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|SET_INEXACT
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|Check_FLT_ROUNDS
end_ifdef

begin_expr_stmt
name|try_quick
operator|=
name|Rounding
operator|==
literal|1
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|try_quick
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*SET_INEXACT*/
end_comment

begin_if
if|if
condition|(
name|mode
operator|>
literal|5
condition|)
block|{
name|mode
operator|-=
literal|4
expr_stmt|;
name|try_quick
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|leftright
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ilim
operator|=
name|ilim1
operator|=
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Values for cases 0 and 1; done here to */
end_comment

begin_comment
comment|/* silence erroneous "gcc -Wall" warning. */
end_comment

begin_switch
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|i
operator|=
literal|18
expr_stmt|;
name|ndigits
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|leftright
operator|=
literal|0
expr_stmt|;
comment|/* no break */
case|case
literal|4
case|:
if|if
condition|(
name|ndigits
operator|<=
literal|0
condition|)
name|ndigits
operator|=
literal|1
expr_stmt|;
name|ilim
operator|=
name|ilim1
operator|=
name|i
operator|=
name|ndigits
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|leftright
operator|=
literal|0
expr_stmt|;
comment|/* no break */
case|case
literal|5
case|:
name|i
operator|=
name|ndigits
operator|+
name|k
operator|+
literal|1
expr_stmt|;
name|ilim
operator|=
name|i
expr_stmt|;
name|ilim1
operator|=
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
block|}
end_switch

begin_expr_stmt
name|s
operator|=
name|s0
operator|=
name|rv_alloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
end_ifdef

begin_if
if|if
condition|(
name|mode
operator|>
literal|1
operator|&&
name|Rounding
operator|!=
literal|1
condition|)
name|leftright
operator|=
literal|0
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|ilim
operator|>=
literal|0
operator|&&
name|ilim
operator|<=
name|Quick_max
operator|&&
name|try_quick
condition|)
block|{
comment|/* Try to get by with floating-point arithmetic. */
name|i
operator|=
literal|0
expr_stmt|;
name|dval
argument_list|(
operator|&
name|d2
argument_list|)
operator|=
name|dval
argument_list|(
operator|&
name|d
argument_list|)
expr_stmt|;
name|k0
operator|=
name|k
expr_stmt|;
name|ilim0
operator|=
name|ilim
expr_stmt|;
name|ieps
operator|=
literal|2
expr_stmt|;
comment|/* conservative */
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
name|ds
operator|=
name|tens
index|[
name|k
operator|&
literal|0xf
index|]
expr_stmt|;
name|j
operator|=
name|k
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|j
operator|&
name|Bletch
condition|)
block|{
comment|/* prevent overflows */
name|j
operator|&=
name|Bletch
operator|-
literal|1
expr_stmt|;
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|/=
name|bigtens
index|[
name|n_bigtens
operator|-
literal|1
index|]
expr_stmt|;
name|ieps
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|j
condition|;
name|j
operator|>>=
literal|1
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|j
operator|&
literal|1
condition|)
block|{
name|ieps
operator|++
expr_stmt|;
name|ds
operator|*=
name|bigtens
index|[
name|i
index|]
expr_stmt|;
block|}
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|/=
name|ds
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|j1
operator|=
operator|-
name|k
operator|)
operator|!=
literal|0
condition|)
block|{
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|*=
name|tens
index|[
name|j1
operator|&
literal|0xf
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|j1
operator|>>
literal|4
init|;
name|j
condition|;
name|j
operator|>>=
literal|1
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|j
operator|&
literal|1
condition|)
block|{
name|ieps
operator|++
expr_stmt|;
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|*=
name|bigtens
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|k_check
operator|&&
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|<
literal|1.
operator|&&
name|ilim
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ilim1
operator|<=
literal|0
condition|)
goto|goto
name|fast_failed
goto|;
name|ilim
operator|=
name|ilim1
expr_stmt|;
name|k
operator|--
expr_stmt|;
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|*=
literal|10.
expr_stmt|;
name|ieps
operator|++
expr_stmt|;
block|}
name|dval
argument_list|(
operator|&
name|eps
argument_list|)
operator|=
name|ieps
operator|*
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|+
literal|7.
expr_stmt|;
name|word0
argument_list|(
operator|&
name|eps
argument_list|)
operator|-=
operator|(
name|P
operator|-
literal|1
operator|)
operator|*
name|Exp_msk1
expr_stmt|;
if|if
condition|(
name|ilim
operator|==
literal|0
condition|)
block|{
name|S
operator|=
name|mhi
operator|=
literal|0
expr_stmt|;
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|-=
literal|5.
expr_stmt|;
if|if
condition|(
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|>
name|dval
argument_list|(
operator|&
name|eps
argument_list|)
condition|)
goto|goto
name|one_digit
goto|;
if|if
condition|(
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|<
operator|-
name|dval
argument_list|(
operator|&
name|eps
argument_list|)
condition|)
goto|goto
name|no_digits
goto|;
goto|goto
name|fast_failed
goto|;
block|}
ifndef|#
directive|ifndef
name|No_leftright
if|if
condition|(
name|leftright
condition|)
block|{
comment|/* Use Steele& White method of only 			 * generating digits needed. 			 */
name|dval
argument_list|(
operator|&
name|eps
argument_list|)
operator|=
literal|0.5
operator|/
name|tens
index|[
name|ilim
operator|-
literal|1
index|]
operator|-
name|dval
argument_list|(
operator|&
name|eps
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
control|)
block|{
name|L
operator|=
name|dval
argument_list|(
operator|&
name|d
argument_list|)
expr_stmt|;
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|-=
name|L
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'0'
operator|+
operator|(
name|int
operator|)
name|L
expr_stmt|;
if|if
condition|(
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|<
name|dval
argument_list|(
operator|&
name|eps
argument_list|)
condition|)
goto|goto
name|ret1
goto|;
if|if
condition|(
literal|1.
operator|-
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|<
name|dval
argument_list|(
operator|&
name|eps
argument_list|)
condition|)
goto|goto
name|bump_up
goto|;
if|if
condition|(
operator|++
name|i
operator|>=
name|ilim
condition|)
break|break;
name|dval
argument_list|(
operator|&
name|eps
argument_list|)
operator|*=
literal|10.
expr_stmt|;
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|*=
literal|10.
expr_stmt|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
comment|/* Generate ilim digits, then fix them up. */
name|dval
argument_list|(
operator|&
name|eps
argument_list|)
operator|*=
name|tens
index|[
name|ilim
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
operator|,
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|*=
literal|10.
control|)
block|{
name|L
operator|=
call|(
name|Long
call|)
argument_list|(
name|dval
argument_list|(
operator|&
name|d
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|-=
name|L
operator|)
condition|)
name|ilim
operator|=
name|i
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'0'
operator|+
operator|(
name|int
operator|)
name|L
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ilim
condition|)
block|{
if|if
condition|(
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|>
literal|0.5
operator|+
name|dval
argument_list|(
operator|&
name|eps
argument_list|)
condition|)
goto|goto
name|bump_up
goto|;
elseif|else
if|if
condition|(
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|<
literal|0.5
operator|-
name|dval
argument_list|(
operator|&
name|eps
argument_list|)
condition|)
block|{
while|while
condition|(
operator|*
operator|--
name|s
operator|==
literal|'0'
condition|)
empty_stmt|;
name|s
operator|++
expr_stmt|;
goto|goto
name|ret1
goto|;
block|}
break|break;
block|}
block|}
ifndef|#
directive|ifndef
name|No_leftright
block|}
endif|#
directive|endif
name|fast_failed
label|:
name|s
operator|=
name|s0
expr_stmt|;
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|=
name|dval
argument_list|(
operator|&
name|d2
argument_list|)
expr_stmt|;
name|k
operator|=
name|k0
expr_stmt|;
name|ilim
operator|=
name|ilim0
expr_stmt|;
block|}
end_if

begin_comment
comment|/* Do we have a "small" integer? */
end_comment

begin_if
if|if
condition|(
name|be
operator|>=
literal|0
operator|&&
name|k
operator|<=
name|Int_max
condition|)
block|{
comment|/* Yes. */
name|ds
operator|=
name|tens
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|ndigits
operator|<
literal|0
operator|&&
name|ilim
operator|<=
literal|0
condition|)
block|{
name|S
operator|=
name|mhi
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ilim
operator|<
literal|0
operator|||
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|<=
literal|5
operator|*
name|ds
condition|)
goto|goto
name|no_digits
goto|;
goto|goto
name|one_digit
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
operator|,
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|*=
literal|10.
control|)
block|{
name|L
operator|=
call|(
name|Long
call|)
argument_list|(
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|/
name|ds
argument_list|)
expr_stmt|;
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|-=
name|L
operator|*
name|ds
expr_stmt|;
ifdef|#
directive|ifdef
name|Check_FLT_ROUNDS
comment|/* If FLT_ROUNDS == 2, L will usually be high by 1 */
if|if
condition|(
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|<
literal|0
condition|)
block|{
name|L
operator|--
expr_stmt|;
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|+=
name|ds
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|s
operator|++
operator|=
literal|'0'
operator|+
operator|(
name|int
operator|)
name|L
expr_stmt|;
if|if
condition|(
operator|!
name|dval
argument_list|(
operator|&
name|d
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SET_INEXACT
name|inexact
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|ilim
condition|)
block|{
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
if|if
condition|(
name|mode
operator|>
literal|1
condition|)
switch|switch
condition|(
name|Rounding
condition|)
block|{
case|case
literal|0
case|:
goto|goto
name|ret1
goto|;
case|case
literal|2
case|:
goto|goto
name|bump_up
goto|;
block|}
endif|#
directive|endif
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|+=
name|dval
argument_list|(
operator|&
name|d
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ROUND_BIASED
if|if
condition|(
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|>=
name|ds
condition|)
else|#
directive|else
if|if
condition|(
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|>
name|ds
operator|||
operator|(
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|==
name|ds
operator|&&
name|L
operator|&
literal|1
operator|)
condition|)
endif|#
directive|endif
block|{
name|bump_up
label|:
while|while
condition|(
operator|*
operator|--
name|s
operator|==
literal|'9'
condition|)
if|if
condition|(
name|s
operator|==
name|s0
condition|)
block|{
name|k
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|'0'
expr_stmt|;
break|break;
block|}
operator|++
operator|*
name|s
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
goto|goto
name|ret1
goto|;
block|}
end_if

begin_expr_stmt
name|m2
operator|=
name|b2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|m5
operator|=
name|b5
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mhi
operator|=
name|mlo
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|leftright
condition|)
block|{
name|i
operator|=
ifndef|#
directive|ifndef
name|Sudden_Underflow
name|denorm
condition|?
name|be
operator|+
operator|(
name|Bias
operator|+
operator|(
name|P
operator|-
literal|1
operator|)
operator|-
literal|1
operator|+
literal|1
operator|)
else|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBM
literal|1
operator|+
literal|4
operator|*
name|P
operator|-
literal|3
operator|-
name|bbits
operator|+
operator|(
operator|(
name|bbits
operator|+
name|be
operator|-
literal|1
operator|)
operator|&
literal|3
operator|)
expr_stmt|;
else|#
directive|else
literal|1
operator|+
name|P
operator|-
name|bbits
expr_stmt|;
endif|#
directive|endif
name|b2
operator|+=
name|i
expr_stmt|;
name|s2
operator|+=
name|i
expr_stmt|;
name|mhi
operator|=
name|i2b
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|m2
operator|>
literal|0
operator|&&
name|s2
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|m2
operator|<
name|s2
condition|?
name|m2
else|:
name|s2
expr_stmt|;
name|b2
operator|-=
name|i
expr_stmt|;
name|m2
operator|-=
name|i
expr_stmt|;
name|s2
operator|-=
name|i
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|b5
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|leftright
condition|)
block|{
if|if
condition|(
name|m5
operator|>
literal|0
condition|)
block|{
name|mhi
operator|=
name|pow5mult
argument_list|(
name|mhi
argument_list|,
name|m5
argument_list|)
expr_stmt|;
name|b1
operator|=
name|mult
argument_list|(
name|mhi
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|=
name|b1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|j
operator|=
name|b5
operator|-
name|m5
operator|)
operator|!=
literal|0
condition|)
name|b
operator|=
name|pow5mult
argument_list|(
name|b
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
else|else
name|b
operator|=
name|pow5mult
argument_list|(
name|b
argument_list|,
name|b5
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|S
operator|=
name|i2b
argument_list|(
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|s5
operator|>
literal|0
condition|)
name|S
operator|=
name|pow5mult
argument_list|(
name|S
argument_list|,
name|s5
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* Check for special case that d is a normalized power of 2. */
end_comment

begin_expr_stmt
name|spec_case
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|mode
operator|<
literal|2
operator|||
name|leftright
operator|)
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
operator|&&
name|Rounding
operator|==
literal|1
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
operator|!
name|word1
argument_list|(
operator|&
name|d
argument_list|)
operator|&&
operator|!
operator|(
name|word0
argument_list|(
operator|&
name|d
argument_list|)
operator|&
name|Bndry_mask
operator|)
ifndef|#
directive|ifndef
name|Sudden_Underflow
operator|&&
name|word0
argument_list|(
operator|&
name|d
argument_list|)
operator|&
operator|(
name|Exp_mask
operator|&
operator|~
name|Exp_msk1
operator|)
endif|#
directive|endif
condition|)
block|{
comment|/* The special case */
name|b2
operator|+=
name|Log2P
expr_stmt|;
name|s2
operator|+=
name|Log2P
expr_stmt|;
name|spec_case
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|/* Arrange for convenient computation of quotients: 	 * shift left if necessary so divisor has 4 leading 0 bits. 	 * 	 * Perhaps we should just compute leading 28 bits of S once 	 * and for all and pass them and a shift to quorem, so it 	 * can do shifts and ors to compute the numerator for q. 	 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|Pack_32
end_ifdef

begin_if
if|if
condition|(
operator|(
name|i
operator|=
operator|(
operator|(
name|s5
condition|?
literal|32
operator|-
name|hi0bits
argument_list|(
name|S
operator|->
name|x
index|[
name|S
operator|->
name|wds
operator|-
literal|1
index|]
argument_list|)
else|:
literal|1
operator|)
operator|+
name|s2
operator|)
operator|&
literal|0x1f
operator|)
operator|!=
literal|0
condition|)
name|i
operator|=
literal|32
operator|-
name|i
expr_stmt|;
end_if

begin_else
else|#
directive|else
end_else

begin_if
if|if
condition|(
operator|(
name|i
operator|=
operator|(
operator|(
name|s5
condition|?
literal|32
operator|-
name|hi0bits
argument_list|(
name|S
operator|->
name|x
index|[
name|S
operator|->
name|wds
operator|-
literal|1
index|]
argument_list|)
else|:
literal|1
operator|)
operator|+
name|s2
operator|)
operator|&
literal|0xf
operator|)
operator|!=
literal|0
condition|)
name|i
operator|=
literal|16
operator|-
name|i
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|i
operator|>
literal|4
condition|)
block|{
name|i
operator|-=
literal|4
expr_stmt|;
name|b2
operator|+=
name|i
expr_stmt|;
name|m2
operator|+=
name|i
expr_stmt|;
name|s2
operator|+=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
literal|4
condition|)
block|{
name|i
operator|+=
literal|28
expr_stmt|;
name|b2
operator|+=
name|i
expr_stmt|;
name|m2
operator|+=
name|i
expr_stmt|;
name|s2
operator|+=
name|i
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|b2
operator|>
literal|0
condition|)
name|b
operator|=
name|lshift
argument_list|(
name|b
argument_list|,
name|b2
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|s2
operator|>
literal|0
condition|)
name|S
operator|=
name|lshift
argument_list|(
name|S
argument_list|,
name|s2
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|k_check
condition|)
block|{
if|if
condition|(
name|cmp
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
operator|<
literal|0
condition|)
block|{
name|k
operator|--
expr_stmt|;
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* we botched the k estimate */
if|if
condition|(
name|leftright
condition|)
name|mhi
operator|=
name|multadd
argument_list|(
name|mhi
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ilim
operator|=
name|ilim1
expr_stmt|;
block|}
block|}
end_if

begin_if
if|if
condition|(
name|ilim
operator|<=
literal|0
operator|&&
operator|(
name|mode
operator|==
literal|3
operator|||
name|mode
operator|==
literal|5
operator|)
condition|)
block|{
if|if
condition|(
name|ilim
operator|<
literal|0
operator|||
name|cmp
argument_list|(
name|b
argument_list|,
name|S
operator|=
name|multadd
argument_list|(
name|S
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|/* no digits, fcvt style */
name|no_digits
label|:
name|k
operator|=
operator|-
literal|1
operator|-
name|ndigits
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|one_digit
label|:
operator|*
name|s
operator|++
operator|=
literal|'1'
expr_stmt|;
name|k
operator|++
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
end_if

begin_if
if|if
condition|(
name|leftright
condition|)
block|{
if|if
condition|(
name|m2
operator|>
literal|0
condition|)
name|mhi
operator|=
name|lshift
argument_list|(
name|mhi
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|/* Compute mlo -- check for special case 		 * that d is a normalized power of 2. 		 */
name|mlo
operator|=
name|mhi
expr_stmt|;
if|if
condition|(
name|spec_case
condition|)
block|{
name|mhi
operator|=
name|Balloc
argument_list|(
name|mhi
operator|->
name|k
argument_list|)
expr_stmt|;
name|Bcopy
argument_list|(
name|mhi
argument_list|,
name|mlo
argument_list|)
expr_stmt|;
name|mhi
operator|=
name|lshift
argument_list|(
name|mhi
argument_list|,
name|Log2P
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
name|dig
operator|=
name|quorem
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
operator|+
literal|'0'
expr_stmt|;
comment|/* Do we yet have the shortest decimal string 			 * that will round to d? 			 */
name|j
operator|=
name|cmp
argument_list|(
name|b
argument_list|,
name|mlo
argument_list|)
expr_stmt|;
name|delta
operator|=
name|diff
argument_list|(
name|S
argument_list|,
name|mhi
argument_list|)
expr_stmt|;
name|j1
operator|=
name|delta
operator|->
name|sign
condition|?
literal|1
else|:
name|cmp
argument_list|(
name|b
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|delta
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ROUND_BIASED
if|if
condition|(
name|j1
operator|==
literal|0
operator|&&
name|mode
operator|!=
literal|1
operator|&&
operator|!
operator|(
name|word1
argument_list|(
operator|&
name|d
argument_list|)
operator|&
literal|1
operator|)
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
operator|&&
name|Rounding
operator|>=
literal|1
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|dig
operator|==
literal|'9'
condition|)
goto|goto
name|round_9_up
goto|;
if|if
condition|(
name|j
operator|>
literal|0
condition|)
name|dig
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SET_INEXACT
elseif|else
if|if
condition|(
operator|!
name|b
operator|->
name|x
index|[
literal|0
index|]
operator|&&
name|b
operator|->
name|wds
operator|<=
literal|1
condition|)
name|inexact
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
operator|*
name|s
operator|++
operator|=
name|dig
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|j
operator|<
literal|0
operator|||
operator|(
name|j
operator|==
literal|0
operator|&&
name|mode
operator|!=
literal|1
ifndef|#
directive|ifndef
name|ROUND_BIASED
operator|&&
operator|!
operator|(
name|word1
argument_list|(
operator|&
name|d
argument_list|)
operator|&
literal|1
operator|)
endif|#
directive|endif
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|b
operator|->
name|x
index|[
literal|0
index|]
operator|&&
name|b
operator|->
name|wds
operator|<=
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|SET_INEXACT
name|inexact
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
goto|goto
name|accept_dig
goto|;
block|}
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
if|if
condition|(
name|mode
operator|>
literal|1
condition|)
switch|switch
condition|(
name|Rounding
condition|)
block|{
case|case
literal|0
case|:
goto|goto
name|accept_dig
goto|;
case|case
literal|2
case|:
goto|goto
name|keep_dig
goto|;
block|}
endif|#
directive|endif
comment|/*Honor_FLT_ROUNDS*/
if|if
condition|(
name|j1
operator|>
literal|0
condition|)
block|{
name|b
operator|=
name|lshift
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|j1
operator|=
name|cmp
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ROUND_BIASED
if|if
condition|(
name|j1
operator|>=
literal|0
comment|/*)*/
else|#
directive|else
if|if
condition|(
operator|(
name|j1
operator|>
literal|0
operator|||
operator|(
name|j1
operator|==
literal|0
operator|&&
name|dig
operator|&
literal|1
operator|)
operator|)
endif|#
directive|endif
operator|&&
name|dig
operator|++
operator|==
literal|'9'
condition|)
goto|goto
name|round_9_up
goto|;
block|}
name|accept_dig
label|:
operator|*
name|s
operator|++
operator|=
name|dig
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|j1
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
if|if
condition|(
operator|!
name|Rounding
condition|)
goto|goto
name|accept_dig
goto|;
endif|#
directive|endif
if|if
condition|(
name|dig
operator|==
literal|'9'
condition|)
block|{
comment|/* possible if i == 1 */
name|round_9_up
label|:
operator|*
name|s
operator|++
operator|=
literal|'9'
expr_stmt|;
goto|goto
name|roundoff
goto|;
block|}
operator|*
name|s
operator|++
operator|=
name|dig
operator|+
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
name|keep_dig
label|:
endif|#
directive|endif
operator|*
name|s
operator|++
operator|=
name|dig
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ilim
condition|)
break|break;
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlo
operator|==
name|mhi
condition|)
name|mlo
operator|=
name|mhi
operator|=
name|multadd
argument_list|(
name|mhi
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|mlo
operator|=
name|multadd
argument_list|(
name|mlo
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mhi
operator|=
name|multadd
argument_list|(
name|mhi
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|s
operator|++
operator|=
name|dig
operator|=
name|quorem
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
operator|+
literal|'0'
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|x
index|[
literal|0
index|]
operator|&&
name|b
operator|->
name|wds
operator|<=
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|SET_INEXACT
name|inexact
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|i
operator|>=
name|ilim
condition|)
break|break;
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* Round off last digit */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
end_ifdef

begin_switch
switch|switch
condition|(
name|Rounding
condition|)
block|{
case|case
literal|0
case|:
goto|goto
name|trimzeros
goto|;
case|case
literal|2
case|:
goto|goto
name|roundoff
goto|;
block|}
end_switch

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|b
operator|=
name|lshift
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|j
operator|=
name|cmp
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ROUND_BIASED
end_ifdef

begin_if
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|j
operator|>
literal|0
operator|||
operator|(
name|j
operator|==
literal|0
operator|&&
name|dig
operator|&
literal|1
operator|)
condition|)
endif|#
directive|endif
block|{
name|roundoff
label|:
while|while
condition|(
operator|*
operator|--
name|s
operator|==
literal|'9'
condition|)
if|if
condition|(
name|s
operator|==
name|s0
condition|)
block|{
name|k
operator|++
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'1'
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
operator|++
operator|*
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|Honor_FLT_ROUNDS
name|trimzeros
label|:
endif|#
directive|endif
while|while
condition|(
operator|*
operator|--
name|s
operator|==
literal|'0'
condition|)
empty_stmt|;
name|s
operator|++
expr_stmt|;
block|}
end_if

begin_label
name|ret
label|:
end_label

begin_expr_stmt
name|Bfree
argument_list|(
name|S
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|mhi
condition|)
block|{
if|if
condition|(
name|mlo
operator|&&
name|mlo
operator|!=
name|mhi
condition|)
name|Bfree
argument_list|(
name|mlo
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|mhi
argument_list|)
expr_stmt|;
block|}
end_if

begin_label
name|ret1
label|:
end_label

begin_ifdef
ifdef|#
directive|ifdef
name|SET_INEXACT
end_ifdef

begin_if
if|if
condition|(
name|inexact
condition|)
block|{
if|if
condition|(
operator|!
name|oldinexact
condition|)
block|{
name|word0
argument_list|(
operator|&
name|d
argument_list|)
operator|=
name|Exp_1
operator|+
operator|(
literal|70
operator|<<
name|Exp_shift
operator|)
expr_stmt|;
name|word1
argument_list|(
operator|&
name|d
argument_list|)
operator|=
literal|0
expr_stmt|;
name|dval
argument_list|(
operator|&
name|d
argument_list|)
operator|+=
literal|1.
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|oldinexact
condition|)
name|clear_inexact
argument_list|()
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|s
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|decpt
operator|=
name|k
operator|+
literal|1
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|rve
condition|)
operator|*
name|rve
operator|=
name|s
expr_stmt|;
end_if

begin_return
return|return
name|s0
return|;
end_return

unit|}
end_unit

