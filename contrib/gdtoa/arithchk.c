begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright (C) 1997, 1998 Lucent Technologies All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name of Lucent or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ****************************************************************/
end_comment

begin_comment
comment|/* Try to deduce arith.h from arithmetic properties. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|dalign
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|Akind
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|kind
decl_stmt|;
block|}
name|Akind
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|Akind
name|IEEE_8087
init|=
block|{
literal|"IEEE_8087"
block|,
literal|1
block|}
decl_stmt|,
name|IEEE_MC68k
init|=
block|{
literal|"IEEE_MC68k"
block|,
literal|2
block|}
decl_stmt|,
name|IBM
init|=
block|{
literal|"IBM"
block|,
literal|3
block|}
decl_stmt|,
name|VAX
init|=
block|{
literal|"VAX"
block|,
literal|4
block|}
decl_stmt|,
name|CRAY
init|=
block|{
literal|"CRAY"
block|,
literal|5
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Akind
modifier|*
name|Lcheck
parameter_list|()
block|{
union|union
block|{
name|double
name|d
decl_stmt|;
name|long
name|L
index|[
literal|2
index|]
decl_stmt|;
block|}
name|u
union|;
struct|struct
block|{
name|double
name|d
decl_stmt|;
name|long
name|L
decl_stmt|;
block|}
name|x
index|[
literal|2
index|]
struct|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|x
argument_list|)
operator|>
literal|2
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
condition|)
name|dalign
operator|=
literal|1
expr_stmt|;
name|u
operator|.
name|L
index|[
literal|0
index|]
operator|=
name|u
operator|.
name|L
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|u
operator|.
name|d
operator|=
literal|1e13
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|L
index|[
literal|0
index|]
operator|==
literal|1117925532
operator|&&
name|u
operator|.
name|L
index|[
literal|1
index|]
operator|==
operator|-
literal|448790528
condition|)
return|return
operator|&
name|IEEE_MC68k
return|;
if|if
condition|(
name|u
operator|.
name|L
index|[
literal|1
index|]
operator|==
literal|1117925532
operator|&&
name|u
operator|.
name|L
index|[
literal|0
index|]
operator|==
operator|-
literal|448790528
condition|)
return|return
operator|&
name|IEEE_8087
return|;
if|if
condition|(
name|u
operator|.
name|L
index|[
literal|0
index|]
operator|==
operator|-
literal|2065213935
operator|&&
name|u
operator|.
name|L
index|[
literal|1
index|]
operator|==
literal|10752
condition|)
return|return
operator|&
name|VAX
return|;
if|if
condition|(
name|u
operator|.
name|L
index|[
literal|0
index|]
operator|==
literal|1267827943
operator|&&
name|u
operator|.
name|L
index|[
literal|1
index|]
operator|==
literal|704643072
condition|)
return|return
operator|&
name|IBM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|Akind
modifier|*
name|icheck
parameter_list|()
block|{
union|union
block|{
name|double
name|d
decl_stmt|;
name|int
name|L
index|[
literal|2
index|]
decl_stmt|;
block|}
name|u
union|;
struct|struct
block|{
name|double
name|d
decl_stmt|;
name|int
name|L
decl_stmt|;
block|}
name|x
index|[
literal|2
index|]
struct|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|x
argument_list|)
operator|>
literal|2
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
condition|)
name|dalign
operator|=
literal|1
expr_stmt|;
name|u
operator|.
name|L
index|[
literal|0
index|]
operator|=
name|u
operator|.
name|L
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|u
operator|.
name|d
operator|=
literal|1e13
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|L
index|[
literal|0
index|]
operator|==
literal|1117925532
operator|&&
name|u
operator|.
name|L
index|[
literal|1
index|]
operator|==
operator|-
literal|448790528
condition|)
return|return
operator|&
name|IEEE_MC68k
return|;
if|if
condition|(
name|u
operator|.
name|L
index|[
literal|1
index|]
operator|==
literal|1117925532
operator|&&
name|u
operator|.
name|L
index|[
literal|0
index|]
operator|==
operator|-
literal|448790528
condition|)
return|return
operator|&
name|IEEE_8087
return|;
if|if
condition|(
name|u
operator|.
name|L
index|[
literal|0
index|]
operator|==
operator|-
literal|2065213935
operator|&&
name|u
operator|.
name|L
index|[
literal|1
index|]
operator|==
literal|10752
condition|)
return|return
operator|&
name|VAX
return|;
if|if
condition|(
name|u
operator|.
name|L
index|[
literal|0
index|]
operator|==
literal|1267827943
operator|&&
name|u
operator|.
name|L
index|[
literal|1
index|]
operator|==
literal|704643072
condition|)
return|return
operator|&
name|IBM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|emptyfmt
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* avoid possible warning message with printf("") */
end_comment

begin_function
specifier|static
name|Akind
modifier|*
name|ccheck
parameter_list|()
block|{
union|union
block|{
name|double
name|d
decl_stmt|;
name|long
name|L
decl_stmt|;
block|}
name|u
union|;
name|long
name|Cray1
decl_stmt|;
comment|/* Cray1 = 4617762693716115456 -- without overflow on non-Crays */
name|Cray1
operator|=
name|printf
argument_list|(
name|emptyfmt
argument_list|)
operator|<
literal|0
condition|?
literal|0
else|:
literal|4617762
expr_stmt|;
if|if
condition|(
name|printf
argument_list|(
name|emptyfmt
argument_list|,
name|Cray1
argument_list|)
operator|>=
literal|0
condition|)
name|Cray1
operator|=
literal|1000000
operator|*
name|Cray1
operator|+
literal|693716
expr_stmt|;
if|if
condition|(
name|printf
argument_list|(
name|emptyfmt
argument_list|,
name|Cray1
argument_list|)
operator|>=
literal|0
condition|)
name|Cray1
operator|=
literal|1000000
operator|*
name|Cray1
operator|+
literal|115456
expr_stmt|;
name|u
operator|.
name|d
operator|=
literal|1e13
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|L
operator|==
name|Cray1
condition|)
return|return
operator|&
name|CRAY
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fzcheck
parameter_list|()
block|{
name|double
name|a
decl_stmt|,
name|b
decl_stmt|;
name|int
name|i
decl_stmt|;
name|a
operator|=
literal|1.
expr_stmt|;
name|b
operator|=
literal|.1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|155
init|;
condition|;
name|b
operator|*=
name|b
operator|,
name|i
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|i
operator|&
literal|1
condition|)
block|{
name|a
operator|*=
name|b
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
break|break;
block|}
block|}
name|b
operator|=
name|a
operator|*
name|a
expr_stmt|;
return|return
name|b
operator|==
literal|0.
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|()
block|{
name|Akind
modifier|*
name|a
init|=
literal|0
decl_stmt|;
name|int
name|Ldef
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
ifdef|#
directive|ifdef
name|WRITE_ARITH_H
comment|/* for Symantec's buggy "make" */
name|f
operator|=
name|fopen
argument_list|(
literal|"arith.h"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot open arith.h\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|#
directive|else
name|f
operator|=
name|stdout
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|==
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|a
operator|=
name|Lcheck
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|==
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|Ldef
operator|=
literal|1
expr_stmt|;
name|a
operator|=
name|icheck
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|a
operator|=
name|ccheck
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"#define %s\n#define Arith_Kind_ASL %d\n"
argument_list|,
name|a
operator|->
name|name
argument_list|,
name|a
operator|->
name|kind
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ldef
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"#define Long int\n#define Intcast (int)(long)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dalign
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"#define Double_Align\n"
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|==
literal|8
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"#define X64_bit_pointers\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LONG_LONG
if|if
condition|(
expr|sizeof
operator|(
name|long
name|long
operator|)
operator|<
literal|8
condition|)
endif|#
directive|endif
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"#define NO_LONG_LONG\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|kind
operator|<=
literal|2
operator|&&
name|fzcheck
argument_list|()
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"#define Sudden_Underflow\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"/* Unknown arithmetic */\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

