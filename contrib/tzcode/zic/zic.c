begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** This file is in the public domain, so clarified as of ** 2006-07-17 by Arthur David Olson. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|elsieid
index|[]
init|=
literal|"@(#)zic.c	8.22"
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"private.h"
end_include

begin_include
include|#
directive|include
file|"tzfile.h"
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/* for umask manifest constants */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_define
define|#
directive|define
name|ZIC_VERSION
value|'2'
end_define

begin_typedef
typedef|typedef
name|int_fast64_t
name|zic_t
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|ZIC_MAX_ABBR_LEN_WO_WARN
end_ifndef

begin_define
define|#
directive|define
name|ZIC_MAX_ABBR_LEN_WO_WARN
value|6
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined ZIC_MAX_ABBR_LEN_WO_WARN */
end_comment

begin_define
define|#
directive|define
name|MKDIR_UMASK
value|(S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)
end_define

begin_comment
comment|/* ** On some ancient hosts, predicates like `isspace(C)' are defined ** only if isascii(C) || C == EOF. Modern hosts obey the C Standard, ** which says they are defined only if C == ((unsigned char) C) || C == EOF. ** Neither the C Standard nor POSIX require that `isascii' exist. ** For portability, we check both ancient and modern requirements. ** If isascii is not defined, the isascii check succeeds trivially. */
end_comment

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|isascii
end_ifndef

begin_define
define|#
directive|define
name|isascii
parameter_list|(
name|x
parameter_list|)
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|OFFSET_STRLEN_MAXIMUM
value|(7 + INT_STRLEN_MAXIMUM(long))
end_define

begin_define
define|#
directive|define
name|RULE_STRLEN_MAXIMUM
value|8
end_define

begin_comment
comment|/* "Mdd.dd.d" */
end_comment

begin_define
define|#
directive|define
name|end
parameter_list|(
name|cp
parameter_list|)
value|(strchr((cp), '\0'))
end_define

begin_struct
struct|struct
name|rule
block|{
specifier|const
name|char
modifier|*
name|r_filename
decl_stmt|;
name|int
name|r_linenum
decl_stmt|;
specifier|const
name|char
modifier|*
name|r_name
decl_stmt|;
name|int
name|r_loyear
decl_stmt|;
comment|/* for example, 1986 */
name|int
name|r_hiyear
decl_stmt|;
comment|/* for example, 1986 */
specifier|const
name|char
modifier|*
name|r_yrtype
decl_stmt|;
name|int
name|r_lowasnum
decl_stmt|;
name|int
name|r_hiwasnum
decl_stmt|;
name|int
name|r_month
decl_stmt|;
comment|/* 0..11 */
name|int
name|r_dycode
decl_stmt|;
comment|/* see below */
name|int
name|r_dayofmonth
decl_stmt|;
name|int
name|r_wday
decl_stmt|;
name|long
name|r_tod
decl_stmt|;
comment|/* time from midnight */
name|int
name|r_todisstd
decl_stmt|;
comment|/* above is standard time if TRUE */
comment|/* or wall clock time if FALSE */
name|int
name|r_todisgmt
decl_stmt|;
comment|/* above is GMT if TRUE */
comment|/* or local time if FALSE */
name|long
name|r_stdoff
decl_stmt|;
comment|/* offset from standard time */
specifier|const
name|char
modifier|*
name|r_abbrvar
decl_stmt|;
comment|/* variable part of abbreviation */
name|int
name|r_todo
decl_stmt|;
comment|/* a rule to do (used in outzone) */
name|zic_t
name|r_temp
decl_stmt|;
comment|/* used in outzone */
block|}
struct|;
end_struct

begin_comment
comment|/* **	r_dycode		r_dayofmonth	r_wday */
end_comment

begin_define
define|#
directive|define
name|DC_DOM
value|0
end_define

begin_comment
comment|/* 1..31 */
end_comment

begin_comment
comment|/* unused */
end_comment

begin_define
define|#
directive|define
name|DC_DOWGEQ
value|1
end_define

begin_comment
comment|/* 1..31 */
end_comment

begin_comment
comment|/* 0..6 (Sun..Sat) */
end_comment

begin_define
define|#
directive|define
name|DC_DOWLEQ
value|2
end_define

begin_comment
comment|/* 1..31 */
end_comment

begin_comment
comment|/* 0..6 (Sun..Sat) */
end_comment

begin_struct
struct|struct
name|zone
block|{
specifier|const
name|char
modifier|*
name|z_filename
decl_stmt|;
name|int
name|z_linenum
decl_stmt|;
specifier|const
name|char
modifier|*
name|z_name
decl_stmt|;
name|long
name|z_gmtoff
decl_stmt|;
specifier|const
name|char
modifier|*
name|z_rule
decl_stmt|;
specifier|const
name|char
modifier|*
name|z_format
decl_stmt|;
name|long
name|z_stdoff
decl_stmt|;
name|struct
name|rule
modifier|*
name|z_rules
decl_stmt|;
name|int
name|z_nrules
decl_stmt|;
name|struct
name|rule
name|z_untilrule
decl_stmt|;
name|zic_t
name|z_untiltime
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|addtt
parameter_list|(
name|zic_t
name|starttime
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|addtype
parameter_list|(
name|long
name|gmtoff
parameter_list|,
specifier|const
name|char
modifier|*
name|abbr
parameter_list|,
name|int
name|isdst
parameter_list|,
name|int
name|ttisstd
parameter_list|,
name|int
name|ttisgmt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|leapadd
parameter_list|(
name|zic_t
name|t
parameter_list|,
name|int
name|positive
parameter_list|,
name|int
name|rolling
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adjleap
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|associate
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ciequal
parameter_list|(
specifier|const
name|char
modifier|*
name|ap
parameter_list|,
specifier|const
name|char
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|convert
parameter_list|(
name|long
name|val
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|convert64
parameter_list|(
name|zic_t
name|val
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dolink
parameter_list|(
specifier|const
name|char
modifier|*
name|fromfield
parameter_list|,
specifier|const
name|char
modifier|*
name|tofield
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doabbr
parameter_list|(
name|char
modifier|*
name|abbr
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|char
modifier|*
name|letters
parameter_list|,
name|int
name|isdst
parameter_list|,
name|int
name|doquotes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eat
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eats
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|num
parameter_list|,
specifier|const
name|char
modifier|*
name|rname
parameter_list|,
name|int
name|rnum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|eitol
parameter_list|(
name|int
name|i
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
modifier|*
name|getfields
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|gethms
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
specifier|const
name|char
modifier|*
name|errstrng
parameter_list|,
name|int
name|signable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|infile
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|inleap
parameter_list|(
name|char
modifier|*
modifier|*
name|fields
parameter_list|,
name|int
name|nfields
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|inlink
parameter_list|(
name|char
modifier|*
modifier|*
name|fields
parameter_list|,
name|int
name|nfields
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|inrule
parameter_list|(
name|char
modifier|*
modifier|*
name|fields
parameter_list|,
name|int
name|nfields
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|inzcont
parameter_list|(
name|char
modifier|*
modifier|*
name|fields
parameter_list|,
name|int
name|nfields
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|inzone
parameter_list|(
name|char
modifier|*
modifier|*
name|fields
parameter_list|,
name|int
name|nfields
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|inzsub
parameter_list|(
name|char
modifier|*
modifier|*
name|fields
parameter_list|,
name|int
name|nfields
parameter_list|,
name|int
name|iscont
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is32
parameter_list|(
name|zic_t
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|itsabbr
parameter_list|(
specifier|const
name|char
modifier|*
name|abbr
parameter_list|,
specifier|const
name|char
modifier|*
name|word
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|itsdir
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lowerit
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|memcheck
parameter_list|(
name|char
modifier|*
name|tocheck
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mkdirs
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|newabbr
parameter_list|(
specifier|const
name|char
modifier|*
name|abbr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|oadd
parameter_list|(
name|long
name|t1
parameter_list|,
name|long
name|t2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|outzone
parameter_list|(
specifier|const
name|struct
name|zone
modifier|*
name|zp
parameter_list|,
name|int
name|ntzones
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|puttzcode
parameter_list|(
name|long
name|code
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|puttzcode64
parameter_list|(
name|zic_t
name|code
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rcomp
parameter_list|(
specifier|const
name|void
modifier|*
name|leftp
parameter_list|,
specifier|const
name|void
modifier|*
name|rightp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|zic_t
name|rpytime
parameter_list|(
specifier|const
name|struct
name|rule
modifier|*
name|rp
parameter_list|,
name|int
name|wantedy
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rulesub
parameter_list|(
name|struct
name|rule
modifier|*
name|rp
parameter_list|,
specifier|const
name|char
modifier|*
name|loyearp
parameter_list|,
specifier|const
name|char
modifier|*
name|hiyearp
parameter_list|,
specifier|const
name|char
modifier|*
name|typep
parameter_list|,
specifier|const
name|char
modifier|*
name|monthp
parameter_list|,
specifier|const
name|char
modifier|*
name|dayp
parameter_list|,
specifier|const
name|char
modifier|*
name|timep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stringoffset
parameter_list|(
name|char
modifier|*
name|result
parameter_list|,
name|long
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stringrule
parameter_list|(
name|char
modifier|*
name|result
parameter_list|,
specifier|const
name|struct
name|rule
modifier|*
name|rp
parameter_list|,
name|long
name|dstoff
parameter_list|,
name|long
name|gmtoff
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stringzone
parameter_list|(
name|char
modifier|*
name|result
parameter_list|,
specifier|const
name|struct
name|zone
modifier|*
name|zp
parameter_list|,
name|int
name|ntzones
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setboundaries
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setgroup
parameter_list|(
name|gid_t
modifier|*
name|flag
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setuser
parameter_list|(
name|uid_t
modifier|*
name|flag
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|zic_t
name|tadd
parameter_list|(
name|zic_t
name|t1
parameter_list|,
name|long
name|t2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|writezone
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yearistype
parameter_list|(
name|int
name|year
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|charcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|errors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|leapcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|leapseen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|leapminyear
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|leapmaxyear
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|linenum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_abbrvar_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_format_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|zic_t
name|max_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_year
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|zic_t
name|min_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|min_year
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|zic_t
name|min_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noise
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|rfilename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rlinenum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|timecnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|typecnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** Line codes. */
end_comment

begin_define
define|#
directive|define
name|LC_RULE
value|0
end_define

begin_define
define|#
directive|define
name|LC_ZONE
value|1
end_define

begin_define
define|#
directive|define
name|LC_LINK
value|2
end_define

begin_define
define|#
directive|define
name|LC_LEAP
value|3
end_define

begin_comment
comment|/* ** Which fields are which on a Zone line. */
end_comment

begin_define
define|#
directive|define
name|ZF_NAME
value|1
end_define

begin_define
define|#
directive|define
name|ZF_GMTOFF
value|2
end_define

begin_define
define|#
directive|define
name|ZF_RULE
value|3
end_define

begin_define
define|#
directive|define
name|ZF_FORMAT
value|4
end_define

begin_define
define|#
directive|define
name|ZF_TILYEAR
value|5
end_define

begin_define
define|#
directive|define
name|ZF_TILMONTH
value|6
end_define

begin_define
define|#
directive|define
name|ZF_TILDAY
value|7
end_define

begin_define
define|#
directive|define
name|ZF_TILTIME
value|8
end_define

begin_define
define|#
directive|define
name|ZONE_MINFIELDS
value|5
end_define

begin_define
define|#
directive|define
name|ZONE_MAXFIELDS
value|9
end_define

begin_comment
comment|/* ** Which fields are which on a Zone continuation line. */
end_comment

begin_define
define|#
directive|define
name|ZFC_GMTOFF
value|0
end_define

begin_define
define|#
directive|define
name|ZFC_RULE
value|1
end_define

begin_define
define|#
directive|define
name|ZFC_FORMAT
value|2
end_define

begin_define
define|#
directive|define
name|ZFC_TILYEAR
value|3
end_define

begin_define
define|#
directive|define
name|ZFC_TILMONTH
value|4
end_define

begin_define
define|#
directive|define
name|ZFC_TILDAY
value|5
end_define

begin_define
define|#
directive|define
name|ZFC_TILTIME
value|6
end_define

begin_define
define|#
directive|define
name|ZONEC_MINFIELDS
value|3
end_define

begin_define
define|#
directive|define
name|ZONEC_MAXFIELDS
value|7
end_define

begin_comment
comment|/* ** Which files are which on a Rule line. */
end_comment

begin_define
define|#
directive|define
name|RF_NAME
value|1
end_define

begin_define
define|#
directive|define
name|RF_LOYEAR
value|2
end_define

begin_define
define|#
directive|define
name|RF_HIYEAR
value|3
end_define

begin_define
define|#
directive|define
name|RF_COMMAND
value|4
end_define

begin_define
define|#
directive|define
name|RF_MONTH
value|5
end_define

begin_define
define|#
directive|define
name|RF_DAY
value|6
end_define

begin_define
define|#
directive|define
name|RF_TOD
value|7
end_define

begin_define
define|#
directive|define
name|RF_STDOFF
value|8
end_define

begin_define
define|#
directive|define
name|RF_ABBRVAR
value|9
end_define

begin_define
define|#
directive|define
name|RULE_FIELDS
value|10
end_define

begin_comment
comment|/* ** Which fields are which on a Link line. */
end_comment

begin_define
define|#
directive|define
name|LF_FROM
value|1
end_define

begin_define
define|#
directive|define
name|LF_TO
value|2
end_define

begin_define
define|#
directive|define
name|LINK_FIELDS
value|3
end_define

begin_comment
comment|/* ** Which fields are which on a Leap line. */
end_comment

begin_define
define|#
directive|define
name|LP_YEAR
value|1
end_define

begin_define
define|#
directive|define
name|LP_MONTH
value|2
end_define

begin_define
define|#
directive|define
name|LP_DAY
value|3
end_define

begin_define
define|#
directive|define
name|LP_TIME
value|4
end_define

begin_define
define|#
directive|define
name|LP_CORR
value|5
end_define

begin_define
define|#
directive|define
name|LP_ROLL
value|6
end_define

begin_define
define|#
directive|define
name|LEAP_FIELDS
value|7
end_define

begin_comment
comment|/* ** Year synonyms. */
end_comment

begin_define
define|#
directive|define
name|YR_MINIMUM
value|0
end_define

begin_define
define|#
directive|define
name|YR_MAXIMUM
value|1
end_define

begin_define
define|#
directive|define
name|YR_ONLY
value|2
end_define

begin_decl_stmt
specifier|static
name|struct
name|rule
modifier|*
name|rules
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nrules
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of rules */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|zone
modifier|*
name|zones
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nzones
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of zones */
end_comment

begin_struct
struct|struct
name|link
block|{
specifier|const
name|char
modifier|*
name|l_filename
decl_stmt|;
name|int
name|l_linenum
decl_stmt|;
specifier|const
name|char
modifier|*
name|l_from
decl_stmt|;
specifier|const
name|char
modifier|*
name|l_to
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|link
modifier|*
name|links
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nlinks
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|lookup
block|{
specifier|const
name|char
modifier|*
name|l_word
decl_stmt|;
specifier|const
name|int
name|l_value
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|struct
name|lookup
specifier|const
modifier|*
name|byword
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
specifier|const
name|struct
name|lookup
modifier|*
name|lp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|lookup
specifier|const
name|line_codes
index|[]
init|=
block|{
block|{
literal|"Rule"
block|,
name|LC_RULE
block|}
block|,
block|{
literal|"Zone"
block|,
name|LC_ZONE
block|}
block|,
block|{
literal|"Link"
block|,
name|LC_LINK
block|}
block|,
block|{
literal|"Leap"
block|,
name|LC_LEAP
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lookup
specifier|const
name|mon_names
index|[]
init|=
block|{
block|{
literal|"January"
block|,
name|TM_JANUARY
block|}
block|,
block|{
literal|"February"
block|,
name|TM_FEBRUARY
block|}
block|,
block|{
literal|"March"
block|,
name|TM_MARCH
block|}
block|,
block|{
literal|"April"
block|,
name|TM_APRIL
block|}
block|,
block|{
literal|"May"
block|,
name|TM_MAY
block|}
block|,
block|{
literal|"June"
block|,
name|TM_JUNE
block|}
block|,
block|{
literal|"July"
block|,
name|TM_JULY
block|}
block|,
block|{
literal|"August"
block|,
name|TM_AUGUST
block|}
block|,
block|{
literal|"September"
block|,
name|TM_SEPTEMBER
block|}
block|,
block|{
literal|"October"
block|,
name|TM_OCTOBER
block|}
block|,
block|{
literal|"November"
block|,
name|TM_NOVEMBER
block|}
block|,
block|{
literal|"December"
block|,
name|TM_DECEMBER
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lookup
specifier|const
name|wday_names
index|[]
init|=
block|{
block|{
literal|"Sunday"
block|,
name|TM_SUNDAY
block|}
block|,
block|{
literal|"Monday"
block|,
name|TM_MONDAY
block|}
block|,
block|{
literal|"Tuesday"
block|,
name|TM_TUESDAY
block|}
block|,
block|{
literal|"Wednesday"
block|,
name|TM_WEDNESDAY
block|}
block|,
block|{
literal|"Thursday"
block|,
name|TM_THURSDAY
block|}
block|,
block|{
literal|"Friday"
block|,
name|TM_FRIDAY
block|}
block|,
block|{
literal|"Saturday"
block|,
name|TM_SATURDAY
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lookup
specifier|const
name|lasts
index|[]
init|=
block|{
block|{
literal|"last-Sunday"
block|,
name|TM_SUNDAY
block|}
block|,
block|{
literal|"last-Monday"
block|,
name|TM_MONDAY
block|}
block|,
block|{
literal|"last-Tuesday"
block|,
name|TM_TUESDAY
block|}
block|,
block|{
literal|"last-Wednesday"
block|,
name|TM_WEDNESDAY
block|}
block|,
block|{
literal|"last-Thursday"
block|,
name|TM_THURSDAY
block|}
block|,
block|{
literal|"last-Friday"
block|,
name|TM_FRIDAY
block|}
block|,
block|{
literal|"last-Saturday"
block|,
name|TM_SATURDAY
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lookup
specifier|const
name|begin_years
index|[]
init|=
block|{
block|{
literal|"minimum"
block|,
name|YR_MINIMUM
block|}
block|,
block|{
literal|"maximum"
block|,
name|YR_MAXIMUM
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lookup
specifier|const
name|end_years
index|[]
init|=
block|{
block|{
literal|"minimum"
block|,
name|YR_MINIMUM
block|}
block|,
block|{
literal|"maximum"
block|,
name|YR_MAXIMUM
block|}
block|,
block|{
literal|"only"
block|,
name|YR_ONLY
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lookup
specifier|const
name|leap_types
index|[]
init|=
block|{
block|{
literal|"Rolling"
block|,
name|TRUE
block|}
block|,
block|{
literal|"Stationary"
block|,
name|FALSE
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|len_months
index|[
literal|2
index|]
index|[
name|MONSPERYEAR
index|]
init|=
block|{
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
block|,
block|{
literal|31
block|,
literal|29
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|len_years
index|[
literal|2
index|]
init|=
block|{
name|DAYSPERNYEAR
block|,
name|DAYSPERLYEAR
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|attype
block|{
name|zic_t
name|at
decl_stmt|;
name|unsigned
name|char
name|type
decl_stmt|;
block|}
name|attypes
index|[
name|TZ_MAX_TIMES
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|long
name|gmtoffs
index|[
name|TZ_MAX_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|isdsts
index|[
name|TZ_MAX_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|abbrinds
index|[
name|TZ_MAX_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ttisstds
index|[
name|TZ_MAX_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ttisgmts
index|[
name|TZ_MAX_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|chars
index|[
name|TZ_MAX_CHARS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|zic_t
name|trans
index|[
name|TZ_MAX_LEAPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|corr
index|[
name|TZ_MAX_LEAPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|roll
index|[
name|TZ_MAX_LEAPS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** Memory allocation. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|memcheck
parameter_list|(
name|ptr
parameter_list|)
name|char
modifier|*
specifier|const
name|ptr
decl_stmt|;
block|{
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_define
define|#
directive|define
name|emalloc
parameter_list|(
name|size
parameter_list|)
value|memcheck(imalloc(size))
end_define

begin_define
define|#
directive|define
name|erealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
value|memcheck(irealloc((ptr), (size)))
end_define

begin_define
define|#
directive|define
name|ecpyalloc
parameter_list|(
name|ptr
parameter_list|)
value|memcheck(icpyalloc(ptr))
end_define

begin_define
define|#
directive|define
name|ecatalloc
parameter_list|(
name|oldp
parameter_list|,
name|newp
parameter_list|)
value|memcheck(icatalloc((oldp), (newp)))
end_define

begin_comment
comment|/* ** Error handling. */
end_comment

begin_function
specifier|static
name|void
name|eats
parameter_list|(
name|name
parameter_list|,
name|num
parameter_list|,
name|rname
parameter_list|,
name|rnum
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|int
name|num
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|rname
decl_stmt|;
specifier|const
name|int
name|rnum
decl_stmt|;
block|{
name|filename
operator|=
name|name
expr_stmt|;
name|linenum
operator|=
name|num
expr_stmt|;
name|rfilename
operator|=
name|rname
expr_stmt|;
name|rlinenum
operator|=
name|rnum
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eat
parameter_list|(
name|name
parameter_list|,
name|num
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|int
name|num
decl_stmt|;
block|{
name|eats
argument_list|(
name|name
argument_list|,
name|num
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|error
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|string
decl_stmt|;
block|{
comment|/* 	** Match the format of "cc" to allow sh users to 	**	zic ... 2>&1 | error -t "*" -v 	** on BSD systems. 	*/
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\"%s\", line %d: %s"
argument_list|)
argument_list|,
name|filename
argument_list|,
name|linenum
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfilename
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|" (rule from \"%s\", line %d)"
argument_list|)
argument_list|,
name|rfilename
argument_list|,
name|rlinenum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|++
name|errors
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|warning
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|ecpyalloc
argument_list|(
name|_
argument_list|(
literal|"warning: "
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ecatalloc
argument_list|(
name|cp
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|cp
argument_list|)
expr_stmt|;
operator|--
name|errors
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|status
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"usage is zic \ [ --version ] [--help] [ -v ] [ -l localtime ] [ -p posixrules ] \\\n\ \t[ -d directory ] [ -L leapseconds ] [ -y yearistype ] [ filename ... ]\n\ \n\ Report bugs to tz@elsie.nci.nih.gov.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|psxrules
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|lcltime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|directory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|leapsec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|yitcommand
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Dflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uid_t
name|uflag
init|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gid_t
name|gflag
init|=
operator|(
name|gid_t
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mode_t
name|mflag
init|=
operator|(
name|S_IRUSR
operator||
name|S_IRGRP
operator||
name|S_IROTH
operator||
name|S_IWUSR
operator|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|unix
operator|(
name|void
operator|)
name|umask
argument_list|(
name|umask
argument_list|(
name|S_IWGRP
operator||
name|S_IWOTH
argument_list|)
operator||
operator|(
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined unix */
if|#
directive|if
name|HAVE_GETTEXT
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TZ_DOMAINDIR
operator|(
name|void
operator|)
name|bindtextdomain
argument_list|(
name|TZ_DOMAIN
argument_list|,
name|TZ_DOMAINDIR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined TEXTDOMAINDIR */
operator|(
name|void
operator|)
name|textdomain
argument_list|(
name|TZ_DOMAIN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_GETTEXT */
if|if
condition|(
name|TYPE_BIT
argument_list|(
name|zic_t
argument_list|)
operator|<
literal|64
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"zic: %s\n"
argument_list|,
name|_
argument_list|(
literal|"wild compilation-time specification of zic_t"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"--version"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|errx
argument_list|(
name|EXIT_SUCCESS
argument_list|,
literal|"%s"
argument_list|,
name|elsieid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"--help"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|usage
argument_list|(
name|stdout
argument_list|,
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"Dd:g:l:m:p:L:u:vsy:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
name|usage
argument_list|(
name|stderr
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
case|case
literal|'D'
case|:
name|Dflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|directory
operator|==
name|NULL
condition|)
name|directory
operator|=
name|optarg
expr_stmt|;
else|else
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"more than one -d option specified"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|setgroup
argument_list|(
operator|&
name|gflag
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|lcltime
operator|==
name|NULL
condition|)
name|lcltime
operator|=
name|optarg
expr_stmt|;
else|else
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"more than one -l option specified"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
block|{
name|void
modifier|*
name|set
init|=
name|setmode
argument_list|(
name|optarg
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"invalid file mode"
argument_list|)
argument_list|)
expr_stmt|;
name|mflag
operator|=
name|getmode
argument_list|(
name|set
argument_list|,
name|mflag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|set
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'p'
case|:
if|if
condition|(
name|psxrules
operator|==
name|NULL
condition|)
name|psxrules
operator|=
name|optarg
expr_stmt|;
else|else
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"more than one -p option specified"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|setuser
argument_list|(
operator|&
name|uflag
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
if|if
condition|(
name|yitcommand
operator|==
name|NULL
condition|)
name|yitcommand
operator|=
name|optarg
expr_stmt|;
else|else
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"more than one -y option specified"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
if|if
condition|(
name|leapsec
operator|==
name|NULL
condition|)
name|leapsec
operator|=
name|optarg
expr_stmt|;
else|else
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"more than one -L option specified"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|noise
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"zic: -s ignored\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|optind
operator|==
name|argc
operator|-
literal|1
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"="
argument_list|)
operator|==
literal|0
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* usage message by request */
if|if
condition|(
name|directory
operator|==
name|NULL
condition|)
name|directory
operator|=
name|TZDIR
expr_stmt|;
if|if
condition|(
name|yitcommand
operator|==
name|NULL
condition|)
name|yitcommand
operator|=
literal|"yearistype"
expr_stmt|;
name|setboundaries
argument_list|()
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
operator|&&
name|leapsec
operator|!=
name|NULL
condition|)
block|{
name|infile
argument_list|(
name|leapsec
argument_list|)
expr_stmt|;
name|adjleap
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|optind
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|infile
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errors
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
name|associate
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nzones
condition|;
name|i
operator|=
name|j
control|)
block|{
comment|/* 		** Find the next non-continuation zone entry. 		*/
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|nzones
operator|&&
name|zones
index|[
name|j
index|]
operator|.
name|z_name
operator|==
name|NULL
condition|;
operator|++
name|j
control|)
continue|continue;
name|outzone
argument_list|(
operator|&
name|zones
index|[
name|i
index|]
argument_list|,
name|j
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 	** Make links. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlinks
condition|;
operator|++
name|i
control|)
block|{
name|eat
argument_list|(
name|links
index|[
name|i
index|]
operator|.
name|l_filename
argument_list|,
name|links
index|[
name|i
index|]
operator|.
name|l_linenum
argument_list|)
expr_stmt|;
name|dolink
argument_list|(
name|links
index|[
name|i
index|]
operator|.
name|l_from
argument_list|,
name|links
index|[
name|i
index|]
operator|.
name|l_to
argument_list|)
expr_stmt|;
if|if
condition|(
name|noise
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nlinks
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|links
index|[
name|i
index|]
operator|.
name|l_to
argument_list|,
name|links
index|[
name|j
index|]
operator|.
name|l_from
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"link to link"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lcltime
operator|!=
name|NULL
condition|)
block|{
name|eat
argument_list|(
literal|"command line"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dolink
argument_list|(
name|lcltime
argument_list|,
name|TZDEFAULT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|psxrules
operator|!=
name|NULL
condition|)
block|{
name|eat
argument_list|(
literal|"command line"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dolink
argument_list|(
name|psxrules
argument_list|,
name|TZDEFRULES
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|errors
operator|==
literal|0
operator|)
condition|?
name|EXIT_SUCCESS
else|:
name|EXIT_FAILURE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dolink
parameter_list|(
name|fromfield
parameter_list|,
name|tofield
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|fromfield
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|tofield
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fromname
decl_stmt|;
specifier|register
name|char
modifier|*
name|toname
decl_stmt|;
if|if
condition|(
name|fromfield
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|fromname
operator|=
name|ecpyalloc
argument_list|(
name|fromfield
argument_list|)
expr_stmt|;
else|else
block|{
name|fromname
operator|=
name|ecpyalloc
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|fromname
operator|=
name|ecatalloc
argument_list|(
name|fromname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|fromname
operator|=
name|ecatalloc
argument_list|(
name|fromname
argument_list|,
name|fromfield
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tofield
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|toname
operator|=
name|ecpyalloc
argument_list|(
name|tofield
argument_list|)
expr_stmt|;
else|else
block|{
name|toname
operator|=
name|ecpyalloc
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|toname
operator|=
name|ecatalloc
argument_list|(
name|toname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|toname
operator|=
name|ecatalloc
argument_list|(
name|toname
argument_list|,
name|tofield
argument_list|)
expr_stmt|;
block|}
comment|/* 	** We get to be careful here since 	** there's a fair chance of root running us. 	*/
if|if
condition|(
operator|!
name|itsdir
argument_list|(
name|toname
argument_list|)
condition|)
operator|(
name|void
operator|)
name|remove
argument_list|(
name|toname
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|fromname
argument_list|,
name|toname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|mkdirs
argument_list|(
name|toname
argument_list|)
operator|!=
literal|0
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
name|result
operator|=
name|link
argument_list|(
name|fromname
argument_list|,
name|toname
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_SYMLINK
if|if
condition|(
name|result
operator|!=
literal|0
operator|&&
name|access
argument_list|(
name|fromname
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|itsdir
argument_list|(
name|fromname
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|tofield
decl_stmt|;
specifier|register
name|char
modifier|*
name|symlinkcontents
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|symlinkcontents
operator|=
name|ecatalloc
argument_list|(
name|symlinkcontents
argument_list|,
literal|"../"
argument_list|)
expr_stmt|;
name|symlinkcontents
operator|=
name|ecatalloc
argument_list|(
name|symlinkcontents
argument_list|,
name|fromname
argument_list|)
expr_stmt|;
name|result
operator|=
name|symlink
argument_list|(
name|symlinkcontents
argument_list|,
name|toname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"hard link failed, symbolic link used"
argument_list|)
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|symlinkcontents
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_SYMLINK */
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"can't link from %s to %s"
argument_list|)
argument_list|,
name|fromname
argument_list|,
name|toname
argument_list|)
expr_stmt|;
block|}
block|}
name|ifree
argument_list|(
name|fromname
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|toname
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|TIME_T_BITS_IN_FILE
value|64
end_define

begin_function
specifier|static
name|void
name|setboundaries
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|min_time
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TIME_T_BITS_IN_FILE
operator|-
literal|1
condition|;
operator|++
name|i
control|)
name|min_time
operator|*=
literal|2
expr_stmt|;
name|max_time
operator|=
operator|-
operator|(
name|min_time
operator|+
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|itsdir
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|myname
decl_stmt|;
specifier|register
name|int
name|accres
decl_stmt|;
name|myname
operator|=
name|ecpyalloc
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|myname
operator|=
name|ecatalloc
argument_list|(
name|myname
argument_list|,
literal|"/."
argument_list|)
expr_stmt|;
name|accres
operator|=
name|access
argument_list|(
name|myname
argument_list|,
name|F_OK
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|myname
argument_list|)
expr_stmt|;
return|return
name|accres
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Associate sets of rules with zones. */
end_comment

begin_comment
comment|/* ** Sort by rule name. */
end_comment

begin_function
specifier|static
name|int
name|rcomp
parameter_list|(
name|cp1
parameter_list|,
name|cp2
parameter_list|)
specifier|const
name|void
modifier|*
name|cp1
decl_stmt|;
specifier|const
name|void
modifier|*
name|cp2
decl_stmt|;
block|{
return|return
name|strcmp
argument_list|(
operator|(
operator|(
specifier|const
expr|struct
name|rule
operator|*
operator|)
name|cp1
operator|)
operator|->
name|r_name
argument_list|,
operator|(
operator|(
specifier|const
expr|struct
name|rule
operator|*
operator|)
name|cp2
operator|)
operator|->
name|r_name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|associate
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|zone
modifier|*
name|zp
decl_stmt|;
specifier|register
name|struct
name|rule
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|base
decl_stmt|,
name|out
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|nrules
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|qsort
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rules
argument_list|,
operator|(
name|size_t
operator|)
name|nrules
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
expr|*
name|rules
argument_list|,
name|rcomp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrules
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|rules
index|[
name|i
index|]
operator|.
name|r_name
argument_list|,
name|rules
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|r_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|rules
index|[
name|i
index|]
operator|.
name|r_filename
argument_list|,
name|rules
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|r_filename
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|eat
argument_list|(
name|rules
index|[
name|i
index|]
operator|.
name|r_filename
argument_list|,
name|rules
index|[
name|i
index|]
operator|.
name|r_linenum
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|_
argument_list|(
literal|"same rule name in multiple files"
argument_list|)
argument_list|)
expr_stmt|;
name|eat
argument_list|(
name|rules
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|r_filename
argument_list|,
name|rules
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|r_linenum
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|_
argument_list|(
literal|"same rule name in multiple files"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|2
init|;
name|j
operator|<
name|nrules
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|rules
index|[
name|i
index|]
operator|.
name|r_name
argument_list|,
name|rules
index|[
name|j
index|]
operator|.
name|r_name
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|rules
index|[
name|i
index|]
operator|.
name|r_filename
argument_list|,
name|rules
index|[
name|j
index|]
operator|.
name|r_filename
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|rules
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|r_filename
argument_list|,
name|rules
index|[
name|j
index|]
operator|.
name|r_filename
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
break|break;
block|}
name|i
operator|=
name|j
operator|-
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nzones
condition|;
operator|++
name|i
control|)
block|{
name|zp
operator|=
operator|&
name|zones
index|[
name|i
index|]
expr_stmt|;
name|zp
operator|->
name|z_rules
operator|=
name|NULL
expr_stmt|;
name|zp
operator|->
name|z_nrules
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|base
operator|=
literal|0
init|;
name|base
operator|<
name|nrules
condition|;
name|base
operator|=
name|out
control|)
block|{
name|rp
operator|=
operator|&
name|rules
index|[
name|base
index|]
expr_stmt|;
for|for
control|(
name|out
operator|=
name|base
operator|+
literal|1
init|;
name|out
operator|<
name|nrules
condition|;
operator|++
name|out
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|rp
operator|->
name|r_name
argument_list|,
name|rules
index|[
name|out
index|]
operator|.
name|r_name
argument_list|)
operator|!=
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nzones
condition|;
operator|++
name|i
control|)
block|{
name|zp
operator|=
operator|&
name|zones
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|zp
operator|->
name|z_rule
argument_list|,
name|rp
operator|->
name|r_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|zp
operator|->
name|z_rules
operator|=
name|rp
expr_stmt|;
name|zp
operator|->
name|z_nrules
operator|=
name|out
operator|-
name|base
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nzones
condition|;
operator|++
name|i
control|)
block|{
name|zp
operator|=
operator|&
name|zones
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_nrules
operator|==
literal|0
condition|)
block|{
comment|/* 			** Maybe we have a local standard time offset. 			*/
name|eat
argument_list|(
name|zp
operator|->
name|z_filename
argument_list|,
name|zp
operator|->
name|z_linenum
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_stdoff
operator|=
name|gethms
argument_list|(
name|zp
operator|->
name|z_rule
argument_list|,
name|_
argument_list|(
literal|"unruly zone"
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 			** Note, though, that if there's no rule, 			** a '%s' in the format is a bad thing. 			*/
if|if
condition|(
name|strchr
argument_list|(
name|zp
operator|->
name|z_format
argument_list|,
literal|'%'
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"%s in ruleless zone"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errors
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|infile
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|fields
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|struct
name|lookup
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|nfields
decl_stmt|;
specifier|register
name|int
name|wantcont
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|name
operator|=
name|_
argument_list|(
literal|"standard input"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|stdin
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"can't open %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|wantcont
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|num
operator|=
literal|1
init|;
condition|;
operator|++
name|num
control|)
block|{
name|eat
argument_list|(
name|name
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
operator|!=
name|buf
condition|)
break|break;
name|cp
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"line too long"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|fields
operator|=
name|getfields
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|nfields
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fields
index|[
name|nfields
index|]
operator|!=
name|NULL
condition|)
block|{
specifier|static
name|char
name|nada
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fields
index|[
name|nfields
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|fields
index|[
name|nfields
index|]
operator|=
operator|&
name|nada
expr_stmt|;
operator|++
name|nfields
expr_stmt|;
block|}
if|if
condition|(
name|nfields
operator|==
literal|0
condition|)
block|{
comment|/* nothing to do */
block|}
elseif|else
if|if
condition|(
name|wantcont
condition|)
block|{
name|wantcont
operator|=
name|inzcont
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lp
operator|=
name|byword
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|,
name|line_codes
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"input line of unknown type"
argument_list|)
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|lp
operator|->
name|l_value
argument_list|)
condition|)
block|{
case|case
name|LC_RULE
case|:
name|inrule
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|wantcont
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|LC_ZONE
case|:
name|wantcont
operator|=
name|inzone
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
break|break;
case|case
name|LC_LINK
case|:
name|inlink
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|wantcont
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|LC_LEAP
case|:
if|if
condition|(
name|name
operator|!=
name|leapsec
condition|)
name|warnx
argument_list|(
name|_
argument_list|(
literal|"leap line in non leap seconds file %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|inleap
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|wantcont
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
comment|/* "cannot happen" */
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"panic: invalid l_value %d"
argument_list|)
argument_list|,
name|lp
operator|->
name|l_value
argument_list|)
expr_stmt|;
block|}
block|}
name|ifree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"error reading %s"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|stdin
operator|&&
name|fclose
argument_list|(
name|fp
argument_list|)
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"error closing %s"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|wantcont
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"expected continuation line not found"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Convert a string of one of the forms **	h	-h	hh:mm	-hh:mm	hh:mm:ss	-hh:mm:ss ** into a number of seconds. ** A null string maps to zero. ** Call error with errstring and return zero on errors. */
end_comment

begin_function
specifier|static
name|long
name|gethms
parameter_list|(
name|string
parameter_list|,
name|errstring
parameter_list|,
name|signable
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|errstring
decl_stmt|;
specifier|const
name|int
name|signable
decl_stmt|;
block|{
name|long
name|hh
decl_stmt|;
name|int
name|mm
decl_stmt|,
name|ss
decl_stmt|,
name|sign
decl_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
operator|||
operator|*
name|string
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|signable
condition|)
name|sign
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|string
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
operator|++
name|string
expr_stmt|;
block|}
else|else
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|string
argument_list|,
name|scheck
argument_list|(
name|string
argument_list|,
literal|"%ld"
argument_list|)
argument_list|,
operator|&
name|hh
argument_list|)
operator|==
literal|1
condition|)
name|mm
operator|=
name|ss
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|string
argument_list|,
name|scheck
argument_list|(
name|string
argument_list|,
literal|"%ld:%d"
argument_list|)
argument_list|,
operator|&
name|hh
argument_list|,
operator|&
name|mm
argument_list|)
operator|==
literal|2
condition|)
name|ss
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|string
argument_list|,
name|scheck
argument_list|(
name|string
argument_list|,
literal|"%ld:%d:%d"
argument_list|)
argument_list|,
operator|&
name|hh
argument_list|,
operator|&
name|mm
argument_list|,
operator|&
name|ss
argument_list|)
operator|!=
literal|3
condition|)
block|{
name|error
argument_list|(
name|errstring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|hh
operator|<
literal|0
operator|||
name|mm
operator|<
literal|0
operator|||
name|mm
operator|>=
name|MINSPERHOUR
operator|||
name|ss
operator|<
literal|0
operator|||
name|ss
operator|>
name|SECSPERMIN
condition|)
block|{
name|error
argument_list|(
name|errstring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|LONG_MAX
operator|/
name|SECSPERHOUR
operator|<
name|hh
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"time overflow"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|noise
operator|&&
name|hh
operator|==
name|HOURSPERDAY
operator|&&
name|mm
operator|==
literal|0
operator|&&
name|ss
operator|==
literal|0
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"24:00 not handled by pre-1998 versions of zic"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noise
operator|&&
operator|(
name|hh
operator|>
name|HOURSPERDAY
operator|||
operator|(
name|hh
operator|==
name|HOURSPERDAY
operator|&&
operator|(
name|mm
operator|!=
literal|0
operator|||
name|ss
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"values over 24 hours not handled by pre-2007 versions of zic"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|oadd
argument_list|(
name|eitol
argument_list|(
name|sign
argument_list|)
operator|*
name|hh
operator|*
name|eitol
argument_list|(
name|SECSPERHOUR
argument_list|)
argument_list|,
name|eitol
argument_list|(
name|sign
argument_list|)
operator|*
operator|(
name|eitol
argument_list|(
name|mm
argument_list|)
operator|*
name|eitol
argument_list|(
name|SECSPERMIN
argument_list|)
operator|+
name|eitol
argument_list|(
name|ss
argument_list|)
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|inrule
parameter_list|(
name|fields
parameter_list|,
name|nfields
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
specifier|const
name|fields
decl_stmt|;
specifier|const
name|int
name|nfields
decl_stmt|;
block|{
specifier|static
name|struct
name|rule
name|r
decl_stmt|;
if|if
condition|(
name|nfields
operator|!=
name|RULE_FIELDS
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"wrong number of fields on Rule line"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|fields
index|[
name|RF_NAME
index|]
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"nameless rule"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|r
operator|.
name|r_filename
operator|=
name|filename
expr_stmt|;
name|r
operator|.
name|r_linenum
operator|=
name|linenum
expr_stmt|;
name|r
operator|.
name|r_stdoff
operator|=
name|gethms
argument_list|(
name|fields
index|[
name|RF_STDOFF
index|]
argument_list|,
name|_
argument_list|(
literal|"invalid saved time"
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|rulesub
argument_list|(
operator|&
name|r
argument_list|,
name|fields
index|[
name|RF_LOYEAR
index|]
argument_list|,
name|fields
index|[
name|RF_HIYEAR
index|]
argument_list|,
name|fields
index|[
name|RF_COMMAND
index|]
argument_list|,
name|fields
index|[
name|RF_MONTH
index|]
argument_list|,
name|fields
index|[
name|RF_DAY
index|]
argument_list|,
name|fields
index|[
name|RF_TOD
index|]
argument_list|)
expr_stmt|;
name|r
operator|.
name|r_name
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|RF_NAME
index|]
argument_list|)
expr_stmt|;
name|r
operator|.
name|r_abbrvar
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|RF_ABBRVAR
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_abbrvar_len
operator|<
name|strlen
argument_list|(
name|r
operator|.
name|r_abbrvar
argument_list|)
condition|)
name|max_abbrvar_len
operator|=
name|strlen
argument_list|(
name|r
operator|.
name|r_abbrvar
argument_list|)
expr_stmt|;
name|rules
operator|=
operator|(
expr|struct
name|rule
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|erealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rules
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|nrules
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|rules
argument_list|)
argument_list|)
expr_stmt|;
name|rules
index|[
name|nrules
operator|++
index|]
operator|=
name|r
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|inzone
parameter_list|(
name|fields
parameter_list|,
name|nfields
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
specifier|const
name|fields
decl_stmt|;
specifier|const
name|int
name|nfields
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|nfields
operator|<
name|ZONE_MINFIELDS
operator|||
name|nfields
operator|>
name|ZONE_MAXFIELDS
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"wrong number of fields on Zone line"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|fields
index|[
name|ZF_NAME
index|]
argument_list|,
name|TZDEFAULT
argument_list|)
operator|==
literal|0
operator|&&
name|lcltime
operator|!=
name|NULL
condition|)
block|{
name|buf
operator|=
name|erealloc
argument_list|(
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|132
operator|+
name|strlen
argument_list|(
name|TZDEFAULT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"\"Zone %s\" line and -l option are mutually exclusive"
argument_list|)
argument_list|,
name|TZDEFAULT
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|fields
index|[
name|ZF_NAME
index|]
argument_list|,
name|TZDEFRULES
argument_list|)
operator|==
literal|0
operator|&&
name|psxrules
operator|!=
name|NULL
condition|)
block|{
name|buf
operator|=
name|erealloc
argument_list|(
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|132
operator|+
name|strlen
argument_list|(
name|TZDEFRULES
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"\"Zone %s\" line and -p option are mutually exclusive"
argument_list|)
argument_list|,
name|TZDEFRULES
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nzones
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|zones
index|[
name|i
index|]
operator|.
name|z_name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|zones
index|[
name|i
index|]
operator|.
name|z_name
argument_list|,
name|fields
index|[
name|ZF_NAME
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|buf
operator|=
name|erealloc
argument_list|(
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|132
operator|+
name|strlen
argument_list|(
name|fields
index|[
name|ZF_NAME
index|]
argument_list|)
operator|+
name|strlen
argument_list|(
name|zones
index|[
name|i
index|]
operator|.
name|z_filename
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"duplicate zone name %s (file \"%s\", line %d)"
argument_list|)
argument_list|,
name|fields
index|[
name|ZF_NAME
index|]
argument_list|,
name|zones
index|[
name|i
index|]
operator|.
name|z_filename
argument_list|,
name|zones
index|[
name|i
index|]
operator|.
name|z_linenum
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|inzsub
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|inzcont
parameter_list|(
name|fields
parameter_list|,
name|nfields
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
specifier|const
name|fields
decl_stmt|;
specifier|const
name|int
name|nfields
decl_stmt|;
block|{
if|if
condition|(
name|nfields
operator|<
name|ZONEC_MINFIELDS
operator|||
name|nfields
operator|>
name|ZONEC_MAXFIELDS
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"wrong number of fields on Zone continuation line"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|inzsub
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|inzsub
parameter_list|(
name|fields
parameter_list|,
name|nfields
parameter_list|,
name|iscont
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
specifier|const
name|fields
decl_stmt|;
specifier|const
name|int
name|nfields
decl_stmt|;
specifier|const
name|int
name|iscont
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|static
name|struct
name|zone
name|z
decl_stmt|;
specifier|register
name|int
name|i_gmtoff
decl_stmt|,
name|i_rule
decl_stmt|,
name|i_format
decl_stmt|;
specifier|register
name|int
name|i_untilyear
decl_stmt|,
name|i_untilmonth
decl_stmt|;
specifier|register
name|int
name|i_untilday
decl_stmt|,
name|i_untiltime
decl_stmt|;
specifier|register
name|int
name|hasuntil
decl_stmt|;
if|if
condition|(
name|iscont
condition|)
block|{
name|i_gmtoff
operator|=
name|ZFC_GMTOFF
expr_stmt|;
name|i_rule
operator|=
name|ZFC_RULE
expr_stmt|;
name|i_format
operator|=
name|ZFC_FORMAT
expr_stmt|;
name|i_untilyear
operator|=
name|ZFC_TILYEAR
expr_stmt|;
name|i_untilmonth
operator|=
name|ZFC_TILMONTH
expr_stmt|;
name|i_untilday
operator|=
name|ZFC_TILDAY
expr_stmt|;
name|i_untiltime
operator|=
name|ZFC_TILTIME
expr_stmt|;
name|z
operator|.
name|z_name
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|i_gmtoff
operator|=
name|ZF_GMTOFF
expr_stmt|;
name|i_rule
operator|=
name|ZF_RULE
expr_stmt|;
name|i_format
operator|=
name|ZF_FORMAT
expr_stmt|;
name|i_untilyear
operator|=
name|ZF_TILYEAR
expr_stmt|;
name|i_untilmonth
operator|=
name|ZF_TILMONTH
expr_stmt|;
name|i_untilday
operator|=
name|ZF_TILDAY
expr_stmt|;
name|i_untiltime
operator|=
name|ZF_TILTIME
expr_stmt|;
name|z
operator|.
name|z_name
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|ZF_NAME
index|]
argument_list|)
expr_stmt|;
block|}
name|z
operator|.
name|z_filename
operator|=
name|filename
expr_stmt|;
name|z
operator|.
name|z_linenum
operator|=
name|linenum
expr_stmt|;
name|z
operator|.
name|z_gmtoff
operator|=
name|gethms
argument_list|(
name|fields
index|[
name|i_gmtoff
index|]
argument_list|,
name|_
argument_list|(
literal|"invalid UTC offset"
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|fields
index|[
name|i_format
index|]
argument_list|,
literal|'%'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|cp
operator|!=
literal|'s'
operator|||
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'%'
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid abbreviation format"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|z
operator|.
name|z_rule
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|i_rule
index|]
argument_list|)
expr_stmt|;
name|z
operator|.
name|z_format
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|i_format
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_format_len
operator|<
name|strlen
argument_list|(
name|z
operator|.
name|z_format
argument_list|)
condition|)
name|max_format_len
operator|=
name|strlen
argument_list|(
name|z
operator|.
name|z_format
argument_list|)
expr_stmt|;
name|hasuntil
operator|=
name|nfields
operator|>
name|i_untilyear
expr_stmt|;
if|if
condition|(
name|hasuntil
condition|)
block|{
name|z
operator|.
name|z_untilrule
operator|.
name|r_filename
operator|=
name|filename
expr_stmt|;
name|z
operator|.
name|z_untilrule
operator|.
name|r_linenum
operator|=
name|linenum
expr_stmt|;
name|rulesub
argument_list|(
operator|&
name|z
operator|.
name|z_untilrule
argument_list|,
name|fields
index|[
name|i_untilyear
index|]
argument_list|,
literal|"only"
argument_list|,
literal|""
argument_list|,
operator|(
name|nfields
operator|>
name|i_untilmonth
operator|)
condition|?
name|fields
index|[
name|i_untilmonth
index|]
else|:
literal|"Jan"
argument_list|,
operator|(
name|nfields
operator|>
name|i_untilday
operator|)
condition|?
name|fields
index|[
name|i_untilday
index|]
else|:
literal|"1"
argument_list|,
operator|(
name|nfields
operator|>
name|i_untiltime
operator|)
condition|?
name|fields
index|[
name|i_untiltime
index|]
else|:
literal|"0"
argument_list|)
expr_stmt|;
name|z
operator|.
name|z_untiltime
operator|=
name|rpytime
argument_list|(
operator|&
name|z
operator|.
name|z_untilrule
argument_list|,
name|z
operator|.
name|z_untilrule
operator|.
name|r_loyear
argument_list|)
expr_stmt|;
if|if
condition|(
name|iscont
operator|&&
name|nzones
operator|>
literal|0
operator|&&
name|z
operator|.
name|z_untiltime
operator|>
name|min_time
operator|&&
name|z
operator|.
name|z_untiltime
operator|<
name|max_time
operator|&&
name|zones
index|[
name|nzones
operator|-
literal|1
index|]
operator|.
name|z_untiltime
operator|>
name|min_time
operator|&&
name|zones
index|[
name|nzones
operator|-
literal|1
index|]
operator|.
name|z_untiltime
operator|<
name|max_time
operator|&&
name|zones
index|[
name|nzones
operator|-
literal|1
index|]
operator|.
name|z_untiltime
operator|>=
name|z
operator|.
name|z_untiltime
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Zone continuation line end time is not after end time of previous line"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|zones
operator|=
operator|(
expr|struct
name|zone
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|erealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zones
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|nzones
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|zones
argument_list|)
argument_list|)
expr_stmt|;
name|zones
index|[
name|nzones
operator|++
index|]
operator|=
name|z
expr_stmt|;
comment|/* 	** If there was an UNTIL field on this line, 	** there's more information about the zone on the next line. 	*/
return|return
name|hasuntil
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|inleap
parameter_list|(
name|fields
parameter_list|,
name|nfields
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
specifier|const
name|fields
decl_stmt|;
specifier|const
name|int
name|nfields
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|struct
name|lookup
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|year
decl_stmt|,
name|month
decl_stmt|,
name|day
decl_stmt|;
name|long
name|dayoff
decl_stmt|,
name|tod
decl_stmt|;
name|zic_t
name|t
decl_stmt|;
if|if
condition|(
name|nfields
operator|!=
name|LEAP_FIELDS
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"wrong number of fields on Leap line"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|dayoff
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|fields
index|[
name|LP_YEAR
index|]
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|cp
argument_list|,
name|scheck
argument_list|(
name|cp
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
operator|&
name|year
argument_list|)
operator|!=
literal|1
condition|)
block|{
comment|/* 		** Leapin' Lizards! 		*/
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid leaping year"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|leapseen
operator|||
name|leapmaxyear
operator|<
name|year
condition|)
name|leapmaxyear
operator|=
name|year
expr_stmt|;
if|if
condition|(
operator|!
name|leapseen
operator|||
name|leapminyear
operator|>
name|year
condition|)
name|leapminyear
operator|=
name|year
expr_stmt|;
name|leapseen
operator|=
name|TRUE
expr_stmt|;
name|j
operator|=
name|EPOCH_YEAR
expr_stmt|;
while|while
condition|(
name|j
operator|!=
name|year
condition|)
block|{
if|if
condition|(
name|year
operator|>
name|j
condition|)
block|{
name|i
operator|=
name|len_years
index|[
name|isleap
argument_list|(
name|j
argument_list|)
index|]
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
else|else
block|{
operator|--
name|j
expr_stmt|;
name|i
operator|=
operator|-
name|len_years
index|[
name|isleap
argument_list|(
name|j
argument_list|)
index|]
expr_stmt|;
block|}
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
name|eitol
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lp
operator|=
name|byword
argument_list|(
name|fields
index|[
name|LP_MONTH
index|]
argument_list|,
name|mon_names
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid month name"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|month
operator|=
name|lp
operator|->
name|l_value
expr_stmt|;
name|j
operator|=
name|TM_JANUARY
expr_stmt|;
while|while
condition|(
name|j
operator|!=
name|month
condition|)
block|{
name|i
operator|=
name|len_months
index|[
name|isleap
argument_list|(
name|year
argument_list|)
index|]
index|[
name|j
index|]
expr_stmt|;
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
name|eitol
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
name|cp
operator|=
name|fields
index|[
name|LP_DAY
index|]
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|cp
argument_list|,
name|scheck
argument_list|(
name|cp
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
operator|&
name|day
argument_list|)
operator|!=
literal|1
operator|||
name|day
operator|<=
literal|0
operator|||
name|day
operator|>
name|len_months
index|[
name|isleap
argument_list|(
name|year
argument_list|)
index|]
index|[
name|month
index|]
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid day of month"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
name|eitol
argument_list|(
name|day
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dayoff
operator|<
literal|0
operator|&&
operator|!
name|TYPE_SIGNED
argument_list|(
name|zic_t
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"time before zero"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dayoff
operator|<
name|min_time
operator|/
name|SECSPERDAY
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"time too small"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dayoff
operator|>
name|max_time
operator|/
name|SECSPERDAY
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"time too large"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|=
operator|(
name|zic_t
operator|)
name|dayoff
operator|*
name|SECSPERDAY
expr_stmt|;
name|tod
operator|=
name|gethms
argument_list|(
name|fields
index|[
name|LP_TIME
index|]
argument_list|,
name|_
argument_list|(
literal|"invalid time of day"
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|cp
operator|=
name|fields
index|[
name|LP_CORR
index|]
expr_stmt|;
block|{
specifier|register
name|int
name|positive
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* infile() turns "-" into "" */
name|positive
operator|=
name|FALSE
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"--"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|positive
operator|=
name|FALSE
expr_stmt|;
name|count
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"+"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|positive
operator|=
name|TRUE
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"++"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|positive
operator|=
name|TRUE
expr_stmt|;
name|count
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"illegal CORRECTION field on Leap line"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|lp
operator|=
name|byword
argument_list|(
name|fields
index|[
name|LP_ROLL
index|]
argument_list|,
name|leap_types
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"illegal Rolling/Stationary field on Leap line"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|leapadd
argument_list|(
name|tadd
argument_list|(
name|t
argument_list|,
name|tod
argument_list|)
argument_list|,
name|positive
argument_list|,
name|lp
operator|->
name|l_value
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|inlink
parameter_list|(
name|fields
parameter_list|,
name|nfields
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
specifier|const
name|fields
decl_stmt|;
specifier|const
name|int
name|nfields
decl_stmt|;
block|{
name|struct
name|link
name|l
decl_stmt|;
if|if
condition|(
name|nfields
operator|!=
name|LINK_FIELDS
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"wrong number of fields on Link line"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|fields
index|[
name|LF_FROM
index|]
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"blank FROM field on Link line"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|fields
index|[
name|LF_TO
index|]
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"blank TO field on Link line"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|l
operator|.
name|l_filename
operator|=
name|filename
expr_stmt|;
name|l
operator|.
name|l_linenum
operator|=
name|linenum
expr_stmt|;
name|l
operator|.
name|l_from
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|LF_FROM
index|]
argument_list|)
expr_stmt|;
name|l
operator|.
name|l_to
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|LF_TO
index|]
argument_list|)
expr_stmt|;
name|links
operator|=
operator|(
expr|struct
name|link
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|erealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|links
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|nlinks
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|links
argument_list|)
argument_list|)
expr_stmt|;
name|links
index|[
name|nlinks
operator|++
index|]
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rulesub
parameter_list|(
name|rp
parameter_list|,
name|loyearp
parameter_list|,
name|hiyearp
parameter_list|,
name|typep
parameter_list|,
name|monthp
parameter_list|,
name|dayp
parameter_list|,
name|timep
parameter_list|)
specifier|register
name|struct
name|rule
modifier|*
specifier|const
name|rp
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|loyearp
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|hiyearp
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|typep
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|monthp
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|dayp
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|timep
decl_stmt|;
block|{
specifier|register
specifier|const
name|struct
name|lookup
modifier|*
name|lp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|byword
argument_list|(
name|monthp
argument_list|,
name|mon_names
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid month name"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|rp
operator|->
name|r_month
operator|=
name|lp
operator|->
name|l_value
expr_stmt|;
name|rp
operator|->
name|r_todisstd
operator|=
name|FALSE
expr_stmt|;
name|rp
operator|->
name|r_todisgmt
operator|=
name|FALSE
expr_stmt|;
name|dp
operator|=
name|ecpyalloc
argument_list|(
name|timep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dp
operator|!=
literal|'\0'
condition|)
block|{
name|ep
operator|=
name|dp
operator|+
name|strlen
argument_list|(
name|dp
argument_list|)
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|lowerit
argument_list|(
operator|*
name|ep
argument_list|)
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* Standard */
name|rp
operator|->
name|r_todisstd
operator|=
name|TRUE
expr_stmt|;
name|rp
operator|->
name|r_todisgmt
operator|=
name|FALSE
expr_stmt|;
operator|*
name|ep
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* Wall */
name|rp
operator|->
name|r_todisstd
operator|=
name|FALSE
expr_stmt|;
name|rp
operator|->
name|r_todisgmt
operator|=
name|FALSE
expr_stmt|;
operator|*
name|ep
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* Greenwich */
case|case
literal|'u'
case|:
comment|/* Universal */
case|case
literal|'z'
case|:
comment|/* Zulu */
name|rp
operator|->
name|r_todisstd
operator|=
name|TRUE
expr_stmt|;
name|rp
operator|->
name|r_todisgmt
operator|=
name|TRUE
expr_stmt|;
operator|*
name|ep
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
name|rp
operator|->
name|r_tod
operator|=
name|gethms
argument_list|(
name|dp
argument_list|,
name|_
argument_list|(
literal|"invalid time of day"
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/* 	** Year work. 	*/
name|cp
operator|=
name|loyearp
expr_stmt|;
name|lp
operator|=
name|byword
argument_list|(
name|cp
argument_list|,
name|begin_years
argument_list|)
expr_stmt|;
name|rp
operator|->
name|r_lowasnum
operator|=
name|lp
operator|==
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|rp
operator|->
name|r_lowasnum
condition|)
switch|switch
condition|(
operator|(
name|int
operator|)
name|lp
operator|->
name|l_value
condition|)
block|{
case|case
name|YR_MINIMUM
case|:
name|rp
operator|->
name|r_loyear
operator|=
name|INT_MIN
expr_stmt|;
break|break;
case|case
name|YR_MAXIMUM
case|:
name|rp
operator|->
name|r_loyear
operator|=
name|INT_MAX
expr_stmt|;
break|break;
default|default:
comment|/* "cannot happen" */
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"panic: invalid l_value %d"
argument_list|)
argument_list|,
name|lp
operator|->
name|l_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|cp
argument_list|,
name|scheck
argument_list|(
name|cp
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
operator|&
name|rp
operator|->
name|r_loyear
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid starting year"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp
operator|=
name|hiyearp
expr_stmt|;
name|lp
operator|=
name|byword
argument_list|(
name|cp
argument_list|,
name|end_years
argument_list|)
expr_stmt|;
name|rp
operator|->
name|r_hiwasnum
operator|=
name|lp
operator|==
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|rp
operator|->
name|r_hiwasnum
condition|)
switch|switch
condition|(
operator|(
name|int
operator|)
name|lp
operator|->
name|l_value
condition|)
block|{
case|case
name|YR_MINIMUM
case|:
name|rp
operator|->
name|r_hiyear
operator|=
name|INT_MIN
expr_stmt|;
break|break;
case|case
name|YR_MAXIMUM
case|:
name|rp
operator|->
name|r_hiyear
operator|=
name|INT_MAX
expr_stmt|;
break|break;
case|case
name|YR_ONLY
case|:
name|rp
operator|->
name|r_hiyear
operator|=
name|rp
operator|->
name|r_loyear
expr_stmt|;
break|break;
default|default:
comment|/* "cannot happen" */
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"panic: invalid l_value %d"
argument_list|)
argument_list|,
name|lp
operator|->
name|l_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|cp
argument_list|,
name|scheck
argument_list|(
name|cp
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
operator|&
name|rp
operator|->
name|r_hiyear
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid ending year"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rp
operator|->
name|r_loyear
operator|>
name|rp
operator|->
name|r_hiyear
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"starting year greater than ending year"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|typep
operator|==
literal|'\0'
condition|)
name|rp
operator|->
name|r_yrtype
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|rp
operator|->
name|r_loyear
operator|==
name|rp
operator|->
name|r_hiyear
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"typed single year"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|rp
operator|->
name|r_yrtype
operator|=
name|ecpyalloc
argument_list|(
name|typep
argument_list|)
expr_stmt|;
block|}
comment|/* 	** Day work. 	** Accept things such as: 	**	1 	**	last-Sunday 	**	Sun<=20 	**	Sun>=7 	*/
name|dp
operator|=
name|ecpyalloc
argument_list|(
name|dayp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|byword
argument_list|(
name|dp
argument_list|,
name|lasts
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rp
operator|->
name|r_dycode
operator|=
name|DC_DOWLEQ
expr_stmt|;
name|rp
operator|->
name|r_wday
operator|=
name|lp
operator|->
name|l_value
expr_stmt|;
name|rp
operator|->
name|r_dayofmonth
operator|=
name|len_months
index|[
literal|1
index|]
index|[
name|rp
operator|->
name|r_month
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ep
operator|=
name|strchr
argument_list|(
name|dp
argument_list|,
literal|'<'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|rp
operator|->
name|r_dycode
operator|=
name|DC_DOWLEQ
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ep
operator|=
name|strchr
argument_list|(
name|dp
argument_list|,
literal|'>'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|rp
operator|->
name|r_dycode
operator|=
name|DC_DOWGEQ
expr_stmt|;
else|else
block|{
name|ep
operator|=
name|dp
expr_stmt|;
name|rp
operator|->
name|r_dycode
operator|=
name|DC_DOM
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|r_dycode
operator|!=
name|DC_DOM
condition|)
block|{
operator|*
name|ep
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|++
operator|!=
literal|'='
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid day of month"
argument_list|)
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|lp
operator|=
name|byword
argument_list|(
name|dp
argument_list|,
name|wday_names
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid weekday name"
argument_list|)
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
name|rp
operator|->
name|r_wday
operator|=
name|lp
operator|->
name|l_value
expr_stmt|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
name|ep
argument_list|,
name|scheck
argument_list|(
name|ep
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
operator|&
name|rp
operator|->
name|r_dayofmonth
argument_list|)
operator|!=
literal|1
operator|||
name|rp
operator|->
name|r_dayofmonth
operator|<=
literal|0
operator|||
operator|(
name|rp
operator|->
name|r_dayofmonth
operator|>
name|len_months
index|[
literal|1
index|]
index|[
name|rp
operator|->
name|r_month
index|]
operator|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid day of month"
argument_list|)
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ifree
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|convert
parameter_list|(
name|val
parameter_list|,
name|buf
parameter_list|)
specifier|const
name|long
name|val
decl_stmt|;
name|char
modifier|*
specifier|const
name|buf
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|shift
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|shift
operator|=
literal|24
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
operator|,
name|shift
operator|-=
literal|8
control|)
name|buf
index|[
name|i
index|]
operator|=
name|val
operator|>>
name|shift
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|convert64
parameter_list|(
name|val
parameter_list|,
name|buf
parameter_list|)
specifier|const
name|zic_t
name|val
decl_stmt|;
name|char
modifier|*
specifier|const
name|buf
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|shift
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|shift
operator|=
literal|56
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
operator|,
name|shift
operator|-=
literal|8
control|)
name|buf
index|[
name|i
index|]
operator|=
name|val
operator|>>
name|shift
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|puttzcode
parameter_list|(
name|val
parameter_list|,
name|fp
parameter_list|)
specifier|const
name|long
name|val
decl_stmt|;
name|FILE
modifier|*
specifier|const
name|fp
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|convert
argument_list|(
name|val
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
name|buf
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|puttzcode64
parameter_list|(
name|val
parameter_list|,
name|fp
parameter_list|)
specifier|const
name|zic_t
name|val
decl_stmt|;
name|FILE
modifier|*
specifier|const
name|fp
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|convert64
argument_list|(
name|val
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
name|buf
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|atcomp
parameter_list|(
name|avp
parameter_list|,
name|bvp
parameter_list|)
specifier|const
name|void
modifier|*
name|avp
decl_stmt|;
specifier|const
name|void
modifier|*
name|bvp
decl_stmt|;
block|{
specifier|const
name|zic_t
name|a
init|=
operator|(
operator|(
specifier|const
expr|struct
name|attype
operator|*
operator|)
name|avp
operator|)
operator|->
name|at
decl_stmt|;
specifier|const
name|zic_t
name|b
init|=
operator|(
operator|(
specifier|const
expr|struct
name|attype
operator|*
operator|)
name|bvp
operator|)
operator|->
name|at
decl_stmt|;
return|return
operator|(
name|a
operator|<
name|b
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
name|a
operator|>
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is32
parameter_list|(
name|x
parameter_list|)
specifier|const
name|zic_t
name|x
decl_stmt|;
block|{
return|return
name|INT32_MIN
operator|<=
name|x
operator|&&
name|x
operator|<=
name|INT32_MAX
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|writezone
parameter_list|(
name|name
parameter_list|,
name|string
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|string
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|int
name|leapcnt32
decl_stmt|,
name|leapi32
decl_stmt|;
specifier|register
name|int
name|timecnt32
decl_stmt|,
name|timei32
decl_stmt|;
specifier|register
name|int
name|pass
decl_stmt|;
specifier|static
name|char
modifier|*
name|fullname
decl_stmt|;
specifier|static
specifier|const
name|struct
name|tzhead
name|tzh0
decl_stmt|;
specifier|static
name|struct
name|tzhead
name|tzh
decl_stmt|;
name|zic_t
name|ats
index|[
name|TZ_MAX_TIMES
index|]
decl_stmt|;
name|unsigned
name|char
name|types
index|[
name|TZ_MAX_TIMES
index|]
decl_stmt|;
comment|/* 	** Sort. 	*/
if|if
condition|(
name|timecnt
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|qsort
argument_list|(
operator|(
name|void
operator|*
operator|)
name|attypes
argument_list|,
operator|(
name|size_t
operator|)
name|timecnt
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
expr|*
name|attypes
argument_list|,
name|atcomp
argument_list|)
expr_stmt|;
comment|/* 	** Optimize. 	*/
block|{
name|int
name|fromi
decl_stmt|;
name|int
name|toi
decl_stmt|;
name|toi
operator|=
literal|0
expr_stmt|;
name|fromi
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fromi
operator|<
name|timecnt
operator|&&
name|attypes
index|[
name|fromi
index|]
operator|.
name|at
operator|<
name|min_time
condition|)
operator|++
name|fromi
expr_stmt|;
if|if
condition|(
name|isdsts
index|[
literal|0
index|]
operator|==
literal|0
condition|)
while|while
condition|(
name|fromi
operator|<
name|timecnt
operator|&&
name|attypes
index|[
name|fromi
index|]
operator|.
name|type
operator|==
literal|0
condition|)
operator|++
name|fromi
expr_stmt|;
comment|/* handled by default rule */
for|for
control|(
init|;
name|fromi
operator|<
name|timecnt
condition|;
operator|++
name|fromi
control|)
block|{
if|if
condition|(
name|toi
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|attypes
index|[
name|fromi
index|]
operator|.
name|at
operator|+
name|gmtoffs
index|[
name|attypes
index|[
name|toi
operator|-
literal|1
index|]
operator|.
name|type
index|]
operator|)
operator|<=
operator|(
name|attypes
index|[
name|toi
operator|-
literal|1
index|]
operator|.
name|at
operator|+
name|gmtoffs
index|[
name|toi
operator|==
literal|1
condition|?
literal|0
else|:
name|attypes
index|[
name|toi
operator|-
literal|2
index|]
operator|.
name|type
index|]
operator|)
operator|)
condition|)
block|{
name|attypes
index|[
name|toi
operator|-
literal|1
index|]
operator|.
name|type
operator|=
name|attypes
index|[
name|fromi
index|]
operator|.
name|type
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|toi
operator|==
literal|0
operator|||
name|attypes
index|[
name|toi
operator|-
literal|1
index|]
operator|.
name|type
operator|!=
name|attypes
index|[
name|fromi
index|]
operator|.
name|type
condition|)
name|attypes
index|[
name|toi
operator|++
index|]
operator|=
name|attypes
index|[
name|fromi
index|]
expr_stmt|;
block|}
name|timecnt
operator|=
name|toi
expr_stmt|;
block|}
comment|/* 	** Transfer. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timecnt
condition|;
operator|++
name|i
control|)
block|{
name|ats
index|[
name|i
index|]
operator|=
name|attypes
index|[
name|i
index|]
operator|.
name|at
expr_stmt|;
name|types
index|[
name|i
index|]
operator|=
name|attypes
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
block|}
comment|/* 	** Correct for leap seconds. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timecnt
condition|;
operator|++
name|i
control|)
block|{
name|j
operator|=
name|leapcnt
expr_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
if|if
condition|(
name|ats
index|[
name|i
index|]
operator|>
name|trans
index|[
name|j
index|]
operator|-
name|corr
index|[
name|j
index|]
condition|)
block|{
name|ats
index|[
name|i
index|]
operator|=
name|tadd
argument_list|(
name|ats
index|[
name|i
index|]
argument_list|,
name|corr
index|[
name|j
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	** Figure out 32-bit-limited starts and counts. 	*/
name|timecnt32
operator|=
name|timecnt
expr_stmt|;
name|timei32
operator|=
literal|0
expr_stmt|;
name|leapcnt32
operator|=
name|leapcnt
expr_stmt|;
name|leapi32
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|timecnt32
operator|>
literal|0
operator|&&
operator|!
name|is32
argument_list|(
name|ats
index|[
name|timecnt32
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|timecnt32
expr_stmt|;
while|while
condition|(
name|timecnt32
operator|>
literal|0
operator|&&
operator|!
name|is32
argument_list|(
name|ats
index|[
name|timei32
index|]
argument_list|)
condition|)
block|{
operator|--
name|timecnt32
expr_stmt|;
operator|++
name|timei32
expr_stmt|;
block|}
while|while
condition|(
name|leapcnt32
operator|>
literal|0
operator|&&
operator|!
name|is32
argument_list|(
name|trans
index|[
name|leapcnt32
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|leapcnt32
expr_stmt|;
while|while
condition|(
name|leapcnt32
operator|>
literal|0
operator|&&
operator|!
name|is32
argument_list|(
name|trans
index|[
name|leapi32
index|]
argument_list|)
condition|)
block|{
operator|--
name|leapcnt32
expr_stmt|;
operator|++
name|leapi32
expr_stmt|;
block|}
name|fullname
operator|=
name|erealloc
argument_list|(
name|fullname
argument_list|,
call|(
name|int
call|)
argument_list|(
name|strlen
argument_list|(
name|directory
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fullname
argument_list|,
literal|"%s/%s"
argument_list|,
name|directory
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Remove old file, if any, to snap links. 	 */
if|if
condition|(
operator|!
name|itsdir
argument_list|(
name|fullname
argument_list|)
operator|&&
name|remove
argument_list|(
name|fullname
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"can't remove %s"
argument_list|)
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fullname
argument_list|,
literal|"wb"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|mkdirs
argument_list|(
name|fullname
argument_list|)
operator|!=
literal|0
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fullname
argument_list|,
literal|"wb"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"can't create %s"
argument_list|)
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pass
operator|=
literal|1
init|;
name|pass
operator|<=
literal|2
condition|;
operator|++
name|pass
control|)
block|{
specifier|register
name|int
name|thistimei
decl_stmt|,
name|thistimecnt
decl_stmt|;
specifier|register
name|int
name|thisleapi
decl_stmt|,
name|thisleapcnt
decl_stmt|;
specifier|register
name|int
name|thistimelim
decl_stmt|,
name|thisleaplim
decl_stmt|;
name|int
name|writetype
index|[
name|TZ_MAX_TIMES
index|]
decl_stmt|;
name|int
name|typemap
index|[
name|TZ_MAX_TYPES
index|]
decl_stmt|;
specifier|register
name|int
name|thistypecnt
decl_stmt|;
name|char
name|thischars
index|[
name|TZ_MAX_CHARS
index|]
decl_stmt|;
name|char
name|thischarcnt
decl_stmt|;
name|int
name|indmap
index|[
name|TZ_MAX_CHARS
index|]
decl_stmt|;
if|if
condition|(
name|pass
operator|==
literal|1
condition|)
block|{
name|thistimei
operator|=
name|timei32
expr_stmt|;
name|thistimecnt
operator|=
name|timecnt32
expr_stmt|;
name|thisleapi
operator|=
name|leapi32
expr_stmt|;
name|thisleapcnt
operator|=
name|leapcnt32
expr_stmt|;
block|}
else|else
block|{
name|thistimei
operator|=
literal|0
expr_stmt|;
name|thistimecnt
operator|=
name|timecnt
expr_stmt|;
name|thisleapi
operator|=
literal|0
expr_stmt|;
name|thisleapcnt
operator|=
name|leapcnt
expr_stmt|;
block|}
name|thistimelim
operator|=
name|thistimei
operator|+
name|thistimecnt
expr_stmt|;
name|thisleaplim
operator|=
name|thisleapi
operator|+
name|thisleapcnt
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|typecnt
condition|;
operator|++
name|i
control|)
name|writetype
index|[
name|i
index|]
operator|=
name|thistimecnt
operator|==
name|timecnt
expr_stmt|;
if|if
condition|(
name|thistimecnt
operator|==
literal|0
condition|)
block|{
comment|/* 			** No transition times fall in the current 			** (32- or 64-bit) window. 			*/
if|if
condition|(
name|typecnt
operator|!=
literal|0
condition|)
name|writetype
index|[
name|typecnt
operator|-
literal|1
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|thistimei
operator|-
literal|1
init|;
name|i
operator|<
name|thistimelim
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|writetype
index|[
name|types
index|[
name|i
index|]
index|]
operator|=
name|TRUE
expr_stmt|;
comment|/* 			** For America/Godthab and Antarctica/Palmer 			*/
if|if
condition|(
name|thistimei
operator|==
literal|0
condition|)
name|writetype
index|[
literal|0
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|LEAVE_SOME_PRE_2011_SYSTEMS_IN_THE_LURCH
comment|/* 		** For some pre-2011 systems: if the last-to-be-written 		** standard (or daylight) type has an offset different from the 		** most recently used offset, 		** append an (unused) copy of the most recently used type 		** (to help get global "altzone" and "timezone" variables 		** set correctly). 		*/
block|{
specifier|register
name|int
name|mrudst
decl_stmt|,
name|mrustd
decl_stmt|,
name|hidst
decl_stmt|,
name|histd
decl_stmt|,
name|type
decl_stmt|;
name|hidst
operator|=
name|histd
operator|=
name|mrudst
operator|=
name|mrustd
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|thistimei
init|;
name|i
operator|<
name|thistimelim
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|isdsts
index|[
name|types
index|[
name|i
index|]
index|]
condition|)
name|mrudst
operator|=
name|types
index|[
name|i
index|]
expr_stmt|;
else|else
name|mrustd
operator|=
name|types
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|typecnt
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|writetype
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|isdsts
index|[
name|i
index|]
condition|)
name|hidst
operator|=
name|i
expr_stmt|;
else|else
name|histd
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|hidst
operator|>=
literal|0
operator|&&
name|mrudst
operator|>=
literal|0
operator|&&
name|hidst
operator|!=
name|mrudst
operator|&&
name|gmtoffs
index|[
name|hidst
index|]
operator|!=
name|gmtoffs
index|[
name|mrudst
index|]
condition|)
block|{
name|isdsts
index|[
name|mrudst
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|type
operator|=
name|addtype
argument_list|(
name|gmtoffs
index|[
name|mrudst
index|]
argument_list|,
operator|&
name|chars
index|[
name|abbrinds
index|[
name|mrudst
index|]
index|]
argument_list|,
name|TRUE
argument_list|,
name|ttisstds
index|[
name|mrudst
index|]
argument_list|,
name|ttisgmts
index|[
name|mrudst
index|]
argument_list|)
expr_stmt|;
name|isdsts
index|[
name|mrudst
index|]
operator|=
name|TRUE
expr_stmt|;
name|writetype
index|[
name|type
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|histd
operator|>=
literal|0
operator|&&
name|mrustd
operator|>=
literal|0
operator|&&
name|histd
operator|!=
name|mrustd
operator|&&
name|gmtoffs
index|[
name|histd
index|]
operator|!=
name|gmtoffs
index|[
name|mrustd
index|]
condition|)
block|{
name|isdsts
index|[
name|mrustd
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|type
operator|=
name|addtype
argument_list|(
name|gmtoffs
index|[
name|mrustd
index|]
argument_list|,
operator|&
name|chars
index|[
name|abbrinds
index|[
name|mrustd
index|]
index|]
argument_list|,
name|FALSE
argument_list|,
name|ttisstds
index|[
name|mrustd
index|]
argument_list|,
name|ttisgmts
index|[
name|mrustd
index|]
argument_list|)
expr_stmt|;
name|isdsts
index|[
name|mrustd
index|]
operator|=
name|FALSE
expr_stmt|;
name|writetype
index|[
name|type
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* !defined LEAVE_SOME_PRE_2011_SYSTEMS_IN_THE_LURCH */
name|thistypecnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|typecnt
condition|;
operator|++
name|i
control|)
name|typemap
index|[
name|i
index|]
operator|=
name|writetype
index|[
name|i
index|]
condition|?
name|thistypecnt
operator|++
else|:
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|indmap
operator|/
sizeof|sizeof
name|indmap
index|[
literal|0
index|]
condition|;
operator|++
name|i
control|)
name|indmap
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|thischarcnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|typecnt
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|char
modifier|*
name|thisabbr
decl_stmt|;
if|if
condition|(
operator|!
name|writetype
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|indmap
index|[
name|abbrinds
index|[
name|i
index|]
index|]
operator|>=
literal|0
condition|)
continue|continue;
name|thisabbr
operator|=
operator|&
name|chars
index|[
name|abbrinds
index|[
name|i
index|]
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|thischarcnt
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|thischars
index|[
name|j
index|]
argument_list|,
name|thisabbr
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|thischarcnt
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|thischars
index|[
operator|(
name|int
operator|)
name|thischarcnt
index|]
argument_list|,
name|thisabbr
argument_list|)
expr_stmt|;
name|thischarcnt
operator|+=
name|strlen
argument_list|(
name|thisabbr
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|indmap
index|[
name|abbrinds
index|[
name|i
index|]
index|]
operator|=
name|j
expr_stmt|;
block|}
define|#
directive|define
name|DO
parameter_list|(
name|field
parameter_list|)
value|(void) fwrite((void *) tzh.field, \ 				(size_t) sizeof tzh.field, (size_t) 1, fp)
name|tzh
operator|=
name|tzh0
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|tzh
operator|.
name|tzh_magic
argument_list|,
name|TZ_MAGIC
argument_list|,
sizeof|sizeof
name|tzh
operator|.
name|tzh_magic
argument_list|)
expr_stmt|;
name|tzh
operator|.
name|tzh_version
index|[
literal|0
index|]
operator|=
name|ZIC_VERSION
expr_stmt|;
name|convert
argument_list|(
name|eitol
argument_list|(
name|thistypecnt
argument_list|)
argument_list|,
name|tzh
operator|.
name|tzh_ttisgmtcnt
argument_list|)
expr_stmt|;
name|convert
argument_list|(
name|eitol
argument_list|(
name|thistypecnt
argument_list|)
argument_list|,
name|tzh
operator|.
name|tzh_ttisstdcnt
argument_list|)
expr_stmt|;
name|convert
argument_list|(
name|eitol
argument_list|(
name|thisleapcnt
argument_list|)
argument_list|,
name|tzh
operator|.
name|tzh_leapcnt
argument_list|)
expr_stmt|;
name|convert
argument_list|(
name|eitol
argument_list|(
name|thistimecnt
argument_list|)
argument_list|,
name|tzh
operator|.
name|tzh_timecnt
argument_list|)
expr_stmt|;
name|convert
argument_list|(
name|eitol
argument_list|(
name|thistypecnt
argument_list|)
argument_list|,
name|tzh
operator|.
name|tzh_typecnt
argument_list|)
expr_stmt|;
name|convert
argument_list|(
name|eitol
argument_list|(
name|thischarcnt
argument_list|)
argument_list|,
name|tzh
operator|.
name|tzh_charcnt
argument_list|)
expr_stmt|;
name|DO
argument_list|(
name|tzh_magic
argument_list|)
expr_stmt|;
name|DO
argument_list|(
name|tzh_version
argument_list|)
expr_stmt|;
name|DO
argument_list|(
name|tzh_reserved
argument_list|)
expr_stmt|;
name|DO
argument_list|(
name|tzh_ttisgmtcnt
argument_list|)
expr_stmt|;
name|DO
argument_list|(
name|tzh_ttisstdcnt
argument_list|)
expr_stmt|;
name|DO
argument_list|(
name|tzh_leapcnt
argument_list|)
expr_stmt|;
name|DO
argument_list|(
name|tzh_timecnt
argument_list|)
expr_stmt|;
name|DO
argument_list|(
name|tzh_typecnt
argument_list|)
expr_stmt|;
name|DO
argument_list|(
name|tzh_charcnt
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|DO
for|for
control|(
name|i
operator|=
name|thistimei
init|;
name|i
operator|<
name|thistimelim
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|pass
operator|==
literal|1
condition|)
name|puttzcode
argument_list|(
operator|(
name|long
operator|)
name|ats
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|puttzcode64
argument_list|(
name|ats
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|thistimei
init|;
name|i
operator|<
name|thistimelim
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|char
name|uc
decl_stmt|;
name|uc
operator|=
name|typemap
index|[
name|types
index|[
name|i
index|]
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|fwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|uc
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
name|uc
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|typecnt
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|writetype
index|[
name|i
index|]
condition|)
block|{
name|puttzcode
argument_list|(
name|gmtoffs
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|isdsts
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|indmap
index|[
name|abbrinds
index|[
name|i
index|]
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|thischarcnt
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|fwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|thischars
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
name|thischars
index|[
literal|0
index|]
argument_list|,
operator|(
name|size_t
operator|)
name|thischarcnt
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|thisleapi
init|;
name|i
operator|<
name|thisleaplim
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|zic_t
name|todo
decl_stmt|;
if|if
condition|(
name|roll
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|timecnt
operator|==
literal|0
operator|||
name|trans
index|[
name|i
index|]
operator|<
name|ats
index|[
literal|0
index|]
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdsts
index|[
name|j
index|]
condition|)
if|if
condition|(
operator|++
name|j
operator|>=
name|typecnt
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|j
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|timecnt
operator|&&
name|trans
index|[
name|i
index|]
operator|>=
name|ats
index|[
name|j
index|]
condition|)
operator|++
name|j
expr_stmt|;
name|j
operator|=
name|types
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|todo
operator|=
name|tadd
argument_list|(
name|trans
index|[
name|i
index|]
argument_list|,
operator|-
name|gmtoffs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|todo
operator|=
name|trans
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pass
operator|==
literal|1
condition|)
name|puttzcode
argument_list|(
operator|(
name|long
operator|)
name|todo
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|puttzcode64
argument_list|(
name|todo
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|puttzcode
argument_list|(
name|corr
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|typecnt
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|writetype
index|[
name|i
index|]
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
name|ttisstds
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|typecnt
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|writetype
index|[
name|i
index|]
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
name|ttisgmts
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n%s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
operator|||
name|fclose
argument_list|(
name|fp
argument_list|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"error writing %s"
argument_list|)
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|fullname
argument_list|,
name|mflag
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"cannot change mode of %s to %03o"
argument_list|)
argument_list|,
name|fullname
argument_list|,
operator|(
name|unsigned
operator|)
name|mflag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uflag
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|||
name|gflag
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|)
operator|&&
name|chown
argument_list|(
name|fullname
argument_list|,
name|uflag
argument_list|,
name|gflag
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"cannot change ownership of %s"
argument_list|)
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|doabbr
parameter_list|(
name|abbr
parameter_list|,
name|format
parameter_list|,
name|letters
parameter_list|,
name|isdst
parameter_list|,
name|doquotes
parameter_list|)
name|char
modifier|*
specifier|const
name|abbr
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|format
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|letters
decl_stmt|;
specifier|const
name|int
name|isdst
decl_stmt|;
specifier|const
name|int
name|doquotes
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|slashp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|slashp
operator|=
name|strchr
argument_list|(
name|format
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slashp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|letters
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|abbr
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|abbr
argument_list|,
name|format
argument_list|,
name|letters
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdst
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|abbr
argument_list|,
name|slashp
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|slashp
operator|>
name|format
condition|)
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|abbr
argument_list|,
name|format
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|slashp
operator|-
name|format
argument_list|)
argument_list|)
expr_stmt|;
name|abbr
index|[
name|slashp
operator|-
name|format
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|doquotes
condition|)
return|return;
for|for
control|(
name|cp
operator|=
name|abbr
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
operator|++
name|cp
control|)
if|if
condition|(
name|strchr
argument_list|(
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
argument_list|,
operator|*
name|cp
argument_list|)
operator|==
name|NULL
operator|&&
name|strchr
argument_list|(
literal|"abcdefghijklmnopqrstuvwxyz"
argument_list|,
operator|*
name|cp
argument_list|)
operator|==
name|NULL
condition|)
break|break;
name|len
operator|=
name|strlen
argument_list|(
name|abbr
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
operator|*
name|cp
operator|==
literal|'\0'
condition|)
return|return;
name|abbr
index|[
name|len
operator|+
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|abbr
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'>'
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
control|)
name|abbr
index|[
name|len
index|]
operator|=
name|abbr
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
name|abbr
index|[
literal|0
index|]
operator|=
literal|'<'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|updateminmax
parameter_list|(
name|x
parameter_list|)
specifier|const
name|int
name|x
decl_stmt|;
block|{
if|if
condition|(
name|min_year
operator|>
name|x
condition|)
name|min_year
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|max_year
operator|<
name|x
condition|)
name|max_year
operator|=
name|x
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|stringoffset
parameter_list|(
name|result
parameter_list|,
name|offset
parameter_list|)
name|char
modifier|*
name|result
decl_stmt|;
name|long
name|offset
decl_stmt|;
block|{
specifier|register
name|int
name|hours
decl_stmt|;
specifier|register
name|int
name|minutes
decl_stmt|;
specifier|register
name|int
name|seconds
decl_stmt|;
name|result
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|result
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
block|}
name|seconds
operator|=
name|offset
operator|%
name|SECSPERMIN
expr_stmt|;
name|offset
operator|/=
name|SECSPERMIN
expr_stmt|;
name|minutes
operator|=
name|offset
operator|%
name|MINSPERHOUR
expr_stmt|;
name|offset
operator|/=
name|MINSPERHOUR
expr_stmt|;
name|hours
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|hours
operator|>=
name|HOURSPERDAY
condition|)
block|{
name|result
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|end
argument_list|(
name|result
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|hours
argument_list|)
expr_stmt|;
if|if
condition|(
name|minutes
operator|!=
literal|0
operator|||
name|seconds
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|end
argument_list|(
name|result
argument_list|)
argument_list|,
literal|":%02d"
argument_list|,
name|minutes
argument_list|)
expr_stmt|;
if|if
condition|(
name|seconds
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|end
argument_list|(
name|result
argument_list|)
argument_list|,
literal|":%02d"
argument_list|,
name|seconds
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|stringrule
parameter_list|(
name|result
parameter_list|,
name|rp
parameter_list|,
name|dstoff
parameter_list|,
name|gmtoff
parameter_list|)
name|char
modifier|*
name|result
decl_stmt|;
specifier|const
name|struct
name|rule
modifier|*
specifier|const
name|rp
decl_stmt|;
specifier|const
name|long
name|dstoff
decl_stmt|;
specifier|const
name|long
name|gmtoff
decl_stmt|;
block|{
specifier|register
name|long
name|tod
decl_stmt|;
name|result
operator|=
name|end
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_dycode
operator|==
name|DC_DOM
condition|)
block|{
specifier|register
name|int
name|month
decl_stmt|,
name|total
decl_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_dayofmonth
operator|==
literal|29
operator|&&
name|rp
operator|->
name|r_month
operator|==
name|TM_FEBRUARY
condition|)
return|return
operator|-
literal|1
return|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|month
operator|=
literal|0
init|;
name|month
operator|<
name|rp
operator|->
name|r_month
condition|;
operator|++
name|month
control|)
name|total
operator|+=
name|len_months
index|[
literal|0
index|]
index|[
name|month
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"J%d"
argument_list|,
name|total
operator|+
name|rp
operator|->
name|r_dayofmonth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
name|week
decl_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_dycode
operator|==
name|DC_DOWGEQ
condition|)
block|{
name|week
operator|=
literal|1
operator|+
name|rp
operator|->
name|r_dayofmonth
operator|/
name|DAYSPERWEEK
expr_stmt|;
if|if
condition|(
operator|(
name|week
operator|-
literal|1
operator|)
operator|*
name|DAYSPERWEEK
operator|+
literal|1
operator|!=
name|rp
operator|->
name|r_dayofmonth
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|rp
operator|->
name|r_dycode
operator|==
name|DC_DOWLEQ
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|r_dayofmonth
operator|==
name|len_months
index|[
literal|1
index|]
index|[
name|rp
operator|->
name|r_month
index|]
condition|)
name|week
operator|=
literal|5
expr_stmt|;
else|else
block|{
name|week
operator|=
literal|1
operator|+
name|rp
operator|->
name|r_dayofmonth
operator|/
name|DAYSPERWEEK
expr_stmt|;
if|if
condition|(
name|week
operator|*
name|DAYSPERWEEK
operator|-
literal|1
operator|!=
name|rp
operator|->
name|r_dayofmonth
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
return|return
operator|-
literal|1
return|;
comment|/* "cannot happen" */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"M%d.%d.%d"
argument_list|,
name|rp
operator|->
name|r_month
operator|+
literal|1
argument_list|,
name|week
argument_list|,
name|rp
operator|->
name|r_wday
argument_list|)
expr_stmt|;
block|}
name|tod
operator|=
name|rp
operator|->
name|r_tod
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_todisgmt
condition|)
name|tod
operator|+=
name|gmtoff
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_todisstd
operator|&&
name|rp
operator|->
name|r_stdoff
operator|==
literal|0
condition|)
name|tod
operator|+=
name|dstoff
expr_stmt|;
if|if
condition|(
name|tod
operator|<
literal|0
condition|)
block|{
name|result
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|tod
operator|!=
literal|2
operator|*
name|SECSPERMIN
operator|*
name|MINSPERHOUR
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|result
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stringoffset
argument_list|(
name|end
argument_list|(
name|result
argument_list|)
argument_list|,
name|tod
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|stringzone
parameter_list|(
name|result
parameter_list|,
name|zpfirst
parameter_list|,
name|zonecount
parameter_list|)
name|char
modifier|*
name|result
decl_stmt|;
specifier|const
name|struct
name|zone
modifier|*
specifier|const
name|zpfirst
decl_stmt|;
specifier|const
name|int
name|zonecount
decl_stmt|;
block|{
specifier|register
specifier|const
name|struct
name|zone
modifier|*
name|zp
decl_stmt|;
specifier|register
name|struct
name|rule
modifier|*
name|rp
decl_stmt|;
specifier|register
name|struct
name|rule
modifier|*
name|stdrp
decl_stmt|;
specifier|register
name|struct
name|rule
modifier|*
name|dstrp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|abbrvar
decl_stmt|;
name|result
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|zp
operator|=
name|zpfirst
operator|+
name|zonecount
operator|-
literal|1
expr_stmt|;
name|stdrp
operator|=
name|dstrp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zp
operator|->
name|z_nrules
condition|;
operator|++
name|i
control|)
block|{
name|rp
operator|=
operator|&
name|zp
operator|->
name|z_rules
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_hiwasnum
operator|||
name|rp
operator|->
name|r_hiyear
operator|!=
name|INT_MAX
condition|)
continue|continue;
if|if
condition|(
name|rp
operator|->
name|r_yrtype
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|rp
operator|->
name|r_stdoff
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stdrp
operator|==
name|NULL
condition|)
name|stdrp
operator|=
name|rp
expr_stmt|;
else|else
return|return;
block|}
else|else
block|{
if|if
condition|(
name|dstrp
operator|==
name|NULL
condition|)
name|dstrp
operator|=
name|rp
expr_stmt|;
else|else
return|return;
block|}
block|}
if|if
condition|(
name|stdrp
operator|==
name|NULL
operator|&&
name|dstrp
operator|==
name|NULL
condition|)
block|{
comment|/* 		** There are no rules running through "max". 		** Let's find the latest rule. 		*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zp
operator|->
name|z_nrules
condition|;
operator|++
name|i
control|)
block|{
name|rp
operator|=
operator|&
name|zp
operator|->
name|z_rules
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|stdrp
operator|==
name|NULL
operator|||
name|rp
operator|->
name|r_hiyear
operator|>
name|stdrp
operator|->
name|r_hiyear
operator|||
operator|(
name|rp
operator|->
name|r_hiyear
operator|==
name|stdrp
operator|->
name|r_hiyear
operator|&&
name|rp
operator|->
name|r_month
operator|>
name|stdrp
operator|->
name|r_month
operator|)
condition|)
name|stdrp
operator|=
name|rp
expr_stmt|;
block|}
if|if
condition|(
name|stdrp
operator|!=
name|NULL
operator|&&
name|stdrp
operator|->
name|r_stdoff
operator|!=
literal|0
condition|)
return|return;
comment|/* We end up in DST (a POSIX no-no). */
comment|/* 		** Horrid special case: if year is 2037, 		** presume this is a zone handled on a year-by-year basis; 		** do not try to apply a rule to the zone. 		*/
if|if
condition|(
name|stdrp
operator|!=
name|NULL
operator|&&
name|stdrp
operator|->
name|r_hiyear
operator|==
literal|2037
condition|)
return|return;
block|}
if|if
condition|(
name|stdrp
operator|==
name|NULL
operator|&&
operator|(
name|zp
operator|->
name|z_nrules
operator|!=
literal|0
operator|||
name|zp
operator|->
name|z_stdoff
operator|!=
literal|0
operator|)
condition|)
return|return;
name|abbrvar
operator|=
operator|(
name|stdrp
operator|==
name|NULL
operator|)
condition|?
literal|""
else|:
name|stdrp
operator|->
name|r_abbrvar
expr_stmt|;
name|doabbr
argument_list|(
name|result
argument_list|,
name|zp
operator|->
name|z_format
argument_list|,
name|abbrvar
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stringoffset
argument_list|(
name|end
argument_list|(
name|result
argument_list|)
argument_list|,
operator|-
name|zp
operator|->
name|z_gmtoff
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|result
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dstrp
operator|==
name|NULL
condition|)
return|return;
name|doabbr
argument_list|(
name|end
argument_list|(
name|result
argument_list|)
argument_list|,
name|zp
operator|->
name|z_format
argument_list|,
name|dstrp
operator|->
name|r_abbrvar
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstrp
operator|->
name|r_stdoff
operator|!=
name|SECSPERMIN
operator|*
name|MINSPERHOUR
condition|)
if|if
condition|(
name|stringoffset
argument_list|(
name|end
argument_list|(
name|result
argument_list|)
argument_list|,
operator|-
operator|(
name|zp
operator|->
name|z_gmtoff
operator|+
name|dstrp
operator|->
name|r_stdoff
operator|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|result
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|result
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|stringrule
argument_list|(
name|result
argument_list|,
name|dstrp
argument_list|,
name|dstrp
operator|->
name|r_stdoff
argument_list|,
name|zp
operator|->
name|z_gmtoff
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|result
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|result
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|stringrule
argument_list|(
name|result
argument_list|,
name|stdrp
argument_list|,
name|dstrp
operator|->
name|r_stdoff
argument_list|,
name|zp
operator|->
name|z_gmtoff
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|result
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|outzone
parameter_list|(
name|zpfirst
parameter_list|,
name|zonecount
parameter_list|)
specifier|const
name|struct
name|zone
modifier|*
specifier|const
name|zpfirst
decl_stmt|;
specifier|const
name|int
name|zonecount
decl_stmt|;
block|{
specifier|register
specifier|const
name|struct
name|zone
modifier|*
name|zp
decl_stmt|;
specifier|register
name|struct
name|rule
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|int
name|usestart
decl_stmt|,
name|useuntil
decl_stmt|;
specifier|register
name|zic_t
name|starttime
decl_stmt|,
name|untiltime
decl_stmt|;
specifier|register
name|long
name|gmtoff
decl_stmt|;
specifier|register
name|long
name|stdoff
decl_stmt|;
specifier|register
name|int
name|year
decl_stmt|;
specifier|register
name|long
name|startoff
decl_stmt|;
specifier|register
name|int
name|startttisstd
decl_stmt|;
specifier|register
name|int
name|startttisgmt
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|;
specifier|register
name|char
modifier|*
name|startbuf
decl_stmt|;
specifier|register
name|char
modifier|*
name|ab
decl_stmt|;
specifier|register
name|char
modifier|*
name|envvar
decl_stmt|;
specifier|register
name|int
name|max_abbr_len
decl_stmt|;
specifier|register
name|int
name|max_envvar_len
decl_stmt|;
name|max_abbr_len
operator|=
literal|2
operator|+
name|max_format_len
operator|+
name|max_abbrvar_len
expr_stmt|;
name|max_envvar_len
operator|=
literal|2
operator|*
name|max_abbr_len
operator|+
literal|5
operator|*
literal|9
expr_stmt|;
name|startbuf
operator|=
name|emalloc
argument_list|(
name|max_abbr_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ab
operator|=
name|emalloc
argument_list|(
name|max_abbr_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|envvar
operator|=
name|emalloc
argument_list|(
name|max_envvar_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|INITIALIZE
argument_list|(
name|untiltime
argument_list|)
expr_stmt|;
name|INITIALIZE
argument_list|(
name|starttime
argument_list|)
expr_stmt|;
comment|/* 	** Now. . .finally. . .generate some useful data! 	*/
name|timecnt
operator|=
literal|0
expr_stmt|;
name|typecnt
operator|=
literal|0
expr_stmt|;
name|charcnt
operator|=
literal|0
expr_stmt|;
comment|/* 	** Thanks to Earl Chew 	** for noting the need to unconditionally initialize startttisstd. 	*/
name|startttisstd
operator|=
name|FALSE
expr_stmt|;
name|startttisgmt
operator|=
name|FALSE
expr_stmt|;
name|min_year
operator|=
name|max_year
operator|=
name|EPOCH_YEAR
expr_stmt|;
if|if
condition|(
name|leapseen
condition|)
block|{
name|updateminmax
argument_list|(
name|leapminyear
argument_list|)
expr_stmt|;
name|updateminmax
argument_list|(
name|leapmaxyear
operator|+
operator|(
name|leapmaxyear
operator|<
name|INT_MAX
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zonecount
condition|;
operator|++
name|i
control|)
block|{
name|zp
operator|=
operator|&
name|zpfirst
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|zonecount
operator|-
literal|1
condition|)
name|updateminmax
argument_list|(
name|zp
operator|->
name|z_untilrule
operator|.
name|r_loyear
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|zp
operator|->
name|z_nrules
condition|;
operator|++
name|j
control|)
block|{
name|rp
operator|=
operator|&
name|zp
operator|->
name|z_rules
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_lowasnum
condition|)
name|updateminmax
argument_list|(
name|rp
operator|->
name|r_loyear
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_hiwasnum
condition|)
name|updateminmax
argument_list|(
name|rp
operator|->
name|r_hiyear
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	** Generate lots of data if a rule can't cover all future times. 	*/
name|stringzone
argument_list|(
name|envvar
argument_list|,
name|zpfirst
argument_list|,
name|zonecount
argument_list|)
expr_stmt|;
if|if
condition|(
name|noise
operator|&&
name|envvar
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
specifier|register
name|char
modifier|*
name|wp
decl_stmt|;
name|wp
operator|=
name|ecpyalloc
argument_list|(
name|_
argument_list|(
literal|"no POSIX environment variable for zone"
argument_list|)
argument_list|)
expr_stmt|;
name|wp
operator|=
name|ecatalloc
argument_list|(
name|wp
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|wp
operator|=
name|ecatalloc
argument_list|(
name|wp
argument_list|,
name|zpfirst
operator|->
name|z_name
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|wp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|envvar
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|min_year
operator|>=
name|INT_MIN
operator|+
name|YEARSPERREPEAT
condition|)
name|min_year
operator|-=
name|YEARSPERREPEAT
expr_stmt|;
else|else
name|min_year
operator|=
name|INT_MIN
expr_stmt|;
if|if
condition|(
name|max_year
operator|<=
name|INT_MAX
operator|-
name|YEARSPERREPEAT
condition|)
name|max_year
operator|+=
name|YEARSPERREPEAT
expr_stmt|;
else|else
name|max_year
operator|=
name|INT_MAX
expr_stmt|;
block|}
comment|/* 	** For the benefit of older systems, 	** generate data from 1900 through 2037. 	*/
if|if
condition|(
name|min_year
operator|>
literal|1900
condition|)
name|min_year
operator|=
literal|1900
expr_stmt|;
if|if
condition|(
name|max_year
operator|<
literal|2037
condition|)
name|max_year
operator|=
literal|2037
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zonecount
condition|;
operator|++
name|i
control|)
block|{
comment|/* 		** A guess that may well be corrected later. 		*/
name|stdoff
operator|=
literal|0
expr_stmt|;
name|zp
operator|=
operator|&
name|zpfirst
index|[
name|i
index|]
expr_stmt|;
name|usestart
operator|=
name|i
operator|>
literal|0
operator|&&
operator|(
name|zp
operator|-
literal|1
operator|)
operator|->
name|z_untiltime
operator|>
name|min_time
expr_stmt|;
name|useuntil
operator|=
name|i
operator|<
operator|(
name|zonecount
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|useuntil
operator|&&
name|zp
operator|->
name|z_untiltime
operator|<=
name|min_time
condition|)
continue|continue;
name|gmtoff
operator|=
name|zp
operator|->
name|z_gmtoff
expr_stmt|;
name|eat
argument_list|(
name|zp
operator|->
name|z_filename
argument_list|,
name|zp
operator|->
name|z_linenum
argument_list|)
expr_stmt|;
operator|*
name|startbuf
operator|=
literal|'\0'
expr_stmt|;
name|startoff
operator|=
name|zp
operator|->
name|z_gmtoff
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_nrules
operator|==
literal|0
condition|)
block|{
name|stdoff
operator|=
name|zp
operator|->
name|z_stdoff
expr_stmt|;
name|doabbr
argument_list|(
name|startbuf
argument_list|,
name|zp
operator|->
name|z_format
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|stdoff
operator|!=
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|type
operator|=
name|addtype
argument_list|(
name|oadd
argument_list|(
name|zp
operator|->
name|z_gmtoff
argument_list|,
name|stdoff
argument_list|)
argument_list|,
name|startbuf
argument_list|,
name|stdoff
operator|!=
literal|0
argument_list|,
name|startttisstd
argument_list|,
name|startttisgmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|usestart
condition|)
block|{
name|addtt
argument_list|(
name|starttime
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|usestart
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stdoff
operator|!=
literal|0
condition|)
name|addtt
argument_list|(
name|min_time
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|year
operator|=
name|min_year
init|;
name|year
operator|<=
name|max_year
condition|;
operator|++
name|year
control|)
block|{
if|if
condition|(
name|useuntil
operator|&&
name|year
operator|>
name|zp
operator|->
name|z_untilrule
operator|.
name|r_hiyear
condition|)
break|break;
comment|/* 			** Mark which rules to do in the current year. 			** For those to do, calculate rpytime(rp, year); 			*/
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|zp
operator|->
name|z_nrules
condition|;
operator|++
name|j
control|)
block|{
name|rp
operator|=
operator|&
name|zp
operator|->
name|z_rules
index|[
name|j
index|]
expr_stmt|;
name|eats
argument_list|(
name|zp
operator|->
name|z_filename
argument_list|,
name|zp
operator|->
name|z_linenum
argument_list|,
name|rp
operator|->
name|r_filename
argument_list|,
name|rp
operator|->
name|r_linenum
argument_list|)
expr_stmt|;
name|rp
operator|->
name|r_todo
operator|=
name|year
operator|>=
name|rp
operator|->
name|r_loyear
operator|&&
name|year
operator|<=
name|rp
operator|->
name|r_hiyear
operator|&&
name|yearistype
argument_list|(
name|year
argument_list|,
name|rp
operator|->
name|r_yrtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_todo
condition|)
name|rp
operator|->
name|r_temp
operator|=
name|rpytime
argument_list|(
name|rp
argument_list|,
name|year
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|zic_t
name|jtime
decl_stmt|,
name|ktime
decl_stmt|;
specifier|register
name|long
name|offset
decl_stmt|;
name|INITIALIZE
argument_list|(
name|ktime
argument_list|)
expr_stmt|;
if|if
condition|(
name|useuntil
condition|)
block|{
comment|/* 					** Turn untiltime into UTC 					** assuming the current gmtoff and 					** stdoff values. 					*/
name|untiltime
operator|=
name|zp
operator|->
name|z_untiltime
expr_stmt|;
if|if
condition|(
operator|!
name|zp
operator|->
name|z_untilrule
operator|.
name|r_todisgmt
condition|)
name|untiltime
operator|=
name|tadd
argument_list|(
name|untiltime
argument_list|,
operator|-
name|gmtoff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zp
operator|->
name|z_untilrule
operator|.
name|r_todisstd
condition|)
name|untiltime
operator|=
name|tadd
argument_list|(
name|untiltime
argument_list|,
operator|-
name|stdoff
argument_list|)
expr_stmt|;
block|}
comment|/* 				** Find the rule (of those to do, if any) 				** that takes effect earliest in the year. 				*/
name|k
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|zp
operator|->
name|z_nrules
condition|;
operator|++
name|j
control|)
block|{
name|rp
operator|=
operator|&
name|zp
operator|->
name|z_rules
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|rp
operator|->
name|r_todo
condition|)
continue|continue;
name|eats
argument_list|(
name|zp
operator|->
name|z_filename
argument_list|,
name|zp
operator|->
name|z_linenum
argument_list|,
name|rp
operator|->
name|r_filename
argument_list|,
name|rp
operator|->
name|r_linenum
argument_list|)
expr_stmt|;
name|offset
operator|=
name|rp
operator|->
name|r_todisgmt
condition|?
literal|0
else|:
name|gmtoff
expr_stmt|;
if|if
condition|(
operator|!
name|rp
operator|->
name|r_todisstd
condition|)
name|offset
operator|=
name|oadd
argument_list|(
name|offset
argument_list|,
name|stdoff
argument_list|)
expr_stmt|;
name|jtime
operator|=
name|rp
operator|->
name|r_temp
expr_stmt|;
if|if
condition|(
name|jtime
operator|==
name|min_time
operator|||
name|jtime
operator|==
name|max_time
condition|)
continue|continue;
name|jtime
operator|=
name|tadd
argument_list|(
name|jtime
argument_list|,
operator|-
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
operator|||
name|jtime
operator|<
name|ktime
condition|)
block|{
name|k
operator|=
name|j
expr_stmt|;
name|ktime
operator|=
name|jtime
expr_stmt|;
block|}
block|}
if|if
condition|(
name|k
operator|<
literal|0
condition|)
break|break;
comment|/* go on to next year */
name|rp
operator|=
operator|&
name|zp
operator|->
name|z_rules
index|[
name|k
index|]
expr_stmt|;
name|rp
operator|->
name|r_todo
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|useuntil
operator|&&
name|ktime
operator|>=
name|untiltime
condition|)
break|break;
name|stdoff
operator|=
name|rp
operator|->
name|r_stdoff
expr_stmt|;
if|if
condition|(
name|usestart
operator|&&
name|ktime
operator|==
name|starttime
condition|)
name|usestart
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|usestart
condition|)
block|{
if|if
condition|(
name|ktime
operator|<
name|starttime
condition|)
block|{
name|startoff
operator|=
name|oadd
argument_list|(
name|zp
operator|->
name|z_gmtoff
argument_list|,
name|stdoff
argument_list|)
expr_stmt|;
name|doabbr
argument_list|(
name|startbuf
argument_list|,
name|zp
operator|->
name|z_format
argument_list|,
name|rp
operator|->
name|r_abbrvar
argument_list|,
name|rp
operator|->
name|r_stdoff
operator|!=
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|startbuf
operator|==
literal|'\0'
operator|&&
name|startoff
operator|==
name|oadd
argument_list|(
name|zp
operator|->
name|z_gmtoff
argument_list|,
name|stdoff
argument_list|)
condition|)
block|{
name|doabbr
argument_list|(
name|startbuf
argument_list|,
name|zp
operator|->
name|z_format
argument_list|,
name|rp
operator|->
name|r_abbrvar
argument_list|,
name|rp
operator|->
name|r_stdoff
operator|!=
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|eats
argument_list|(
name|zp
operator|->
name|z_filename
argument_list|,
name|zp
operator|->
name|z_linenum
argument_list|,
name|rp
operator|->
name|r_filename
argument_list|,
name|rp
operator|->
name|r_linenum
argument_list|)
expr_stmt|;
name|doabbr
argument_list|(
name|ab
argument_list|,
name|zp
operator|->
name|z_format
argument_list|,
name|rp
operator|->
name|r_abbrvar
argument_list|,
name|rp
operator|->
name|r_stdoff
operator|!=
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|offset
operator|=
name|oadd
argument_list|(
name|zp
operator|->
name|z_gmtoff
argument_list|,
name|rp
operator|->
name|r_stdoff
argument_list|)
expr_stmt|;
name|type
operator|=
name|addtype
argument_list|(
name|offset
argument_list|,
name|ab
argument_list|,
name|rp
operator|->
name|r_stdoff
operator|!=
literal|0
argument_list|,
name|rp
operator|->
name|r_todisstd
argument_list|,
name|rp
operator|->
name|r_todisgmt
argument_list|)
expr_stmt|;
name|addtt
argument_list|(
name|ktime
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|usestart
condition|)
block|{
if|if
condition|(
operator|*
name|startbuf
operator|==
literal|'\0'
operator|&&
name|zp
operator|->
name|z_format
operator|!=
name|NULL
operator|&&
name|strchr
argument_list|(
name|zp
operator|->
name|z_format
argument_list|,
literal|'%'
argument_list|)
operator|==
name|NULL
operator|&&
name|strchr
argument_list|(
name|zp
operator|->
name|z_format
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|startbuf
argument_list|,
name|zp
operator|->
name|z_format
argument_list|)
expr_stmt|;
name|eat
argument_list|(
name|zp
operator|->
name|z_filename
argument_list|,
name|zp
operator|->
name|z_linenum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|startbuf
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"can't determine time zone abbreviation to use just after until time"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addtt
argument_list|(
name|starttime
argument_list|,
name|addtype
argument_list|(
name|startoff
argument_list|,
name|startbuf
argument_list|,
name|startoff
operator|!=
name|zp
operator|->
name|z_gmtoff
argument_list|,
name|startttisstd
argument_list|,
name|startttisgmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		** Now we may get to set starttime for the next zone line. 		*/
if|if
condition|(
name|useuntil
condition|)
block|{
name|startttisstd
operator|=
name|zp
operator|->
name|z_untilrule
operator|.
name|r_todisstd
expr_stmt|;
name|startttisgmt
operator|=
name|zp
operator|->
name|z_untilrule
operator|.
name|r_todisgmt
expr_stmt|;
name|starttime
operator|=
name|zp
operator|->
name|z_untiltime
expr_stmt|;
if|if
condition|(
operator|!
name|startttisstd
condition|)
name|starttime
operator|=
name|tadd
argument_list|(
name|starttime
argument_list|,
operator|-
name|stdoff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|startttisgmt
condition|)
name|starttime
operator|=
name|tadd
argument_list|(
name|starttime
argument_list|,
operator|-
name|gmtoff
argument_list|)
expr_stmt|;
block|}
block|}
name|writezone
argument_list|(
name|zpfirst
operator|->
name|z_name
argument_list|,
name|envvar
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|startbuf
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|ab
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|envvar
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|addtt
parameter_list|(
name|starttime
parameter_list|,
name|type
parameter_list|)
specifier|const
name|zic_t
name|starttime
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
if|if
condition|(
name|starttime
operator|<=
name|min_time
operator|||
operator|(
name|timecnt
operator|==
literal|1
operator|&&
name|attypes
index|[
literal|0
index|]
operator|.
name|at
operator|<
name|min_time
operator|)
condition|)
block|{
name|gmtoffs
index|[
literal|0
index|]
operator|=
name|gmtoffs
index|[
name|type
index|]
expr_stmt|;
name|isdsts
index|[
literal|0
index|]
operator|=
name|isdsts
index|[
name|type
index|]
expr_stmt|;
name|ttisstds
index|[
literal|0
index|]
operator|=
name|ttisstds
index|[
name|type
index|]
expr_stmt|;
name|ttisgmts
index|[
literal|0
index|]
operator|=
name|ttisgmts
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|abbrinds
index|[
name|type
index|]
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|chars
argument_list|,
operator|&
name|chars
index|[
name|abbrinds
index|[
name|type
index|]
index|]
argument_list|)
expr_stmt|;
name|abbrinds
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|charcnt
operator|=
name|strlen
argument_list|(
name|chars
argument_list|)
operator|+
literal|1
expr_stmt|;
name|typecnt
operator|=
literal|1
expr_stmt|;
name|timecnt
operator|=
literal|0
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|timecnt
operator|>=
name|TZ_MAX_TIMES
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"too many transitions?!"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|attypes
index|[
name|timecnt
index|]
operator|.
name|at
operator|=
name|starttime
expr_stmt|;
name|attypes
index|[
name|timecnt
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
operator|++
name|timecnt
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|addtype
parameter_list|(
name|gmtoff
parameter_list|,
name|abbr
parameter_list|,
name|isdst
parameter_list|,
name|ttisstd
parameter_list|,
name|ttisgmt
parameter_list|)
specifier|const
name|long
name|gmtoff
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|abbr
decl_stmt|;
specifier|const
name|int
name|isdst
decl_stmt|;
specifier|const
name|int
name|ttisstd
decl_stmt|;
specifier|const
name|int
name|ttisgmt
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|isdst
operator|!=
name|TRUE
operator|&&
name|isdst
operator|!=
name|FALSE
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"internal error - addtype called with bad isdst"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ttisstd
operator|!=
name|TRUE
operator|&&
name|ttisstd
operator|!=
name|FALSE
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"internal error - addtype called with bad ttisstd"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ttisgmt
operator|!=
name|TRUE
operator|&&
name|ttisgmt
operator|!=
name|FALSE
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"internal error - addtype called with bad ttisgmt"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|/* 	** See if there's already an entry for this zone type. 	** If so, just return its index. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|typecnt
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|gmtoff
operator|==
name|gmtoffs
index|[
name|i
index|]
operator|&&
name|isdst
operator|==
name|isdsts
index|[
name|i
index|]
operator|&&
name|strcmp
argument_list|(
name|abbr
argument_list|,
operator|&
name|chars
index|[
name|abbrinds
index|[
name|i
index|]
index|]
argument_list|)
operator|==
literal|0
operator|&&
name|ttisstd
operator|==
name|ttisstds
index|[
name|i
index|]
operator|&&
name|ttisgmt
operator|==
name|ttisgmts
index|[
name|i
index|]
condition|)
return|return
name|i
return|;
block|}
comment|/* 	** There isn't one; add a new one, unless there are already too 	** many. 	*/
if|if
condition|(
name|typecnt
operator|>=
name|TZ_MAX_TYPES
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"too many local time types"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|-
literal|1L
operator|-
literal|2147483647L
operator|<=
name|gmtoff
operator|&&
name|gmtoff
operator|<=
literal|2147483647L
operator|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"UTC offset out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|gmtoffs
index|[
name|i
index|]
operator|=
name|gmtoff
expr_stmt|;
name|isdsts
index|[
name|i
index|]
operator|=
name|isdst
expr_stmt|;
name|ttisstds
index|[
name|i
index|]
operator|=
name|ttisstd
expr_stmt|;
name|ttisgmts
index|[
name|i
index|]
operator|=
name|ttisgmt
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|charcnt
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|chars
index|[
name|j
index|]
argument_list|,
name|abbr
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|charcnt
condition|)
name|newabbr
argument_list|(
name|abbr
argument_list|)
expr_stmt|;
name|abbrinds
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
operator|++
name|typecnt
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|leapadd
parameter_list|(
name|t
parameter_list|,
name|positive
parameter_list|,
name|rolling
parameter_list|,
name|count
parameter_list|)
specifier|const
name|zic_t
name|t
decl_stmt|;
specifier|const
name|int
name|positive
decl_stmt|;
specifier|const
name|int
name|rolling
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|leapcnt
operator|+
operator|(
name|positive
condition|?
name|count
else|:
literal|1
operator|)
operator|>
name|TZ_MAX_LEAPS
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"too many leap seconds"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|leapcnt
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|t
operator|<=
name|trans
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|trans
index|[
name|i
index|]
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"repeated leap second moment"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
do|do
block|{
for|for
control|(
name|j
operator|=
name|leapcnt
init|;
name|j
operator|>
name|i
condition|;
operator|--
name|j
control|)
block|{
name|trans
index|[
name|j
index|]
operator|=
name|trans
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|corr
index|[
name|j
index|]
operator|=
name|corr
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|roll
index|[
name|j
index|]
operator|=
name|roll
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|trans
index|[
name|i
index|]
operator|=
name|t
expr_stmt|;
name|corr
index|[
name|i
index|]
operator|=
name|positive
condition|?
literal|1L
else|:
name|eitol
argument_list|(
operator|-
name|count
argument_list|)
expr_stmt|;
name|roll
index|[
name|i
index|]
operator|=
name|rolling
expr_stmt|;
operator|++
name|leapcnt
expr_stmt|;
block|}
do|while
condition|(
name|positive
operator|&&
operator|--
name|count
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|adjleap
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|long
name|last
init|=
literal|0
decl_stmt|;
comment|/* 	** propagate leap seconds forward 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|leapcnt
condition|;
operator|++
name|i
control|)
block|{
name|trans
index|[
name|i
index|]
operator|=
name|tadd
argument_list|(
name|trans
index|[
name|i
index|]
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|last
operator|=
name|corr
index|[
name|i
index|]
operator|+=
name|last
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|yearistype
parameter_list|(
name|year
parameter_list|,
name|type
parameter_list|)
specifier|const
name|int
name|year
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|type
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
operator|*
name|type
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
name|buf
operator|=
name|erealloc
argument_list|(
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|132
operator|+
name|strlen
argument_list|(
name|yitcommand
argument_list|)
operator|+
name|strlen
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %d %s"
argument_list|,
name|yitcommand
argument_list|,
name|year
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
name|system
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|result
argument_list|)
condition|)
switch|switch
condition|(
name|WEXITSTATUS
argument_list|(
name|result
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
name|TRUE
return|;
case|case
literal|1
case|:
return|return
name|FALSE
return|;
block|}
name|error
argument_list|(
name|_
argument_list|(
literal|"wild result from command execution"
argument_list|)
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
name|_
argument_list|(
literal|"command was '%s', result was %d"
argument_list|)
argument_list|,
name|buf
argument_list|,
name|result
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lowerit
parameter_list|(
name|a
parameter_list|)
name|int
name|a
decl_stmt|;
block|{
name|a
operator|=
operator|(
name|unsigned
name|char
operator|)
name|a
expr_stmt|;
return|return
operator|(
name|isascii
argument_list|(
name|a
argument_list|)
operator|&&
name|isupper
argument_list|(
name|a
argument_list|)
operator|)
condition|?
name|tolower
argument_list|(
name|a
argument_list|)
else|:
name|a
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ciequal
parameter_list|(
name|ap
parameter_list|,
name|bp
parameter_list|)
comment|/* case-insensitive equality */
specifier|register
specifier|const
name|char
modifier|*
name|ap
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|bp
decl_stmt|;
block|{
while|while
condition|(
name|lowerit
argument_list|(
operator|*
name|ap
argument_list|)
operator|==
name|lowerit
argument_list|(
operator|*
name|bp
operator|++
argument_list|)
condition|)
if|if
condition|(
operator|*
name|ap
operator|++
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|itsabbr
parameter_list|(
name|abbr
parameter_list|,
name|word
parameter_list|)
specifier|register
specifier|const
name|char
modifier|*
name|abbr
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|word
decl_stmt|;
block|{
if|if
condition|(
name|lowerit
argument_list|(
operator|*
name|abbr
argument_list|)
operator|!=
name|lowerit
argument_list|(
operator|*
name|word
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|++
name|word
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|abbr
operator|!=
literal|'\0'
condition|)
do|do
block|{
if|if
condition|(
operator|*
name|word
operator|==
literal|'\0'
condition|)
return|return
name|FALSE
return|;
block|}
do|while
condition|(
name|lowerit
argument_list|(
operator|*
name|word
operator|++
argument_list|)
operator|!=
name|lowerit
argument_list|(
operator|*
name|abbr
argument_list|)
condition|)
do|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|lookup
modifier|*
name|byword
parameter_list|(
name|word
parameter_list|,
name|table
parameter_list|)
specifier|register
specifier|const
name|char
modifier|*
specifier|const
name|word
decl_stmt|;
specifier|register
specifier|const
name|struct
name|lookup
modifier|*
specifier|const
name|table
decl_stmt|;
block|{
specifier|register
specifier|const
name|struct
name|lookup
modifier|*
name|foundlp
decl_stmt|;
specifier|register
specifier|const
name|struct
name|lookup
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|word
operator|==
name|NULL
operator|||
name|table
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* 	** Look for exact match. 	*/
for|for
control|(
name|lp
operator|=
name|table
init|;
name|lp
operator|->
name|l_word
operator|!=
name|NULL
condition|;
operator|++
name|lp
control|)
if|if
condition|(
name|ciequal
argument_list|(
name|word
argument_list|,
name|lp
operator|->
name|l_word
argument_list|)
condition|)
return|return
name|lp
return|;
comment|/* 	** Look for inexact match. 	*/
name|foundlp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|table
init|;
name|lp
operator|->
name|l_word
operator|!=
name|NULL
condition|;
operator|++
name|lp
control|)
if|if
condition|(
name|itsabbr
argument_list|(
name|word
argument_list|,
name|lp
operator|->
name|l_word
argument_list|)
condition|)
block|{
if|if
condition|(
name|foundlp
operator|==
name|NULL
condition|)
name|foundlp
operator|=
name|lp
expr_stmt|;
else|else
return|return
name|NULL
return|;
comment|/* multiple inexact matches */
block|}
return|return
name|foundlp
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|getfields
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|array
decl_stmt|;
specifier|register
name|int
name|nsubs
decl_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|array
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|emalloc
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|array
argument_list|)
argument_list|)
expr_stmt|;
name|nsubs
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|isascii
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
operator|||
operator|*
name|cp
operator|==
literal|'#'
condition|)
break|break;
name|array
index|[
name|nsubs
operator|++
index|]
operator|=
name|dp
operator|=
name|cp
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
operator|*
name|dp
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|'"'
condition|)
operator|++
name|dp
expr_stmt|;
else|else
while|while
condition|(
operator|(
operator|*
name|dp
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|'"'
condition|)
if|if
condition|(
operator|*
name|dp
operator|!=
literal|'\0'
condition|)
operator|++
name|dp
expr_stmt|;
else|else
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"odd number of quotation marks"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
literal|'#'
operator|&&
operator|(
operator|!
name|isascii
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
operator|)
condition|)
do|;
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|array
index|[
name|nsubs
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|array
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|oadd
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
specifier|const
name|long
name|t1
decl_stmt|;
specifier|const
name|long
name|t2
decl_stmt|;
block|{
specifier|register
name|long
name|t
decl_stmt|;
name|t
operator|=
name|t1
operator|+
name|t2
expr_stmt|;
if|if
condition|(
operator|(
name|t2
operator|>
literal|0
operator|&&
name|t
operator|<=
name|t1
operator|)
operator|||
operator|(
name|t2
operator|<
literal|0
operator|&&
name|t
operator|>=
name|t1
operator|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"time overflow"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_function
specifier|static
name|zic_t
name|tadd
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
specifier|const
name|zic_t
name|t1
decl_stmt|;
specifier|const
name|long
name|t2
decl_stmt|;
block|{
specifier|register
name|zic_t
name|t
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|max_time
operator|&&
name|t2
operator|>
literal|0
condition|)
return|return
name|max_time
return|;
if|if
condition|(
name|t1
operator|==
name|min_time
operator|&&
name|t2
operator|<
literal|0
condition|)
return|return
name|min_time
return|;
name|t
operator|=
name|t1
operator|+
name|t2
expr_stmt|;
if|if
condition|(
operator|(
name|t2
operator|>
literal|0
operator|&&
name|t
operator|<=
name|t1
operator|)
operator|||
operator|(
name|t2
operator|<
literal|0
operator|&&
name|t
operator|>=
name|t1
operator|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"time overflow"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* ** Given a rule, and a year, compute the date - in seconds since January 1, ** 1970, 00:00 LOCAL time - in that year that the rule refers to. */
end_comment

begin_function
specifier|static
name|zic_t
name|rpytime
parameter_list|(
name|rp
parameter_list|,
name|wantedy
parameter_list|)
specifier|register
specifier|const
name|struct
name|rule
modifier|*
specifier|const
name|rp
decl_stmt|;
specifier|register
specifier|const
name|int
name|wantedy
decl_stmt|;
block|{
specifier|register
name|int
name|y
decl_stmt|,
name|m
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|long
name|dayoff
decl_stmt|;
comment|/* with a nod to Margaret O. */
specifier|register
name|zic_t
name|t
decl_stmt|;
if|if
condition|(
name|wantedy
operator|==
name|INT_MIN
condition|)
return|return
name|min_time
return|;
if|if
condition|(
name|wantedy
operator|==
name|INT_MAX
condition|)
return|return
name|max_time
return|;
name|dayoff
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|TM_JANUARY
expr_stmt|;
name|y
operator|=
name|EPOCH_YEAR
expr_stmt|;
while|while
condition|(
name|wantedy
operator|!=
name|y
condition|)
block|{
if|if
condition|(
name|wantedy
operator|>
name|y
condition|)
block|{
name|i
operator|=
name|len_years
index|[
name|isleap
argument_list|(
name|y
argument_list|)
index|]
expr_stmt|;
operator|++
name|y
expr_stmt|;
block|}
else|else
block|{
operator|--
name|y
expr_stmt|;
name|i
operator|=
operator|-
name|len_years
index|[
name|isleap
argument_list|(
name|y
argument_list|)
index|]
expr_stmt|;
block|}
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
name|eitol
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|m
operator|!=
name|rp
operator|->
name|r_month
condition|)
block|{
name|i
operator|=
name|len_months
index|[
name|isleap
argument_list|(
name|y
argument_list|)
index|]
index|[
name|m
index|]
expr_stmt|;
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
name|eitol
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|m
expr_stmt|;
block|}
name|i
operator|=
name|rp
operator|->
name|r_dayofmonth
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|TM_FEBRUARY
operator|&&
name|i
operator|==
literal|29
operator|&&
operator|!
name|isleap
argument_list|(
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|r_dycode
operator|==
name|DC_DOWLEQ
condition|)
operator|--
name|i
expr_stmt|;
else|else
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"use of 2/29 in non leap-year"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
operator|--
name|i
expr_stmt|;
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
name|eitol
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_dycode
operator|==
name|DC_DOWGEQ
operator|||
name|rp
operator|->
name|r_dycode
operator|==
name|DC_DOWLEQ
condition|)
block|{
specifier|register
name|long
name|wday
decl_stmt|;
define|#
directive|define
name|LDAYSPERWEEK
value|((long) DAYSPERWEEK)
name|wday
operator|=
name|eitol
argument_list|(
name|EPOCH_WDAY
argument_list|)
expr_stmt|;
comment|/* 		** Don't trust mod of negative numbers. 		*/
if|if
condition|(
name|dayoff
operator|>=
literal|0
condition|)
name|wday
operator|=
operator|(
name|wday
operator|+
name|dayoff
operator|)
operator|%
name|LDAYSPERWEEK
expr_stmt|;
else|else
block|{
name|wday
operator|-=
operator|(
operator|(
operator|-
name|dayoff
operator|)
operator|%
name|LDAYSPERWEEK
operator|)
expr_stmt|;
if|if
condition|(
name|wday
operator|<
literal|0
condition|)
name|wday
operator|+=
name|LDAYSPERWEEK
expr_stmt|;
block|}
while|while
condition|(
name|wday
operator|!=
name|eitol
argument_list|(
name|rp
operator|->
name|r_wday
argument_list|)
condition|)
if|if
condition|(
name|rp
operator|->
name|r_dycode
operator|==
name|DC_DOWGEQ
condition|)
block|{
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|wday
operator|>=
name|LDAYSPERWEEK
condition|)
name|wday
operator|=
literal|0
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
else|else
block|{
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|wday
operator|<
literal|0
condition|)
name|wday
operator|=
name|LDAYSPERWEEK
operator|-
literal|1
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|len_months
index|[
name|isleap
argument_list|(
name|y
argument_list|)
index|]
index|[
name|m
index|]
condition|)
block|{
if|if
condition|(
name|noise
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"rule goes past start/end of month--\ will not work with pre-2004 versions of zic"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dayoff
operator|<
name|min_time
operator|/
name|SECSPERDAY
condition|)
return|return
name|min_time
return|;
if|if
condition|(
name|dayoff
operator|>
name|max_time
operator|/
name|SECSPERDAY
condition|)
return|return
name|max_time
return|;
name|t
operator|=
operator|(
name|zic_t
operator|)
name|dayoff
operator|*
name|SECSPERDAY
expr_stmt|;
return|return
name|tadd
argument_list|(
name|t
argument_list|,
name|rp
operator|->
name|r_tod
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|newabbr
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
name|GRANDPARENTED
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|wp
decl_stmt|;
comment|/* 		** Want one to ZIC_MAX_ABBR_LEN_WO_WARN alphabetics 		** optionally followed by a + or - and a number from 1 to 14. 		*/
name|cp
operator|=
name|string
expr_stmt|;
name|wp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
operator|&&
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|-
name|string
operator|==
literal|0
condition|)
name|wp
operator|=
name|_
argument_list|(
literal|"time zone abbreviation lacks alphabetic at start"
argument_list|)
expr_stmt|;
if|if
condition|(
name|noise
operator|&&
name|cp
operator|-
name|string
operator|>
literal|3
condition|)
name|wp
operator|=
name|_
argument_list|(
literal|"time zone abbreviation has more than 3 alphabetics"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|-
name|string
operator|>
name|ZIC_MAX_ABBR_LEN_WO_WARN
condition|)
name|wp
operator|=
name|_
argument_list|(
literal|"time zone abbreviation has too many alphabetics"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|==
name|NULL
operator|&&
operator|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'-'
operator|)
condition|)
block|{
operator|++
name|cp
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|'1'
operator|&&
operator|*
name|cp
operator|>=
literal|'0'
operator|&&
operator|*
name|cp
operator|<=
literal|'4'
condition|)
operator|++
name|cp
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|wp
operator|=
name|_
argument_list|(
literal|"time zone abbreviation differs from POSIX standard"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|!=
name|NULL
condition|)
block|{
name|wp
operator|=
name|ecpyalloc
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|wp
operator|=
name|ecatalloc
argument_list|(
name|wp
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|wp
operator|=
name|ecatalloc
argument_list|(
name|wp
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|wp
operator|=
name|ecatalloc
argument_list|(
name|wp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|wp
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|charcnt
operator|+
name|i
operator|>
name|TZ_MAX_CHARS
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"too many, or too long, time zone abbreviations"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|chars
index|[
name|charcnt
index|]
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|charcnt
operator|+=
name|eitol
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mkdirs
parameter_list|(
name|argname
parameter_list|)
name|char
modifier|*
name|argname
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|argname
operator|==
name|NULL
operator|||
operator|*
name|argname
operator|==
literal|'\0'
operator|||
name|Dflag
condition|)
return|return
literal|0
return|;
name|cp
operator|=
name|name
operator|=
name|ecpyalloc
argument_list|(
name|argname
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
ifndef|#
directive|ifndef
name|unix
comment|/* 		** DOS drive specifier? 		*/
if|if
condition|(
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|name
index|[
literal|0
index|]
argument_list|)
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* !defined unix */
if|if
condition|(
operator|!
name|itsdir
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* 			** It doesn't seem to exist, so we try to create it. 			** Creation may fail because of the directory being 			** created by some other multiprocessor, so we get 			** to do extra checking. 			*/
if|if
condition|(
name|mkdir
argument_list|(
name|name
argument_list|,
name|MKDIR_UMASK
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|errno
operator|!=
name|EEXIST
operator|||
operator|!
name|itsdir
argument_list|(
name|name
argument_list|)
operator|)
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"can't create directory %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
block|}
name|ifree
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|eitol
parameter_list|(
name|i
parameter_list|)
specifier|const
name|int
name|i
decl_stmt|;
block|{
name|long
name|l
decl_stmt|;
name|l
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|&&
name|l
operator|>=
literal|0
operator|)
operator|||
operator|(
name|i
operator|==
literal|0
operator|&&
name|l
operator|!=
literal|0
operator|)
operator|||
operator|(
name|i
operator|>
literal|0
operator|&&
name|l
operator|<=
literal|0
operator|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"%d did not sign extend correctly"
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_function
specifier|static
name|void
name|setgroup
parameter_list|(
name|flag
parameter_list|,
name|name
parameter_list|)
name|gid_t
modifier|*
name|flag
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
if|if
condition|(
operator|*
name|flag
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"multiple -g flags specified"
argument_list|)
argument_list|)
expr_stmt|;
name|gr
operator|=
name|getgrnam
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|unsigned
name|long
name|ul
decl_stmt|;
name|ul
operator|=
name|strtoul
argument_list|(
name|name
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ul
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|(
name|gid_t
operator|)
name|ul
operator|&&
operator|*
name|ep
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|flag
operator|=
name|ul
expr_stmt|;
return|return;
block|}
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"group `%s' not found"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
operator|*
name|flag
operator|=
name|gr
operator|->
name|gr_gid
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setuser
parameter_list|(
name|flag
parameter_list|,
name|name
parameter_list|)
name|uid_t
modifier|*
name|flag
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
if|if
condition|(
operator|*
name|flag
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"multiple -u flags specified"
argument_list|)
argument_list|)
expr_stmt|;
name|pw
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|unsigned
name|long
name|ul
decl_stmt|;
name|ul
operator|=
name|strtoul
argument_list|(
name|name
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ul
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|(
name|gid_t
operator|)
name|ul
operator|&&
operator|*
name|ep
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|flag
operator|=
name|ul
expr_stmt|;
return|return;
block|}
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"user `%s' not found"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
operator|*
name|flag
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** UNIX was a registered trademark of The Open Group in 2003. */
end_comment

end_unit

